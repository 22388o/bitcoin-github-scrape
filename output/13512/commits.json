[
  {
    "sha": "fa1eac9cdb1a491d5947b6972b87833792a16fe3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYTFlYWM5Y2RiMWE0OTFkNTk0N2I2OTcyYjg3ODMzNzkyYTE2ZmUz",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2018-06-21T01:24:29Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2018-06-22T16:00:00Z"
      },
      "message": "[qa] mininode: Expose connection state through is_connected",
      "tree": {
        "sha": "f889edb2824334f4207f47eaf7d209903a6941ea",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f889edb2824334f4207f47eaf7d209903a6941ea"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa1eac9cdb1a491d5947b6972b87833792a16fe3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGcBAABCgAGBQJbLR0AAAoJEM4rdWl+aaVI6t8L/2hd6puYis2uf6D7xMpu1MiM\ng/23Tyv9BmR7i/L7IKZLmyIYE0p2E6NdJVn27lp6Ajb3nssxqnNjydG9Xd1pAt8r\ncYIPSY8UltJRxbGUAOrQfFx6eiy5NVWy9IOGjnPjTC6tKurgu4wIk9WyCxMP+gkh\nxwnVWq8k1dJDGZnmTeFkXxsYmSgsLxz2RNLTPoBM9RDUcSdqYfrrXabmB4BJUZBH\nzUA5+dmPgwUnxF05w1Jqrohs8N6P4VI7eAvBmxdbO5XY9MLCbO571veCeAQ3lSvo\nlFq27liHFFpyf/NFx45KpZda+6Mlqz80fxabrLLxXqN/4s4CIBa8GzDDDq+ownAb\nFNDAItjydtDYxrCuSjUTSblPT9v8LTQP0P+cRXDyIckMru3X6JFXFScEIfsyTPAM\ngwDlrNHWwQnhf+VMIiVrEFZlJra4KfgMWaM2V/tg1lre9PPDZxED10s81gLUFwEt\nNzjiTxJqWUyPNQdVKMyYbq8Z8wPdrCUERY5BA6d+YA==\n=jQLT\n-----END PGP SIGNATURE-----",
        "payload": "tree f889edb2824334f4207f47eaf7d209903a6941ea\nparent ac3224c8eea9cacba23fea3a4f22a0375485dce7\nauthor MarcoFalke <falke.marco@gmail.com> 1529544269 -0400\ncommitter MarcoFalke <falke.marco@gmail.com> 1529683200 -0400\n\n[qa] mininode: Expose connection state through is_connected\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa1eac9cdb1a491d5947b6972b87833792a16fe3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa1eac9cdb1a491d5947b6972b87833792a16fe3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa1eac9cdb1a491d5947b6972b87833792a16fe3/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ac3224c8eea9cacba23fea3a4f22a0375485dce7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ac3224c8eea9cacba23fea3a4f22a0375485dce7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ac3224c8eea9cacba23fea3a4f22a0375485dce7"
      }
    ],
    "stats": {
      "total": 98,
      "additions": 51,
      "deletions": 47
    },
    "files": [
      {
        "sha": "a925c7078355463fd1f4cecdb9bae8bbbeb9551e",
        "filename": "test/functional/feature_assumevalid.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa1eac9cdb1a491d5947b6972b87833792a16fe3/test/functional/feature_assumevalid.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa1eac9cdb1a491d5947b6972b87833792a16fe3/test/functional/feature_assumevalid.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_assumevalid.py?ref=fa1eac9cdb1a491d5947b6972b87833792a16fe3",
        "patch": "@@ -68,12 +68,12 @@ def setup_network(self):\n     def send_blocks_until_disconnected(self, p2p_conn):\n         \"\"\"Keep sending blocks to the node until we're disconnected.\"\"\"\n         for i in range(len(self.blocks)):\n-            if p2p_conn.state != \"connected\":\n+            if not p2p_conn.is_connected:\n                 break\n             try:\n                 p2p_conn.send_message(msg_block(self.blocks[i]))\n             except IOError as e:\n-                assert str(e) == 'Not connected, no pushbuf'\n+                assert not p2p_conn.is_connected\n                 break\n \n     def assert_blockchain_height(self, node, height):"
      },
      {
        "sha": "37849e92130044869f2b9e32c855e4968783b21a",
        "filename": "test/functional/p2p_compactblocks.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa1eac9cdb1a491d5947b6972b87833792a16fe3/test/functional/p2p_compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa1eac9cdb1a491d5947b6972b87833792a16fe3/test/functional/p2p_compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_compactblocks.py?ref=fa1eac9cdb1a491d5947b6972b87833792a16fe3",
        "patch": "@@ -87,7 +87,7 @@ def send_await_disconnect(self, message, timeout=30):\n         This is used when we want to send a message into the node that we expect\n         will get us disconnected, eg an invalid block.\"\"\"\n         self.send_message(message)\n-        wait_until(lambda: self.state != \"connected\", timeout=timeout, lock=mininode_lock)\n+        wait_until(lambda: not self.is_connected, timeout=timeout, lock=mininode_lock)\n \n class CompactBlocksTest(BitcoinTestFramework):\n     def set_test_params(self):"
      },
      {
        "sha": "dca5ea39de328202edf628bd07997f70dbced34f",
        "filename": "test/functional/p2p_leak.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa1eac9cdb1a491d5947b6972b87833792a16fe3/test/functional/p2p_leak.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa1eac9cdb1a491d5947b6972b87833792a16fe3/test/functional/p2p_leak.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_leak.py?ref=fa1eac9cdb1a491d5947b6972b87833792a16fe3",
        "patch": "@@ -118,11 +118,11 @@ def run_test(self):\n         time.sleep(5)\n \n         #This node should have been banned\n-        assert no_version_bannode.state != \"connected\"\n+        assert not no_version_bannode.is_connected\n \n         # These nodes should have been disconnected\n-        assert unsupported_service_bit5_node.state != \"connected\"\n-        assert unsupported_service_bit7_node.state != \"connected\"\n+        assert not unsupported_service_bit5_node.is_connected\n+        assert not unsupported_service_bit7_node.is_connected\n \n         self.nodes[0].disconnect_p2ps()\n "
      },
      {
        "sha": "e958536cf94c5964829835da69f5659b5188514c",
        "filename": "test/functional/p2p_timeouts.py",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa1eac9cdb1a491d5947b6972b87833792a16fe3/test/functional/p2p_timeouts.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa1eac9cdb1a491d5947b6972b87833792a16fe3/test/functional/p2p_timeouts.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_timeouts.py?ref=fa1eac9cdb1a491d5947b6972b87833792a16fe3",
        "patch": "@@ -47,9 +47,9 @@ def run_test(self):\n \n         sleep(1)\n \n-        assert no_verack_node.connected\n-        assert no_version_node.connected\n-        assert no_send_node.connected\n+        assert no_verack_node.is_connected\n+        assert no_version_node.is_connected\n+        assert no_send_node.is_connected\n \n         no_verack_node.send_message(msg_ping())\n         no_version_node.send_message(msg_ping())\n@@ -58,18 +58,18 @@ def run_test(self):\n \n         assert \"version\" in no_verack_node.last_message\n \n-        assert no_verack_node.connected\n-        assert no_version_node.connected\n-        assert no_send_node.connected\n+        assert no_verack_node.is_connected\n+        assert no_version_node.is_connected\n+        assert no_send_node.is_connected\n \n         no_verack_node.send_message(msg_ping())\n         no_version_node.send_message(msg_ping())\n \n         sleep(31)\n \n-        assert not no_verack_node.connected\n-        assert not no_version_node.connected\n-        assert not no_send_node.connected\n+        assert not no_verack_node.is_connected\n+        assert not no_version_node.is_connected\n+        assert not no_send_node.is_connected\n \n if __name__ == '__main__':\n     TimeoutsTest().main()"
      },
      {
        "sha": "5859f108a4e0040de5fda3c16f1608c674b1bb56",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 36,
        "deletions": 32,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa1eac9cdb1a491d5947b6972b87833792a16fe3/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa1eac9cdb1a491d5947b6972b87833792a16fe3/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=fa1eac9cdb1a491d5947b6972b87833792a16fe3",
        "patch": "@@ -77,14 +77,20 @@ def __init__(self):\n \n         super().__init__(map=mininode_socket_map)\n \n+        self._conn_open = False\n+\n+    @property\n+    def is_connected(self):\n+        return self._conn_open\n+\n     def peer_connect(self, dstaddr, dstport, net=\"regtest\"):\n         self.dstaddr = dstaddr\n         self.dstport = dstport\n         self.create_socket(socket.AF_INET, socket.SOCK_STREAM)\n         self.socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n         self.sendbuf = b\"\"\n         self.recvbuf = b\"\"\n-        self.state = \"connecting\"\n+        self._asyncore_pre_connection = True\n         self.network = net\n         self.disconnect = False\n \n@@ -97,22 +103,23 @@ def peer_connect(self, dstaddr, dstport, net=\"regtest\"):\n \n     def peer_disconnect(self):\n         # Connection could have already been closed by other end.\n-        if self.state == \"connected\":\n-            self.disconnect_node()\n+        if self.is_connected:\n+            self.disconnect = True  # Signal asyncore to disconnect\n \n     # Connection and disconnection methods\n \n     def handle_connect(self):\n         \"\"\"asyncore callback when a connection is opened.\"\"\"\n-        if self.state != \"connected\":\n+        if not self.is_connected:\n             logger.debug(\"Connected & Listening: %s:%d\" % (self.dstaddr, self.dstport))\n-            self.state = \"connected\"\n+            self._conn_open = True\n+            self._asyncore_pre_connection = False\n             self.on_open()\n \n     def handle_close(self):\n         \"\"\"asyncore callback when a connection is closed.\"\"\"\n         logger.debug(\"Closing connection to: %s:%d\" % (self.dstaddr, self.dstport))\n-        self.state = \"closed\"\n+        self._conn_open = False\n         self.recvbuf = b\"\"\n         self.sendbuf = b\"\"\n         try:\n@@ -121,13 +128,6 @@ def handle_close(self):\n             pass\n         self.on_close()\n \n-    def disconnect_node(self):\n-        \"\"\"Disconnect the p2p connection.\n-\n-        Called by the test logic thread. Causes the p2p connection\n-        to be disconnected on the next iteration of the asyncore loop.\"\"\"\n-        self.disconnect = True\n-\n     # Socket read methods\n \n     def handle_read(self):\n@@ -182,17 +182,16 @@ def on_message(self, message):\n     def writable(self):\n         \"\"\"asyncore method to determine whether the handle_write() callback should be called on the next loop.\"\"\"\n         with mininode_lock:\n-            pre_connection = self.state == \"connecting\"\n             length = len(self.sendbuf)\n-        return (length > 0 or pre_connection)\n+        return length > 0 or self._asyncore_pre_connection\n \n     def handle_write(self):\n         \"\"\"asyncore callback when data should be written to the socket.\"\"\"\n         with mininode_lock:\n             # asyncore does not expose socket connection, only the first read/write\n             # event, thus we must check connection manually here to know when we\n             # actually connect\n-            if self.state == \"connecting\":\n+            if self._asyncore_pre_connection:\n                 self.handle_connect()\n             if not self.writable():\n                 return\n@@ -204,26 +203,17 @@ def handle_write(self):\n                 return\n             self.sendbuf = self.sendbuf[sent:]\n \n-    def send_message(self, message, pushbuf=False):\n+    def send_message(self, message):\n         \"\"\"Send a P2P message over the socket.\n \n         This method takes a P2P payload, builds the P2P header and adds\n         the message to the send buffer to be sent over the socket.\"\"\"\n-        if self.state != \"connected\" and not pushbuf:\n-            raise IOError('Not connected, no pushbuf')\n+        if not self.is_connected:\n+            raise IOError('Not connected')\n         self._log_message(\"send\", message)\n-        command = message.command\n-        data = message.serialize()\n-        tmsg = MAGIC_BYTES[self.network]\n-        tmsg += command\n-        tmsg += b\"\\x00\" * (12 - len(command))\n-        tmsg += struct.pack(\"<I\", len(data))\n-        th = sha256(data)\n-        h = sha256(th)\n-        tmsg += h[:4]\n-        tmsg += data\n+        tmsg = self._build_message(message)\n         with mininode_lock:\n-            if (len(self.sendbuf) == 0 and not pushbuf):\n+            if len(self.sendbuf) == 0:\n                 try:\n                     sent = self.send(tmsg)\n                     self.sendbuf = tmsg[sent:]\n@@ -234,6 +224,20 @@ def send_message(self, message, pushbuf=False):\n \n     # Class utility methods\n \n+    def _build_message(self, message):\n+        \"\"\"Build a serialized P2P message\"\"\"\n+        command = message.command\n+        data = message.serialize()\n+        tmsg = MAGIC_BYTES[self.network]\n+        tmsg += command\n+        tmsg += b\"\\x00\" * (12 - len(command))\n+        tmsg += struct.pack(\"<I\", len(data))\n+        th = sha256(data)\n+        h = sha256(th)\n+        tmsg += h[:4]\n+        tmsg += data\n+        return tmsg\n+\n     def _log_message(self, direction, msg):\n         \"\"\"Logs a message being sent or received over the connection.\"\"\"\n         if direction == \"send\":\n@@ -280,7 +284,7 @@ def peer_connect(self, *args, services=NODE_NETWORK|NODE_WITNESS, send_version=T\n             vt.addrTo.port = self.dstport\n             vt.addrFrom.ip = \"0.0.0.0\"\n             vt.addrFrom.port = 0\n-            self.send_message(vt, True)\n+            self.sendbuf = self._build_message(vt)  # Will be sent right after handle_connect\n \n     # Message receiving methods\n \n@@ -348,7 +352,7 @@ def on_version(self, message):\n     # Connection helper methods\n \n     def wait_for_disconnect(self, timeout=60):\n-        test_function = lambda: self.state != \"connected\"\n+        test_function = lambda: not self.is_connected\n         wait_until(test_function, timeout=timeout, lock=mininode_lock)\n \n     # Message receiving helper methods"
      }
    ]
  }
]