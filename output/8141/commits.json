[
  {
    "sha": "8c9e681ff8bae61c803cdcc1d05d69cbea5da7bf",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4YzllNjgxZmY4YmFlNjFjODAzY2RjYzFkMDVkNjljYmVhNWRhN2Jm",
    "commit": {
      "author": {
        "name": "mrbandrews",
        "email": "bandrewsny@gmail.com",
        "date": "2016-05-31T18:21:40Z"
      },
      "committer": {
        "name": "mrbandrews",
        "email": "bandrewsny@gmail.com",
        "date": "2016-05-31T18:21:40Z"
      },
      "message": "Tests: Rework blockstore to avoid re-serialization.",
      "tree": {
        "sha": "e55908a7241f90439016840d849f72c6abf7bdcb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e55908a7241f90439016840d849f72c6abf7bdcb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8c9e681ff8bae61c803cdcc1d05d69cbea5da7bf",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8c9e681ff8bae61c803cdcc1d05d69cbea5da7bf",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8c9e681ff8bae61c803cdcc1d05d69cbea5da7bf",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8c9e681ff8bae61c803cdcc1d05d69cbea5da7bf/comments",
    "author": {
      "login": "mrbandrews",
      "id": 7504522,
      "node_id": "MDQ6VXNlcjc1MDQ1MjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7504522?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mrbandrews",
      "html_url": "https://github.com/mrbandrews",
      "followers_url": "https://api.github.com/users/mrbandrews/followers",
      "following_url": "https://api.github.com/users/mrbandrews/following{/other_user}",
      "gists_url": "https://api.github.com/users/mrbandrews/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mrbandrews/subscriptions",
      "organizations_url": "https://api.github.com/users/mrbandrews/orgs",
      "repos_url": "https://api.github.com/users/mrbandrews/repos",
      "events_url": "https://api.github.com/users/mrbandrews/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mrbandrews/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mrbandrews",
      "id": 7504522,
      "node_id": "MDQ6VXNlcjc1MDQ1MjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7504522?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mrbandrews",
      "html_url": "https://github.com/mrbandrews",
      "followers_url": "https://api.github.com/users/mrbandrews/followers",
      "following_url": "https://api.github.com/users/mrbandrews/following{/other_user}",
      "gists_url": "https://api.github.com/users/mrbandrews/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mrbandrews/subscriptions",
      "organizations_url": "https://api.github.com/users/mrbandrews/orgs",
      "repos_url": "https://api.github.com/users/mrbandrews/repos",
      "events_url": "https://api.github.com/users/mrbandrews/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mrbandrews/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "425278d17bd0edf8a3a7cc81e55016f7fd8e7726",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/425278d17bd0edf8a3a7cc81e55016f7fd8e7726",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/425278d17bd0edf8a3a7cc81e55016f7fd8e7726"
      }
    ],
    "stats": {
      "total": 72,
      "additions": 53,
      "deletions": 19
    },
    "files": [
      {
        "sha": "6120dd574b5dda7d81bb3776413ed7cf14d4cd22",
        "filename": "qa/rpc-tests/test_framework/blockstore.py",
        "status": "modified",
        "additions": 40,
        "deletions": 19,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8c9e681ff8bae61c803cdcc1d05d69cbea5da7bf/qa/rpc-tests/test_framework/blockstore.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8c9e681ff8bae61c803cdcc1d05d69cbea5da7bf/qa/rpc-tests/test_framework/blockstore.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/blockstore.py?ref=8c9e681ff8bae61c803cdcc1d05d69cbea5da7bf",
        "patch": "@@ -13,20 +13,31 @@ def __init__(self, datadir):\n         self.blockDB = dbm.ndbm.open(datadir + \"/blocks\", 'c')\n         self.currentBlock = 0\n         self.headers_map = dict()\n-    \n+\n     def close(self):\n         self.blockDB.close()\n \n+    def erase(self, blockhash):\n+        del self.blockDB[repr(blockhash)]\n+\n+    # lookup an entry and return the item as raw bytes\n     def get(self, blockhash):\n-        serialized_block = None\n+        value = None\n         try:\n-            serialized_block = self.blockDB[repr(blockhash)]\n+            value = self.blockDB[repr(blockhash)]\n         except KeyError:\n             return None\n-        f = BytesIO(serialized_block)\n-        ret = CBlock()\n-        ret.deserialize(f)\n-        ret.calc_sha256()\n+        return value\n+\n+    # lookup an entry and return it as a CBlock\n+    def get_block(self, blockhash):\n+        ret = None\n+        serialized_block = self.get(blockhash)\n+        if serialized_block is not None:\n+            f = BytesIO(serialized_block)\n+            ret = CBlock()\n+            ret.deserialize(f)\n+            ret.calc_sha256()\n         return ret\n \n     def get_header(self, blockhash):\n@@ -75,13 +86,16 @@ def add_block(self, block):\n     def add_header(self, header):\n         self.headers_map[header.sha256] = header\n \n+    # lookup the hashes in \"inv\", and return p2p messages for delivering\n+    # blocks found.\n     def get_blocks(self, inv):\n         responses = []\n         for i in inv:\n             if (i.type == 2): # MSG_BLOCK\n-                block = self.get(i.hash)\n-                if block is not None:\n-                    responses.append(msg_block(block))\n+                data = self.get(i.hash)\n+                if data is not None:\n+                    # Use msg_generic to avoid re-serialization\n+                    responses.append(msg_generic(b\"block\", data))\n         return responses\n \n     def get_locator(self, current_tip=None):\n@@ -90,11 +104,11 @@ def get_locator(self, current_tip=None):\n         r = []\n         counter = 0\n         step = 1\n-        lastBlock = self.get(current_tip)\n+        lastBlock = self.get_block(current_tip)\n         while lastBlock is not None:\n             r.append(lastBlock.hashPrevBlock)\n             for i in range(step):\n-                lastBlock = self.get(lastBlock.hashPrevBlock)\n+                lastBlock = self.get_block(lastBlock.hashPrevBlock)\n                 if lastBlock is None:\n                     break\n             counter += 1\n@@ -111,16 +125,23 @@ def __init__(self, datadir):\n     def close(self):\n         self.txDB.close()\n \n+    # lookup an entry and return the item as raw bytes\n     def get(self, txhash):\n-        serialized_tx = None\n+        value = None\n         try:\n-            serialized_tx = self.txDB[repr(txhash)]\n+            value = self.txDB[repr(txhash)]\n         except KeyError:\n             return None\n-        f = BytesIO(serialized_tx)\n-        ret = CTransaction()\n-        ret.deserialize(f)\n-        ret.calc_sha256()\n+        return value\n+\n+    def get_transaction(self, txhash):\n+        ret = None\n+        serialized_tx = self.get(txhash)\n+        if serialized_tx is not None:\n+            f = BytesIO(serialized_tx)\n+            ret = CTransaction()\n+            ret.deserialize(f)\n+            ret.calc_sha256()\n         return ret\n \n     def add_transaction(self, tx):\n@@ -136,5 +157,5 @@ def get_transactions(self, inv):\n             if (i.type == 1): # MSG_TX\n                 tx = self.get(i.hash)\n                 if tx is not None:\n-                    responses.append(msg_tx(tx))\n+                    responses.append(msg_generic(b\"tx\", tx))\n         return responses"
      },
      {
        "sha": "e85399c960bb7a3b5a2df7a1a91a1a3bc684d8b9",
        "filename": "qa/rpc-tests/test_framework/mininode.py",
        "status": "modified",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8c9e681ff8bae61c803cdcc1d05d69cbea5da7bf/qa/rpc-tests/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8c9e681ff8bae61c803cdcc1d05d69cbea5da7bf/qa/rpc-tests/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/mininode.py?ref=8c9e681ff8bae61c803cdcc1d05d69cbea5da7bf",
        "patch": "@@ -556,6 +556,7 @@ def solve(self):\n             self.nNonce += 1\n             self.rehash()\n \n+\n     def __repr__(self):\n         return \"CBlock(nVersion=%i hashPrevBlock=%064x hashMerkleRoot=%064x nTime=%s nBits=%08x nNonce=%08x vtx=%s)\" \\\n             % (self.nVersion, self.hashPrevBlock, self.hashMerkleRoot,\n@@ -836,6 +837,18 @@ def serialize(self):\n     def __repr__(self):\n         return \"msg_block(block=%s)\" % (repr(self.block))\n \n+# for cases where a user needs tighter control over what is sent over the wire\n+# note that the user must supply the name of the command, and the data\n+class msg_generic(object):\n+    def __init__(self, command, data=None):\n+        self.command = command\n+        self.data = data\n+\n+    def serialize(self):\n+        return self.data\n+\n+    def __repr__(self):\n+        return \"msg_generic()\"\n \n class msg_getaddr(object):\n     command = b\"getaddr\""
      }
    ]
  },
  {
    "sha": "291f8aa5daf80eed56d6cefa3d410652b412150a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyOTFmOGFhNWRhZjgwZWVkNTZkNmNlZmEzZDQxMDY1MmI0MTIxNTBh",
    "commit": {
      "author": {
        "name": "mrbandrews",
        "email": "bandrewsny@gmail.com",
        "date": "2016-06-02T18:42:09Z"
      },
      "committer": {
        "name": "mrbandrews",
        "email": "bandrewsny@gmail.com",
        "date": "2016-06-02T18:42:09Z"
      },
      "message": "Continuing port of java comptool",
      "tree": {
        "sha": "c35a5208f431842091032eb429c415ae8efe36c7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c35a5208f431842091032eb429c415ae8efe36c7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/291f8aa5daf80eed56d6cefa3d410652b412150a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/291f8aa5daf80eed56d6cefa3d410652b412150a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/291f8aa5daf80eed56d6cefa3d410652b412150a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/291f8aa5daf80eed56d6cefa3d410652b412150a/comments",
    "author": {
      "login": "mrbandrews",
      "id": 7504522,
      "node_id": "MDQ6VXNlcjc1MDQ1MjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7504522?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mrbandrews",
      "html_url": "https://github.com/mrbandrews",
      "followers_url": "https://api.github.com/users/mrbandrews/followers",
      "following_url": "https://api.github.com/users/mrbandrews/following{/other_user}",
      "gists_url": "https://api.github.com/users/mrbandrews/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mrbandrews/subscriptions",
      "organizations_url": "https://api.github.com/users/mrbandrews/orgs",
      "repos_url": "https://api.github.com/users/mrbandrews/repos",
      "events_url": "https://api.github.com/users/mrbandrews/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mrbandrews/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mrbandrews",
      "id": 7504522,
      "node_id": "MDQ6VXNlcjc1MDQ1MjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7504522?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mrbandrews",
      "html_url": "https://github.com/mrbandrews",
      "followers_url": "https://api.github.com/users/mrbandrews/followers",
      "following_url": "https://api.github.com/users/mrbandrews/following{/other_user}",
      "gists_url": "https://api.github.com/users/mrbandrews/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mrbandrews/subscriptions",
      "organizations_url": "https://api.github.com/users/mrbandrews/orgs",
      "repos_url": "https://api.github.com/users/mrbandrews/repos",
      "events_url": "https://api.github.com/users/mrbandrews/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mrbandrews/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8c9e681ff8bae61c803cdcc1d05d69cbea5da7bf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8c9e681ff8bae61c803cdcc1d05d69cbea5da7bf",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8c9e681ff8bae61c803cdcc1d05d69cbea5da7bf"
      }
    ],
    "stats": {
      "total": 1121,
      "additions": 1010,
      "deletions": 111
    },
    "files": [
      {
        "sha": "19b90d4db11ebbf828bdf2ce247e20bb4a76495d",
        "filename": "qa/rpc-tests/p2p-fullblocktest.py",
        "status": "modified",
        "additions": 991,
        "deletions": 106,
        "changes": 1097,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/291f8aa5daf80eed56d6cefa3d410652b412150a/qa/rpc-tests/p2p-fullblocktest.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/291f8aa5daf80eed56d6cefa3d410652b412150a/qa/rpc-tests/p2p-fullblocktest.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-fullblocktest.py?ref=291f8aa5daf80eed56d6cefa3d410652b412150a",
        "patch": "@@ -9,7 +9,8 @@\n from test_framework.blocktools import *\n import time\n from test_framework.key import CECKey\n-from test_framework.script import CScript, SignatureHash, SIGHASH_ALL, OP_TRUE, OP_FALSE\n+from test_framework.script import *\n+import struct\n \n class PreviousSpendableOutput(object):\n     def __init__(self, tx = CTransaction(), n = -1):\n@@ -24,77 +25,103 @@ def __init__(self, tx = CTransaction(), n = -1):\n each test.\n '''\n \n+def hash160(s):\n+    return hashlib.new('ripemd160', sha256(s)).digest()\n+\n+#  Use this class for tests that require behavior other than normal \"mininode\" behavior.\n+#  For now, it is used to serialize a bloated varint (b64).\n+class CBrokenBlock(CBlock):\n+    def __init__(self, header=None):\n+        super(CBrokenBlock, self).__init__(header)\n+\n+    def initialize(self, base_block):\n+        self.vtx = copy.deepcopy(base_block.vtx)\n+        self.hashMerkleRoot = self.calc_merkle_root()\n+\n+    def serialize(self):\n+        r = b\"\"\n+        r += super(CBlock, self).serialize()\n+        r += struct.pack(\"<BQ\", 255, len(self.vtx))\n+        for tx in self.vtx:\n+            r += tx.serialize()\n+        return r\n+\n+    def normal_serialize(self):\n+        r = b\"\"\n+        r += super(CBrokenBlock, self).serialize()\n+        return r\n+\n class FullBlockTest(ComparisonTestFramework):\n \n-    ''' Can either run this test as 1 node with expected answers, or two and compare them. \n-        Change the \"outcome\" variable from each TestInstance object to only do the comparison. '''\n+    # Can either run this test as 1 node with expected answers, or two and compare them.\n+    # Change the \"outcome\" variable from each TestInstance object to only do the comparison.\n     def __init__(self):\n         super().__init__()\n         self.num_nodes = 1\n         self.block_heights = {}\n         self.coinbase_key = CECKey()\n         self.coinbase_key.set_secretbytes(b\"horsebattery\")\n         self.coinbase_pubkey = self.coinbase_key.get_pubkey()\n-        self.block_time = int(time.time())+1\n         self.tip = None\n         self.blocks = {}\n \n     def run_test(self):\n-        test = TestManager(self, self.options.tmpdir)\n-        test.add_all_connections(self.nodes)\n+        self.test = TestManager(self, self.options.tmpdir)\n+        self.test.add_all_connections(self.nodes)\n         NetworkThread().start() # Start up network handling in another thread\n-        test.run()\n+        self.test.run()\n \n     def add_transactions_to_block(self, block, tx_list):\n         [ tx.rehash() for tx in tx_list ]\n         block.vtx.extend(tx_list)\n-        block.hashMerkleRoot = block.calc_merkle_root()\n-        block.rehash()\n-        return block\n-    \n-    # Create a block on top of self.tip, and advance self.tip to point to the new block\n-    # if spend is specified, then 1 satoshi will be spent from that to an anyone-can-spend output,\n-    # and rest will go to fees.\n-    def next_block(self, number, spend=None, additional_coinbase_value=0, script=None):\n+\n+    # this is a little handier to use than the version in blocktools.py\n+    def create_tx(self, spend_tx, n, value, script=CScript([OP_TRUE])):\n+        tx = create_transaction(spend_tx, n, b\"\", value, script)\n+        return tx\n+\n+    # sign a transaction, using the key we know about\n+    # this signs input 0 in tx, which is assumed to be spending output n in spend_tx\n+    def sign_tx(self, tx, spend_tx, n):\n+        scriptPubKey = bytearray(spend_tx.vout[n].scriptPubKey)\n+        if (scriptPubKey[0] == OP_TRUE):  # an anyone-can-spend\n+            tx.vin[0].scriptSig = CScript()\n+            return\n+        (sighash, err) = SignatureHash(spend_tx.vout[n].scriptPubKey, tx, 0, SIGHASH_ALL)\n+        tx.vin[0].scriptSig = CScript([self.coinbase_key.sign(sighash) + bytes(bytearray([SIGHASH_ALL]))])\n+\n+    def create_and_sign_transaction(self, spend_tx, n, value, script=CScript([OP_TRUE])):\n+        tx = self.create_tx(spend_tx, n, value, script)\n+        self.sign_tx(tx, spend_tx, n)\n+        tx.rehash()\n+        return tx\n+\n+    def next_block(self, number, spend=None, additional_coinbase_value=0, script=CScript([OP_TRUE]), solve=True):\n         if self.tip == None:\n             base_block_hash = self.genesis_hash\n+            block_time = int(time.time())+1\n         else:\n             base_block_hash = self.tip.sha256\n+            block_time = self.tip.nTime + 1\n         # First create the coinbase\n         height = self.block_heights[base_block_hash] + 1\n         coinbase = create_coinbase(height, self.coinbase_pubkey)\n         coinbase.vout[0].nValue += additional_coinbase_value\n-        if (spend != None):\n-            coinbase.vout[0].nValue += spend.tx.vout[spend.n].nValue - 1 # all but one satoshi to fees\n         coinbase.rehash()\n-        block = create_block(base_block_hash, coinbase, self.block_time)\n-        if (spend != None):\n-            tx = CTransaction()\n-            tx.vin.append(CTxIn(COutPoint(spend.tx.sha256, spend.n), b\"\", 0xffffffff))  # no signature yet\n-            # This copies the java comparison tool testing behavior: the first\n-            # txout has a garbage scriptPubKey, \"to make sure we're not\n-            # pre-verifying too much\" (?)\n-            tx.vout.append(CTxOut(0, CScript([random.randint(0,255), height & 255])))\n-            if script == None:\n-                tx.vout.append(CTxOut(1, CScript([OP_TRUE])))\n-            else:\n-                tx.vout.append(CTxOut(1, script))\n-            # Now sign it if necessary\n-            scriptSig = b\"\"\n-            scriptPubKey = bytearray(spend.tx.vout[spend.n].scriptPubKey)\n-            if (scriptPubKey[0] == OP_TRUE):  # looks like an anyone-can-spend\n-                scriptSig = CScript([OP_TRUE])\n-            else:\n-                # We have to actually sign it\n-                (sighash, err) = SignatureHash(spend.tx.vout[spend.n].scriptPubKey, tx, 0, SIGHASH_ALL)\n-                scriptSig = CScript([self.coinbase_key.sign(sighash) + bytes(bytearray([SIGHASH_ALL]))])\n-            tx.vin[0].scriptSig = scriptSig\n-            # Now add the transaction to the block\n-            block = self.add_transactions_to_block(block, [tx])\n-        block.solve()\n+        if spend == None:\n+            block = create_block(base_block_hash, coinbase, block_time)\n+        else:\n+            coinbase.vout[0].nValue += spend.tx.vout[spend.n].nValue - 1 # all but one satoshi to fees\n+            coinbase.rehash()\n+            block = create_block(base_block_hash, coinbase, block_time)\n+            tx = create_transaction(spend.tx, spend.n, b\"\", 1, script)  # spend 1 satoshi\n+            self.sign_tx(tx, spend.tx, spend.n)\n+            self.add_transactions_to_block(block, [tx])\n+            block.hashMerkleRoot = block.calc_merkle_root()\n+        if solve:\n+            block.solve()\n         self.tip = block\n         self.block_heights[block.sha256] = height\n-        self.block_time += 1\n         assert number not in self.blocks\n         self.blocks[number] = block\n         return block\n@@ -108,7 +135,7 @@ def get_tests(self):\n         def save_spendable_output():\n             spendable_outputs.append(self.tip)\n \n-        # get an output that we previous marked as spendable\n+        # get an output that we previously marked as spendable\n         def get_spendable_output():\n             return PreviousSpendableOutput(spendable_outputs.pop(0).vtx[0], 0)\n \n@@ -122,26 +149,33 @@ def rejected(reject = None):\n                 return TestInstance([[self.tip, False]])\n             else:\n                 return TestInstance([[self.tip, reject]])\n-       \n+\n         # move the tip back to a previous block\n         def tip(number):\n             self.tip = self.blocks[number]\n \n-        # add transactions to a block produced by next_block\n+        # adds transactions to the block and updates state\n         def update_block(block_number, new_transactions):\n             block = self.blocks[block_number]\n-            old_hash = block.sha256\n             self.add_transactions_to_block(block, new_transactions)\n+            old_sha256 = block.sha256\n+            block.hashMerkleRoot = block.calc_merkle_root()\n             block.solve()\n             # Update the internal state just like in next_block\n             self.tip = block\n-            self.block_heights[block.sha256] = self.block_heights[old_hash]\n-            del self.block_heights[old_hash]\n+            if block.sha256 != old_sha256:\n+                self.block_heights[block.sha256] = self.block_heights[old_sha256]\n+                del self.block_heights[old_sha256]\n             self.blocks[block_number] = block\n             return block\n \n-        # creates a new block and advances the tip to that block\n+        # shorthand for functions\n         block = self.next_block\n+        create_tx = self.create_tx\n+        create_and_sign_tx = self.create_and_sign_transaction\n+\n+        # these must be updated if consensus changes\n+        MAX_BLOCK_SIGOPS = 20000\n \n \n         # Create a new block\n@@ -153,90 +187,86 @@ def update_block(block_number, new_transactions):\n         # Now we need that block to mature so we can spend the coinbase.\n         test = TestInstance(sync_every_block=False)\n         for i in range(99):\n-            block(1000 + i)\n+            block(5000 + i)\n             test.blocks_and_transactions.append([self.tip, True])\n             save_spendable_output()\n         yield test\n \n+        # collect spendable outputs now to avoid cluttering the code later on\n+        out = []\n+        for i in range(33):\n+            out.append(get_spendable_output())\n \n         # Start by building a couple of blocks on top (which output is spent is\n         # in parentheses):\n         #     genesis -> b1 (0) -> b2 (1)\n-        out0 = get_spendable_output()\n-        block(1, spend=out0)\n+        block(1, spend=out[0])\n         save_spendable_output()\n         yield accepted()\n \n-        out1 = get_spendable_output()\n-        b2 = block(2, spend=out1)\n+        block(2, spend=out[1])\n         yield accepted()\n-\n+        save_spendable_output()\n \n         # so fork like this:\n-        # \n+        #\n         #     genesis -> b1 (0) -> b2 (1)\n         #                      \\-> b3 (1)\n-        # \n+        #\n         # Nothing should happen at this point. We saw b2 first so it takes priority.\n         tip(1)\n-        b3 = block(3, spend=out1)\n-        txout_b3 = PreviousSpendableOutput(b3.vtx[1], 1)\n+        b3 = block(3, spend=out[1])\n+        txout_b3 = PreviousSpendableOutput(b3.vtx[1], 0)\n         yield rejected()\n \n \n         # Now we add another block to make the alternative chain longer.\n-        # \n+        #\n         #     genesis -> b1 (0) -> b2 (1)\n         #                      \\-> b3 (1) -> b4 (2)\n-        out2 = get_spendable_output()\n-        block(4, spend=out2)\n+        block(4, spend=out[2])\n         yield accepted()\n \n \n         # ... and back to the first chain.\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6 (3)\n         #                      \\-> b3 (1) -> b4 (2)\n         tip(2)\n-        block(5, spend=out2)\n+        block(5, spend=out[2])\n         save_spendable_output()\n         yield rejected()\n \n-        out3 = get_spendable_output()\n-        block(6, spend=out3)\n+        block(6, spend=out[3])\n         yield accepted()\n \n-\n         # Try to create a fork that double-spends\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6 (3)\n         #                                          \\-> b7 (2) -> b8 (4)\n         #                      \\-> b3 (1) -> b4 (2)\n         tip(5)\n-        block(7, spend=out2)\n+        block(7, spend=out[2])\n         yield rejected()\n \n-        out4 = get_spendable_output()\n-        block(8, spend=out4)\n+        block(8, spend=out[4])\n         yield rejected()\n \n-\n         # Try to create a block that has too much fee\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6 (3)\n         #                                                    \\-> b9 (4)\n         #                      \\-> b3 (1) -> b4 (2)\n         tip(6)\n-        block(9, spend=out4, additional_coinbase_value=1)\n+        block(9, spend=out[4], additional_coinbase_value=1)\n         yield rejected(RejectResult(16, b'bad-cb-amount'))\n \n-        \n         # Create a fork that ends in a block with too much fee (the one that causes the reorg)\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n         #                                          \\-> b10 (3) -> b11 (4)\n         #                      \\-> b3 (1) -> b4 (2)\n         tip(5)\n-        block(10, spend=out3)\n+        block(10, spend=out[3])\n         yield rejected()\n \n-        block(11, spend=out4, additional_coinbase_value=1)\n+        block(11, spend=out[4], additional_coinbase_value=1)\n         yield rejected(RejectResult(16, b'bad-cb-amount'))\n \n \n@@ -246,19 +276,17 @@ def update_block(block_number, new_transactions):\n         #                                              (b12 added last)\n         #                      \\-> b3 (1) -> b4 (2)\n         tip(5)\n-        b12 = block(12, spend=out3)\n+        b12 = block(12, spend=out[3])\n         save_spendable_output()\n-        #yield TestInstance([[b12, False]])\n-        b13 = block(13, spend=out4)\n+        b13 = block(13, spend=out[4])\n         # Deliver the block header for b12, and the block b13.\n         # b13 should be accepted but the tip won't advance until b12 is delivered.\n         yield TestInstance([[CBlockHeader(b12), None], [b13, False]])\n \n         save_spendable_output()\n-        out5 = get_spendable_output()\n         # b14 is invalid, but the node won't know that until it tries to connect\n         # Tip still can't advance because b12 is missing\n-        block(14, spend=out5, additional_coinbase_value=1)\n+        block(14, spend=out[5], additional_coinbase_value=1)\n         yield rejected()\n \n         yield TestInstance([[b12, True, b13.sha256]]) # New tip should be b13.\n@@ -267,18 +295,18 @@ def update_block(block_number, new_transactions):\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n         #                                          \\-> b12 (3) -> b13 (4) -> b15 (5) -> b16 (6)\n         #                      \\-> b3 (1) -> b4 (2)\n-        \n+\n         # Test that a block with a lot of checksigs is okay\n-        lots_of_checksigs = CScript([OP_CHECKSIG] * (1000000 // 50 - 1))\n+        lots_of_checksigs = CScript([OP_CHECKSIG] * (MAX_BLOCK_SIGOPS - 1))\n         tip(13)\n-        block(15, spend=out5, script=lots_of_checksigs)\n+        block(15, spend=out[5], script=lots_of_checksigs)\n         yield accepted()\n+        save_spendable_output()\n \n \n         # Test that a block with too many checksigs is rejected\n-        out6 = get_spendable_output()\n-        too_many_checksigs = CScript([OP_CHECKSIG] * (1000000 // 50))\n-        block(16, spend=out6, script=too_many_checksigs)\n+        too_many_checksigs = CScript([OP_CHECKSIG] * (MAX_BLOCK_SIGOPS))\n+        block(16, spend=out[6], script=too_many_checksigs)\n         yield rejected(RejectResult(16, b'bad-blk-sigops'))\n \n \n@@ -299,16 +327,15 @@ def update_block(block_number, new_transactions):\n         block(18, spend=txout_b3)\n         yield rejected()\n \n-        block(19, spend=out6)\n+        block(19, spend=out[6])\n         yield rejected()\n \n         # Attempt to spend a coinbase at depth too low\n         #     genesis -> b1 (0) -> b2 (1) -> b5 (2) -> b6  (3)\n         #                                          \\-> b12 (3) -> b13 (4) -> b15 (5) -> b20 (7)\n         #                      \\-> b3 (1) -> b4 (2)\n         tip(15)\n-        out7 = get_spendable_output()\n-        block(20, spend=out7)\n+        block(20, spend=out[7])\n         yield rejected(RejectResult(16, b'bad-txns-premature-spend-of-coinbase'))\n \n         # Attempt to spend a coinbase at depth too low (on a fork this time)\n@@ -317,10 +344,10 @@ def update_block(block_number, new_transactions):\n         #                                                                \\-> b21 (6) -> b22 (5)\n         #                      \\-> b3 (1) -> b4 (2)\n         tip(13)\n-        block(21, spend=out6)\n+        block(21, spend=out[6])\n         yield rejected()\n \n-        block(22, spend=out5)\n+        block(22, spend=out[5])\n         yield rejected()\n \n         # Create a block on either side of MAX_BLOCK_SIZE and make sure its accepted/rejected\n@@ -329,29 +356,29 @@ def update_block(block_number, new_transactions):\n         #                                                                           \\-> b24 (6) -> b25 (7)\n         #                      \\-> b3 (1) -> b4 (2)\n         tip(15)\n-        b23 = block(23, spend=out6)\n-        old_hash = b23.sha256\n+        b23 = block(23, spend=out[6])\n         tx = CTransaction()\n         script_length = MAX_BLOCK_SIZE - len(b23.serialize()) - 69\n         script_output = CScript([b'\\x00' * script_length])\n         tx.vout.append(CTxOut(0, script_output))\n-        tx.vin.append(CTxIn(COutPoint(b23.vtx[1].sha256, 1)))\n+        tx.vin.append(CTxIn(COutPoint(b23.vtx[1].sha256, 0)))\n         b23 = update_block(23, [tx])\n         # Make sure the math above worked out to produce a max-sized block\n         assert_equal(len(b23.serialize()), MAX_BLOCK_SIZE)\n         yield accepted()\n+        save_spendable_output()\n \n         # Make the next block one byte bigger and check that it fails\n         tip(15)\n-        b24 = block(24, spend=out6)\n+        b24 = block(24, spend=out[6])\n         script_length = MAX_BLOCK_SIZE - len(b24.serialize()) - 69\n         script_output = CScript([b'\\x00' * (script_length+1)])\n         tx.vout = [CTxOut(0, script_output)]\n         b24 = update_block(24, [tx])\n         assert_equal(len(b24.serialize()), MAX_BLOCK_SIZE+1)\n         yield rejected(RejectResult(16, b'bad-blk-length'))\n \n-        b25 = block(25, spend=out7)\n+        block(25, spend=out[7])\n         yield rejected()\n \n         # Create blocks with a coinbase input script size out of range\n@@ -360,7 +387,7 @@ def update_block(block_number, new_transactions):\n         #                                                                           \\-> ... (6) -> ... (7)\n         #                      \\-> b3 (1) -> b4 (2)\n         tip(15)\n-        b26 = block(26, spend=out6)\n+        b26 = block(26, spend=out[6])\n         b26.vtx[0].vin[0].scriptSig = b'\\x00'\n         b26.vtx[0].rehash()\n         # update_block causes the merkle root to get updated, even with no new\n@@ -369,23 +396,20 @@ def update_block(block_number, new_transactions):\n         yield rejected(RejectResult(16, b'bad-cb-length'))\n \n         # Extend the b26 chain to make sure bitcoind isn't accepting b26\n-        b27 = block(27, spend=out7)\n-        yield rejected()\n+        b27 = block(27, spend=out[7])\n+        yield rejected(RejectResult(16, b'bad-prevblk'))\n \n         # Now try a too-large-coinbase script\n         tip(15)\n-        b28 = block(28, spend=out6)\n+        b28 = block(28, spend=out[6])\n         b28.vtx[0].vin[0].scriptSig = b'\\x00' * 101\n         b28.vtx[0].rehash()\n         b28 = update_block(28, [])\n         yield rejected(RejectResult(16, b'bad-cb-length'))\n \n-        # Extend the b28 chain to make sure bitcoind isn't accepted b28\n-        b29 = block(29, spend=out7)\n-        # TODO: Should get a reject message back with \"bad-prevblk\", except\n-        # there's a bug that prevents this from being detected.  Just note\n-        # failure for now, and add the reject result later.\n-        yield rejected()\n+        # Extend the b28 chain to make sure bitcoind isn't accepting b28\n+        b29 = block(29, spend=out[7])\n+        yield rejected(RejectResult(16, b'bad-prevblk'))\n \n         # b30 has a max-sized coinbase scriptSig.\n         tip(23)\n@@ -394,6 +418,867 @@ def update_block(block_number, new_transactions):\n         b30.vtx[0].rehash()\n         b30 = update_block(30, [])\n         yield accepted()\n+        save_spendable_output()\n+\n+        # b31 - b35 - check sigops of OP_CHECKMULTISIG / OP_CHECKMULTISIGVERIFY / OP_CHECKSIGVERIFY\n+        #\n+        #     genesis -> ... -> b30 (7) -> b31 (8) -> b33 (9) -> b35 (10)\n+        #                                                                \\-> b36 (11)\n+        #                                                    \\-> b34 (10)\n+        #                                         \\-> b32 (9)\n+        #\n+\n+        # MULTISIG: each op code counts as 20 sigops.  To create the edge case, pack another 19 sigops at the end.\n+        lots_of_multisigs = CScript([OP_CHECKMULTISIG] * ((MAX_BLOCK_SIGOPS-1) // 20) + [OP_CHECKSIG] * 19)\n+        b31 = block(31, spend=out[8], script=lots_of_multisigs)\n+        assert_equal(get_legacy_sigopcount_block(b31), MAX_BLOCK_SIGOPS)\n+        yield accepted()\n+        save_spendable_output()\n+\n+        # this goes over the limit because the coinbase has one sigop\n+        too_many_multisigs = CScript([OP_CHECKMULTISIG] * (MAX_BLOCK_SIGOPS // 20))\n+        b32 = block(32, spend=out[9], script=too_many_multisigs)\n+        assert_equal(get_legacy_sigopcount_block(b32), MAX_BLOCK_SIGOPS + 1)\n+        yield rejected(RejectResult(16, b'bad-blk-sigops'))\n+\n+\n+        # CHECKMULTISIGVERIFY\n+        tip(31)\n+        lots_of_multisigs = CScript([OP_CHECKMULTISIGVERIFY] * ((MAX_BLOCK_SIGOPS-1) // 20) + [OP_CHECKSIG] * 19)\n+        block(33, spend=out[9], script=lots_of_multisigs)\n+        yield accepted()\n+        save_spendable_output()\n+\n+        too_many_multisigs = CScript([OP_CHECKMULTISIGVERIFY] * (MAX_BLOCK_SIGOPS // 20))\n+        block(34, spend=out[10], script=too_many_multisigs)\n+        yield rejected(RejectResult(16, b'bad-blk-sigops'))\n+\n+\n+        # CHECKSIGVERIFY\n+        tip(33)\n+        lots_of_checksigs = CScript([OP_CHECKSIGVERIFY] * (MAX_BLOCK_SIGOPS - 1))\n+        b35 = block(35, spend=out[10], script=lots_of_checksigs)\n+        yield accepted()\n+        save_spendable_output()\n+\n+        too_many_checksigs = CScript([OP_CHECKSIGVERIFY] * (MAX_BLOCK_SIGOPS))\n+        block(36, spend=out[11], script=too_many_checksigs)\n+        yield rejected(RejectResult(16, b'bad-blk-sigops'))\n+\n+\n+        # Check spending of a transaction in a block which failed to connect\n+        #\n+        # b6  (3)\n+        # b12 (3) -> b13 (4) -> b15 (5) -> b23 (6) -> b30 (7) -> b31 (8) -> b33 (9) -> b35 (10)\n+        #                                                                                     \\-> b37 (11)\n+        #                                                                                     \\-> b38 (11/37)\n+        #\n+\n+        # save 37's spendable output, but then double-spend out11 to invalidate the block\n+        tip(35)\n+        b37 = block(37, spend=out[11])\n+        txout_b37 = PreviousSpendableOutput(b37.vtx[1], 0)\n+        tx = create_and_sign_tx(out[11].tx, out[11].n, 0)\n+        b37 = update_block(37, [tx])\n+        yield rejected(RejectResult(16, b'bad-txns-inputs-missingorspent'))\n+\n+        # attempt to spend b37's first non-coinbase tx, at which point b37 was still considered valid\n+        tip(35)\n+        block(38, spend=txout_b37)\n+        yield rejected(RejectResult(16, b'bad-txns-inputs-missingorspent'))\n+\n+        # Check P2SH SigOp counting\n+        #\n+        #\n+        #   13 (4) -> b15 (5) -> b23 (6) -> b30 (7) -> b31 (8) -> b33 (9) -> b35 (10) -> b39 (11) -> b41 (12)\n+        #                                                                                        \\-> b40 (12)\n+        #\n+        # b39 - create some P2SH outputs that will require 6 sigops to spend:\n+        #\n+        #           redeem_script = COINBASE_PUBKEY, (OP_2DUP+OP_CHECKSIGVERIFY) * 5, OP_CHECKSIG\n+        #           p2sh_script = OP_HASH160, ripemd160(sha256(script)), OP_EQUAL\n+        #\n+        tip(35)\n+        b39 = block(39)\n+        b39_outputs = 0\n+        b39_sigops_per_output = 6\n+\n+        # Build the redeem script, hash it, use hash to create the p2sh script\n+        redeem_script = CScript([self.coinbase_pubkey] + [OP_2DUP, OP_CHECKSIGVERIFY]*5 + [OP_CHECKSIG])\n+        redeem_script_hash = hash160(redeem_script)\n+        p2sh_script = CScript([OP_HASH160, redeem_script_hash, OP_EQUAL])\n+\n+        # Create a transaction that spends one satoshi to the p2sh_script, the rest to OP_TRUE\n+        # This must be signed because it is spending a coinbase\n+        spend = out[11]\n+        tx = create_tx(spend.tx, spend.n, 1, p2sh_script)\n+        tx.vout.append(CTxOut(spend.tx.vout[spend.n].nValue - 1, CScript([OP_TRUE])))\n+        self.sign_tx(tx, spend.tx, spend.n)\n+        tx.rehash()\n+        b39 = update_block(39, [tx])\n+        b39_outputs += 1\n+\n+        # Until block is full, add tx's with 1 satoshi to p2sh_script, the rest to OP_TRUE\n+        tx_new = None\n+        tx_last = tx\n+        total_size=len(b39.serialize())\n+        while(total_size < MAX_BLOCK_SIZE):\n+            tx_new = create_tx(tx_last, 1, 1, p2sh_script)\n+            tx_new.vout.append(CTxOut(tx_last.vout[1].nValue - 1, CScript([OP_TRUE])))\n+            tx_new.rehash()\n+            total_size += len(tx_new.serialize())\n+            if total_size >= MAX_BLOCK_SIZE:\n+                break\n+            b39.vtx.append(tx_new) # add tx to block\n+            tx_last = tx_new\n+            b39_outputs += 1\n+\n+        b39 = update_block(39, [])\n+        yield accepted()\n+        save_spendable_output()\n+\n+\n+        # Test sigops in P2SH redeem scripts\n+        #\n+        # b40 creates 3333 tx's spending the 6-sigop P2SH outputs from b39 for a total of 19998 sigops.\n+        # The first tx has one sigop and then at the end we add 2 more to put us just over the max.\n+        #\n+        # b41 does the same, less one, so it has the maximum sigops permitted.\n+        #\n+        tip(39)\n+        b40 = block(40, spend=out[12])\n+        sigops = get_legacy_sigopcount_block(b40)\n+        numTxes = (MAX_BLOCK_SIGOPS - sigops) // b39_sigops_per_output\n+        assert_equal(numTxes <= b39_outputs, True)\n+\n+        lastOutpoint = COutPoint(b40.vtx[1].sha256, 0)\n+        new_txs = []\n+        for i in range(1, numTxes+1):\n+            tx = CTransaction()\n+            tx.vout.append(CTxOut(1, CScript([OP_TRUE])))\n+            tx.vin.append(CTxIn(lastOutpoint, b''))\n+            # second input is corresponding P2SH output from b39\n+            tx.vin.append(CTxIn(COutPoint(b39.vtx[i].sha256, 0), b''))\n+            # Note: must pass the redeem_script (not p2sh_script) to the signature hash function\n+            (sighash, err) = SignatureHash(redeem_script, tx, 1, SIGHASH_ALL)\n+            sig = self.coinbase_key.sign(sighash) + bytes(bytearray([SIGHASH_ALL]))\n+            scriptSig = CScript([sig, redeem_script])\n+\n+            tx.vin[1].scriptSig = scriptSig\n+            tx.rehash()\n+            new_txs.append(tx)\n+            lastOutpoint = COutPoint(tx.sha256, 0)\n+\n+        b40_sigops_to_fill = MAX_BLOCK_SIGOPS - (numTxes * b39_sigops_per_output + sigops) + 1\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(lastOutpoint, b''))\n+        tx.vout.append(CTxOut(1, CScript([OP_CHECKSIG] * b40_sigops_to_fill)))\n+        tx.rehash()\n+        new_txs.append(tx)\n+        update_block(40, new_txs)\n+        yield rejected(RejectResult(16, b'bad-blk-sigops'))\n+\n+        # same as b40, but one less sigop\n+        tip(39)\n+        b41 = block(41, spend=None)\n+        update_block(41, b40.vtx[1:-1])\n+        b41_sigops_to_fill = b40_sigops_to_fill - 1\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(lastOutpoint, b''))\n+        tx.vout.append(CTxOut(1, CScript([OP_CHECKSIG] * b41_sigops_to_fill)))\n+        tx.rehash()\n+        update_block(41, [tx])\n+        yield accepted()\n+\n+        # Fork off of b39 to create a constant base again\n+        #\n+        # b23 (6) -> b30 (7) -> b31 (8) -> b33 (9) -> b35 (10) -> b39 (11) -> b42 (12) -> b43 (13)\n+        #                                                                  \\-> b41 (12)\n+        #\n+        tip(39)\n+        block(42, spend=out[12])\n+        yield rejected()\n+        save_spendable_output()\n+\n+        block(43, spend=out[13])\n+        yield accepted()\n+        save_spendable_output()\n+\n+\n+        # Test a number of really invalid scenarios\n+        #\n+        #  -> b31 (8) -> b33 (9) -> b35 (10) -> b39 (11) -> b42 (12) -> b43 (13) -> b44 (14)\n+        #                                                                                   \\-> ??? (15)\n+\n+        # The next few blocks are going to be created \"by hand\" since they'll do funky things, such as having\n+        # the first transaction be non-coinbase, etc.  The purpose of b44 is to make sure this works.\n+        height = self.block_heights[self.tip.sha256] + 1\n+        coinbase = create_coinbase(height, self.coinbase_pubkey)\n+        b44 = CBlock()\n+        b44.nTime = self.tip.nTime + 1\n+        b44.hashPrevBlock = self.tip.sha256\n+        b44.nBits = 0x207fffff\n+        b44.vtx.append(coinbase)\n+        b44.hashMerkleRoot = b44.calc_merkle_root()\n+        b44.solve()\n+        self.tip = b44\n+        self.block_heights[b44.sha256] = height\n+        self.blocks[44] = b44\n+        yield accepted()\n+\n+        # A block with a non-coinbase as the first tx\n+        non_coinbase = create_tx(out[15].tx, out[15].n, 1)\n+        b45 = CBlock()\n+        b45.nTime = self.tip.nTime + 1\n+        b45.hashPrevBlock = self.tip.sha256\n+        b45.nBits = 0x207fffff\n+        b45.vtx.append(non_coinbase)\n+        b45.hashMerkleRoot = b45.calc_merkle_root()\n+        b45.calc_sha256()\n+        b45.solve()\n+        self.block_heights[b45.sha256] = self.block_heights[self.tip.sha256]+1\n+        self.tip = b45\n+        self.blocks[45] = b45\n+        yield rejected(RejectResult(16, b'bad-cb-missing'))\n+\n+        # A block with no txns\n+        tip(44)\n+        b46 = CBlock()\n+        b46.nTime = b44.nTime+1\n+        b46.hashPrevBlock = b44.sha256\n+        b46.nBits = 0x207fffff\n+        b46.vtx = []\n+        b46.hashMerkleRoot = 0\n+        b46.solve()\n+        self.block_heights[b46.sha256] = self.block_heights[b44.sha256]+1\n+        self.tip = b46\n+        assert 46 not in self.blocks\n+        self.blocks[46] = b46\n+        s = ser_uint256(b46.hashMerkleRoot)\n+        yield rejected(RejectResult(16, b'bad-blk-length'))\n+\n+        # A block with invalid work\n+        tip(44)\n+        b47 = block(47, solve=False)\n+        target = uint256_from_compact(b47.nBits)\n+        while b47.sha256 < target: #changed > to <\n+            b47.nNonce += 1\n+            b47.rehash()\n+        yield rejected(RejectResult(16, b'high-hash'))\n+\n+        # A block with timestamp > 2 hrs in the future\n+        tip(44)\n+        b48 = block(48, solve=False)\n+        b48.nTime = int(time.time()) + 60 * 60 * 3\n+        b48.solve()\n+        yield rejected(RejectResult(16, b'time-too-new'))\n+\n+        # A block with an invalid merkle hash\n+        tip(44)\n+        b49 = block(49)\n+        b49.hashMerkleRoot += 1\n+        b49.solve()\n+        yield rejected(RejectResult(16, b'bad-txnmrklroot'))\n+\n+        # A block with an incorrect POW limit\n+        tip(44)\n+        b50 = block(50)\n+        b50.nBits = b50.nBits - 1\n+        b50.solve()\n+        yield rejected(RejectResult(16, b'bad-diffbits'))\n+\n+        # A block with two coinbase txns\n+        tip(44)\n+        b51 = block(51)\n+        cb2 = create_coinbase(51, self.coinbase_pubkey)\n+        b51 = update_block(51, [cb2])\n+        yield rejected(RejectResult(16, b'bad-cb-multiple'))\n+\n+        # A block w/ duplicate txns\n+        # Note: txns have to be in the right position in the merkle tree to trigger this error\n+        tip(44)\n+        b52 = block(52, spend=out[15])\n+        tx = create_tx(b52.vtx[1], 0, 1)\n+        b52 = update_block(52, [tx, tx])\n+        yield rejected(RejectResult(16, b'bad-txns-duplicate'))\n+\n+        # Test block timestamps\n+        #  -> b31 (8) -> b33 (9) -> b35 (10) -> b39 (11) -> b42 (12) -> b43 (13) -> b53 (14) -> b55 (15)\n+        #                                                                                   \\-> b54 (15)\n+        #\n+        tip(43)\n+        block(53, spend=out[14])\n+        yield rejected() # rejected since b44 is at same height\n+        save_spendable_output()\n+\n+        # invalid timestamp (b35 is 5 blocks back, so its time is MedianTimePast)\n+        b54 = block(54, spend=out[15])\n+        b54.nTime = b35.nTime - 1\n+        b54.solve()\n+        yield rejected(RejectResult(16, b'time-too-old'))\n+\n+        # valid timestamp\n+        tip(53)\n+        b55 = block(55, spend=out[15])\n+        b55.nTime = b35.nTime\n+        update_block(55, [])\n+        yield accepted()\n+        save_spendable_output()\n+\n+\n+        # Test CVE-2012-2459\n+        #\n+        # -> b42 (12) -> b43 (13) -> b53 (14) -> b55 (15) -> b57p2 (16)\n+        #                                                \\-> b57   (16)\n+        #                                                \\-> b56p2 (16)\n+        #                                                \\-> b56   (16)\n+        #\n+        # Merkle tree malleability (CVE-2012-2459): repeating sequences of transactions in a block without \n+        #                           affecting the merkle root of a block, while still invalidating it.\n+        #                           See:  src/consensus/merkle.h\n+        #\n+        #  b57 has three txns:  coinbase, tx, tx1.  The merkle root computation will duplicate tx.\n+        #  Result:  OK\n+        #\n+        #  b56 copies b57 but duplicates tx1 and does not recalculate the block hash.  So it has a valid merkle\n+        #  root but duplicate transactions.\n+        #  Result:  Fails\n+        #\n+        #  b57p2 has six transactions in its merkle tree:\n+        #       - coinbase, tx, tx1, tx2, tx3, tx4\n+        #  Merkle root calculation will duplicate as necessary.\n+        #  Result:  OK.\n+        #\n+        #  b56p2 copies b57p2 but adds both tx3 and tx4.  The purpose of the test is to make sure the code catches\n+        #  duplicate txns that are not next to one another with the \"bad-txns-duplicate\" error (which indicates\n+        #  that the error was caught early, avoiding a DOS vulnerability.)\n+\n+        # b57 - a good block with 2 txs, don't submit until end\n+        tip(55)\n+        b57 = block(57)\n+        tx = create_and_sign_tx(out[16].tx, out[16].n, 1)\n+        tx1 = create_tx(tx, 0, 1)\n+        b57 = update_block(57, [tx, tx1])\n+\n+        # b56 - copy b57, add a duplicate tx\n+        tip(55)\n+        b56 = copy.deepcopy(b57)\n+        self.blocks[56] = b56\n+        assert_equal(len(b56.vtx),3)\n+        b56 = update_block(56, [tx1])\n+        assert_equal(b56.hash, b57.hash)\n+        yield rejected(RejectResult(16, b'bad-txns-duplicate'))\n+\n+        # b57p2 - a good block with 6 tx'es, don't submit until end\n+        tip(55)\n+        b57p2 = block(\"57p2\")\n+        tx = create_and_sign_tx(out[16].tx, out[16].n, 1)\n+        tx1 = create_tx(tx, 0, 1)\n+        tx2 = create_tx(tx1, 0, 1)\n+        tx3 = create_tx(tx2, 0, 1)\n+        tx4 = create_tx(tx3, 0, 1)\n+        b57p2 = update_block(\"57p2\", [tx, tx1, tx2, tx3, tx4])\n+\n+        # b56p2 - copy b57p2, duplicate two non-consecutive tx's\n+        tip(55)\n+        b56p2 = copy.deepcopy(b57p2)\n+        self.blocks[\"b56p2\"] = b56p2\n+        assert_equal(b56p2.hash, b57p2.hash)\n+        assert_equal(len(b56p2.vtx),6)\n+        b56p2 = update_block(\"b56p2\", [tx3, tx4])\n+        yield rejected(RejectResult(16, b'bad-txns-duplicate'))\n+\n+        tip(\"57p2\")\n+        yield accepted()\n+\n+        tip(57)\n+        yield rejected()  #rejected because 57p2 seen first\n+        save_spendable_output()\n+\n+        # Test a few invalid tx types\n+        #\n+        # -> b35 (10) -> b39 (11) -> b42 (12) -> b43 (13) -> b53 (14) -> b55 (15) -> b57 (16) -> b60 (17)\n+        #                                                                                    \\-> ??? (17)\n+        #\n+\n+        # tx with prevout.n out of range\n+        tip(57)\n+        b58 = block(58, spend=out[17])\n+        tx = CTransaction()\n+        assert(len(out[17].tx.vout) < 42)\n+        tx.vin.append(CTxIn(COutPoint(out[17].tx.sha256, 42), CScript([OP_TRUE]), 0xffffffff))\n+        tx.vout.append(CTxOut(0, b\"\"))\n+        tx.calc_sha256()\n+        b58 = update_block(58, [tx])\n+        yield rejected(RejectResult(16, b'bad-txns-inputs-missingorspent'))\n+\n+        # tx with output value > input value out of range\n+        tip(57)\n+        b59 = block(59)\n+        tx = create_and_sign_tx(out[17].tx, out[17].n, 51*COIN)\n+        b59 = update_block(59, [tx])\n+        yield rejected(RejectResult(16, b'bad-txns-in-belowout'))\n+\n+        # reset to good chain\n+        tip(57)\n+        b60 = block(60, spend=out[17])\n+        yield accepted()\n+        save_spendable_output()\n+\n+        # Test BIP30\n+        #\n+        # -> b39 (11) -> b42 (12) -> b43 (13) -> b53 (14) -> b55 (15) -> b57 (16) -> b60 (17)\n+        #                                                                                    \\-> b61 (18)\n+        #\n+        # Blocks are not allowed to contain a transaction whose id matches that of an earlier,\n+        # not-fully-spent transaction in the same chain. To test, make identical coinbases;\n+        # the second one should be rejected.\n+        #\n+        tip(60)\n+        b61 = block(61, spend=out[18])\n+        b61.vtx[0].vin[0].scriptSig = b60.vtx[0].vin[0].scriptSig  #equalize the coinbases\n+        b61.vtx[0].rehash()\n+        b61 = update_block(61, [])\n+        assert_equal(b60.vtx[0].serialize(), b61.vtx[0].serialize())\n+        yield rejected(RejectResult(16, b'bad-txns-BIP30'))\n+\n+\n+        # Test tx.isFinal is properly rejected (not an exhaustive tx.isFinal test, that should be in data-driven transaction tests)\n+        #\n+        #   -> b39 (11) -> b42 (12) -> b43 (13) -> b53 (14) -> b55 (15) -> b57 (16) -> b60 (17)\n+        #                                                                                     \\-> b62 (18)\n+        #\n+        tip(60)\n+        b62 = block(62)\n+        tx = CTransaction()\n+        tx.nLockTime = 0xffffffff  #this locktime is non-final\n+        assert(out[18].n < len(out[18].tx.vout))\n+        tx.vin.append(CTxIn(COutPoint(out[18].tx.sha256, out[18].n))) # don't set nSequence\n+        tx.vout.append(CTxOut(0, CScript([OP_TRUE])))\n+        assert(tx.vin[0].nSequence < 0xffffffff)\n+        tx.calc_sha256()\n+        b62 = update_block(62, [tx])\n+        yield rejected(RejectResult(16, b'bad-txns-nonfinal'))\n+\n+\n+        # Test a non-final coinbase is also rejected\n+        #\n+        #   -> b39 (11) -> b42 (12) -> b43 (13) -> b53 (14) -> b55 (15) -> b57 (16) -> b60 (17)\n+        #                                                                                     \\-> b63 (-)\n+        #\n+        tip(60)\n+        b63 = block(63)\n+        b63.vtx[0].nLockTime = 0xffffffff\n+        b63.vtx[0].vin[0].nSequence = 0xDEADBEEF\n+        b63.vtx[0].rehash()\n+        b63 = update_block(63, [])\n+        yield rejected(RejectResult(16, b'bad-txns-nonfinal'))\n+\n+\n+        #  This checks that a block with a bloated VARINT between the block_header and the array of tx is rejected\n+        #  (previous behavior was that it was accepted.)  It also checks that if you subsequently send that block\n+        #  with correct encoding, it should be accepted (i.e., the receiving node should not reject it on the\n+        #  basis that it's the same as an already-rejected block, which would be a DoS vulnerability.)\n+        #\n+        #  -> b39 (11) -> b42 (12) -> b43 (13) -> b53 (14) -> b55 (15) -> b57 (16) -> b60 (17) -> b64 (18)\n+        #                                                                                        \\\n+        #                                                                                         b64a (18)\n+        #  b64a is a bloated block (non-canonical varint)\n+        #  b64 is a good block (same as b64 but w/ canonical varint)\n+        #\n+        tip(60)\n+        regular_block = block(\"64a\", spend=out[18])\n+\n+        # make it a \"broken_block,\" with non-canonical serialization\n+        b64a = CBrokenBlock(regular_block)\n+        b64a.initialize(regular_block)\n+        self.blocks[\"64a\"] = b64a\n+        self.tip = b64a\n+        tx = CTransaction()\n+\n+        # use canonical serialization to calculate size\n+        script_length = MAX_BLOCK_SIZE - len(b64a.normal_serialize()) - 69\n+        script_output = CScript([b'\\x00' * script_length])\n+        tx.vout.append(CTxOut(0, script_output))\n+        tx.vin.append(CTxIn(COutPoint(b64a.vtx[1].sha256, 0)))\n+        b64a = update_block(\"64a\", [tx])\n+        assert_equal(len(b64a.serialize()), MAX_BLOCK_SIZE + 8)\n+        yield rejected()\n+\n+        # comptool workaround: to make sure b64 is delivered, manually erase b64a from blockstore\n+        self.test.block_store.erase(b64a.sha256)\n+\n+        tip(60)\n+        b64 = CBlock(b64a)\n+        b64.vtx = copy.deepcopy(b64a.vtx)\n+        assert_equal(b64.hash, b64a.hash)\n+        assert_equal(len(b64.serialize()), MAX_BLOCK_SIZE)\n+        self.blocks[64] = b64\n+        update_block(64, [])\n+        yield accepted()\n+        save_spendable_output()\n+\n+        # Spend an output created in the block itself\n+        #\n+        # -> b42 (12) -> b43 (13) -> b53 (14) -> b55 (15) -> b57 (16) -> b60 (17) -> b64 (18) -> b65 (19)\n+        #\n+        tip(64)\n+        b65 = block(65)\n+        tx1 = create_and_sign_tx(out[19].tx, out[19].n, out[19].tx.vout[0].nValue)\n+        tx2 = create_and_sign_tx(tx1, 0, 0)\n+        update_block(65, [tx1, tx2])\n+        yield accepted()\n+        save_spendable_output()\n+\n+        # Attempt to spend an output created later in the same block\n+        #\n+        # -> b43 (13) -> b53 (14) -> b55 (15) -> b57 (16) -> b60 (17) -> b64 (18) -> b65 (19)\n+        #                                                                                    \\-> b66 (20)\n+        tip(65)\n+        b66 = block(66)\n+        tx1 = create_and_sign_tx(out[20].tx, out[20].n, out[20].tx.vout[0].nValue)\n+        tx2 = create_and_sign_tx(tx1, 0, 1)\n+        update_block(66, [tx2, tx1])\n+        yield rejected(RejectResult(16, b'bad-txns-inputs-missingorspent'))\n+\n+\n+        # Attempt to double-spend a transaction created in a block\n+        #\n+        # -> b43 (13) -> b53 (14) -> b55 (15) -> b57 (16) -> b60 (17) -> b64 (18) -> b65 (19)\n+        #                                                                                    \\-> b67 (20)\n+        #\n+        #\n+        tip(65)\n+        b67 = block(67)\n+        tx1 = create_and_sign_tx(out[20].tx, out[20].n, out[20].tx.vout[0].nValue)\n+        tx2 = create_and_sign_tx(tx1, 0, 1)\n+        tx3 = create_and_sign_tx(tx1, 0, 2)\n+        update_block(67, [tx1, tx2, tx3])\n+        yield rejected(RejectResult(16, b'bad-txns-inputs-missingorspent'))\n+\n+        # More tests of block subsidy\n+        #\n+        # -> b43 (13) -> b53 (14) -> b55 (15) -> b57 (16) -> b60 (17) -> b64 (18) -> b65 (19) -> b69 (20)\n+        #                                                                                    \\-> b68 (20)\n+        #\n+        # b68 - coinbase with an extra 10 satoshis,\n+        #       creates a tx that has 9 satoshis from out[20] go to fees\n+        #       this fails because the coinbase is trying to claim 1 satoshi too much in fees\n+        #\n+        # b69 - coinbase with extra 10 satoshis, and a tx that gives a 10 satoshi fee\n+        #       this succeeds\n+        #\n+        tip(65)\n+        b68 = block(68, additional_coinbase_value=10)\n+        tx = create_and_sign_tx(out[20].tx, out[20].n, out[20].tx.vout[0].nValue-9)\n+        update_block(68, [tx])\n+        yield rejected(RejectResult(16, b'bad-cb-amount'))\n+\n+        tip(65)\n+        b69 = block(69, additional_coinbase_value=10)\n+        tx = create_and_sign_tx(out[20].tx, out[20].n, out[20].tx.vout[0].nValue-10)\n+        update_block(69, [tx])\n+        yield accepted()\n+        save_spendable_output()\n+\n+        # Test spending the outpoint of a non-existent transaction\n+        #\n+        # -> b53 (14) -> b55 (15) -> b57 (16) -> b60 (17) -> b64 (18) -> b65 (19) -> b69 (20)\n+        #                                                                                    \\-> b70 (21)\n+        #\n+        tip(69)\n+        block(70, spend=out[21])\n+        bogus_tx = CTransaction()\n+        bogus_tx.sha256 = uint256_from_str(b\"23c70ed7c0506e9178fc1a987f40a33946d4ad4c962b5ae3a52546da53af0c5c\")\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(bogus_tx.sha256, 0), b\"\", 0xffffffff))\n+        tx.vout.append(CTxOut(1, b\"\"))\n+        update_block(70, [tx])\n+        yield rejected(RejectResult(16, b'bad-txns-inputs-missingorspent'))\n+\n+\n+        # Test accepting an invalid block which has the same hash as a valid one (via merkle tree tricks)\n+        #\n+        #  -> b53 (14) -> b55 (15) -> b57 (16) -> b60 (17) -> b64 (18) -> b65 (19) -> b69 (20) -> b72 (21)\n+        #                                                                                      \\-> b71 (21)\n+        #\n+        # b72 is a good block.\n+        # b71 is a copy of 72, but re-adds one of its transactions.  However, it has the same hash as b71.\n+        #\n+        tip(69)\n+        b72 = block(72)\n+        tx1 = create_and_sign_tx(out[21].tx, out[21].n, 2)\n+        tx2 = create_and_sign_tx(tx1, 0, 1)\n+        b72 = update_block(72, [tx1, tx2])  # now tip is 72\n+        b71 = copy.deepcopy(b72)\n+        b71.vtx.append(tx2)   # add duplicate tx2\n+        self.block_heights[b71.sha256] = self.block_heights[b69.sha256] + 1  # b71 builds off b69\n+        self.blocks[71] = b71\n+\n+        assert_equal(len(b71.vtx), 4)\n+        assert_equal(len(b72.vtx), 3)\n+        assert_equal(b72.sha256, b71.sha256)\n+\n+        tip(71)\n+        yield rejected(RejectResult(16, b'bad-txns-duplicate'))\n+        tip(72)\n+        yield accepted()\n+        save_spendable_output()\n+\n+\n+        # Test some invalid scripts and MAX_BLOCK_SIGOPS\n+        #\n+        # -> b55 (15) -> b57 (16) -> b60 (17) -> b64 (18) -> b65 (19) -> b69 (20) -> b72 (21)\n+        #                                                                                    \\-> b** (22)\n+        #\n+\n+        # b73 - tx with excessive sigops that are placed after an excessively large script element.\n+        #       The purpose of the test is to make sure those sigops are counted.\n+        #\n+        #       script is a bytearray of size 20,526\n+        #\n+        #       bytearray[0-19,998]     : OP_CHECKSIG\n+        #       bytearray[19,999]       : OP_PUSHDATA4\n+        #       bytearray[20,000-20,003]: 521  (max_script_element_size+1, in little-endian format)\n+        #       bytearray[20,004-20,525]: unread data (script_element)\n+        #       bytearray[20,526]       : OP_CHECKSIG (this puts us over the limit)\n+        #\n+        tip(72)\n+        b73 = block(73)\n+        size = MAX_BLOCK_SIGOPS - 1 + MAX_SCRIPT_ELEMENT_SIZE + 1 + 5 + 1\n+        a = bytearray([OP_CHECKSIG] * size)\n+        a[MAX_BLOCK_SIGOPS - 1] = int(\"4e\",16) # OP_PUSHDATA4\n+\n+        element_size = MAX_SCRIPT_ELEMENT_SIZE + 1\n+        a[MAX_BLOCK_SIGOPS] = element_size % 256\n+        a[MAX_BLOCK_SIGOPS+1] = element_size // 256\n+        a[MAX_BLOCK_SIGOPS+2] = 0\n+        a[MAX_BLOCK_SIGOPS+3] = 0\n+\n+        tx = create_and_sign_tx(out[22].tx, 0, 1, CScript(a))\n+        b73 = update_block(73, [tx])\n+        assert_equal(get_legacy_sigopcount_block(b73), MAX_BLOCK_SIGOPS+1)\n+        yield rejected(RejectResult(16, b'bad-blk-sigops'))\n+\n+        # b74/75 - if we push an invalid script element, all prevous sigops are counted,\n+        #          but sigops after the element are not counted.\n+        #\n+        #       The invalid script element is that the push_data indicates that\n+        #       there will be a large amount of data (0xffffff bytes), but we only\n+        #       provide a much smaller number.  These bytes are CHECKSIGS so they would\n+        #       cause b75 to fail for excessive sigops, if those bytes were counted.\n+        #\n+        #       b74 fails because we put MAX_BLOCK_SIGOPS+1 before the element\n+        #       b75 succeeds because we put MAX_BLOCK_SIGOPS before the element\n+        #\n+        #\n+        tip(72)\n+        b74 = block(74)\n+        size = MAX_BLOCK_SIGOPS - 1 + MAX_SCRIPT_ELEMENT_SIZE + 42 # total = 20,561\n+        a = bytearray([OP_CHECKSIG] * size)\n+        a[MAX_BLOCK_SIGOPS] = 0x4e\n+        a[MAX_BLOCK_SIGOPS+1] = 0xfe\n+        a[MAX_BLOCK_SIGOPS+2] = 0xff\n+        a[MAX_BLOCK_SIGOPS+3] = 0xff\n+        a[MAX_BLOCK_SIGOPS+4] = 0xff\n+        tx = create_and_sign_tx(out[22].tx, 0, 1, CScript(a))\n+        b74 = update_block(74, [tx])\n+        yield rejected(RejectResult(16, b'bad-blk-sigops'))\n+\n+        tip(72)\n+        b75 = block(75)\n+        size = MAX_BLOCK_SIGOPS - 1 + MAX_SCRIPT_ELEMENT_SIZE + 42\n+        a = bytearray([OP_CHECKSIG] * size)\n+        a[MAX_BLOCK_SIGOPS-1] = 0x4e\n+        a[MAX_BLOCK_SIGOPS] = 0xff\n+        a[MAX_BLOCK_SIGOPS+1] = 0xff\n+        a[MAX_BLOCK_SIGOPS+2] = 0xff\n+        a[MAX_BLOCK_SIGOPS+3] = 0xff\n+        tx = create_and_sign_tx(out[22].tx, 0, 1, CScript(a))\n+        b75 = update_block(75, [tx])\n+        yield accepted()\n+        save_spendable_output()\n+\n+        # Check that if we push an element filled with CHECKSIGs, they are not counted\n+        tip(75)\n+        b76 = block(76)\n+        size = MAX_BLOCK_SIGOPS - 1 + MAX_SCRIPT_ELEMENT_SIZE + 1 + 5\n+        a = bytearray([OP_CHECKSIG] * size)\n+        a[MAX_BLOCK_SIGOPS-1] = 0x4e # PUSHDATA4, but leave the following bytes as just checksigs\n+        tx = create_and_sign_tx(out[23].tx, 0, 1, CScript(a))\n+        b76 = update_block(76, [tx])\n+        yield accepted()\n+        save_spendable_output()\n+\n+        # Test transaction resurrection\n+        #\n+        # -> b77 (24) -> b78 (25) -> b79 (26)\n+        #            \\-> b80 (25) -> b81 (26) -> b82 (27)\n+        #\n+        #    b78 creates a tx, which is spent in b79. After b82, both should be in mempool\n+        #\n+        #    The tx'es must be unsigned and pass the node's mempool policy.  It is unsigned for the\n+        #    rather obscure reason that the Python signature code does not distinguish between\n+        #    Low-S and High-S values (whereas the bitcoin code has custom code which does so);\n+        #    as a result of which, the odds are 50% that the python code will use the right\n+        #    value and the transaction will be accepted into the mempool. Until we modify the\n+        #    test framework to support low-S signing, we are out of luck.\n+        #\n+        #    To get around this issue, we construct transactions which are not signed and which\n+        #    spend to OP_TRUE.  If the standard-ness rules change, this test would need to be\n+        #    updated.  (Perhaps to spend to a P2SH OP_TRUE script)\n+        #\n+        tip(76)\n+        block(77)\n+        tx77 = create_and_sign_tx(out[24].tx, out[24].n, 10*COIN)\n+        update_block(77, [tx77])\n+        yield accepted()\n+        save_spendable_output()\n+\n+        block(78)\n+        tx78 = create_tx(tx77, 0, 9*COIN)\n+        update_block(78, [tx78])\n+        yield accepted()\n+\n+        block(79)\n+        tx79 = create_tx(tx78, 0, 8*COIN)\n+        update_block(79, [tx79])\n+        yield accepted()\n+\n+        # mempool should be empty\n+        assert_equal(len(self.nodes[0].getrawmempool()), 0)\n+\n+        tip(77)\n+        block(80, spend=out[25])\n+        yield rejected()\n+        save_spendable_output()\n+\n+        block(81, spend=out[26])\n+        yield rejected() # other chain is same length\n+        save_spendable_output()\n+\n+        block(82, spend=out[27])\n+        yield accepted()  # now this chain is longer, triggers re-org\n+        save_spendable_output()\n+\n+        # now check that tx78 and tx79 have been put back into the peer's mempool\n+        mempool = self.nodes[0].getrawmempool()\n+        assert_equal(len(mempool), 2)\n+        assert(tx78.hash in mempool)\n+        assert(tx79.hash in mempool)\n+\n+\n+        # Test invalid opcodes in dead execution paths.\n+        #\n+        #  -> b81 (26) -> b82 (27) -> b83 (28)\n+        #\n+        b83 = block(83)\n+        op_codes = [OP_IF, OP_INVALIDOPCODE, OP_ELSE, OP_TRUE, OP_ENDIF]\n+        script = CScript(op_codes)\n+        tx1 = create_and_sign_tx(out[28].tx, out[28].n, out[28].tx.vout[0].nValue, script)\n+\n+        tx2 = create_and_sign_tx(tx1, 0, 0, CScript([OP_TRUE]))\n+        tx2.vin[0].scriptSig = CScript([OP_FALSE])\n+        tx2.rehash()\n+\n+        update_block(83, [tx1, tx2])\n+        yield accepted()\n+        save_spendable_output()\n+\n+\n+        # Reorg on/off blocks that have OP_RETURN in them (and try to spend them)\n+        #\n+        #  -> b81 (26) -> b82 (27) -> b83 (28) -> b84 (29) -> b87 (30) -> b88 (31)\n+        #                                    \\-> b85 (29) -> b86 (30)            \\-> b89a (32)\n+        #\n+        #\n+        b84 = block(84)\n+        tx1 = create_tx(out[29].tx, out[29].n, 0, CScript([OP_RETURN]))\n+        tx1.vout.append(CTxOut(0, CScript([OP_TRUE])))\n+        tx1.vout.append(CTxOut(0, CScript([OP_TRUE])))\n+        tx1.vout.append(CTxOut(0, CScript([OP_TRUE])))\n+        tx1.vout.append(CTxOut(0, CScript([OP_TRUE])))\n+        tx1.calc_sha256()\n+        self.sign_tx(tx1, out[29].tx, out[29].n)\n+        tx1.rehash()\n+        tx2 = create_tx(tx1, 1, 0, CScript([OP_RETURN]))\n+        tx2.vout.append(CTxOut(0, CScript([OP_RETURN])))\n+        tx3 = create_tx(tx1, 2, 0, CScript([OP_RETURN]))\n+        tx3.vout.append(CTxOut(0, CScript([OP_TRUE])))\n+        tx4 = create_tx(tx1, 3, 0, CScript([OP_TRUE]))\n+        tx4.vout.append(CTxOut(0, CScript([OP_RETURN])))\n+        tx5 = create_tx(tx1, 4, 0, CScript([OP_RETURN]))\n+\n+        update_block(84, [tx1,tx2,tx3,tx4,tx5])\n+        yield accepted()\n+        save_spendable_output()\n+\n+        tip(83)\n+        block(85, spend=out[29])\n+        yield rejected()\n+\n+        block(86, spend=out[30])\n+        yield accepted()\n+\n+        tip(84)\n+        block(87, spend=out[30])\n+        yield rejected()\n+        save_spendable_output()\n+\n+        block(88, spend=out[31])\n+        yield accepted()\n+        save_spendable_output()\n+\n+        # trying to spend the OP_RETURN output is rejected\n+        block(\"89a\", spend=out[32])\n+        tx = create_tx(tx1, 0, 0, CScript([OP_TRUE]))\n+        update_block(\"89a\", [tx])\n+        yield rejected()\n+\n+\n+        #  Test re-org of a week's worth of blocks (1088 blocks)\n+        #  This test takes a minute or two and can be accomplished in memory\n+        #\n+        tip(88)\n+        LARGE_REORG_SIZE = 1088\n+        test1 = TestInstance(sync_every_block=False)\n+        spend=out[32]\n+        for i in range(89, LARGE_REORG_SIZE + 89):\n+            b = block(i, spend)\n+            tx = CTransaction()\n+            script_length = MAX_BLOCK_SIZE - len(b.serialize()) - 69\n+            script_output = CScript([b'\\x00' * script_length])\n+            tx.vout.append(CTxOut(0, script_output))\n+            tx.vin.append(CTxIn(COutPoint(b.vtx[1].sha256, 0)))\n+            b = update_block(i, [tx])\n+            assert_equal(len(b.serialize()), MAX_BLOCK_SIZE)\n+            test1.blocks_and_transactions.append([self.tip, True])\n+            save_spendable_output()\n+            spend = get_spendable_output()\n+\n+        yield test1\n+        chain1_tip = i\n+\n+        # now create alt chain of same length\n+        tip(88)\n+        test2 = TestInstance(sync_every_block=False)\n+        for i in range(89, LARGE_REORG_SIZE + 89):\n+            block(\"alt\"+str(i))\n+            test2.blocks_and_transactions.append([self.tip, False])\n+        yield test2\n+\n+        # extend alt chain to trigger re-org\n+        block(\"alt\" + str(chain1_tip + 1))\n+        yield accepted()\n+\n+        # ... and re-org back to the first chain\n+        tip(chain1_tip)\n+        block(chain1_tip + 1)\n+        yield rejected()\n+        block(chain1_tip + 2)\n+        yield accepted()\n+\n+        chain1_tip += 2\n \n \n if __name__ == '__main__':"
      },
      {
        "sha": "26cc3963151edbda2e12c88445a6c019f8630347",
        "filename": "qa/rpc-tests/test_framework/blocktools.py",
        "status": "modified",
        "additions": 19,
        "deletions": 4,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/291f8aa5daf80eed56d6cefa3d410652b412150a/qa/rpc-tests/test_framework/blocktools.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/291f8aa5daf80eed56d6cefa3d410652b412150a/qa/rpc-tests/test_framework/blocktools.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/blocktools.py?ref=291f8aa5daf80eed56d6cefa3d410652b412150a",
        "patch": "@@ -56,12 +56,27 @@ def create_coinbase(height, pubkey = None):\n     coinbase.calc_sha256()\n     return coinbase\n \n-# Create a transaction with an anyone-can-spend output, that spends the\n-# nth output of prevtx.\n-def create_transaction(prevtx, n, sig, value):\n+# Create a transaction.\n+# If the scriptPubKey is not specified, make it anyone-can-spend.\n+def create_transaction(prevtx, n, sig, value, scriptPubKey=CScript()):\n     tx = CTransaction()\n     assert(n < len(prevtx.vout))\n     tx.vin.append(CTxIn(COutPoint(prevtx.sha256, n), sig, 0xffffffff))\n-    tx.vout.append(CTxOut(value, b\"\"))\n+    tx.vout.append(CTxOut(value, scriptPubKey))\n     tx.calc_sha256()\n     return tx\n+\n+def get_legacy_sigopcount_block(block, fAccurate=True):\n+    count = 0\n+    for tx in block.vtx:\n+        count += get_legacy_sigopcount_tx(tx, fAccurate)\n+    return count\n+\n+def get_legacy_sigopcount_tx(tx, fAccurate=True):\n+    count = 0\n+    for i in tx.vout:\n+        count += i.scriptPubKey.GetSigOpCount(fAccurate)\n+    for j in tx.vin:\n+        # scriptSig might be of type bytes, so convert to CScript for the moment\n+        count += CScript(j.scriptSig).GetSigOpCount(fAccurate)\n+    return count"
      },
      {
        "sha": "c0b59f38579d72ac0c2dba44396a831d92ae5188",
        "filename": "qa/rpc-tests/test_framework/mininode.py",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/291f8aa5daf80eed56d6cefa3d410652b412150a/qa/rpc-tests/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/291f8aa5daf80eed56d6cefa3d410652b412150a/qa/rpc-tests/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/mininode.py?ref=291f8aa5daf80eed56d6cefa3d410652b412150a",
        "patch": "@@ -556,7 +556,6 @@ def solve(self):\n             self.nNonce += 1\n             self.rehash()\n \n-\n     def __repr__(self):\n         return \"CBlock(nVersion=%i hashPrevBlock=%064x hashMerkleRoot=%064x nTime=%s nBits=%08x nNonce=%08x vtx=%s)\" \\\n             % (self.nVersion, self.hashPrevBlock, self.hashMerkleRoot,"
      }
    ]
  },
  {
    "sha": "12c5a16c4e635799cfb6cadbca79dfa83555da72",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMmM1YTE2YzRlNjM1Nzk5Y2ZiNmNhZGJjYTc5ZGZhODM1NTVkYTcy",
    "commit": {
      "author": {
        "name": "mrbandrews",
        "email": "bandrewsny@gmail.com",
        "date": "2016-06-02T18:43:18Z"
      },
      "committer": {
        "name": "mrbandrews",
        "email": "bandrewsny@gmail.com",
        "date": "2016-06-02T18:43:18Z"
      },
      "message": "Catch exceptions from non-canonical encoding and print only to log",
      "tree": {
        "sha": "bef0c0207347c5201b380ff3e50a05ee592c8d55",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bef0c0207347c5201b380ff3e50a05ee592c8d55"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/12c5a16c4e635799cfb6cadbca79dfa83555da72",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/12c5a16c4e635799cfb6cadbca79dfa83555da72",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/12c5a16c4e635799cfb6cadbca79dfa83555da72",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/12c5a16c4e635799cfb6cadbca79dfa83555da72/comments",
    "author": {
      "login": "mrbandrews",
      "id": 7504522,
      "node_id": "MDQ6VXNlcjc1MDQ1MjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7504522?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mrbandrews",
      "html_url": "https://github.com/mrbandrews",
      "followers_url": "https://api.github.com/users/mrbandrews/followers",
      "following_url": "https://api.github.com/users/mrbandrews/following{/other_user}",
      "gists_url": "https://api.github.com/users/mrbandrews/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mrbandrews/subscriptions",
      "organizations_url": "https://api.github.com/users/mrbandrews/orgs",
      "repos_url": "https://api.github.com/users/mrbandrews/repos",
      "events_url": "https://api.github.com/users/mrbandrews/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mrbandrews/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mrbandrews",
      "id": 7504522,
      "node_id": "MDQ6VXNlcjc1MDQ1MjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7504522?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mrbandrews",
      "html_url": "https://github.com/mrbandrews",
      "followers_url": "https://api.github.com/users/mrbandrews/followers",
      "following_url": "https://api.github.com/users/mrbandrews/following{/other_user}",
      "gists_url": "https://api.github.com/users/mrbandrews/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mrbandrews/subscriptions",
      "organizations_url": "https://api.github.com/users/mrbandrews/orgs",
      "repos_url": "https://api.github.com/users/mrbandrews/repos",
      "events_url": "https://api.github.com/users/mrbandrews/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mrbandrews/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "291f8aa5daf80eed56d6cefa3d410652b412150a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/291f8aa5daf80eed56d6cefa3d410652b412150a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/291f8aa5daf80eed56d6cefa3d410652b412150a"
      }
    ],
    "stats": {
      "total": 5,
      "additions": 5,
      "deletions": 0
    },
    "files": [
      {
        "sha": "885b1b56fb533dcca37b294c59d26b618f0197ee",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/12c5a16c4e635799cfb6cadbca79dfa83555da72/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/12c5a16c4e635799cfb6cadbca79dfa83555da72/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=12c5a16c4e635799cfb6cadbca79dfa83555da72",
        "patch": "@@ -5567,6 +5567,11 @@ bool ProcessMessages(CNode* pfrom)\n                 // Allow exceptions from over-long size\n                 LogPrintf(\"%s(%s, %u bytes): Exception '%s' caught\\n\", __func__, SanitizeString(strCommand), nMessageSize, e.what());\n             }\n+            else if (strstr(e.what(), \"non-canonical ReadCompactSize()\"))\n+            {\n+                // Allow exceptions from non-canonical encoding\n+                LogPrintf(\"%s(%s, %u bytes): Exception '%s' caught\\n\", __func__, SanitizeString(strCommand), nMessageSize, e.what());\n+            }\n             else\n             {\n                 PrintExceptionContinue(&e, \"ProcessMessages()\");"
      }
    ]
  },
  {
    "sha": "ff2dcf274d8a69de07a8cbd3ada3aaaca38501cf",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmZjJkY2YyNzRkOGE2OWRlMDdhOGNiZDNhZGEzYWFhY2EzODUwMWNm",
    "commit": {
      "author": {
        "name": "mrbandrews",
        "email": "bandrewsny@gmail.com",
        "date": "2016-06-08T19:09:01Z"
      },
      "committer": {
        "name": "mrbandrews",
        "email": "bandrewsny@gmail.com",
        "date": "2016-06-08T19:09:01Z"
      },
      "message": "Tests: Edit bloated varint test and add option for 'barely expensive' tests",
      "tree": {
        "sha": "4a9324fd23d2e26d653de5e4e20cbc5370a814da",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4a9324fd23d2e26d653de5e4e20cbc5370a814da"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ff2dcf274d8a69de07a8cbd3ada3aaaca38501cf",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ff2dcf274d8a69de07a8cbd3ada3aaaca38501cf",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ff2dcf274d8a69de07a8cbd3ada3aaaca38501cf",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ff2dcf274d8a69de07a8cbd3ada3aaaca38501cf/comments",
    "author": {
      "login": "mrbandrews",
      "id": 7504522,
      "node_id": "MDQ6VXNlcjc1MDQ1MjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7504522?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mrbandrews",
      "html_url": "https://github.com/mrbandrews",
      "followers_url": "https://api.github.com/users/mrbandrews/followers",
      "following_url": "https://api.github.com/users/mrbandrews/following{/other_user}",
      "gists_url": "https://api.github.com/users/mrbandrews/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mrbandrews/subscriptions",
      "organizations_url": "https://api.github.com/users/mrbandrews/orgs",
      "repos_url": "https://api.github.com/users/mrbandrews/repos",
      "events_url": "https://api.github.com/users/mrbandrews/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mrbandrews/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mrbandrews",
      "id": 7504522,
      "node_id": "MDQ6VXNlcjc1MDQ1MjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7504522?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mrbandrews",
      "html_url": "https://github.com/mrbandrews",
      "followers_url": "https://api.github.com/users/mrbandrews/followers",
      "following_url": "https://api.github.com/users/mrbandrews/following{/other_user}",
      "gists_url": "https://api.github.com/users/mrbandrews/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mrbandrews/subscriptions",
      "organizations_url": "https://api.github.com/users/mrbandrews/orgs",
      "repos_url": "https://api.github.com/users/mrbandrews/repos",
      "events_url": "https://api.github.com/users/mrbandrews/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mrbandrews/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "12c5a16c4e635799cfb6cadbca79dfa83555da72",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/12c5a16c4e635799cfb6cadbca79dfa83555da72",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/12c5a16c4e635799cfb6cadbca79dfa83555da72"
      }
    ],
    "stats": {
      "total": 98,
      "additions": 53,
      "deletions": 45
    },
    "files": [
      {
        "sha": "17fd40ef1dffd824ba5581bb60126c6d1504a5e1",
        "filename": "qa/rpc-tests/p2p-fullblocktest.py",
        "status": "modified",
        "additions": 53,
        "deletions": 45,
        "changes": 98,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ff2dcf274d8a69de07a8cbd3ada3aaaca38501cf/qa/rpc-tests/p2p-fullblocktest.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ff2dcf274d8a69de07a8cbd3ada3aaaca38501cf/qa/rpc-tests/p2p-fullblocktest.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-fullblocktest.py?ref=ff2dcf274d8a69de07a8cbd3ada3aaaca38501cf",
        "patch": "@@ -65,6 +65,10 @@ def __init__(self):\n         self.tip = None\n         self.blocks = {}\n \n+    def add_options(self, parser):\n+        super().add_options(parser)\n+        parser.add_option(\"--runbarelyexpensive\", dest=\"runbarelyexpensive\", default=True)\n+\n     def run_test(self):\n         self.test = TestManager(self, self.options.tmpdir)\n         self.test.add_all_connections(self.nodes)\n@@ -875,10 +879,13 @@ def update_block(block_number, new_transactions):\n         yield rejected(RejectResult(16, b'bad-txns-nonfinal'))\n \n \n-        #  This checks that a block with a bloated VARINT between the block_header and the array of tx is rejected\n-        #  (previous behavior was that it was accepted.)  It also checks that if you subsequently send that block\n-        #  with correct encoding, it should be accepted (i.e., the receiving node should not reject it on the\n-        #  basis that it's the same as an already-rejected block, which would be a DoS vulnerability.)\n+        #  This checks that a block with a bloated VARINT between the block_header and the array of tx such that\n+        #  the block is > MAX_BLOCK_SIZE with the bloated varint, but <= MAX_BLOCK_SIZE without the bloated varint,\n+        #  does not cause a subsequent, identical block with canonical encoding to be rejected.  The test does not\n+        #  care whether the bloated block is accepted or rejected; it only cares that the second block is accepted.\n+        #\n+        #  What matters is that the receiving node should not reject the bloated block, and then reject the canonical\n+        #  block on the basis that it's the same as an already-rejected block (which would be a consensus failure.)\n         #\n         #  -> b39 (11) -> b42 (12) -> b43 (13) -> b53 (14) -> b55 (15) -> b57 (16) -> b60 (17) -> b64 (18)\n         #                                                                                        \\\n@@ -903,7 +910,7 @@ def update_block(block_number, new_transactions):\n         tx.vin.append(CTxIn(COutPoint(b64a.vtx[1].sha256, 0)))\n         b64a = update_block(\"64a\", [tx])\n         assert_equal(len(b64a.serialize()), MAX_BLOCK_SIZE + 8)\n-        yield rejected()\n+        yield TestInstance([[self.tip, None]])\n \n         # comptool workaround: to make sure b64 is delivered, manually erase b64a from blockstore\n         self.test.block_store.erase(b64a.sha256)\n@@ -941,7 +948,6 @@ def update_block(block_number, new_transactions):\n         update_block(66, [tx2, tx1])\n         yield rejected(RejectResult(16, b'bad-txns-inputs-missingorspent'))\n \n-\n         # Attempt to double-spend a transaction created in a block\n         #\n         # -> b43 (13) -> b53 (14) -> b55 (15) -> b57 (16) -> b60 (17) -> b64 (18) -> b65 (19)\n@@ -1239,46 +1245,48 @@ def update_block(block_number, new_transactions):\n         #  Test re-org of a week's worth of blocks (1088 blocks)\n         #  This test takes a minute or two and can be accomplished in memory\n         #\n-        tip(88)\n-        LARGE_REORG_SIZE = 1088\n-        test1 = TestInstance(sync_every_block=False)\n-        spend=out[32]\n-        for i in range(89, LARGE_REORG_SIZE + 89):\n-            b = block(i, spend)\n-            tx = CTransaction()\n-            script_length = MAX_BLOCK_SIZE - len(b.serialize()) - 69\n-            script_output = CScript([b'\\x00' * script_length])\n-            tx.vout.append(CTxOut(0, script_output))\n-            tx.vin.append(CTxIn(COutPoint(b.vtx[1].sha256, 0)))\n-            b = update_block(i, [tx])\n-            assert_equal(len(b.serialize()), MAX_BLOCK_SIZE)\n-            test1.blocks_and_transactions.append([self.tip, True])\n-            save_spendable_output()\n-            spend = get_spendable_output()\n-\n-        yield test1\n-        chain1_tip = i\n-\n-        # now create alt chain of same length\n-        tip(88)\n-        test2 = TestInstance(sync_every_block=False)\n-        for i in range(89, LARGE_REORG_SIZE + 89):\n-            block(\"alt\"+str(i))\n-            test2.blocks_and_transactions.append([self.tip, False])\n-        yield test2\n-\n-        # extend alt chain to trigger re-org\n-        block(\"alt\" + str(chain1_tip + 1))\n-        yield accepted()\n-\n-        # ... and re-org back to the first chain\n-        tip(chain1_tip)\n-        block(chain1_tip + 1)\n-        yield rejected()\n-        block(chain1_tip + 2)\n-        yield accepted()\n+        if self.options.runbarelyexpensive:\n+            tip(88)\n+            LARGE_REORG_SIZE = 1088\n+            test1 = TestInstance(sync_every_block=False)\n+            spend=out[32]\n+            for i in range(89, LARGE_REORG_SIZE + 89):\n+                b = block(i, spend)\n+                tx = CTransaction()\n+                script_length = MAX_BLOCK_SIZE - len(b.serialize()) - 69\n+                script_output = CScript([b'\\x00' * script_length])\n+                tx.vout.append(CTxOut(0, script_output))\n+                tx.vin.append(CTxIn(COutPoint(b.vtx[1].sha256, 0)))\n+                b = update_block(i, [tx])\n+                assert_equal(len(b.serialize()), MAX_BLOCK_SIZE)\n+                test1.blocks_and_transactions.append([self.tip, True])\n+                save_spendable_output()\n+                spend = get_spendable_output()\n+\n+            yield test1\n+            chain1_tip = i\n+\n+            # now create alt chain of same length\n+            tip(88)\n+            test2 = TestInstance(sync_every_block=False)\n+            for i in range(89, LARGE_REORG_SIZE + 89):\n+                block(\"alt\"+str(i))\n+                test2.blocks_and_transactions.append([self.tip, False])\n+            yield test2\n+\n+            # extend alt chain to trigger re-org\n+            block(\"alt\" + str(chain1_tip + 1))\n+            yield accepted()\n+\n+            # ... and re-org back to the first chain\n+            tip(chain1_tip)\n+            block(chain1_tip + 1)\n+            yield rejected()\n+            block(chain1_tip + 2)\n+            yield accepted()\n+\n+            chain1_tip += 2\n \n-        chain1_tip += 2\n \n \n if __name__ == '__main__':"
      }
    ]
  }
]