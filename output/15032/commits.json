[
  {
    "sha": "291130c939ae5e3f15c5c6144a037746db9dca59",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyOTExMzBjOTM5YWU1ZTNmMTVjNWM2MTQ0YTAzNzc0NmRiOWRjYTU5",
    "commit": {
      "author": {
        "name": "MeshCollider",
        "email": "dobsonsa68@gmail.com",
        "date": "2018-12-24T11:49:16Z"
      },
      "committer": {
        "name": "MeshCollider",
        "email": "dobsonsa68@gmail.com",
        "date": "2019-02-05T06:48:53Z"
      },
      "message": "Nits from PR 14565",
      "tree": {
        "sha": "fc44c3c90bc0711c180abc9bd93fdfc4764bc876",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fc44c3c90bc0711c180abc9bd93fdfc4764bc876"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/291130c939ae5e3f15c5c6144a037746db9dca59",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/291130c939ae5e3f15c5c6144a037746db9dca59",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/291130c939ae5e3f15c5c6144a037746db9dca59",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/291130c939ae5e3f15c5c6144a037746db9dca59/comments",
    "author": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e50853501b79378597edbcd6dd217819c057de4b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e50853501b79378597edbcd6dd217819c057de4b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e50853501b79378597edbcd6dd217819c057de4b"
      }
    ],
    "stats": {
      "total": 38,
      "additions": 27,
      "deletions": 11
    },
    "files": [
      {
        "sha": "124a7a99618d4f1199e71dfa5ff6cfb1dff64427",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 3,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/291130c939ae5e3f15c5c6144a037746db9dca59/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/291130c939ae5e3f15c5c6144a037746db9dca59/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=291130c939ae5e3f15c5c6144a037746db9dca59",
        "patch": "@@ -964,6 +964,11 @@ static std::string RecurseImportData(const CScript& script, ImportData& import_d\n     }\n }\n \n+/**\n+ * ProcessImport is called once for each request within an importmulti call.\n+ * All input data is parsed and validated first. Then scripts, pubkeys and keys are imported.\n+ * This function doesn't throw - all errors are caught and returned in the error field.\n+ */\n static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n     UniValue warnings(UniValue::VARR);\n@@ -1046,7 +1051,7 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             const auto& str = keys[i].get_str();\n             CKey key = DecodeSecret(str);\n             if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(\"Invalid private key encoding at index %zu\", i));\n             }\n             CPubKey pubkey = key.GetPubKey();\n             CKeyID id = pubkey.GetID();\n@@ -1081,7 +1086,9 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n                 for (const auto& require_key : import_data.used_keys) {\n                     if (!require_key.second) continue; // Not a required key\n                     if (pubkey_map.count(require_key.first) == 0 && privkey_map.count(require_key.first) == 0) {\n-                        error = \"some required keys are missing\";\n+                        if (error.empty()) error = \"some required keys are missing: \";\n+                        else error += \", \";\n+                        error += HexStr(require_key.first);\n                     }\n                 }\n             }\n@@ -1116,7 +1123,7 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n \n         // Check whether we have any work to do\n         if (::IsMine(*pwallet, script) & ISMINE_SPENDABLE) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"This address or script is already owned by the wallet\");\n         }\n \n         // All good, time to import"
      },
      {
        "sha": "74898bb1139b0b8571b6543b3e365bf41e7b66c3",
        "filename": "test/functional/wallet_importmulti.py",
        "status": "modified",
        "additions": 17,
        "deletions": 8,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/291130c939ae5e3f15c5c6144a037746db9dca59/test/functional/wallet_importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/291130c939ae5e3f15c5c6144a037746db9dca59/test/functional/wallet_importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_importmulti.py?ref=291130c939ae5e3f15c5c6144a037746db9dca59",
        "patch": "@@ -18,13 +18,15 @@\n from test_framework.script import (\n     CScript,\n     OP_NOP,\n+    hash160,\n )\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n     assert_greater_than,\n     assert_raises_rpc_error,\n     bytes_to_hex_str,\n+    hex_str_to_bytes,\n )\n from test_framework.wallet_util import (\n     get_key,\n@@ -44,13 +46,15 @@ def skip_test_if_missing_module(self):\n     def setup_network(self):\n         self.setup_nodes()\n \n-    def test_importmulti(self, req, success, error_code=None, error_message=None, warnings=[]):\n+    def test_importmulti(self, req, success, error_code=None, error_message=None, warnings=None):\n         \"\"\"Run importmulti and assert success\"\"\"\n         result = self.nodes[1].importmulti([req])\n         observed_warnings = []\n+        if warnings is None:\n+            warnings = []\n         if 'warnings' in result[0]:\n-           observed_warnings = result[0]['warnings']\n-        assert_equal(\"\\n\".join(sorted(warnings)), \"\\n\".join(sorted(observed_warnings)))\n+            observed_warnings = result[0]['warnings']\n+        assert_equal(sorted(warnings), sorted(observed_warnings))\n         assert_equal(result[0]['success'], success)\n         if error_code is not None:\n             assert_equal(result[0]['error']['code'], error_code)\n@@ -203,7 +207,7 @@ def run_test(self):\n                                \"keys\": [key.privkey]},\n                               success=False,\n                               error_code=-4,\n-                              error_message='The wallet already contains the private key for this address or script')\n+                              error_message='This address or script is already owned by the wallet')\n \n         # Address + Private key + watchonly\n         self.log.info(\"Should import an address with private key and with watchonly\")\n@@ -338,12 +342,13 @@ def run_test(self):\n         # Address + Public key + !Internal + Wrong pubkey\n         self.log.info(\"Should not import an address with the wrong public key as non-solvable\")\n         key = get_key(self.nodes[0])\n+        pkh = hash160(hex_str_to_bytes(key.pubkey))\n         wrong_key = get_key(self.nodes[0]).pubkey\n         self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2pkh_addr},\n                                \"timestamp\": \"now\",\n                                \"pubkeys\": [wrong_key]},\n                               success=True,\n-                              warnings=[\"Importing as non-solvable: some required keys are missing. If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\", \"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n+                              warnings=[\"Importing as non-solvable: some required keys are missing: \" + bytes_to_hex_str(pkh) + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\", \"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n         test_address(self.nodes[1],\n                      key.p2pkh_addr,\n                      iswatchonly=True,\n@@ -354,13 +359,14 @@ def run_test(self):\n         # ScriptPubKey + Public key + internal + Wrong pubkey\n         self.log.info(\"Should import a scriptPubKey with internal and with a wrong public key as non-solvable\")\n         key = get_key(self.nodes[0])\n+        pkh = hash160(hex_str_to_bytes(key.pubkey))\n         wrong_key = get_key(self.nodes[0]).pubkey\n         self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n                                \"timestamp\": \"now\",\n                                \"pubkeys\": [wrong_key],\n                                \"internal\": True},\n                               success=True,\n-                              warnings=[\"Importing as non-solvable: some required keys are missing. If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\", \"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n+                              warnings=[\"Importing as non-solvable: some required keys are missing: \" + bytes_to_hex_str(pkh) + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\", \"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n         test_address(self.nodes[1],\n                      key.p2pkh_addr,\n                      iswatchonly=True,\n@@ -371,12 +377,13 @@ def run_test(self):\n         # Address + Private key + !watchonly + Wrong private key\n         self.log.info(\"Should import an address with a wrong private key as non-solvable\")\n         key = get_key(self.nodes[0])\n+        pkh = hash160(hex_str_to_bytes(key.pubkey))\n         wrong_privkey = get_key(self.nodes[0]).privkey\n         self.test_importmulti({\"scriptPubKey\": {\"address\": key.p2pkh_addr},\n                                \"timestamp\": \"now\",\n                                \"keys\": [wrong_privkey]},\n                                success=True,\n-                               warnings=[\"Importing as non-solvable: some required keys are missing. If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\", \"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n+                               warnings=[\"Importing as non-solvable: some required keys are missing: \" + bytes_to_hex_str(pkh) + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\", \"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n         test_address(self.nodes[1],\n                      key.p2pkh_addr,\n                      iswatchonly=True,\n@@ -387,13 +394,14 @@ def run_test(self):\n         # ScriptPubKey + Private key + internal + Wrong private key\n         self.log.info(\"Should import a scriptPubKey with internal and with a wrong private key as non-solvable\")\n         key = get_key(self.nodes[0])\n+        pkh = hash160(hex_str_to_bytes(key.pubkey))\n         wrong_privkey = get_key(self.nodes[0]).privkey\n         self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n                                \"timestamp\": \"now\",\n                                \"keys\": [wrong_privkey],\n                                \"internal\": True},\n                               success=True,\n-                              warnings=[\"Importing as non-solvable: some required keys are missing. If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\", \"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n+                              warnings=[\"Importing as non-solvable: some required keys are missing: \" + bytes_to_hex_str(pkh) + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\", \"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n         test_address(self.nodes[1],\n                      key.p2pkh_addr,\n                      iswatchonly=True,\n@@ -540,6 +548,7 @@ def run_test(self):\n                               warnings=[\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\"])\n         test_address(self.nodes[1],\n                      multisig.p2sh_p2wsh_addr,\n+                     iswatchonly=True,\n                      solvable=True,\n                      ismine=False)\n "
      }
    ]
  },
  {
    "sha": "6e51d1d6dbf8d27a3efc1f17358830c7b3a771c3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2ZTUxZDFkNmRiZjhkMjdhM2VmYzFmMTczNTg4MzBjN2IzYTc3MWMz",
    "commit": {
      "author": {
        "name": "MeshCollider",
        "email": "dobsonsa68@gmail.com",
        "date": "2018-12-24T12:07:48Z"
      },
      "committer": {
        "name": "MeshCollider",
        "email": "dobsonsa68@gmail.com",
        "date": "2019-02-05T10:27:03Z"
      },
      "message": "Make AddKeyPubKey accept timestamp for metadata",
      "tree": {
        "sha": "4bdc2b832bfb74026bee9e1b04a3e68ec6b93d52",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4bdc2b832bfb74026bee9e1b04a3e68ec6b93d52"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6e51d1d6dbf8d27a3efc1f17358830c7b3a771c3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6e51d1d6dbf8d27a3efc1f17358830c7b3a771c3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6e51d1d6dbf8d27a3efc1f17358830c7b3a771c3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6e51d1d6dbf8d27a3efc1f17358830c7b3a771c3/comments",
    "author": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "meshcollider",
      "id": 3211283,
      "node_id": "MDQ6VXNlcjMyMTEyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3211283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/meshcollider",
      "html_url": "https://github.com/meshcollider",
      "followers_url": "https://api.github.com/users/meshcollider/followers",
      "following_url": "https://api.github.com/users/meshcollider/following{/other_user}",
      "gists_url": "https://api.github.com/users/meshcollider/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/meshcollider/subscriptions",
      "organizations_url": "https://api.github.com/users/meshcollider/orgs",
      "repos_url": "https://api.github.com/users/meshcollider/repos",
      "events_url": "https://api.github.com/users/meshcollider/events{/privacy}",
      "received_events_url": "https://api.github.com/users/meshcollider/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "291130c939ae5e3f15c5c6144a037746db9dca59",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/291130c939ae5e3f15c5c6144a037746db9dca59",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/291130c939ae5e3f15c5c6144a037746db9dca59"
      }
    ],
    "stats": {
      "total": 22,
      "additions": 14,
      "deletions": 8
    },
    "files": [
      {
        "sha": "977156e3cc58cfadb9f9b691a910ab46d4929d25",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 8,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6e51d1d6dbf8d27a3efc1f17358830c7b3a771c3/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6e51d1d6dbf8d27a3efc1f17358830c7b3a771c3/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=6e51d1d6dbf8d27a3efc1f17358830c7b3a771c3",
        "patch": "@@ -186,10 +186,7 @@ UniValue importprivkey(const JSONRPCRequest& request)\n             }\n \n             // whenever a key is imported, we need to scan the whole chain\n-            pwallet->UpdateTimeFirstKey(1);\n-            pwallet->mapKeyMetadata[vchAddress].nCreateTime = 1;\n-\n-            if (!pwallet->AddKeyPubKey(key, pubkey)) {\n+            if (!pwallet->AddKeyPubKey(key, pubkey, 1)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n             }\n             pwallet->LearnAllRelatedScripts(pubkey);\n@@ -651,7 +648,8 @@ UniValue importwallet(const JSONRPCRequest& request)\n                 continue;\n             }\n             pwallet->WalletLogPrintf(\"Importing %s...\\n\", EncodeDestination(keyid));\n-            if (!pwallet->AddKeyPubKey(key, pubkey)) {\n+            nTimeBegin = std::min(nTimeBegin, time);\n+            if (!pwallet->AddKeyPubKey(key, pubkey, time)) {\n                 fGood = false;\n                 continue;\n             }\n@@ -1138,12 +1136,10 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n             CPubKey pubkey = key.GetPubKey();\n             const CKeyID& id = entry.first;\n             assert(key.VerifyPubKey(pubkey));\n-            pwallet->mapKeyMetadata[id].nCreateTime = timestamp;\n             // If the private key is not present in the wallet, insert it.\n-            if (!pwallet->HaveKey(id) && !pwallet->AddKeyPubKey(key, pubkey)) {\n+            if (!pwallet->HaveKey(id) && !pwallet->AddKeyPubKey(key, pubkey, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n             }\n-            pwallet->UpdateTimeFirstKey(timestamp);\n         }\n         for (const auto& entry : pubkey_map) {\n             const CPubKey& pubkey = entry.second;"
      },
      {
        "sha": "b12341da8fecc36bd78b06ab2b715279573f3326",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6e51d1d6dbf8d27a3efc1f17358830c7b3a771c3/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6e51d1d6dbf8d27a3efc1f17358830c7b3a771c3/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=6e51d1d6dbf8d27a3efc1f17358830c7b3a771c3",
        "patch": "@@ -288,10 +288,18 @@ bool CWallet::AddKeyPubKeyWithDB(WalletBatch &batch, const CKey& secret, const C\n \n bool CWallet::AddKeyPubKey(const CKey& secret, const CPubKey &pubkey)\n {\n+    const CKeyMetadata& meta = mapKeyMetadata[pubkey.GetID()];\n+    UpdateTimeFirstKey(meta.nCreateTime);\n     WalletBatch batch(*database);\n     return CWallet::AddKeyPubKeyWithDB(batch, secret, pubkey);\n }\n \n+bool CWallet::AddKeyPubKey(const CKey& secret, const CPubKey &pubkey, int64_t create_time)\n+{\n+    mapKeyMetadata[pubkey.GetID()].nCreateTime = create_time;\n+    return AddKeyPubKey(secret, pubkey);\n+}\n+\n bool CWallet::AddCryptedKey(const CPubKey &vchPubKey,\n                             const std::vector<unsigned char> &vchCryptedSecret)\n {"
      },
      {
        "sha": "e5d0d1ab557c6f44e8e9539bf9b98ff80cd1d11c",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6e51d1d6dbf8d27a3efc1f17358830c7b3a771c3/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6e51d1d6dbf8d27a3efc1f17358830c7b3a771c3/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=6e51d1d6dbf8d27a3efc1f17358830c7b3a771c3",
        "patch": "@@ -847,6 +847,8 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     CPubKey GenerateNewKey(WalletBatch& batch, bool internal = false) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     //! Adds a key to the store, and saves it to disk.\n     bool AddKeyPubKey(const CKey& key, const CPubKey &pubkey) override EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+    //! Adds a key to the store and saves it to disk after updating its metadata creation time.\n+    bool AddKeyPubKey(const CKey& key, const CPubKey &pubkey, int64_t create_time) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     bool AddKeyPubKeyWithDB(WalletBatch &batch,const CKey& key, const CPubKey &pubkey) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     //! Adds a key to the store, without saving it to disk (used by LoadWallet)\n     bool LoadKey(const CKey& key, const CPubKey &pubkey) { return CCryptoKeyStore::AddKeyPubKey(key, pubkey); }"
      }
    ]
  }
]