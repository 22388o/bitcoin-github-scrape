[
  {
    "sha": "8e2ecfe2496d8a015f3ee8723025a438feffbd28",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4ZTJlY2ZlMjQ5NmQ4YTAxNWYzZWU4NzIzMDI1YTQzOGZlZmZiZDI4",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-12-11T21:41:40Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2020-03-17T17:27:39Z"
      },
      "message": "validation: add CChainState.m_from_snapshot_blockhash\n\nThis parameter is unused, but in future commits will allow ChainstateManager to\ndifferentiate between chainstates created from a UTXO snapshot from those that\nweren't.",
      "tree": {
        "sha": "5e9c5694508d57a7317d66e14f310f31e056aeec",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5e9c5694508d57a7317d66e14f310f31e056aeec"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8e2ecfe2496d8a015f3ee8723025a438feffbd28",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8e2ecfe2496d8a015f3ee8723025a438feffbd28",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8e2ecfe2496d8a015f3ee8723025a438feffbd28",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8e2ecfe2496d8a015f3ee8723025a438feffbd28/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d2d0a04a661fde731a212b0489fe211566ff5ca8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d2d0a04a661fde731a212b0489fe211566ff5ca8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d2d0a04a661fde731a212b0489fe211566ff5ca8"
      }
    ],
    "stats": {
      "total": 19,
      "additions": 16,
      "deletions": 3
    },
    "files": [
      {
        "sha": "31b78380affd90f5b5a65eac1028f61915800cba",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8e2ecfe2496d8a015f3ee8723025a438feffbd28/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8e2ecfe2496d8a015f3ee8723025a438feffbd28/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=8e2ecfe2496d8a015f3ee8723025a438feffbd28",
        "patch": "@@ -1244,7 +1244,9 @@ void CoinsViews::InitCache()\n \n // NOTE: for now m_blockman is set to a global, but this will be changed\n // in a future commit.\n-CChainState::CChainState() : m_blockman(g_blockman) {}\n+CChainState::CChainState(uint256 from_snapshot_blockhash)\n+    : m_blockman(g_blockman),\n+      m_from_snapshot_blockhash(from_snapshot_blockhash) {}\n \n \n void CChainState::InitCoinsDB(\n@@ -1253,6 +1255,10 @@ void CChainState::InitCoinsDB(\n     bool should_wipe,\n     std::string leveldb_name)\n {\n+    if (!m_from_snapshot_blockhash.IsNull()) {\n+        leveldb_name += \"_\" + m_from_snapshot_blockhash.ToString();\n+    }\n+\n     m_coins_views = MakeUnique<CoinsViews>(\n         leveldb_name, cache_size_bytes, in_memory, should_wipe);\n }"
      },
      {
        "sha": "07d90ab11006c7bf5acfbc53635e9f337404390f",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 9,
        "deletions": 2,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8e2ecfe2496d8a015f3ee8723025a438feffbd28/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8e2ecfe2496d8a015f3ee8723025a438feffbd28/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=8e2ecfe2496d8a015f3ee8723025a438feffbd28",
        "patch": "@@ -591,8 +591,8 @@ class CChainState {\n     std::unique_ptr<CoinsViews> m_coins_views;\n \n public:\n-    CChainState(BlockManager& blockman) : m_blockman(blockman) {}\n-    CChainState();\n+    explicit CChainState(BlockManager& blockman) : m_blockman(blockman) {}\n+    explicit CChainState(uint256 from_snapshot_blockhash = uint256());\n \n     /**\n      * Initialize the CoinsViews UTXO set database management data structures. The in-memory\n@@ -620,6 +620,13 @@ class CChainState {\n     //! @see CChain, CBlockIndex.\n     CChain m_chain;\n \n+    /**\n+     * The blockhash which is the base of the snapshot this chainstate was created from.\n+     *\n+     * IsNull() if this chainstate was not created from a snapshot.\n+     */\n+    const uint256 m_from_snapshot_blockhash{};\n+\n     /**\n      * The set of all CBlockIndex entries with BLOCK_VALID_TRANSACTIONS (for itself and all ancestors) and\n      * as good as our current tip or better. Entries may be failed, though, and pruning nodes may be"
      }
    ]
  },
  {
    "sha": "89cdf4d5692d396b8c7177b3918aa9dab07f9624",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4OWNkZjRkNTY5MmQzOTZiOGM3MTc3YjM5MThhYTlkYWIwN2Y5NjI0",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-12-12T15:20:44Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2020-03-17T17:27:39Z"
      },
      "message": "validation: introduce unused ChainstateManager\n\nChainstateManager is responsible for creating and managing multiple\nchainstates, and will provide a high-level interface for accessing the\nappropriate chainstate based upon a certain use.\n\nIncorporates feedback from Marco Falke. Additional documentation written\nby Russ Yanofsky.\n\nCo-authored-by: Russell Yanofsky <russ@yanofsky.org>",
      "tree": {
        "sha": "fee6785bd277c90c0c50cb9572b67d510c349ed0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fee6785bd277c90c0c50cb9572b67d510c349ed0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/89cdf4d5692d396b8c7177b3918aa9dab07f9624",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/89cdf4d5692d396b8c7177b3918aa9dab07f9624",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/89cdf4d5692d396b8c7177b3918aa9dab07f9624",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/89cdf4d5692d396b8c7177b3918aa9dab07f9624/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8e2ecfe2496d8a015f3ee8723025a438feffbd28",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8e2ecfe2496d8a015f3ee8723025a438feffbd28",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8e2ecfe2496d8a015f3ee8723025a438feffbd28"
      }
    ],
    "stats": {
      "total": 209,
      "additions": 209,
      "deletions": 0
    },
    "files": [
      {
        "sha": "a6b1344792d949910f63b84368349784aff6883a",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 96,
        "deletions": 0,
        "changes": 96,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/89cdf4d5692d396b8c7177b3918aa9dab07f9624/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/89cdf4d5692d396b8c7177b3918aa9dab07f9624/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=89cdf4d5692d396b8c7177b3918aa9dab07f9624",
        "patch": "@@ -20,6 +20,7 @@\n #include <index/txindex.h>\n #include <logging.h>\n #include <logging/timer.h>\n+#include <optional.h>\n #include <policy/fees.h>\n #include <policy/policy.h>\n #include <policy/settings.h>\n@@ -4950,6 +4951,14 @@ void CChainState::CheckBlockIndex(const Consensus::Params& consensusParams)\n     assert(nNodes == forward.size());\n }\n \n+std::string CChainState::ToString()\n+{\n+    CBlockIndex* tip = m_chain.Tip();\n+    return strprintf(\"Chainstate [%s] @ height %d (%s)\",\n+        m_from_snapshot_blockhash.IsNull() ? \"ibd\" : \"snapshot\",\n+        tip ? tip->nHeight : -1, tip ? tip->GetBlockHash().ToString() : \"null\");\n+}\n+\n std::string CBlockFileInfo::ToString() const\n {\n     return strprintf(\"CBlockFileInfo(blocks=%u, size=%u, heights=%u...%u, time=%s...%s)\", nBlocks, nSize, nHeightFirst, nHeightLast, FormatISO8601Date(nTimeFirst), FormatISO8601Date(nTimeLast));\n@@ -5144,3 +5153,90 @@ class CMainCleanup\n     }\n };\n static CMainCleanup instance_of_cmaincleanup;\n+\n+Optional<uint256> ChainstateManager::SnapshotBlockhash() const {\n+    if (m_active_chainstate != nullptr) {\n+        // If a snapshot chainstate exists, it will always be our active.\n+        return m_active_chainstate->m_from_snapshot_blockhash;\n+    }\n+    return {};\n+}\n+\n+std::vector<CChainState*> ChainstateManager::GetAll()\n+{\n+    std::vector<CChainState*> out;\n+\n+    if (!IsSnapshotValidated() && m_ibd_chainstate) {\n+        out.push_back(m_ibd_chainstate.get());\n+    }\n+\n+    if (m_snapshot_chainstate) {\n+        out.push_back(m_snapshot_chainstate.get());\n+    }\n+\n+    return out;\n+}\n+\n+CChainState& ChainstateManager::InitializeChainstate(const uint256& snapshot_blockhash)\n+{\n+    bool is_snapshot = !snapshot_blockhash.IsNull();\n+    std::unique_ptr<CChainState>& to_modify =\n+        is_snapshot ? m_snapshot_chainstate : m_ibd_chainstate;\n+\n+    if (to_modify) {\n+        throw std::logic_error(\"should not be overwriting a chainstate\");\n+    }\n+\n+    to_modify.reset(new CChainState(snapshot_blockhash));\n+\n+    // Snapshot chainstates and initial IBD chaintates always become active.\n+    if (is_snapshot || (!is_snapshot && !m_active_chainstate)) {\n+        LogPrintf(\"Switching active chainstate to %s\\n\", to_modify->ToString());\n+        m_active_chainstate = to_modify.get();\n+    } else {\n+        throw std::logic_error(\"unexpected chainstate activation\");\n+    }\n+\n+    return *to_modify;\n+}\n+\n+CChain& ChainstateManager::ActiveChain() const\n+{\n+    assert(m_active_chainstate);\n+    return m_active_chainstate->m_chain;\n+}\n+\n+bool ChainstateManager::IsSnapshotActive() const\n+{\n+    return m_snapshot_chainstate && m_active_chainstate == m_snapshot_chainstate.get();\n+}\n+\n+CChainState& ChainstateManager::ValidatedChainstate() const\n+{\n+    if (m_snapshot_chainstate && IsSnapshotValidated()) {\n+        return *m_snapshot_chainstate.get();\n+    }\n+    assert(m_ibd_chainstate);\n+    return *m_ibd_chainstate.get();\n+}\n+\n+bool ChainstateManager::IsBackgroundIBD(CChainState* chainstate) const\n+{\n+    return (m_snapshot_chainstate && chainstate == m_ibd_chainstate.get());\n+}\n+\n+void ChainstateManager::Unload()\n+{\n+    for (CChainState* chainstate : this->GetAll()) {\n+        chainstate->m_chain.SetTip(nullptr);\n+        chainstate->UnloadBlockIndex();\n+    }\n+}\n+\n+void ChainstateManager::Reset()\n+{\n+    m_ibd_chainstate.reset();\n+    m_snapshot_chainstate.reset();\n+    m_active_chainstate = nullptr;\n+    m_snapshot_validated = false;\n+}"
      },
      {
        "sha": "35e4380bc025b97ea1dc0a7ef157a0c0f1d20600",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 113,
        "deletions": 0,
        "changes": 113,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/89cdf4d5692d396b8c7177b3918aa9dab07f9624/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/89cdf4d5692d396b8c7177b3918aa9dab07f9624/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=89cdf4d5692d396b8c7177b3918aa9dab07f9624",
        "patch": "@@ -14,6 +14,7 @@\n #include <coins.h>\n #include <crypto/common.h> // for ReadLE64\n #include <fs.h>\n+#include <optional.h>\n #include <policy/feerate.h>\n #include <protocol.h> // For CMessageHeader::MessageStartChars\n #include <script/script_error.h>\n@@ -539,6 +540,9 @@ enum class CoinsCacheSizeState\n     OK = 0\n };\n \n+// Defined below, but needed for `friend` usage in CChainState.\n+class ChainstateManager;\n+\n /**\n  * CChainState stores and provides an API to update our local knowledge of the\n  * current best chain.\n@@ -748,6 +752,8 @@ class CChainState {\n         size_t max_coins_cache_size_bytes,\n         size_t max_mempool_size_bytes) EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n \n+    std::string ToString() EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n+\n private:\n     bool ActivateBestChainStep(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexMostWork, const std::shared_ptr<const CBlock>& pblock, bool& fInvalidFound, ConnectTrace& connectTrace) EXCLUSIVE_LOCKS_REQUIRED(cs_main, ::mempool.cs);\n     bool ConnectTip(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace, DisconnectedBlockTransactions& disconnectpool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, ::mempool.cs);\n@@ -760,6 +766,8 @@ class CChainState {\n \n     //! Mark a block as not having block data\n     void EraseBlockData(CBlockIndex* index) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    friend ChainstateManager;\n };\n \n /** Mark a block as precious and reorganize.\n@@ -775,6 +783,111 @@ bool InvalidateBlock(BlockValidationState& state, const CChainParams& chainparam\n /** Remove invalidity status from a block and its descendants. */\n void ResetBlockFailureFlags(CBlockIndex* pindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n+/**\n+ * Provides an interface for creating and interacting with one or two\n+ * chainstates: an IBD chainstate generated by downloading blocks, and\n+ * an optional snapshot chainstate loaded from a UTXO snapshot. Managed\n+ * chainstates can be maintained at different heights simultaneously.\n+ *\n+ * This class provides abstractions that allow the retrieval of the current\n+ * most-work chainstate (\"Active\") as well as chainstates which may be in\n+ * background use to validate UTXO snapshots.\n+ *\n+ * Definitions:\n+ *\n+ * *IBD chainstate*: a chainstate whose current state has been \"fully\"\n+ *   validated by the initial block download process.\n+ *\n+ * *Snapshot chainstate*: a chainstate populated by loading in an\n+ *    assumeutxo UTXO snapshot.\n+ *\n+ * *Active chainstate*: the chainstate containing the current most-work\n+ *    chain. Consulted by most parts of the system (net_processing,\n+ *    wallet) as a reflection of the current chain and UTXO set.\n+ *    This may either be an IBD chainstate or a snapshot chainstate.\n+ *\n+ * *Background IBD chainstate*: an IBD chainstate for which the\n+ *    IBD process is happening in the background while use of the\n+ *    active (snapshot) chainstate allows the rest of the system to function.\n+ *\n+ * *Validated chainstate*: the most-work chainstate which has been validated\n+ *   locally via initial block download. This will be the snapshot chainstate\n+ *   if a snapshot was loaded and all blocks up to the snapshot starting point\n+ *   have been downloaded and validated (via background validation), otherwise\n+ *   it will be the IBD chainstate.\n+ */\n+class ChainstateManager\n+{\n+private:\n+    //! The chainstate used under normal operation (i.e. \"regular\" IBD) or, if\n+    //! a snapshot is in use, for background validation.\n+    //!\n+    //! Its contents (including on-disk data) will be deleted *upon shutdown*\n+    //! after background validation of the snapshot has completed. We do not\n+    //! free the chainstate contents immediately after it finishes validation\n+    //! to cautiously avoid a case where some other part of the system is still\n+    //! using this pointer (e.g. net_processing).\n+    std::unique_ptr<CChainState> m_ibd_chainstate;\n+\n+    //! A chainstate initialized on the basis of a UTXO snapshot. If this is\n+    //! non-null, it is always our active chainstate.\n+    std::unique_ptr<CChainState> m_snapshot_chainstate;\n+\n+    //! Points to either the ibd or snapshot chainstate; indicates our\n+    //! most-work chain.\n+    CChainState* m_active_chainstate{nullptr};\n+\n+    //! If true, the assumed-valid chainstate has been fully validated\n+    //! by the background validation chainstate.\n+    bool m_snapshot_validated{false};\n+\n+    // For access to m_active_chainstate.\n+    friend CChain& ChainActive();\n+\n+public:\n+    //! Instantiate a new chainstate and assign it based upon whether it is\n+    //! from a snapshot.\n+    //!\n+    //! @param[in] snapshot_blockhash   If given, signify that this chainstate\n+    //!                                 is based on a snapshot.\n+    CChainState& InitializeChainstate(const uint256& snapshot_blockhash = uint256())\n+        EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n+\n+    //! Get all chainstates currently being used.\n+    std::vector<CChainState*> GetAll();\n+\n+    //! The most-work chain.\n+    CChain& ActiveChain() const;\n+    int ActiveHeight() const { return ActiveChain().Height(); }\n+    CBlockIndex* ActiveTip() const { return ActiveChain().Tip(); }\n+\n+    bool IsSnapshotActive() const;\n+\n+    Optional<uint256> SnapshotBlockhash() const;\n+\n+    //! Is there a snapshot in use and has it been fully validated?\n+    bool IsSnapshotValidated() const { return m_snapshot_validated; }\n+\n+    //! @returns true if this chainstate is being used to validate an active\n+    //!          snapshot in the background.\n+    bool IsBackgroundIBD(CChainState* chainstate) const;\n+\n+    //! Return the most-work chainstate that has been fully validated.\n+    //!\n+    //! During background validation of a snapshot, this is the IBD chain. After\n+    //! background validation has completed, this is the snapshot chain.\n+    CChainState& ValidatedChainstate() const;\n+\n+    CChain& ValidatedChain() const { return ValidatedChainstate().m_chain; }\n+    CBlockIndex* ValidatedTip() const { return ValidatedChain().Tip(); }\n+\n+    //! Unload block index and chain data before shutdown.\n+    void Unload() EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n+\n+    //! Clear (deconstruct) chainstate data.\n+    void Reset();\n+};\n+\n /** @returns the most-work valid chainstate. */\n CChainState& ChainstateActive();\n "
      }
    ]
  },
  {
    "sha": "5b690f0aae21e7d46cbefe3f5be645842ac4ae3b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1YjY5MGYwYWFlMjFlN2Q0NmNiZWZlM2Y1YmU2NDU4NDJhYzRhZTNi",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-12-12T15:28:14Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2020-03-17T18:03:40Z"
      },
      "message": "refactor: move RewindBlockIndex to CChainState\n\nThis is in preparation for multiple chainstate initialization in init.",
      "tree": {
        "sha": "f400ff724c4d23acaff44dd9820854e00cbdafdb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f400ff724c4d23acaff44dd9820854e00cbdafdb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5b690f0aae21e7d46cbefe3f5be645842ac4ae3b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5b690f0aae21e7d46cbefe3f5be645842ac4ae3b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5b690f0aae21e7d46cbefe3f5be645842ac4ae3b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5b690f0aae21e7d46cbefe3f5be645842ac4ae3b/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "89cdf4d5692d396b8c7177b3918aa9dab07f9624",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/89cdf4d5692d396b8c7177b3918aa9dab07f9624",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/89cdf4d5692d396b8c7177b3918aa9dab07f9624"
      }
    ],
    "stats": {
      "total": 32,
      "additions": 9,
      "deletions": 23
    },
    "files": [
      {
        "sha": "765c61b3db6a3eca3f4db927ac1876aa2344635a",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5b690f0aae21e7d46cbefe3f5be645842ac4ae3b/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5b690f0aae21e7d46cbefe3f5be645842ac4ae3b/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=5b690f0aae21e7d46cbefe3f5be645842ac4ae3b",
        "patch": "@@ -1614,7 +1614,7 @@ bool AppInitMain(NodeContext& node)\n                 // It both disconnects blocks based on ::ChainActive(), and drops block data in\n                 // BlockIndex() based on lack of available witness data.\n                 uiInterface.InitMessage(_(\"Rewinding blocks...\").translated);\n-                if (!RewindBlockIndex(chainparams)) {\n+                if (!::ChainstateActive().RewindBlockIndex(chainparams)) {\n                     strLoadError = _(\"Unable to rewind the database to a pre-fork state. You will need to redownload the blockchain\").translated;\n                     break;\n                 }"
      },
      {
        "sha": "9d4cdf6eb9c78aede73358868dbfce5cb5653b4d",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 19,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5b690f0aae21e7d46cbefe3f5be645842ac4ae3b/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5b690f0aae21e7d46cbefe3f5be645842ac4ae3b/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=5b690f0aae21e7d46cbefe3f5be645842ac4ae3b",
        "patch": "@@ -4538,26 +4538,15 @@ bool CChainState::RewindBlockIndex(const CChainParams& params)\n             PruneBlockIndexCandidates();\n \n             CheckBlockIndex(params.GetConsensus());\n-        }\n-    }\n-\n-    return true;\n-}\n-\n-bool RewindBlockIndex(const CChainParams& params) {\n-    if (!::ChainstateActive().RewindBlockIndex(params)) {\n-        return false;\n-    }\n \n-    LOCK(cs_main);\n-    if (::ChainActive().Tip() != nullptr) {\n-        // FlushStateToDisk can possibly read ::ChainActive(). Be conservative\n-        // and skip it here, we're about to -reindex-chainstate anyway, so\n-        // it'll get called a bunch real soon.\n-        BlockValidationState state;\n-        if (!::ChainstateActive().FlushStateToDisk(params, state, FlushStateMode::ALWAYS)) {\n-            LogPrintf(\"RewindBlockIndex: unable to flush state to disk (%s)\\n\", state.ToString());\n-            return false;\n+            // FlushStateToDisk can possibly read ::ChainActive(). Be conservative\n+            // and skip it here, we're about to -reindex-chainstate anyway, so\n+            // it'll get called a bunch real soon.\n+            BlockValidationState state;\n+            if (!FlushStateToDisk(params, state, FlushStateMode::ALWAYS)) {\n+                LogPrintf(\"RewindBlockIndex: unable to flush state to disk (%s)\\n\", state.ToString());\n+                return false;\n+            }\n         }\n     }\n "
      },
      {
        "sha": "3b160ac799280180a73e5cb2fa901b74b083cc50",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5b690f0aae21e7d46cbefe3f5be645842ac4ae3b/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5b690f0aae21e7d46cbefe3f5be645842ac4ae3b/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=5b690f0aae21e7d46cbefe3f5be645842ac4ae3b",
        "patch": "@@ -380,9 +380,6 @@ bool TestBlockValidity(BlockValidationState& state, const CChainParams& chainpar\n  *  Note that transaction witness validation rules are always enforced when P2SH is enforced. */\n bool IsWitnessEnabled(const CBlockIndex* pindexPrev, const Consensus::Params& params);\n \n-/** When there are blocks in the active chain with missing data, rewind the chainstate and remove them from the block index */\n-bool RewindBlockIndex(const CChainParams& params) LOCKS_EXCLUDED(cs_main);\n-\n /** Compute at which vout of the block's coinbase transaction the witness commitment occurs, or -1 if not found */\n int GetWitnessCommitmentIndex(const CBlock& block);\n "
      }
    ]
  },
  {
    "sha": "4ae29f5f0c5117032debb722d7049664fdceeae8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0YWUyOWY1ZjBjNTExNzAzMmRlYmI3MjJkNzA0OTY2NGZkY2VlYWU4",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-12-12T15:48:28Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2020-03-17T18:03:40Z"
      },
      "message": "use ChainstateManager to initialize chainstate\n\nThis allows us to easily initialize multiple chainstates on startup in future\ncommits. It retires the g_chainstate global in lieu of g_chainman.",
      "tree": {
        "sha": "48432a68a7fc218f88aa8dc3eaa6e7abef4477b6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/48432a68a7fc218f88aa8dc3eaa6e7abef4477b6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4ae29f5f0c5117032debb722d7049664fdceeae8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ae29f5f0c5117032debb722d7049664fdceeae8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4ae29f5f0c5117032debb722d7049664fdceeae8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ae29f5f0c5117032debb722d7049664fdceeae8/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5b690f0aae21e7d46cbefe3f5be645842ac4ae3b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5b690f0aae21e7d46cbefe3f5be645842ac4ae3b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5b690f0aae21e7d46cbefe3f5be645842ac4ae3b"
      }
    ],
    "stats": {
      "total": 287,
      "additions": 165,
      "deletions": 122
    },
    "files": [
      {
        "sha": "56b63c81010a97899c7354bf2da4d8fc1084177f",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 117,
        "deletions": 76,
        "changes": 193,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4ae29f5f0c5117032debb722d7049664fdceeae8/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4ae29f5f0c5117032debb722d7049664fdceeae8/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=4ae29f5f0c5117032debb722d7049664fdceeae8",
        "patch": "@@ -233,13 +233,12 @@ void Shutdown(NodeContext& node)\n     }\n \n     // FlushStateToDisk generates a ChainStateFlushed callback, which we should avoid missing\n-    //\n-    // g_chainstate is referenced here directly (instead of ::ChainstateActive()) because it\n-    // may not have been initialized yet.\n     {\n         LOCK(cs_main);\n-        if (g_chainstate && g_chainstate->CanFlushToDisk()) {\n-            g_chainstate->ForceFlushStateToDisk();\n+        for (CChainState* chainstate : g_chainman.GetAll()) {\n+            if (chainstate->CanFlushToDisk()) {\n+                chainstate->ForceFlushStateToDisk();\n+            }\n         }\n     }\n \n@@ -263,9 +262,11 @@ void Shutdown(NodeContext& node)\n \n     {\n         LOCK(cs_main);\n-        if (g_chainstate && g_chainstate->CanFlushToDisk()) {\n-            g_chainstate->ForceFlushStateToDisk();\n-            g_chainstate->ResetCoinsViews();\n+        for (CChainState* chainstate : g_chainman.GetAll()) {\n+            if (chainstate->CanFlushToDisk()) {\n+                chainstate->ForceFlushStateToDisk();\n+                chainstate->ResetCoinsViews();\n+            }\n         }\n         pblocktree.reset();\n     }\n@@ -1502,17 +1503,18 @@ bool AppInitMain(NodeContext& node)\n     bool fLoaded = false;\n     while (!fLoaded && !ShutdownRequested()) {\n         bool fReset = fReindex;\n+        auto is_coinsview_empty = [&](CChainState* chainstate) EXCLUSIVE_LOCKS_REQUIRED(::cs_main) {\n+            return fReset || fReindexChainState || chainstate->CoinsTip().GetBestBlock().IsNull();\n+        };\n         std::string strLoadError;\n \n         uiInterface.InitMessage(_(\"Loading block index...\").translated);\n \n         do {\n             const int64_t load_block_index_start_time = GetTimeMillis();\n-            bool is_coinsview_empty;\n             try {\n                 LOCK(cs_main);\n-                // This statement makes ::ChainstateActive() usable.\n-                g_chainstate = MakeUnique<CChainState>();\n+                g_chainman.InitializeChainstate();\n                 UnloadBlockIndex();\n \n                 // new CBlockTreeDB tries to delete the existing file, which\n@@ -1565,93 +1567,129 @@ bool AppInitMain(NodeContext& node)\n                 // At this point we're either in reindex or we've loaded a useful\n                 // block tree into BlockIndex()!\n \n-                ::ChainstateActive().InitCoinsDB(\n-                    /* cache_size_bytes */ nCoinDBCache,\n-                    /* in_memory */ false,\n-                    /* should_wipe */ fReset || fReindexChainState);\n-\n-                ::ChainstateActive().CoinsErrorCatcher().AddReadErrCallback([]() {\n-                    uiInterface.ThreadSafeMessageBox(\n-                        _(\"Error reading from database, shutting down.\").translated,\n-                        \"\", CClientUIInterface::MSG_ERROR);\n-                });\n-\n-                // If necessary, upgrade from older database format.\n-                // This is a no-op if we cleared the coinsviewdb with -reindex or -reindex-chainstate\n-                if (!::ChainstateActive().CoinsDB().Upgrade()) {\n-                    strLoadError = _(\"Error upgrading chainstate database\").translated;\n-                    break;\n-                }\n-\n-                // ReplayBlocks is a no-op if we cleared the coinsviewdb with -reindex or -reindex-chainstate\n-                if (!::ChainstateActive().ReplayBlocks(chainparams)) {\n-                    strLoadError = _(\"Unable to replay blocks. You will need to rebuild the database using -reindex-chainstate.\").translated;\n-                    break;\n-                }\n-\n-                // The on-disk coinsdb is now in a good state, create the cache\n-                ::ChainstateActive().InitCoinsCache();\n-                assert(::ChainstateActive().CanFlushToDisk());\n+                bool failed_chainstate_init = false;\n+\n+                for (CChainState* chainstate : g_chainman.GetAll()) {\n+                    LogPrintf(\"Initializing chainstate %s\\n\", chainstate->ToString());\n+                    chainstate->InitCoinsDB(\n+                        /* cache_size_bytes */ nCoinDBCache,\n+                        /* in_memory */ false,\n+                        /* should_wipe */ fReset || fReindexChainState);\n+\n+                    chainstate->CoinsErrorCatcher().AddReadErrCallback([]() {\n+                        uiInterface.ThreadSafeMessageBox(\n+                            _(\"Error reading from database, shutting down.\").translated,\n+                            \"\", CClientUIInterface::MSG_ERROR);\n+                    });\n+\n+                    // If necessary, upgrade from older database format.\n+                    // This is a no-op if we cleared the coinsviewdb with -reindex or -reindex-chainstate\n+                    if (!chainstate->CoinsDB().Upgrade()) {\n+                        strLoadError = _(\"Error upgrading chainstate database\").translated;\n+                        failed_chainstate_init = true;\n+                        break;\n+                    }\n \n-                is_coinsview_empty = fReset || fReindexChainState ||\n-                    ::ChainstateActive().CoinsTip().GetBestBlock().IsNull();\n-                if (!is_coinsview_empty) {\n-                    // LoadChainTip initializes the chain based on CoinsTip()'s best block\n-                    if (!::ChainstateActive().LoadChainTip(chainparams)) {\n-                        strLoadError = _(\"Error initializing block database\").translated;\n+                    // ReplayBlocks is a no-op if we cleared the coinsviewdb with -reindex or -reindex-chainstate\n+                    if (!chainstate->ReplayBlocks(chainparams)) {\n+                        strLoadError = _(\"Unable to replay blocks. You will need to rebuild the database using -reindex-chainstate.\").translated;\n+                        failed_chainstate_init = true;\n                         break;\n                     }\n-                    assert(::ChainActive().Tip() != nullptr);\n+\n+                    // The on-disk coinsdb is now in a good state, create the cache\n+                    chainstate->InitCoinsCache();\n+                    assert(chainstate->CanFlushToDisk());\n+\n+                    if (!is_coinsview_empty(chainstate)) {\n+                        // LoadChainTip initializes the chain based on CoinsTip()'s best block\n+                        if (!chainstate->LoadChainTip(chainparams)) {\n+                            strLoadError = _(\"Error initializing block database\").translated;\n+                            failed_chainstate_init = true;\n+                            break; // out of the per-chainstate loop\n+                        }\n+                        assert(chainstate->m_chain.Tip() != nullptr);\n+                    }\n+                }\n+\n+                if (failed_chainstate_init) {\n+                    break; // out of the chainstate activation do-while\n                 }\n             } catch (const std::exception& e) {\n                 LogPrintf(\"%s\\n\", e.what());\n                 strLoadError = _(\"Error opening block database\").translated;\n                 break;\n             }\n \n-            if (!fReset) {\n-                // Note that RewindBlockIndex MUST run even if we're about to -reindex-chainstate.\n-                // It both disconnects blocks based on ::ChainActive(), and drops block data in\n-                // BlockIndex() based on lack of available witness data.\n-                uiInterface.InitMessage(_(\"Rewinding blocks...\").translated);\n-                if (!::ChainstateActive().RewindBlockIndex(chainparams)) {\n-                    strLoadError = _(\"Unable to rewind the database to a pre-fork state. You will need to redownload the blockchain\").translated;\n-                    break;\n+            bool failed_rewind{false};\n+\n+            for (CChainState* chainstate : g_chainman.GetAll()) {\n+                if (!fReset) {\n+                    // Note that RewindBlockIndex MUST run even if we're about to -reindex-chainstate.\n+                    // It both disconnects blocks based on the chainstate, and drops block data in\n+                    // BlockIndex() based on lack of available witness data.\n+                    uiInterface.InitMessage(_(\"Rewinding blocks...\").translated);\n+                    if (!chainstate->RewindBlockIndex(chainparams)) {\n+                        strLoadError = _(\n+                            \"Unable to rewind the database to a pre-fork state. \"\n+                            \"You will need to redownload the blockchain\").translated;\n+                        failed_rewind = true;\n+                        break; // out of the per-chainstate loop\n+                    }\n                 }\n             }\n \n+            if (failed_rewind) {\n+                break; // out of the chainstate activation do-while\n+            }\n+\n+            bool failed_verification = false;\n+\n             try {\n                 LOCK(cs_main);\n-                if (!is_coinsview_empty) {\n-                    uiInterface.InitMessage(_(\"Verifying blocks...\").translated);\n-                    if (fHavePruned && gArgs.GetArg(\"-checkblocks\", DEFAULT_CHECKBLOCKS) > MIN_BLOCKS_TO_KEEP) {\n-                        LogPrintf(\"Prune: pruned datadir may not have more than %d blocks; only checking available blocks\\n\",\n-                            MIN_BLOCKS_TO_KEEP);\n-                    }\n \n-                    CBlockIndex* tip = ::ChainActive().Tip();\n-                    RPCNotifyBlockChange(true, tip);\n-                    if (tip && tip->nTime > GetAdjustedTime() + 2 * 60 * 60) {\n-                        strLoadError = _(\"The block database contains a block which appears to be from the future. \"\n-                                \"This may be due to your computer's date and time being set incorrectly. \"\n-                                \"Only rebuild the block database if you are sure that your computer's date and time are correct\").translated;\n-                        break;\n-                    }\n-\n-                    if (!CVerifyDB().VerifyDB(chainparams, &::ChainstateActive().CoinsDB(), gArgs.GetArg(\"-checklevel\", DEFAULT_CHECKLEVEL),\n-                                  gArgs.GetArg(\"-checkblocks\", DEFAULT_CHECKBLOCKS))) {\n-                        strLoadError = _(\"Corrupted block database detected\").translated;\n-                        break;\n+                for (CChainState* chainstate : g_chainman.GetAll()) {\n+                    if (!is_coinsview_empty(chainstate)) {\n+                        uiInterface.InitMessage(_(\"Verifying blocks...\").translated);\n+                        if (fHavePruned && gArgs.GetArg(\"-checkblocks\", DEFAULT_CHECKBLOCKS) > MIN_BLOCKS_TO_KEEP) {\n+                            LogPrintf(\"Prune: pruned datadir may not have more than %d blocks; only checking available blocks\\n\",\n+                                MIN_BLOCKS_TO_KEEP);\n+                        }\n+\n+                        const CBlockIndex* tip = chainstate->m_chain.Tip();\n+                        RPCNotifyBlockChange(true, tip);\n+                        if (tip && tip->nTime > GetAdjustedTime() + 2 * 60 * 60) {\n+                            strLoadError = _(\"The block database contains a block which appears to be from the future. \"\n+                                    \"This may be due to your computer's date and time being set incorrectly. \"\n+                                    \"Only rebuild the block database if you are sure that your computer's date and time are correct\").translated;\n+                            failed_verification = true;\n+                            break;\n+                        }\n+\n+                        // Only verify the DB of the active chainstate. This is fixed in later\n+                        // work when we allow VerifyDB to be parameterized by chainstate.\n+                        if (&::ChainstateActive() == chainstate &&\n+                                !CVerifyDB().VerifyDB(\n+                                chainparams, &chainstate->CoinsDB(),\n+                                gArgs.GetArg(\"-checklevel\", DEFAULT_CHECKLEVEL),\n+                                gArgs.GetArg(\"-checkblocks\", DEFAULT_CHECKBLOCKS))) {\n+                            strLoadError = _(\"Corrupted block database detected\").translated;\n+                            failed_verification = true;\n+                            break;\n+                        }\n                     }\n                 }\n             } catch (const std::exception& e) {\n                 LogPrintf(\"%s\\n\", e.what());\n                 strLoadError = _(\"Error opening block database\").translated;\n+                failed_verification = true;\n                 break;\n             }\n \n-            fLoaded = true;\n-            LogPrintf(\" block index %15dms\\n\", GetTimeMillis() - load_block_index_start_time);\n+            if (!failed_verification) {\n+                fLoaded = true;\n+                LogPrintf(\" block index %15dms\\n\", GetTimeMillis() - load_block_index_start_time);\n+            }\n         } while(false);\n \n         if (!fLoaded && !ShutdownRequested()) {\n@@ -1715,8 +1753,11 @@ bool AppInitMain(NodeContext& node)\n         LogPrintf(\"Unsetting NODE_NETWORK on prune mode\\n\");\n         nLocalServices = ServiceFlags(nLocalServices & ~NODE_NETWORK);\n         if (!fReindex) {\n-            uiInterface.InitMessage(_(\"Pruning blockstore...\").translated);\n-            ::ChainstateActive().PruneAndFlush();\n+            LOCK(cs_main);\n+            for (CChainState* chainstate : g_chainman.GetAll()) {\n+                uiInterface.InitMessage(_(\"Pruning blockstore...\").translated);\n+                chainstate->PruneAndFlush();\n+            }\n         }\n     }\n "
      },
      {
        "sha": "9de2e2e5a130dd3f43c79222d3089d7642480147",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4ae29f5f0c5117032debb722d7049664fdceeae8/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4ae29f5f0c5117032debb722d7049664fdceeae8/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=4ae29f5f0c5117032debb722d7049664fdceeae8",
        "patch": "@@ -1319,7 +1319,7 @@ static UniValue getchaintips(const JSONRPCRequest& request)\n     /*\n      * Idea:  the set of chain tips is ::ChainActive().tip, plus orphan blocks which do not have another orphan building off of them.\n      * Algorithm:\n-     *  - Make one pass through g_blockman.m_block_index, picking out the orphan blocks, and also storing a set of the orphan block's pprev pointers.\n+     *  - Make one pass through BlockIndex(), picking out the orphan blocks, and also storing a set of the orphan block's pprev pointers.\n      *  - Iterate through the orphan blocks. If the block isn't pointed to by another orphan, it is a chain tip.\n      *  - add ::ChainActive().Tip()\n      */"
      },
      {
        "sha": "dacdce0acb29124f1e97c9d65f10a927ef80ffd4",
        "filename": "src/test/util/setup_common.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4ae29f5f0c5117032debb722d7049664fdceeae8/src/test/util/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4ae29f5f0c5117032debb722d7049664fdceeae8/src/test/util/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/setup_common.cpp?ref=4ae29f5f0c5117032debb722d7049664fdceeae8",
        "patch": "@@ -111,7 +111,7 @@ TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(cha\n     GetMainSignals().RegisterBackgroundSignalScheduler(*g_rpc_node->scheduler);\n \n     pblocktree.reset(new CBlockTreeDB(1 << 20, true));\n-    g_chainstate = MakeUnique<CChainState>();\n+    g_chainman.InitializeChainstate();\n     ::ChainstateActive().InitCoinsDB(\n         /* cache_size_bytes */ 1 << 23, /* in_memory */ true, /* should_wipe */ false);\n     assert(!::ChainstateActive().CanFlushToDisk());\n@@ -153,7 +153,7 @@ TestingSetup::~TestingSetup()\n     m_node.mempool = nullptr;\n     m_node.scheduler.reset();\n     UnloadBlockIndex();\n-    g_chainstate.reset();\n+    g_chainman.Reset();\n     pblocktree.reset();\n }\n "
      },
      {
        "sha": "77b6e7c0513aad211d8a38b27bccb59b605840fb",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 36,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4ae29f5f0c5117032debb722d7049664fdceeae8/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4ae29f5f0c5117032debb722d7049664fdceeae8/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=4ae29f5f0c5117032debb722d7049664fdceeae8",
        "patch": "@@ -77,20 +77,17 @@ bool CBlockIndexWorkComparator::operator()(const CBlockIndex *pa, const CBlockIn\n     return false;\n }\n \n-namespace {\n-BlockManager g_blockman;\n-} // anon namespace\n-\n-std::unique_ptr<CChainState> g_chainstate;\n+ChainstateManager g_chainman;\n \n-CChainState& ChainstateActive() {\n-    assert(g_chainstate);\n-    return *g_chainstate;\n+CChainState& ChainstateActive()\n+{\n+    assert(g_chainman.m_active_chainstate);\n+    return *g_chainman.m_active_chainstate;\n }\n \n-CChain& ChainActive() {\n-    assert(g_chainstate);\n-    return g_chainstate->m_chain;\n+CChain& ChainActive()\n+{\n+    return ::ChainstateActive().m_chain;\n }\n \n /**\n@@ -152,8 +149,8 @@ namespace {\n CBlockIndex* LookupBlockIndex(const uint256& hash)\n {\n     AssertLockHeld(cs_main);\n-    BlockMap::const_iterator it = g_blockman.m_block_index.find(hash);\n-    return it == g_blockman.m_block_index.end() ? nullptr : it->second;\n+    BlockMap::const_iterator it = g_chainman.BlockIndex().find(hash);\n+    return it == g_chainman.BlockIndex().end() ? nullptr : it->second;\n }\n \n CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& locator)\n@@ -1243,13 +1240,10 @@ void CoinsViews::InitCache()\n     m_cacheview = MakeUnique<CCoinsViewCache>(&m_catcherview);\n }\n \n-// NOTE: for now m_blockman is set to a global, but this will be changed\n-// in a future commit.\n-CChainState::CChainState(uint256 from_snapshot_blockhash)\n-    : m_blockman(g_blockman),\n+CChainState::CChainState(BlockManager& blockman, uint256 from_snapshot_blockhash)\n+    : m_blockman(blockman),\n       m_from_snapshot_blockhash(from_snapshot_blockhash) {}\n \n-\n void CChainState::InitCoinsDB(\n     size_t cache_size_bytes,\n     bool in_memory,\n@@ -1301,7 +1295,7 @@ static CBlockIndex *pindexBestForkTip = nullptr, *pindexBestForkBase = nullptr;\n \n BlockMap& BlockIndex()\n {\n-    return g_blockman.m_block_index;\n+    return g_chainman.m_blockman.m_block_index;\n }\n \n static void AlertNotify(const std::string& strMessage)\n@@ -3471,7 +3465,7 @@ static bool ContextualCheckBlockHeader(const CBlockHeader& block, BlockValidatio\n     if (fCheckpointsEnabled) {\n         // Don't accept any forks from the main chain prior to last checkpoint.\n         // GetLastCheckpoint finds the last checkpoint in MapCheckpoints that's in our\n-        // g_blockman.m_block_index.\n+        // BlockIndex().\n         CBlockIndex* pcheckpoint = GetLastCheckpoint(params.Checkpoints());\n         if (pcheckpoint && nHeight < pcheckpoint->nHeight) {\n             LogPrintf(\"ERROR: %s: forked chain older than last checkpoint (height %d)\\n\", __func__, nHeight);\n@@ -3679,7 +3673,8 @@ bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& headers, BlockValid\n         LOCK(cs_main);\n         for (const CBlockHeader& header : headers) {\n             CBlockIndex *pindex = nullptr; // Use a temp pindex instead of ppindex to avoid a const_cast\n-            bool accepted = g_blockman.AcceptBlockHeader(header, state, chainparams, &pindex);\n+            bool accepted = g_chainman.m_blockman.AcceptBlockHeader(\n+                header, state, chainparams, &pindex);\n             ::ChainstateActive().CheckBlockIndex(chainparams.GetConsensus());\n \n             if (!accepted) {\n@@ -3881,7 +3876,7 @@ void PruneOneBlockFile(const int fileNumber)\n {\n     LOCK(cs_LastBlockFile);\n \n-    for (const auto& entry : g_blockman.m_block_index) {\n+    for (const auto& entry : g_chainman.BlockIndex()) {\n         CBlockIndex* pindex = entry.second;\n         if (pindex->nFile == fileNumber) {\n             pindex->nStatus &= ~BLOCK_HAVE_DATA;\n@@ -3895,12 +3890,12 @@ void PruneOneBlockFile(const int fileNumber)\n             // to be downloaded again in order to consider its chain, at which\n             // point it would be considered as a candidate for\n             // m_blocks_unlinked or setBlockIndexCandidates.\n-            auto range = g_blockman.m_blocks_unlinked.equal_range(pindex->pprev);\n+            auto range = g_chainman.m_blockman.m_blocks_unlinked.equal_range(pindex->pprev);\n             while (range.first != range.second) {\n                 std::multimap<CBlockIndex *, CBlockIndex *>::iterator _it = range.first;\n                 range.first++;\n                 if (_it->second == pindex) {\n-                    g_blockman.m_blocks_unlinked.erase(_it);\n+                    g_chainman.m_blockman.m_blocks_unlinked.erase(_it);\n                 }\n             }\n         }\n@@ -4137,9 +4132,11 @@ void BlockManager::Unload() {\n \n bool static LoadBlockIndexDB(const CChainParams& chainparams) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    if (!g_blockman.LoadBlockIndex(\n-            chainparams.GetConsensus(), *pblocktree, ::ChainstateActive().setBlockIndexCandidates))\n+    if (!g_chainman.m_blockman.LoadBlockIndex(\n+            chainparams.GetConsensus(), *pblocktree,\n+            ::ChainstateActive().setBlockIndexCandidates)) {\n         return false;\n+    }\n \n     // Load block file info\n     pblocktree->ReadLastBlockFile(nLastBlockFile);\n@@ -4161,7 +4158,7 @@ bool static LoadBlockIndexDB(const CChainParams& chainparams) EXCLUSIVE_LOCKS_RE\n     // Check presence of blk files\n     LogPrintf(\"Checking all blk files are present...\\n\");\n     std::set<int> setBlkDataFiles;\n-    for (const std::pair<const uint256, CBlockIndex*>& item : g_blockman.m_block_index)\n+    for (const std::pair<const uint256, CBlockIndex*>& item : g_chainman.BlockIndex())\n     {\n         CBlockIndex* pindex = item.second;\n         if (pindex->nStatus & BLOCK_HAVE_DATA) {\n@@ -4564,8 +4561,7 @@ void CChainState::UnloadBlockIndex() {\n void UnloadBlockIndex()\n {\n     LOCK(cs_main);\n-    ::ChainActive().SetTip(nullptr);\n-    g_blockman.Unload();\n+    g_chainman.Unload();\n     pindexBestInvalid = nullptr;\n     pindexBestHeader = nullptr;\n     mempool.clear();\n@@ -4578,8 +4574,6 @@ void UnloadBlockIndex()\n         warningcache[b].clear();\n     }\n     fHavePruned = false;\n-\n-    ::ChainstateActive().UnloadBlockIndex();\n }\n \n bool LoadBlockIndex(const CChainParams& chainparams)\n@@ -4589,7 +4583,7 @@ bool LoadBlockIndex(const CChainParams& chainparams)\n     if (!fReindex) {\n         bool ret = LoadBlockIndexDB(chainparams);\n         if (!ret) return false;\n-        needs_init = g_blockman.m_block_index.empty();\n+        needs_init = g_chainman.m_blockman.m_block_index.empty();\n     }\n \n     if (needs_init) {\n@@ -5135,10 +5129,10 @@ class CMainCleanup\n     CMainCleanup() {}\n     ~CMainCleanup() {\n         // block headers\n-        BlockMap::iterator it1 = g_blockman.m_block_index.begin();\n-        for (; it1 != g_blockman.m_block_index.end(); it1++)\n+        BlockMap::iterator it1 = g_chainman.BlockIndex().begin();\n+        for (; it1 != g_chainman.BlockIndex().end(); it1++)\n             delete (*it1).second;\n-        g_blockman.m_block_index.clear();\n+        g_chainman.BlockIndex().clear();\n     }\n };\n static CMainCleanup instance_of_cmaincleanup;\n@@ -5176,7 +5170,7 @@ CChainState& ChainstateManager::InitializeChainstate(const uint256& snapshot_blo\n         throw std::logic_error(\"should not be overwriting a chainstate\");\n     }\n \n-    to_modify.reset(new CChainState(snapshot_blockhash));\n+    to_modify.reset(new CChainState(m_blockman, snapshot_blockhash));\n \n     // Snapshot chainstates and initial IBD chaintates always become active.\n     if (is_snapshot || (!is_snapshot && !m_active_chainstate)) {\n@@ -5220,6 +5214,8 @@ void ChainstateManager::Unload()\n         chainstate->m_chain.SetTip(nullptr);\n         chainstate->UnloadBlockIndex();\n     }\n+\n+    m_blockman.Unload();\n }\n \n void ChainstateManager::Reset()"
      },
      {
        "sha": "901f6d22bd5c0cb564db798ccd1da52a9ab2553c",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 13,
        "deletions": 7,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4ae29f5f0c5117032debb722d7049664fdceeae8/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4ae29f5f0c5117032debb722d7049664fdceeae8/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=4ae29f5f0c5117032debb722d7049664fdceeae8",
        "patch": "@@ -592,8 +592,7 @@ class CChainState {\n     std::unique_ptr<CoinsViews> m_coins_views;\n \n public:\n-    explicit CChainState(BlockManager& blockman) : m_blockman(blockman) {}\n-    explicit CChainState(uint256 from_snapshot_blockhash = uint256());\n+    explicit CChainState(BlockManager& blockman, uint256 from_snapshot_blockhash = uint256());\n \n     /**\n      * Initialize the CoinsViews UTXO set database management data structures. The in-memory\n@@ -839,9 +838,14 @@ class ChainstateManager\n     bool m_snapshot_validated{false};\n \n     // For access to m_active_chainstate.\n+    friend CChainState& ChainstateActive();\n     friend CChain& ChainActive();\n \n public:\n+    //! A single BlockManager instance is shared across each constructed\n+    //! chainstate to avoid duplicating block metadata.\n+    BlockManager m_blockman GUARDED_BY(::cs_main);\n+\n     //! Instantiate a new chainstate and assign it based upon whether it is\n     //! from a snapshot.\n     //!\n@@ -858,6 +862,11 @@ class ChainstateManager\n     int ActiveHeight() const { return ActiveChain().Height(); }\n     CBlockIndex* ActiveTip() const { return ActiveChain().Tip(); }\n \n+    BlockMap& BlockIndex() EXCLUSIVE_LOCKS_REQUIRED(::cs_main)\n+    {\n+        return m_blockman.m_block_index;\n+    }\n+\n     bool IsSnapshotActive() const;\n \n     Optional<uint256> SnapshotBlockhash() const;\n@@ -885,6 +894,8 @@ class ChainstateManager\n     void Reset();\n };\n \n+extern ChainstateManager g_chainman;\n+\n /** @returns the most-work valid chainstate. */\n CChainState& ChainstateActive();\n \n@@ -894,11 +905,6 @@ CChain& ChainActive();\n /** @returns the global block index map. */\n BlockMap& BlockIndex();\n \n-// Most often ::ChainstateActive() should be used instead of this, but some code\n-// may not be able to assume that this has been initialized yet and so must use it\n-// directly, e.g. init.cpp.\n-extern std::unique_ptr<CChainState> g_chainstate;\n-\n /** Global variable that points to the active block tree (protected by cs_main) */\n extern std::unique_ptr<CBlockTreeDB> pblocktree;\n "
      }
    ]
  },
  {
    "sha": "2b081c4568e8019886fdb0f2a57babc73d7487f7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyYjA4MWM0NTY4ZTgwMTk4ODZmZGIwZjJhNTdiYWJjNzNkNzQ4N2Y3",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2019-12-12T19:11:03Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2020-03-17T18:03:40Z"
      },
      "message": "test: add basic tests for ChainstateManager\n\nFeedback incorporated from Russell Yanofsky.\n\nCo-authored-by: MarcoFalke <falke.marco@gmail.com>",
      "tree": {
        "sha": "0ed3d53fda9453067ca1d0526ae5a60da9bb9e00",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0ed3d53fda9453067ca1d0526ae5a60da9bb9e00"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2b081c4568e8019886fdb0f2a57babc73d7487f7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2b081c4568e8019886fdb0f2a57babc73d7487f7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2b081c4568e8019886fdb0f2a57babc73d7487f7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2b081c4568e8019886fdb0f2a57babc73d7487f7/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4ae29f5f0c5117032debb722d7049664fdceeae8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ae29f5f0c5117032debb722d7049664fdceeae8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4ae29f5f0c5117032debb722d7049664fdceeae8"
      }
    ],
    "stats": {
      "total": 107,
      "additions": 107,
      "deletions": 0
    },
    "files": [
      {
        "sha": "9c0aa347d4bd4a167ea097e529195fb6e62bc5d5",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b081c4568e8019886fdb0f2a57babc73d7487f7/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b081c4568e8019886fdb0f2a57babc73d7487f7/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=2b081c4568e8019886fdb0f2a57babc73d7487f7",
        "patch": "@@ -231,6 +231,7 @@ BITCOIN_TESTS =\\\n   test/uint256_tests.cpp \\\n   test/util_tests.cpp \\\n   test/validation_block_tests.cpp \\\n+  test/validation_chainstatemanager_tests.cpp \\\n   test/validation_flush_tests.cpp \\\n   test/versionbits_tests.cpp\n "
      },
      {
        "sha": "f9eb4cde3089b6aa43a362d5d9236c53fdf7a9a1",
        "filename": "src/qt/test/apptests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b081c4568e8019886fdb0f2a57babc73d7487f7/src/qt/test/apptests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b081c4568e8019886fdb0f2a57babc73d7487f7/src/qt/test/apptests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/apptests.cpp?ref=2b081c4568e8019886fdb0f2a57babc73d7487f7",
        "patch": "@@ -82,6 +82,7 @@ void AppTests::appTests()\n     // Reset global state to avoid interfering with later tests.\n     AbortShutdown();\n     UnloadBlockIndex();\n+    g_chainman.Reset();\n }\n \n //! Entry point for BitcoinGUI tests."
      },
      {
        "sha": "c77f59e0500fc3868d92177f268ec7ce067ec959",
        "filename": "src/test/util/setup_common.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b081c4568e8019886fdb0f2a57babc73d7487f7/src/test/util/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b081c4568e8019886fdb0f2a57babc73d7487f7/src/test/util/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/setup_common.cpp?ref=2b081c4568e8019886fdb0f2a57babc73d7487f7",
        "patch": "@@ -111,6 +111,7 @@ TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(cha\n     GetMainSignals().RegisterBackgroundSignalScheduler(*g_rpc_node->scheduler);\n \n     pblocktree.reset(new CBlockTreeDB(1 << 20, true));\n+\n     g_chainman.InitializeChainstate();\n     ::ChainstateActive().InitCoinsDB(\n         /* cache_size_bytes */ 1 << 23, /* in_memory */ true, /* should_wipe */ false);"
      },
      {
        "sha": "6e7186db227a0df22d4f97e0d7ba99a9bdd71557",
        "filename": "src/test/validation_chainstatemanager_tests.cpp",
        "status": "added",
        "additions": 104,
        "deletions": 0,
        "changes": 104,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b081c4568e8019886fdb0f2a57babc73d7487f7/src/test/validation_chainstatemanager_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b081c4568e8019886fdb0f2a57babc73d7487f7/src/test/validation_chainstatemanager_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/validation_chainstatemanager_tests.cpp?ref=2b081c4568e8019886fdb0f2a57babc73d7487f7",
        "patch": "@@ -0,0 +1,104 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+//\n+#include <chainparams.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <consensus/validation.h>\n+#include <sync.h>\n+#include <test/util/setup_common.h>\n+#include <validation.h>\n+\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(validation_chainstatemanager_tests, TestingSetup)\n+\n+//! Basic tests for ChainstateManager.\n+//!\n+//! First create a legacy (IBD) chainstate, then create a snapshot chainstate.\n+BOOST_AUTO_TEST_CASE(chainstatemanager)\n+{\n+    ChainstateManager manager;\n+    std::vector<CChainState*> chainstates;\n+    const CChainParams& chainparams = Params();\n+\n+    // Create a legacy (IBD) chainstate.\n+    //\n+    ENTER_CRITICAL_SECTION(cs_main);\n+    CChainState& c1 = manager.InitializeChainstate();\n+    LEAVE_CRITICAL_SECTION(cs_main);\n+    chainstates.push_back(&c1);\n+    c1.InitCoinsDB(\n+        /* cache_size_bytes */ 1 << 23, /* in_memory */ true, /* should_wipe */ false);\n+    WITH_LOCK(::cs_main, c1.InitCoinsCache());\n+\n+    BOOST_CHECK(!manager.IsSnapshotActive());\n+    BOOST_CHECK(!manager.IsSnapshotValidated());\n+    BOOST_CHECK(!manager.IsBackgroundIBD(&c1));\n+    auto all = manager.GetAll();\n+    BOOST_CHECK_EQUAL_COLLECTIONS(all.begin(), all.end(), chainstates.begin(), chainstates.end());\n+\n+    auto& active_chain = manager.ActiveChain();\n+    BOOST_CHECK_EQUAL(&active_chain, &c1.m_chain);\n+\n+    BOOST_CHECK_EQUAL(manager.ActiveHeight(), -1);\n+\n+    auto active_tip = manager.ActiveTip();\n+    auto exp_tip = c1.m_chain.Tip();\n+    BOOST_CHECK_EQUAL(active_tip, exp_tip);\n+\n+    auto& validated_cs = manager.ValidatedChainstate();\n+    BOOST_CHECK_EQUAL(&validated_cs, &c1);\n+\n+    // Create a snapshot-based chainstate.\n+    //\n+    ENTER_CRITICAL_SECTION(cs_main);\n+    CChainState& c2 = manager.InitializeChainstate(GetRandHash());\n+    LEAVE_CRITICAL_SECTION(cs_main);\n+    chainstates.push_back(&c2);\n+    c2.InitCoinsDB(\n+        /* cache_size_bytes */ 1 << 23, /* in_memory */ true, /* should_wipe */ false);\n+    WITH_LOCK(::cs_main, c2.InitCoinsCache());\n+    // Unlike c1, which doesn't have any blocks. Gets us different tip, height.\n+    c2.LoadGenesisBlock(chainparams);\n+    BlockValidationState _;\n+    BOOST_CHECK(c2.ActivateBestChain(_, chainparams, nullptr));\n+\n+    BOOST_CHECK(manager.IsSnapshotActive());\n+    BOOST_CHECK(!manager.IsSnapshotValidated());\n+    BOOST_CHECK(manager.IsBackgroundIBD(&c1));\n+    BOOST_CHECK(!manager.IsBackgroundIBD(&c2));\n+    auto all2 = manager.GetAll();\n+    BOOST_CHECK_EQUAL_COLLECTIONS(all2.begin(), all2.end(), chainstates.begin(), chainstates.end());\n+\n+    auto& active_chain2 = manager.ActiveChain();\n+    BOOST_CHECK_EQUAL(&active_chain2, &c2.m_chain);\n+\n+    BOOST_CHECK_EQUAL(manager.ActiveHeight(), 0);\n+\n+    auto active_tip2 = manager.ActiveTip();\n+    auto exp_tip2 = c2.m_chain.Tip();\n+    BOOST_CHECK_EQUAL(active_tip2, exp_tip2);\n+\n+    // Ensure that these pointers actually correspond to different\n+    // CCoinsViewCache instances.\n+    BOOST_CHECK(exp_tip != exp_tip2);\n+\n+    auto& validated_cs2 = manager.ValidatedChainstate();\n+    BOOST_CHECK_EQUAL(&validated_cs2, &c1);\n+\n+    auto& validated_chain = manager.ValidatedChain();\n+    BOOST_CHECK_EQUAL(&validated_chain, &c1.m_chain);\n+\n+    auto validated_tip = manager.ValidatedTip();\n+    exp_tip = c1.m_chain.Tip();\n+    BOOST_CHECK_EQUAL(validated_tip, exp_tip);\n+\n+    // Avoid triggering the address sanitizer.\n+    WITH_LOCK(::cs_main, manager.Unload());\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "c9017ce3bc27665594c9d80f395780d40755bb22",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjOTAxN2NlM2JjMjc2NjU1OTRjOWQ4MGYzOTU3ODBkNDA3NTViYjIy",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2020-01-29T14:57:56Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2020-03-17T18:07:58Z"
      },
      "message": "protect g_chainman with cs_main\n\nI'd previously attempted to create a specialized lock for ChainstateManager,\nbut it turns out that because that lock would be required for functions like\nChainActive() and ChainstateActive(), it created irreconcilable lock inversions\nsince those functions are used so broadly throughout the codebase.\n\nInstead, I'm just using cs_main to protect the contents of g_chainman.\n\nCo-authored-by: Russell Yanofsky <russ@yanofsky.org>",
      "tree": {
        "sha": "36ea710a14db1757ed270ff6e8585eb53427e74f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/36ea710a14db1757ed270ff6e8585eb53427e74f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c9017ce3bc27665594c9d80f395780d40755bb22",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c9017ce3bc27665594c9d80f395780d40755bb22",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c9017ce3bc27665594c9d80f395780d40755bb22",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c9017ce3bc27665594c9d80f395780d40755bb22/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2b081c4568e8019886fdb0f2a57babc73d7487f7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2b081c4568e8019886fdb0f2a57babc73d7487f7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2b081c4568e8019886fdb0f2a57babc73d7487f7"
      }
    ],
    "stats": {
      "total": 59,
      "additions": 48,
      "deletions": 11
    },
    "files": [
      {
        "sha": "f0ececbb39469c458920427999c07652e0fa8cd4",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 7,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9017ce3bc27665594c9d80f395780d40755bb22/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9017ce3bc27665594c9d80f395780d40755bb22/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=c9017ce3bc27665594c9d80f395780d40755bb22",
        "patch": "@@ -709,11 +709,17 @@ static void ThreadImport(std::vector<fs::path> vImportFiles)\n     }\n \n     // scan for better chains in the block chain database, that are not yet connected in the active best chain\n-    BlockValidationState state;\n-    if (!ActivateBestChain(state, chainparams)) {\n-        LogPrintf(\"Failed to connect best block (%s)\\n\", state.ToString());\n-        StartShutdown();\n-        return;\n+\n+    // We can't hold cs_main during ActivateBestChain even though we're accessing\n+    // the g_chainman unique_ptrs since ABC requires us not to be holding cs_main, so retrieve\n+    // the relevant pointers before the ABC call.\n+    for (CChainState* chainstate : WITH_LOCK(::cs_main, return g_chainman.GetAll())) {\n+        BlockValidationState state;\n+        if (!chainstate->ActivateBestChain(state, chainparams, nullptr)) {\n+            LogPrintf(\"Failed to connect best block (%s)\\n\", state.ToString());\n+            StartShutdown();\n+            return;\n+        }\n     }\n \n     if (gArgs.GetBoolArg(\"-stopafterblockimport\", DEFAULT_STOPAFTERBLOCKIMPORT)) {\n@@ -1622,8 +1628,9 @@ bool AppInitMain(NodeContext& node)\n             }\n \n             bool failed_rewind{false};\n-\n-            for (CChainState* chainstate : g_chainman.GetAll()) {\n+            // Can't hold cs_main while calling RewindBlockIndex, so retrieve the relevant\n+            // chainstates beforehand.\n+            for (CChainState* chainstate : WITH_LOCK(::cs_main, return g_chainman.GetAll())) {\n                 if (!fReset) {\n                     // Note that RewindBlockIndex MUST run even if we're about to -reindex-chainstate.\n                     // It both disconnects blocks based on the chainstate, and drops block data in"
      },
      {
        "sha": "064b9ceb1892545b3f2224dcd7cc613f6b770f3e",
        "filename": "src/qt/test/apptests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9017ce3bc27665594c9d80f395780d40755bb22/src/qt/test/apptests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9017ce3bc27665594c9d80f395780d40755bb22/src/qt/test/apptests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/apptests.cpp?ref=c9017ce3bc27665594c9d80f395780d40755bb22",
        "patch": "@@ -82,7 +82,7 @@ void AppTests::appTests()\n     // Reset global state to avoid interfering with later tests.\n     AbortShutdown();\n     UnloadBlockIndex();\n-    g_chainman.Reset();\n+    WITH_LOCK(::cs_main, g_chainman.Reset());\n }\n \n //! Entry point for BitcoinGUI tests."
      },
      {
        "sha": "84b93180d69aef1f804b4479143d40acfbed2602",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9017ce3bc27665594c9d80f395780d40755bb22/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9017ce3bc27665594c9d80f395780d40755bb22/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=c9017ce3bc27665594c9d80f395780d40755bb22",
        "patch": "@@ -81,12 +81,14 @@ ChainstateManager g_chainman;\n \n CChainState& ChainstateActive()\n {\n+    LOCK(::cs_main);\n     assert(g_chainman.m_active_chainstate);\n     return *g_chainman.m_active_chainstate;\n }\n \n CChain& ChainActive()\n {\n+    LOCK(::cs_main);\n     return ::ChainstateActive().m_chain;\n }\n \n@@ -1295,6 +1297,7 @@ static CBlockIndex *pindexBestForkTip = nullptr, *pindexBestForkBase = nullptr;\n \n BlockMap& BlockIndex()\n {\n+    LOCK(::cs_main);\n     return g_chainman.m_blockman.m_block_index;\n }\n \n@@ -4704,7 +4707,7 @@ bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, FlatFi\n                 // Activate the genesis block so normal node progress can continue\n                 if (hash == chainparams.GetConsensus().hashGenesisBlock) {\n                     BlockValidationState state;\n-                    if (!ActivateBestChain(state, chainparams)) {\n+                    if (!ActivateBestChain(state, chainparams, nullptr)) {\n                         break;\n                     }\n                 }"
      },
      {
        "sha": "dbf7aa28db90b70a1c738cf2ffc3ea8df495c63f",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 28,
        "deletions": 1,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9017ce3bc27665594c9d80f395780d40755bb22/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9017ce3bc27665594c9d80f395780d40755bb22/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=c9017ce3bc27665594c9d80f395780d40755bb22",
        "patch": "@@ -823,14 +823,41 @@ class ChainstateManager\n     //! free the chainstate contents immediately after it finishes validation\n     //! to cautiously avoid a case where some other part of the system is still\n     //! using this pointer (e.g. net_processing).\n+    //!\n+    //! Once this pointer is set to a corresponding chainstate, it will not\n+    //! be reset until init.cpp:Shutdown(). This means it is safe to acquire\n+    //! the contents of this pointer with ::cs_main held, release the lock,\n+    //! and then use the reference without concern of it being deconstructed.\n+    //!\n+    //! This is especially important when, e.g., calling ActivateBestChain()\n+    //! on all chainstates because we are not able to hold ::cs_main going into\n+    //! that call.\n     std::unique_ptr<CChainState> m_ibd_chainstate;\n \n     //! A chainstate initialized on the basis of a UTXO snapshot. If this is\n     //! non-null, it is always our active chainstate.\n+    //!\n+    //! Once this pointer is set to a corresponding chainstate, it will not\n+    //! be reset until init.cpp:Shutdown(). This means it is safe to acquire\n+    //! the contents of this pointer with ::cs_main held, release the lock,\n+    //! and then use the reference without concern of it being deconstructed.\n+    //!\n+    //! This is especially important when, e.g., calling ActivateBestChain()\n+    //! on all chainstates because we are not able to hold ::cs_main going into\n+    //! that call.\n     std::unique_ptr<CChainState> m_snapshot_chainstate;\n \n     //! Points to either the ibd or snapshot chainstate; indicates our\n     //! most-work chain.\n+    //!\n+    //! Once this pointer is set to a corresponding chainstate, it will not\n+    //! be reset until init.cpp:Shutdown(). This means it is safe to acquire\n+    //! the contents of this pointer with ::cs_main held, release the lock,\n+    //! and then use the reference without concern of it being deconstructed.\n+    //!\n+    //! This is especially important when, e.g., calling ActivateBestChain()\n+    //! on all chainstates because we are not able to hold ::cs_main going into\n+    //! that call.\n     CChainState* m_active_chainstate{nullptr};\n \n     //! If true, the assumed-valid chainstate has been fully validated\n@@ -894,7 +921,7 @@ class ChainstateManager\n     void Reset();\n };\n \n-extern ChainstateManager g_chainman;\n+extern ChainstateManager g_chainman GUARDED_BY(::cs_main);\n \n /** @returns the most-work valid chainstate. */\n CChainState& ChainstateActive();"
      },
      {
        "sha": "13e10c1eabcf24540a893f04c572f11a145e79f6",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9017ce3bc27665594c9d80f395780d40755bb22/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9017ce3bc27665594c9d80f395780d40755bb22/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=c9017ce3bc27665594c9d80f395780d40755bb22",
        "patch": "@@ -454,7 +454,7 @@ class ListCoinsTestingSetup : public TestChain100Setup\n         CreateAndProcessBlock({}, GetScriptForRawPubKey(coinbaseKey.GetPubKey()));\n         wallet = MakeUnique<CWallet>(m_chain.get(), WalletLocation(), WalletDatabase::CreateMock());\n         {\n-            LOCK(wallet->cs_wallet);\n+            LOCK2(::cs_main, wallet->cs_wallet);\n             wallet->SetLastBlockProcessed(::ChainActive().Height(), ::ChainActive().Tip()->GetBlockHash());\n         }\n         bool firstRun;"
      }
    ]
  }
]