[
  {
    "sha": "c95a277d059d6400945e1a6ede3734600f1d1081",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjOTVhMjc3ZDA1OWQ2NDAwOTQ1ZTFhNmVkZTM3MzQ2MDBmMWQxMDgx",
    "commit": {
      "author": {
        "name": "Ben Woosley",
        "email": "ben.woosley@gmail.com",
        "date": "2018-07-01T20:12:10Z"
      },
      "committer": {
        "name": "Ben Woosley",
        "email": "ben.woosley@gmail.com",
        "date": "2019-05-17T19:03:23Z"
      },
      "message": "Extract AppInitLoadBlockIndex from AppInitMain\n\nAppInitMain goes from ~650 lines to ~500. This also replaces\nconstructs like `while(false)` and using `break` vs `return` with\nmore explicit operation.",
      "tree": {
        "sha": "c5bb365aad3ad4ee7fe91ec614c7febf950d2d5d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c5bb365aad3ad4ee7fe91ec614c7febf950d2d5d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c95a277d059d6400945e1a6ede3734600f1d1081",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\nComment: GPGTools - https://gpgtools.org\n\niQEcBAABCgAGBQJc3wV+AAoJEG7l83hfeLNFk9IH/2c4kBLbi3d6khGhsC2OydI0\n+yWV48IIiaJpn6V8RDoB1mvhalDBFLSV7YoKz4zhjlm93bLhgv7vuLmbQn34GYC3\nh4XiB+6Ewj3vbt3T03En/+CdDLolKEgvPI397sP3VoC0+HtnKqWV2kRle8AK8mDP\ni845CMCaQE/IzmGkncZBFJErGWjYjasMsvkgCGyiT0GRYe9Y1tNuWNXxhM5XVRa1\nkF/+gqzY136B1Fejv+/1GozYJXogTIqiPYps0WAYPpkDLmNyiv1E9U4g7VH/A64q\nkvMeuzyUqCWJJld+sHtLaJxp8Bth36nwqKmtR/vT8o7BQFFeWduAizQyFwXMOvA=\n=pk2R\n-----END PGP SIGNATURE-----",
        "payload": "tree c5bb365aad3ad4ee7fe91ec614c7febf950d2d5d\nparent 277abed604a81be8036458573d052eaa293b6cf8\nauthor Ben Woosley <ben.woosley@gmail.com> 1530475930 -0400\ncommitter Ben Woosley <ben.woosley@gmail.com> 1558119803 -0400\n\nExtract AppInitLoadBlockIndex from AppInitMain\n\nAppInitMain goes from ~650 lines to ~500. This also replaces\nconstructs like `while(false)` and using `break` vs `return` with\nmore explicit operation.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c95a277d059d6400945e1a6ede3734600f1d1081",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c95a277d059d6400945e1a6ede3734600f1d1081",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c95a277d059d6400945e1a6ede3734600f1d1081/comments",
    "author": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "277abed604a81be8036458573d052eaa293b6cf8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/277abed604a81be8036458573d052eaa293b6cf8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/277abed604a81be8036458573d052eaa293b6cf8"
      }
    ],
    "stats": {
      "total": 276,
      "additions": 140,
      "deletions": 136
    },
    "files": [
      {
        "sha": "2b5aa485269a2d127937ffce1b19c5eef0a6a518",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 140,
        "deletions": 136,
        "changes": 276,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c95a277d059d6400945e1a6ede3734600f1d1081/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c95a277d059d6400945e1a6ede3734600f1d1081/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=c95a277d059d6400945e1a6ede3734600f1d1081",
        "patch": "@@ -1235,6 +1235,145 @@ bool AppInitLockDataDirectory()\n     return true;\n }\n \n+static bool AppInitLoadBlockIndex(const CChainParams& chainparams, int64_t nCoinDBCache, int64_t nBlockTreeDBCache, bool fReindexChainState, bool& fReset, std::string& strLoadError)\n+{\n+    const int64_t load_block_index_start_time = GetTimeMillis();\n+    bool is_coinsview_empty;\n+    try {\n+        LOCK(cs_main);\n+        UnloadBlockIndex();\n+        pcoinsTip.reset();\n+        pcoinsdbview.reset();\n+        pcoinscatcher.reset();\n+        // new CBlockTreeDB tries to delete the existing file, which\n+        // fails if it's still open from the previous loop. Close it first:\n+        pblocktree.reset();\n+        pblocktree.reset(new CBlockTreeDB(nBlockTreeDBCache, false, fReset));\n+\n+        if (fReset) {\n+            pblocktree->WriteReindexing(true);\n+            //If we're reindexing in prune mode, wipe away unusable block files and all undo data files\n+            if (fPruneMode)\n+                CleanupBlockRevFiles();\n+        }\n+\n+        if (ShutdownRequested()) return false;\n+\n+        // LoadBlockIndex will load fHavePruned if we've ever removed a\n+        // block file from disk.\n+        // Note that it also sets fReindex based on the disk flag!\n+        // From here on out fReindex and fReset mean something different!\n+        if (!LoadBlockIndex(chainparams)) {\n+            strLoadError = _(\"Error loading block database\");\n+            return false;\n+        }\n+\n+        // If the loaded chain has a wrong genesis, bail out immediately\n+        // (we're likely using a testnet datadir, or the other way around).\n+        if (!mapBlockIndex.empty() && !LookupBlockIndex(chainparams.GetConsensus().hashGenesisBlock)) {\n+            fReset = true; // don't retry\n+            strLoadError = _(\"Incorrect or no genesis block found. Wrong datadir for network?\");\n+            return false;\n+        }\n+\n+        // Check for changed -prune state.  What we are concerned about is a user who has pruned blocks\n+        // in the past, but is now trying to run unpruned.\n+        if (fHavePruned && !fPruneMode) {\n+            strLoadError = _(\"You need to rebuild the database using -reindex to go back to unpruned mode.  This will redownload the entire blockchain\");\n+            return false;\n+        }\n+\n+        // At this point blocktree args are consistent with what's on disk.\n+        // If we're not mid-reindex (based on disk + args), add a genesis block on disk\n+        // (otherwise we use the one already on disk).\n+        // This is called again in ThreadImport after the reindex completes.\n+        if (!fReindex && !LoadGenesisBlock(chainparams)) {\n+            strLoadError = _(\"Error initializing block database\");\n+            return false;\n+        }\n+\n+        // At this point we're either in reindex or we've loaded a useful\n+        // block tree into mapBlockIndex!\n+\n+        pcoinsdbview.reset(new CCoinsViewDB(nCoinDBCache, false, fReset || fReindexChainState));\n+        pcoinscatcher.reset(new CCoinsViewErrorCatcher(pcoinsdbview.get()));\n+\n+        // If necessary, upgrade from older database format.\n+        // This is a no-op if we cleared the coinsviewdb with -reindex or -reindex-chainstate\n+        if (!pcoinsdbview->Upgrade()) {\n+            strLoadError = _(\"Error upgrading chainstate database\");\n+            return false;\n+        }\n+\n+        // ReplayBlocks is a no-op if we cleared the coinsviewdb with -reindex or -reindex-chainstate\n+        if (!ReplayBlocks(chainparams, pcoinsdbview.get())) {\n+            strLoadError = _(\"Unable to replay blocks. You will need to rebuild the database using -reindex-chainstate.\");\n+            return false;\n+        }\n+\n+        // The on-disk coinsdb is now in a good state, create the cache\n+        pcoinsTip.reset(new CCoinsViewCache(pcoinscatcher.get()));\n+\n+        is_coinsview_empty = fReset || fReindexChainState || pcoinsTip->GetBestBlock().IsNull();\n+        if (!is_coinsview_empty) {\n+            // LoadChainTip sets ::ChainActive() based on pcoinsTip's best block\n+            if (!LoadChainTip(chainparams)) {\n+                strLoadError = _(\"Error initializing block database\");\n+                return false;\n+            }\n+            assert(::ChainActive().Tip() != nullptr);\n+        }\n+    } catch (const std::exception& e) {\n+        LogPrintf(\"%s\\n\", e.what());\n+        strLoadError = _(\"Error opening block database\");\n+        return false;\n+    }\n+\n+    if (!fReset) {\n+        // Note that RewindBlockIndex MUST run even if we're about to -reindex-chainstate.\n+        // It both disconnects blocks based on ::ChainActive(), and drops block data in\n+        // mapBlockIndex based on lack of available witness data.\n+        uiInterface.InitMessage(_(\"Rewinding blocks...\"));\n+        if (!RewindBlockIndex(chainparams)) {\n+            strLoadError = _(\"Unable to rewind the database to a pre-fork state. You will need to redownload the blockchain\");\n+            return false;\n+        }\n+    }\n+\n+    try {\n+        LOCK(cs_main);\n+        if (!is_coinsview_empty) {\n+            uiInterface.InitMessage(_(\"Verifying blocks...\"));\n+            if (fHavePruned && gArgs.GetArg(\"-checkblocks\", DEFAULT_CHECKBLOCKS) > MIN_BLOCKS_TO_KEEP) {\n+                LogPrintf(\"Prune: pruned datadir may not have more than %d blocks; only checking available blocks\\n\",\n+                    MIN_BLOCKS_TO_KEEP);\n+            }\n+\n+            CBlockIndex* tip = ::ChainActive().Tip();\n+            RPCNotifyBlockChange(true, tip);\n+            if (tip && tip->nTime > GetAdjustedTime() + 2 * 60 * 60) {\n+                strLoadError = _(\"The block database contains a block which appears to be from the future. \"\n+                        \"This may be due to your computer's date and time being set incorrectly. \"\n+                        \"Only rebuild the block database if you are sure that your computer's date and time are correct\");\n+                return false;\n+            }\n+\n+            if (!CVerifyDB().VerifyDB(chainparams, pcoinsdbview.get(), gArgs.GetArg(\"-checklevel\", DEFAULT_CHECKLEVEL),\n+                          gArgs.GetArg(\"-checkblocks\", DEFAULT_CHECKBLOCKS))) {\n+                strLoadError = _(\"Corrupted block database detected\");\n+                return false;\n+            }\n+        }\n+    } catch (const std::exception& e) {\n+        LogPrintf(\"%s\\n\", e.what());\n+        strLoadError = _(\"Error opening block database\");\n+        return false;\n+    }\n+\n+    LogPrintf(\" block index %15dms\\n\", GetTimeMillis() - load_block_index_start_time);\n+    return true;\n+}\n+\n bool AppInitMain(InitInterfaces& interfaces)\n {\n     const CChainParams& chainparams = Params();\n@@ -1494,142 +1633,7 @@ bool AppInitMain(InitInterfaces& interfaces)\n \n         uiInterface.InitMessage(_(\"Loading block index...\"));\n \n-        do {\n-            const int64_t load_block_index_start_time = GetTimeMillis();\n-            bool is_coinsview_empty;\n-            try {\n-                LOCK(cs_main);\n-                UnloadBlockIndex();\n-                pcoinsTip.reset();\n-                pcoinsdbview.reset();\n-                pcoinscatcher.reset();\n-                // new CBlockTreeDB tries to delete the existing file, which\n-                // fails if it's still open from the previous loop. Close it first:\n-                pblocktree.reset();\n-                pblocktree.reset(new CBlockTreeDB(nBlockTreeDBCache, false, fReset));\n-\n-                if (fReset) {\n-                    pblocktree->WriteReindexing(true);\n-                    //If we're reindexing in prune mode, wipe away unusable block files and all undo data files\n-                    if (fPruneMode)\n-                        CleanupBlockRevFiles();\n-                }\n-\n-                if (ShutdownRequested()) break;\n-\n-                // LoadBlockIndex will load fHavePruned if we've ever removed a\n-                // block file from disk.\n-                // Note that it also sets fReindex based on the disk flag!\n-                // From here on out fReindex and fReset mean something different!\n-                if (!LoadBlockIndex(chainparams)) {\n-                    strLoadError = _(\"Error loading block database\");\n-                    break;\n-                }\n-\n-                // If the loaded chain has a wrong genesis, bail out immediately\n-                // (we're likely using a testnet datadir, or the other way around).\n-                if (!mapBlockIndex.empty() && !LookupBlockIndex(chainparams.GetConsensus().hashGenesisBlock)) {\n-                    return InitError(_(\"Incorrect or no genesis block found. Wrong datadir for network?\"));\n-                }\n-\n-                // Check for changed -prune state.  What we are concerned about is a user who has pruned blocks\n-                // in the past, but is now trying to run unpruned.\n-                if (fHavePruned && !fPruneMode) {\n-                    strLoadError = _(\"You need to rebuild the database using -reindex to go back to unpruned mode.  This will redownload the entire blockchain\");\n-                    break;\n-                }\n-\n-                // At this point blocktree args are consistent with what's on disk.\n-                // If we're not mid-reindex (based on disk + args), add a genesis block on disk\n-                // (otherwise we use the one already on disk).\n-                // This is called again in ThreadImport after the reindex completes.\n-                if (!fReindex && !LoadGenesisBlock(chainparams)) {\n-                    strLoadError = _(\"Error initializing block database\");\n-                    break;\n-                }\n-\n-                // At this point we're either in reindex or we've loaded a useful\n-                // block tree into mapBlockIndex!\n-\n-                pcoinsdbview.reset(new CCoinsViewDB(nCoinDBCache, false, fReset || fReindexChainState));\n-                pcoinscatcher.reset(new CCoinsViewErrorCatcher(pcoinsdbview.get()));\n-\n-                // If necessary, upgrade from older database format.\n-                // This is a no-op if we cleared the coinsviewdb with -reindex or -reindex-chainstate\n-                if (!pcoinsdbview->Upgrade()) {\n-                    strLoadError = _(\"Error upgrading chainstate database\");\n-                    break;\n-                }\n-\n-                // ReplayBlocks is a no-op if we cleared the coinsviewdb with -reindex or -reindex-chainstate\n-                if (!ReplayBlocks(chainparams, pcoinsdbview.get())) {\n-                    strLoadError = _(\"Unable to replay blocks. You will need to rebuild the database using -reindex-chainstate.\");\n-                    break;\n-                }\n-\n-                // The on-disk coinsdb is now in a good state, create the cache\n-                pcoinsTip.reset(new CCoinsViewCache(pcoinscatcher.get()));\n-\n-                is_coinsview_empty = fReset || fReindexChainState || pcoinsTip->GetBestBlock().IsNull();\n-                if (!is_coinsview_empty) {\n-                    // LoadChainTip sets ::ChainActive() based on pcoinsTip's best block\n-                    if (!LoadChainTip(chainparams)) {\n-                        strLoadError = _(\"Error initializing block database\");\n-                        break;\n-                    }\n-                    assert(::ChainActive().Tip() != nullptr);\n-                }\n-            } catch (const std::exception& e) {\n-                LogPrintf(\"%s\\n\", e.what());\n-                strLoadError = _(\"Error opening block database\");\n-                break;\n-            }\n-\n-            if (!fReset) {\n-                // Note that RewindBlockIndex MUST run even if we're about to -reindex-chainstate.\n-                // It both disconnects blocks based on ::ChainActive(), and drops block data in\n-                // mapBlockIndex based on lack of available witness data.\n-                uiInterface.InitMessage(_(\"Rewinding blocks...\"));\n-                if (!RewindBlockIndex(chainparams)) {\n-                    strLoadError = _(\"Unable to rewind the database to a pre-fork state. You will need to redownload the blockchain\");\n-                    break;\n-                }\n-            }\n-\n-            try {\n-                LOCK(cs_main);\n-                if (!is_coinsview_empty) {\n-                    uiInterface.InitMessage(_(\"Verifying blocks...\"));\n-                    if (fHavePruned && gArgs.GetArg(\"-checkblocks\", DEFAULT_CHECKBLOCKS) > MIN_BLOCKS_TO_KEEP) {\n-                        LogPrintf(\"Prune: pruned datadir may not have more than %d blocks; only checking available blocks\\n\",\n-                            MIN_BLOCKS_TO_KEEP);\n-                    }\n-\n-                    CBlockIndex* tip = ::ChainActive().Tip();\n-                    RPCNotifyBlockChange(true, tip);\n-                    if (tip && tip->nTime > GetAdjustedTime() + 2 * 60 * 60) {\n-                        strLoadError = _(\"The block database contains a block which appears to be from the future. \"\n-                                \"This may be due to your computer's date and time being set incorrectly. \"\n-                                \"Only rebuild the block database if you are sure that your computer's date and time are correct\");\n-                        break;\n-                    }\n-\n-                    if (!CVerifyDB().VerifyDB(chainparams, pcoinsdbview.get(), gArgs.GetArg(\"-checklevel\", DEFAULT_CHECKLEVEL),\n-                                  gArgs.GetArg(\"-checkblocks\", DEFAULT_CHECKBLOCKS))) {\n-                        strLoadError = _(\"Corrupted block database detected\");\n-                        break;\n-                    }\n-                }\n-            } catch (const std::exception& e) {\n-                LogPrintf(\"%s\\n\", e.what());\n-                strLoadError = _(\"Error opening block database\");\n-                break;\n-            }\n-\n-            fLoaded = true;\n-            LogPrintf(\" block index %15dms\\n\", GetTimeMillis() - load_block_index_start_time);\n-        } while(false);\n-\n+        fLoaded = AppInitLoadBlockIndex(chainparams, nCoinDBCache, nBlockTreeDBCache, fReindexChainState, fReset, strLoadError);\n         if (!fLoaded && !ShutdownRequested()) {\n             // first suggest a reindex\n             if (!fReset) {"
      }
    ]
  }
]