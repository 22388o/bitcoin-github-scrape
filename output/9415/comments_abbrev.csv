theuni,2016-12-24T07:41:16Z,"There's so much currently wrong with this loop that I'm hesitant to make changes before rewriting it entirely. I've been discussing my plans with @TheBlueMatt for doing just that after #9289 is merged.\n\nSome other fun issues with this loop (I'm sure I'm leaving several out):\n- messageHandlerCondition wakes spuriously\n- The depth of vRecvGetData and messages to send aren't taken into consid",https://github.com/bitcoin/bitcoin/pull/9415#issuecomment-269073566,269073566,
gmaxwell,2016-12-24T22:19:56Z,"> messageHandlerCondition wakes spuriously\n\nwho cares? :) It's not like this loop or processing that results from random wakes ever shows up in profiles. \n\nIf it were a real concern it would be easy to go back to sleep if the boolean hasn't been flipped and not enough time has passed.\n\n>  but I'm really really hoping to address all of those at once in my next PR which moves this handle",https://github.com/bitcoin/bitcoin/pull/9415#issuecomment-269102470,269102470,
TheBlueMatt,2016-12-24T22:33:42Z,"I'm hoping the next PR isn't huge in the way of complicated locking implications, more like simplified locking implications compared to master. Let's wait and take a look next week (and if we decide it can't make it we can come back to here - I think the potential advantage in initial from-network sync time from ""doing it right"" might be worth the extra review/testing implications).\n\nOn December",https://github.com/bitcoin/bitcoin/pull/9415#issuecomment-269102850,269102850,
theuni,2016-12-25T06:00:58Z,"> who cares? :) It's not like this loop or processing that results from random wakes ever shows up in profiles.\n\nMy concern was moreso that some platforms (win32) may vary significantly in this wakeup behavior.\n\nCompletely agree with you though. I certainly wasn't suggesting that we not take the improvements here for the sake of something coming later. In fact, the wake from the miner is n",https://github.com/bitcoin/bitcoin/pull/9415#issuecomment-269111417,269111417,
gmaxwell,2016-12-27T11:52:55Z,"Mystery: this slows the IBD of the first 200k blocks from a local gigabit ethernet connected peer by about 40%. I've run the test 4 times each way, same result.  Maybe if we solve that, we make IBD faster.",https://github.com/bitcoin/bitcoin/pull/9415#issuecomment-269316189,269316189,
gmaxwell,2016-12-27T23:39:24Z,I bisected my patch down to the  cs_vSend cs_vRecvMsg contention causing fsleep=false to be the cause of the IBD performance regression.,https://github.com/bitcoin/bitcoin/pull/9415#issuecomment-269398595,269398595,
TheBlueMatt,2016-12-28T11:34:06Z,"Ugh, yea, those desperately need splitting. I know @theuni has been working on a patch to do that, see-also https://github.com/bitcoin/bitcoin/pull/9419/commits/c214d120a363a05ba9afdccff6b4bda6e29ae7c4\n\nOn December 28, 2016 12:39:28 AM GMT+01:00, Gregory Maxwell <notifications@github.com> wrote:\n>I bisected my patch down to the  cs_vSend cs_vRecvMsg contention\n>causing fsleep=false to be the c",https://github.com/bitcoin/bitcoin/pull/9415#issuecomment-269465287,269465287,
gmaxwell,2016-12-29T08:12:03Z,"I tested reducing the message handler hold of cs_vrecv lock to be just a narrow space small enough to std::move the message out, and speed up IBD to 200k from a single peer by more than a factor of two over master.",https://github.com/bitcoin/bitcoin/pull/9415#issuecomment-269595765,269595765,
gmaxwell,2016-12-29T14:51:43Z,"Sync to 200k with master:  243.7 blocks per second.\nWith this PR on the receiver:  465.431 blocks per second.\nWith the PR on both sender and receiver: 782.287  (3.2x master's speed).\n\n(Chainstate reindex is about 1000/s so there is still perhaps some room for improvement.)",https://github.com/bitcoin/bitcoin/pull/9415#issuecomment-269640771,269640771,
theuni,2016-12-29T15:46:55Z,"Looks like we’re stepping on each-other :)\n\nWe’re definitely working to solve the same issue, though it seems we disagree on the approach. This is less flexible for a clean separation of layers as it requires constant two-way communication between the net layer and the message processor. Done this way, the net must notify the processor that new messages are available, then the processor must g",https://github.com/bitcoin/bitcoin/pull/9415#issuecomment-269648692,269648692,
gmaxwell,2016-12-29T16:18:27Z,"I don't follow your two-way comments.  There is communication only one way here: from the ThreadSocketHandler to ThreadMessageHandler  for receive, and the reverse for sending.\n\nThe processing cannot itself throttle the network (except in terms of the input rate exceeding the processing rate):  Assuming we haven't hit the GetReceiveFloodSize  the only time message processing can stall receptio",https://github.com/bitcoin/bitcoin/pull/9415#issuecomment-269653447,269653447,
theuni,2016-12-29T16:45:09Z,"> I don't follow your two-way comments. There is communication only one way here: from the ThreadSocketHandler to ThreadMessageHandler for receive, and the reverse for sending.\n\nThreadSocketHandler notifies ThreadMessageHandler that it has a new message. \nThreadMessageHandler then reaches into the socket handler's buffer to get and remove it. Logically the queue belongs in the processor so t",https://github.com/bitcoin/bitcoin/pull/9415#issuecomment-269657451,269657451,
gmaxwell,2016-12-29T17:12:56Z,"> After all, the net is done with a message as soon as it's come in.\n\nI don't think it is-- e.g need to stop reading data off the socket if we have too much queued data. Otherwise the memory usage is unbounded: I don't think going around and lazily asking it to stop is sufficient, as AFAIK we have no guarantee about how much data we can receive between times the message handler will make its w",https://github.com/bitcoin/bitcoin/pull/9415#issuecomment-269661459,269661459,
theuni,2016-12-29T17:48:51Z,"> I don't think it is its need to stop reading data off the socket if we have too much queued data. Otherwise the memory usage is unbounded: I don't think going around and lazily asking it to stop is sufficient, as AFAIK we have no guarantee about how much data we can receive between times the message handler will make its way back around to notice that it's too large.\n\nNor do I.\n\nWith eac",https://github.com/bitcoin/bitcoin/pull/9415#issuecomment-269666581,269666581,
