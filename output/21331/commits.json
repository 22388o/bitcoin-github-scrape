[
  {
    "sha": "48669340080feaff86b8fc0403ef22c820477697",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ODY2OTM0MDA4MGZlYWZmODZiOGZjMDQwM2VmMjJjODIwNDc3Njk3",
    "commit": {
      "author": {
        "name": "fanquake",
        "email": "fanquake@gmail.com",
        "date": "2021-03-04T14:44:40Z"
      },
      "committer": {
        "name": "fanquake",
        "email": "fanquake@gmail.com",
        "date": "2021-03-05T01:05:37Z"
      },
      "message": "rpc: remove calls to CWallet.get()\n\nCo-authored-by: MarcoFalke <falke.marco@gmail.com>\nCo-authored-by: Jo\u00e3o Barbosa <joao.paulo.barbosa@gmail.com>",
      "tree": {
        "sha": "e050237b000d8135f2186ce03fe64553da83c502",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e050237b000d8135f2186ce03fe64553da83c502"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/48669340080feaff86b8fc0403ef22c820477697",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEz7FuIclQ9n+pXlWPLuufXMCVJsEFAmBBg+YACgkQLuufXMCV\nJsHbyw//QBuWtjIODyih1owSFw36IEqf6wH9vRh2Px8ApZsAESWTMeYI+McidvAc\nEaZzcyxpVTM9xPIYX08kF68XyOzjs6NYTSBLSyisVuY0/wqf+wcNFmgNPVpJXqgS\nb6s4GzG0ng2CEbynobHdjiozZ818BRn0e9yVGkceOfCPc2MR3ukQf2MMgvziUgfw\nVrXzeOPBdMTyLB6SG0WoAlWRBCWkiDa1N2Pq+ZZHF13OJ5dna6sfr/3S9Uu54AmX\n7nd4PHklYwPvk/rasmIYwfk18ICFcP+Av8BRSN1UV2YnHSu8QxFB9+llTopFj0LX\nAkdAyvH76wTD9FbFAarsk3pfoU6fy2e4kvsFQu0aOgOQDSaNEUrAf4DlbS6YdcmU\nVZjv9v45ZHCpmrOwuiKJPPRRvo1oh6D67KyP2Yc0dhC0wyQ8fFd/Qt4N2sgy60TK\ngsRvUbwnibOETmJnFoYkiNJmzcioWkOEvux3QQApSv15dCQQ/5XpfgzBdbA6zoNw\nL2ri6OxYCa1CEd0t+gBV7NbE/IH2vlNWPP+pYjw1OwR+FdJ77pi8oTgLtdQMXKaK\npLSvY/H1wuKTpYtXAgxZt9uHLU+I1RQ3woqJGB/gQM/bvbuI61Xl2tyU3YFNUTOA\n+UpEfbgHSyafYXdP8KBhRSWtiF3XNhi40BZEiVBYFRQ8XCJGxjc=\n=PL+E\n-----END PGP SIGNATURE-----",
        "payload": "tree e050237b000d8135f2186ce03fe64553da83c502\nparent b4d22654fe9e90093e643cb7beb896c48a274d47\nauthor fanquake <fanquake@gmail.com> 1614869080 +0800\ncommitter fanquake <fanquake@gmail.com> 1614906337 +0800\n\nrpc: remove calls to CWallet.get()\n\nCo-authored-by: MarcoFalke <falke.marco@gmail.com>\nCo-authored-by: Jo\u00e3o Barbosa <joao.paulo.barbosa@gmail.com>\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/48669340080feaff86b8fc0403ef22c820477697",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/48669340080feaff86b8fc0403ef22c820477697",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/48669340080feaff86b8fc0403ef22c820477697/comments",
    "author": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b4d22654fe9e90093e643cb7beb896c48a274d47",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b4d22654fe9e90093e643cb7beb896c48a274d47",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b4d22654fe9e90093e643cb7beb896c48a274d47"
      }
    ],
    "stats": {
      "total": 312,
      "additions": 131,
      "deletions": 181
    },
    "files": [
      {
        "sha": "597d0e22eedc7c1f74909387581488b6bcf83e33",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 42,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48669340080feaff86b8fc0403ef22c820477697/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48669340080feaff86b8fc0403ef22c820477697/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=48669340080feaff86b8fc0403ef22c820477697",
        "patch": "@@ -118,22 +118,21 @@ RPCHelpMan importprivkey()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     if (pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Cannot import private keys to a wallet with private keys disabled\");\n     }\n \n-    EnsureLegacyScriptPubKeyMan(*wallet, true);\n+    EnsureLegacyScriptPubKeyMan(*pwallet, true);\n \n     WalletRescanReserver reserver(*pwallet);\n     bool fRescan = true;\n     {\n         LOCK(pwallet->cs_wallet);\n \n-        EnsureWalletIsUnlocked(pwallet);\n+        EnsureWalletIsUnlocked(pwallet.get());\n \n         std::string strSecret = request.params[0].get_str();\n         std::string strLabel = \"\";\n@@ -210,9 +209,8 @@ RPCHelpMan abortrescan()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     if (!pwallet->IsScanning() || pwallet->IsAbortingRescan()) return false;\n     pwallet->AbortRescan();\n@@ -249,9 +247,8 @@ RPCHelpMan importaddress()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     EnsureLegacyScriptPubKeyMan(*pwallet, true);\n \n@@ -335,9 +332,8 @@ RPCHelpMan importprunedfunds()\n                 RPCExamples{\"\"},\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     CMutableTransaction tx;\n     if (!DecodeHexTx(tx, request.params[0].get_str())) {\n@@ -397,9 +393,8 @@ RPCHelpMan removeprunedfunds()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     LOCK(pwallet->cs_wallet);\n \n@@ -445,11 +440,10 @@ RPCHelpMan importpubkey()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n-    EnsureLegacyScriptPubKeyMan(*wallet, true);\n+    EnsureLegacyScriptPubKeyMan(*pwallet, true);\n \n     std::string strLabel;\n     if (!request.params[1].isNull())\n@@ -527,11 +521,10 @@ RPCHelpMan importwallet()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n-    EnsureLegacyScriptPubKeyMan(*wallet, true);\n+    EnsureLegacyScriptPubKeyMan(*pwallet, true);\n \n     if (pwallet->chain().havePruned()) {\n         // Exit early and print an error.\n@@ -550,7 +543,7 @@ RPCHelpMan importwallet()\n     {\n         LOCK(pwallet->cs_wallet);\n \n-        EnsureWalletIsUnlocked(pwallet);\n+        EnsureWalletIsUnlocked(pwallet.get());\n \n         fsbridge::ifstream file;\n         file.open(request.params[0].get_str(), std::ios::in | std::ios::ate);\n@@ -684,15 +677,14 @@ RPCHelpMan dumpprivkey()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n-    LegacyScriptPubKeyMan& spk_man = EnsureLegacyScriptPubKeyMan(*wallet);\n+    LegacyScriptPubKeyMan& spk_man = EnsureLegacyScriptPubKeyMan(*pwallet);\n \n     LOCK2(pwallet->cs_wallet, spk_man.cs_KeyStore);\n \n-    EnsureWalletIsUnlocked(pwallet);\n+    EnsureWalletIsUnlocked(pwallet.get());\n \n     std::string strAddress = request.params[0].get_str();\n     CTxDestination dest = DecodeDestination(strAddress);\n@@ -1336,13 +1328,12 @@ RPCHelpMan importmulti()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& mainRequest) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(mainRequest);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(mainRequest);\n+    if (!pwallet) return NullUniValue;\n \n     RPCTypeCheck(mainRequest.params, {UniValue::VARR, UniValue::VOBJ});\n \n-    EnsureLegacyScriptPubKeyMan(*wallet, true);\n+    EnsureLegacyScriptPubKeyMan(*pwallet, true);\n \n     const UniValue& requests = mainRequest.params[0];\n \n@@ -1368,7 +1359,7 @@ RPCHelpMan importmulti()\n     UniValue response(UniValue::VARR);\n     {\n         LOCK(pwallet->cs_wallet);\n-        EnsureWalletIsUnlocked(pwallet);\n+        EnsureWalletIsUnlocked(pwallet.get());\n \n         // Verify all timestamps are present before importing any keys.\n         CHECK_NONFATAL(pwallet->chain().findBlock(pwallet->GetLastBlockHash(), FoundBlock().time(nLowestTimestamp).mtpTime(now)));\n@@ -1380,7 +1371,7 @@ RPCHelpMan importmulti()\n \n         for (const UniValue& data : requests.getValues()) {\n             const int64_t timestamp = std::max(GetImportTimestamp(data, now), minimumTimestamp);\n-            const UniValue result = ProcessImport(pwallet, data, timestamp);\n+            const UniValue result = ProcessImport(pwallet.get(), data, timestamp);\n             response.push_back(result);\n \n             if (!fRescan) {\n@@ -1641,9 +1632,8 @@ RPCHelpMan importdescriptors()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& main_request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(main_request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(main_request);\n+    if (!pwallet) return NullUniValue;\n \n     //  Make sure wallet is a descriptor wallet\n     if (!pwallet->IsWalletFlagSet(WALLET_FLAG_DESCRIPTORS)) {\n@@ -1665,15 +1655,15 @@ RPCHelpMan importdescriptors()\n     UniValue response(UniValue::VARR);\n     {\n         LOCK(pwallet->cs_wallet);\n-        EnsureWalletIsUnlocked(pwallet);\n+        EnsureWalletIsUnlocked(pwallet.get());\n \n         CHECK_NONFATAL(pwallet->chain().findBlock(pwallet->GetLastBlockHash(), FoundBlock().time(lowest_timestamp).mtpTime(now)));\n \n         // Get all timestamps and extract the lowest timestamp\n         for (const UniValue& request : requests.getValues()) {\n             // This throws an error if \"timestamp\" doesn't exist\n             const int64_t timestamp = std::max(GetImportTimestamp(request, now), minimum_timestamp);\n-            const UniValue result = ProcessDescriptorImport(pwallet, request, timestamp);\n+            const UniValue result = ProcessDescriptorImport(pwallet.get(), request, timestamp);\n             response.push_back(result);\n \n             if (lowest_timestamp > timestamp ) {"
      },
      {
        "sha": "2c8944fc765eeebf945c0fd9975e2d1ce4f9d292",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 99,
        "deletions": 139,
        "changes": 238,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48669340080feaff86b8fc0403ef22c820477697/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48669340080feaff86b8fc0403ef22c820477697/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=48669340080feaff86b8fc0403ef22c820477697",
        "patch": "@@ -249,9 +249,8 @@ static RPCHelpMan getnewaddress()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     LOCK(pwallet->cs_wallet);\n \n@@ -299,9 +298,8 @@ static RPCHelpMan getrawchangeaddress()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     LOCK(pwallet->cs_wallet);\n \n@@ -342,9 +340,8 @@ static RPCHelpMan setlabel()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     LOCK(pwallet->cs_wallet);\n \n@@ -480,9 +477,8 @@ static RPCHelpMan sendtoaddress()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     // Make sure the results are valid at least up to the most recent block\n     // the user could have gotten from another RPC command prior to now\n@@ -507,13 +503,13 @@ static RPCHelpMan sendtoaddress()\n         coin_control.m_signal_bip125_rbf = request.params[5].get_bool();\n     }\n \n-    coin_control.m_avoid_address_reuse = GetAvoidReuseFlag(pwallet, request.params[8]);\n+    coin_control.m_avoid_address_reuse = GetAvoidReuseFlag(pwallet.get(), request.params[8]);\n     // We also enable partial spend avoidance if reuse avoidance is set.\n     coin_control.m_avoid_partial_spends |= coin_control.m_avoid_address_reuse;\n \n     SetFeeEstimateMode(*pwallet, coin_control, /* conf_target */ request.params[6], /* estimate_mode */ request.params[7], /* fee_rate */ request.params[9], /* override_min_fee */ false);\n \n-    EnsureWalletIsUnlocked(pwallet);\n+    EnsureWalletIsUnlocked(pwallet.get());\n \n     UniValue address_amounts(UniValue::VOBJ);\n     const std::string address = request.params[0].get_str();\n@@ -527,7 +523,7 @@ static RPCHelpMan sendtoaddress()\n     ParseRecipients(address_amounts, subtractFeeFromAmount, recipients);\n     const bool verbose{request.params[10].isNull() ? false : request.params[10].get_bool()};\n \n-    return SendMoney(pwallet, coin_control, recipients, mapValue, verbose);\n+    return SendMoney(pwallet.get(), coin_control, recipients, mapValue, verbose);\n },\n     };\n }\n@@ -559,9 +555,8 @@ static RPCHelpMan listaddressgroupings()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     // Make sure the results are valid at least up to the most recent block\n     // the user could have gotten from another RPC command prior to now\n@@ -617,13 +612,12 @@ static RPCHelpMan signmessage()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     LOCK(pwallet->cs_wallet);\n \n-    EnsureWalletIsUnlocked(pwallet);\n+    EnsureWalletIsUnlocked(pwallet.get());\n \n     std::string strAddress = request.params[0].get_str();\n     std::string strMessage = request.params[1].get_str();\n@@ -720,9 +714,8 @@ static RPCHelpMan getreceivedbyaddress()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     // Make sure the results are valid at least up to the most recent block\n     // the user could have gotten from another RPC command prior to now\n@@ -759,9 +752,8 @@ static RPCHelpMan getreceivedbylabel()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     // Make sure the results are valid at least up to the most recent block\n     // the user could have gotten from another RPC command prior to now\n@@ -800,9 +792,8 @@ static RPCHelpMan getbalance()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     // Make sure the results are valid at least up to the most recent block\n     // the user could have gotten from another RPC command prior to now\n@@ -822,7 +813,7 @@ static RPCHelpMan getbalance()\n \n     bool include_watchonly = ParseIncludeWatchonly(request.params[2], *pwallet);\n \n-    bool avoid_reuse = GetAvoidReuseFlag(pwallet, request.params[3]);\n+    bool avoid_reuse = GetAvoidReuseFlag(pwallet.get(), request.params[3]);\n \n     const auto bal = pwallet->GetBalance(min_depth, avoid_reuse);\n \n@@ -840,9 +831,8 @@ static RPCHelpMan getunconfirmedbalance()\n                 RPCExamples{\"\"},\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     // Make sure the results are valid at least up to the most recent block\n     // the user could have gotten from another RPC command prior to now\n@@ -911,9 +901,8 @@ static RPCHelpMan sendmany()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     // Make sure the results are valid at least up to the most recent block\n     // the user could have gotten from another RPC command prior to now\n@@ -945,7 +934,7 @@ static RPCHelpMan sendmany()\n     ParseRecipients(sendTo, subtractFeeFromAmount, recipients);\n     const bool verbose{request.params[9].isNull() ? false : request.params[9].get_bool()};\n \n-    return SendMoney(pwallet, coin_control, recipients, std::move(mapValue), verbose);\n+    return SendMoney(pwallet.get(), coin_control, recipients, std::move(mapValue), verbose);\n },\n     };\n }\n@@ -985,9 +974,8 @@ static RPCHelpMan addmultisigaddress()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     LegacyScriptPubKeyMan& spk_man = EnsureLegacyScriptPubKeyMan(*pwallet);\n \n@@ -1227,17 +1215,16 @@ static RPCHelpMan listreceivedbyaddress()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     // Make sure the results are valid at least up to the most recent block\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n     LOCK(pwallet->cs_wallet);\n \n-    return ListReceived(pwallet, request.params, false);\n+    return ListReceived(pwallet.get(), request.params, false);\n },\n     };\n }\n@@ -1270,17 +1257,16 @@ static RPCHelpMan listreceivedbylabel()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     // Make sure the results are valid at least up to the most recent block\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n     LOCK(pwallet->cs_wallet);\n \n-    return ListReceived(pwallet, request.params, true);\n+    return ListReceived(pwallet.get(), request.params, true);\n },\n     };\n }\n@@ -1451,9 +1437,8 @@ static RPCHelpMan listtransactions()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     // Make sure the results are valid at least up to the most recent block\n     // the user could have gotten from another RPC command prior to now\n@@ -1494,7 +1479,7 @@ static RPCHelpMan listtransactions()\n         for (CWallet::TxItems::const_reverse_iterator it = txOrdered.rbegin(); it != txOrdered.rend(); ++it)\n         {\n             CWalletTx *const pwtx = (*it).second;\n-            ListTransactions(pwallet, *pwtx, 0, true, ret, filter, filter_label);\n+            ListTransactions(pwallet.get(), *pwtx, 0, true, ret, filter, filter_label);\n             if ((int)ret.size() >= (nCount+nFrom)) break;\n         }\n     }\n@@ -1710,9 +1695,8 @@ static RPCHelpMan gettransaction()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     // Make sure the results are valid at least up to the most recent block\n     // the user could have gotten from another RPC command prior to now\n@@ -1749,7 +1733,7 @@ static RPCHelpMan gettransaction()\n     WalletTxToJSON(pwallet->chain(), wtx, entry);\n \n     UniValue details(UniValue::VARR);\n-    ListTransactions(pwallet, wtx, 0, false, details, filter, nullptr /* filter_label */);\n+    ListTransactions(pwallet.get(), wtx, 0, false, details, filter, nullptr /* filter_label */);\n     entry.pushKV(\"details\", details);\n \n     std::string strHex = EncodeHexTx(*wtx.tx, pwallet->chain().rpcSerializationFlags());\n@@ -1784,9 +1768,8 @@ static RPCHelpMan abandontransaction()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     // Make sure the results are valid at least up to the most recent block\n     // the user could have gotten from another RPC command prior to now\n@@ -1823,9 +1806,8 @@ static RPCHelpMan backupwallet()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     // Make sure the results are valid at least up to the most recent block\n     // the user could have gotten from another RPC command prior to now\n@@ -1859,9 +1841,8 @@ static RPCHelpMan keypoolrefill()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     if (pwallet->IsLegacy() && pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Error: Private keys are disabled for this wallet\");\n@@ -1877,7 +1858,7 @@ static RPCHelpMan keypoolrefill()\n         kpSize = (unsigned int)request.params[0].get_int();\n     }\n \n-    EnsureWalletIsUnlocked(pwallet);\n+    EnsureWalletIsUnlocked(pwallet.get());\n     pwallet->TopUpKeyPool(kpSize);\n \n     if (pwallet->GetKeyPoolSize() < kpSize) {\n@@ -2001,9 +1982,8 @@ static RPCHelpMan walletpassphrasechange()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     LOCK(pwallet->cs_wallet);\n \n@@ -2055,9 +2035,8 @@ static RPCHelpMan walletlock()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     LOCK(pwallet->cs_wallet);\n \n@@ -2100,9 +2079,8 @@ static RPCHelpMan encryptwallet()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     LOCK(pwallet->cs_wallet);\n \n@@ -2174,9 +2152,8 @@ static RPCHelpMan lockunspent()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     // Make sure the results are valid at least up to the most recent block\n     // the user could have gotten from another RPC command prior to now\n@@ -2289,9 +2266,8 @@ static RPCHelpMan listlockunspent()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     LOCK(pwallet->cs_wallet);\n \n@@ -2330,9 +2306,8 @@ static RPCHelpMan settxfee()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     LOCK(pwallet->cs_wallet);\n \n@@ -2460,9 +2435,8 @@ static RPCHelpMan getwalletinfo()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     // Make sure the results are valid at least up to the most recent block\n     // the user could have gotten from another RPC command prior to now\n@@ -2672,9 +2646,8 @@ static RPCHelpMan setwalletflag()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     std::string flag_str = request.params[0].get_str();\n     bool value = request.params[1].isNull() || request.params[1].get_bool();\n@@ -2916,9 +2889,8 @@ static RPCHelpMan listunspent()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     int nMinDepth = 1;\n     if (!request.params[0].isNull()) {\n@@ -3283,9 +3255,8 @@ static RPCHelpMan fundrawtransaction()\n                                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     RPCTypeCheck(request.params, {UniValue::VSTR, UniValueType(), UniValue::VBOOL});\n \n@@ -3302,7 +3273,7 @@ static RPCHelpMan fundrawtransaction()\n     CCoinControl coin_control;\n     // Automatically select (additional) coins. Can be overridden by options.add_inputs.\n     coin_control.m_add_inputs = true;\n-    FundTransaction(pwallet, tx, fee, change_position, request.params[1], coin_control, /* override_min_fee */ true);\n+    FundTransaction(pwallet.get(), tx, fee, change_position, request.params[1], coin_control, /* override_min_fee */ true);\n \n     UniValue result(UniValue::VOBJ);\n     result.pushKV(\"hex\", EncodeHexTx(CTransaction(tx)));\n@@ -3369,9 +3340,8 @@ RPCHelpMan signrawtransactionwithwallet()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR, UniValue::VSTR}, true);\n \n@@ -3382,7 +3352,7 @@ RPCHelpMan signrawtransactionwithwallet()\n \n     // Sign the transaction\n     LOCK(pwallet->cs_wallet);\n-    EnsureWalletIsUnlocked(pwallet);\n+    EnsureWalletIsUnlocked(pwallet.get());\n \n     // Fetch previous transactions (inputs):\n     std::map<COutPoint, Coin> coins;\n@@ -3469,9 +3439,8 @@ static RPCHelpMan bumpfee_helper(std::string method_name)\n         },\n         [want_psbt](const RPCHelpMan& self, const JSONRPCRequest& request) mutable -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     if (pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS) && !want_psbt) {\n         throw JSONRPCError(RPC_WALLET_ERROR, \"bumpfee is not available with wallets that have private keys disabled. Use psbtbumpfee instead.\");\n@@ -3514,7 +3483,7 @@ static RPCHelpMan bumpfee_helper(std::string method_name)\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n     LOCK(pwallet->cs_wallet);\n-    EnsureWalletIsUnlocked(pwallet);\n+    EnsureWalletIsUnlocked(pwallet.get());\n \n \n     std::vector<bilingual_str> errors;\n@@ -3608,9 +3577,8 @@ static RPCHelpMan rescanblockchain()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     WalletRescanReserver reserver(*pwallet);\n     if (!reserver.reserve()) {\n@@ -3840,9 +3808,8 @@ RPCHelpMan getaddressinfo()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     LOCK(pwallet->cs_wallet);\n \n@@ -3887,7 +3854,7 @@ RPCHelpMan getaddressinfo()\n \n     ret.pushKV(\"iswatchonly\", bool(mine & ISMINE_WATCH_ONLY));\n \n-    UniValue detail = DescribeWalletAddress(pwallet, dest);\n+    UniValue detail = DescribeWalletAddress(pwallet.get(), dest);\n     ret.pushKVs(detail);\n \n     ret.pushKV(\"ischange\", pwallet->IsChange(scriptPubKey));\n@@ -3943,9 +3910,8 @@ static RPCHelpMan getaddressesbylabel()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     LOCK(pwallet->cs_wallet);\n \n@@ -4005,9 +3971,8 @@ static RPCHelpMan listlabels()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     LOCK(pwallet->cs_wallet);\n \n@@ -4130,9 +4095,8 @@ static RPCHelpMan send()\n                 }, true\n             );\n \n-            std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-            if (!wallet) return NullUniValue;\n-            CWallet* const pwallet = wallet.get();\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return NullUniValue;\n \n             UniValue options{request.params[4].isNull() ? UniValue::VOBJ : request.params[4]};\n             if (options.exists(\"conf_target\") || options.exists(\"estimate_mode\")) {\n@@ -4185,7 +4149,7 @@ static RPCHelpMan send()\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n-            FundTransaction(pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n+            FundTransaction(pwallet.get(), rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n             bool add_to_wallet = true;\n             if (options.exists(\"add_to_wallet\")) {\n@@ -4258,9 +4222,8 @@ static RPCHelpMan sethdseed()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     LegacyScriptPubKeyMan& spk_man = EnsureLegacyScriptPubKeyMan(*pwallet, true);\n \n@@ -4275,7 +4238,7 @@ static RPCHelpMan sethdseed()\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Cannot set an HD seed on a non-HD wallet. Use the upgradewallet RPC in order to upgrade a non-HD wallet to HD\");\n     }\n \n-    EnsureWalletIsUnlocked(pwallet);\n+    EnsureWalletIsUnlocked(pwallet.get());\n \n     bool flush_key_pool = true;\n     if (!request.params[0].isNull()) {\n@@ -4336,9 +4299,8 @@ static RPCHelpMan walletprocesspsbt()\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    const CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL, UniValue::VSTR});\n \n@@ -4448,9 +4410,8 @@ static RPCHelpMan walletcreatefundedpsbt()\n                                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     RPCTypeCheck(request.params, {\n         UniValue::VARR,\n@@ -4474,7 +4435,7 @@ static RPCHelpMan walletcreatefundedpsbt()\n     // Automatically select coins, unless at least one is manually selected. Can\n     // be overridden by options.add_inputs.\n     coin_control.m_add_inputs = rawTx.vin.size() == 0;\n-    FundTransaction(pwallet, rawTx, fee, change_position, request.params[3], coin_control, /* override_min_fee */ true);\n+    FundTransaction(pwallet.get(), rawTx, fee, change_position, request.params[3], coin_control, /* override_min_fee */ true);\n \n     // Make a blank psbt\n     PartiallySignedTransaction psbtx(rawTx);\n@@ -4524,13 +4485,12 @@ static RPCHelpMan upgradewallet()\n         },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    if (!wallet) return NullUniValue;\n-    CWallet* const pwallet = wallet.get();\n+    std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+    if (!pwallet) return NullUniValue;\n \n     RPCTypeCheck(request.params, {UniValue::VNUM}, true);\n \n-    EnsureWalletIsUnlocked(pwallet);\n+    EnsureWalletIsUnlocked(pwallet.get());\n \n     int version = 0;\n     if (!request.params[0].isNull()) {"
      }
    ]
  },
  {
    "sha": "7c90c67b7e6f598f9ffdc136ded2b533b78ed044",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3YzkwYzY3YjdlNmY1OThmOWZmZGMxMzZkZWQyYjUzM2I3OGVkMDQ0",
    "commit": {
      "author": {
        "name": "fanquake",
        "email": "fanquake@gmail.com",
        "date": "2021-03-04T15:20:13Z"
      },
      "committer": {
        "name": "fanquake",
        "email": "fanquake@gmail.com",
        "date": "2021-03-05T01:20:13Z"
      },
      "message": "rpc: refactor rpc wallet functions to take references instead of pointers\n\nCo-authored-by: MarcoFalke <falke.marco@gmail.com>\nCo-authored-by: Jo\u00e3o Barbosa <joao.paulo.barbosa@gmail.com>",
      "tree": {
        "sha": "aa1aa54359dc87b462685691a21d488476ce0ce1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/aa1aa54359dc87b462685691a21d488476ce0ce1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7c90c67b7e6f598f9ffdc136ded2b533b78ed044",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEz7FuIclQ9n+pXlWPLuufXMCVJsEFAmBBh2gACgkQLuufXMCV\nJsG/GxAAhfFg/ZhOBhklKShndKsi+NAZrhVGscMEWTWRyifSXZu0E99Ej01MsSvk\n9eROnrvgqi8tN39CcK/Pud4yD58fnwHHxQfnJLk4z1Pi4NRozXhsnWyRM2jezQGr\nH9a43L6WP432uWI8GPbXofsFp3nHNKDAJAf/NlgAhosEVQsMExYFHVRMoeuJED25\n7e9L6M57Au7FX2/cxNbcmUrjs/h3JRz1n0f14WMp3PwbLRYzZk8QtsJ+jZECK4E7\ndB1QDw+r8BucnXas2cKIMII1YxYhWS99F7PdmBbCsjw3fLbpfmmnGtvvKjQnOEy6\nGTQnmmv8Q5/sKMWNNVt+Mo7wVsWF15/IV7E3X9QFE7cBvsskbb/jZ0TwHmPBIEo1\nCVt4nfAwruLHfEnbTc8TvZYX5rAVvzng9s2BnWwMERKs7R7QZkvNrEKTkt947ymn\nplKZJ0YUxuhpYIh5L/Vzjh7YEilMJVGr9PfVUWSzDCBe98QtHGJeuCDBMS8CJQZH\nzEcdDz13CzKEefx/EXbL/zUtWijNr3qEhI9HOMvoKwi1DbYCMali+zMXqMhYnpKW\nonqi2pz+weI/nG4z2/C+Y3XjjEzQqHJ7FtCbNyWTNojzqZ34MYmsqJOsFJpUTMjn\nXNKyPJkayY5P1e9SAj7qWk10Qd5tEIAAxPlAv9Zm3kEaNA8xgAg=\n=crNm\n-----END PGP SIGNATURE-----",
        "payload": "tree aa1aa54359dc87b462685691a21d488476ce0ce1\nparent 48669340080feaff86b8fc0403ef22c820477697\nauthor fanquake <fanquake@gmail.com> 1614871213 +0800\ncommitter fanquake <fanquake@gmail.com> 1614907213 +0800\n\nrpc: refactor rpc wallet functions to take references instead of pointers\n\nCo-authored-by: MarcoFalke <falke.marco@gmail.com>\nCo-authored-by: Jo\u00e3o Barbosa <joao.paulo.barbosa@gmail.com>\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7c90c67b7e6f598f9ffdc136ded2b533b78ed044",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7c90c67b7e6f598f9ffdc136ded2b533b78ed044",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7c90c67b7e6f598f9ffdc136ded2b533b78ed044/comments",
    "author": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "48669340080feaff86b8fc0403ef22c820477697",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/48669340080feaff86b8fc0403ef22c820477697",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/48669340080feaff86b8fc0403ef22c820477697"
      }
    ],
    "stats": {
      "total": 171,
      "additions": 85,
      "deletions": 86
    },
    "files": [
      {
        "sha": "60f76465a6f049239af16473e0d35075a3f20e23",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 28,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c90c67b7e6f598f9ffdc136ded2b533b78ed044/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c90c67b7e6f598f9ffdc136ded2b533b78ed044/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=7c90c67b7e6f598f9ffdc136ded2b533b78ed044",
        "patch": "@@ -56,13 +56,13 @@ static std::string DecodeDumpString(const std::string &str) {\n     return ret.str();\n }\n \n-static bool GetWalletAddressesForKey(LegacyScriptPubKeyMan* spk_man, const CWallet* const pwallet, const CKeyID& keyid, std::string& strAddr, std::string& strLabel) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static bool GetWalletAddressesForKey(LegacyScriptPubKeyMan* spk_man, const CWallet& wallet, const CKeyID& keyid, std::string& strAddr, std::string& strLabel) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet)\n {\n     bool fLabelFound = false;\n     CKey key;\n     spk_man->GetKey(keyid, key);\n     for (const auto& dest : GetAllDestinationsForKey(key.GetPubKey())) {\n-        const auto* address_book_entry = pwallet->FindAddressBookEntry(dest);\n+        const auto* address_book_entry = wallet.FindAddressBookEntry(dest);\n         if (address_book_entry) {\n             if (!strAddr.empty()) {\n                 strAddr += \",\";\n@@ -73,7 +73,7 @@ static bool GetWalletAddressesForKey(LegacyScriptPubKeyMan* spk_man, const CWall\n         }\n     }\n     if (!fLabelFound) {\n-        strAddr = EncodeDestination(GetDestinationForKey(key.GetPubKey(), pwallet->m_default_address_type));\n+        strAddr = EncodeDestination(GetDestinationForKey(key.GetPubKey(), wallet.m_default_address_type));\n     }\n     return fLabelFound;\n }\n@@ -132,7 +132,7 @@ RPCHelpMan importprivkey()\n     {\n         LOCK(pwallet->cs_wallet);\n \n-        EnsureWalletIsUnlocked(pwallet.get());\n+        EnsureWalletIsUnlocked(*pwallet);\n \n         std::string strSecret = request.params[0].get_str();\n         std::string strLabel = \"\";\n@@ -543,7 +543,7 @@ RPCHelpMan importwallet()\n     {\n         LOCK(pwallet->cs_wallet);\n \n-        EnsureWalletIsUnlocked(pwallet.get());\n+        EnsureWalletIsUnlocked(*pwallet);\n \n         fsbridge::ifstream file;\n         file.open(request.params[0].get_str(), std::ios::in | std::ios::ate);\n@@ -684,7 +684,7 @@ RPCHelpMan dumpprivkey()\n \n     LOCK2(pwallet->cs_wallet, spk_man.cs_KeyStore);\n \n-    EnsureWalletIsUnlocked(pwallet.get());\n+    EnsureWalletIsUnlocked(*pwallet);\n \n     std::string strAddress = request.params[0].get_str();\n     CTxDestination dest = DecodeDestination(strAddress);\n@@ -739,7 +739,7 @@ RPCHelpMan dumpwallet()\n \n     LOCK2(wallet.cs_wallet, spk_man.cs_KeyStore);\n \n-    EnsureWalletIsUnlocked(&wallet);\n+    EnsureWalletIsUnlocked(wallet);\n \n     fs::path filepath = request.params[0].get_str();\n     filepath = fs::absolute(filepath);\n@@ -801,7 +801,7 @@ RPCHelpMan dumpwallet()\n         CKey key;\n         if (spk_man.GetKey(keyid, key)) {\n             file << strprintf(\"%s %s \", EncodeSecret(key), strTime);\n-            if (GetWalletAddressesForKey(&spk_man, &wallet, keyid, strAddr, strLabel)) {\n+            if (GetWalletAddressesForKey(&spk_man, wallet, keyid, strAddr, strLabel)) {\n                 file << strprintf(\"label=%s\", strLabel);\n             } else if (keyid == seed_id) {\n                 file << \"hdseed=1\";\n@@ -1161,7 +1161,7 @@ static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID\n     return warnings;\n }\n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static UniValue ProcessImport(CWallet& wallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet)\n {\n     UniValue warnings(UniValue::VARR);\n     UniValue result(UniValue::VOBJ);\n@@ -1176,7 +1176,7 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n         const bool add_keypool = data.exists(\"keypool\") ? data[\"keypool\"].get_bool() : false;\n \n         // Add to keypool only works with privkeys disabled\n-        if (add_keypool && !pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {\n+        if (add_keypool && !wallet.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Keys can only be imported to the keypool when private keys are disabled\");\n         }\n \n@@ -1198,29 +1198,29 @@ static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, con\n         }\n \n         // If private keys are disabled, abort if private keys are being imported\n-        if (pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS) && !privkey_map.empty()) {\n+        if (wallet.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS) && !privkey_map.empty()) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"Cannot import private keys to a wallet with private keys disabled\");\n         }\n \n         // Check whether we have any work to do\n         for (const CScript& script : script_pub_keys) {\n-            if (pwallet->IsMine(script) & ISMINE_SPENDABLE) {\n+            if (wallet.IsMine(script) & ISMINE_SPENDABLE) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script (\\\"\" + HexStr(script) + \"\\\")\");\n             }\n         }\n \n         // All good, time to import\n-        pwallet->MarkDirty();\n-        if (!pwallet->ImportScripts(import_data.import_scripts, timestamp)) {\n+        wallet.MarkDirty();\n+        if (!wallet.ImportScripts(import_data.import_scripts, timestamp)) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n         }\n-        if (!pwallet->ImportPrivKeys(privkey_map, timestamp)) {\n+        if (!wallet.ImportPrivKeys(privkey_map, timestamp)) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n         }\n-        if (!pwallet->ImportPubKeys(ordered_pubkeys, pubkey_map, import_data.key_origins, add_keypool, internal, timestamp)) {\n+        if (!wallet.ImportPubKeys(ordered_pubkeys, pubkey_map, import_data.key_origins, add_keypool, internal, timestamp)) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n         }\n-        if (!pwallet->ImportScriptPubKeys(label, script_pub_keys, have_solving_data, !internal, timestamp)) {\n+        if (!wallet.ImportScriptPubKeys(label, script_pub_keys, have_solving_data, !internal, timestamp)) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n         }\n \n@@ -1359,7 +1359,7 @@ RPCHelpMan importmulti()\n     UniValue response(UniValue::VARR);\n     {\n         LOCK(pwallet->cs_wallet);\n-        EnsureWalletIsUnlocked(pwallet.get());\n+        EnsureWalletIsUnlocked(*pwallet);\n \n         // Verify all timestamps are present before importing any keys.\n         CHECK_NONFATAL(pwallet->chain().findBlock(pwallet->GetLastBlockHash(), FoundBlock().time(nLowestTimestamp).mtpTime(now)));\n@@ -1371,7 +1371,7 @@ RPCHelpMan importmulti()\n \n         for (const UniValue& data : requests.getValues()) {\n             const int64_t timestamp = std::max(GetImportTimestamp(data, now), minimumTimestamp);\n-            const UniValue result = ProcessImport(pwallet.get(), data, timestamp);\n+            const UniValue result = ProcessImport(*pwallet, data, timestamp);\n             response.push_back(result);\n \n             if (!fRescan) {\n@@ -1438,7 +1438,7 @@ RPCHelpMan importmulti()\n     };\n }\n \n-static UniValue ProcessDescriptorImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static UniValue ProcessDescriptorImport(CWallet& wallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet)\n {\n     UniValue warnings(UniValue::VARR);\n     UniValue result(UniValue::VOBJ);\n@@ -1507,7 +1507,7 @@ static UniValue ProcessDescriptorImport(CWallet * const pwallet, const UniValue&\n         }\n \n         // If the wallet disabled private keys, abort if private keys exist\n-        if (pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS) && !keys.keys.empty()) {\n+        if (wallet.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS) && !keys.keys.empty()) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"Cannot import private keys to a wallet with private keys disabled\");\n         }\n \n@@ -1531,7 +1531,7 @@ static UniValue ProcessDescriptorImport(CWallet * const pwallet, const UniValue&\n         }\n \n         // If private keys are enabled, check some things.\n-        if (!pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {\n+        if (!wallet.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {\n            if (keys.keys.empty()) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Cannot import descriptor without private keys to a wallet with private keys enabled\");\n            }\n@@ -1543,7 +1543,7 @@ static UniValue ProcessDescriptorImport(CWallet * const pwallet, const UniValue&\n         WalletDescriptor w_desc(std::move(parsed_desc), timestamp, range_start, range_end, next_index);\n \n         // Check if the wallet already contains the descriptor\n-        auto existing_spk_manager = pwallet->GetDescriptorScriptPubKeyMan(w_desc);\n+        auto existing_spk_manager = wallet.GetDescriptorScriptPubKeyMan(w_desc);\n         if (existing_spk_manager) {\n             LOCK(existing_spk_manager->cs_desc_man);\n             if (range_start > existing_spk_manager->GetWalletDescriptor().range_start) {\n@@ -1552,7 +1552,7 @@ static UniValue ProcessDescriptorImport(CWallet * const pwallet, const UniValue&\n         }\n \n         // Add descriptor to the wallet\n-        auto spk_manager = pwallet->AddWalletDescriptor(w_desc, keys, label, internal);\n+        auto spk_manager = wallet.AddWalletDescriptor(w_desc, keys, label, internal);\n         if (spk_manager == nullptr) {\n             throw JSONRPCError(RPC_WALLET_ERROR, strprintf(\"Could not add descriptor '%s'\", descriptor));\n         }\n@@ -1562,7 +1562,7 @@ static UniValue ProcessDescriptorImport(CWallet * const pwallet, const UniValue&\n             if (!w_desc.descriptor->GetOutputType()) {\n                 warnings.push_back(\"Unknown output type, cannot set descriptor to active.\");\n             } else {\n-                pwallet->AddActiveScriptPubKeyMan(spk_manager->GetID(), *w_desc.descriptor->GetOutputType(), internal);\n+                wallet.AddActiveScriptPubKeyMan(spk_manager->GetID(), *w_desc.descriptor->GetOutputType(), internal);\n             }\n         }\n \n@@ -1655,15 +1655,15 @@ RPCHelpMan importdescriptors()\n     UniValue response(UniValue::VARR);\n     {\n         LOCK(pwallet->cs_wallet);\n-        EnsureWalletIsUnlocked(pwallet.get());\n+        EnsureWalletIsUnlocked(*pwallet);\n \n         CHECK_NONFATAL(pwallet->chain().findBlock(pwallet->GetLastBlockHash(), FoundBlock().time(lowest_timestamp).mtpTime(now)));\n \n         // Get all timestamps and extract the lowest timestamp\n         for (const UniValue& request : requests.getValues()) {\n             // This throws an error if \"timestamp\" doesn't exist\n             const int64_t timestamp = std::max(GetImportTimestamp(request, now), minimum_timestamp);\n-            const UniValue result = ProcessDescriptorImport(pwallet.get(), request, timestamp);\n+            const UniValue result = ProcessDescriptorImport(*pwallet, request, timestamp);\n             response.push_back(result);\n \n             if (lowest_timestamp > timestamp ) {\n@@ -1765,7 +1765,7 @@ RPCHelpMan listdescriptors()\n         throw JSONRPCError(RPC_WALLET_ERROR, \"listdescriptors is not available for non-descriptor wallets\");\n     }\n \n-    EnsureWalletIsUnlocked(wallet.get());\n+    EnsureWalletIsUnlocked(*wallet);\n \n     LOCK(wallet->cs_wallet);\n "
      },
      {
        "sha": "8b0962f9ee00998ae9d20c7caeed8ea8052aa883",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 56,
        "deletions": 57,
        "changes": 113,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c90c67b7e6f598f9ffdc136ded2b533b78ed044/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c90c67b7e6f598f9ffdc136ded2b533b78ed044/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=7c90c67b7e6f598f9ffdc136ded2b533b78ed044",
        "patch": "@@ -48,8 +48,8 @@ using interfaces::FoundBlock;\n static const std::string WALLET_ENDPOINT_BASE = \"/wallet/\";\n static const std::string HELP_REQUIRING_PASSPHRASE{\"\\nRequires wallet passphrase to be set with walletpassphrase call if wallet is encrypted.\\n\"};\n \n-static inline bool GetAvoidReuseFlag(const CWallet* const pwallet, const UniValue& param) {\n-    bool can_avoid_reuse = pwallet->IsWalletFlagSet(WALLET_FLAG_AVOID_REUSE);\n+static inline bool GetAvoidReuseFlag(const CWallet& wallet, const UniValue& param) {\n+    bool can_avoid_reuse = wallet.IsWalletFlagSet(WALLET_FLAG_AVOID_REUSE);\n     bool avoid_reuse = param.isNull() ? can_avoid_reuse : param.get_bool();\n \n     if (avoid_reuse && !can_avoid_reuse) {\n@@ -64,11 +64,11 @@ static inline bool GetAvoidReuseFlag(const CWallet* const pwallet, const UniValu\n  *  We default to true for watchonly wallets if include_watchonly isn't\n  *  explicitly set.\n  */\n-static bool ParseIncludeWatchonly(const UniValue& include_watchonly, const CWallet& pwallet)\n+static bool ParseIncludeWatchonly(const UniValue& include_watchonly, const CWallet& wallet)\n {\n     if (include_watchonly.isNull()) {\n         // if include_watchonly isn't explicitly set, then check if we have a watchonly wallet\n-        return pwallet.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS);\n+        return wallet.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS);\n     }\n \n     // otherwise return whatever include_watchonly was set to\n@@ -117,9 +117,9 @@ std::shared_ptr<CWallet> GetWalletForJSONRPCRequest(const JSONRPCRequest& reques\n         \"Wallet file not specified (must request wallet RPC through /wallet/<filename> uri-path).\");\n }\n \n-void EnsureWalletIsUnlocked(const CWallet* pwallet)\n+void EnsureWalletIsUnlocked(const CWallet& wallet)\n {\n-    if (pwallet->IsLocked()) {\n+    if (wallet.IsLocked()) {\n         throw JSONRPCError(RPC_WALLET_UNLOCK_NEEDED, \"Error: Please enter the wallet passphrase with walletpassphrase first.\");\n     }\n }\n@@ -393,13 +393,13 @@ void ParseRecipients(const UniValue& address_amounts, const UniValue& subtract_f\n     }\n }\n \n-UniValue SendMoney(CWallet* const pwallet, const CCoinControl &coin_control, std::vector<CRecipient> &recipients, mapValue_t map_value, bool verbose)\n+UniValue SendMoney(CWallet& wallet, const CCoinControl &coin_control, std::vector<CRecipient> &recipients, mapValue_t map_value, bool verbose)\n {\n-    EnsureWalletIsUnlocked(pwallet);\n+    EnsureWalletIsUnlocked(wallet);\n \n     // This function is only used by sendtoaddress and sendmany.\n     // This should always try to sign, if we don't have private keys, don't try to do anything here.\n-    if (pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {\n+    if (wallet.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Error: Private keys are disabled for this wallet\");\n     }\n \n@@ -412,11 +412,11 @@ UniValue SendMoney(CWallet* const pwallet, const CCoinControl &coin_control, std\n     bilingual_str error;\n     CTransactionRef tx;\n     FeeCalculation fee_calc_out;\n-    const bool fCreated = pwallet->CreateTransaction(recipients, tx, nFeeRequired, nChangePosRet, error, coin_control, fee_calc_out, true);\n+    const bool fCreated = wallet.CreateTransaction(recipients, tx, nFeeRequired, nChangePosRet, error, coin_control, fee_calc_out, true);\n     if (!fCreated) {\n         throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, error.original);\n     }\n-    pwallet->CommitTransaction(tx, std::move(map_value), {} /* orderForm */);\n+    wallet.CommitTransaction(tx, std::move(map_value), {} /* orderForm */);\n     if (verbose) {\n         UniValue entry(UniValue::VOBJ);\n         entry.pushKV(\"txid\", tx->GetHash().GetHex());\n@@ -503,13 +503,13 @@ static RPCHelpMan sendtoaddress()\n         coin_control.m_signal_bip125_rbf = request.params[5].get_bool();\n     }\n \n-    coin_control.m_avoid_address_reuse = GetAvoidReuseFlag(pwallet.get(), request.params[8]);\n+    coin_control.m_avoid_address_reuse = GetAvoidReuseFlag(*pwallet, request.params[8]);\n     // We also enable partial spend avoidance if reuse avoidance is set.\n     coin_control.m_avoid_partial_spends |= coin_control.m_avoid_address_reuse;\n \n     SetFeeEstimateMode(*pwallet, coin_control, /* conf_target */ request.params[6], /* estimate_mode */ request.params[7], /* fee_rate */ request.params[9], /* override_min_fee */ false);\n \n-    EnsureWalletIsUnlocked(pwallet.get());\n+    EnsureWalletIsUnlocked(*pwallet);\n \n     UniValue address_amounts(UniValue::VOBJ);\n     const std::string address = request.params[0].get_str();\n@@ -523,7 +523,7 @@ static RPCHelpMan sendtoaddress()\n     ParseRecipients(address_amounts, subtractFeeFromAmount, recipients);\n     const bool verbose{request.params[10].isNull() ? false : request.params[10].get_bool()};\n \n-    return SendMoney(pwallet.get(), coin_control, recipients, mapValue, verbose);\n+    return SendMoney(*pwallet, coin_control, recipients, mapValue, verbose);\n },\n     };\n }\n@@ -617,7 +617,7 @@ static RPCHelpMan signmessage()\n \n     LOCK(pwallet->cs_wallet);\n \n-    EnsureWalletIsUnlocked(pwallet.get());\n+    EnsureWalletIsUnlocked(*pwallet);\n \n     std::string strAddress = request.params[0].get_str();\n     std::string strMessage = request.params[1].get_str();\n@@ -813,7 +813,7 @@ static RPCHelpMan getbalance()\n \n     bool include_watchonly = ParseIncludeWatchonly(request.params[2], *pwallet);\n \n-    bool avoid_reuse = GetAvoidReuseFlag(pwallet.get(), request.params[3]);\n+    bool avoid_reuse = GetAvoidReuseFlag(*pwallet, request.params[3]);\n \n     const auto bal = pwallet->GetBalance(min_depth, avoid_reuse);\n \n@@ -934,7 +934,7 @@ static RPCHelpMan sendmany()\n     ParseRecipients(sendTo, subtractFeeFromAmount, recipients);\n     const bool verbose{request.params[9].isNull() ? false : request.params[9].get_bool()};\n \n-    return SendMoney(pwallet.get(), coin_control, recipients, std::move(mapValue), verbose);\n+    return SendMoney(*pwallet, coin_control, recipients, std::move(mapValue), verbose);\n },\n     };\n }\n@@ -1033,7 +1033,7 @@ struct tallyitem\n     }\n };\n \n-static UniValue ListReceived(const CWallet* const pwallet, const UniValue& params, bool by_label) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static UniValue ListReceived(const CWallet& wallet, const UniValue& params, bool by_label) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet)\n {\n     // Minimum confirmations\n     int nMinDepth = 1;\n@@ -1047,7 +1047,7 @@ static UniValue ListReceived(const CWallet* const pwallet, const UniValue& param\n \n     isminefilter filter = ISMINE_SPENDABLE;\n \n-    if (ParseIncludeWatchonly(params[2], *pwallet)) {\n+    if (ParseIncludeWatchonly(params[2], wallet)) {\n         filter |= ISMINE_WATCH_ONLY;\n     }\n \n@@ -1063,10 +1063,10 @@ static UniValue ListReceived(const CWallet* const pwallet, const UniValue& param\n \n     // Tally\n     std::map<CTxDestination, tallyitem> mapTally;\n-    for (const std::pair<const uint256, CWalletTx>& pairWtx : pwallet->mapWallet) {\n+    for (const std::pair<const uint256, CWalletTx>& pairWtx : wallet.mapWallet) {\n         const CWalletTx& wtx = pairWtx.second;\n \n-        if (wtx.IsCoinBase() || !pwallet->chain().checkFinalTx(*wtx.tx)) {\n+        if (wtx.IsCoinBase() || !wallet.chain().checkFinalTx(*wtx.tx)) {\n             continue;\n         }\n \n@@ -1084,7 +1084,7 @@ static UniValue ListReceived(const CWallet* const pwallet, const UniValue& param\n                 continue;\n             }\n \n-            isminefilter mine = pwallet->IsMine(address);\n+            isminefilter mine = wallet.IsMine(address);\n             if(!(mine & filter))\n                 continue;\n \n@@ -1103,11 +1103,11 @@ static UniValue ListReceived(const CWallet* const pwallet, const UniValue& param\n \n     // Create m_address_book iterator\n     // If we aren't filtering, go from begin() to end()\n-    auto start = pwallet->m_address_book.begin();\n-    auto end = pwallet->m_address_book.end();\n+    auto start = wallet.m_address_book.begin();\n+    auto end = wallet.m_address_book.end();\n     // If we are filtering, find() the applicable entry\n     if (has_filtered_address) {\n-        start = pwallet->m_address_book.find(filtered_address);\n+        start = wallet.m_address_book.find(filtered_address);\n         if (start != end) {\n             end = std::next(start);\n         }\n@@ -1224,7 +1224,7 @@ static RPCHelpMan listreceivedbyaddress()\n \n     LOCK(pwallet->cs_wallet);\n \n-    return ListReceived(pwallet.get(), request.params, false);\n+    return ListReceived(*pwallet, request.params, false);\n },\n     };\n }\n@@ -1266,7 +1266,7 @@ static RPCHelpMan listreceivedbylabel()\n \n     LOCK(pwallet->cs_wallet);\n \n-    return ListReceived(pwallet.get(), request.params, true);\n+    return ListReceived(*pwallet, request.params, true);\n },\n     };\n }\n@@ -1289,7 +1289,7 @@ static void MaybePushAddress(UniValue & entry, const CTxDestination &dest)\n  * @param  filter_ismine  The \"is mine\" filter flags.\n  * @param  filter_label   Optional label string to filter incoming transactions.\n  */\n-static void ListTransactions(const CWallet* const pwallet, const CWalletTx& wtx, int nMinDepth, bool fLong, UniValue& ret, const isminefilter& filter_ismine, const std::string* filter_label) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ListTransactions(const CWallet& wallet, const CWalletTx& wtx, int nMinDepth, bool fLong, UniValue& ret, const isminefilter& filter_ismine, const std::string* filter_label) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet)\n {\n     CAmount nFee;\n     std::list<COutputEntry> listReceived;\n@@ -1305,20 +1305,20 @@ static void ListTransactions(const CWallet* const pwallet, const CWalletTx& wtx,\n         for (const COutputEntry& s : listSent)\n         {\n             UniValue entry(UniValue::VOBJ);\n-            if (involvesWatchonly || (pwallet->IsMine(s.destination) & ISMINE_WATCH_ONLY)) {\n+            if (involvesWatchonly || (wallet.IsMine(s.destination) & ISMINE_WATCH_ONLY)) {\n                 entry.pushKV(\"involvesWatchonly\", true);\n             }\n             MaybePushAddress(entry, s.destination);\n             entry.pushKV(\"category\", \"send\");\n             entry.pushKV(\"amount\", ValueFromAmount(-s.amount));\n-            const auto* address_book_entry = pwallet->FindAddressBookEntry(s.destination);\n+            const auto* address_book_entry = wallet.FindAddressBookEntry(s.destination);\n             if (address_book_entry) {\n                 entry.pushKV(\"label\", address_book_entry->GetLabel());\n             }\n             entry.pushKV(\"vout\", s.vout);\n             entry.pushKV(\"fee\", ValueFromAmount(-nFee));\n             if (fLong)\n-                WalletTxToJSON(pwallet->chain(), wtx, entry);\n+                WalletTxToJSON(wallet.chain(), wtx, entry);\n             entry.pushKV(\"abandoned\", wtx.isAbandoned());\n             ret.push_back(entry);\n         }\n@@ -1329,15 +1329,15 @@ static void ListTransactions(const CWallet* const pwallet, const CWalletTx& wtx,\n         for (const COutputEntry& r : listReceived)\n         {\n             std::string label;\n-            const auto* address_book_entry = pwallet->FindAddressBookEntry(r.destination);\n+            const auto* address_book_entry = wallet.FindAddressBookEntry(r.destination);\n             if (address_book_entry) {\n                 label = address_book_entry->GetLabel();\n             }\n             if (filter_label && label != *filter_label) {\n                 continue;\n             }\n             UniValue entry(UniValue::VOBJ);\n-            if (involvesWatchonly || (pwallet->IsMine(r.destination) & ISMINE_WATCH_ONLY)) {\n+            if (involvesWatchonly || (wallet.IsMine(r.destination) & ISMINE_WATCH_ONLY)) {\n                 entry.pushKV(\"involvesWatchonly\", true);\n             }\n             MaybePushAddress(entry, r.destination);\n@@ -1360,7 +1360,7 @@ static void ListTransactions(const CWallet* const pwallet, const CWalletTx& wtx,\n             }\n             entry.pushKV(\"vout\", r.vout);\n             if (fLong)\n-                WalletTxToJSON(pwallet->chain(), wtx, entry);\n+                WalletTxToJSON(wallet.chain(), wtx, entry);\n             ret.push_back(entry);\n         }\n     }\n@@ -1479,7 +1479,7 @@ static RPCHelpMan listtransactions()\n         for (CWallet::TxItems::const_reverse_iterator it = txOrdered.rbegin(); it != txOrdered.rend(); ++it)\n         {\n             CWalletTx *const pwtx = (*it).second;\n-            ListTransactions(pwallet.get(), *pwtx, 0, true, ret, filter, filter_label);\n+            ListTransactions(*pwallet, *pwtx, 0, true, ret, filter, filter_label);\n             if ((int)ret.size() >= (nCount+nFrom)) break;\n         }\n     }\n@@ -1601,7 +1601,7 @@ static RPCHelpMan listsinceblock()\n         const CWalletTx& tx = pairWtx.second;\n \n         if (depth == -1 || abs(tx.GetDepthInMainChain()) < depth) {\n-            ListTransactions(&wallet, tx, 0, true, transactions, filter, nullptr /* filter_label */);\n+            ListTransactions(wallet, tx, 0, true, transactions, filter, nullptr /* filter_label */);\n         }\n     }\n \n@@ -1618,7 +1618,7 @@ static RPCHelpMan listsinceblock()\n             if (it != wallet.mapWallet.end()) {\n                 // We want all transactions regardless of confirmation count to appear here,\n                 // even negative confirmation ones, hence the big negative.\n-                ListTransactions(&wallet, it->second, -100000000, true, removed, filter, nullptr /* filter_label */);\n+                ListTransactions(wallet, it->second, -100000000, true, removed, filter, nullptr /* filter_label */);\n             }\n         }\n         blockId = block.hashPrevBlock;\n@@ -1733,7 +1733,7 @@ static RPCHelpMan gettransaction()\n     WalletTxToJSON(pwallet->chain(), wtx, entry);\n \n     UniValue details(UniValue::VARR);\n-    ListTransactions(pwallet.get(), wtx, 0, false, details, filter, nullptr /* filter_label */);\n+    ListTransactions(*pwallet, wtx, 0, false, details, filter, nullptr /* filter_label */);\n     entry.pushKV(\"details\", details);\n \n     std::string strHex = EncodeHexTx(*wtx.tx, pwallet->chain().rpcSerializationFlags());\n@@ -1858,7 +1858,7 @@ static RPCHelpMan keypoolrefill()\n         kpSize = (unsigned int)request.params[0].get_int();\n     }\n \n-    EnsureWalletIsUnlocked(pwallet.get());\n+    EnsureWalletIsUnlocked(*pwallet);\n     pwallet->TopUpKeyPool(kpSize);\n \n     if (pwallet->GetKeyPoolSize() < kpSize) {\n@@ -3052,11 +3052,11 @@ static RPCHelpMan listunspent()\n     };\n }\n \n-void FundTransaction(CWallet* const pwallet, CMutableTransaction& tx, CAmount& fee_out, int& change_position, const UniValue& options, CCoinControl& coinControl, bool override_min_fee)\n+void FundTransaction(CWallet& wallet, CMutableTransaction& tx, CAmount& fee_out, int& change_position, const UniValue& options, CCoinControl& coinControl, bool override_min_fee)\n {\n     // Make sure the results are valid at least up to the most recent block\n     // the user could have gotten from another RPC command prior to now\n-    pwallet->BlockUntilSyncedToCurrentChain();\n+    wallet.BlockUntilSyncedToCurrentChain();\n \n     change_position = -1;\n     bool lockUnspents = false;\n@@ -3127,7 +3127,7 @@ void FundTransaction(CWallet* const pwallet, CMutableTransaction& tx, CAmount& f\n         }\n \n         const UniValue include_watching_option = options.exists(\"include_watching\") ? options[\"include_watching\"] : options[\"includeWatching\"];\n-        coinControl.fAllowWatchOnly = ParseIncludeWatchonly(include_watching_option, *pwallet);\n+        coinControl.fAllowWatchOnly = ParseIncludeWatchonly(include_watching_option, wallet);\n \n         if (options.exists(\"lockUnspents\") || options.exists(\"lock_unspents\")) {\n             lockUnspents = (options.exists(\"lock_unspents\") ? options[\"lock_unspents\"] : options[\"lockUnspents\"]).get_bool();\n@@ -3153,11 +3153,11 @@ void FundTransaction(CWallet* const pwallet, CMutableTransaction& tx, CAmount& f\n         if (options.exists(\"replaceable\")) {\n             coinControl.m_signal_bip125_rbf = options[\"replaceable\"].get_bool();\n         }\n-        SetFeeEstimateMode(*pwallet, coinControl, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], override_min_fee);\n+        SetFeeEstimateMode(wallet, coinControl, options[\"conf_target\"], options[\"estimate_mode\"], options[\"fee_rate\"], override_min_fee);\n       }\n     } else {\n         // if options is null and not a bool\n-        coinControl.fAllowWatchOnly = ParseIncludeWatchonly(NullUniValue, *pwallet);\n+        coinControl.fAllowWatchOnly = ParseIncludeWatchonly(NullUniValue, wallet);\n     }\n \n     if (tx.vout.size() == 0)\n@@ -3179,7 +3179,7 @@ void FundTransaction(CWallet* const pwallet, CMutableTransaction& tx, CAmount& f\n \n     bilingual_str error;\n \n-    if (!pwallet->FundTransaction(tx, fee_out, change_position, error, lockUnspents, setSubtractFeeFromOutputs, coinControl)) {\n+    if (!wallet.FundTransaction(tx, fee_out, change_position, error, lockUnspents, setSubtractFeeFromOutputs, coinControl)) {\n         throw JSONRPCError(RPC_WALLET_ERROR, error.original);\n     }\n }\n@@ -3273,7 +3273,7 @@ static RPCHelpMan fundrawtransaction()\n     CCoinControl coin_control;\n     // Automatically select (additional) coins. Can be overridden by options.add_inputs.\n     coin_control.m_add_inputs = true;\n-    FundTransaction(pwallet.get(), tx, fee, change_position, request.params[1], coin_control, /* override_min_fee */ true);\n+    FundTransaction(*pwallet, tx, fee, change_position, request.params[1], coin_control, /* override_min_fee */ true);\n \n     UniValue result(UniValue::VOBJ);\n     result.pushKV(\"hex\", EncodeHexTx(CTransaction(tx)));\n@@ -3352,7 +3352,7 @@ RPCHelpMan signrawtransactionwithwallet()\n \n     // Sign the transaction\n     LOCK(pwallet->cs_wallet);\n-    EnsureWalletIsUnlocked(pwallet.get());\n+    EnsureWalletIsUnlocked(*pwallet);\n \n     // Fetch previous transactions (inputs):\n     std::map<COutPoint, Coin> coins;\n@@ -3483,7 +3483,8 @@ static RPCHelpMan bumpfee_helper(std::string method_name)\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n     LOCK(pwallet->cs_wallet);\n-    EnsureWalletIsUnlocked(pwallet.get());\n+\n+    EnsureWalletIsUnlocked(*pwallet);\n \n \n     std::vector<bilingual_str> errors;\n@@ -3727,15 +3728,13 @@ class DescribeWalletAddressVisitor\n     UniValue operator()(const WitnessUnknown& id) const { return UniValue(UniValue::VOBJ); }\n };\n \n-static UniValue DescribeWalletAddress(const CWallet* const pwallet, const CTxDestination& dest)\n+static UniValue DescribeWalletAddress(const CWallet& wallet, const CTxDestination& dest)\n {\n     UniValue ret(UniValue::VOBJ);\n     UniValue detail = DescribeAddress(dest);\n     CScript script = GetScriptForDestination(dest);\n     std::unique_ptr<SigningProvider> provider = nullptr;\n-    if (pwallet) {\n-        provider = pwallet->GetSolvingProvider(script);\n-    }\n+    provider = wallet.GetSolvingProvider(script);\n     ret.pushKVs(detail);\n     ret.pushKVs(std::visit(DescribeWalletAddressVisitor(provider.get()), dest));\n     return ret;\n@@ -3854,7 +3853,7 @@ RPCHelpMan getaddressinfo()\n \n     ret.pushKV(\"iswatchonly\", bool(mine & ISMINE_WATCH_ONLY));\n \n-    UniValue detail = DescribeWalletAddress(pwallet.get(), dest);\n+    UniValue detail = DescribeWalletAddress(*pwallet, dest);\n     ret.pushKVs(detail);\n \n     ret.pushKV(\"ischange\", pwallet->IsChange(scriptPubKey));\n@@ -4149,7 +4148,7 @@ static RPCHelpMan send()\n             // Automatically select coins, unless at least one is manually selected. Can\n             // be overridden by options.add_inputs.\n             coin_control.m_add_inputs = rawTx.vin.size() == 0;\n-            FundTransaction(pwallet.get(), rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n+            FundTransaction(*pwallet, rawTx, fee, change_position, options, coin_control, /* override_min_fee */ false);\n \n             bool add_to_wallet = true;\n             if (options.exists(\"add_to_wallet\")) {\n@@ -4238,7 +4237,7 @@ static RPCHelpMan sethdseed()\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Cannot set an HD seed on a non-HD wallet. Use the upgradewallet RPC in order to upgrade a non-HD wallet to HD\");\n     }\n \n-    EnsureWalletIsUnlocked(pwallet.get());\n+    EnsureWalletIsUnlocked(*pwallet);\n \n     bool flush_key_pool = true;\n     if (!request.params[0].isNull()) {\n@@ -4435,7 +4434,7 @@ static RPCHelpMan walletcreatefundedpsbt()\n     // Automatically select coins, unless at least one is manually selected. Can\n     // be overridden by options.add_inputs.\n     coin_control.m_add_inputs = rawTx.vin.size() == 0;\n-    FundTransaction(pwallet.get(), rawTx, fee, change_position, request.params[3], coin_control, /* override_min_fee */ true);\n+    FundTransaction(*pwallet, rawTx, fee, change_position, request.params[3], coin_control, /* override_min_fee */ true);\n \n     // Make a blank psbt\n     PartiallySignedTransaction psbtx(rawTx);\n@@ -4490,7 +4489,7 @@ static RPCHelpMan upgradewallet()\n \n     RPCTypeCheck(request.params, {UniValue::VNUM}, true);\n \n-    EnsureWalletIsUnlocked(pwallet.get());\n+    EnsureWalletIsUnlocked(*pwallet);\n \n     int version = 0;\n     if (!request.params[0].isNull()) {"
      },
      {
        "sha": "b82fe1ec76870de6e24c5162816d5319acaeafda",
        "filename": "src/wallet/rpcwallet.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c90c67b7e6f598f9ffdc136ded2b533b78ed044/src/wallet/rpcwallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c90c67b7e6f598f9ffdc136ded2b533b78ed044/src/wallet/rpcwallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.h?ref=7c90c67b7e6f598f9ffdc136ded2b533b78ed044",
        "patch": "@@ -30,7 +30,7 @@ Span<const CRPCCommand> GetWalletRPCCommands();\n  */\n std::shared_ptr<CWallet> GetWalletForJSONRPCRequest(const JSONRPCRequest& request);\n \n-void EnsureWalletIsUnlocked(const CWallet*);\n+void EnsureWalletIsUnlocked(const CWallet&);\n WalletContext& EnsureWalletContext(const util::Ref& context);\n LegacyScriptPubKeyMan& EnsureLegacyScriptPubKeyMan(CWallet& wallet, bool also_create = false);\n "
      }
    ]
  }
]