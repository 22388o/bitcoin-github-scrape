[
  {
    "sha": "3ba9283a47ac358168db9db7840ae559f443486c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozYmE5MjgzYTQ3YWMzNTgxNjhkYjlkYjc4NDBhZTU1OWY0NDM0ODZj",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2020-10-19T10:49:42Z"
      },
      "committer": {
        "name": "Sjors Provoost",
        "email": "sjors@sprovoost.nl",
        "date": "2021-03-03T13:12:16Z"
      },
      "message": "tests: more helpful errors for failing versionbits tests\n\nCo-authored-by: Sjors Provoost <sjors@sprovoost.nl>",
      "tree": {
        "sha": "b04af7b4e5c69ec069be42e4e70b189d905d5838",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b04af7b4e5c69ec069be42e4e70b189d905d5838"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3ba9283a47ac358168db9db7840ae559f443486c",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7ZvfetalXiMuhFJCV/+b28wwEAkFAmA/izIACgkQV/+b28ww\nEAks3w//VOYmUC9jUsc7tfa63iM4rX4uKuOaprqCgPgLRcW+SOXnxAkfN9CqlxN1\np1yVFhnZS07zgVygnWv/rZIrcjWbxghZwVojc1SI8RYN7LF1tuZX+UTWQ+iFA1/h\nfxcyynduj43BZ60yj/tHW8MUxbEE1ZsPVrGh6O70zXoU/WCaQG9yjL/HsYG8nur5\naNyqhIPHF/JXukkKOV9XHsIIDxOvyFtGI/grlg8nPOHqER5ofw1JG4oDjk6HfOil\nuZh3V2waF5ZoDgJRQ+AIVWmvtVLchX9tB51nz4J9VIoMlkRw6jn6cfOnkgJMz/zk\n/nu2VKOef//UwIy0+Dd1PnYIrnHRTqD/sF30jit1y94F9Uoxocqf+4SFU5yKU69c\npDeiv1DU8ZNo4u0B8doVWiYJ48xoVVccHvdyfRFlRgsd2X2wBky7LL+S2oOnwZcF\nyh8jh9ijM3ekYXOXurO7SYY/dzV7qCmFybblZKlcBBETHWwpu2IF1KDG0WW6OgRC\ntR0/b1bTeBddELi2U5HLC8ToV87sPgEcAPldU8Htiv/t2hCjgwkcItgH4y5/jloI\nx68CvpmL5jpV1m6M/Xv/d8sW/jhF2pJKcwYX62Gu8CDEior6wSfgbYrEGk+izLDj\n3/iaVgiwqSsjwYBG1xKCPwH5E0zlHc7nR48UcWEbwznuyZwbtZw=\n=tnq7\n-----END PGP SIGNATURE-----",
        "payload": "tree b04af7b4e5c69ec069be42e4e70b189d905d5838\nparent 831675c8dccfa6525ffe751da3cc60709c380953\nauthor Anthony Towns <aj@erisian.com.au> 1603104582 +1000\ncommitter Sjors Provoost <sjors@sprovoost.nl> 1614777136 +0100\n\ntests: more helpful errors for failing versionbits tests\n\nCo-authored-by: Sjors Provoost <sjors@sprovoost.nl>\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3ba9283a47ac358168db9db7840ae559f443486c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3ba9283a47ac358168db9db7840ae559f443486c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3ba9283a47ac358168db9db7840ae559f443486c/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "Sjors",
      "id": 10217,
      "node_id": "MDQ6VXNlcjEwMjE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Sjors",
      "html_url": "https://github.com/Sjors",
      "followers_url": "https://api.github.com/users/Sjors/followers",
      "following_url": "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url": "https://api.github.com/users/Sjors/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
      "organizations_url": "https://api.github.com/users/Sjors/orgs",
      "repos_url": "https://api.github.com/users/Sjors/repos",
      "events_url": "https://api.github.com/users/Sjors/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Sjors/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "831675c8dccfa6525ffe751da3cc60709c380953",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/831675c8dccfa6525ffe751da3cc60709c380953",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/831675c8dccfa6525ffe751da3cc60709c380953"
      }
    ],
    "stats": {
      "total": 72,
      "additions": 26,
      "deletions": 46
    },
    "files": [
      {
        "sha": "23b1709c8f7b0c71d28b5982c5ceb71b2e081dae",
        "filename": "src/test/versionbits_tests.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 46,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3ba9283a47ac358168db9db7840ae559f443486c/src/test/versionbits_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3ba9283a47ac358168db9db7840ae559f443486c/src/test/versionbits_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/versionbits_tests.cpp?ref=3ba9283a47ac358168db9db7840ae559f443486c",
        "patch": "@@ -14,6 +14,18 @@\n /* Define a virtual block time, one block per 10 minutes after Nov 14 2014, 0:55:36am */\n static int32_t TestTime(int nHeight) { return 1415926536 + 600 * nHeight; }\n \n+static const std::string StateName(ThresholdState state)\n+{\n+    switch (state) {\n+    case ThresholdState::DEFINED:   return \"DEFINED\";\n+    case ThresholdState::STARTED:   return \"STARTED\";\n+    case ThresholdState::LOCKED_IN: return \"LOCKED_IN\";\n+    case ThresholdState::ACTIVE:    return \"ACTIVE\";\n+    case ThresholdState::FAILED:    return \"FAILED\";\n+    } // no default case, so the compiler can warn about missing cases\n+    return \"\";\n+}\n+\n static const Consensus::Params paramsDummy = Consensus::Params();\n \n class TestConditionChecker : public AbstractThresholdConditionChecker\n@@ -98,60 +110,28 @@ class VersionBitsTester\n         return *this;\n     }\n \n-    VersionBitsTester& TestDefined() {\n-        for (int i = 0; i < CHECKERS; i++) {\n-            if (InsecureRandBits(i) == 0) {\n-                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::DEFINED, strprintf(\"Test %i for DEFINED\", num));\n-                BOOST_CHECK_MESSAGE(checker_always[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::ACTIVE, strprintf(\"Test %i for ACTIVE (always active)\", num));\n-            }\n-        }\n-        num++;\n-        return *this;\n-    }\n-\n-    VersionBitsTester& TestStarted() {\n-        for (int i = 0; i < CHECKERS; i++) {\n-            if (InsecureRandBits(i) == 0) {\n-                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::STARTED, strprintf(\"Test %i for STARTED\", num));\n-                BOOST_CHECK_MESSAGE(checker_always[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::ACTIVE, strprintf(\"Test %i for ACTIVE (always active)\", num));\n-            }\n-        }\n-        num++;\n-        return *this;\n-    }\n-\n-    VersionBitsTester& TestLockedIn() {\n+    VersionBitsTester& TestState(ThresholdState exp) {\n         for (int i = 0; i < CHECKERS; i++) {\n             if (InsecureRandBits(i) == 0) {\n-                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::LOCKED_IN, strprintf(\"Test %i for LOCKED_IN\", num));\n-                BOOST_CHECK_MESSAGE(checker_always[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::ACTIVE, strprintf(\"Test %i for ACTIVE (always active)\", num));\n+                const CBlockIndex* pindex = vpblock.empty() ? nullptr : vpblock.back();\n+                ThresholdState got = checker[i].GetStateFor(pindex);\n+                ThresholdState got_always = checker_always[i].GetStateFor(pindex);\n+                // nHeight of the next block. If vpblock is empty, the next (ie first)\n+                // block should be the genesis block with nHeight == 0.\n+                int height = pindex == nullptr ? 0 : pindex->nHeight + 1;\n+                BOOST_CHECK_MESSAGE(got == exp, strprintf(\"Test %i for %s height %d (got %s)\", num, StateName(exp), height, StateName(got)));\n+                BOOST_CHECK_MESSAGE(got_always == ThresholdState::ACTIVE, strprintf(\"Test %i for ACTIVE height %d (got %s; always active case)\", num, height, StateName(got_always)));\n             }\n         }\n         num++;\n         return *this;\n     }\n \n-    VersionBitsTester& TestActive() {\n-        for (int i = 0; i < CHECKERS; i++) {\n-            if (InsecureRandBits(i) == 0) {\n-                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::ACTIVE, strprintf(\"Test %i for ACTIVE\", num));\n-                BOOST_CHECK_MESSAGE(checker_always[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::ACTIVE, strprintf(\"Test %i for ACTIVE (always active)\", num));\n-            }\n-        }\n-        num++;\n-        return *this;\n-    }\n-\n-    VersionBitsTester& TestFailed() {\n-        for (int i = 0; i < CHECKERS; i++) {\n-            if (InsecureRandBits(i) == 0) {\n-                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::FAILED, strprintf(\"Test %i for FAILED\", num));\n-                BOOST_CHECK_MESSAGE(checker_always[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::ACTIVE, strprintf(\"Test %i for ACTIVE (always active)\", num));\n-            }\n-        }\n-        num++;\n-        return *this;\n-    }\n+    VersionBitsTester& TestDefined() { return TestState(ThresholdState::DEFINED); }\n+    VersionBitsTester& TestStarted() { return TestState(ThresholdState::STARTED); }\n+    VersionBitsTester& TestLockedIn() { return TestState(ThresholdState::LOCKED_IN); }\n+    VersionBitsTester& TestActive() { return TestState(ThresholdState::ACTIVE); }\n+    VersionBitsTester& TestFailed() { return TestState(ThresholdState::FAILED); }\n \n     CBlockIndex * Tip() { return vpblock.size() ? vpblock.back() : nullptr; }\n };"
      }
    ]
  },
  {
    "sha": "0c471a5f306044cbd2eb230714571f05dd6aaf3c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowYzQ3MWE1ZjMwNjA0NGNiZDJlYjIzMDcxNDU3MWYwNWRkNmFhZjNj",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2020-10-19T12:59:50Z"
      },
      "committer": {
        "name": "Sjors Provoost",
        "email": "sjors@sprovoost.nl",
        "date": "2021-03-03T13:14:40Z"
      },
      "message": "tests: check never active versionbits",
      "tree": {
        "sha": "6c5c83cb4ccc6efdbdbb28744cbb89a7a1405343",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6c5c83cb4ccc6efdbdbb28744cbb89a7a1405343"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0c471a5f306044cbd2eb230714571f05dd6aaf3c",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7ZvfetalXiMuhFJCV/+b28wwEAkFAmA/i8IACgkQV/+b28ww\nEAk7zg/9GJTKjaKu/5wb4edmpVq6Dt1N2r4WMBxCow1qWQ+PYWSx1gzb0fyxa53V\ncEDZ5J/h73Plv3JBqdME89/O5Uv/rt1JHEuH2mB/15FeI/ucBqONoOQ4NyAVyJvA\nm7MHaCgDyXh/hnlvECZLuhRfF/b5UOJQy6Y+Pcikhgf6+P6QqoWxWi7coNbl0A/Y\nA56hkTXkzg544I7nQ4WhwTPcLk0T8gDY0UOBi6uH1WwQN4bT7OhvLDSIuUocc5Ho\nmukoi0CzBZEkaO4gcejnuHnVA77N1hF7i8dmPygXkTDq60dKYzJFVAlQ5AbUWo+L\nEcecrxz8qE1p2ruWiM8uPyHNL/TRi8VLCvRzyV9uAxuR1icnVwDwe6zafSG8A28p\n55IQiXsBG5ceT25UgAEK4FSs5h7AxqqFWXQwyrwNZuR9tXePxQ1eV6osQDzA268e\nrTGY8qjEqDt38KBv+2IJGZc5ki9B3ufY6l5oVnSo8ULwaN9FW7a50MZk/TyNv3Fu\n0WZIx/74UiaJ412F2dxlvZ1FuxB13SMaXqSdbfvbNCZSLFoMd4hD4hG/UpW7X/7y\n6D+wCjRBl1mlj5+iE93U6KctuL/cnv9cWQe7OcyKCDv5IqpatFHMkjVGf/2301A/\nsRDnFuudvhUwgvYtTvjWqgBVr0Y0NNETvS5CnGxE3TtXFy9bLHQ=\n=AI1+\n-----END PGP SIGNATURE-----",
        "payload": "tree 6c5c83cb4ccc6efdbdbb28744cbb89a7a1405343\nparent 3ba9283a47ac358168db9db7840ae559f443486c\nauthor Anthony Towns <aj@erisian.com.au> 1603112390 +1000\ncommitter Sjors Provoost <sjors@sprovoost.nl> 1614777280 +0100\n\ntests: check never active versionbits\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0c471a5f306044cbd2eb230714571f05dd6aaf3c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0c471a5f306044cbd2eb230714571f05dd6aaf3c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0c471a5f306044cbd2eb230714571f05dd6aaf3c/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "Sjors",
      "id": 10217,
      "node_id": "MDQ6VXNlcjEwMjE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Sjors",
      "html_url": "https://github.com/Sjors",
      "followers_url": "https://api.github.com/users/Sjors/followers",
      "following_url": "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url": "https://api.github.com/users/Sjors/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
      "organizations_url": "https://api.github.com/users/Sjors/orgs",
      "repos_url": "https://api.github.com/users/Sjors/repos",
      "events_url": "https://api.github.com/users/Sjors/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Sjors/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3ba9283a47ac358168db9db7840ae559f443486c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3ba9283a47ac358168db9db7840ae559f443486c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3ba9283a47ac358168db9db7840ae559f443486c"
      }
    ],
    "stats": {
      "total": 16,
      "additions": 16,
      "deletions": 0
    },
    "files": [
      {
        "sha": "8841a540f2dfd426cdb324fcaa8bd6d058807b8a",
        "filename": "src/test/versionbits_tests.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0c471a5f306044cbd2eb230714571f05dd6aaf3c/src/test/versionbits_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0c471a5f306044cbd2eb230714571f05dd6aaf3c/src/test/versionbits_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/versionbits_tests.cpp?ref=0c471a5f306044cbd2eb230714571f05dd6aaf3c",
        "patch": "@@ -50,6 +50,13 @@ class TestAlwaysActiveConditionChecker : public TestConditionChecker\n     int64_t BeginTime(const Consensus::Params& params) const override { return Consensus::BIP9Deployment::ALWAYS_ACTIVE; }\n };\n \n+class TestNeverActiveConditionChecker : public TestConditionChecker\n+{\n+public:\n+    int64_t BeginTime(const Consensus::Params& params) const override { return 0; }\n+    int64_t EndTime(const Consensus::Params& params) const override { return 1230768000; }\n+};\n+\n #define CHECKERS 6\n \n class VersionBitsTester\n@@ -63,6 +70,8 @@ class VersionBitsTester\n     TestConditionChecker checker[CHECKERS];\n     // Another 6 that assume always active activation\n     TestAlwaysActiveConditionChecker checker_always[CHECKERS];\n+    // Another 6 that assume never active activation\n+    TestNeverActiveConditionChecker checker_never[CHECKERS];\n \n     // Test counter (to identify failures)\n     int num;\n@@ -77,6 +86,7 @@ class VersionBitsTester\n         for (unsigned int  i = 0; i < CHECKERS; i++) {\n             checker[i] = TestConditionChecker();\n             checker_always[i] = TestAlwaysActiveConditionChecker();\n+            checker_never[i] = TestNeverActiveConditionChecker();\n         }\n         vpblock.clear();\n         return *this;\n@@ -104,6 +114,10 @@ class VersionBitsTester\n             if (InsecureRandBits(i) == 0) {\n                 BOOST_CHECK_MESSAGE(checker[i].GetStateSinceHeightFor(vpblock.empty() ? nullptr : vpblock.back()) == height, strprintf(\"Test %i for StateSinceHeight\", num));\n                 BOOST_CHECK_MESSAGE(checker_always[i].GetStateSinceHeightFor(vpblock.empty() ? nullptr : vpblock.back()) == 0, strprintf(\"Test %i for StateSinceHeight (always active)\", num));\n+\n+                // never active may go from DEFINED -> FAILED at the first period\n+                const auto never_height = checker_never[i].GetStateSinceHeightFor(vpblock.empty() ? nullptr : vpblock.back());\n+                BOOST_CHECK_MESSAGE(never_height == 0 || never_height == checker_never[i].Period(paramsDummy), strprintf(\"Test %i for StateSinceHeight (never active)\", num));\n             }\n         }\n         num++;\n@@ -116,11 +130,13 @@ class VersionBitsTester\n                 const CBlockIndex* pindex = vpblock.empty() ? nullptr : vpblock.back();\n                 ThresholdState got = checker[i].GetStateFor(pindex);\n                 ThresholdState got_always = checker_always[i].GetStateFor(pindex);\n+                ThresholdState got_never = checker_never[i].GetStateFor(pindex);\n                 // nHeight of the next block. If vpblock is empty, the next (ie first)\n                 // block should be the genesis block with nHeight == 0.\n                 int height = pindex == nullptr ? 0 : pindex->nHeight + 1;\n                 BOOST_CHECK_MESSAGE(got == exp, strprintf(\"Test %i for %s height %d (got %s)\", num, StateName(exp), height, StateName(got)));\n                 BOOST_CHECK_MESSAGE(got_always == ThresholdState::ACTIVE, strprintf(\"Test %i for ACTIVE height %d (got %s; always active case)\", num, height, StateName(got_always)));\n+                BOOST_CHECK_MESSAGE(got_never == ThresholdState::DEFINED|| got_never == ThresholdState::FAILED, strprintf(\"Test %i for DEFINED/FAILED height %d (got %s; never active case)\", num, height, StateName(got_never)));\n             }\n         }\n         num++;"
      }
    ]
  },
  {
    "sha": "e775b0a6dd8358df0e8921739faf15942027239e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNzc1YjBhNmRkODM1OGRmMGU4OTIxNzM5ZmFmMTU5NDIwMjcyMzll",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-03-16T08:35:45Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-03-21T04:24:41Z"
      },
      "message": "tests: Add fuzzing harness for versionbits\n\nGithub-Pull: #21380\nRebased-From: 1639c3b76c3f2b74606f62ecd3ca725154e27f1b",
      "tree": {
        "sha": "ecf98f1b4c1805f67e0e2a7df221ecd9460f9f2f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ecf98f1b4c1805f67e0e2a7df221ecd9460f9f2f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e775b0a6dd8358df0e8921739faf15942027239e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e775b0a6dd8358df0e8921739faf15942027239e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e775b0a6dd8358df0e8921739faf15942027239e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e775b0a6dd8358df0e8921739faf15942027239e/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0c471a5f306044cbd2eb230714571f05dd6aaf3c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0c471a5f306044cbd2eb230714571f05dd6aaf3c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0c471a5f306044cbd2eb230714571f05dd6aaf3c"
      }
    ],
    "stats": {
      "total": 354,
      "additions": 353,
      "deletions": 1
    },
    "files": [
      {
        "sha": "45f2a04cde2404496cd5d47f9abfe8005461270c",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 8,
        "deletions": 1,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e775b0a6dd8358df0e8921739faf15942027239e/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e775b0a6dd8358df0e8921739faf15942027239e/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=e775b0a6dd8358df0e8921739faf15942027239e",
        "patch": "@@ -157,7 +157,8 @@ FUZZ_TARGETS = \\\n   test/fuzz/txrequest \\\n   test/fuzz/txundo_deserialize \\\n   test/fuzz/uint160_deserialize \\\n-  test/fuzz/uint256_deserialize\n+  test/fuzz/uint256_deserialize \\\n+  test/fuzz/versionbits\n \n if ENABLE_FUZZ\n noinst_PROGRAMS += $(FUZZ_TARGETS:=)\n@@ -1260,6 +1261,12 @@ test_fuzz_uint256_deserialize_LDADD = $(FUZZ_SUITE_LD_COMMON)\n test_fuzz_uint256_deserialize_LDFLAGS = $(FUZZ_SUITE_LDFLAGS_COMMON)\n test_fuzz_uint256_deserialize_SOURCES = test/fuzz/deserialize.cpp\n \n+test_fuzz_versionbits_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n+test_fuzz_versionbits_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n+test_fuzz_versionbits_LDADD = $(FUZZ_SUITE_LD_COMMON)\n+test_fuzz_versionbits_LDFLAGS = $(FUZZ_SUITE_LDFLAGS_COMMON)\n+test_fuzz_versionbits_SOURCES = test/fuzz/versionbits.cpp\n+\n endif # ENABLE_FUZZ\n \n nodist_test_test_bitcoin_SOURCES = $(GENERATED_TEST_FILES)"
      },
      {
        "sha": "992a5c13211874da073eafba1cf60cce6e6d977a",
        "filename": "src/test/fuzz/versionbits.cpp",
        "status": "added",
        "additions": 345,
        "deletions": 0,
        "changes": 345,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e775b0a6dd8358df0e8921739faf15942027239e/src/test/fuzz/versionbits.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e775b0a6dd8358df0e8921739faf15942027239e/src/test/fuzz/versionbits.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/versionbits.cpp?ref=e775b0a6dd8358df0e8921739faf15942027239e",
        "patch": "@@ -0,0 +1,345 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <limits>\n+#include <memory>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit)\n+        : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    int Period(const Consensus::Params& params) const override { return m_period; }\n+    int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<std::unique_ptr<CBlockIndex>> m_blocks;\n+    const uint32_t m_start_time;\n+    const uint32_t m_interval;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, uint32_t interval, int32_t signal, int32_t no_signal)\n+        : m_start_time{start_time}, m_interval{interval}, m_signal{signal}, m_no_signal{no_signal} {}\n+\n+    size_t size() const { return m_blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return m_blocks.empty() ? nullptr : m_blocks.back().get();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + m_blocks.size() * m_interval;\n+        header.nBits = 0x1d00ffff;\n+\n+        auto current_block = std::make_unique<CBlockIndex>(header);\n+        current_block->pprev = tip();\n+        current_block->nHeight = m_blocks.size();\n+        current_block->BuildSkip();\n+\n+        return m_blocks.emplace_back(std::move(current_block)).get();\n+    }\n+};\n+} // namespace\n+\n+void initialize()\n+{\n+    SelectParams(CBaseChainParams::MAIN);\n+}\n+\n+constexpr uint32_t MAX_TIME = 4102444800; // 2100-01-01\n+\n+void test_one_input(const std::vector<uint8_t>& buffer)\n+{\n+    const CChainParams& params = Params();\n+\n+    const int64_t interval = params.GetConsensus().nPowTargetSpacing;\n+    assert(interval > 1); // need to be able to halve it\n+    assert(interval < std::numeric_limits<int32_t>::max());\n+\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    // making period/max_periods larger slows these tests down significantly\n+    const int period = 32;\n+    const size_t max_periods = 16;\n+    const size_t max_blocks = 2 * period * max_periods;\n+\n+    const int threshold = fuzzed_data_provider.ConsumeIntegralInRange(1, period);\n+    assert(0 < threshold && threshold <= period); // must be able to both pass and fail threshold!\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(std::numeric_limits<uint32_t>::max() - MAX_TIME > interval * max_blocks);\n+\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(params.GenesisBlock().nTime, MAX_TIME);\n+\n+    // what values for version will we use to signal / not signal?\n+    const int32_t ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+    const int32_t ver_nosignal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+    // select deployment parameters: bit, start time, timeout\n+    const int bit = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, VERSIONBITS_NUM_BITS - 1);\n+\n+    bool always_active_test = false;\n+    bool never_active_test = false;\n+    int64_t start_time;\n+    int64_t timeout;\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        // pick the timestamp to switch based on a block\n+        // note states will change *after* these blocks because mediantime lags\n+        int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods - 3));\n+        int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods - 3));\n+\n+        start_time = block_start_time + start_block * interval;\n+        timeout = block_start_time + end_block * interval;\n+\n+        assert(start_time <= timeout);\n+\n+        // allow for times to not exactly match a block\n+        if (fuzzed_data_provider.ConsumeBool()) start_time += interval / 2;\n+        if (fuzzed_data_provider.ConsumeBool()) timeout += interval / 2;\n+\n+        // this may make timeout too early; if so, don't run the test\n+        if (start_time > timeout) return;\n+    } else {\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            start_time = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n+            timeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+            always_active_test = true;\n+        } else {\n+            start_time = 1199145601; // January 1, 2008\n+            timeout = 1230767999;    // December 31, 2008\n+            never_active_test = true;\n+        }\n+    }\n+\n+    TestConditionChecker checker(start_time, timeout, period, threshold, bit);\n+\n+    // Early exit if the versions don't signal sensibly for the deployment\n+    if (!checker.Condition(ver_signal)) return;\n+    if (checker.Condition(ver_nosignal)) return;\n+    if (ver_nosignal < 0) return;\n+\n+    // TOP_BITS should ensure version will be positive\n+    assert(ver_signal > 0);\n+\n+    // Now that we have chosen time and versions, setup to mine blocks\n+    Blocks blocks(block_start_time, interval, ver_signal, ver_nosignal);\n+\n+    /* Strategy:\n+     *  * we will mine a final period worth of blocks, with\n+     *    randomised signalling according to a mask\n+     *  * but before we mine those blocks, we will mine some\n+     *    randomised number of prior periods; with either all\n+     *    or no blocks in the period signalling\n+     *\n+     * We establish the mask first, then consume \"bools\" until\n+     * we run out of fuzz data to work out how many prior periods\n+     * there are and which ones will signal.\n+     */\n+\n+    // establish the mask\n+    const uint32_t signalling_mask = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+    // mine prior periods\n+    while (fuzzed_data_provider.remaining_bytes() > 0) {\n+        // all blocks in these periods either do or don't signal\n+        bool signal = fuzzed_data_provider.ConsumeBool();\n+        for (int b = 0; b < period; ++b) {\n+            blocks.mine_block(signal);\n+        }\n+\n+        // don't risk exceeding max_blocks or times may wrap around\n+        if (blocks.size() + period*2 > max_blocks) break;\n+    }\n+    // NOTE: fuzzed_data_provider may be fully consumed at this point and should not be used further\n+\n+    // now we mine the final period and check that everything looks sane\n+\n+    // count the number of signalling blocks\n+    int blocks_sig = 0;\n+\n+    // get the info for the first block of the period\n+    CBlockIndex* prev = blocks.tip();\n+    const int exp_since = checker.GetStateSinceHeightFor(prev);\n+    const ThresholdState exp_state = checker.GetStateFor(prev);\n+    BIP9Stats last_stats = checker.GetStateStatisticsFor(prev);\n+\n+    int prev_next_height = (prev == nullptr ? 0 : prev->nHeight + 1);\n+    assert(exp_since <= prev_next_height);\n+\n+    // mine (period-1) blocks and check state\n+    for (int b = 1; b < period; ++b) {\n+        const bool signal = (signalling_mask >> (b % 32)) & 1;\n+        if (signal) ++blocks_sig;\n+\n+        CBlockIndex* current_block = blocks.mine_block(signal);\n+\n+        // verify that signalling attempt was interpreted correctly\n+        assert(checker.Condition(current_block) == signal);\n+\n+        // state and since don't change within the period\n+        const ThresholdState state = checker.GetStateFor(current_block);\n+        const int since = checker.GetStateSinceHeightFor(current_block);\n+        assert(state == exp_state);\n+        assert(since == exp_since);\n+\n+        // GetStateStatistics may crash when state is not STARTED\n+        if (state != ThresholdState::STARTED) continue;\n+\n+        // check that after mining this block stats change as expected\n+        const BIP9Stats stats = checker.GetStateStatisticsFor(current_block);\n+        assert(stats.period == period);\n+        assert(stats.threshold == threshold);\n+        assert(stats.elapsed == b);\n+        assert(stats.count == last_stats.count + (signal ? 1 : 0));\n+        assert(stats.possible == (stats.count + period >= stats.elapsed + threshold));\n+        last_stats = stats;\n+    }\n+\n+    if (exp_state == ThresholdState::STARTED) {\n+        // double check that stats.possible is sane\n+        if (blocks_sig >= threshold - 1) assert(last_stats.possible);\n+    }\n+\n+    // mine the final block\n+    bool signal = (signalling_mask >> (period % 32)) & 1;\n+    if (signal) ++blocks_sig;\n+    CBlockIndex* current_block = blocks.mine_block(signal);\n+    assert(checker.Condition(current_block) == signal);\n+\n+    // GetStateStatistics is safe on a period boundary\n+    // and has progressed to a new period\n+    const BIP9Stats stats = checker.GetStateStatisticsFor(current_block);\n+    assert(stats.period == period);\n+    assert(stats.threshold == threshold);\n+    assert(stats.elapsed == 0);\n+    assert(stats.count == 0);\n+    assert(stats.possible == true);\n+\n+    // More interesting is whether the state changed.\n+    const ThresholdState state = checker.GetStateFor(current_block);\n+    const int since = checker.GetStateSinceHeightFor(current_block);\n+\n+    // since is straightforward:\n+    assert(since % period == 0);\n+    assert(0 <= since && since <= current_block->nHeight + 1);\n+    if (state == exp_state) {\n+        assert(since == exp_since);\n+    } else {\n+        assert(since == current_block->nHeight + 1);\n+    }\n+\n+    // state is where everything interesting is\n+    switch (state) {\n+    case ThresholdState::DEFINED:\n+        assert(since == 0);\n+        assert(exp_state == ThresholdState::DEFINED);\n+        assert(current_block->GetMedianTimePast() < checker.m_begin);\n+        assert(current_block->GetMedianTimePast() < checker.m_end);\n+        break;\n+    case ThresholdState::STARTED:\n+        assert(current_block->GetMedianTimePast() >= checker.m_begin);\n+        assert(current_block->GetMedianTimePast() < checker.m_end);\n+        if (exp_state == ThresholdState::STARTED) {\n+            assert(blocks_sig < threshold);\n+        } else {\n+            assert(exp_state == ThresholdState::DEFINED);\n+        }\n+        break;\n+    case ThresholdState::LOCKED_IN:\n+        assert(exp_state == ThresholdState::STARTED);\n+        assert(current_block->GetMedianTimePast() < checker.m_end);\n+        assert(blocks_sig >= threshold);\n+        break;\n+    case ThresholdState::ACTIVE:\n+        assert(exp_state == ThresholdState::ACTIVE || exp_state == ThresholdState::LOCKED_IN);\n+        break;\n+    case ThresholdState::FAILED:\n+        assert(current_block->GetMedianTimePast() >= checker.m_end);\n+        assert(exp_state != ThresholdState::LOCKED_IN && exp_state != ThresholdState::ACTIVE);\n+        break;\n+    default:\n+        assert(false);\n+    }\n+\n+    if (blocks.size() >= max_periods * period) {\n+        // we chose the timeout (and block times) so that by the time we have this many blocks it's all over\n+        assert(state == ThresholdState::ACTIVE || state == ThresholdState::FAILED);\n+    }\n+\n+    // \"always active\" has additional restrictions\n+    if (always_active_test) {\n+        assert(state == ThresholdState::ACTIVE);\n+        assert(exp_state == ThresholdState::ACTIVE);\n+        assert(since == 0);\n+    } else {\n+        // except for always active, the initial state is always DEFINED\n+        assert(since > 0 || state == ThresholdState::DEFINED);\n+        assert(exp_since > 0 || exp_state == ThresholdState::DEFINED);\n+    }\n+\n+    // \"never active\" does too\n+    if (never_active_test) {\n+        assert(state == ThresholdState::FAILED);\n+        assert(since == period);\n+        if (exp_since == 0) {\n+            assert(exp_state == ThresholdState::DEFINED);\n+        } else {\n+            assert(exp_state == ThresholdState::FAILED);\n+        }\n+    }\n+}"
      }
    ]
  }
]