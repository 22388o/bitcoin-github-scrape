sipa,2014-11-06T16:36:07Z,"Also, here is a sweet canary: bcdf879e47de3b3d93d111d4cada5b59961f51c6879a01ad53df98ae76144b7c\n",https://github.com/bitcoin/bitcoin/pull/5227#issuecomment-62007498,62007498,
theuni,2014-11-06T20:33:24Z,"For 0.10, why not take both and verify them against eachother?\n",https://github.com/bitcoin/bitcoin/pull/5227#issuecomment-62046435,62046435,
gmaxwell,2014-11-07T02:46:48Z,"@theuni that would defeat one of the advantages of libsecp2561k: its signing is effectively constant time, openssl currently leaks secret data over cache/timing sidechannels like a sieve.\n\nVerification tests the signature in any case (and doesn't touch secret data).\n",https://github.com/bitcoin/bitcoin/pull/5227#issuecomment-62088442,62088442,
sipa,2014-11-10T09:25:36Z,"Note that this implementation is certainly worse in terms of timing leaks than OpenSSL's own (which takes some steps to prevent those, at least in their current master branch). If we'd want to merge this without libsecp256k1-based signing, it could be improved though.\n\nEDIT: no longer relevant, as this is now using libsecp256k1's signing.\n",https://github.com/bitcoin/bitcoin/pull/5227#issuecomment-62359505,62359505,
sipa,2014-11-10T13:23:33Z,"Rebased on top of #5256, as it's otherwise hard to merge with #5220.\n",https://github.com/bitcoin/bitcoin/pull/5227#issuecomment-62383168,62383168,
sipa,2014-11-12T11:58:25Z,"By the way, the unit tests here were generated using @ciphrex's CoinCore implementation of RFC6979 with HMAC-SHA256 (https://github.com/ciphrex/CoinVault/blob/5da653249680169822afa3aecd0bcffb2ddf4961/deps/CoinCore/tests/secp256k1/src/secp256k1_rfc6979_test.cpp).\n",https://github.com/bitcoin/bitcoin/pull/5227#issuecomment-62707986,62707986,
gmaxwell,2014-11-18T17:46:57Z,"The iter argument is kinda ugly, since thats really not a good way to stir the nonce. I'd find it preferable to xor it into the message input into the PRNG.  Of course this is pointless nitpicking since it's only a testing shim... I did wtf at seeing a nonce += iter in that inner loop.\n\nWRT timing, I think the ""takes some steps"" is only true in openssl pre-release code. :( \n\nIn any case, ACK. ",https://github.com/bitcoin/bitcoin/pull/5227#issuecomment-63513098,63513098,
sipa,2014-11-18T17:53:36Z,"@gmaxwell I initially wrote it so that the iter argument just skipped the first N outputs of the PRNG. Turns out that that makes the unit tests take many minutes, as some script generations require a few hundred attempts (which becomes squared...).\n\nMixing it into the message is fine to me.\n",https://github.com/bitcoin/bitcoin/pull/5227#issuecomment-63514173,63514173,
gmaxwell,2014-11-18T18:15:50Z,"If you do make that change, perhaps also rename the argument to be test_case or something?  I'm concerned that someone immitating this code will think that iter is related to nonce retries for out of range nonces. (Though I suppose they may have more problems, like leaving the secret key out.)\n",https://github.com/bitcoin/bitcoin/pull/5227#issuecomment-63517768,63517768,
sipa,2014-11-18T18:35:51Z,"I'm not updating the code now, people may already be reviewing it. As you say, it's only for testing (and the comment in header even says so explicitly).\n",https://github.com/bitcoin/bitcoin/pull/5227#issuecomment-63521122,63521122,
sipa,2014-11-19T11:35:09Z,Rebased on top of #5220 and #5313.\n,https://github.com/bitcoin/bitcoin/pull/5227#issuecomment-63627290,63627290,
sipa,2014-11-19T11:53:43Z,And renamed the argument to test_case as suggested by @gmaxwell.\n,https://github.com/bitcoin/bitcoin/pull/5227#issuecomment-63629144,63629144,
sipa,2014-11-19T21:18:30Z,Added a commit to make @Diapolo happy.\n,https://github.com/bitcoin/bitcoin/pull/5227#issuecomment-63715355,63715355,
sipa,2014-11-20T14:01:11Z,Rebased.\n,https://github.com/bitcoin/bitcoin/pull/5227#issuecomment-63811550,63811550,
sipa,2014-11-27T10:21:54Z,Updated the PR description.\n,https://github.com/bitcoin/bitcoin/pull/5227#issuecomment-64771431,64771431,
laanwj,2014-11-28T16:40:30Z,"I was looking at 36fa4a78acac0ae6bb0e95c6ef78630120a28bdd and it looks like it is not entirely move-only:\n\n``` patch\n@@ -131,8 +123,8 @@ void Transform(uint64_t* s, const unsigned char* chunk)\n     Round(f, g, h, a, b, c, d, e, 0x431d67c49c100d4cull, w11 += sigma1(w9) + w4 + sigma0(w12));\n     Round(e, f, g, h, a, b, c, d, 0x4cc5d4becb3e42b6ull, w12 += sigma1(w10) + w5 + sigma0(w13));\n     R",https://github.com/bitcoin/bitcoin/pull/5227#issuecomment-64911770,64911770,
apoelstra,2014-11-29T16:26:57Z,"ACK, verified code correctness against my Rust code and the RFC, checked for secret data being left in memory, but did not think about timing since I don't know the first thing about that. Also ran `make check`.\n",https://github.com/bitcoin/bitcoin/pull/5227#issuecomment-64956913,64956913,
gmaxwell,2014-11-30T23:45:45Z,ACK\n,https://github.com/bitcoin/bitcoin/pull/5227#issuecomment-65006192,65006192,
SergioDemianLerner,2014-12-10T23:15:17Z,"Does OpenSSL implements RFC6979?\nI propose that the test cases include the code that implements deterministic signatures over OpenSSL (which Sipa already coded) and compares the results with the test vectors. I cannot validate the correctness of the test vectors without creating such a tool myself. Alternatively, the tool to generate the test vectors from OpenSSL should be part of the source code",https://github.com/bitcoin/bitcoin/pull/5227#issuecomment-66542646,66542646,
sipa,2014-12-10T23:16:35Z,"AFAIK, OpenSSL does not do RFC6979. It just has a means of mixing in the private key and message into the RNG (in addition to the normal randomness) used for generating the nonce.\n",https://github.com/bitcoin/bitcoin/pull/5227#issuecomment-66542833,66542833,
sipa,2014-12-10T23:22:55Z,@SergioDemianLerner I created the unit tests using an independent implementation (@Codeshark's CoinVault/CoinCore).\n,https://github.com/bitcoin/bitcoin/pull/5227#issuecomment-66543615,66543615,
SergioDemianLerner,2014-12-10T23:23:49Z,"Ok, so I'll use it.\n",https://github.com/bitcoin/bitcoin/pull/5227#issuecomment-66543719,66543719,
gmaxwell,2014-12-10T23:23:55Z,"@SergioDemianLerner  What pieter said, OpenSSL git (not a release version; release versions are all stright up random) implements a non-standard DSA RNG hardening scheme. The most important thing is that the hash depend on at least the message and a secret, which OpenSSL achieves. Satisifying 6979 is an extra perk.\n\nI believe our test vectors were actually generated with the Ciphrex software rat",https://github.com/bitcoin/bitcoin/pull/5227#issuecomment-66543731,66543731,
sipa,2014-12-11T00:34:58Z,"Well if anything, I agree that RFC6979 seems total overkill. One HMAC should have sufficed. But sticking to accepted standards is nice.\n\nRegarding specific concerns: I don't believe the SHA256 code we have should result in variable-time code on any supported platform. EM or power comsumption... I don't believe there is any reasonable way to avoid those.\n",https://github.com/bitcoin/bitcoin/pull/5227#issuecomment-66550954,66550954,
gmaxwell,2014-12-11T00:36:06Z,"Additions are constant time up to my ability to measure on the platforms we support.  If they are not constant time, then all bets are off for timing sidechannel immunity _anywhere_ in the signature system.  That hashing the key may have some sidechannel leak is very small concern compared to any place else there where there could be (or would be) a timing sidechannel. (Multiplies are also constan",https://github.com/bitcoin/bitcoin/pull/5227#issuecomment-66551050,66551050,
gmaxwell,2014-12-11T00:38:16Z,"> But sticking to accepted standards is nice.\n\nNot just nice, but producing a common reproducable output means that you can do diverse signing with multiple signers to guard against nonce covert channel backdooring.\n\nIt also provides some assurance against things like insiders intentionally making the nonce H(message) in order to leak keys.\n",https://github.com/bitcoin/bitcoin/pull/5227#issuecomment-66551229,66551229,
SergioDemianLerner,2014-12-11T00:47:41Z,"Sorry about deleting my post. I didn't want to waste your time. But since you've responded, I leave it here for consistency of the conversation.\n\nI don't like RFC6979. I know I'm being terrible audacious by this assertion. But I don't like the way the key is mapped into the SHA-256 key schedule.\nThe value V (32 bytes long) ends up at the beginning of the compression block, so that the key ends ",https://github.com/bitcoin/bitcoin/pull/5227#issuecomment-66552117,66552117,
SergioDemianLerner,2014-12-11T00:52:23Z,"Still, if I could change RFC6979, I would make K = key at the beginning, and not part of the message, instead of K = zero.\n",https://github.com/bitcoin/bitcoin/pull/5227#issuecomment-66552539,66552539,
gmaxwell,2014-12-11T00:55:28Z,"Yea, I would have done that in terms of a preitter construction. I suspect the authors of 6979 would have done that too, but I believe what they wanted to do was to take a pre-existing, standardized, construction for a CSPRNG and turn it into a standard for derandomized DSA without any change that might have introduced an application specific weakness.\n\n(No biggie on the response. Messages cross",https://github.com/bitcoin/bitcoin/pull/5227#issuecomment-66552783,66552783,
Diapolo,2014-11-19T12:29:27Z,"New format would result in `BITCOIN_CRYPTO_HMAC_SHA256_H` I guess you should look at the oder headers and end comments, too :). I just will give this single nit, nice, isn't it ^^?\n",https://github.com/bitcoin/bitcoin/pull/5227#discussion_r20571885,20571885,src/crypto/hmac_sha256.h
theuni,2014-11-19T21:42:06Z,Isn't it possible that these will be optimized away by the compiler? Is it worth worrying about?\n,https://github.com/bitcoin/bitcoin/pull/5227#discussion_r20609716,20609716,src/crypto/rfc6979_hmac_sha256.cpp
sipa,2014-11-19T21:46:47Z,"Yup, that's possible. OpenSSL has OPENSSL_cleanse() for that, which we could use too (but I would prefer crypto to not depend on OpenSSL...).\n\nIdeally, I think we use belt-and-suspenders and let every layer do as much as it can to avoid this sort of leakage (which can't be 100% avoided anyway, unless you only ever let assembly code touch the confidential data).\n",https://github.com/bitcoin/bitcoin/pull/5227#discussion_r20610031,20610031,src/crypto/rfc6979_hmac_sha256.cpp
gmaxwell,2014-11-19T22:21:24Z,"To add some color there...  we could (and perhaps should-- I'd be a fan of it) have some extern-ed memsetting function for these cases which we can be sure won't get optimized away.\n\nHowever, thats not sufficient:  The compiler can randomly stash data from variables into random spots on the stack, the compiler can and commonly will leave data sitting around in registers from where other function",https://github.com/bitcoin/bitcoin/pull/5227#discussion_r20612399,20612399,src/crypto/rfc6979_hmac_sha256.cpp
laanwj,2014-11-28T18:12:05Z,"Better to move this before `secp256k1_ecdsa_sign` below, with the `nSigLen = 72` line. Otherwise it could theoretically happened that the buffer has been made smaller and receives 72 bytes in a next iteration of the loop.\n",https://github.com/bitcoin/bitcoin/pull/5227#discussion_r21041015,21041015,src/key.cpp
sipa,2014-11-28T20:17:26Z,Fixed (in a different way).\n,https://github.com/bitcoin/bitcoin/pull/5227#discussion_r21043503,21043503,src/key.cpp
apoelstra,2014-11-29T15:11:45Z,"This is maybe not worth the hassle, but it's possible to do this with only a single `CSHA256`. In `Finalize` you'd put the output of `inner` into `hash`, then reset `inner`, write the outer key to it, write `hash` to it, then output to `hash`. This way you don't have any non-final HMAC state hanging around in memory after finalization.\n",https://github.com/bitcoin/bitcoin/pull/5227#discussion_r21054418,21054418,src/crypto/hmac_sha256.cpp
apoelstra,2014-11-29T15:13:07Z,Ditto.\n,https://github.com/bitcoin/bitcoin/pull/5227#discussion_r21054422,21054422,src/crypto/hmac_sha512.cpp
sipa,2014-11-29T15:13:28Z,I prefer keeping an extra SHA256 state in memory than keeping the key in memory.\n,https://github.com/bitcoin/bitcoin/pull/5227#discussion_r21054424,21054424,src/crypto/hmac_sha256.cpp
apoelstra,2014-11-29T15:25:01Z,"Oh, of course. I somehow missed that you avoided storing the key.\n",https://github.com/bitcoin/bitcoin/pull/5227#discussion_r21054497,21054497,src/crypto/hmac_sha256.cpp
SergioDemianLerner,2014-12-10T23:19:12Z,"I would prefer not to iterate though all the words of the nonce unnecessarily, even if nothing is changed. It reduces the possibility that part of the nonce is kept in the stack or in registers.\n\nI propose adding:\nif (test_case)\n  nonce += test_case;\n",https://github.com/bitcoin/bitcoin/pull/5227#discussion_r21647010,21647010,src/key.cpp
