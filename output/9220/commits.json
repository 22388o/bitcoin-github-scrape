[
  {
    "sha": "2f2625a0bb94db220a6f5560fa942159b66ac61e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyZjI2MjVhMGJiOTRkYjIyMGE2ZjU1NjBmYTk0MjE1OWI2NmFjNjFl",
    "commit": {
      "author": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2016-11-25T08:17:57Z"
      },
      "committer": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2016-11-25T08:17:57Z"
      },
      "message": "Removed using namespace std from bitcoin-cli/-tx and added std:: in appropriate places.",
      "tree": {
        "sha": "4869608f6040bed7083b73b3eac987fce1a2578d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4869608f6040bed7083b73b3eac987fce1a2578d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2f2625a0bb94db220a6f5560fa942159b66ac61e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2f2625a0bb94db220a6f5560fa942159b66ac61e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2f2625a0bb94db220a6f5560fa942159b66ac61e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2f2625a0bb94db220a6f5560fa942159b66ac61e/comments",
    "author": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bc121b0eb19713ec72002b5be03ba5ac35903a17",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bc121b0eb19713ec72002b5be03ba5ac35903a17",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bc121b0eb19713ec72002b5be03ba5ac35903a17"
      }
    ],
    "stats": {
      "total": 220,
      "additions": 108,
      "deletions": 112
    },
    "files": [
      {
        "sha": "b2726408199f53172affb8d18de2c51ade591109",
        "filename": "src/bitcoin-cli.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 16,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2f2625a0bb94db220a6f5560fa942159b66ac61e/src/bitcoin-cli.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2f2625a0bb94db220a6f5560fa942159b66ac61e/src/bitcoin-cli.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-cli.cpp?ref=2f2625a0bb94db220a6f5560fa942159b66ac61e",
        "patch": "@@ -24,15 +24,13 @@\n \n #include <univalue.h>\n \n-using namespace std;\n-\n static const char DEFAULT_RPCCONNECT[] = \"127.0.0.1\";\n static const int DEFAULT_HTTP_CLIENT_TIMEOUT=900;\n static const int CONTINUE_EXECUTION=-1;\n \n std::string HelpMessageCli()\n {\n-    string strUsage;\n+    std::string strUsage;\n     strUsage += HelpMessageGroup(_(\"Options:\"));\n     strUsage += HelpMessageOpt(\"-?\", _(\"This help message\"));\n     strUsage += HelpMessageOpt(\"-conf=<file>\", strprintf(_(\"Specify configuration file (default: %s)\"), BITCOIN_CONF_FILENAME));\n@@ -187,26 +185,26 @@ static void http_error_cb(enum evhttp_request_error err, void *ctx)\n }\n #endif\n \n-UniValue CallRPC(const string& strMethod, const UniValue& params)\n+UniValue CallRPC(const std::string& strMethod, const UniValue& params)\n {\n     std::string host = GetArg(\"-rpcconnect\", DEFAULT_RPCCONNECT);\n     int port = GetArg(\"-rpcport\", BaseParams().RPCPort());\n \n     // Create event base\n     struct event_base *base = event_base_new(); // TODO RAII\n     if (!base)\n-        throw runtime_error(\"cannot create event_base\");\n+        throw std::runtime_error(\"cannot create event_base\");\n \n     // Synchronously look up hostname\n     struct evhttp_connection *evcon = evhttp_connection_base_new(base, NULL, host.c_str(), port); // TODO RAII\n     if (evcon == NULL)\n-        throw runtime_error(\"create connection failed\");\n+        throw std::runtime_error(\"create connection failed\");\n     evhttp_connection_set_timeout(evcon, GetArg(\"-rpcclienttimeout\", DEFAULT_HTTP_CLIENT_TIMEOUT));\n \n     HTTPReply response;\n     struct evhttp_request *req = evhttp_request_new(http_request_done, (void*)&response); // TODO RAII\n     if (req == NULL)\n-        throw runtime_error(\"create http request failed\");\n+        throw std::runtime_error(\"create http request failed\");\n #if LIBEVENT_VERSION_NUMBER >= 0x02010300\n     evhttp_request_set_error_cb(req, http_error_cb);\n #endif\n@@ -216,7 +214,7 @@ UniValue CallRPC(const string& strMethod, const UniValue& params)\n     if (mapArgs[\"-rpcpassword\"] == \"\") {\n         // Try fall back to cookie-based authentication if no password is provided\n         if (!GetAuthCookie(&strRPCUserColonPass)) {\n-            throw runtime_error(strprintf(\n+            throw std::runtime_error(strprintf(\n                 _(\"Could not locate RPC credentials. No authentication cookie could be found, and no rpcpassword is set in the configuration file (%s)\"),\n                     GetConfigFile(GetArg(\"-conf\", BITCOIN_CONF_FILENAME)).string().c_str()));\n \n@@ -251,26 +249,26 @@ UniValue CallRPC(const string& strMethod, const UniValue& params)\n     if (response.status == 0)\n         throw CConnectionFailed(strprintf(\"couldn't connect to server\\n(make sure server is running and you are connecting to the correct RPC port: %d %s)\", response.error, http_errorstring(response.error)));\n     else if (response.status == HTTP_UNAUTHORIZED)\n-        throw runtime_error(\"incorrect rpcuser or rpcpassword (authorization failed)\");\n+        throw std::runtime_error(\"incorrect rpcuser or rpcpassword (authorization failed)\");\n     else if (response.status >= 400 && response.status != HTTP_BAD_REQUEST && response.status != HTTP_NOT_FOUND && response.status != HTTP_INTERNAL_SERVER_ERROR)\n-        throw runtime_error(strprintf(\"server returned HTTP error %d\", response.status));\n+        throw std::runtime_error(strprintf(\"server returned HTTP error %d\", response.status));\n     else if (response.body.empty())\n-        throw runtime_error(\"no response from server\");\n+        throw std::runtime_error(\"no response from server\");\n \n     // Parse reply\n     UniValue valReply(UniValue::VSTR);\n     if (!valReply.read(response.body))\n-        throw runtime_error(\"couldn't parse reply from server\");\n+        throw std::runtime_error(\"couldn't parse reply from server\");\n     const UniValue& reply = valReply.get_obj();\n     if (reply.empty())\n-        throw runtime_error(\"expected reply to have result, error and id properties\");\n+        throw std::runtime_error(\"expected reply to have result, error and id properties\");\n \n     return reply;\n }\n \n int CommandLineRPC(int argc, char *argv[])\n {\n-    string strPrint;\n+    std::string strPrint;\n     int nRet = 0;\n     try {\n         // Skip switches\n@@ -286,7 +284,7 @@ int CommandLineRPC(int argc, char *argv[])\n                 args.push_back(line);\n         }\n         if (args.size() < 1)\n-            throw runtime_error(\"too few parameters (need at least command)\");\n+            throw std::runtime_error(\"too few parameters (need at least command)\");\n         std::string strMethod = args[0];\n         UniValue params = RPCConvertValues(strMethod, std::vector<std::string>(args.begin()+1, args.end()));\n \n@@ -340,7 +338,7 @@ int CommandLineRPC(int argc, char *argv[])\n         throw;\n     }\n     catch (const std::exception& e) {\n-        strPrint = string(\"error: \") + e.what();\n+        strPrint = std::string(\"error: \") + e.what();\n         nRet = EXIT_FAILURE;\n     }\n     catch (...) {"
      },
      {
        "sha": "346d8e180d39e0d87a8a7b576ba42cd8532960e6",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 94,
        "deletions": 96,
        "changes": 190,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2f2625a0bb94db220a6f5560fa942159b66ac61e/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2f2625a0bb94db220a6f5560fa942159b66ac61e/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=2f2625a0bb94db220a6f5560fa942159b66ac61e",
        "patch": "@@ -26,10 +26,8 @@\n #include <boost/algorithm/string.hpp>\n #include <boost/assign/list_of.hpp>\n \n-using namespace std;\n-\n static bool fCreateBlank;\n-static map<string,UniValue> registers;\n+static std::map<std::string,UniValue> registers;\n static const int CONTINUE_EXECUTION=-1;\n \n //\n@@ -103,52 +101,52 @@ static int AppInitRawTx(int argc, char* argv[])\n     return CONTINUE_EXECUTION;\n }\n \n-static void RegisterSetJson(const string& key, const string& rawJson)\n+static void RegisterSetJson(const std::string& key, const std::string& rawJson)\n {\n     UniValue val;\n     if (!val.read(rawJson)) {\n-        string strErr = \"Cannot parse JSON for key \" + key;\n-        throw runtime_error(strErr);\n+        std::string strErr = \"Cannot parse JSON for key \" + key;\n+        throw std::runtime_error(strErr);\n     }\n \n     registers[key] = val;\n }\n \n-static void RegisterSet(const string& strInput)\n+static void RegisterSet(const std::string& strInput)\n {\n     // separate NAME:VALUE in string\n     size_t pos = strInput.find(':');\n-    if ((pos == string::npos) ||\n+    if ((pos == std::string::npos) ||\n         (pos == 0) ||\n         (pos == (strInput.size() - 1)))\n-        throw runtime_error(\"Register input requires NAME:VALUE\");\n+        throw std::runtime_error(\"Register input requires NAME:VALUE\");\n \n-    string key = strInput.substr(0, pos);\n-    string valStr = strInput.substr(pos + 1, string::npos);\n+    std::string key = strInput.substr(0, pos);\n+    std::string valStr = strInput.substr(pos + 1, std::string::npos);\n \n     RegisterSetJson(key, valStr);\n }\n \n-static void RegisterLoad(const string& strInput)\n+static void RegisterLoad(const std::string& strInput)\n {\n     // separate NAME:FILENAME in string\n     size_t pos = strInput.find(':');\n-    if ((pos == string::npos) ||\n+    if ((pos == std::string::npos) ||\n         (pos == 0) ||\n         (pos == (strInput.size() - 1)))\n-        throw runtime_error(\"Register load requires NAME:FILENAME\");\n+        throw std::runtime_error(\"Register load requires NAME:FILENAME\");\n \n-    string key = strInput.substr(0, pos);\n-    string filename = strInput.substr(pos + 1, string::npos);\n+    std::string key = strInput.substr(0, pos);\n+    std::string filename = strInput.substr(pos + 1, std::string::npos);\n \n     FILE *f = fopen(filename.c_str(), \"r\");\n     if (!f) {\n-        string strErr = \"Cannot open file \" + filename;\n-        throw runtime_error(strErr);\n+        std::string strErr = \"Cannot open file \" + filename;\n+        throw std::runtime_error(strErr);\n     }\n \n     // load file chunks into one big buffer\n-    string valStr;\n+    std::string valStr;\n     while ((!feof(f)) && (!ferror(f))) {\n         char buf[4096];\n         int bread = fread(buf, 1, sizeof(buf), f);\n@@ -162,55 +160,55 @@ static void RegisterLoad(const string& strInput)\n     fclose(f);\n \n     if (error) {\n-        string strErr = \"Error reading file \" + filename;\n-        throw runtime_error(strErr);\n+        std::string strErr = \"Error reading file \" + filename;\n+        throw std::runtime_error(strErr);\n     }\n \n     // evaluate as JSON buffer register\n     RegisterSetJson(key, valStr);\n }\n \n-static void MutateTxVersion(CMutableTransaction& tx, const string& cmdVal)\n+static void MutateTxVersion(CMutableTransaction& tx, const std::string& cmdVal)\n {\n     int64_t newVersion = atoi64(cmdVal);\n     if (newVersion < 1 || newVersion > CTransaction::MAX_STANDARD_VERSION)\n-        throw runtime_error(\"Invalid TX version requested\");\n+        throw std::runtime_error(\"Invalid TX version requested\");\n \n     tx.nVersion = (int) newVersion;\n }\n \n-static void MutateTxLocktime(CMutableTransaction& tx, const string& cmdVal)\n+static void MutateTxLocktime(CMutableTransaction& tx, const std::string& cmdVal)\n {\n     int64_t newLocktime = atoi64(cmdVal);\n     if (newLocktime < 0LL || newLocktime > 0xffffffffLL)\n-        throw runtime_error(\"Invalid TX locktime requested\");\n+        throw std::runtime_error(\"Invalid TX locktime requested\");\n \n     tx.nLockTime = (unsigned int) newLocktime;\n }\n \n-static void MutateTxAddInput(CMutableTransaction& tx, const string& strInput)\n+static void MutateTxAddInput(CMutableTransaction& tx, const std::string& strInput)\n {\n     std::vector<std::string> vStrInputParts;\n     boost::split(vStrInputParts, strInput, boost::is_any_of(\":\"));\n \n     // separate TXID:VOUT in string\n     if (vStrInputParts.size()<2)\n-        throw runtime_error(\"TX input missing separator\");\n+        throw std::runtime_error(\"TX input missing separator\");\n \n     // extract and validate TXID\n-    string strTxid = vStrInputParts[0];\n+    std::string strTxid = vStrInputParts[0];\n     if ((strTxid.size() != 64) || !IsHex(strTxid))\n-        throw runtime_error(\"invalid TX input txid\");\n+        throw std::runtime_error(\"invalid TX input txid\");\n     uint256 txid(uint256S(strTxid));\n \n     static const unsigned int minTxOutSz = 9;\n     static const unsigned int maxVout = MAX_BLOCK_BASE_SIZE / minTxOutSz;\n \n     // extract and validate vout\n-    string strVout = vStrInputParts[1];\n+    std::string strVout = vStrInputParts[1];\n     int vout = atoi(strVout);\n     if ((vout < 0) || (vout > (int)maxVout))\n-        throw runtime_error(\"invalid TX input vout\");\n+        throw std::runtime_error(\"invalid TX input vout\");\n \n     // extract the optional sequence number\n     uint32_t nSequenceIn=std::numeric_limits<unsigned int>::max();\n@@ -222,26 +220,26 @@ static void MutateTxAddInput(CMutableTransaction& tx, const string& strInput)\n     tx.vin.push_back(txin);\n }\n \n-static void MutateTxAddOutAddr(CMutableTransaction& tx, const string& strInput)\n+static void MutateTxAddOutAddr(CMutableTransaction& tx, const std::string& strInput)\n {\n     // separate VALUE:ADDRESS in string\n     size_t pos = strInput.find(':');\n-    if ((pos == string::npos) ||\n+    if ((pos == std::string::npos) ||\n         (pos == 0) ||\n         (pos == (strInput.size() - 1)))\n-        throw runtime_error(\"TX output missing separator\");\n+        throw std::runtime_error(\"TX output missing separator\");\n \n     // extract and validate VALUE\n-    string strValue = strInput.substr(0, pos);\n+    std::string strValue = strInput.substr(0, pos);\n     CAmount value;\n     if (!ParseMoney(strValue, value))\n-        throw runtime_error(\"invalid TX output value\");\n+        throw std::runtime_error(\"invalid TX output value\");\n \n     // extract and validate ADDRESS\n-    string strAddr = strInput.substr(pos + 1, string::npos);\n+    std::string strAddr = strInput.substr(pos + 1, std::string::npos);\n     CBitcoinAddress addr(strAddr);\n     if (!addr.IsValid())\n-        throw runtime_error(\"invalid TX output address\");\n+        throw std::runtime_error(\"invalid TX output address\");\n \n     // build standard output script via GetScriptForDestination()\n     CScript scriptPubKey = GetScriptForDestination(addr.Get());\n@@ -251,78 +249,78 @@ static void MutateTxAddOutAddr(CMutableTransaction& tx, const string& strInput)\n     tx.vout.push_back(txout);\n }\n \n-static void MutateTxAddOutData(CMutableTransaction& tx, const string& strInput)\n+static void MutateTxAddOutData(CMutableTransaction& tx, const std::string& strInput)\n {\n     CAmount value = 0;\n \n     // separate [VALUE:]DATA in string\n     size_t pos = strInput.find(':');\n \n     if (pos==0)\n-        throw runtime_error(\"TX output value not specified\");\n+        throw std::runtime_error(\"TX output value not specified\");\n \n-    if (pos != string::npos) {\n+    if (pos != std::string::npos) {\n         // extract and validate VALUE\n-        string strValue = strInput.substr(0, pos);\n+        std::string strValue = strInput.substr(0, pos);\n         if (!ParseMoney(strValue, value))\n-            throw runtime_error(\"invalid TX output value\");\n+            throw std::runtime_error(\"invalid TX output value\");\n     }\n \n     // extract and validate DATA\n-    string strData = strInput.substr(pos + 1, string::npos);\n+    std::string strData = strInput.substr(pos + 1, std::string::npos);\n \n     if (!IsHex(strData))\n-        throw runtime_error(\"invalid TX output data\");\n+        throw std::runtime_error(\"invalid TX output data\");\n \n     std::vector<unsigned char> data = ParseHex(strData);\n \n     CTxOut txout(value, CScript() << OP_RETURN << data);\n     tx.vout.push_back(txout);\n }\n \n-static void MutateTxAddOutScript(CMutableTransaction& tx, const string& strInput)\n+static void MutateTxAddOutScript(CMutableTransaction& tx, const std::string& strInput)\n {\n     // separate VALUE:SCRIPT in string\n     size_t pos = strInput.find(':');\n-    if ((pos == string::npos) ||\n+    if ((pos == std::string::npos) ||\n         (pos == 0))\n-        throw runtime_error(\"TX output missing separator\");\n+        throw std::runtime_error(\"TX output missing separator\");\n \n     // extract and validate VALUE\n-    string strValue = strInput.substr(0, pos);\n+    std::string strValue = strInput.substr(0, pos);\n     CAmount value;\n     if (!ParseMoney(strValue, value))\n-        throw runtime_error(\"invalid TX output value\");\n+        throw std::runtime_error(\"invalid TX output value\");\n \n     // extract and validate script\n-    string strScript = strInput.substr(pos + 1, string::npos);\n+    std::string strScript = strInput.substr(pos + 1, std::string::npos);\n     CScript scriptPubKey = ParseScript(strScript); // throws on err\n \n     // construct TxOut, append to transaction output list\n     CTxOut txout(value, scriptPubKey);\n     tx.vout.push_back(txout);\n }\n \n-static void MutateTxDelInput(CMutableTransaction& tx, const string& strInIdx)\n+static void MutateTxDelInput(CMutableTransaction& tx, const std::string& strInIdx)\n {\n     // parse requested deletion index\n     int inIdx = atoi(strInIdx);\n     if (inIdx < 0 || inIdx >= (int)tx.vin.size()) {\n-        string strErr = \"Invalid TX input index '\" + strInIdx + \"'\";\n-        throw runtime_error(strErr.c_str());\n+        std::string strErr = \"Invalid TX input index '\" + strInIdx + \"'\";\n+        throw std::runtime_error(strErr.c_str());\n     }\n \n     // delete input from transaction\n     tx.vin.erase(tx.vin.begin() + inIdx);\n }\n \n-static void MutateTxDelOutput(CMutableTransaction& tx, const string& strOutIdx)\n+static void MutateTxDelOutput(CMutableTransaction& tx, const std::string& strOutIdx)\n {\n     // parse requested deletion index\n     int outIdx = atoi(strOutIdx);\n     if (outIdx < 0 || outIdx >= (int)tx.vout.size()) {\n-        string strErr = \"Invalid TX output index '\" + strOutIdx + \"'\";\n-        throw runtime_error(strErr.c_str());\n+        std::string strErr = \"Invalid TX output index '\" + strOutIdx + \"'\";\n+        throw std::runtime_error(strErr.c_str());\n     }\n \n     // delete output from transaction\n@@ -342,7 +340,7 @@ static const struct {\n     {\"SINGLE|ANYONECANPAY\", SIGHASH_SINGLE|SIGHASH_ANYONECANPAY},\n };\n \n-static bool findSighashFlags(int& flags, const string& flagStr)\n+static bool findSighashFlags(int& flags, const std::string& flagStr)\n {\n     flags = 0;\n \n@@ -356,17 +354,17 @@ static bool findSighashFlags(int& flags, const string& flagStr)\n     return false;\n }\n \n-uint256 ParseHashUO(map<string,UniValue>& o, string strKey)\n+uint256 ParseHashUO(std::map<std::string,UniValue>& o, std::string strKey)\n {\n     if (!o.count(strKey))\n         return uint256();\n     return ParseHashUV(o[strKey], strKey);\n }\n \n-vector<unsigned char> ParseHexUO(map<string,UniValue>& o, string strKey)\n+std::vector<unsigned char> ParseHexUO(std::map<std::string,UniValue>& o, std::string strKey)\n {\n     if (!o.count(strKey)) {\n-        vector<unsigned char> emptyVec;\n+        std::vector<unsigned char> emptyVec;\n         return emptyVec;\n     }\n     return ParseHexUV(o[strKey], strKey);\n@@ -375,24 +373,24 @@ vector<unsigned char> ParseHexUO(map<string,UniValue>& o, string strKey)\n static CAmount AmountFromValue(const UniValue& value)\n {\n     if (!value.isNum() && !value.isStr())\n-        throw runtime_error(\"Amount is not a number or string\");\n+        throw std::runtime_error(\"Amount is not a number or string\");\n     CAmount amount;\n     if (!ParseFixedPoint(value.getValStr(), 8, &amount))\n-        throw runtime_error(\"Invalid amount\");\n+        throw std::runtime_error(\"Invalid amount\");\n     if (!MoneyRange(amount))\n-        throw runtime_error(\"Amount out of range\");\n+        throw std::runtime_error(\"Amount out of range\");\n     return amount;\n }\n \n-static void MutateTxSign(CMutableTransaction& tx, const string& flagStr)\n+static void MutateTxSign(CMutableTransaction& tx, const std::string& flagStr)\n {\n     int nHashType = SIGHASH_ALL;\n \n     if (flagStr.size() > 0)\n         if (!findSighashFlags(nHashType, flagStr))\n-            throw runtime_error(\"unknown sighash flag/sign option\");\n+            throw std::runtime_error(\"unknown sighash flag/sign option\");\n \n-    vector<CTransaction> txVariants;\n+    std::vector<CTransaction> txVariants;\n     txVariants.push_back(tx);\n \n     // mergedTx will end up with all the signatures; it\n@@ -403,52 +401,52 @@ static void MutateTxSign(CMutableTransaction& tx, const string& flagStr)\n     CCoinsViewCache view(&viewDummy);\n \n     if (!registers.count(\"privatekeys\"))\n-        throw runtime_error(\"privatekeys register variable must be set.\");\n+        throw std::runtime_error(\"privatekeys register variable must be set.\");\n     CBasicKeyStore tempKeystore;\n     UniValue keysObj = registers[\"privatekeys\"];\n \n     for (unsigned int kidx = 0; kidx < keysObj.size(); kidx++) {\n         if (!keysObj[kidx].isStr())\n-            throw runtime_error(\"privatekey not a string\");\n+            throw std::runtime_error(\"privatekey not a std::string\");\n         CBitcoinSecret vchSecret;\n         bool fGood = vchSecret.SetString(keysObj[kidx].getValStr());\n         if (!fGood)\n-            throw runtime_error(\"privatekey not valid\");\n+            throw std::runtime_error(\"privatekey not valid\");\n \n         CKey key = vchSecret.GetKey();\n         tempKeystore.AddKey(key);\n     }\n \n     // Add previous txouts given in the RPC call:\n     if (!registers.count(\"prevtxs\"))\n-        throw runtime_error(\"prevtxs register variable must be set.\");\n+        throw std::runtime_error(\"prevtxs register variable must be set.\");\n     UniValue prevtxsObj = registers[\"prevtxs\"];\n     {\n         for (unsigned int previdx = 0; previdx < prevtxsObj.size(); previdx++) {\n             UniValue prevOut = prevtxsObj[previdx];\n             if (!prevOut.isObject())\n-                throw runtime_error(\"expected prevtxs internal object\");\n+                throw std::runtime_error(\"expected prevtxs internal object\");\n \n-            map<string,UniValue::VType> types = boost::assign::map_list_of(\"txid\", UniValue::VSTR)(\"vout\",UniValue::VNUM)(\"scriptPubKey\",UniValue::VSTR);\n+            std::map<std::string,UniValue::VType> types = boost::assign::map_list_of(\"txid\", UniValue::VSTR)(\"vout\",UniValue::VNUM)(\"scriptPubKey\",UniValue::VSTR);\n             if (!prevOut.checkObject(types))\n-                throw runtime_error(\"prevtxs internal object typecheck fail\");\n+                throw std::runtime_error(\"prevtxs internal object typecheck fail\");\n \n             uint256 txid = ParseHashUV(prevOut[\"txid\"], \"txid\");\n \n             int nOut = atoi(prevOut[\"vout\"].getValStr());\n             if (nOut < 0)\n-                throw runtime_error(\"vout must be positive\");\n+                throw std::runtime_error(\"vout must be positive\");\n \n-            vector<unsigned char> pkData(ParseHexUV(prevOut[\"scriptPubKey\"], \"scriptPubKey\"));\n+            std::vector<unsigned char> pkData(ParseHexUV(prevOut[\"scriptPubKey\"], \"scriptPubKey\"));\n             CScript scriptPubKey(pkData.begin(), pkData.end());\n \n             {\n                 CCoinsModifier coins = view.ModifyCoins(txid);\n                 if (coins->IsAvailable(nOut) && coins->vout[nOut].scriptPubKey != scriptPubKey) {\n-                    string err(\"Previous output scriptPubKey mismatch:\\n\");\n+                    std::string err(\"Previous output scriptPubKey mismatch:\\n\");\n                     err = err + ScriptToAsmStr(coins->vout[nOut].scriptPubKey) + \"\\nvs:\\n\"+\n                         ScriptToAsmStr(scriptPubKey);\n-                    throw runtime_error(err);\n+                    throw std::runtime_error(err);\n                 }\n                 if ((unsigned int)nOut >= coins->vout.size())\n                     coins->vout.resize(nOut+1);\n@@ -464,7 +462,7 @@ static void MutateTxSign(CMutableTransaction& tx, const string& flagStr)\n             if ((scriptPubKey.IsPayToScriptHash() || scriptPubKey.IsPayToWitnessScriptHash()) &&\n                 prevOut.exists(\"redeemScript\")) {\n                 UniValue v = prevOut[\"redeemScript\"];\n-                vector<unsigned char> rsData(ParseHexUV(v, \"redeemScript\"));\n+                std::vector<unsigned char> rsData(ParseHexUV(v, \"redeemScript\"));\n                 CScript redeemScript(rsData.begin(), rsData.end());\n                 tempKeystore.AddCScript(redeemScript);\n             }\n@@ -521,8 +519,8 @@ class Secp256k1Init\n     }\n };\n \n-static void MutateTx(CMutableTransaction& tx, const string& command,\n-                     const string& commandVal)\n+static void MutateTx(CMutableTransaction& tx, const std::string& command,\n+                     const std::string& commandVal)\n {\n     std::unique_ptr<Secp256k1Init> ecc;\n \n@@ -557,28 +555,28 @@ static void MutateTx(CMutableTransaction& tx, const string& command,\n         RegisterSet(commandVal);\n \n     else\n-        throw runtime_error(\"unknown command\");\n+        throw std::runtime_error(\"unknown command\");\n }\n \n static void OutputTxJSON(const CTransaction& tx)\n {\n     UniValue entry(UniValue::VOBJ);\n     TxToUniv(tx, uint256(), entry);\n \n-    string jsonOutput = entry.write(4);\n+    std::string jsonOutput = entry.write(4);\n     fprintf(stdout, \"%s\\n\", jsonOutput.c_str());\n }\n \n static void OutputTxHash(const CTransaction& tx)\n {\n-    string strHexHash = tx.GetHash().GetHex(); // the hex-encoded transaction hash (aka the transaction id)\n+    std::string strHexHash = tx.GetHash().GetHex(); // the hex-encoded transaction hash (aka the transaction id)\n \n     fprintf(stdout, \"%s\\n\", strHexHash.c_str());\n }\n \n static void OutputTxHex(const CTransaction& tx)\n {\n-    string strHex = EncodeHexTx(tx);\n+    std::string strHex = EncodeHexTx(tx);\n \n     fprintf(stdout, \"%s\\n\", strHex.c_str());\n }\n@@ -593,10 +591,10 @@ static void OutputTx(const CTransaction& tx)\n         OutputTxHex(tx);\n }\n \n-static string readStdin()\n+static std::string readStdin()\n {\n     char buf[4096];\n-    string ret;\n+    std::string ret;\n \n     while (!feof(stdin)) {\n         size_t bread = fread(buf, 1, sizeof(buf), stdin);\n@@ -606,7 +604,7 @@ static string readStdin()\n     }\n \n     if (ferror(stdin))\n-        throw runtime_error(\"error reading stdin\");\n+        throw std::runtime_error(\"error reading stdin\");\n \n     boost::algorithm::trim_right(ret);\n \n@@ -615,7 +613,7 @@ static string readStdin()\n \n static int CommandLineRawTx(int argc, char* argv[])\n {\n-    string strPrint;\n+    std::string strPrint;\n     int nRet = 0;\n     try {\n         // Skip switches; Permit common stdin convention \"-\"\n@@ -631,15 +629,15 @@ static int CommandLineRawTx(int argc, char* argv[])\n         if (!fCreateBlank) {\n             // require at least one param\n             if (argc < 2)\n-                throw runtime_error(\"too few parameters\");\n+                throw std::runtime_error(\"too few parameters\");\n \n             // param: hex-encoded bitcoin transaction\n-            string strHexTx(argv[1]);\n+            std::string strHexTx(argv[1]);\n             if (strHexTx == \"-\")                 // \"-\" implies standard input\n                 strHexTx = readStdin();\n \n             if (!DecodeHexTx(txDecodeTmp, strHexTx, true))\n-                throw runtime_error(\"invalid transaction encoding\");\n+                throw std::runtime_error(\"invalid transaction encoding\");\n \n             startArg = 2;\n         } else\n@@ -648,10 +646,10 @@ static int CommandLineRawTx(int argc, char* argv[])\n         CMutableTransaction tx(txDecodeTmp);\n \n         for (int i = startArg; i < argc; i++) {\n-            string arg = argv[i];\n-            string key, value;\n+            std::string arg = argv[i];\n+            std::string key, value;\n             size_t eqpos = arg.find('=');\n-            if (eqpos == string::npos)\n+            if (eqpos == std::string::npos)\n                 key = arg;\n             else {\n                 key = arg.substr(0, eqpos);\n@@ -668,7 +666,7 @@ static int CommandLineRawTx(int argc, char* argv[])\n         throw;\n     }\n     catch (const std::exception& e) {\n-        strPrint = string(\"error: \") + e.what();\n+        strPrint = std::string(\"error: \") + e.what();\n         nRet = EXIT_FAILURE;\n     }\n     catch (...) {"
      }
    ]
  }
]