[
  {
    "sha": "a1a07cfe99fc8cee30ba5976dc36b47b1f6532ab",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphMWEwN2NmZTk5ZmM4Y2VlMzBiYTU5NzZkYzM2YjQ3YjFmNjUzMmFi",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2019-09-30T20:25:04Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2019-10-10T15:17:01Z"
      },
      "message": "[validation] Fix peer punishment for bad blocks\n\nBecause the call to MaybePunishNode() in\nPeerLogicValidation::BlockChecked() only previously happened if the\nREJECT code was > 0 and < REJECT_INTERNAL, then there are cases were\nMaybePunishNode() can get called where it wasn't previously:\n\n- when AcceptBlockHeader() fails with CACHED_INVALID.\n- when AcceptBlockHeader() fails with BLOCK_MISSING_PREV.\n\nNote that BlockChecked() cannot fail with an 'internal' reject code. The\nonly internal reject code was REJECT_HIGHFEE, which was only set in\nATMP.\n\nThis change restores the behaviour pre-commit\n5d08c9c579ba8cc7b684105c6a08263992b08d52 which did punish nodes that\nsent us CACHED_INVALID and BLOCK_MISSING_PREV blocks.",
      "tree": {
        "sha": "36a7d2b8821a1dbc2169c0fa21086899a7934550",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/36a7d2b8821a1dbc2169c0fa21086899a7934550"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a1a07cfe99fc8cee30ba5976dc36b47b1f6532ab",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a1a07cfe99fc8cee30ba5976dc36b47b1f6532ab",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a1a07cfe99fc8cee30ba5976dc36b47b1f6532ab",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a1a07cfe99fc8cee30ba5976dc36b47b1f6532ab/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ceecefe0b0e1595e3397e7523a5749e114304d28",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ceecefe0b0e1595e3397e7523a5749e114304d28",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ceecefe0b0e1595e3397e7523a5749e114304d28"
      }
    ],
    "stats": {
      "total": 9,
      "additions": 5,
      "deletions": 4
    },
    "files": [
      {
        "sha": "8d5cccc7ff1d0fb9a16e430bd56ce6e554711e60",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a1a07cfe99fc8cee30ba5976dc36b47b1f6532ab/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a1a07cfe99fc8cee30ba5976dc36b47b1f6532ab/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=a1a07cfe99fc8cee30ba5976dc36b47b1f6532ab",
        "patch": "@@ -1234,11 +1234,12 @@ void PeerLogicValidation::BlockChecked(const CBlock& block, const CValidationSta\n     const uint256 hash(block.GetHash());\n     std::map<uint256, std::pair<NodeId, bool>>::iterator it = mapBlockSource.find(hash);\n \n-    if (state.IsInvalid()) {\n-        // Don't send reject message with code 0 or an internal reject code.\n-        if (it != mapBlockSource.end() && State(it->second.first) && state.GetRejectCode() > 0 && state.GetRejectCode() < REJECT_INTERNAL) {\n+    // If the block failed validation, we know where it came from and we're still connected\n+    // to that peer, maybe punish.\n+    if (state.IsInvalid() &&\n+        it != mapBlockSource.end() &&\n+        State(it->second.first)) {\n             MaybePunishNode(/*nodeid=*/ it->second.first, state, /*via_compact_block=*/ !it->second.second);\n-        }\n     }\n     // Check that:\n     // 1. The block is valid"
      }
    ]
  },
  {
    "sha": "0053e16714323c1694c834fdca74f064a1a33529",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMDUzZTE2NzE0MzIzYzE2OTRjODM0ZmRjYTc0ZjA2NGExYTMzNTI5",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2019-10-10T15:19:42Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2019-10-10T15:19:42Z"
      },
      "message": "[logging] Don't log REJECT code when transaction is rejected\n\nRemove the BIP61 REJECT code from error messages and logs when a\ntransaction is rejected.\n\nBIP61 support was removed from Bitcoin Core in\nfa25f43ac5692082dba3f90456c501eb08f1b75c. The REJECT codes will be\nremoved from the codebase entirely in the following commit.",
      "tree": {
        "sha": "64cf4fc218b010678a52000a09c3e4fd79f5d258",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/64cf4fc218b010678a52000a09c3e4fd79f5d258"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0053e16714323c1694c834fdca74f064a1a33529",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0053e16714323c1694c834fdca74f064a1a33529",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0053e16714323c1694c834fdca74f064a1a33529",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0053e16714323c1694c834fdca74f064a1a33529/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a1a07cfe99fc8cee30ba5976dc36b47b1f6532ab",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a1a07cfe99fc8cee30ba5976dc36b47b1f6532ab",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a1a07cfe99fc8cee30ba5976dc36b47b1f6532ab"
      }
    ],
    "stats": {
      "total": 65,
      "additions": 32,
      "deletions": 33
    },
    "files": [
      {
        "sha": "13ff2a455f588b4b217f5cfd465db338f4342ecf",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0053e16714323c1694c834fdca74f064a1a33529/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0053e16714323c1694c834fdca74f064a1a33529/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=0053e16714323c1694c834fdca74f064a1a33529",
        "patch": "@@ -906,7 +906,7 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     result_0.pushKV(\"allowed\", test_accept_res);\n     if (!test_accept_res) {\n         if (state.IsInvalid()) {\n-            result_0.pushKV(\"reject-reason\", strprintf(\"%i: %s\", state.GetRejectCode(), state.GetRejectReason()));\n+            result_0.pushKV(\"reject-reason\", strprintf(\"%s\", state.GetRejectReason()));\n         } else if (missing_inputs) {\n             result_0.pushKV(\"reject-reason\", \"missing-inputs\");\n         } else {"
      },
      {
        "sha": "9a0d889447f34a5d8383ee443845d99c9747eb0f",
        "filename": "src/util/validation.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0053e16714323c1694c834fdca74f064a1a33529/src/util/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0053e16714323c1694c834fdca74f064a1a33529/src/util/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/validation.cpp?ref=0053e16714323c1694c834fdca74f064a1a33529",
        "patch": "@@ -11,10 +11,9 @@\n /** Convert CValidationState to a human-readable message for logging */\n std::string FormatStateMessage(const CValidationState &state)\n {\n-    return strprintf(\"%s%s (code %i)\",\n+    return strprintf(\"%s%s\",\n         state.GetRejectReason(),\n-        state.GetDebugMessage().empty() ? \"\" : \", \"+state.GetDebugMessage(),\n-        state.GetRejectCode());\n+        state.GetDebugMessage().empty() ? \"\" : \", \"+state.GetDebugMessage());\n }\n \n const std::string strMessageMagic = \"Bitcoin Signed Message:\\n\";"
      },
      {
        "sha": "dd495ba41e8c97a6eeff81e7038b79624eb831cb",
        "filename": "test/functional/feature_bip68_sequence.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0053e16714323c1694c834fdca74f064a1a33529/test/functional/feature_bip68_sequence.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0053e16714323c1694c834fdca74f064a1a33529/test/functional/feature_bip68_sequence.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_bip68_sequence.py?ref=0053e16714323c1694c834fdca74f064a1a33529",
        "patch": "@@ -24,7 +24,7 @@\n SEQUENCE_LOCKTIME_MASK = 0x0000ffff\n \n # RPC error for non-BIP68 final transactions\n-NOT_FINAL_ERROR = \"non-BIP68-final (code 64)\"\n+NOT_FINAL_ERROR = \"non-BIP68-final\"\n \n class BIP68Test(BitcoinTestFramework):\n     def set_test_params(self):"
      },
      {
        "sha": "7d131e604537729d10f9fe047b9253c41243c7b2",
        "filename": "test/functional/feature_cltv.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0053e16714323c1694c834fdca74f064a1a33529/test/functional/feature_cltv.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0053e16714323c1694c834fdca74f064a1a33529/test/functional/feature_cltv.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_cltv.py?ref=0053e16714323c1694c834fdca74f064a1a33529",
        "patch": "@@ -126,7 +126,7 @@ def run_test(self):\n         # First we show that this tx is valid except for CLTV by getting it\n         # rejected from the mempool for exactly that reason.\n         assert_equal(\n-            [{'txid': spendtx.hash, 'allowed': False, 'reject-reason': '64: non-mandatory-script-verify-flag (Negative locktime)'}],\n+            [{'txid': spendtx.hash, 'allowed': False, 'reject-reason': 'non-mandatory-script-verify-flag (Negative locktime)'}],\n             self.nodes[0].testmempoolaccept(rawtxs=[spendtx.serialize().hex()], maxfeerate=0)\n         )\n "
      },
      {
        "sha": "2ace96fef40554fea20370a5ea498860b4d4babd",
        "filename": "test/functional/feature_dersig.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0053e16714323c1694c834fdca74f064a1a33529/test/functional/feature_dersig.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0053e16714323c1694c834fdca74f064a1a33529/test/functional/feature_dersig.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_dersig.py?ref=0053e16714323c1694c834fdca74f064a1a33529",
        "patch": "@@ -110,7 +110,7 @@ def run_test(self):\n         # First we show that this tx is valid except for DERSIG by getting it\n         # rejected from the mempool for exactly that reason.\n         assert_equal(\n-            [{'txid': spendtx.hash, 'allowed': False, 'reject-reason': '64: non-mandatory-script-verify-flag (Non-canonical DER signature)'}],\n+            [{'txid': spendtx.hash, 'allowed': False, 'reject-reason': 'non-mandatory-script-verify-flag (Non-canonical DER signature)'}],\n             self.nodes[0].testmempoolaccept(rawtxs=[spendtx.serialize().hex()], maxfeerate=0)\n         )\n "
      },
      {
        "sha": "aaf56a42d00ab5f0429d75308a54339b3b2dfa01",
        "filename": "test/functional/feature_nulldummy.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0053e16714323c1694c834fdca74f064a1a33529/test/functional/feature_nulldummy.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0053e16714323c1694c834fdca74f064a1a33529/test/functional/feature_nulldummy.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_nulldummy.py?ref=0053e16714323c1694c834fdca74f064a1a33529",
        "patch": "@@ -20,7 +20,7 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal, assert_raises_rpc_error\n \n-NULLDUMMY_ERROR = \"non-mandatory-script-verify-flag (Dummy CHECKMULTISIG argument must be zero) (code 64)\"\n+NULLDUMMY_ERROR = \"non-mandatory-script-verify-flag (Dummy CHECKMULTISIG argument must be zero)\"\n \n def trueDummy(tx):\n     scriptSig = CScript(tx.vin[0].scriptSig)"
      },
      {
        "sha": "82c7e55245cf3024b9edd6486418ad1d64618f4f",
        "filename": "test/functional/feature_segwit.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0053e16714323c1694c834fdca74f064a1a33529/test/functional/feature_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0053e16714323c1694c834fdca74f064a1a33529/test/functional/feature_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_segwit.py?ref=0053e16714323c1694c834fdca74f064a1a33529",
        "patch": "@@ -193,10 +193,10 @@ def run_test(self):\n             assert self.nodes[0].getrawtransaction(tx_id, False, blockhash) == tx.serialize_without_witness().hex()\n \n         self.log.info(\"Verify witness txs without witness data are invalid after the fork\")\n-        self.fail_accept(self.nodes[2], 'non-mandatory-script-verify-flag (Witness program hash mismatch) (code 64)', wit_ids[NODE_2][WIT_V0][2], sign=False)\n-        self.fail_accept(self.nodes[2], 'non-mandatory-script-verify-flag (Witness program was passed an empty witness) (code 64)', wit_ids[NODE_2][WIT_V1][2], sign=False)\n-        self.fail_accept(self.nodes[2], 'non-mandatory-script-verify-flag (Witness program hash mismatch) (code 64)', p2sh_ids[NODE_2][WIT_V0][2], sign=False, redeem_script=witness_script(False, self.pubkey[2]))\n-        self.fail_accept(self.nodes[2], 'non-mandatory-script-verify-flag (Witness program was passed an empty witness) (code 64)', p2sh_ids[NODE_2][WIT_V1][2], sign=False, redeem_script=witness_script(True, self.pubkey[2]))\n+        self.fail_accept(self.nodes[2], 'non-mandatory-script-verify-flag (Witness program hash mismatch)', wit_ids[NODE_2][WIT_V0][2], sign=False)\n+        self.fail_accept(self.nodes[2], 'non-mandatory-script-verify-flag (Witness program was passed an empty witness)', wit_ids[NODE_2][WIT_V1][2], sign=False)\n+        self.fail_accept(self.nodes[2], 'non-mandatory-script-verify-flag (Witness program hash mismatch)', p2sh_ids[NODE_2][WIT_V0][2], sign=False, redeem_script=witness_script(False, self.pubkey[2]))\n+        self.fail_accept(self.nodes[2], 'non-mandatory-script-verify-flag (Witness program was passed an empty witness)', p2sh_ids[NODE_2][WIT_V1][2], sign=False, redeem_script=witness_script(True, self.pubkey[2]))\n \n         self.log.info(\"Verify default node can now use witness txs\")\n         self.success_mine(self.nodes[0], wit_ids[NODE_0][WIT_V0][0], True)  # block 432"
      },
      {
        "sha": "c466b120f28a79ad13a889ae0cd6ea754938aecb",
        "filename": "test/functional/mempool_accept.py",
        "status": "modified",
        "additions": 18,
        "deletions": 18,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0053e16714323c1694c834fdca74f064a1a33529/test/functional/mempool_accept.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0053e16714323c1694c834fdca74f064a1a33529/test/functional/mempool_accept.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_accept.py?ref=0053e16714323c1694c834fdca74f064a1a33529",
        "patch": "@@ -71,7 +71,7 @@ def run_test(self):\n         node.generate(1)\n         self.mempool_size = 0\n         self.check_mempool_result(\n-            result_expected=[{'txid': txid_in_block, 'allowed': False, 'reject-reason': '18: txn-already-known'}],\n+            result_expected=[{'txid': txid_in_block, 'allowed': False, 'reject-reason': 'txn-already-known'}],\n             rawtxs=[raw_tx_in_block],\n         )\n \n@@ -109,7 +109,7 @@ def run_test(self):\n         node.sendrawtransaction(hexstring=raw_tx_0)\n         self.mempool_size += 1\n         self.check_mempool_result(\n-            result_expected=[{'txid': txid_0, 'allowed': False, 'reject-reason': '18: txn-already-in-mempool'}],\n+            result_expected=[{'txid': txid_0, 'allowed': False, 'reject-reason': 'txn-already-in-mempool'}],\n             rawtxs=[raw_tx_0],\n         )\n \n@@ -133,7 +133,7 @@ def run_test(self):\n         tx.vout[0].nValue -= int(4 * fee * COIN)  # Set more fee\n         # skip re-signing the tx\n         self.check_mempool_result(\n-            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '18: txn-mempool-conflict'}],\n+            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': 'txn-mempool-conflict'}],\n             rawtxs=[tx.serialize().hex()],\n             maxfeerate=0,\n         )\n@@ -192,23 +192,23 @@ def run_test(self):\n         # Skip re-signing the transaction for context independent checks from now on\n         # tx.deserialize(BytesIO(hex_str_to_bytes(node.signrawtransactionwithwallet(tx.serialize().hex())['hex'])))\n         self.check_mempool_result(\n-            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '16: bad-txns-vout-empty'}],\n+            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': 'bad-txns-vout-empty'}],\n             rawtxs=[tx.serialize().hex()],\n         )\n \n         self.log.info('A really large transaction')\n         tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n         tx.vin = [tx.vin[0]] * math.ceil(MAX_BLOCK_BASE_SIZE / len(tx.vin[0].serialize()))\n         self.check_mempool_result(\n-            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '16: bad-txns-oversize'}],\n+            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': 'bad-txns-oversize'}],\n             rawtxs=[tx.serialize().hex()],\n         )\n \n         self.log.info('A transaction with negative output value')\n         tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n         tx.vout[0].nValue *= -1\n         self.check_mempool_result(\n-            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '16: bad-txns-vout-negative'}],\n+            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': 'bad-txns-vout-negative'}],\n             rawtxs=[tx.serialize().hex()],\n         )\n \n@@ -217,7 +217,7 @@ def run_test(self):\n         tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n         tx.vout[0].nValue = 21000000 * COIN + 1\n         self.check_mempool_result(\n-            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '16: bad-txns-vout-toolarge'}],\n+            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': 'bad-txns-vout-toolarge'}],\n             rawtxs=[tx.serialize().hex()],\n         )\n \n@@ -226,15 +226,15 @@ def run_test(self):\n         tx.vout = [tx.vout[0]] * 2\n         tx.vout[0].nValue = 21000000 * COIN\n         self.check_mempool_result(\n-            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '16: bad-txns-txouttotal-toolarge'}],\n+            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': 'bad-txns-txouttotal-toolarge'}],\n             rawtxs=[tx.serialize().hex()],\n         )\n \n         self.log.info('A transaction with duplicate inputs')\n         tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n         tx.vin = [tx.vin[0]] * 2\n         self.check_mempool_result(\n-            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '16: bad-txns-inputs-duplicate'}],\n+            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': 'bad-txns-inputs-duplicate'}],\n             rawtxs=[tx.serialize().hex()],\n         )\n \n@@ -243,49 +243,49 @@ def run_test(self):\n         raw_tx_coinbase_spent = node.getrawtransaction(txid=node.decoderawtransaction(hexstring=raw_tx_in_block)['vin'][0]['txid'])\n         tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_coinbase_spent)))\n         self.check_mempool_result(\n-            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '16: coinbase'}],\n+            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': 'coinbase'}],\n             rawtxs=[tx.serialize().hex()],\n         )\n \n         self.log.info('Some nonstandard transactions')\n         tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n         tx.nVersion = 3  # A version currently non-standard\n         self.check_mempool_result(\n-            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '64: version'}],\n+            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': 'version'}],\n             rawtxs=[tx.serialize().hex()],\n         )\n         tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n         tx.vout[0].scriptPubKey = CScript([OP_0])  # Some non-standard script\n         self.check_mempool_result(\n-            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '64: scriptpubkey'}],\n+            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': 'scriptpubkey'}],\n             rawtxs=[tx.serialize().hex()],\n         )\n         tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n         tx.vin[0].scriptSig = CScript([OP_HASH160])  # Some not-pushonly scriptSig\n         self.check_mempool_result(\n-            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '64: scriptsig-not-pushonly'}],\n+            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': 'scriptsig-not-pushonly'}],\n             rawtxs=[tx.serialize().hex()],\n         )\n         tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n         output_p2sh_burn = CTxOut(nValue=540, scriptPubKey=CScript([OP_HASH160, hash160(b'burn'), OP_EQUAL]))\n         num_scripts = 100000 // len(output_p2sh_burn.serialize())  # Use enough outputs to make the tx too large for our policy\n         tx.vout = [output_p2sh_burn] * num_scripts\n         self.check_mempool_result(\n-            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '64: tx-size'}],\n+            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': 'tx-size'}],\n             rawtxs=[tx.serialize().hex()],\n         )\n         tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n         tx.vout[0] = output_p2sh_burn\n         tx.vout[0].nValue -= 1  # Make output smaller, such that it is dust for our policy\n         self.check_mempool_result(\n-            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '64: dust'}],\n+            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': 'dust'}],\n             rawtxs=[tx.serialize().hex()],\n         )\n         tx.deserialize(BytesIO(hex_str_to_bytes(raw_tx_reference)))\n         tx.vout[0].scriptPubKey = CScript([OP_RETURN, b'\\xff'])\n         tx.vout = [tx.vout[0]] * 2\n         self.check_mempool_result(\n-            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '64: multi-op-return'}],\n+            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': 'multi-op-return'}],\n             rawtxs=[tx.serialize().hex()],\n         )\n \n@@ -294,7 +294,7 @@ def run_test(self):\n         tx.vin[0].nSequence -= 1  # Should be non-max, so locktime is not ignored\n         tx.nLockTime = node.getblockcount() + 1\n         self.check_mempool_result(\n-            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '64: non-final'}],\n+            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': 'non-final'}],\n             rawtxs=[tx.serialize().hex()],\n         )\n \n@@ -303,7 +303,7 @@ def run_test(self):\n         tx.vin[0].nSequence = 2  # We could include it in the second block mined from now, but not the very next one\n         # Can skip re-signing the tx because of early rejection\n         self.check_mempool_result(\n-            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': '64: non-BIP68-final'}],\n+            result_expected=[{'txid': tx.rehash(), 'allowed': False, 'reject-reason': 'non-BIP68-final'}],\n             rawtxs=[tx.serialize().hex()],\n             maxfeerate=0,\n         )"
      },
      {
        "sha": "6676b84e542a356451ff441bdb9bd413a726bc93",
        "filename": "test/functional/p2p_dos_header_tree.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0053e16714323c1694c834fdca74f064a1a33529/test/functional/p2p_dos_header_tree.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0053e16714323c1694c834fdca74f064a1a33529/test/functional/p2p_dos_header_tree.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_dos_header_tree.py?ref=0053e16714323c1694c834fdca74f064a1a33529",
        "patch": "@@ -57,7 +57,7 @@ def run_test(self):\n         } in self.nodes[0].getchaintips()\n \n         self.log.info(\"Feed all fork headers (fails due to checkpoint)\")\n-        with self.nodes[0].assert_debug_log(['bad-fork-prior-to-checkpoint (code 67)']):\n+        with self.nodes[0].assert_debug_log(['bad-fork-prior-to-checkpoint']):\n             self.nodes[0].p2p.send_message(msg_headers(self.headers_fork))\n             self.nodes[0].p2p.wait_for_disconnect()\n "
      },
      {
        "sha": "74fea07350e91ff176ec88e771f67419d1b9face",
        "filename": "test/functional/rpc_rawtransaction.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0053e16714323c1694c834fdca74f064a1a33529/test/functional/rpc_rawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0053e16714323c1694c834fdca74f064a1a33529/test/functional/rpc_rawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_rawtransaction.py?ref=0053e16714323c1694c834fdca74f064a1a33529",
        "patch": "@@ -454,7 +454,7 @@ def run_test(self):\n         # Thus, testmempoolaccept should reject\n         testres = self.nodes[2].testmempoolaccept([rawTxSigned['hex']], 0.00001000)[0]\n         assert_equal(testres['allowed'], False)\n-        assert_equal(testres['reject-reason'], '256: absurdly-high-fee')\n+        assert_equal(testres['reject-reason'], 'absurdly-high-fee')\n         # and sendrawtransaction should throw\n         assert_raises_rpc_error(-26, \"absurdly-high-fee\", self.nodes[2].sendrawtransaction, rawTxSigned['hex'], 0.00001000)\n         # and the following calls should both succeed\n@@ -478,7 +478,7 @@ def run_test(self):\n         # Thus, testmempoolaccept should reject\n         testres = self.nodes[2].testmempoolaccept([rawTxSigned['hex']])[0]\n         assert_equal(testres['allowed'], False)\n-        assert_equal(testres['reject-reason'], '256: absurdly-high-fee')\n+        assert_equal(testres['reject-reason'], 'absurdly-high-fee')\n         # and sendrawtransaction should throw\n         assert_raises_rpc_error(-26, \"absurdly-high-fee\", self.nodes[2].sendrawtransaction, rawTxSigned['hex'])\n         # and the following calls should both succeed"
      }
    ]
  },
  {
    "sha": "e9d5a59e34ff2d538d8f5315efd9908bf24d0fdc",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplOWQ1YTU5ZTM0ZmYyZDUzOGQ4ZjUzMTVlZmQ5OTA4YmYyNGQwZmRj",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2019-09-30T20:25:04Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2019-10-10T17:31:53Z"
      },
      "message": "[validation] Remove REJECT code from CValidationState\n\nWe no longer send BIP 61 REJECT messages, so there's no need to set\na REJECT code in the CValidationState object.",
      "tree": {
        "sha": "1019a60f2c8c49fc377b87968b04f59349716de7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1019a60f2c8c49fc377b87968b04f59349716de7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e9d5a59e34ff2d538d8f5315efd9908bf24d0fdc",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e9d5a59e34ff2d538d8f5315efd9908bf24d0fdc",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e9d5a59e34ff2d538d8f5315efd9908bf24d0fdc",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e9d5a59e34ff2d538d8f5315efd9908bf24d0fdc/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0053e16714323c1694c834fdca74f064a1a33529",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0053e16714323c1694c834fdca74f064a1a33529",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0053e16714323c1694c834fdca74f064a1a33529"
      }
    ],
    "stats": {
      "total": 168,
      "additions": 72,
      "deletions": 96
    },
    "files": [
      {
        "sha": "12060358397814c62ee8d1d7217678340fecef2d",
        "filename": "src/consensus/tx_check.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e9d5a59e34ff2d538d8f5315efd9908bf24d0fdc/src/consensus/tx_check.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e9d5a59e34ff2d538d8f5315efd9908bf24d0fdc/src/consensus/tx_check.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_check.cpp?ref=e9d5a59e34ff2d538d8f5315efd9908bf24d0fdc",
        "patch": "@@ -11,24 +11,24 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fChe\n {\n     // Basic checks that don't depend on any context\n     if (tx.vin.empty())\n-        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-vin-empty\");\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-txns-vin-empty\");\n     if (tx.vout.empty())\n-        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-vout-empty\");\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-txns-vout-empty\");\n     // Size limits (this doesn't take the witness into account, as that hasn't been checked for malleability)\n     if (::GetSerializeSize(tx, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)\n-        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-oversize\");\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-txns-oversize\");\n \n     // Check for negative or overflow output values (see CVE-2010-5139)\n     CAmount nValueOut = 0;\n     for (const auto& txout : tx.vout)\n     {\n         if (txout.nValue < 0)\n-            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-vout-negative\");\n+            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-txns-vout-negative\");\n         if (txout.nValue > MAX_MONEY)\n-            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-vout-toolarge\");\n+            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-txns-vout-toolarge\");\n         nValueOut += txout.nValue;\n         if (!MoneyRange(nValueOut))\n-            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-txouttotal-toolarge\");\n+            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-txns-txouttotal-toolarge\");\n     }\n \n     // Check for duplicate inputs - note that this check is slow so we skip it in CheckBlock\n@@ -37,20 +37,20 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fChe\n         for (const auto& txin : tx.vin)\n         {\n             if (!vInOutPoints.insert(txin.prevout).second)\n-                return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n+                return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-txns-inputs-duplicate\");\n         }\n     }\n \n     if (tx.IsCoinBase())\n     {\n         if (tx.vin[0].scriptSig.size() < 2 || tx.vin[0].scriptSig.size() > 100)\n-            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-cb-length\");\n+            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-cb-length\");\n     }\n     else\n     {\n         for (const auto& txin : tx.vin)\n             if (txin.prevout.IsNull())\n-                return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-prevout-null\");\n+                return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-txns-prevout-null\");\n     }\n \n     return true;"
      },
      {
        "sha": "ceeddc3f6d092a93b485b0ad887b52d6c06bd662",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e9d5a59e34ff2d538d8f5315efd9908bf24d0fdc/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e9d5a59e34ff2d538d8f5315efd9908bf24d0fdc/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=e9d5a59e34ff2d538d8f5315efd9908bf24d0fdc",
        "patch": "@@ -160,7 +160,7 @@ bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, c\n {\n     // are the actual inputs available?\n     if (!inputs.HaveInputs(tx)) {\n-        return state.Invalid(ValidationInvalidReason::TX_MISSING_INPUTS, false, REJECT_INVALID, \"bad-txns-inputs-missingorspent\",\n+        return state.Invalid(ValidationInvalidReason::TX_MISSING_INPUTS, false, \"bad-txns-inputs-missingorspent\",\n                          strprintf(\"%s: inputs missing/spent\", __func__));\n     }\n \n@@ -172,27 +172,27 @@ bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, c\n \n         // If prev is coinbase, check that it's matured\n         if (coin.IsCoinBase() && nSpendHeight - coin.nHeight < COINBASE_MATURITY) {\n-            return state.Invalid(ValidationInvalidReason::TX_PREMATURE_SPEND, false, REJECT_INVALID, \"bad-txns-premature-spend-of-coinbase\",\n+            return state.Invalid(ValidationInvalidReason::TX_PREMATURE_SPEND, false, \"bad-txns-premature-spend-of-coinbase\",\n                 strprintf(\"tried to spend coinbase at depth %d\", nSpendHeight - coin.nHeight));\n         }\n \n         // Check for negative or overflow input values\n         nValueIn += coin.out.nValue;\n         if (!MoneyRange(coin.out.nValue) || !MoneyRange(nValueIn)) {\n-            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-inputvalues-outofrange\");\n+            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-txns-inputvalues-outofrange\");\n         }\n     }\n \n     const CAmount value_out = tx.GetValueOut();\n     if (nValueIn < value_out) {\n-        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-in-belowout\",\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-txns-in-belowout\",\n             strprintf(\"value in (%s) < value out (%s)\", FormatMoney(nValueIn), FormatMoney(value_out)));\n     }\n \n     // Tally transaction fees\n     const CAmount txfee_aux = nValueIn - value_out;\n     if (!MoneyRange(txfee_aux)) {\n-        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-fee-outofrange\");\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-txns-fee-outofrange\");\n     }\n \n     txfee = txfee_aux;"
      },
      {
        "sha": "4920cdf8811f6d21e45f8093f9c6c22b30251819",
        "filename": "src/consensus/validation.h",
        "status": "modified",
        "additions": 2,
        "deletions": 17,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e9d5a59e34ff2d538d8f5315efd9908bf24d0fdc/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e9d5a59e34ff2d538d8f5315efd9908bf24d0fdc/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=e9d5a59e34ff2d538d8f5315efd9908bf24d0fdc",
        "patch": "@@ -12,20 +12,8 @@\n #include <primitives/transaction.h>\n #include <primitives/block.h>\n \n-/** \"reject\" message codes */\n-static const unsigned char REJECT_MALFORMED = 0x01;\n-static const unsigned char REJECT_INVALID = 0x10;\n-static const unsigned char REJECT_OBSOLETE = 0x11;\n-static const unsigned char REJECT_DUPLICATE = 0x12;\n-static const unsigned char REJECT_NONSTANDARD = 0x40;\n-// static const unsigned char REJECT_DUST = 0x41; // part of BIP 61\n-static const unsigned char REJECT_INSUFFICIENTFEE = 0x42;\n-static const unsigned char REJECT_CHECKPOINT = 0x43;\n-\n /** A \"reason\" why something was invalid, suitable for determining whether the\n   * provider of the object should be banned/ignored/disconnected/etc.\n-  * These are much more granular than the rejection codes, which may be more\n-  * useful for some other use-cases.\n   */\n enum class ValidationInvalidReason {\n     // txn and blocks:\n@@ -104,15 +92,13 @@ class CValidationState {\n     } mode;\n     ValidationInvalidReason m_reason;\n     std::string strRejectReason;\n-    unsigned int chRejectCode;\n     std::string strDebugMessage;\n public:\n-    CValidationState() : mode(MODE_VALID), m_reason(ValidationInvalidReason::NONE), chRejectCode(0) {}\n+    CValidationState() : mode(MODE_VALID), m_reason(ValidationInvalidReason::NONE) {}\n     bool Invalid(ValidationInvalidReason reasonIn, bool ret = false,\n-            unsigned int chRejectCodeIn=0, const std::string &strRejectReasonIn=\"\",\n+            const std::string &strRejectReasonIn=\"\",\n             const std::string &strDebugMessageIn=\"\") {\n         m_reason = reasonIn;\n-        chRejectCode = chRejectCodeIn;\n         strRejectReason = strRejectReasonIn;\n         strDebugMessage = strDebugMessageIn;\n         if (mode == MODE_ERROR)\n@@ -136,7 +122,6 @@ class CValidationState {\n         return mode == MODE_ERROR;\n     }\n     ValidationInvalidReason GetReason() const { return m_reason; }\n-    unsigned int GetRejectCode() const { return chRejectCode; }\n     std::string GetRejectReason() const { return strRejectReason; }\n     std::string GetDebugMessage() const { return strDebugMessage; }\n };"
      },
      {
        "sha": "3d9bf5509004f940c1c39199cf29e9263cfdd8ff",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 56,
        "deletions": 57,
        "changes": 113,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e9d5a59e34ff2d538d8f5315efd9908bf24d0fdc/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e9d5a59e34ff2d538d8f5315efd9908bf24d0fdc/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=e9d5a59e34ff2d538d8f5315efd9908bf24d0fdc",
        "patch": "@@ -508,11 +508,11 @@ class MemPoolAccept\n     {\n         CAmount mempoolRejectFee = m_pool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(package_size);\n         if (mempoolRejectFee > 0 && package_fee < mempoolRejectFee) {\n-            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"mempool min fee not met\", strprintf(\"%d < %d\", package_fee, mempoolRejectFee));\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, \"mempool min fee not met\", strprintf(\"%d < %d\", package_fee, mempoolRejectFee));\n         }\n \n         if (package_fee < ::minRelayTxFee.GetFee(package_size)) {\n-            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"min relay fee not met\", strprintf(\"%d < %d\", package_fee, ::minRelayTxFee.GetFee(package_size)));\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, \"min relay fee not met\", strprintf(\"%d < %d\", package_fee, ::minRelayTxFee.GetFee(package_size)));\n         }\n         return true;\n     }\n@@ -565,29 +565,29 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n \n     // Coinbase is only valid in a block, not as a loose transaction\n     if (tx.IsCoinBase())\n-        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"coinbase\");\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"coinbase\");\n \n     // Rather not work on nonstandard transactions (unless -testnet/-regtest)\n     std::string reason;\n     if (fRequireStandard && !IsStandardTx(tx, reason))\n-        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, reason);\n+        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, reason);\n \n     // Do not work on transactions that are too small.\n     // A transaction with 1 segwit input and 1 P2WPHK output has non-witness size of 82 bytes.\n     // Transactions smaller than this are not relayed to mitigate CVE-2017-12842 by not relaying\n     // 64-byte transactions.\n     if (::GetSerializeSize(tx, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) < MIN_STANDARD_TX_NONWITNESS_SIZE)\n-        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"tx-size-small\");\n+        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, \"tx-size-small\");\n \n     // Only accept nLockTime-using transactions that can be mined in the next\n     // block; we don't want our mempool filled up with transactions that can't\n     // be mined yet.\n     if (!CheckFinalTx(tx, STANDARD_LOCKTIME_VERIFY_FLAGS))\n-        return state.Invalid(ValidationInvalidReason::TX_PREMATURE_SPEND, false, REJECT_NONSTANDARD, \"non-final\");\n+        return state.Invalid(ValidationInvalidReason::TX_PREMATURE_SPEND, false, \"non-final\");\n \n     // is it already in the memory pool?\n     if (m_pool.exists(hash)) {\n-        return state.Invalid(ValidationInvalidReason::TX_CONFLICT, false, REJECT_DUPLICATE, \"txn-already-in-mempool\");\n+        return state.Invalid(ValidationInvalidReason::TX_CONFLICT, false, \"txn-already-in-mempool\");\n     }\n \n     // Check for conflicts with in-memory transactions\n@@ -619,7 +619,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n                     }\n                 }\n                 if (fReplacementOptOut) {\n-                    return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_DUPLICATE, \"txn-mempool-conflict\");\n+                    return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, \"txn-mempool-conflict\");\n                 }\n \n                 setConflicts.insert(ptxConflicting->GetHash());\n@@ -645,7 +645,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n             for (size_t out = 0; out < tx.vout.size(); out++) {\n                 // Optimistically just do efficient check of cache for outputs\n                 if (coins_cache.HaveCoinInCache(COutPoint(hash, out))) {\n-                    return state.Invalid(ValidationInvalidReason::TX_CONFLICT, false, REJECT_DUPLICATE, \"txn-already-known\");\n+                    return state.Invalid(ValidationInvalidReason::TX_CONFLICT, false, \"txn-already-known\");\n                 }\n             }\n             // Otherwise assume this might be an orphan tx for which we just haven't seen parents yet\n@@ -670,7 +670,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     // Must keep pool.cs for this unless we change CheckSequenceLocks to take a\n     // CoinsViewCache instead of create its own\n     if (!CheckSequenceLocks(m_pool, tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n-        return state.Invalid(ValidationInvalidReason::TX_PREMATURE_SPEND, false, REJECT_NONSTANDARD, \"non-BIP68-final\");\n+        return state.Invalid(ValidationInvalidReason::TX_PREMATURE_SPEND, false, \"non-BIP68-final\");\n \n     CAmount nFees = 0;\n     if (!Consensus::CheckTxInputs(tx, state, m_view, GetSpendHeight(m_view), nFees)) {\n@@ -679,11 +679,11 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n \n     // Check for non-standard pay-to-script-hash in inputs\n     if (fRequireStandard && !AreInputsStandard(tx, m_view))\n-        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n+        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, \"bad-txns-nonstandard-inputs\");\n \n     // Check for non-standard witness in P2WSH\n     if (tx.HasWitness() && fRequireStandard && !IsWitnessStandard(tx, m_view))\n-        return state.Invalid(ValidationInvalidReason::TX_WITNESS_MUTATED, false, REJECT_NONSTANDARD, \"bad-witness-nonstandard\");\n+        return state.Invalid(ValidationInvalidReason::TX_WITNESS_MUTATED, false, \"bad-witness-nonstandard\");\n \n     int64_t nSigOpsCost = GetTransactionSigOpCost(tx, m_view, STANDARD_SCRIPT_VERIFY_FLAGS);\n \n@@ -707,7 +707,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     unsigned int nSize = entry->GetTxSize();\n \n     if (nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST)\n-        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\",\n+        return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, \"bad-txns-too-many-sigops\",\n                 strprintf(\"%d\", nSigOpsCost));\n \n     // No transactions are allowed below minRelayTxFee except from disconnected\n@@ -716,8 +716,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n \n     if (nAbsurdFee && nFees > nAbsurdFee)\n         return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false,\n-                REJECT_HIGHFEE, \"absurdly-high-fee\",\n-                strprintf(\"%d > %d\", nFees, nAbsurdFee));\n+                \"absurdly-high-fee\", strprintf(\"%d > %d\", nFees, nAbsurdFee));\n \n     const CTxMemPool::setEntries setIterConflicting = m_pool.GetIterSet(setConflicts);\n     // Calculate in-mempool ancestors, up to a limit.\n@@ -774,7 +773,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n         // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n         if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n                 !m_pool.CalculateMemPoolAncestors(*entry, setAncestors, 2, m_limit_ancestor_size, m_limit_descendants + 1, m_limit_descendant_size + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, \"too-long-mempool-chain\", errString);\n         }\n     }\n \n@@ -787,7 +786,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n         const uint256 &hashAncestor = ancestorIt->GetTx().GetHash();\n         if (setConflicts.count(hashAncestor))\n         {\n-            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-spends-conflicting-tx\",\n+            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-txns-spends-conflicting-tx\",\n                     strprintf(\"%s spends conflicting transaction %s\",\n                         hash.ToString(),\n                         hashAncestor.ToString()));\n@@ -827,7 +826,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n             CFeeRate oldFeeRate(mi->GetModifiedFee(), mi->GetTxSize());\n             if (newFeeRate <= oldFeeRate)\n             {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n+                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, \"insufficient fee\",\n                         strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",\n                             hash.ToString(),\n                             newFeeRate.ToString(),\n@@ -855,7 +854,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n                 nConflictingSize += it->GetTxSize();\n             }\n         } else {\n-            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too many potential replacements\",\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, \"too many potential replacements\",\n                     strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n                         hash.ToString(),\n                         nConflictingCount,\n@@ -879,7 +878,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n                 // it's cheaper to just check if the new input refers to a\n                 // tx that's in the mempool.\n                 if (m_pool.exists(tx.vin[j].prevout.hash)) {\n-                    return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"replacement-adds-unconfirmed\",\n+                    return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, \"replacement-adds-unconfirmed\",\n                             strprintf(\"replacement %s adds unconfirmed input, idx %d\",\n                                 hash.ToString(), j));\n                 }\n@@ -891,7 +890,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n         // transactions would not be paid for.\n         if (nModifiedFees < nConflictingFees)\n         {\n-            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, \"insufficient fee\",\n                     strprintf(\"rejecting replacement %s, less fees than conflicting txs; %s < %s\",\n                         hash.ToString(), FormatMoney(nModifiedFees), FormatMoney(nConflictingFees)));\n         }\n@@ -901,7 +900,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n         CAmount nDeltaFees = nModifiedFees - nConflictingFees;\n         if (nDeltaFees < ::incrementalRelayFee.GetFee(nSize))\n         {\n-            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, \"insufficient fee\",\n                     strprintf(\"rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n                         hash.ToString(),\n                         FormatMoney(nDeltaFees),\n@@ -930,7 +929,7 @@ bool MemPoolAccept::PolicyScriptChecks(ATMPArgs& args, Workspace& ws, Precompute\n                 !CheckInputs(tx, stateDummy, m_view, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true, false, txdata)) {\n             // Only the witness is missing, so the transaction itself may be fine.\n             state.Invalid(ValidationInvalidReason::TX_WITNESS_MUTATED, false,\n-                    state.GetRejectCode(), state.GetRejectReason(), state.GetDebugMessage());\n+                    state.GetRejectReason(), state.GetDebugMessage());\n         }\n         assert(IsTransactionReason(state.GetReason()));\n         return false; // state filled in by CheckInputs\n@@ -1013,7 +1012,7 @@ bool MemPoolAccept::Finalize(ATMPArgs& args, Workspace& ws)\n     if (!bypass_limits) {\n         LimitMempoolSize(m_pool, gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, std::chrono::hours{gArgs.GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY)});\n         if (!m_pool.exists(hash))\n-            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_INSUFFICIENTFEE, \"mempool full\");\n+            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, \"mempool full\");\n     }\n     return true;\n }\n@@ -1548,7 +1547,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                 CScriptCheck check2(coin.out, tx, i,\n                         flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheSigStore, &txdata);\n                 if (check2())\n-                    return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n+                    return state.Invalid(ValidationInvalidReason::TX_NOT_STANDARD, false, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n             }\n             // MANDATORY flag failures correspond to\n             // ValidationInvalidReason::CONSENSUS. Because CONSENSUS\n@@ -1559,7 +1558,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n             // support, to avoid splitting the network (but this\n             // depends on the details of how net_processing handles\n             // such errors).\n-            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n+            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n         }\n     }\n \n@@ -2062,7 +2061,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n             for (size_t o = 0; o < tx->vout.size(); o++) {\n                 if (view.HaveCoin(COutPoint(tx->GetHash(), o))) {\n                     return state.Invalid(ValidationInvalidReason::CONSENSUS, error(\"ConnectBlock(): tried to overwrite transaction\"),\n-                                     REJECT_INVALID, \"bad-txns-BIP30\");\n+                                     \"bad-txns-BIP30\");\n                 }\n             }\n         }\n@@ -2107,14 +2106,14 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n                     // defined for a block, so we reset the reason flag to\n                     // CONSENSUS here.\n                     state.Invalid(ValidationInvalidReason::CONSENSUS, false,\n-                            state.GetRejectCode(), state.GetRejectReason(), state.GetDebugMessage());\n+                            state.GetRejectReason(), state.GetDebugMessage());\n                 }\n                 return error(\"%s: Consensus::CheckTxInputs: %s, %s\", __func__, tx.GetHash().ToString(), FormatStateMessage(state));\n             }\n             nFees += txfee;\n             if (!MoneyRange(nFees)) {\n                 return state.Invalid(ValidationInvalidReason::CONSENSUS, error(\"%s: accumulated fee in the block out of range.\", __func__),\n-                                 REJECT_INVALID, \"bad-txns-accumulated-fee-outofrange\");\n+                                 \"bad-txns-accumulated-fee-outofrange\");\n             }\n \n             // Check that transaction is BIP68 final\n@@ -2127,7 +2126,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n \n             if (!SequenceLocks(tx, nLockTimeFlags, &prevheights, *pindex)) {\n                 return state.Invalid(ValidationInvalidReason::CONSENSUS, error(\"%s: contains a non-BIP68-final transaction\", __func__),\n-                                 REJECT_INVALID, \"bad-txns-nonfinal\");\n+                                 \"bad-txns-nonfinal\");\n             }\n         }\n \n@@ -2138,7 +2137,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n         nSigOpsCost += GetTransactionSigOpCost(tx, view, flags);\n         if (nSigOpsCost > MAX_BLOCK_SIGOPS_COST)\n             return state.Invalid(ValidationInvalidReason::CONSENSUS, error(\"ConnectBlock(): too many sigops\"),\n-                             REJECT_INVALID, \"bad-blk-sigops\");\n+                             \"bad-blk-sigops\");\n \n         txdata.emplace_back(tx);\n         if (!tx.IsCoinBase())\n@@ -2154,7 +2153,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n                     // consider whether rewriting to CONSENSUS or\n                     // RECENT_CONSENSUS_CHANGE would be more appropriate.\n                     state.Invalid(ValidationInvalidReason::CONSENSUS, false,\n-                              state.GetRejectCode(), state.GetRejectReason(), state.GetDebugMessage());\n+                              state.GetRejectReason(), state.GetDebugMessage());\n                 }\n                 return error(\"ConnectBlock(): CheckInputs on %s failed with %s\",\n                     tx.GetHash().ToString(), FormatStateMessage(state));\n@@ -2176,10 +2175,10 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n         return state.Invalid(ValidationInvalidReason::CONSENSUS,\n                          error(\"ConnectBlock(): coinbase pays too much (actual=%d vs limit=%d)\",\n                                block.vtx[0]->GetValueOut(), blockReward),\n-                               REJECT_INVALID, \"bad-cb-amount\");\n+                               \"bad-cb-amount\");\n \n     if (!control.Wait())\n-        return state.Invalid(ValidationInvalidReason::CONSENSUS, error(\"%s: CheckQueue failed\", __func__), REJECT_INVALID, \"block-validation-failed\");\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS, error(\"%s: CheckQueue failed\", __func__), \"block-validation-failed\");\n     int64_t nTime4 = GetTimeMicros(); nTimeVerify += nTime4 - nTime2;\n     LogPrint(BCLog::BENCH, \"    - Verify %u txins: %.2fms (%.3fms/txin) [%.2fs (%.2fms/blk)]\\n\", nInputs - 1, MILLI * (nTime4 - nTime2), nInputs <= 1 ? 0 : MILLI * (nTime4 - nTime2) / (nInputs-1), nTimeVerify * MICRO, nTimeVerify * MILLI / nBlocksTotal);\n \n@@ -3256,7 +3255,7 @@ static bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state,\n {\n     // Check proof of work matches claimed amount\n     if (fCheckPOW && !CheckProofOfWork(block.GetHash(), block.nBits, consensusParams))\n-        return state.Invalid(ValidationInvalidReason::BLOCK_INVALID_HEADER, false, REJECT_INVALID, \"high-hash\", \"proof of work failed\");\n+        return state.Invalid(ValidationInvalidReason::BLOCK_INVALID_HEADER, false, \"high-hash\", \"proof of work failed\");\n \n     return true;\n }\n@@ -3278,13 +3277,13 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n         bool mutated;\n         uint256 hashMerkleRoot2 = BlockMerkleRoot(block, &mutated);\n         if (block.hashMerkleRoot != hashMerkleRoot2)\n-            return state.Invalid(ValidationInvalidReason::BLOCK_MUTATED, false, REJECT_INVALID, \"bad-txnmrklroot\", \"hashMerkleRoot mismatch\");\n+            return state.Invalid(ValidationInvalidReason::BLOCK_MUTATED, false, \"bad-txnmrklroot\", \"hashMerkleRoot mismatch\");\n \n         // Check for merkle tree malleability (CVE-2012-2459): repeating sequences\n         // of transactions in a block without affecting the merkle root of a block,\n         // while still invalidating it.\n         if (mutated)\n-            return state.Invalid(ValidationInvalidReason::BLOCK_MUTATED, false, REJECT_INVALID, \"bad-txns-duplicate\", \"duplicate transaction\");\n+            return state.Invalid(ValidationInvalidReason::BLOCK_MUTATED, false, \"bad-txns-duplicate\", \"duplicate transaction\");\n     }\n \n     // All potential-corruption validation must be done before we do any\n@@ -3295,20 +3294,20 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n \n     // Size limits\n     if (block.vtx.empty() || block.vtx.size() * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT || ::GetSerializeSize(block, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)\n-        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-blk-length\", \"size limits failed\");\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-blk-length\", \"size limits failed\");\n \n     // First transaction must be coinbase, the rest must not be\n     if (block.vtx.empty() || !block.vtx[0]->IsCoinBase())\n-        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-cb-missing\", \"first tx is not coinbase\");\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-cb-missing\", \"first tx is not coinbase\");\n     for (unsigned int i = 1; i < block.vtx.size(); i++)\n         if (block.vtx[i]->IsCoinBase())\n-            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-cb-multiple\", \"more than one coinbase\");\n+            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-cb-multiple\", \"more than one coinbase\");\n \n     // Check transactions\n     // Must check for duplicate inputs (see CVE-2018-17144)\n     for (const auto& tx : block.vtx)\n         if (!CheckTransaction(*tx, state, true))\n-            return state.Invalid(state.GetReason(), false, state.GetRejectCode(), state.GetRejectReason(),\n+            return state.Invalid(state.GetReason(), false, state.GetRejectReason(),\n                                  strprintf(\"Transaction check failed (tx hash %s) %s\", tx->GetHash().ToString(), state.GetDebugMessage()));\n \n     unsigned int nSigOps = 0;\n@@ -3317,7 +3316,7 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n         nSigOps += GetLegacySigOpCount(*tx);\n     }\n     if (nSigOps * WITNESS_SCALE_FACTOR > MAX_BLOCK_SIGOPS_COST)\n-        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-blk-sigops\", \"out-of-bounds SigOpCount\");\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-blk-sigops\", \"out-of-bounds SigOpCount\");\n \n     if (fCheckPOW && fCheckMerkleRoot)\n         block.fChecked = true;\n@@ -3418,7 +3417,7 @@ static bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationSta\n     // Check proof of work\n     const Consensus::Params& consensusParams = params.GetConsensus();\n     if (block.nBits != GetNextWorkRequired(pindexPrev, &block, consensusParams))\n-        return state.Invalid(ValidationInvalidReason::BLOCK_INVALID_HEADER, false, REJECT_INVALID, \"bad-diffbits\", \"incorrect proof of work\");\n+        return state.Invalid(ValidationInvalidReason::BLOCK_INVALID_HEADER, false, \"bad-diffbits\", \"incorrect proof of work\");\n \n     // Check against checkpoints\n     if (fCheckpointsEnabled) {\n@@ -3427,23 +3426,23 @@ static bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationSta\n         // g_blockman.m_block_index.\n         CBlockIndex* pcheckpoint = GetLastCheckpoint(params.Checkpoints());\n         if (pcheckpoint && nHeight < pcheckpoint->nHeight)\n-            return state.Invalid(ValidationInvalidReason::BLOCK_CHECKPOINT, error(\"%s: forked chain older than last checkpoint (height %d)\", __func__, nHeight), REJECT_CHECKPOINT, \"bad-fork-prior-to-checkpoint\");\n+            return state.Invalid(ValidationInvalidReason::BLOCK_CHECKPOINT, error(\"%s: forked chain older than last checkpoint (height %d)\", __func__, nHeight), \"bad-fork-prior-to-checkpoint\");\n     }\n \n     // Check timestamp against prev\n     if (block.GetBlockTime() <= pindexPrev->GetMedianTimePast())\n-        return state.Invalid(ValidationInvalidReason::BLOCK_INVALID_HEADER, false, REJECT_INVALID, \"time-too-old\", \"block's timestamp is too early\");\n+        return state.Invalid(ValidationInvalidReason::BLOCK_INVALID_HEADER, false, \"time-too-old\", \"block's timestamp is too early\");\n \n     // Check timestamp\n     if (block.GetBlockTime() > nAdjustedTime + MAX_FUTURE_BLOCK_TIME)\n-        return state.Invalid(ValidationInvalidReason::BLOCK_TIME_FUTURE, false, REJECT_INVALID, \"time-too-new\", \"block timestamp too far in the future\");\n+        return state.Invalid(ValidationInvalidReason::BLOCK_TIME_FUTURE, false, \"time-too-new\", \"block timestamp too far in the future\");\n \n     // Reject outdated version blocks when 95% (75% on testnet) of the network has upgraded:\n     // check for version 2, 3 and 4 upgrades\n     if((block.nVersion < 2 && nHeight >= consensusParams.BIP34Height) ||\n        (block.nVersion < 3 && nHeight >= consensusParams.BIP66Height) ||\n        (block.nVersion < 4 && nHeight >= consensusParams.BIP65Height))\n-            return state.Invalid(ValidationInvalidReason::BLOCK_INVALID_HEADER, false, REJECT_OBSOLETE, strprintf(\"bad-version(0x%08x)\", block.nVersion),\n+            return state.Invalid(ValidationInvalidReason::BLOCK_INVALID_HEADER, false, strprintf(\"bad-version(0x%08x)\", block.nVersion),\n                                  strprintf(\"rejected nVersion=0x%08x block\", block.nVersion));\n \n     return true;\n@@ -3473,7 +3472,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     // Check that all transactions are finalized\n     for (const auto& tx : block.vtx) {\n         if (!IsFinalTx(*tx, nHeight, nLockTimeCutoff)) {\n-            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-txns-nonfinal\", \"non-final transaction\");\n+            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-txns-nonfinal\", \"non-final transaction\");\n         }\n     }\n \n@@ -3483,7 +3482,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n         CScript expect = CScript() << nHeight;\n         if (block.vtx[0]->vin[0].scriptSig.size() < expect.size() ||\n             !std::equal(expect.begin(), expect.end(), block.vtx[0]->vin[0].scriptSig.begin())) {\n-            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-cb-height\", \"block height mismatch in coinbase\");\n+            return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-cb-height\", \"block height mismatch in coinbase\");\n         }\n     }\n \n@@ -3505,11 +3504,11 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n             // already does not permit it, it is impossible to trigger in the\n             // witness tree.\n             if (block.vtx[0]->vin[0].scriptWitness.stack.size() != 1 || block.vtx[0]->vin[0].scriptWitness.stack[0].size() != 32) {\n-                return state.Invalid(ValidationInvalidReason::BLOCK_MUTATED, false, REJECT_INVALID, \"bad-witness-nonce-size\", strprintf(\"%s : invalid witness reserved value size\", __func__));\n+                return state.Invalid(ValidationInvalidReason::BLOCK_MUTATED, false, \"bad-witness-nonce-size\", strprintf(\"%s : invalid witness reserved value size\", __func__));\n             }\n             CHash256().Write(hashWitness.begin(), 32).Write(&block.vtx[0]->vin[0].scriptWitness.stack[0][0], 32).Finalize(hashWitness.begin());\n             if (memcmp(hashWitness.begin(), &block.vtx[0]->vout[commitpos].scriptPubKey[6], 32)) {\n-                return state.Invalid(ValidationInvalidReason::BLOCK_MUTATED, false, REJECT_INVALID, \"bad-witness-merkle-match\", strprintf(\"%s : witness merkle commitment mismatch\", __func__));\n+                return state.Invalid(ValidationInvalidReason::BLOCK_MUTATED, false, \"bad-witness-merkle-match\", strprintf(\"%s : witness merkle commitment mismatch\", __func__));\n             }\n             fHaveWitness = true;\n         }\n@@ -3519,7 +3518,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     if (!fHaveWitness) {\n       for (const auto& tx : block.vtx) {\n             if (tx->HasWitness()) {\n-                return state.Invalid(ValidationInvalidReason::BLOCK_MUTATED, false, REJECT_INVALID, \"unexpected-witness\", strprintf(\"%s : unexpected witness data found\", __func__));\n+                return state.Invalid(ValidationInvalidReason::BLOCK_MUTATED, false, \"unexpected-witness\", strprintf(\"%s : unexpected witness data found\", __func__));\n             }\n         }\n     }\n@@ -3531,7 +3530,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     // the block hash, so we couldn't mark the block as permanently\n     // failed).\n     if (GetBlockWeight(block) > MAX_BLOCK_WEIGHT) {\n-        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, REJECT_INVALID, \"bad-blk-weight\", strprintf(\"%s : weight limit failed\", __func__));\n+        return state.Invalid(ValidationInvalidReason::CONSENSUS, false, \"bad-blk-weight\", strprintf(\"%s : weight limit failed\", __func__));\n     }\n \n     return true;\n@@ -3551,7 +3550,7 @@ bool BlockManager::AcceptBlockHeader(const CBlockHeader& block, CValidationState\n             if (ppindex)\n                 *ppindex = pindex;\n             if (pindex->nStatus & BLOCK_FAILED_MASK)\n-                return state.Invalid(ValidationInvalidReason::CACHED_INVALID, error(\"%s: block %s is marked invalid\", __func__, hash.ToString()), 0, \"duplicate\");\n+                return state.Invalid(ValidationInvalidReason::CACHED_INVALID, error(\"%s: block %s is marked invalid\", __func__, hash.ToString()), \"duplicate\");\n             return true;\n         }\n \n@@ -3562,10 +3561,10 @@ bool BlockManager::AcceptBlockHeader(const CBlockHeader& block, CValidationState\n         CBlockIndex* pindexPrev = nullptr;\n         BlockMap::iterator mi = m_block_index.find(block.hashPrevBlock);\n         if (mi == m_block_index.end())\n-            return state.Invalid(ValidationInvalidReason::BLOCK_MISSING_PREV, error(\"%s: prev block not found\", __func__), 0, \"prev-blk-not-found\");\n+            return state.Invalid(ValidationInvalidReason::BLOCK_MISSING_PREV, error(\"%s: prev block not found\", __func__), \"prev-blk-not-found\");\n         pindexPrev = (*mi).second;\n         if (pindexPrev->nStatus & BLOCK_FAILED_MASK)\n-            return state.Invalid(ValidationInvalidReason::BLOCK_INVALID_PREV, error(\"%s: prev block invalid\", __func__), REJECT_INVALID, \"bad-prevblk\");\n+            return state.Invalid(ValidationInvalidReason::BLOCK_INVALID_PREV, error(\"%s: prev block invalid\", __func__), \"bad-prevblk\");\n         if (!ContextualCheckBlockHeader(block, state, chainparams, pindexPrev, GetAdjustedTime()))\n             return error(\"%s: Consensus::ContextualCheckBlockHeader: %s, %s\", __func__, hash.ToString(), FormatStateMessage(state));\n \n@@ -3602,7 +3601,7 @@ bool BlockManager::AcceptBlockHeader(const CBlockHeader& block, CValidationState\n                         setDirtyBlockIndex.insert(invalid_walk);\n                         invalid_walk = invalid_walk->pprev;\n                     }\n-                    return state.Invalid(ValidationInvalidReason::BLOCK_INVALID_PREV, error(\"%s: prev block invalid\", __func__), REJECT_INVALID, \"bad-prevblk\");\n+                    return state.Invalid(ValidationInvalidReason::BLOCK_INVALID_PREV, error(\"%s: prev block invalid\", __func__), \"bad-prevblk\");\n                 }\n             }\n         }"
      },
      {
        "sha": "fe81ef83e2cc0e79e1fb2faaefcfe3e1c380a9f8",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 0,
        "deletions": 8,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e9d5a59e34ff2d538d8f5315efd9908bf24d0fdc/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e9d5a59e34ff2d538d8f5315efd9908bf24d0fdc/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=e9d5a59e34ff2d538d8f5315efd9908bf24d0fdc",
        "patch": "@@ -779,14 +779,6 @@ extern VersionBitsCache versionbitscache;\n  */\n int32_t ComputeBlockVersion(const CBlockIndex* pindexPrev, const Consensus::Params& params);\n \n-/** Reject codes greater or equal to this can be returned by AcceptToMemPool\n- * for transactions, to signal internal conditions. They cannot and should not\n- * be sent over the P2P network.\n- */\n-static const unsigned int REJECT_INTERNAL = 0x100;\n-/** Too high fee. Can not be triggered by P2P transactions */\n-static const unsigned int REJECT_HIGHFEE = 0x100;\n-\n /** Get block file info entry for one block file */\n CBlockFileInfo* GetBlockFileInfo(size_t n);\n "
      }
    ]
  },
  {
    "sha": "04a2f326ec0f06fb4fce1c4f93500752f05dede8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowNGEyZjMyNmVjMGYwNmZiNGZjZTFjNGY5MzUwMDc1MmYwNWRlZGU4",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2019-10-10T15:28:22Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2019-10-10T17:31:57Z"
      },
      "message": "[validation] Fix REJECT message comments",
      "tree": {
        "sha": "4c48477281c0fcf7e7aff2900b701835a44b4ba6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4c48477281c0fcf7e7aff2900b701835a44b4ba6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/04a2f326ec0f06fb4fce1c4f93500752f05dede8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/04a2f326ec0f06fb4fce1c4f93500752f05dede8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/04a2f326ec0f06fb4fce1c4f93500752f05dede8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/04a2f326ec0f06fb4fce1c4f93500752f05dede8/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e9d5a59e34ff2d538d8f5315efd9908bf24d0fdc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e9d5a59e34ff2d538d8f5315efd9908bf24d0fdc",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e9d5a59e34ff2d538d8f5315efd9908bf24d0fdc"
      }
    ],
    "stats": {
      "total": 16,
      "additions": 9,
      "deletions": 7
    },
    "files": [
      {
        "sha": "1425f091c595fcba680c289dcf7d7836258e145c",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 7,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/04a2f326ec0f06fb4fce1c4f93500752f05dede8/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/04a2f326ec0f06fb4fce1c4f93500752f05dede8/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=04a2f326ec0f06fb4fce1c4f93500752f05dede8",
        "patch": "@@ -117,8 +117,8 @@ namespace {\n     int nSyncStarted GUARDED_BY(cs_main) = 0;\n \n     /**\n-     * Sources of received blocks, saved to be able to send them reject\n-     * messages or ban them when processing happens afterwards.\n+     * Sources of received blocks, saved to be able punish them when processing\n+     * happens afterwards.\n      * Set mapBlockSource[hash].second to false if the node should not be\n      * punished if the block is invalid.\n      */\n@@ -2861,11 +2861,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 // been run).  This is handled below, so just treat this as\n                 // though the block was successfully read, and rely on the\n                 // handling in ProcessNewBlock to ensure the block index is\n-                // updated, reject messages go out, etc.\n+                // updated, etc.\n                 MarkBlockAsReceived(resp.blockhash); // it is now an empty pointer\n                 fBlockRead = true;\n-                // mapBlockSource is only used for sending reject messages and DoS scores,\n-                // so the race between here and cs_main in ProcessNewBlock is fine.\n+                // mapBlockSource is used for potentially punishing peers and\n+                // updating which peers send us compact blocks, so the race\n+                // between here and cs_main in ProcessNewBlock is fine.\n                 // BIP 152 permits peers to relay compact blocks after validating\n                 // the header only; we should not punish peers if the block turns\n                 // out to be invalid.\n@@ -2937,8 +2938,9 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // Also always process if we requested the block explicitly, as we may\n             // need it even though it is not a candidate for a new best tip.\n             forceProcessing |= MarkBlockAsReceived(hash);\n-            // mapBlockSource is only used for sending reject messages and DoS scores,\n-            // so the race between here and cs_main in ProcessNewBlock is fine.\n+            // mapBlockSource is only used for punishing peers and setting\n+            // which peers send us compact blocks, so the race between here and\n+            // cs_main in ProcessNewBlock is fine.\n             mapBlockSource.emplace(hash, std::make_pair(pfrom->GetId(), true));\n         }\n         bool fNewBlock = false;"
      }
    ]
  },
  {
    "sha": "9075d13153ce06cd59a45644831ecc43126e1e82",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5MDc1ZDEzMTUzY2UwNmNkNTlhNDU2NDQ4MzFlY2M0MzEyNmUxZTgy",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2019-10-08T20:24:30Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2019-10-10T17:31:57Z"
      },
      "message": "[docs] Add release notes for removal of REJECT reasons",
      "tree": {
        "sha": "49dda7e40956d8aa488476041ea7b68ea20e8e55",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/49dda7e40956d8aa488476041ea7b68ea20e8e55"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9075d13153ce06cd59a45644831ecc43126e1e82",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9075d13153ce06cd59a45644831ecc43126e1e82",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9075d13153ce06cd59a45644831ecc43126e1e82",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9075d13153ce06cd59a45644831ecc43126e1e82/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "04a2f326ec0f06fb4fce1c4f93500752f05dede8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/04a2f326ec0f06fb4fce1c4f93500752f05dede8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/04a2f326ec0f06fb4fce1c4f93500752f05dede8"
      }
    ],
    "stats": {
      "total": 19,
      "additions": 19,
      "deletions": 0
    },
    "files": [
      {
        "sha": "661420775756332bec75077abb550ec81fd3875e",
        "filename": "doc/release-notes-15437.md",
        "status": "modified",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9075d13153ce06cd59a45644831ecc43126e1e82/doc/release-notes-15437.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9075d13153ce06cd59a45644831ecc43126e1e82/doc/release-notes-15437.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes-15437.md?ref=9075d13153ce06cd59a45644831ecc43126e1e82",
        "patch": "@@ -32,3 +32,22 @@ Please use the recommended alternatives if you rely on this deprecated feature:\n   could wait until the transaction has confirmed (taking into account the fee\n   target they set (compare the RPC `estimatesmartfee`)) or listen for the\n   transaction announcement by other network peers to check for propagation.\n+\n+The removal of BIP61 REJECT message support also has the following minor RPC\n+and logging implications:\n+\n+* `testmempoolaccept` and `sendrawtransaction` no longer return the P2P REJECT\n+  code when a transaction is not accepted to the mempool. They still return the\n+  verbal reject reason.\n+\n+* Log messages that previously reported the REJECT code when a transaction was\n+  not accepted to the mempool now no longer report the REJECT code. The reason\n+  for rejection is still reported.\n+\n+Updated RPCs\n+------------\n+\n+- `testmempoolaccept` and `sendrawtransaction` no longer return the P2P REJECT\n+  code when a transaction is not accepted to the mempool. See the Section\n+  _Removal of reject network messages from Bitcoin Core (BIP61)_ for details on\n+  the removal of BIP61 REJECT message support."
      }
    ]
  }
]