[
  {
    "sha": "b9ed349f42ee7a8b7f3a6013dffbcc63becf5742",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiOWVkMzQ5ZjQyZWU3YThiN2YzYTYwMTNkZmZiY2M2M2JlY2Y1NzQy",
    "commit": {
      "author": {
        "name": "Ben Woosley",
        "email": "ben.woosley@gmail.com",
        "date": "2018-05-15T19:31:51Z"
      },
      "committer": {
        "name": "Ben Woosley",
        "email": "ben.woosley@gmail.com",
        "date": "2018-05-24T22:00:37Z"
      },
      "message": "[moveonly] Move CNode declaration above CConnman in net.h\n\nThis enables CConnman template methods to have access to a full declaration\nof CNode, such that their implementation can be fully contained in net.h.",
      "tree": {
        "sha": "1a72e6554597f31adcf04bb8f972bbaad51414ed",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1a72e6554597f31adcf04bb8f972bbaad51414ed"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b9ed349f42ee7a8b7f3a6013dffbcc63becf5742",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE+XLHXoy4Dim7e8hvTYykuhgECQYFAlsHNgcACgkQTYykuhgE\nCQZrBBAAggn7bOzttsrBYmilnGxxXhuJcyWvXCR982IF5WtgAoHSQgXNXY3zmHwc\n1q42AbNF//QFNXx2AkpRCPXs28YgUQBw1/GQ324ySeveEXh6c9vrm4I0yFBQ2No0\nV0gPHZ9SygIM8w/gK3tnfrg+J5yuZ137Rq7Dg1+mYYGyKpZfKtv987CpZODPNaoF\nbeT7kH+0NBG52tk9eUDhygf4RzzMqn+2Rv9bCQQp/5dTMLU73zyQbiAW4+rXln40\nuueziwRjGGG0IiXUqzfjM0XT7rrL9Cz8LyXJgI+21mduLK5+5VwkgP3oeylQ4NQL\nfLCxOEf789+wRv2O14UpXVEGP3BlcZVrkd1GL4pZCHY6pfFtguL7pmfL6+02FaD9\nTnm/ZVvM8p1r0WtD90ywpe863d/jq2jsgsMd7Gm30puRGEFY1D9yqOsRW0EU9Pfb\nASobPjIufglS7xvtVhxCfpDKVSUEhN1OAafI0yySAUSCvWjCpz2sEyGoI8p75sZn\nftGDWwN7EwF3yFMbUzT7B5biFOEuFCL7c//zVewcYDWcCm6DmHJ6fubSTrBTOtuk\nezod7d/J/+uQkxxfPZ9rdtrEosfeOjWcRyEGborwSJm/+ccTrp89KuZZHXy68tet\nqwix5dX7a07t8eVvmfAm6tpgQpCz9TNRRH04JhOPr4atykh4m2Q=\n=QUcg\n-----END PGP SIGNATURE-----",
        "payload": "tree 1a72e6554597f31adcf04bb8f972bbaad51414ed\nparent 4cfe17c3382ba750131cdc8703b2978132822070\nauthor Ben Woosley <ben.woosley@gmail.com> 1526412711 -0700\ncommitter Ben Woosley <ben.woosley@gmail.com> 1527199237 -0700\n\n[moveonly] Move CNode declaration above CConnman in net.h\n\nThis enables CConnman template methods to have access to a full declaration\nof CNode, such that their implementation can be fully contained in net.h.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b9ed349f42ee7a8b7f3a6013dffbcc63becf5742",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b9ed349f42ee7a8b7f3a6013dffbcc63becf5742",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b9ed349f42ee7a8b7f3a6013dffbcc63becf5742/comments",
    "author": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4cfe17c3382ba750131cdc8703b2978132822070",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4cfe17c3382ba750131cdc8703b2978132822070",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4cfe17c3382ba750131cdc8703b2978132822070"
      }
    ],
    "stats": {
      "total": 1258,
      "additions": 627,
      "deletions": 631
    },
    "files": [
      {
        "sha": "43ab2d7b6893c7ba60a2602bc3936d12344d83e1",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 627,
        "deletions": 631,
        "changes": 1258,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b9ed349f42ee7a8b7f3a6013dffbcc63becf5742/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b9ed349f42ee7a8b7f3a6013dffbcc63becf5742/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=b9ed349f42ee7a8b7f3a6013dffbcc63becf5742",
        "patch": "@@ -35,7 +35,6 @@\n \n \n class CScheduler;\n-class CNode;\n \n /** Time between pings automatically sent out for latency probing and keepalive (in seconds). */\n static const int PING_INTERVAL = 2 * 60;\n@@ -93,7 +92,47 @@ struct AddedNodeInfo\n     bool fInbound;\n };\n \n-class CNodeStats;\n+struct LocalServiceInfo {\n+    int nScore;\n+    int nPort;\n+};\n+\n+extern CCriticalSection cs_mapLocalHost;\n+extern std::map<CNetAddr, LocalServiceInfo> mapLocalHost;\n+typedef std::map<std::string, uint64_t> mapMsgCmdSize; //command, total bytes\n+\n+class CNodeStats\n+{\n+public:\n+    NodeId nodeid;\n+    ServiceFlags nServices;\n+    bool fRelayTxes;\n+    int64_t nLastSend;\n+    int64_t nLastRecv;\n+    int64_t nTimeConnected;\n+    int64_t nTimeOffset;\n+    std::string addrName;\n+    int nVersion;\n+    std::string cleanSubVer;\n+    bool fInbound;\n+    bool m_manual_connection;\n+    int nStartingHeight;\n+    uint64_t nSendBytes;\n+    mapMsgCmdSize mapSendBytesPerMsgCmd;\n+    uint64_t nRecvBytes;\n+    mapMsgCmdSize mapRecvBytesPerMsgCmd;\n+    bool fWhitelisted;\n+    double dPingTime;\n+    double dPingWait;\n+    double dMinPing;\n+    // Our address, as reported by the peer\n+    std::string addrLocal;\n+    // Address of this peer\n+    CAddress addr;\n+    // Bind address of our side of the connection\n+    CAddress addrBind;\n+};\n+\n class CClientUIInterface;\n \n struct CSerializedNetMsg\n@@ -109,754 +148,711 @@ struct CSerializedNetMsg\n     std::string command;\n };\n \n-class NetEventsInterface;\n-class CConnman\n-{\n+class CNetMessage {\n+private:\n+    mutable CHash256 hasher;\n+    mutable uint256 data_hash;\n public:\n+    bool in_data;                   // parsing header (false) or data (true)\n \n-    enum NumConnections {\n-        CONNECTIONS_NONE = 0,\n-        CONNECTIONS_IN = (1U << 0),\n-        CONNECTIONS_OUT = (1U << 1),\n-        CONNECTIONS_ALL = (CONNECTIONS_IN | CONNECTIONS_OUT),\n-    };\n-\n-    struct Options\n-    {\n-        ServiceFlags nLocalServices = NODE_NONE;\n-        int nMaxConnections = 0;\n-        int nMaxOutbound = 0;\n-        int nMaxAddnode = 0;\n-        int nMaxFeeler = 0;\n-        int nBestHeight = 0;\n-        CClientUIInterface* uiInterface = nullptr;\n-        NetEventsInterface* m_msgproc = nullptr;\n-        unsigned int nSendBufferMaxSize = 0;\n-        unsigned int nReceiveFloodSize = 0;\n-        uint64_t nMaxOutboundTimeframe = 0;\n-        uint64_t nMaxOutboundLimit = 0;\n-        std::vector<std::string> vSeedNodes;\n-        std::vector<CSubNet> vWhitelistedRange;\n-        std::vector<CService> vBinds, vWhiteBinds;\n-        bool m_use_addrman_outgoing = true;\n-        std::vector<std::string> m_specified_outgoing;\n-        std::vector<std::string> m_added_nodes;\n-    };\n-\n-    void Init(const Options& connOptions) {\n-        nLocalServices = connOptions.nLocalServices;\n-        nMaxConnections = connOptions.nMaxConnections;\n-        nMaxOutbound = std::min(connOptions.nMaxOutbound, connOptions.nMaxConnections);\n-        nMaxAddnode = connOptions.nMaxAddnode;\n-        nMaxFeeler = connOptions.nMaxFeeler;\n-        nBestHeight = connOptions.nBestHeight;\n-        clientInterface = connOptions.uiInterface;\n-        m_msgproc = connOptions.m_msgproc;\n-        nSendBufferMaxSize = connOptions.nSendBufferMaxSize;\n-        nReceiveFloodSize = connOptions.nReceiveFloodSize;\n-        {\n-            LOCK(cs_totalBytesSent);\n-            nMaxOutboundTimeframe = connOptions.nMaxOutboundTimeframe;\n-            nMaxOutboundLimit = connOptions.nMaxOutboundLimit;\n-        }\n-        vWhitelistedRange = connOptions.vWhitelistedRange;\n-        {\n-            LOCK(cs_vAddedNodes);\n-            vAddedNodes = connOptions.m_added_nodes;\n-        }\n-    }\n-\n-    CConnman(uint64_t seed0, uint64_t seed1);\n-    ~CConnman();\n-    bool Start(CScheduler& scheduler, const Options& options);\n-    void Stop();\n-    void Interrupt();\n-    bool GetNetworkActive() const { return fNetworkActive; };\n-    void SetNetworkActive(bool active);\n-    void OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound = nullptr, const char *strDest = nullptr, bool fOneShot = false, bool fFeeler = false, bool manual_connection = false);\n-    bool CheckIncomingNonce(uint64_t nonce);\n+    CDataStream hdrbuf;             // partially received header\n+    CMessageHeader hdr;             // complete header\n+    unsigned int nHdrPos;\n \n-    bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func);\n+    CDataStream vRecv;              // received message data\n+    unsigned int nDataPos;\n \n-    void PushMessage(CNode* pnode, CSerializedNetMsg&& msg);\n+    int64_t nTime;                  // time (in microseconds) of message receipt.\n \n-    template<typename Callable>\n-    void ForEachNode(Callable&& func)\n-    {\n-        LOCK(cs_vNodes);\n-        for (auto&& node : vNodes) {\n-            if (NodeFullyConnected(node))\n-                func(node);\n-        }\n-    };\n+    CNetMessage(const CMessageHeader::MessageStartChars& pchMessageStartIn, int nTypeIn, int nVersionIn) : hdrbuf(nTypeIn, nVersionIn), hdr(pchMessageStartIn), vRecv(nTypeIn, nVersionIn) {\n+        hdrbuf.resize(24);\n+        in_data = false;\n+        nHdrPos = 0;\n+        nDataPos = 0;\n+        nTime = 0;\n+    }\n \n-    template<typename Callable>\n-    void ForEachNode(Callable&& func) const\n+    bool complete() const\n     {\n-        LOCK(cs_vNodes);\n-        for (auto&& node : vNodes) {\n-            if (NodeFullyConnected(node))\n-                func(node);\n-        }\n-    };\n+        if (!in_data)\n+            return false;\n+        return (hdr.nMessageSize == nDataPos);\n+    }\n \n-    template<typename Callable, typename CallableAfter>\n-    void ForEachNodeThen(Callable&& pre, CallableAfter&& post)\n-    {\n-        LOCK(cs_vNodes);\n-        for (auto&& node : vNodes) {\n-            if (NodeFullyConnected(node))\n-                pre(node);\n-        }\n-        post();\n-    };\n+    const uint256& GetMessageHash() const;\n \n-    template<typename Callable, typename CallableAfter>\n-    void ForEachNodeThen(Callable&& pre, CallableAfter&& post) const\n+    void SetVersion(int nVersionIn)\n     {\n-        LOCK(cs_vNodes);\n-        for (auto&& node : vNodes) {\n-            if (NodeFullyConnected(node))\n-                pre(node);\n-        }\n-        post();\n-    };\n-\n-    // Addrman functions\n-    size_t GetAddressCount() const;\n-    void SetServices(const CService &addr, ServiceFlags nServices);\n-    void MarkAddressGood(const CAddress& addr);\n-    void AddNewAddresses(const std::vector<CAddress>& vAddr, const CAddress& addrFrom, int64_t nTimePenalty = 0);\n-    std::vector<CAddress> GetAddresses();\n-\n-    // Denial-of-service detection/prevention\n-    // The idea is to detect peers that are behaving\n-    // badly and disconnect/ban them, but do it in a\n-    // one-coding-mistake-won't-shatter-the-entire-network\n-    // way.\n-    // IMPORTANT:  There should be nothing I can give a\n-    // node that it will forward on that will make that\n-    // node's peers drop it. If there is, an attacker\n-    // can isolate a node and/or try to split the network.\n-    // Dropping a node for sending stuff that is invalid\n-    // now but might be valid in a later version is also\n-    // dangerous, because it can cause a network split\n-    // between nodes running old code and nodes running\n-    // new code.\n-    void Ban(const CNetAddr& netAddr, const BanReason& reason, int64_t bantimeoffset = 0, bool sinceUnixEpoch = false);\n-    void Ban(const CSubNet& subNet, const BanReason& reason, int64_t bantimeoffset = 0, bool sinceUnixEpoch = false);\n-    void ClearBanned(); // needed for unit testing\n-    bool IsBanned(CNetAddr ip);\n-    bool IsBanned(CSubNet subnet);\n-    bool Unban(const CNetAddr &ip);\n-    bool Unban(const CSubNet &ip);\n-    void GetBanned(banmap_t &banmap);\n-    void SetBanned(const banmap_t &banmap);\n-\n-    // This allows temporarily exceeding nMaxOutbound, with the goal of finding\n-    // a peer that is better than all our current peers.\n-    void SetTryNewOutboundPeer(bool flag);\n-    bool GetTryNewOutboundPeer();\n+        hdrbuf.SetVersion(nVersionIn);\n+        vRecv.SetVersion(nVersionIn);\n+    }\n \n-    // Return the number of outbound peers we have in excess of our target (eg,\n-    // if we previously called SetTryNewOutboundPeer(true), and have since set\n-    // to false, we may have extra peers that we wish to disconnect). This may\n-    // return a value less than (num_outbound_connections - num_outbound_slots)\n-    // in cases where some outbound connections are not yet fully connected, or\n-    // not yet fully disconnected.\n-    int GetExtraOutboundCount();\n+    int readHeader(const char *pch, unsigned int nBytes);\n+    int readData(const char *pch, unsigned int nBytes);\n+};\n \n-    bool AddNode(const std::string& node);\n-    bool RemoveAddedNode(const std::string& node);\n-    std::vector<AddedNodeInfo> GetAddedNodeInfo();\n+class CConnman;\n \n-    size_t GetNodeCount(NumConnections num);\n-    void GetNodeStats(std::vector<CNodeStats>& vstats);\n-    bool DisconnectNode(const std::string& node);\n-    bool DisconnectNode(NodeId id);\n+/** Information about a peer */\n+class CNode\n+{\n+    friend class CConnman;\n+public:\n+    // socket\n+    std::atomic<ServiceFlags> nServices;\n+    SOCKET hSocket;\n+    size_t nSendSize; // total size of all vSendMsg entries\n+    size_t nSendOffset; // offset inside the first vSendMsg already sent\n+    uint64_t nSendBytes;\n+    std::deque<std::vector<unsigned char>> vSendMsg;\n+    CCriticalSection cs_vSend;\n+    CCriticalSection cs_hSocket;\n+    CCriticalSection cs_vRecv;\n \n-    ServiceFlags GetLocalServices() const;\n+    CCriticalSection cs_vProcessMsg;\n+    std::list<CNetMessage> vProcessMsg;\n+    size_t nProcessQueueSize;\n \n-    //!set the max outbound target in bytes\n-    void SetMaxOutboundTarget(uint64_t limit);\n-    uint64_t GetMaxOutboundTarget();\n+    CCriticalSection cs_sendProcessing;\n \n-    //!set the timeframe for the max outbound target\n-    void SetMaxOutboundTimeframe(uint64_t timeframe);\n-    uint64_t GetMaxOutboundTimeframe();\n+    std::deque<CInv> vRecvGetData;\n+    uint64_t nRecvBytes;\n+    std::atomic<int> nRecvVersion;\n \n-    //!check if the outbound target is reached\n-    // if param historicalBlockServingLimit is set true, the function will\n-    // response true if the limit for serving historical blocks has been reached\n-    bool OutboundTargetReached(bool historicalBlockServingLimit);\n+    std::atomic<int64_t> nLastSend;\n+    std::atomic<int64_t> nLastRecv;\n+    const int64_t nTimeConnected;\n+    std::atomic<int64_t> nTimeOffset;\n+    // Address of this peer\n+    const CAddress addr;\n+    // Bind address of our side of the connection\n+    const CAddress addrBind;\n+    std::atomic<int> nVersion;\n+    // strSubVer is whatever byte array we read from the wire. However, this field is intended\n+    // to be printed out, displayed to humans in various forms and so on. So we sanitize it and\n+    // store the sanitized version in cleanSubVer. The original should be used when dealing with\n+    // the network or wire types and the cleaned string used when displayed or logged.\n+    std::string strSubVer, cleanSubVer;\n+    CCriticalSection cs_SubVer; // used for both cleanSubVer and strSubVer\n+    bool fWhitelisted; // This peer can bypass DoS banning.\n+    bool fFeeler; // If true this node is being used as a short lived feeler.\n+    bool fOneShot;\n+    bool m_manual_connection;\n+    bool fClient;\n+    bool m_limited_node; //after BIP159\n+    const bool fInbound;\n+    std::atomic_bool fSuccessfullyConnected;\n+    std::atomic_bool fDisconnect;\n+    // We use fRelayTxes for two purposes -\n+    // a) it allows us to not relay tx invs before receiving the peer's version message\n+    // b) the peer may tell us in its version message that we should not relay tx invs\n+    //    unless it loads a bloom filter.\n+    bool fRelayTxes; //protected by cs_filter\n+    bool fSentAddr;\n+    CSemaphoreGrant grantOutbound;\n+    CCriticalSection cs_filter;\n+    std::unique_ptr<CBloomFilter> pfilter;\n+    std::atomic<int> nRefCount;\n \n-    //!response the bytes left in the current max outbound cycle\n-    // in case of no limit, it will always response 0\n-    uint64_t GetOutboundTargetBytesLeft();\n+    const uint64_t nKeyedNetGroup;\n+    std::atomic_bool fPauseRecv;\n+    std::atomic_bool fPauseSend;\n+protected:\n \n-    //!response the time in second left in the current max outbound cycle\n-    // in case of no limit, it will always response 0\n-    uint64_t GetMaxOutboundTimeLeftInCycle();\n+    mapMsgCmdSize mapSendBytesPerMsgCmd;\n+    mapMsgCmdSize mapRecvBytesPerMsgCmd;\n \n-    uint64_t GetTotalBytesRecv();\n-    uint64_t GetTotalBytesSent();\n+public:\n+    uint256 hashContinue;\n+    std::atomic<int> nStartingHeight;\n \n-    void SetBestHeight(int height);\n-    int GetBestHeight() const;\n+    // flood relay\n+    std::vector<CAddress> vAddrToSend;\n+    CRollingBloomFilter addrKnown;\n+    bool fGetAddr;\n+    std::set<uint256> setKnown;\n+    int64_t nNextAddrSend;\n+    int64_t nNextLocalAddrSend;\n \n-    /** Get a unique deterministic randomizer. */\n-    CSipHasher GetDeterministicRandomizer(uint64_t id) const;\n+    // inventory based relay\n+    CRollingBloomFilter filterInventoryKnown;\n+    // Set of transaction ids we still have to announce.\n+    // They are sorted by the mempool before relay, so the order is not important.\n+    std::set<uint256> setInventoryTxToSend;\n+    // List of block ids we still have announce.\n+    // There is no final sorting before sending, as they are always sent immediately\n+    // and in the order requested.\n+    std::vector<uint256> vInventoryBlockToSend;\n+    CCriticalSection cs_inventory;\n+    std::set<uint256> setAskFor;\n+    std::multimap<int64_t, CInv> mapAskFor;\n+    int64_t nNextInvSend;\n+    // Used for headers announcements - unfiltered blocks to relay\n+    // Also protected by cs_inventory\n+    std::vector<uint256> vBlockHashesToAnnounce;\n+    // Used for BIP35 mempool sending, also protected by cs_inventory\n+    bool fSendMempool;\n \n-    unsigned int GetReceiveFloodSize() const;\n+    // Last time a \"MEMPOOL\" request was serviced.\n+    std::atomic<int64_t> timeLastMempoolReq;\n \n-    void WakeMessageHandler();\n-private:\n-    struct ListenSocket {\n-        SOCKET socket;\n-        bool whitelisted;\n+    // Block and TXN accept times\n+    std::atomic<int64_t> nLastBlockTime;\n+    std::atomic<int64_t> nLastTXTime;\n \n-        ListenSocket(SOCKET socket_, bool whitelisted_) : socket(socket_), whitelisted(whitelisted_) {}\n-    };\n+    // Ping time measurement:\n+    // The pong reply we're expecting, or 0 if no pong expected.\n+    std::atomic<uint64_t> nPingNonceSent;\n+    // Time (in usec) the last ping was sent, or 0 if no ping was ever sent.\n+    std::atomic<int64_t> nPingUsecStart;\n+    // Last measured round-trip time.\n+    std::atomic<int64_t> nPingUsecTime;\n+    // Best measured round-trip time.\n+    std::atomic<int64_t> nMinPingUsecTime;\n+    // Whether a ping is requested.\n+    std::atomic<bool> fPingQueued;\n+    // Minimum fee rate with which to filter inv's to this node\n+    CAmount minFeeFilter;\n+    CCriticalSection cs_feeFilter;\n+    CAmount lastSentFeeFilter;\n+    int64_t nextSendTimeFeeFilter;\n \n-    bool BindListenPort(const CService &bindAddr, std::string& strError, bool fWhitelisted = false);\n-    bool Bind(const CService &addr, unsigned int flags);\n-    bool InitBinds(const std::vector<CService>& binds, const std::vector<CService>& whiteBinds);\n-    void ThreadOpenAddedConnections();\n-    void AddOneShot(const std::string& strDest);\n-    void ProcessOneShot();\n-    void ThreadOpenConnections(std::vector<std::string> connect);\n-    void ThreadMessageHandler();\n-    void AcceptConnection(const ListenSocket& hListenSocket);\n-    void ThreadSocketHandler();\n-    void ThreadDNSAddressSeed();\n+    CNode(NodeId id, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn, SOCKET hSocketIn, const CAddress &addrIn, uint64_t nKeyedNetGroupIn, uint64_t nLocalHostNonceIn, const CAddress &addrBindIn, const std::string &addrNameIn = \"\", bool fInboundIn = false);\n+    ~CNode();\n+    CNode(const CNode&) = delete;\n+    CNode& operator=(const CNode&) = delete;\n \n-    uint64_t CalculateKeyedNetGroup(const CAddress& ad) const;\n+private:\n+    const NodeId id;\n+    const uint64_t nLocalHostNonce;\n+    // Services offered to this peer\n+    const ServiceFlags nLocalServices;\n+    const int nMyStartingHeight;\n+    int nSendVersion;\n+    std::list<CNetMessage> vRecvMsg;  // Used only by SocketHandler thread\n \n-    CNode* FindNode(const CNetAddr& ip);\n-    CNode* FindNode(const CSubNet& subNet);\n-    CNode* FindNode(const std::string& addrName);\n-    CNode* FindNode(const CService& addr);\n+    mutable CCriticalSection cs_addrName;\n+    std::string addrName;\n \n-    bool AttemptToEvictConnection();\n-    CNode* ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure, bool manual_connection);\n-    bool IsWhitelistedRange(const CNetAddr &addr);\n+    // Our address, as reported by the peer\n+    CService addrLocal;\n+    mutable CCriticalSection cs_addrLocal;\n+public:\n \n-    void DeleteNode(CNode* pnode);\n+    NodeId GetId() const {\n+        return id;\n+    }\n \n-    NodeId GetNewNodeId();\n+    uint64_t GetLocalNonce() const {\n+        return nLocalHostNonce;\n+    }\n \n-    size_t SocketSendData(CNode *pnode) const;\n-    //!check is the banlist has unwritten changes\n-    bool BannedSetIsDirty();\n-    //!set the \"dirty\" flag for the banlist\n-    void SetBannedSetDirty(bool dirty=true);\n-    //!clean unused entries (if bantime has expired)\n-    void SweepBanned();\n-    void DumpAddresses();\n-    void DumpData();\n-    void DumpBanlist();\n+    int GetMyStartingHeight() const {\n+        return nMyStartingHeight;\n+    }\n \n-    // Network stats\n-    void RecordBytesRecv(uint64_t bytes);\n-    void RecordBytesSent(uint64_t bytes);\n+    int GetRefCount() const\n+    {\n+        assert(nRefCount >= 0);\n+        return nRefCount;\n+    }\n \n-    // Whether the node should be passed out in ForEach* callbacks\n-    static bool NodeFullyConnected(const CNode* pnode);\n+    bool ReceiveMsgBytes(const char *pch, unsigned int nBytes, bool& complete);\n \n-    // Network usage totals\n-    CCriticalSection cs_totalBytesRecv;\n-    CCriticalSection cs_totalBytesSent;\n-    uint64_t nTotalBytesRecv GUARDED_BY(cs_totalBytesRecv);\n-    uint64_t nTotalBytesSent GUARDED_BY(cs_totalBytesSent);\n+    void SetRecvVersion(int nVersionIn)\n+    {\n+        nRecvVersion = nVersionIn;\n+    }\n+    int GetRecvVersion() const\n+    {\n+        return nRecvVersion;\n+    }\n+    void SetSendVersion(int nVersionIn);\n+    int GetSendVersion() const;\n \n-    // outbound limit & stats\n-    uint64_t nMaxOutboundTotalBytesSentInCycle GUARDED_BY(cs_totalBytesSent);\n-    uint64_t nMaxOutboundCycleStartTime GUARDED_BY(cs_totalBytesSent);\n-    uint64_t nMaxOutboundLimit GUARDED_BY(cs_totalBytesSent);\n-    uint64_t nMaxOutboundTimeframe GUARDED_BY(cs_totalBytesSent);\n+    CService GetAddrLocal() const;\n+    //! May not be called more than once\n+    void SetAddrLocal(const CService& addrLocalIn);\n \n-    // Whitelisted ranges. Any node connecting from these is automatically\n-    // whitelisted (as well as those connecting to whitelisted binds).\n-    std::vector<CSubNet> vWhitelistedRange;\n+    CNode* AddRef()\n+    {\n+        nRefCount++;\n+        return this;\n+    }\n \n-    unsigned int nSendBufferMaxSize;\n-    unsigned int nReceiveFloodSize;\n+    void Release()\n+    {\n+        nRefCount--;\n+    }\n \n-    std::vector<ListenSocket> vhListenSocket;\n-    std::atomic<bool> fNetworkActive;\n-    banmap_t setBanned;\n-    CCriticalSection cs_setBanned;\n-    bool setBannedIsDirty;\n-    bool fAddressesInitialized;\n-    CAddrMan addrman;\n-    std::deque<std::string> vOneShots;\n-    CCriticalSection cs_vOneShots;\n-    std::vector<std::string> vAddedNodes GUARDED_BY(cs_vAddedNodes);\n-    CCriticalSection cs_vAddedNodes;\n-    std::vector<CNode*> vNodes;\n-    std::list<CNode*> vNodesDisconnected;\n-    mutable CCriticalSection cs_vNodes;\n-    std::atomic<NodeId> nLastNodeId;\n \n-    /** Services this instance offers */\n-    ServiceFlags nLocalServices;\n \n-    std::unique_ptr<CSemaphore> semOutbound;\n-    std::unique_ptr<CSemaphore> semAddnode;\n-    int nMaxConnections;\n-    int nMaxOutbound;\n-    int nMaxAddnode;\n-    int nMaxFeeler;\n-    std::atomic<int> nBestHeight;\n-    CClientUIInterface* clientInterface;\n-    NetEventsInterface* m_msgproc;\n+    void AddAddressKnown(const CAddress& _addr)\n+    {\n+        addrKnown.insert(_addr.GetKey());\n+    }\n \n-    /** SipHasher seeds for deterministic randomness */\n-    const uint64_t nSeed0, nSeed1;\n+    void PushAddress(const CAddress& _addr, FastRandomContext &insecure_rand)\n+    {\n+        // Known checking here is only to save space from duplicates.\n+        // SendMessages will filter it again for knowns that were added\n+        // after addresses were pushed.\n+        if (_addr.IsValid() && !addrKnown.contains(_addr.GetKey())) {\n+            if (vAddrToSend.size() >= MAX_ADDR_TO_SEND) {\n+                vAddrToSend[insecure_rand.randrange(vAddrToSend.size())] = _addr;\n+            } else {\n+                vAddrToSend.push_back(_addr);\n+            }\n+        }\n+    }\n \n-    /** flag for waking the message processor. */\n-    bool fMsgProcWake;\n \n-    std::condition_variable condMsgProc;\n-    std::mutex mutexMsgProc;\n-    std::atomic<bool> flagInterruptMsgProc;\n+    void AddInventoryKnown(const CInv& inv)\n+    {\n+        {\n+            LOCK(cs_inventory);\n+            filterInventoryKnown.insert(inv.hash);\n+        }\n+    }\n \n-    CThreadInterrupt interruptNet;\n+    void PushInventory(const CInv& inv)\n+    {\n+        LOCK(cs_inventory);\n+        if (inv.type == MSG_TX) {\n+            if (!filterInventoryKnown.contains(inv.hash)) {\n+                setInventoryTxToSend.insert(inv.hash);\n+            }\n+        } else if (inv.type == MSG_BLOCK) {\n+            vInventoryBlockToSend.push_back(inv.hash);\n+        }\n+    }\n \n-    std::thread threadDNSAddressSeed;\n-    std::thread threadSocketHandler;\n-    std::thread threadOpenAddedConnections;\n-    std::thread threadOpenConnections;\n-    std::thread threadMessageHandler;\n+    void PushBlockHash(const uint256 &hash)\n+    {\n+        LOCK(cs_inventory);\n+        vBlockHashesToAnnounce.push_back(hash);\n+    }\n \n-    /** flag for deciding to connect to an extra outbound peer,\n-     *  in excess of nMaxOutbound\n-     *  This takes the place of a feeler connection */\n-    std::atomic_bool m_try_another_outbound_peer;\n+    void AskFor(const CInv& inv);\n \n-    friend struct CConnmanTest;\n-};\n-extern std::unique_ptr<CConnman> g_connman;\n-void Discover();\n-void StartMapPort();\n-void InterruptMapPort();\n-void StopMapPort();\n-unsigned short GetListenPort();\n-bool BindListenPort(const CService &bindAddr, std::string& strError, bool fWhitelisted = false);\n+    void CloseSocketDisconnect();\n \n-struct CombinerAll\n-{\n-    typedef bool result_type;\n+    void copyStats(CNodeStats &stats);\n \n-    template<typename I>\n-    bool operator()(I first, I last) const\n+    ServiceFlags GetLocalServices() const\n     {\n-        while (first != last) {\n-            if (!(*first)) return false;\n-            ++first;\n-        }\n-        return true;\n+        return nLocalServices;\n     }\n-};\n \n-/**\n- * Interface for message handling\n- */\n-class NetEventsInterface\n-{\n-public:\n-    virtual bool ProcessMessages(CNode* pnode, std::atomic<bool>& interrupt) = 0;\n-    virtual bool SendMessages(CNode* pnode, std::atomic<bool>& interrupt) = 0;\n-    virtual void InitializeNode(CNode* pnode) = 0;\n-    virtual void FinalizeNode(NodeId id, bool& update_connection_time) = 0;\n-\n-protected:\n-    /**\n-     * Protected destructor so that instances can only be deleted by derived classes.\n-     * If that restriction is no longer desired, this should be made public and virtual.\n-     */\n-    ~NetEventsInterface() = default;\n+    std::string GetAddrName() const;\n+    //! Sets the addrName only if it was not previously set\n+    void MaybeSetAddrName(const std::string& addrNameIn);\n };\n \n-enum\n+class NetEventsInterface;\n+class CConnman\n {\n-    LOCAL_NONE,   // unknown\n-    LOCAL_IF,     // address a local interface listens on\n-    LOCAL_BIND,   // address explicit bound to\n-    LOCAL_UPNP,   // address reported by UPnP\n-    LOCAL_MANUAL, // address explicitly specified (-externalip=)\n-\n-    LOCAL_MAX\n-};\n+public:\n \n-bool IsPeerAddrLocalGood(CNode *pnode);\n-void AdvertiseLocal(CNode *pnode);\n-void SetLimited(enum Network net, bool fLimited = true);\n-bool IsLimited(enum Network net);\n-bool IsLimited(const CNetAddr& addr);\n-bool AddLocal(const CService& addr, int nScore = LOCAL_NONE);\n-bool AddLocal(const CNetAddr& addr, int nScore = LOCAL_NONE);\n-bool RemoveLocal(const CService& addr);\n-bool SeenLocal(const CService& addr);\n-bool IsLocal(const CService& addr);\n-bool GetLocal(CService &addr, const CNetAddr *paddrPeer = nullptr);\n-bool IsReachable(enum Network net);\n-bool IsReachable(const CNetAddr &addr);\n-CAddress GetLocalAddress(const CNetAddr *paddrPeer, ServiceFlags nLocalServices);\n+    enum NumConnections {\n+        CONNECTIONS_NONE = 0,\n+        CONNECTIONS_IN = (1U << 0),\n+        CONNECTIONS_OUT = (1U << 1),\n+        CONNECTIONS_ALL = (CONNECTIONS_IN | CONNECTIONS_OUT),\n+    };\n \n+    struct Options\n+    {\n+        ServiceFlags nLocalServices = NODE_NONE;\n+        int nMaxConnections = 0;\n+        int nMaxOutbound = 0;\n+        int nMaxAddnode = 0;\n+        int nMaxFeeler = 0;\n+        int nBestHeight = 0;\n+        CClientUIInterface* uiInterface = nullptr;\n+        NetEventsInterface* m_msgproc = nullptr;\n+        unsigned int nSendBufferMaxSize = 0;\n+        unsigned int nReceiveFloodSize = 0;\n+        uint64_t nMaxOutboundTimeframe = 0;\n+        uint64_t nMaxOutboundLimit = 0;\n+        std::vector<std::string> vSeedNodes;\n+        std::vector<CSubNet> vWhitelistedRange;\n+        std::vector<CService> vBinds, vWhiteBinds;\n+        bool m_use_addrman_outgoing = true;\n+        std::vector<std::string> m_specified_outgoing;\n+        std::vector<std::string> m_added_nodes;\n+    };\n \n-extern bool fDiscover;\n-extern bool fListen;\n-extern bool fRelayTxes;\n+    void Init(const Options& connOptions) {\n+        nLocalServices = connOptions.nLocalServices;\n+        nMaxConnections = connOptions.nMaxConnections;\n+        nMaxOutbound = std::min(connOptions.nMaxOutbound, connOptions.nMaxConnections);\n+        nMaxAddnode = connOptions.nMaxAddnode;\n+        nMaxFeeler = connOptions.nMaxFeeler;\n+        nBestHeight = connOptions.nBestHeight;\n+        clientInterface = connOptions.uiInterface;\n+        m_msgproc = connOptions.m_msgproc;\n+        nSendBufferMaxSize = connOptions.nSendBufferMaxSize;\n+        nReceiveFloodSize = connOptions.nReceiveFloodSize;\n+        {\n+            LOCK(cs_totalBytesSent);\n+            nMaxOutboundTimeframe = connOptions.nMaxOutboundTimeframe;\n+            nMaxOutboundLimit = connOptions.nMaxOutboundLimit;\n+        }\n+        vWhitelistedRange = connOptions.vWhitelistedRange;\n+        {\n+            LOCK(cs_vAddedNodes);\n+            vAddedNodes = connOptions.m_added_nodes;\n+        }\n+    }\n \n-extern limitedmap<uint256, int64_t> mapAlreadyAskedFor;\n+    CConnman(uint64_t seed0, uint64_t seed1);\n+    ~CConnman();\n+    bool Start(CScheduler& scheduler, const Options& options);\n+    void Stop();\n+    void Interrupt();\n+    bool GetNetworkActive() const { return fNetworkActive; };\n+    void SetNetworkActive(bool active);\n+    void OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound = nullptr, const char *strDest = nullptr, bool fOneShot = false, bool fFeeler = false, bool manual_connection = false);\n+    bool CheckIncomingNonce(uint64_t nonce);\n \n-/** Subversion as sent to the P2P network in `version` messages */\n-extern std::string strSubVersion;\n+    bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func);\n \n-struct LocalServiceInfo {\n-    int nScore;\n-    int nPort;\n-};\n+    void PushMessage(CNode* pnode, CSerializedNetMsg&& msg);\n \n-extern CCriticalSection cs_mapLocalHost;\n-extern std::map<CNetAddr, LocalServiceInfo> mapLocalHost;\n-typedef std::map<std::string, uint64_t> mapMsgCmdSize; //command, total bytes\n+    template<typename Callable>\n+    void ForEachNode(Callable&& func)\n+    {\n+        LOCK(cs_vNodes);\n+        for (auto&& node : vNodes) {\n+            if (NodeFullyConnected(node))\n+                func(node);\n+        }\n+    };\n \n-class CNodeStats\n-{\n-public:\n-    NodeId nodeid;\n-    ServiceFlags nServices;\n-    bool fRelayTxes;\n-    int64_t nLastSend;\n-    int64_t nLastRecv;\n-    int64_t nTimeConnected;\n-    int64_t nTimeOffset;\n-    std::string addrName;\n-    int nVersion;\n-    std::string cleanSubVer;\n-    bool fInbound;\n-    bool m_manual_connection;\n-    int nStartingHeight;\n-    uint64_t nSendBytes;\n-    mapMsgCmdSize mapSendBytesPerMsgCmd;\n-    uint64_t nRecvBytes;\n-    mapMsgCmdSize mapRecvBytesPerMsgCmd;\n-    bool fWhitelisted;\n-    double dPingTime;\n-    double dPingWait;\n-    double dMinPing;\n-    // Our address, as reported by the peer\n-    std::string addrLocal;\n-    // Address of this peer\n-    CAddress addr;\n-    // Bind address of our side of the connection\n-    CAddress addrBind;\n-};\n+    template<typename Callable>\n+    void ForEachNode(Callable&& func) const\n+    {\n+        LOCK(cs_vNodes);\n+        for (auto&& node : vNodes) {\n+            if (NodeFullyConnected(node))\n+                func(node);\n+        }\n+    };\n \n+    template<typename Callable, typename CallableAfter>\n+    void ForEachNodeThen(Callable&& pre, CallableAfter&& post)\n+    {\n+        LOCK(cs_vNodes);\n+        for (auto&& node : vNodes) {\n+            if (NodeFullyConnected(node))\n+                pre(node);\n+        }\n+        post();\n+    };\n \n+    template<typename Callable, typename CallableAfter>\n+    void ForEachNodeThen(Callable&& pre, CallableAfter&& post) const\n+    {\n+        LOCK(cs_vNodes);\n+        for (auto&& node : vNodes) {\n+            if (NodeFullyConnected(node))\n+                pre(node);\n+        }\n+        post();\n+    };\n \n+    // Addrman functions\n+    size_t GetAddressCount() const;\n+    void SetServices(const CService &addr, ServiceFlags nServices);\n+    void MarkAddressGood(const CAddress& addr);\n+    void AddNewAddresses(const std::vector<CAddress>& vAddr, const CAddress& addrFrom, int64_t nTimePenalty = 0);\n+    std::vector<CAddress> GetAddresses();\n \n-class CNetMessage {\n-private:\n-    mutable CHash256 hasher;\n-    mutable uint256 data_hash;\n-public:\n-    bool in_data;                   // parsing header (false) or data (true)\n+    // Denial-of-service detection/prevention\n+    // The idea is to detect peers that are behaving\n+    // badly and disconnect/ban them, but do it in a\n+    // one-coding-mistake-won't-shatter-the-entire-network\n+    // way.\n+    // IMPORTANT:  There should be nothing I can give a\n+    // node that it will forward on that will make that\n+    // node's peers drop it. If there is, an attacker\n+    // can isolate a node and/or try to split the network.\n+    // Dropping a node for sending stuff that is invalid\n+    // now but might be valid in a later version is also\n+    // dangerous, because it can cause a network split\n+    // between nodes running old code and nodes running\n+    // new code.\n+    void Ban(const CNetAddr& netAddr, const BanReason& reason, int64_t bantimeoffset = 0, bool sinceUnixEpoch = false);\n+    void Ban(const CSubNet& subNet, const BanReason& reason, int64_t bantimeoffset = 0, bool sinceUnixEpoch = false);\n+    void ClearBanned(); // needed for unit testing\n+    bool IsBanned(CNetAddr ip);\n+    bool IsBanned(CSubNet subnet);\n+    bool Unban(const CNetAddr &ip);\n+    bool Unban(const CSubNet &ip);\n+    void GetBanned(banmap_t &banmap);\n+    void SetBanned(const banmap_t &banmap);\n \n-    CDataStream hdrbuf;             // partially received header\n-    CMessageHeader hdr;             // complete header\n-    unsigned int nHdrPos;\n+    // This allows temporarily exceeding nMaxOutbound, with the goal of finding\n+    // a peer that is better than all our current peers.\n+    void SetTryNewOutboundPeer(bool flag);\n+    bool GetTryNewOutboundPeer();\n \n-    CDataStream vRecv;              // received message data\n-    unsigned int nDataPos;\n+    // Return the number of outbound peers we have in excess of our target (eg,\n+    // if we previously called SetTryNewOutboundPeer(true), and have since set\n+    // to false, we may have extra peers that we wish to disconnect). This may\n+    // return a value less than (num_outbound_connections - num_outbound_slots)\n+    // in cases where some outbound connections are not yet fully connected, or\n+    // not yet fully disconnected.\n+    int GetExtraOutboundCount();\n \n-    int64_t nTime;                  // time (in microseconds) of message receipt.\n+    bool AddNode(const std::string& node);\n+    bool RemoveAddedNode(const std::string& node);\n+    std::vector<AddedNodeInfo> GetAddedNodeInfo();\n \n-    CNetMessage(const CMessageHeader::MessageStartChars& pchMessageStartIn, int nTypeIn, int nVersionIn) : hdrbuf(nTypeIn, nVersionIn), hdr(pchMessageStartIn), vRecv(nTypeIn, nVersionIn) {\n-        hdrbuf.resize(24);\n-        in_data = false;\n-        nHdrPos = 0;\n-        nDataPos = 0;\n-        nTime = 0;\n-    }\n+    size_t GetNodeCount(NumConnections num);\n+    void GetNodeStats(std::vector<CNodeStats>& vstats);\n+    bool DisconnectNode(const std::string& node);\n+    bool DisconnectNode(NodeId id);\n \n-    bool complete() const\n-    {\n-        if (!in_data)\n-            return false;\n-        return (hdr.nMessageSize == nDataPos);\n-    }\n+    ServiceFlags GetLocalServices() const;\n \n-    const uint256& GetMessageHash() const;\n+    //!set the max outbound target in bytes\n+    void SetMaxOutboundTarget(uint64_t limit);\n+    uint64_t GetMaxOutboundTarget();\n \n-    void SetVersion(int nVersionIn)\n-    {\n-        hdrbuf.SetVersion(nVersionIn);\n-        vRecv.SetVersion(nVersionIn);\n-    }\n+    //!set the timeframe for the max outbound target\n+    void SetMaxOutboundTimeframe(uint64_t timeframe);\n+    uint64_t GetMaxOutboundTimeframe();\n \n-    int readHeader(const char *pch, unsigned int nBytes);\n-    int readData(const char *pch, unsigned int nBytes);\n-};\n+    //!check if the outbound target is reached\n+    // if param historicalBlockServingLimit is set true, the function will\n+    // response true if the limit for serving historical blocks has been reached\n+    bool OutboundTargetReached(bool historicalBlockServingLimit);\n \n+    //!response the bytes left in the current max outbound cycle\n+    // in case of no limit, it will always response 0\n+    uint64_t GetOutboundTargetBytesLeft();\n \n-/** Information about a peer */\n-class CNode\n-{\n-    friend class CConnman;\n-public:\n-    // socket\n-    std::atomic<ServiceFlags> nServices;\n-    SOCKET hSocket;\n-    size_t nSendSize; // total size of all vSendMsg entries\n-    size_t nSendOffset; // offset inside the first vSendMsg already sent\n-    uint64_t nSendBytes;\n-    std::deque<std::vector<unsigned char>> vSendMsg;\n-    CCriticalSection cs_vSend;\n-    CCriticalSection cs_hSocket;\n-    CCriticalSection cs_vRecv;\n+    //!response the time in second left in the current max outbound cycle\n+    // in case of no limit, it will always response 0\n+    uint64_t GetMaxOutboundTimeLeftInCycle();\n \n-    CCriticalSection cs_vProcessMsg;\n-    std::list<CNetMessage> vProcessMsg;\n-    size_t nProcessQueueSize;\n+    uint64_t GetTotalBytesRecv();\n+    uint64_t GetTotalBytesSent();\n \n-    CCriticalSection cs_sendProcessing;\n+    void SetBestHeight(int height);\n+    int GetBestHeight() const;\n \n-    std::deque<CInv> vRecvGetData;\n-    uint64_t nRecvBytes;\n-    std::atomic<int> nRecvVersion;\n+    /** Get a unique deterministic randomizer. */\n+    CSipHasher GetDeterministicRandomizer(uint64_t id) const;\n \n-    std::atomic<int64_t> nLastSend;\n-    std::atomic<int64_t> nLastRecv;\n-    const int64_t nTimeConnected;\n-    std::atomic<int64_t> nTimeOffset;\n-    // Address of this peer\n-    const CAddress addr;\n-    // Bind address of our side of the connection\n-    const CAddress addrBind;\n-    std::atomic<int> nVersion;\n-    // strSubVer is whatever byte array we read from the wire. However, this field is intended\n-    // to be printed out, displayed to humans in various forms and so on. So we sanitize it and\n-    // store the sanitized version in cleanSubVer. The original should be used when dealing with\n-    // the network or wire types and the cleaned string used when displayed or logged.\n-    std::string strSubVer, cleanSubVer;\n-    CCriticalSection cs_SubVer; // used for both cleanSubVer and strSubVer\n-    bool fWhitelisted; // This peer can bypass DoS banning.\n-    bool fFeeler; // If true this node is being used as a short lived feeler.\n-    bool fOneShot;\n-    bool m_manual_connection;\n-    bool fClient;\n-    bool m_limited_node; //after BIP159\n-    const bool fInbound;\n-    std::atomic_bool fSuccessfullyConnected;\n-    std::atomic_bool fDisconnect;\n-    // We use fRelayTxes for two purposes -\n-    // a) it allows us to not relay tx invs before receiving the peer's version message\n-    // b) the peer may tell us in its version message that we should not relay tx invs\n-    //    unless it loads a bloom filter.\n-    bool fRelayTxes; //protected by cs_filter\n-    bool fSentAddr;\n-    CSemaphoreGrant grantOutbound;\n-    CCriticalSection cs_filter;\n-    std::unique_ptr<CBloomFilter> pfilter;\n-    std::atomic<int> nRefCount;\n+    unsigned int GetReceiveFloodSize() const;\n \n-    const uint64_t nKeyedNetGroup;\n-    std::atomic_bool fPauseRecv;\n-    std::atomic_bool fPauseSend;\n-protected:\n+    void WakeMessageHandler();\n+private:\n+    struct ListenSocket {\n+        SOCKET socket;\n+        bool whitelisted;\n \n-    mapMsgCmdSize mapSendBytesPerMsgCmd;\n-    mapMsgCmdSize mapRecvBytesPerMsgCmd;\n+        ListenSocket(SOCKET socket_, bool whitelisted_) : socket(socket_), whitelisted(whitelisted_) {}\n+    };\n \n-public:\n-    uint256 hashContinue;\n-    std::atomic<int> nStartingHeight;\n+    bool BindListenPort(const CService &bindAddr, std::string& strError, bool fWhitelisted = false);\n+    bool Bind(const CService &addr, unsigned int flags);\n+    bool InitBinds(const std::vector<CService>& binds, const std::vector<CService>& whiteBinds);\n+    void ThreadOpenAddedConnections();\n+    void AddOneShot(const std::string& strDest);\n+    void ProcessOneShot();\n+    void ThreadOpenConnections(std::vector<std::string> connect);\n+    void ThreadMessageHandler();\n+    void AcceptConnection(const ListenSocket& hListenSocket);\n+    void ThreadSocketHandler();\n+    void ThreadDNSAddressSeed();\n \n-    // flood relay\n-    std::vector<CAddress> vAddrToSend;\n-    CRollingBloomFilter addrKnown;\n-    bool fGetAddr;\n-    std::set<uint256> setKnown;\n-    int64_t nNextAddrSend;\n-    int64_t nNextLocalAddrSend;\n+    uint64_t CalculateKeyedNetGroup(const CAddress& ad) const;\n \n-    // inventory based relay\n-    CRollingBloomFilter filterInventoryKnown;\n-    // Set of transaction ids we still have to announce.\n-    // They are sorted by the mempool before relay, so the order is not important.\n-    std::set<uint256> setInventoryTxToSend;\n-    // List of block ids we still have announce.\n-    // There is no final sorting before sending, as they are always sent immediately\n-    // and in the order requested.\n-    std::vector<uint256> vInventoryBlockToSend;\n-    CCriticalSection cs_inventory;\n-    std::set<uint256> setAskFor;\n-    std::multimap<int64_t, CInv> mapAskFor;\n-    int64_t nNextInvSend;\n-    // Used for headers announcements - unfiltered blocks to relay\n-    // Also protected by cs_inventory\n-    std::vector<uint256> vBlockHashesToAnnounce;\n-    // Used for BIP35 mempool sending, also protected by cs_inventory\n-    bool fSendMempool;\n+    CNode* FindNode(const CNetAddr& ip);\n+    CNode* FindNode(const CSubNet& subNet);\n+    CNode* FindNode(const std::string& addrName);\n+    CNode* FindNode(const CService& addr);\n \n-    // Last time a \"MEMPOOL\" request was serviced.\n-    std::atomic<int64_t> timeLastMempoolReq;\n+    bool AttemptToEvictConnection();\n+    CNode* ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure, bool manual_connection);\n+    bool IsWhitelistedRange(const CNetAddr &addr);\n \n-    // Block and TXN accept times\n-    std::atomic<int64_t> nLastBlockTime;\n-    std::atomic<int64_t> nLastTXTime;\n+    void DeleteNode(CNode* pnode);\n+\n+    NodeId GetNewNodeId();\n+\n+    size_t SocketSendData(CNode *pnode) const;\n+    //!check is the banlist has unwritten changes\n+    bool BannedSetIsDirty();\n+    //!set the \"dirty\" flag for the banlist\n+    void SetBannedSetDirty(bool dirty=true);\n+    //!clean unused entries (if bantime has expired)\n+    void SweepBanned();\n+    void DumpAddresses();\n+    void DumpData();\n+    void DumpBanlist();\n \n-    // Ping time measurement:\n-    // The pong reply we're expecting, or 0 if no pong expected.\n-    std::atomic<uint64_t> nPingNonceSent;\n-    // Time (in usec) the last ping was sent, or 0 if no ping was ever sent.\n-    std::atomic<int64_t> nPingUsecStart;\n-    // Last measured round-trip time.\n-    std::atomic<int64_t> nPingUsecTime;\n-    // Best measured round-trip time.\n-    std::atomic<int64_t> nMinPingUsecTime;\n-    // Whether a ping is requested.\n-    std::atomic<bool> fPingQueued;\n-    // Minimum fee rate with which to filter inv's to this node\n-    CAmount minFeeFilter;\n-    CCriticalSection cs_feeFilter;\n-    CAmount lastSentFeeFilter;\n-    int64_t nextSendTimeFeeFilter;\n+    // Network stats\n+    void RecordBytesRecv(uint64_t bytes);\n+    void RecordBytesSent(uint64_t bytes);\n \n-    CNode(NodeId id, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn, SOCKET hSocketIn, const CAddress &addrIn, uint64_t nKeyedNetGroupIn, uint64_t nLocalHostNonceIn, const CAddress &addrBindIn, const std::string &addrNameIn = \"\", bool fInboundIn = false);\n-    ~CNode();\n-    CNode(const CNode&) = delete;\n-    CNode& operator=(const CNode&) = delete;\n+    // Whether the node should be passed out in ForEach* callbacks\n+    static bool NodeFullyConnected(const CNode* pnode);\n \n-private:\n-    const NodeId id;\n-    const uint64_t nLocalHostNonce;\n-    // Services offered to this peer\n-    const ServiceFlags nLocalServices;\n-    const int nMyStartingHeight;\n-    int nSendVersion;\n-    std::list<CNetMessage> vRecvMsg;  // Used only by SocketHandler thread\n+    // Network usage totals\n+    CCriticalSection cs_totalBytesRecv;\n+    CCriticalSection cs_totalBytesSent;\n+    uint64_t nTotalBytesRecv GUARDED_BY(cs_totalBytesRecv);\n+    uint64_t nTotalBytesSent GUARDED_BY(cs_totalBytesSent);\n \n-    mutable CCriticalSection cs_addrName;\n-    std::string addrName;\n+    // outbound limit & stats\n+    uint64_t nMaxOutboundTotalBytesSentInCycle GUARDED_BY(cs_totalBytesSent);\n+    uint64_t nMaxOutboundCycleStartTime GUARDED_BY(cs_totalBytesSent);\n+    uint64_t nMaxOutboundLimit GUARDED_BY(cs_totalBytesSent);\n+    uint64_t nMaxOutboundTimeframe GUARDED_BY(cs_totalBytesSent);\n \n-    // Our address, as reported by the peer\n-    CService addrLocal;\n-    mutable CCriticalSection cs_addrLocal;\n-public:\n+    // Whitelisted ranges. Any node connecting from these is automatically\n+    // whitelisted (as well as those connecting to whitelisted binds).\n+    std::vector<CSubNet> vWhitelistedRange;\n \n-    NodeId GetId() const {\n-        return id;\n-    }\n+    unsigned int nSendBufferMaxSize;\n+    unsigned int nReceiveFloodSize;\n \n-    uint64_t GetLocalNonce() const {\n-        return nLocalHostNonce;\n-    }\n+    std::vector<ListenSocket> vhListenSocket;\n+    std::atomic<bool> fNetworkActive;\n+    banmap_t setBanned;\n+    CCriticalSection cs_setBanned;\n+    bool setBannedIsDirty;\n+    bool fAddressesInitialized;\n+    CAddrMan addrman;\n+    std::deque<std::string> vOneShots;\n+    CCriticalSection cs_vOneShots;\n+    std::vector<std::string> vAddedNodes GUARDED_BY(cs_vAddedNodes);\n+    CCriticalSection cs_vAddedNodes;\n+    std::vector<CNode*> vNodes;\n+    std::list<CNode*> vNodesDisconnected;\n+    mutable CCriticalSection cs_vNodes;\n+    std::atomic<NodeId> nLastNodeId;\n \n-    int GetMyStartingHeight() const {\n-        return nMyStartingHeight;\n-    }\n+    /** Services this instance offers */\n+    ServiceFlags nLocalServices;\n \n-    int GetRefCount() const\n-    {\n-        assert(nRefCount >= 0);\n-        return nRefCount;\n-    }\n+    std::unique_ptr<CSemaphore> semOutbound;\n+    std::unique_ptr<CSemaphore> semAddnode;\n+    int nMaxConnections;\n+    int nMaxOutbound;\n+    int nMaxAddnode;\n+    int nMaxFeeler;\n+    std::atomic<int> nBestHeight;\n+    CClientUIInterface* clientInterface;\n+    NetEventsInterface* m_msgproc;\n \n-    bool ReceiveMsgBytes(const char *pch, unsigned int nBytes, bool& complete);\n+    /** SipHasher seeds for deterministic randomness */\n+    const uint64_t nSeed0, nSeed1;\n \n-    void SetRecvVersion(int nVersionIn)\n-    {\n-        nRecvVersion = nVersionIn;\n-    }\n-    int GetRecvVersion() const\n-    {\n-        return nRecvVersion;\n-    }\n-    void SetSendVersion(int nVersionIn);\n-    int GetSendVersion() const;\n+    /** flag for waking the message processor. */\n+    bool fMsgProcWake;\n \n-    CService GetAddrLocal() const;\n-    //! May not be called more than once\n-    void SetAddrLocal(const CService& addrLocalIn);\n+    std::condition_variable condMsgProc;\n+    std::mutex mutexMsgProc;\n+    std::atomic<bool> flagInterruptMsgProc;\n \n-    CNode* AddRef()\n-    {\n-        nRefCount++;\n-        return this;\n-    }\n+    CThreadInterrupt interruptNet;\n \n-    void Release()\n-    {\n-        nRefCount--;\n-    }\n+    std::thread threadDNSAddressSeed;\n+    std::thread threadSocketHandler;\n+    std::thread threadOpenAddedConnections;\n+    std::thread threadOpenConnections;\n+    std::thread threadMessageHandler;\n \n+    /** flag for deciding to connect to an extra outbound peer,\n+     *  in excess of nMaxOutbound\n+     *  This takes the place of a feeler connection */\n+    std::atomic_bool m_try_another_outbound_peer;\n \n+    friend struct CConnmanTest;\n+};\n+extern std::unique_ptr<CConnman> g_connman;\n+void Discover();\n+void StartMapPort();\n+void InterruptMapPort();\n+void StopMapPort();\n+unsigned short GetListenPort();\n+bool BindListenPort(const CService &bindAddr, std::string& strError, bool fWhitelisted = false);\n \n-    void AddAddressKnown(const CAddress& _addr)\n-    {\n-        addrKnown.insert(_addr.GetKey());\n-    }\n+struct CombinerAll\n+{\n+    typedef bool result_type;\n \n-    void PushAddress(const CAddress& _addr, FastRandomContext &insecure_rand)\n+    template<typename I>\n+    bool operator()(I first, I last) const\n     {\n-        // Known checking here is only to save space from duplicates.\n-        // SendMessages will filter it again for knowns that were added\n-        // after addresses were pushed.\n-        if (_addr.IsValid() && !addrKnown.contains(_addr.GetKey())) {\n-            if (vAddrToSend.size() >= MAX_ADDR_TO_SEND) {\n-                vAddrToSend[insecure_rand.randrange(vAddrToSend.size())] = _addr;\n-            } else {\n-                vAddrToSend.push_back(_addr);\n-            }\n+        while (first != last) {\n+            if (!(*first)) return false;\n+            ++first;\n         }\n+        return true;\n     }\n+};\n \n+/**\n+ * Interface for message handling\n+ */\n+class NetEventsInterface\n+{\n+public:\n+    virtual bool ProcessMessages(CNode* pnode, std::atomic<bool>& interrupt) = 0;\n+    virtual bool SendMessages(CNode* pnode, std::atomic<bool>& interrupt) = 0;\n+    virtual void InitializeNode(CNode* pnode) = 0;\n+    virtual void FinalizeNode(NodeId id, bool& update_connection_time) = 0;\n \n-    void AddInventoryKnown(const CInv& inv)\n-    {\n-        {\n-            LOCK(cs_inventory);\n-            filterInventoryKnown.insert(inv.hash);\n-        }\n-    }\n+protected:\n+    /**\n+     * Protected destructor so that instances can only be deleted by derived classes.\n+     * If that restriction is no longer desired, this should be made public and virtual.\n+     */\n+    ~NetEventsInterface() = default;\n+};\n \n-    void PushInventory(const CInv& inv)\n-    {\n-        LOCK(cs_inventory);\n-        if (inv.type == MSG_TX) {\n-            if (!filterInventoryKnown.contains(inv.hash)) {\n-                setInventoryTxToSend.insert(inv.hash);\n-            }\n-        } else if (inv.type == MSG_BLOCK) {\n-            vInventoryBlockToSend.push_back(inv.hash);\n-        }\n-    }\n+enum\n+{\n+    LOCAL_NONE,   // unknown\n+    LOCAL_IF,     // address a local interface listens on\n+    LOCAL_BIND,   // address explicit bound to\n+    LOCAL_UPNP,   // address reported by UPnP\n+    LOCAL_MANUAL, // address explicitly specified (-externalip=)\n \n-    void PushBlockHash(const uint256 &hash)\n-    {\n-        LOCK(cs_inventory);\n-        vBlockHashesToAnnounce.push_back(hash);\n-    }\n+    LOCAL_MAX\n+};\n \n-    void AskFor(const CInv& inv);\n+bool IsPeerAddrLocalGood(CNode *pnode);\n+void AdvertiseLocal(CNode *pnode);\n+void SetLimited(enum Network net, bool fLimited = true);\n+bool IsLimited(enum Network net);\n+bool IsLimited(const CNetAddr& addr);\n+bool AddLocal(const CService& addr, int nScore = LOCAL_NONE);\n+bool AddLocal(const CNetAddr& addr, int nScore = LOCAL_NONE);\n+bool RemoveLocal(const CService& addr);\n+bool SeenLocal(const CService& addr);\n+bool IsLocal(const CService& addr);\n+bool GetLocal(CService &addr, const CNetAddr *paddrPeer = nullptr);\n+bool IsReachable(enum Network net);\n+bool IsReachable(const CNetAddr &addr);\n+CAddress GetLocalAddress(const CNetAddr *paddrPeer, ServiceFlags nLocalServices);\n \n-    void CloseSocketDisconnect();\n \n-    void copyStats(CNodeStats &stats);\n+extern bool fDiscover;\n+extern bool fListen;\n+extern bool fRelayTxes;\n \n-    ServiceFlags GetLocalServices() const\n-    {\n-        return nLocalServices;\n-    }\n+extern limitedmap<uint256, int64_t> mapAlreadyAskedFor;\n \n-    std::string GetAddrName() const;\n-    //! Sets the addrName only if it was not previously set\n-    void MaybeSetAddrName(const std::string& addrNameIn);\n-};\n+/** Subversion as sent to the P2P network in `version` messages */\n+extern std::string strSubVersion;\n \n \n "
      }
    ]
  },
  {
    "sha": "118948996d40c9bd872cf44342a9e72b70c21055",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMTg5NDg5OTZkNDBjOWJkODcyY2Y0NDM0MmE5ZTcyYjcwYzIxMDU1",
    "commit": {
      "author": {
        "name": "Ben Woosley",
        "email": "ben.woosley@gmail.com",
        "date": "2018-05-15T19:36:12Z"
      },
      "committer": {
        "name": "Ben Woosley",
        "email": "ben.woosley@gmail.com",
        "date": "2018-05-24T22:01:47Z"
      },
      "message": "[moveonly] Move CConnman::NodeFullyConnected to CNode::FullyConnected\n\nThe CConnman template methods ForEachNode and ForEachNodeThen use\nNodeFullyConnected, so when defined in net.cpp, outside callers were lacking\nthe implementation necessary for the template methods.\n\nSee https://travis-ci.org/bitcoin/bitcoin/jobs/379011082 for an example\nof how this failure looked in practice.\n\nThis existed on CConnman before because\nCConnman could not rely on CNode methods for its template methods. Now that the\nCNode declaration is first, this is the more natural place to represent this\ncode.",
      "tree": {
        "sha": "57947f5be9b88e947f21d705a5953114e8c59bca",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/57947f5be9b88e947f21d705a5953114e8c59bca"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/118948996d40c9bd872cf44342a9e72b70c21055",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE+XLHXoy4Dim7e8hvTYykuhgECQYFAlsHNskACgkQTYykuhgE\nCQa1dA/+O2CbqriElBQoCW8zTEy2aN+BEElY0MwxfHnk6x2O3HoL4U01c5PzZKZE\nXsGsTuw7X2nlC6K91VGtDiItUPcZO7kYGT5I/PkX1zPvMVCLNHwEzhN3gr2HbbpD\nHFFp5ODT/vw+wQnIKKiCkXVZSjTy3CVhilFceiZGxDNGUd04ekhp4QIoAI7fl8qA\nA1z9+d5q69auL8RLVdEV6VocpfxrImhxJbLiEbxNqMF3uXbroC90mR5SduZA0iEC\nwtnldQSzB2dAky+1Qn++guOfuY+U8PVrnkOgfMN+NR59iGZuf3T+H6PZvvU67162\n3N7j8Wr4q7HLQM9IcyjDbOu2NrZ8TRJDBhuahcENP0ca5V/x5AZAZ8LbdU/lQyrZ\n0yxQCX9ym7xDVVjfJSvKIGrWkPxIhQFYObj4Ed8wJd9xgJbLibxLf27ENTYCheFn\ndWTbQvPJeZFdOT/FzRYeAV5nkOTjMZEqZRKHKeVq1ZVBj+Atgq5JgD1SHHQbzM/7\nNieQ84tPLCvpA7/Za5ZdyCx8xxpZxebzE7yjgfv1NFHW0U6j/qjrvarNeVGBz/jO\nsMQymsjnWLx8+n+uEjm0lwqEBXDYC9GCo2cq6MJm1RT3bvOhKpxz1zEqrszfhAMx\nqsfZAg/sboOjVm3HDD8kUfw9VPioVRMo1+cSyYfBiRfPfLDjuA8=\n=6vJU\n-----END PGP SIGNATURE-----",
        "payload": "tree 57947f5be9b88e947f21d705a5953114e8c59bca\nparent b9ed349f42ee7a8b7f3a6013dffbcc63becf5742\nauthor Ben Woosley <ben.woosley@gmail.com> 1526412972 -0700\ncommitter Ben Woosley <ben.woosley@gmail.com> 1527199307 -0700\n\n[moveonly] Move CConnman::NodeFullyConnected to CNode::FullyConnected\n\nThe CConnman template methods ForEachNode and ForEachNodeThen use\nNodeFullyConnected, so when defined in net.cpp, outside callers were lacking\nthe implementation necessary for the template methods.\n\nSee https://travis-ci.org/bitcoin/bitcoin/jobs/379011082 for an example\nof how this failure looked in practice.\n\nThis existed on CConnman before because\nCConnman could not rely on CNode methods for its template methods. Now that the\nCNode declaration is first, this is the more natural place to represent this\ncode.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/118948996d40c9bd872cf44342a9e72b70c21055",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/118948996d40c9bd872cf44342a9e72b70c21055",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/118948996d40c9bd872cf44342a9e72b70c21055/comments",
    "author": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "Empact",
      "id": 5470,
      "node_id": "MDQ6VXNlcjU0NzA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Empact",
      "html_url": "https://github.com/Empact",
      "followers_url": "https://api.github.com/users/Empact/followers",
      "following_url": "https://api.github.com/users/Empact/following{/other_user}",
      "gists_url": "https://api.github.com/users/Empact/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Empact/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
      "organizations_url": "https://api.github.com/users/Empact/orgs",
      "repos_url": "https://api.github.com/users/Empact/repos",
      "events_url": "https://api.github.com/users/Empact/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Empact/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b9ed349f42ee7a8b7f3a6013dffbcc63becf5742",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b9ed349f42ee7a8b7f3a6013dffbcc63becf5742",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b9ed349f42ee7a8b7f3a6013dffbcc63becf5742"
      }
    ],
    "stats": {
      "total": 26,
      "additions": 12,
      "deletions": 14
    },
    "files": [
      {
        "sha": "17406185e43204bda1a3fcd40840714eef93c8b7",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 6,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/118948996d40c9bd872cf44342a9e72b70c21055/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/118948996d40c9bd872cf44342a9e72b70c21055/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=118948996d40c9bd872cf44342a9e72b70c21055",
        "patch": "@@ -2809,11 +2809,6 @@ void CNode::AskFor(const CInv& inv)\n     mapAskFor.insert(std::make_pair(nRequestTime, inv));\n }\n \n-bool CConnman::NodeFullyConnected(const CNode* pnode)\n-{\n-    return pnode && pnode->fSuccessfullyConnected && !pnode->fDisconnect;\n-}\n-\n void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n {\n     size_t nMessageSize = msg.data.size();\n@@ -2861,7 +2856,7 @@ bool CConnman::ForNode(NodeId id, std::function<bool(CNode* pnode)> func)\n             break;\n         }\n     }\n-    return found != nullptr && NodeFullyConnected(found) && func(found);\n+    return found != nullptr && found->FullyConnected() && func(found);\n }\n \n int64_t PoissonNextSend(int64_t nNow, int average_interval_seconds) {"
      },
      {
        "sha": "2d82bcc6bd338b8efaa8437c61f38599b7cf6416",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 10,
        "deletions": 7,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/118948996d40c9bd872cf44342a9e72b70c21055/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/118948996d40c9bd872cf44342a9e72b70c21055/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=118948996d40c9bd872cf44342a9e72b70c21055",
        "patch": "@@ -322,6 +322,12 @@ class CNode\n     CNode(const CNode&) = delete;\n     CNode& operator=(const CNode&) = delete;\n \n+    // Whether the node should be passed out in ForEach* callbacks\n+    bool FullyConnected() const\n+    {\n+        return fSuccessfullyConnected && !fDisconnect;\n+    }\n+\n private:\n     const NodeId id;\n     const uint64_t nLocalHostNonce;\n@@ -525,7 +531,7 @@ class CConnman\n     {\n         LOCK(cs_vNodes);\n         for (auto&& node : vNodes) {\n-            if (NodeFullyConnected(node))\n+            if (node != nullptr && node->FullyConnected())\n                 func(node);\n         }\n     };\n@@ -535,7 +541,7 @@ class CConnman\n     {\n         LOCK(cs_vNodes);\n         for (auto&& node : vNodes) {\n-            if (NodeFullyConnected(node))\n+            if (node != nullptr && node->FullyConnected())\n                 func(node);\n         }\n     };\n@@ -545,7 +551,7 @@ class CConnman\n     {\n         LOCK(cs_vNodes);\n         for (auto&& node : vNodes) {\n-            if (NodeFullyConnected(node))\n+            if (node != nullptr && node->FullyConnected())\n                 pre(node);\n         }\n         post();\n@@ -556,7 +562,7 @@ class CConnman\n     {\n         LOCK(cs_vNodes);\n         for (auto&& node : vNodes) {\n-            if (NodeFullyConnected(node))\n+            if (node != nullptr && node->FullyConnected())\n                 pre(node);\n         }\n         post();\n@@ -700,9 +706,6 @@ class CConnman\n     void RecordBytesRecv(uint64_t bytes);\n     void RecordBytesSent(uint64_t bytes);\n \n-    // Whether the node should be passed out in ForEach* callbacks\n-    static bool NodeFullyConnected(const CNode* pnode);\n-\n     // Network usage totals\n     CCriticalSection cs_totalBytesRecv;\n     CCriticalSection cs_totalBytesSent;"
      },
      {
        "sha": "1d5c37fb062c1d9be72478f4ee12310c4fc38701",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/118948996d40c9bd872cf44342a9e72b70c21055/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/118948996d40c9bd872cf44342a9e72b70c21055/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=118948996d40c9bd872cf44342a9e72b70c21055",
        "patch": "@@ -3200,7 +3200,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto, std::atomic<bool>& interruptM\n     const Consensus::Params& consensusParams = Params().GetConsensus();\n     {\n         // Don't send anything until the version handshake is complete\n-        if (!pto->fSuccessfullyConnected || pto->fDisconnect)\n+        if (!pto->FullyConnected())\n             return true;\n \n         // If we get here, the outgoing message serialization version is set and can't change."
      }
    ]
  }
]