[
  {
    "sha": "58bc86e37fda1aec270bccb3df6c20fbd2a6591c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1OGJjODZlMzdmZGExYWVjMjcwYmNjYjNkZjZjMjBmYmQyYTY1OTFj",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-08-22T20:33:21Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-09-20T23:24:25Z"
      },
      "message": "Check for canonical public keys and signatures\n\nOnly enabled inside tests for now.",
      "tree": {
        "sha": "281ed668edca7eb3d528f37ebff803e4eaac12bd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/281ed668edca7eb3d528f37ebff803e4eaac12bd"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/58bc86e37fda1aec270bccb3df6c20fbd2a6591c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/58bc86e37fda1aec270bccb3df6c20fbd2a6591c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/58bc86e37fda1aec270bccb3df6c20fbd2a6591c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/58bc86e37fda1aec270bccb3df6c20fbd2a6591c/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bfc24bd4cee1c1da944dfd1f236b07e9194f493c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bfc24bd4cee1c1da944dfd1f236b07e9194f493c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bfc24bd4cee1c1da944dfd1f236b07e9194f493c"
      }
    ],
    "stats": {
      "total": 307,
      "additions": 245,
      "deletions": 62
    },
    "files": [
      {
        "sha": "53ef0ddc4f38e06c994a32c6b317847c0eaccf6c",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/58bc86e37fda1aec270bccb3df6c20fbd2a6591c/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/58bc86e37fda1aec270bccb3df6c20fbd2a6591c/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=58bc86e37fda1aec270bccb3df6c20fbd2a6591c",
        "patch": "@@ -327,7 +327,7 @@ bool CTransaction::AreInputsStandard(const MapPrevTx& mapInputs) const\n         // beside \"push data\" in the scriptSig the\n         // IsStandard() call returns false\n         vector<vector<unsigned char> > stack;\n-        if (!EvalScript(stack, vin[i].scriptSig, *this, i, 0))\n+        if (!EvalScript(stack, vin[i].scriptSig, *this, i, false, 0))\n             return false;\n \n         if (whichType == TX_SCRIPTHASH)\n@@ -1292,11 +1292,11 @@ bool CTransaction::ConnectInputs(MapPrevTx inputs,\n             if (!(fBlock && (nBestHeight < Checkpoints::GetTotalBlocksEstimate())))\n             {\n                 // Verify signature\n-                if (!VerifySignature(txPrev, *this, i, fStrictPayToScriptHash, 0))\n+                if (!VerifySignature(txPrev, *this, i, fStrictPayToScriptHash, false, 0))\n                 {\n                     // only during transition phase for P2SH: do not invoke anti-DoS code for\n                     // potentially old clients relaying bad P2SH transactions\n-                    if (fStrictPayToScriptHash && VerifySignature(txPrev, *this, i, false, 0))\n+                    if (fStrictPayToScriptHash && VerifySignature(txPrev, *this, i, false, false, 0))\n                         return error(\"ConnectInputs() : %s P2SH VerifySignature failed\", GetHash().ToString().substr(0,10).c_str());\n \n                     return DoS(100,error(\"ConnectInputs() : %s VerifySignature failed\", GetHash().ToString().substr(0,10).c_str()));\n@@ -1350,7 +1350,7 @@ bool CTransaction::ClientConnectInputs()\n                 return false;\n \n             // Verify signature\n-            if (!VerifySignature(txPrev, *this, i, true, 0))\n+            if (!VerifySignature(txPrev, *this, i, true, false, 0))\n                 return error(\"ConnectInputs() : VerifySignature failed\");\n \n             ///// this is redundant with the mempool.mapNextTx stuff,"
      },
      {
        "sha": "7646861ffe6a0110c4269463b41e1b5b7b11375f",
        "filename": "src/rpcrawtransaction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/58bc86e37fda1aec270bccb3df6c20fbd2a6591c/src/rpcrawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/58bc86e37fda1aec270bccb3df6c20fbd2a6591c/src/rpcrawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcrawtransaction.cpp?ref=58bc86e37fda1aec270bccb3df6c20fbd2a6591c",
        "patch": "@@ -469,7 +469,7 @@ Value signrawtransaction(const Array& params, bool fHelp)\n         {\n             txin.scriptSig = CombineSignatures(prevPubKey, mergedTx, i, txin.scriptSig, txv.vin[i].scriptSig);\n         }\n-        if (!VerifyScript(txin.scriptSig, prevPubKey, mergedTx, i, true, 0))\n+        if (!VerifyScript(txin.scriptSig, prevPubKey, mergedTx, i, true, true, 0))\n             fComplete = false;\n     }\n "
      },
      {
        "sha": "7eeacaf708fa9d12d04a153a5e1828e33520f129",
        "filename": "src/script.cpp",
        "status": "modified",
        "additions": 79,
        "deletions": 13,
        "changes": 92,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/58bc86e37fda1aec270bccb3df6c20fbd2a6591c/src/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/58bc86e37fda1aec270bccb3df6c20fbd2a6591c/src/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.cpp?ref=58bc86e37fda1aec270bccb3df6c20fbd2a6591c",
        "patch": "@@ -236,7 +236,68 @@ const char* GetOpName(opcodetype opcode)\n     }\n }\n \n-bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, int nHashType)\n+bool IsCanonicalPubKey(const valtype &vchPubKey) {\n+    if (vchPubKey.size() < 33)\n+        return error(\"Non-canonical public key: too short\");\n+    if (vchPubKey[0] == 0x04) {\n+        if (vchPubKey.size() != 65)\n+            return error(\"Non-canonical public key: invalid length for uncompressed key\");\n+    } else if (vchPubKey[0] == 0x02 || vchPubKey[0] == 0x03) {\n+        if (vchPubKey.size() != 33)\n+            return error(\"Non-canonical public key: invalid length for compressed key\");\n+    } else {\n+        return error(\"Non-canonical public key: compressed nor uncompressed\");\n+    }\n+    return true;\n+}\n+\n+bool IsCanonicalSignature(const valtype &vchSig) {\n+    // See https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623\n+    // A canonical signature exists of: <30> <total len> <02> <len R> <R> <02> <len S> <S> <hashtype>\n+    // Where R and S are not negative (their first byte has its highest bit not set), and not\n+    // excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,\n+    // in which case a single 0 byte is necessary and even required).\n+    if (vchSig.size() < 9)\n+        return error(\"Non-canonical signature: too short\");\n+    if (vchSig.size() > 73)\n+        return error(\"Non-canonical signature: too long\");\n+    if (vchSig[vchSig.size() - 1] & 0x7C)\n+        return error(\"Non-canonical signature: unknown hashtype byte\");\n+    if (vchSig[0] != 0x30)\n+        return error(\"Non-canonical signature: wrong type\");\n+    if (vchSig[1] != vchSig.size()-3)\n+        return error(\"Non-canonical signature: wrong length marker\");\n+    unsigned int nLenR = vchSig[3];\n+    if (5 + nLenR >= vchSig.size())\n+        return error(\"Non-canonical signature: S length misplaced\");\n+    unsigned int nLenS = vchSig[5+nLenR];\n+    if ((unsigned long)(nLenR+nLenS+7) != vchSig.size())\n+        return error(\"Non-canonical signature: R+S length mismatch\");\n+\n+    const unsigned char *R = &vchSig[4];\n+    if (R[-2] != 0x02)\n+        return error(\"Non-canonical signature: R value type mismatch\");\n+    if (nLenR == 0)\n+        return error(\"Non-canonical signature: R length is zero\");\n+    if (R[0] & 0x80)\n+        return error(\"Non-canonical signature: R value negative\");\n+    if (nLenR > 1 && (R[0] == 0x00) && !(R[1] & 0x80))\n+        return error(\"Non-canonical signature: R value excessively padded\");\n+\n+    const unsigned char *S = &vchSig[6+nLenR];\n+    if (S[-2] != 0x02)\n+        return error(\"Non-canonical signature: S value type mismatch\");\n+    if (nLenS == 0)\n+        return error(\"Non-canonical signature: S length is zero\");\n+    if (S[0] & 0x80)\n+        return error(\"Non-canonical signature: S value negative\");\n+    if (nLenS > 1 && (S[0] == 0x00) && !(S[1] & 0x80))\n+        return error(\"Non-canonical signature: S value excessively padded\");\n+\n+    return true;\n+}\n+\n+bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, bool fStrictEncodings, int nHashType)\n {\n     CAutoBN_CTX pctx;\n     CScript::const_iterator pc = script.begin();\n@@ -922,7 +983,9 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, co\n                     // Drop the signature, since there's no way for a signature to sign itself\n                     scriptCode.FindAndDelete(CScript(vchSig));\n \n-                    bool fSuccess = CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType);\n+                    bool fSuccess = (!fStrictEncodings || (IsCanonicalSignature(vchSig) && IsCanonicalPubKey(vchPubKey)));\n+                    if (fSuccess)\n+                        fSuccess = CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType);\n \n                     popstack(stack);\n                     popstack(stack);\n@@ -982,8 +1045,11 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, co\n                         valtype& vchPubKey = stacktop(-ikey);\n \n                         // Check signature\n-                        if (CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType))\n-                        {\n+                        bool fOk = (!fStrictEncodings || (IsCanonicalSignature(vchSig) && IsCanonicalPubKey(vchPubKey)));\n+                        if (fOk)\n+                            fOk = CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType);\n+\n+                        if (fOk) {\n                             isig++;\n                             nSigsCount--;\n                         }\n@@ -1550,14 +1616,14 @@ bool ExtractDestinations(const CScript& scriptPubKey, txnouttype& typeRet, vecto\n }\n \n bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n-                  bool fValidatePayToScriptHash, int nHashType)\n+                  bool fValidatePayToScriptHash, bool fStrictEncodings, int nHashType)\n {\n     vector<vector<unsigned char> > stack, stackCopy;\n-    if (!EvalScript(stack, scriptSig, txTo, nIn, nHashType))\n+    if (!EvalScript(stack, scriptSig, txTo, nIn, fStrictEncodings, nHashType))\n         return false;\n     if (fValidatePayToScriptHash)\n         stackCopy = stack;\n-    if (!EvalScript(stack, scriptPubKey, txTo, nIn, nHashType))\n+    if (!EvalScript(stack, scriptPubKey, txTo, nIn, fStrictEncodings, nHashType))\n         return false;\n     if (stack.empty())\n         return false;\n@@ -1575,7 +1641,7 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n         CScript pubKey2(pubKeySerialized.begin(), pubKeySerialized.end());\n         popstack(stackCopy);\n \n-        if (!EvalScript(stackCopy, pubKey2, txTo, nIn, nHashType))\n+        if (!EvalScript(stackCopy, pubKey2, txTo, nIn, fStrictEncodings, nHashType))\n             return false;\n         if (stackCopy.empty())\n             return false;\n@@ -1618,7 +1684,7 @@ bool SignSignature(const CKeyStore &keystore, const CScript& fromPubKey, CTransa\n     }\n \n     // Test solution\n-    return VerifyScript(txin.scriptSig, fromPubKey, txTo, nIn, true, 0);\n+    return VerifyScript(txin.scriptSig, fromPubKey, txTo, nIn, true, true, 0);\n }\n \n bool SignSignature(const CKeyStore &keystore, const CTransaction& txFrom, CTransaction& txTo, unsigned int nIn, int nHashType)\n@@ -1631,7 +1697,7 @@ bool SignSignature(const CKeyStore &keystore, const CTransaction& txFrom, CTrans\n     return SignSignature(keystore, txout.scriptPubKey, txTo, nIn, nHashType);\n }\n \n-bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, bool fValidatePayToScriptHash, int nHashType)\n+bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, bool fValidatePayToScriptHash, bool fStrictEncodings, int nHashType)\n {\n     assert(nIn < txTo.vin.size());\n     const CTxIn& txin = txTo.vin[nIn];\n@@ -1642,7 +1708,7 @@ bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsig\n     if (txin.prevout.hash != txFrom.GetHash())\n         return false;\n \n-    return VerifyScript(txin.scriptSig, txout.scriptPubKey, txTo, nIn, fValidatePayToScriptHash, nHashType);\n+    return VerifyScript(txin.scriptSig, txout.scriptPubKey, txTo, nIn, fValidatePayToScriptHash, fStrictEncodings, nHashType);\n }\n \n static CScript PushAll(const vector<valtype>& values)\n@@ -1760,9 +1826,9 @@ CScript CombineSignatures(CScript scriptPubKey, const CTransaction& txTo, unsign\n     Solver(scriptPubKey, txType, vSolutions);\n \n     vector<valtype> stack1;\n-    EvalScript(stack1, scriptSig1, CTransaction(), 0, 0);\n+    EvalScript(stack1, scriptSig1, CTransaction(), 0, true, 0);\n     vector<valtype> stack2;\n-    EvalScript(stack2, scriptSig2, CTransaction(), 0, 0);\n+    EvalScript(stack2, scriptSig2, CTransaction(), 0, true, 0);\n \n     return CombineSignatures(scriptPubKey, txTo, nIn, txType, vSolutions, stack1, stack2);\n }"
      },
      {
        "sha": "51e3b5eb843b9113cd8f45384674b0b66b04633c",
        "filename": "src/script.h",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/58bc86e37fda1aec270bccb3df6c20fbd2a6591c/src/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/58bc86e37fda1aec270bccb3df6c20fbd2a6591c/src/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.h?ref=58bc86e37fda1aec270bccb3df6c20fbd2a6591c",
        "patch": "@@ -581,9 +581,10 @@ class CScript : public std::vector<unsigned char>\n \n \n \n+bool IsCanonicalPubKey(const std::vector<unsigned char> &vchPubKey);\n+bool IsCanonicalSignature(const std::vector<unsigned char> &vchSig);\n \n-\n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, int nHashType);\n+bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, bool fStrictEncodings, int nHashType);\n bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<std::vector<unsigned char> >& vSolutionsRet);\n int ScriptSigArgsExpected(txnouttype t, const std::vector<std::vector<unsigned char> >& vSolutions);\n bool IsStandard(const CScript& scriptPubKey);\n@@ -594,8 +595,8 @@ bool ExtractDestinations(const CScript& scriptPubKey, txnouttype& typeRet, std::\n bool SignSignature(const CKeyStore& keystore, const CScript& fromPubKey, CTransaction& txTo, unsigned int nIn, int nHashType=SIGHASH_ALL);\n bool SignSignature(const CKeyStore& keystore, const CTransaction& txFrom, CTransaction& txTo, unsigned int nIn, int nHashType=SIGHASH_ALL);\n bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n-                  bool fValidatePayToScriptHash, int nHashType);\n-bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, bool fValidatePayToScriptHash, int nHashType);\n+                  bool fValidatePayToScriptHash, bool fStrictEncodings, int nHashType);\n+bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, bool fValidatePayToScriptHash, bool fStrictEncodings, int nHashType);\n \n // Given two sets of signatures for scriptPubKey, possibly with OP_0 placeholders,\n // combine them intelligently and return the result."
      },
      {
        "sha": "d46959312041561c5b70f200f3a45aeeac7d8409",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/58bc86e37fda1aec270bccb3df6c20fbd2a6591c/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/58bc86e37fda1aec270bccb3df6c20fbd2a6591c/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=58bc86e37fda1aec270bccb3df6c20fbd2a6591c",
        "patch": "@@ -278,7 +278,7 @@ BOOST_AUTO_TEST_CASE(DoS_checkSig)\n     mst1 = boost::posix_time::microsec_clock::local_time();\n     for (unsigned int i = 0; i < 5; i++)\n         for (unsigned int j = 0; j < tx.vin.size(); j++)\n-            BOOST_CHECK(VerifySignature(orphans[j], tx, j, true, SIGHASH_ALL));\n+            BOOST_CHECK(VerifySignature(orphans[j], tx, j, true, true, SIGHASH_ALL));\n     mst2 = boost::posix_time::microsec_clock::local_time();\n     msdiff = mst2 - mst1;\n     long nManyValidate = msdiff.total_milliseconds();\n@@ -289,13 +289,13 @@ BOOST_AUTO_TEST_CASE(DoS_checkSig)\n     // Empty a signature, validation should fail:\n     CScript save = tx.vin[0].scriptSig;\n     tx.vin[0].scriptSig = CScript();\n-    BOOST_CHECK(!VerifySignature(orphans[0], tx, 0, true, SIGHASH_ALL));\n+    BOOST_CHECK(!VerifySignature(orphans[0], tx, 0, true, true, SIGHASH_ALL));\n     tx.vin[0].scriptSig = save;\n \n     // Swap signatures, validation should fail:\n     std::swap(tx.vin[0].scriptSig, tx.vin[1].scriptSig);\n-    BOOST_CHECK(!VerifySignature(orphans[0], tx, 0, true, SIGHASH_ALL));\n-    BOOST_CHECK(!VerifySignature(orphans[1], tx, 1, true, SIGHASH_ALL));\n+    BOOST_CHECK(!VerifySignature(orphans[0], tx, 0, true, true, SIGHASH_ALL));\n+    BOOST_CHECK(!VerifySignature(orphans[1], tx, 1, true, true, SIGHASH_ALL));\n     std::swap(tx.vin[0].scriptSig, tx.vin[1].scriptSig);\n \n     // Exercise -maxsigcachesize code:\n@@ -305,7 +305,7 @@ BOOST_AUTO_TEST_CASE(DoS_checkSig)\n     BOOST_CHECK(SignSignature(keystore, orphans[0], tx, 0));\n     BOOST_CHECK(tx.vin[0].scriptSig != oldSig);\n     for (unsigned int j = 0; j < tx.vin.size(); j++)\n-        BOOST_CHECK(VerifySignature(orphans[j], tx, j, true, SIGHASH_ALL));\n+        BOOST_CHECK(VerifySignature(orphans[j], tx, j, true, true, SIGHASH_ALL));\n     mapArgs.erase(\"-maxsigcachesize\");\n \n     LimitOrphanTxSize(0);"
      },
      {
        "sha": "42d21f8ac55cb7dc3478dd69614db7c1b7c26c48",
        "filename": "src/test/canonical_tests.cpp",
        "status": "added",
        "additions": 87,
        "deletions": 0,
        "changes": 87,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/58bc86e37fda1aec270bccb3df6c20fbd2a6591c/src/test/canonical_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/58bc86e37fda1aec270bccb3df6c20fbd2a6591c/src/test/canonical_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/canonical_tests.cpp?ref=58bc86e37fda1aec270bccb3df6c20fbd2a6591c",
        "patch": "@@ -0,0 +1,87 @@\n+//\n+// Unit tests for canonical signatures\n+\n+#include \"json/json_spirit_writer_template.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <openssl/ecdsa.h>\n+\n+#include \"key.h\"\n+#include \"script.h\"\n+#include \"util.h\"\n+\n+using namespace std;\n+using namespace json_spirit;\n+\n+\n+// In script_tests.cpp\n+extern Array read_json(const std::string& filename);\n+\n+BOOST_AUTO_TEST_SUITE(canonical_tests)\n+\n+// OpenSSL-based test for canonical signature (without test for hashtype byte)\n+bool static IsCanonicalSignature_OpenSSL_inner(const std::vector<unsigned char>& vchSig)\n+{\n+    if (vchSig.size() == 0)\n+        return false;\n+    const unsigned char *input = &vchSig[0];\n+    ECDSA_SIG *psig = NULL;\n+    d2i_ECDSA_SIG(&psig, &input, vchSig.size());\n+    if (psig == NULL)\n+        return false;\n+    unsigned char buf[256];\n+    unsigned char *pbuf = buf;\n+    unsigned int nLen = i2d_ECDSA_SIG(psig, NULL);\n+    if (nLen != vchSig.size()) {\n+        ECDSA_SIG_free(psig);\n+        return false;\n+    }\n+    nLen = i2d_ECDSA_SIG(psig, &pbuf);\n+    ECDSA_SIG_free(psig);\n+    return (memcmp(&vchSig[0], &buf[0], nLen) == 0);\n+}\n+\n+// OpenSSL-based test for canonical signature\n+bool static IsCanonicalSignature_OpenSSL(const std::vector<unsigned char> &vchSignature) {\n+    if (vchSignature.size() < 1)\n+        return false;\n+    if (vchSignature.size() > 127)\n+        return false;\n+    if (vchSignature[vchSignature.size() - 1] & 0x7C)\n+        return false;\n+\n+    std::vector<unsigned char> vchSig(vchSignature);\n+    vchSig.pop_back();\n+    if (!IsCanonicalSignature_OpenSSL_inner(vchSig))\n+        return false;\n+    return true;\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_canon)\n+{\n+    Array tests = read_json(\"sig_canonical.json\");\n+\n+    BOOST_FOREACH(Value &tv, tests) {\n+        string test = tv.get_str();\n+        if (IsHex(test)) {\n+            std::vector<unsigned char> sig = ParseHex(test);\n+            BOOST_CHECK_MESSAGE(IsCanonicalSignature(sig), test);\n+            BOOST_CHECK_MESSAGE(IsCanonicalSignature_OpenSSL(sig), test);\n+        }\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_noncanon)\n+{\n+    Array tests = read_json(\"sig_noncanonical.json\");\n+\n+    BOOST_FOREACH(Value &tv, tests) {\n+        string test = tv.get_str();\n+        if (IsHex(test)) {\n+            std::vector<unsigned char> sig = ParseHex(test);\n+            BOOST_CHECK_MESSAGE(!IsCanonicalSignature(sig), test);\n+            BOOST_CHECK_MESSAGE(!IsCanonicalSignature_OpenSSL(sig), test);\n+        }\n+    }\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "e43a08629a1ae2b51feba692b244b8a301649208",
        "filename": "src/test/data/sig_canonical.json",
        "status": "added",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/58bc86e37fda1aec270bccb3df6c20fbd2a6591c/src/test/data/sig_canonical.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/58bc86e37fda1aec270bccb3df6c20fbd2a6591c/src/test/data/sig_canonical.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/sig_canonical.json?ref=58bc86e37fda1aec270bccb3df6c20fbd2a6591c",
        "patch": "@@ -0,0 +1,7 @@\n+[\n+    \"300602010002010001\",\n+    \"3008020200ff020200ff01\",\n+    \"304402203932c892e2e550f3af8ee4ce9c215a87f9bb831dcac87b2838e2c2eaa891df0c022030b61dd36543125d56b9f9f3a1f9353189e5af33cdda8d77a5209aec03978fa001\",\n+    \"30450220076045be6f9eca28ff1ec606b833d0b87e70b2a630f5e3a496b110967a40f90a0221008fffd599910eefe00bc803c688c2eca1d2ba7f6b180620eaa03488e6585db6ba01\",\n+    \"3046022100876045be6f9eca28ff1ec606b833d0b87e70b2a630f5e3a496b110967a40f90a0221008fffd599910eefe00bc803c688c2eca1d2ba7f6b180620eaa03488e6585db6ba01\"\n+]"
      },
      {
        "sha": "d9a6c1cdd872ec1d64ac429577b6b210f67b17b8",
        "filename": "src/test/data/sig_noncanonical.json",
        "status": "added",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/58bc86e37fda1aec270bccb3df6c20fbd2a6591c/src/test/data/sig_noncanonical.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/58bc86e37fda1aec270bccb3df6c20fbd2a6591c/src/test/data/sig_noncanonical.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/sig_noncanonical.json?ref=58bc86e37fda1aec270bccb3df6c20fbd2a6591c",
        "patch": "@@ -0,0 +1,22 @@\n+[\n+    \"non-hex strings are ignored\",\n+\n+    \"too short:\",    \"30050201FF020001\",\n+    \"too long:\",     \"30470221005990e0584b2b238e1dfaad8d6ed69ecc1a4a13ac85fc0b31d0df395eb1ba6105022200002d5876262c288beb511d061691bf26777344b702b00f8fe28621fe4e566695ed01\",\n+    \"hashtype:\",     \"304402205990e0584b2b238e1dfaad8d6ed69ecc1a4a13ac85fc0b31d0df395eb1ba610502202d5876262c288beb511d061691bf26777344b702b00f8fe28621fe4e566695ed11\",\n+    \"type:\",         \"314402205990e0584b2b238e1dfaad8d6ed69ecc1a4a13ac85fc0b31d0df395eb1ba610502202d5876262c288beb511d061691bf26777344b702b00f8fe28621fe4e566695ed01\",\n+    \"total length:\", \"304502205990e0584b2b238e1dfaad8d6ed69ecc1a4a13ac85fc0b31d0df395eb1ba610502202d5876262c288beb511d061691bf26777344b702b00f8fe28621fe4e566695ed01\",\n+    \"S len oob:\",    \"301F01205990e0584b2b238e1dfaad8d6ed69ecc1a4a13ac85fc0b31d0df395eb101\",\n+    \"R+S:\",          \"304502205990e0584b2b238e1dfaad8d6ed69ecc1a4a13ac85fc0b31d0df395eb1ba610502202d5876262c288beb511d061691bf26777344b702b00f8fe28621fe4e566695ed0001\",\n+\n+    \"R type:\",       \"304401205990e0584b2b238e1dfaad8d6ed69ecc1a4a13ac85fc0b31d0df395eb1ba610502202d5876262c288beb511d061691bf26777344b702b00f8fe28621fe4e566695ed01\",\n+    \"R len = 0:\",    \"3024020002202d5876262c288beb511d061691bf26777344b702b00f8fe28621fe4e566695ed01\",\n+    \"R<0:\",          \"304402208990e0584b2b238e1dfaad8d6ed69ecc1a4a13ac85fc0b31d0df395eb1ba610502202d5876262c288beb511d061691bf26777344b702b00f8fe28621fe4e566695ed01\",\n+    \"R padded:\",     \"30450221005990e0584b2b238e1dfaad8d6ed69ecc1a4a13ac85fc0b31d0df395eb1ba610502202d5876262c288beb511d061691bf26777344b702b00f8fe28621fe4e566695ed01\",\n+\n+\n+    \"S type:\",       \"304402205990e0584b2b238e1dfaad8d6ed69ecc1a4a13ac85fc0b31d0df395eb1ba610501202d5876262c288beb511d061691bf26777344b702b00f8fe28621fe4e566695ed01\",\n+    \"S len = 0:\",    \"302402205990e0584b2b238e1dfaad8d6ed69ecc1a4a13ac85fc0b31d0df395eb1ba6105020001\",\n+    \"S<0:\",          \"304402205990e0584b2b238e1dfaad8d6ed69ecc1a4a13ac85fc0b31d0df395eb1ba61050220fd5876262c288beb511d061691bf26777344b702b00f8fe28621fe4e566695ed01\",\n+    \"S padded:\",     \"304502205990e0584b2b238e1dfaad8d6ed69ecc1a4a13ac85fc0b31d0df395eb1ba61050221002d5876262c288beb511d061691bf26777344b702b00f8fe28621fe4e566695ed01\"\n+]"
      },
      {
        "sha": "aa6feb7201b70c067742c6f32c6aaa2efe91f16a",
        "filename": "src/test/multisig_tests.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/58bc86e37fda1aec270bccb3df6c20fbd2a6591c/src/test/multisig_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/58bc86e37fda1aec270bccb3df6c20fbd2a6591c/src/test/multisig_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/multisig_tests.cpp?ref=58bc86e37fda1aec270bccb3df6c20fbd2a6591c",
        "patch": "@@ -21,7 +21,7 @@ typedef vector<unsigned char> valtype;\n \n extern uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n extern bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n-                         bool fValidatePayToScriptHash, int nHashType);\n+                         bool fValidatePayToScriptHash, bool fStrictEncodings, int nHashType);\n \n BOOST_AUTO_TEST_SUITE(multisig_tests)\n \n@@ -80,19 +80,19 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n     keys.clear();\n     keys += key[0],key[1]; // magic operator+= from boost.assign\n     s = sign_multisig(a_and_b, keys, txTo[0], 0);\n-    BOOST_CHECK(VerifyScript(s, a_and_b, txTo[0], 0, true, 0));\n+    BOOST_CHECK(VerifyScript(s, a_and_b, txTo[0], 0, true, true, 0));\n \n     for (int i = 0; i < 4; i++)\n     {\n         keys.clear();\n         keys += key[i];\n         s = sign_multisig(a_and_b, keys, txTo[0], 0);\n-        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, txTo[0], 0, true, 0), strprintf(\"a&b 1: %d\", i));\n+        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, txTo[0], 0, true, true, 0), strprintf(\"a&b 1: %d\", i));\n \n         keys.clear();\n         keys += key[1],key[i];\n         s = sign_multisig(a_and_b, keys, txTo[0], 0);\n-        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, txTo[0], 0, true, 0), strprintf(\"a&b 2: %d\", i));\n+        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, txTo[0], 0, true, true, 0), strprintf(\"a&b 2: %d\", i));\n     }\n \n     // Test a OR b:\n@@ -102,16 +102,16 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n         keys += key[i];\n         s = sign_multisig(a_or_b, keys, txTo[1], 0);\n         if (i == 0 || i == 1)\n-            BOOST_CHECK_MESSAGE(VerifyScript(s, a_or_b, txTo[1], 0, true, 0), strprintf(\"a|b: %d\", i));\n+            BOOST_CHECK_MESSAGE(VerifyScript(s, a_or_b, txTo[1], 0, true, true, 0), strprintf(\"a|b: %d\", i));\n         else\n-            BOOST_CHECK_MESSAGE(!VerifyScript(s, a_or_b, txTo[1], 0, true, 0), strprintf(\"a|b: %d\", i));\n+            BOOST_CHECK_MESSAGE(!VerifyScript(s, a_or_b, txTo[1], 0, true, true, 0), strprintf(\"a|b: %d\", i));\n     }\n     s.clear();\n     s << OP_0 << OP_0;\n-    BOOST_CHECK(!VerifyScript(s, a_or_b, txTo[1], 0, true, 0));\n+    BOOST_CHECK(!VerifyScript(s, a_or_b, txTo[1], 0, true, true, 0));\n     s.clear();\n     s << OP_0 << OP_1;\n-    BOOST_CHECK(!VerifyScript(s, a_or_b, txTo[1], 0, true, 0));\n+    BOOST_CHECK(!VerifyScript(s, a_or_b, txTo[1], 0, true, true, 0));\n \n \n     for (int i = 0; i < 4; i++)\n@@ -121,9 +121,9 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n             keys += key[i],key[j];\n             s = sign_multisig(escrow, keys, txTo[2], 0);\n             if (i < j && i < 3 && j < 3)\n-                BOOST_CHECK_MESSAGE(VerifyScript(s, escrow, txTo[2], 0, true, 0), strprintf(\"escrow 1: %d %d\", i, j));\n+                BOOST_CHECK_MESSAGE(VerifyScript(s, escrow, txTo[2], 0, true, true, 0), strprintf(\"escrow 1: %d %d\", i, j));\n             else\n-                BOOST_CHECK_MESSAGE(!VerifyScript(s, escrow, txTo[2], 0, true, 0), strprintf(\"escrow 2: %d %d\", i, j));\n+                BOOST_CHECK_MESSAGE(!VerifyScript(s, escrow, txTo[2], 0, true, true, 0), strprintf(\"escrow 2: %d %d\", i, j));\n         }\n }\n "
      },
      {
        "sha": "9db584c1471f12291f274f4fce75dff7fc736b1e",
        "filename": "src/test/script_P2SH_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/58bc86e37fda1aec270bccb3df6c20fbd2a6591c/src/test/script_P2SH_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/58bc86e37fda1aec270bccb3df6c20fbd2a6591c/src/test/script_P2SH_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_P2SH_tests.cpp?ref=58bc86e37fda1aec270bccb3df6c20fbd2a6591c",
        "patch": "@@ -14,7 +14,7 @@ using namespace std;\n // Test routines internal to script.cpp:\n extern uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n extern bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n-                         bool fValidatePayToScriptHash, int nHashType);\n+                         bool fValidatePayToScriptHash, bool fStrictEncodings, int nHashType);\n \n // Helpers:\n static std::vector<unsigned char>\n@@ -40,7 +40,7 @@ Verify(const CScript& scriptSig, const CScript& scriptPubKey, bool fStrict)\n     txTo.vin[0].scriptSig = scriptSig;\n     txTo.vout[0].nValue = 1;\n \n-    return VerifyScript(scriptSig, scriptPubKey, txTo, 0, fStrict, 0);\n+    return VerifyScript(scriptSig, scriptPubKey, txTo, 0, fStrict, true, 0);\n }\n \n \n@@ -105,7 +105,7 @@ BOOST_AUTO_TEST_CASE(sign)\n         {\n             CScript sigSave = txTo[i].vin[0].scriptSig;\n             txTo[i].vin[0].scriptSig = txTo[j].vin[0].scriptSig;\n-            bool sigOK = VerifySignature(txFrom, txTo[i], 0, true, 0);\n+            bool sigOK = VerifySignature(txFrom, txTo[i], 0, true, true, 0);\n             if (i == j)\n                 BOOST_CHECK_MESSAGE(sigOK, strprintf(\"VerifySignature %d %d\", i, j));\n             else"
      },
      {
        "sha": "f8e4fa8a49b407111be417f9f33b38dcb62e229c",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 20,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/58bc86e37fda1aec270bccb3df6c20fbd2a6591c/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/58bc86e37fda1aec270bccb3df6c20fbd2a6591c/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=58bc86e37fda1aec270bccb3df6c20fbd2a6591c",
        "patch": "@@ -21,7 +21,7 @@ using namespace boost::algorithm;\n \n extern uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n extern bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n-                         bool fValidatePayToScriptHash, int nHashType);\n+                         bool fValidatePayToScriptHash, bool fStrictEncodings, int nHashType);\n \n CScript\n ParseScript(string s)\n@@ -143,7 +143,7 @@ BOOST_AUTO_TEST_CASE(script_valid)\n         CScript scriptPubKey = ParseScript(scriptPubKeyString);\n \n         CTransaction tx;\n-        BOOST_CHECK_MESSAGE(VerifyScript(scriptSig, scriptPubKey, tx, 0, true, SIGHASH_NONE), strTest);\n+        BOOST_CHECK_MESSAGE(VerifyScript(scriptSig, scriptPubKey, tx, 0, true, true, SIGHASH_NONE), strTest);\n     }\n }\n \n@@ -167,7 +167,7 @@ BOOST_AUTO_TEST_CASE(script_invalid)\n         CScript scriptPubKey = ParseScript(scriptPubKeyString);\n \n         CTransaction tx;\n-        BOOST_CHECK_MESSAGE(!VerifyScript(scriptSig, scriptPubKey, tx, 0, true, SIGHASH_NONE), strTest);\n+        BOOST_CHECK_MESSAGE(!VerifyScript(scriptSig, scriptPubKey, tx, 0, true, true, SIGHASH_NONE), strTest);\n     }\n }\n \n@@ -181,18 +181,18 @@ BOOST_AUTO_TEST_CASE(script_PushData)\n     static const unsigned char pushdata4[] = { OP_PUSHDATA4, 1, 0, 0, 0, 0x5a };\n \n     vector<vector<unsigned char> > directStack;\n-    BOOST_CHECK(EvalScript(directStack, CScript(&direct[0], &direct[sizeof(direct)]), CTransaction(), 0, 0));\n+    BOOST_CHECK(EvalScript(directStack, CScript(&direct[0], &direct[sizeof(direct)]), CTransaction(), 0, true, 0));\n \n     vector<vector<unsigned char> > pushdata1Stack;\n-    BOOST_CHECK(EvalScript(pushdata1Stack, CScript(&pushdata1[0], &pushdata1[sizeof(pushdata1)]), CTransaction(), 0, 0));\n+    BOOST_CHECK(EvalScript(pushdata1Stack, CScript(&pushdata1[0], &pushdata1[sizeof(pushdata1)]), CTransaction(), 0, true, 0));\n     BOOST_CHECK(pushdata1Stack == directStack);\n \n     vector<vector<unsigned char> > pushdata2Stack;\n-    BOOST_CHECK(EvalScript(pushdata2Stack, CScript(&pushdata2[0], &pushdata2[sizeof(pushdata2)]), CTransaction(), 0, 0));\n+    BOOST_CHECK(EvalScript(pushdata2Stack, CScript(&pushdata2[0], &pushdata2[sizeof(pushdata2)]), CTransaction(), 0, true, 0));\n     BOOST_CHECK(pushdata2Stack == directStack);\n \n     vector<vector<unsigned char> > pushdata4Stack;\n-    BOOST_CHECK(EvalScript(pushdata4Stack, CScript(&pushdata4[0], &pushdata4[sizeof(pushdata4)]), CTransaction(), 0, 0));\n+    BOOST_CHECK(EvalScript(pushdata4Stack, CScript(&pushdata4[0], &pushdata4[sizeof(pushdata4)]), CTransaction(), 0, true, 0));\n     BOOST_CHECK(pushdata4Stack == directStack);\n }\n \n@@ -250,15 +250,15 @@ BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG12)\n     txTo12.vout[0].nValue = 1;\n \n     CScript goodsig1 = sign_multisig(scriptPubKey12, key1, txTo12);\n-    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey12, txTo12, 0, true, 0));\n+    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey12, txTo12, 0, true, true, 0));\n     txTo12.vout[0].nValue = 2;\n-    BOOST_CHECK(!VerifyScript(goodsig1, scriptPubKey12, txTo12, 0, true, 0));\n+    BOOST_CHECK(!VerifyScript(goodsig1, scriptPubKey12, txTo12, 0, true, true, 0));\n \n     CScript goodsig2 = sign_multisig(scriptPubKey12, key2, txTo12);\n-    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey12, txTo12, 0, true, 0));\n+    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey12, txTo12, 0, true, true, 0));\n \n     CScript badsig1 = sign_multisig(scriptPubKey12, key3, txTo12);\n-    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey12, txTo12, 0, true, 0));\n+    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey12, txTo12, 0, true, true, 0));\n }\n \n BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG23)\n@@ -286,46 +286,46 @@ BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG23)\n     std::vector<CKey> keys;\n     keys.push_back(key1); keys.push_back(key2);\n     CScript goodsig1 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey23, txTo23, 0, true, 0));\n+    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey23, txTo23, 0, true, true, 0));\n \n     keys.clear();\n     keys.push_back(key1); keys.push_back(key3);\n     CScript goodsig2 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey23, txTo23, 0, true, 0));\n+    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey23, txTo23, 0, true, true, 0));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key3);\n     CScript goodsig3 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(VerifyScript(goodsig3, scriptPubKey23, txTo23, 0, true, 0));\n+    BOOST_CHECK(VerifyScript(goodsig3, scriptPubKey23, txTo23, 0, true, true, 0));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key2); // Can't re-use sig\n     CScript badsig1 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey23, txTo23, 0, true, 0));\n+    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey23, txTo23, 0, true, true, 0));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key1); // sigs must be in correct order\n     CScript badsig2 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig2, scriptPubKey23, txTo23, 0, true, 0));\n+    BOOST_CHECK(!VerifyScript(badsig2, scriptPubKey23, txTo23, 0, true, true, 0));\n \n     keys.clear();\n     keys.push_back(key3); keys.push_back(key2); // sigs must be in correct order\n     CScript badsig3 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig3, scriptPubKey23, txTo23, 0, true, 0));\n+    BOOST_CHECK(!VerifyScript(badsig3, scriptPubKey23, txTo23, 0, true, true, 0));\n \n     keys.clear();\n     keys.push_back(key4); keys.push_back(key2); // sigs must match pubkeys\n     CScript badsig4 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig4, scriptPubKey23, txTo23, 0, true, 0));\n+    BOOST_CHECK(!VerifyScript(badsig4, scriptPubKey23, txTo23, 0, true, true, 0));\n \n     keys.clear();\n     keys.push_back(key1); keys.push_back(key4); // sigs must match pubkeys\n     CScript badsig5 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig5, scriptPubKey23, txTo23, 0, true, 0));\n+    BOOST_CHECK(!VerifyScript(badsig5, scriptPubKey23, txTo23, 0, true, true, 0));\n \n     keys.clear(); // Must have signatures\n     CScript badsig6 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig6, scriptPubKey23, txTo23, 0, true, 0));\n+    BOOST_CHECK(!VerifyScript(badsig6, scriptPubKey23, txTo23, 0, true, true, 0));\n }    \n \n BOOST_AUTO_TEST_CASE(script_combineSigs)"
      },
      {
        "sha": "1dacdeaa239295ef7d9f16d5a297dc6f5c3981da",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/58bc86e37fda1aec270bccb3df6c20fbd2a6591c/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/58bc86e37fda1aec270bccb3df6c20fbd2a6591c/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=58bc86e37fda1aec270bccb3df6c20fbd2a6591c",
        "patch": "@@ -76,7 +76,7 @@ BOOST_AUTO_TEST_CASE(tx_valid)\n                     break;\n                 }\n \n-                BOOST_CHECK_MESSAGE(VerifyScript(tx.vin[i].scriptSig, mapprevOutScriptPubKeys[tx.vin[i].prevout], tx, i, test[2].get_bool(), 0), strTest);\n+                BOOST_CHECK_MESSAGE(VerifyScript(tx.vin[i].scriptSig, mapprevOutScriptPubKeys[tx.vin[i].prevout], tx, i, test[2].get_bool(), false, 0), strTest);\n             }\n         }\n     }\n@@ -143,7 +143,7 @@ BOOST_AUTO_TEST_CASE(tx_invalid)\n                     break;\n                 }\n \n-                fValid = VerifyScript(tx.vin[i].scriptSig, mapprevOutScriptPubKeys[tx.vin[i].prevout], tx, i, test[2].get_bool(), 0);\n+                fValid = VerifyScript(tx.vin[i].scriptSig, mapprevOutScriptPubKeys[tx.vin[i].prevout], tx, i, test[2].get_bool(), true, 0);\n             }\n \n             BOOST_CHECK_MESSAGE(!fValid, strTest);"
      }
    ]
  },
  {
    "sha": "3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozZTRlZWM4Y2I2YmY1YjhjZGZlZTQ0OGNlOGRmNDNlNzhiNGM3M2E2",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-19T23:54:48Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-19T23:54:48Z"
      },
      "message": "Merge branch 'canonical'",
      "tree": {
        "sha": "9eaf50e73a51a3b40da9cb557090a794138e9f35",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9eaf50e73a51a3b40da9cb557090a794138e9f35"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "485d667748b776a1932e3e14dc1b9dfe2ba841d0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/485d667748b776a1932e3e14dc1b9dfe2ba841d0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/485d667748b776a1932e3e14dc1b9dfe2ba841d0"
      },
      {
        "sha": "58bc86e37fda1aec270bccb3df6c20fbd2a6591c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/58bc86e37fda1aec270bccb3df6c20fbd2a6591c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/58bc86e37fda1aec270bccb3df6c20fbd2a6591c"
      }
    ],
    "stats": {
      "total": 307,
      "additions": 245,
      "deletions": 62
    },
    "files": [
      {
        "sha": "fb2e650ac43f4ad33200d67057068c7fb4a7d2b7",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6",
        "patch": "@@ -327,7 +327,7 @@ bool CTransaction::AreInputsStandard(const MapPrevTx& mapInputs) const\n         // beside \"push data\" in the scriptSig the\n         // IsStandard() call returns false\n         vector<vector<unsigned char> > stack;\n-        if (!EvalScript(stack, vin[i].scriptSig, *this, i, 0))\n+        if (!EvalScript(stack, vin[i].scriptSig, *this, i, false, 0))\n             return false;\n \n         if (whichType == TX_SCRIPTHASH)\n@@ -1292,11 +1292,11 @@ bool CTransaction::ConnectInputs(MapPrevTx inputs,\n             if (!(fBlock && (nBestHeight < Checkpoints::GetTotalBlocksEstimate())))\n             {\n                 // Verify signature\n-                if (!VerifySignature(txPrev, *this, i, fStrictPayToScriptHash, 0))\n+                if (!VerifySignature(txPrev, *this, i, fStrictPayToScriptHash, false, 0))\n                 {\n                     // only during transition phase for P2SH: do not invoke anti-DoS code for\n                     // potentially old clients relaying bad P2SH transactions\n-                    if (fStrictPayToScriptHash && VerifySignature(txPrev, *this, i, false, 0))\n+                    if (fStrictPayToScriptHash && VerifySignature(txPrev, *this, i, false, false, 0))\n                         return error(\"ConnectInputs() : %s P2SH VerifySignature failed\", GetHash().ToString().substr(0,10).c_str());\n \n                     return DoS(100,error(\"ConnectInputs() : %s VerifySignature failed\", GetHash().ToString().substr(0,10).c_str()));\n@@ -1350,7 +1350,7 @@ bool CTransaction::ClientConnectInputs()\n                 return false;\n \n             // Verify signature\n-            if (!VerifySignature(txPrev, *this, i, true, 0))\n+            if (!VerifySignature(txPrev, *this, i, true, false, 0))\n                 return error(\"ConnectInputs() : VerifySignature failed\");\n \n             ///// this is redundant with the mempool.mapNextTx stuff,"
      },
      {
        "sha": "cb5bae62da469eec7c7dee3d8459b257e20daa0a",
        "filename": "src/rpcrawtransaction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6/src/rpcrawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6/src/rpcrawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcrawtransaction.cpp?ref=3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6",
        "patch": "@@ -469,7 +469,7 @@ Value signrawtransaction(const Array& params, bool fHelp)\n         {\n             txin.scriptSig = CombineSignatures(prevPubKey, mergedTx, i, txin.scriptSig, txv.vin[i].scriptSig);\n         }\n-        if (!VerifyScript(txin.scriptSig, prevPubKey, mergedTx, i, true, 0))\n+        if (!VerifyScript(txin.scriptSig, prevPubKey, mergedTx, i, true, true, 0))\n             fComplete = false;\n     }\n "
      },
      {
        "sha": "89bc5632bc0851e1659c2b9309058c052fb6b2f8",
        "filename": "src/script.cpp",
        "status": "modified",
        "additions": 79,
        "deletions": 13,
        "changes": 92,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6/src/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6/src/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.cpp?ref=3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6",
        "patch": "@@ -253,7 +253,68 @@ const char* GetOpName(opcodetype opcode)\n     }\n }\n \n-bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, int nHashType)\n+bool IsCanonicalPubKey(const valtype &vchPubKey) {\n+    if (vchPubKey.size() < 33)\n+        return error(\"Non-canonical public key: too short\");\n+    if (vchPubKey[0] == 0x04) {\n+        if (vchPubKey.size() != 65)\n+            return error(\"Non-canonical public key: invalid length for uncompressed key\");\n+    } else if (vchPubKey[0] == 0x02 || vchPubKey[0] == 0x03) {\n+        if (vchPubKey.size() != 33)\n+            return error(\"Non-canonical public key: invalid length for compressed key\");\n+    } else {\n+        return error(\"Non-canonical public key: compressed nor uncompressed\");\n+    }\n+    return true;\n+}\n+\n+bool IsCanonicalSignature(const valtype &vchSig) {\n+    // See https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623\n+    // A canonical signature exists of: <30> <total len> <02> <len R> <R> <02> <len S> <S> <hashtype>\n+    // Where R and S are not negative (their first byte has its highest bit not set), and not\n+    // excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,\n+    // in which case a single 0 byte is necessary and even required).\n+    if (vchSig.size() < 9)\n+        return error(\"Non-canonical signature: too short\");\n+    if (vchSig.size() > 73)\n+        return error(\"Non-canonical signature: too long\");\n+    if (vchSig[vchSig.size() - 1] & 0x7C)\n+        return error(\"Non-canonical signature: unknown hashtype byte\");\n+    if (vchSig[0] != 0x30)\n+        return error(\"Non-canonical signature: wrong type\");\n+    if (vchSig[1] != vchSig.size()-3)\n+        return error(\"Non-canonical signature: wrong length marker\");\n+    unsigned int nLenR = vchSig[3];\n+    if (5 + nLenR >= vchSig.size())\n+        return error(\"Non-canonical signature: S length misplaced\");\n+    unsigned int nLenS = vchSig[5+nLenR];\n+    if ((unsigned long)(nLenR+nLenS+7) != vchSig.size())\n+        return error(\"Non-canonical signature: R+S length mismatch\");\n+\n+    const unsigned char *R = &vchSig[4];\n+    if (R[-2] != 0x02)\n+        return error(\"Non-canonical signature: R value type mismatch\");\n+    if (nLenR == 0)\n+        return error(\"Non-canonical signature: R length is zero\");\n+    if (R[0] & 0x80)\n+        return error(\"Non-canonical signature: R value negative\");\n+    if (nLenR > 1 && (R[0] == 0x00) && !(R[1] & 0x80))\n+        return error(\"Non-canonical signature: R value excessively padded\");\n+\n+    const unsigned char *S = &vchSig[6+nLenR];\n+    if (S[-2] != 0x02)\n+        return error(\"Non-canonical signature: S value type mismatch\");\n+    if (nLenS == 0)\n+        return error(\"Non-canonical signature: S length is zero\");\n+    if (S[0] & 0x80)\n+        return error(\"Non-canonical signature: S value negative\");\n+    if (nLenS > 1 && (S[0] == 0x00) && !(S[1] & 0x80))\n+        return error(\"Non-canonical signature: S value excessively padded\");\n+\n+    return true;\n+}\n+\n+bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, bool fStrictEncodings, int nHashType)\n {\n     CAutoBN_CTX pctx;\n     CScript::const_iterator pc = script.begin();\n@@ -944,7 +1005,9 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, co\n                     // Drop the signature, since there's no way for a signature to sign itself\n                     scriptCode.FindAndDelete(CScript(vchSig));\n \n-                    bool fSuccess = CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType);\n+                    bool fSuccess = (!fStrictEncodings || (IsCanonicalSignature(vchSig) && IsCanonicalPubKey(vchPubKey)));\n+                    if (fSuccess)\n+                        fSuccess = CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType);\n \n                     popstack(stack);\n                     popstack(stack);\n@@ -1004,8 +1067,11 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, co\n                         valtype& vchPubKey = stacktop(-ikey);\n \n                         // Check signature\n-                        if (CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType))\n-                        {\n+                        bool fOk = (!fStrictEncodings || (IsCanonicalSignature(vchSig) && IsCanonicalPubKey(vchPubKey)));\n+                        if (fOk)\n+                            fOk = CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType);\n+\n+                        if (fOk) {\n                             isig++;\n                             nSigsCount--;\n                         }\n@@ -1572,14 +1638,14 @@ bool ExtractDestinations(const CScript& scriptPubKey, txnouttype& typeRet, vecto\n }\n \n bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n-                  bool fValidatePayToScriptHash, int nHashType)\n+                  bool fValidatePayToScriptHash, bool fStrictEncodings, int nHashType)\n {\n     vector<vector<unsigned char> > stack, stackCopy;\n-    if (!EvalScript(stack, scriptSig, txTo, nIn, nHashType))\n+    if (!EvalScript(stack, scriptSig, txTo, nIn, fStrictEncodings, nHashType))\n         return false;\n     if (fValidatePayToScriptHash)\n         stackCopy = stack;\n-    if (!EvalScript(stack, scriptPubKey, txTo, nIn, nHashType))\n+    if (!EvalScript(stack, scriptPubKey, txTo, nIn, fStrictEncodings, nHashType))\n         return false;\n     if (stack.empty())\n         return false;\n@@ -1597,7 +1663,7 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n         CScript pubKey2(pubKeySerialized.begin(), pubKeySerialized.end());\n         popstack(stackCopy);\n \n-        if (!EvalScript(stackCopy, pubKey2, txTo, nIn, nHashType))\n+        if (!EvalScript(stackCopy, pubKey2, txTo, nIn, fStrictEncodings, nHashType))\n             return false;\n         if (stackCopy.empty())\n             return false;\n@@ -1640,7 +1706,7 @@ bool SignSignature(const CKeyStore &keystore, const CScript& fromPubKey, CTransa\n     }\n \n     // Test solution\n-    return VerifyScript(txin.scriptSig, fromPubKey, txTo, nIn, true, 0);\n+    return VerifyScript(txin.scriptSig, fromPubKey, txTo, nIn, true, true, 0);\n }\n \n bool SignSignature(const CKeyStore &keystore, const CTransaction& txFrom, CTransaction& txTo, unsigned int nIn, int nHashType)\n@@ -1653,7 +1719,7 @@ bool SignSignature(const CKeyStore &keystore, const CTransaction& txFrom, CTrans\n     return SignSignature(keystore, txout.scriptPubKey, txTo, nIn, nHashType);\n }\n \n-bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, bool fValidatePayToScriptHash, int nHashType)\n+bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, bool fValidatePayToScriptHash, bool fStrictEncodings, int nHashType)\n {\n     assert(nIn < txTo.vin.size());\n     const CTxIn& txin = txTo.vin[nIn];\n@@ -1664,7 +1730,7 @@ bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsig\n     if (txin.prevout.hash != txFrom.GetHash())\n         return false;\n \n-    return VerifyScript(txin.scriptSig, txout.scriptPubKey, txTo, nIn, fValidatePayToScriptHash, nHashType);\n+    return VerifyScript(txin.scriptSig, txout.scriptPubKey, txTo, nIn, fValidatePayToScriptHash, fStrictEncodings, nHashType);\n }\n \n static CScript PushAll(const vector<valtype>& values)\n@@ -1782,9 +1848,9 @@ CScript CombineSignatures(CScript scriptPubKey, const CTransaction& txTo, unsign\n     Solver(scriptPubKey, txType, vSolutions);\n \n     vector<valtype> stack1;\n-    EvalScript(stack1, scriptSig1, CTransaction(), 0, 0);\n+    EvalScript(stack1, scriptSig1, CTransaction(), 0, true, 0);\n     vector<valtype> stack2;\n-    EvalScript(stack2, scriptSig2, CTransaction(), 0, 0);\n+    EvalScript(stack2, scriptSig2, CTransaction(), 0, true, 0);\n \n     return CombineSignatures(scriptPubKey, txTo, nIn, txType, vSolutions, stack1, stack2);\n }"
      },
      {
        "sha": "51e3b5eb843b9113cd8f45384674b0b66b04633c",
        "filename": "src/script.h",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6/src/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6/src/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.h?ref=3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6",
        "patch": "@@ -581,9 +581,10 @@ class CScript : public std::vector<unsigned char>\n \n \n \n+bool IsCanonicalPubKey(const std::vector<unsigned char> &vchPubKey);\n+bool IsCanonicalSignature(const std::vector<unsigned char> &vchSig);\n \n-\n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, int nHashType);\n+bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, bool fStrictEncodings, int nHashType);\n bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<std::vector<unsigned char> >& vSolutionsRet);\n int ScriptSigArgsExpected(txnouttype t, const std::vector<std::vector<unsigned char> >& vSolutions);\n bool IsStandard(const CScript& scriptPubKey);\n@@ -594,8 +595,8 @@ bool ExtractDestinations(const CScript& scriptPubKey, txnouttype& typeRet, std::\n bool SignSignature(const CKeyStore& keystore, const CScript& fromPubKey, CTransaction& txTo, unsigned int nIn, int nHashType=SIGHASH_ALL);\n bool SignSignature(const CKeyStore& keystore, const CTransaction& txFrom, CTransaction& txTo, unsigned int nIn, int nHashType=SIGHASH_ALL);\n bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n-                  bool fValidatePayToScriptHash, int nHashType);\n-bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, bool fValidatePayToScriptHash, int nHashType);\n+                  bool fValidatePayToScriptHash, bool fStrictEncodings, int nHashType);\n+bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, bool fValidatePayToScriptHash, bool fStrictEncodings, int nHashType);\n \n // Given two sets of signatures for scriptPubKey, possibly with OP_0 placeholders,\n // combine them intelligently and return the result."
      },
      {
        "sha": "d46959312041561c5b70f200f3a45aeeac7d8409",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6",
        "patch": "@@ -278,7 +278,7 @@ BOOST_AUTO_TEST_CASE(DoS_checkSig)\n     mst1 = boost::posix_time::microsec_clock::local_time();\n     for (unsigned int i = 0; i < 5; i++)\n         for (unsigned int j = 0; j < tx.vin.size(); j++)\n-            BOOST_CHECK(VerifySignature(orphans[j], tx, j, true, SIGHASH_ALL));\n+            BOOST_CHECK(VerifySignature(orphans[j], tx, j, true, true, SIGHASH_ALL));\n     mst2 = boost::posix_time::microsec_clock::local_time();\n     msdiff = mst2 - mst1;\n     long nManyValidate = msdiff.total_milliseconds();\n@@ -289,13 +289,13 @@ BOOST_AUTO_TEST_CASE(DoS_checkSig)\n     // Empty a signature, validation should fail:\n     CScript save = tx.vin[0].scriptSig;\n     tx.vin[0].scriptSig = CScript();\n-    BOOST_CHECK(!VerifySignature(orphans[0], tx, 0, true, SIGHASH_ALL));\n+    BOOST_CHECK(!VerifySignature(orphans[0], tx, 0, true, true, SIGHASH_ALL));\n     tx.vin[0].scriptSig = save;\n \n     // Swap signatures, validation should fail:\n     std::swap(tx.vin[0].scriptSig, tx.vin[1].scriptSig);\n-    BOOST_CHECK(!VerifySignature(orphans[0], tx, 0, true, SIGHASH_ALL));\n-    BOOST_CHECK(!VerifySignature(orphans[1], tx, 1, true, SIGHASH_ALL));\n+    BOOST_CHECK(!VerifySignature(orphans[0], tx, 0, true, true, SIGHASH_ALL));\n+    BOOST_CHECK(!VerifySignature(orphans[1], tx, 1, true, true, SIGHASH_ALL));\n     std::swap(tx.vin[0].scriptSig, tx.vin[1].scriptSig);\n \n     // Exercise -maxsigcachesize code:\n@@ -305,7 +305,7 @@ BOOST_AUTO_TEST_CASE(DoS_checkSig)\n     BOOST_CHECK(SignSignature(keystore, orphans[0], tx, 0));\n     BOOST_CHECK(tx.vin[0].scriptSig != oldSig);\n     for (unsigned int j = 0; j < tx.vin.size(); j++)\n-        BOOST_CHECK(VerifySignature(orphans[j], tx, j, true, SIGHASH_ALL));\n+        BOOST_CHECK(VerifySignature(orphans[j], tx, j, true, true, SIGHASH_ALL));\n     mapArgs.erase(\"-maxsigcachesize\");\n \n     LimitOrphanTxSize(0);"
      },
      {
        "sha": "42d21f8ac55cb7dc3478dd69614db7c1b7c26c48",
        "filename": "src/test/canonical_tests.cpp",
        "status": "added",
        "additions": 87,
        "deletions": 0,
        "changes": 87,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6/src/test/canonical_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6/src/test/canonical_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/canonical_tests.cpp?ref=3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6",
        "patch": "@@ -0,0 +1,87 @@\n+//\n+// Unit tests for canonical signatures\n+\n+#include \"json/json_spirit_writer_template.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <openssl/ecdsa.h>\n+\n+#include \"key.h\"\n+#include \"script.h\"\n+#include \"util.h\"\n+\n+using namespace std;\n+using namespace json_spirit;\n+\n+\n+// In script_tests.cpp\n+extern Array read_json(const std::string& filename);\n+\n+BOOST_AUTO_TEST_SUITE(canonical_tests)\n+\n+// OpenSSL-based test for canonical signature (without test for hashtype byte)\n+bool static IsCanonicalSignature_OpenSSL_inner(const std::vector<unsigned char>& vchSig)\n+{\n+    if (vchSig.size() == 0)\n+        return false;\n+    const unsigned char *input = &vchSig[0];\n+    ECDSA_SIG *psig = NULL;\n+    d2i_ECDSA_SIG(&psig, &input, vchSig.size());\n+    if (psig == NULL)\n+        return false;\n+    unsigned char buf[256];\n+    unsigned char *pbuf = buf;\n+    unsigned int nLen = i2d_ECDSA_SIG(psig, NULL);\n+    if (nLen != vchSig.size()) {\n+        ECDSA_SIG_free(psig);\n+        return false;\n+    }\n+    nLen = i2d_ECDSA_SIG(psig, &pbuf);\n+    ECDSA_SIG_free(psig);\n+    return (memcmp(&vchSig[0], &buf[0], nLen) == 0);\n+}\n+\n+// OpenSSL-based test for canonical signature\n+bool static IsCanonicalSignature_OpenSSL(const std::vector<unsigned char> &vchSignature) {\n+    if (vchSignature.size() < 1)\n+        return false;\n+    if (vchSignature.size() > 127)\n+        return false;\n+    if (vchSignature[vchSignature.size() - 1] & 0x7C)\n+        return false;\n+\n+    std::vector<unsigned char> vchSig(vchSignature);\n+    vchSig.pop_back();\n+    if (!IsCanonicalSignature_OpenSSL_inner(vchSig))\n+        return false;\n+    return true;\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_canon)\n+{\n+    Array tests = read_json(\"sig_canonical.json\");\n+\n+    BOOST_FOREACH(Value &tv, tests) {\n+        string test = tv.get_str();\n+        if (IsHex(test)) {\n+            std::vector<unsigned char> sig = ParseHex(test);\n+            BOOST_CHECK_MESSAGE(IsCanonicalSignature(sig), test);\n+            BOOST_CHECK_MESSAGE(IsCanonicalSignature_OpenSSL(sig), test);\n+        }\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_noncanon)\n+{\n+    Array tests = read_json(\"sig_noncanonical.json\");\n+\n+    BOOST_FOREACH(Value &tv, tests) {\n+        string test = tv.get_str();\n+        if (IsHex(test)) {\n+            std::vector<unsigned char> sig = ParseHex(test);\n+            BOOST_CHECK_MESSAGE(!IsCanonicalSignature(sig), test);\n+            BOOST_CHECK_MESSAGE(!IsCanonicalSignature_OpenSSL(sig), test);\n+        }\n+    }\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "e43a08629a1ae2b51feba692b244b8a301649208",
        "filename": "src/test/data/sig_canonical.json",
        "status": "added",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6/src/test/data/sig_canonical.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6/src/test/data/sig_canonical.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/sig_canonical.json?ref=3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6",
        "patch": "@@ -0,0 +1,7 @@\n+[\n+    \"300602010002010001\",\n+    \"3008020200ff020200ff01\",\n+    \"304402203932c892e2e550f3af8ee4ce9c215a87f9bb831dcac87b2838e2c2eaa891df0c022030b61dd36543125d56b9f9f3a1f9353189e5af33cdda8d77a5209aec03978fa001\",\n+    \"30450220076045be6f9eca28ff1ec606b833d0b87e70b2a630f5e3a496b110967a40f90a0221008fffd599910eefe00bc803c688c2eca1d2ba7f6b180620eaa03488e6585db6ba01\",\n+    \"3046022100876045be6f9eca28ff1ec606b833d0b87e70b2a630f5e3a496b110967a40f90a0221008fffd599910eefe00bc803c688c2eca1d2ba7f6b180620eaa03488e6585db6ba01\"\n+]"
      },
      {
        "sha": "d9a6c1cdd872ec1d64ac429577b6b210f67b17b8",
        "filename": "src/test/data/sig_noncanonical.json",
        "status": "added",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6/src/test/data/sig_noncanonical.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6/src/test/data/sig_noncanonical.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/sig_noncanonical.json?ref=3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6",
        "patch": "@@ -0,0 +1,22 @@\n+[\n+    \"non-hex strings are ignored\",\n+\n+    \"too short:\",    \"30050201FF020001\",\n+    \"too long:\",     \"30470221005990e0584b2b238e1dfaad8d6ed69ecc1a4a13ac85fc0b31d0df395eb1ba6105022200002d5876262c288beb511d061691bf26777344b702b00f8fe28621fe4e566695ed01\",\n+    \"hashtype:\",     \"304402205990e0584b2b238e1dfaad8d6ed69ecc1a4a13ac85fc0b31d0df395eb1ba610502202d5876262c288beb511d061691bf26777344b702b00f8fe28621fe4e566695ed11\",\n+    \"type:\",         \"314402205990e0584b2b238e1dfaad8d6ed69ecc1a4a13ac85fc0b31d0df395eb1ba610502202d5876262c288beb511d061691bf26777344b702b00f8fe28621fe4e566695ed01\",\n+    \"total length:\", \"304502205990e0584b2b238e1dfaad8d6ed69ecc1a4a13ac85fc0b31d0df395eb1ba610502202d5876262c288beb511d061691bf26777344b702b00f8fe28621fe4e566695ed01\",\n+    \"S len oob:\",    \"301F01205990e0584b2b238e1dfaad8d6ed69ecc1a4a13ac85fc0b31d0df395eb101\",\n+    \"R+S:\",          \"304502205990e0584b2b238e1dfaad8d6ed69ecc1a4a13ac85fc0b31d0df395eb1ba610502202d5876262c288beb511d061691bf26777344b702b00f8fe28621fe4e566695ed0001\",\n+\n+    \"R type:\",       \"304401205990e0584b2b238e1dfaad8d6ed69ecc1a4a13ac85fc0b31d0df395eb1ba610502202d5876262c288beb511d061691bf26777344b702b00f8fe28621fe4e566695ed01\",\n+    \"R len = 0:\",    \"3024020002202d5876262c288beb511d061691bf26777344b702b00f8fe28621fe4e566695ed01\",\n+    \"R<0:\",          \"304402208990e0584b2b238e1dfaad8d6ed69ecc1a4a13ac85fc0b31d0df395eb1ba610502202d5876262c288beb511d061691bf26777344b702b00f8fe28621fe4e566695ed01\",\n+    \"R padded:\",     \"30450221005990e0584b2b238e1dfaad8d6ed69ecc1a4a13ac85fc0b31d0df395eb1ba610502202d5876262c288beb511d061691bf26777344b702b00f8fe28621fe4e566695ed01\",\n+\n+\n+    \"S type:\",       \"304402205990e0584b2b238e1dfaad8d6ed69ecc1a4a13ac85fc0b31d0df395eb1ba610501202d5876262c288beb511d061691bf26777344b702b00f8fe28621fe4e566695ed01\",\n+    \"S len = 0:\",    \"302402205990e0584b2b238e1dfaad8d6ed69ecc1a4a13ac85fc0b31d0df395eb1ba6105020001\",\n+    \"S<0:\",          \"304402205990e0584b2b238e1dfaad8d6ed69ecc1a4a13ac85fc0b31d0df395eb1ba61050220fd5876262c288beb511d061691bf26777344b702b00f8fe28621fe4e566695ed01\",\n+    \"S padded:\",     \"304502205990e0584b2b238e1dfaad8d6ed69ecc1a4a13ac85fc0b31d0df395eb1ba61050221002d5876262c288beb511d061691bf26777344b702b00f8fe28621fe4e566695ed01\"\n+]"
      },
      {
        "sha": "aa6feb7201b70c067742c6f32c6aaa2efe91f16a",
        "filename": "src/test/multisig_tests.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6/src/test/multisig_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6/src/test/multisig_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/multisig_tests.cpp?ref=3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6",
        "patch": "@@ -21,7 +21,7 @@ typedef vector<unsigned char> valtype;\n \n extern uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n extern bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n-                         bool fValidatePayToScriptHash, int nHashType);\n+                         bool fValidatePayToScriptHash, bool fStrictEncodings, int nHashType);\n \n BOOST_AUTO_TEST_SUITE(multisig_tests)\n \n@@ -80,19 +80,19 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n     keys.clear();\n     keys += key[0],key[1]; // magic operator+= from boost.assign\n     s = sign_multisig(a_and_b, keys, txTo[0], 0);\n-    BOOST_CHECK(VerifyScript(s, a_and_b, txTo[0], 0, true, 0));\n+    BOOST_CHECK(VerifyScript(s, a_and_b, txTo[0], 0, true, true, 0));\n \n     for (int i = 0; i < 4; i++)\n     {\n         keys.clear();\n         keys += key[i];\n         s = sign_multisig(a_and_b, keys, txTo[0], 0);\n-        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, txTo[0], 0, true, 0), strprintf(\"a&b 1: %d\", i));\n+        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, txTo[0], 0, true, true, 0), strprintf(\"a&b 1: %d\", i));\n \n         keys.clear();\n         keys += key[1],key[i];\n         s = sign_multisig(a_and_b, keys, txTo[0], 0);\n-        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, txTo[0], 0, true, 0), strprintf(\"a&b 2: %d\", i));\n+        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, txTo[0], 0, true, true, 0), strprintf(\"a&b 2: %d\", i));\n     }\n \n     // Test a OR b:\n@@ -102,16 +102,16 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n         keys += key[i];\n         s = sign_multisig(a_or_b, keys, txTo[1], 0);\n         if (i == 0 || i == 1)\n-            BOOST_CHECK_MESSAGE(VerifyScript(s, a_or_b, txTo[1], 0, true, 0), strprintf(\"a|b: %d\", i));\n+            BOOST_CHECK_MESSAGE(VerifyScript(s, a_or_b, txTo[1], 0, true, true, 0), strprintf(\"a|b: %d\", i));\n         else\n-            BOOST_CHECK_MESSAGE(!VerifyScript(s, a_or_b, txTo[1], 0, true, 0), strprintf(\"a|b: %d\", i));\n+            BOOST_CHECK_MESSAGE(!VerifyScript(s, a_or_b, txTo[1], 0, true, true, 0), strprintf(\"a|b: %d\", i));\n     }\n     s.clear();\n     s << OP_0 << OP_0;\n-    BOOST_CHECK(!VerifyScript(s, a_or_b, txTo[1], 0, true, 0));\n+    BOOST_CHECK(!VerifyScript(s, a_or_b, txTo[1], 0, true, true, 0));\n     s.clear();\n     s << OP_0 << OP_1;\n-    BOOST_CHECK(!VerifyScript(s, a_or_b, txTo[1], 0, true, 0));\n+    BOOST_CHECK(!VerifyScript(s, a_or_b, txTo[1], 0, true, true, 0));\n \n \n     for (int i = 0; i < 4; i++)\n@@ -121,9 +121,9 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n             keys += key[i],key[j];\n             s = sign_multisig(escrow, keys, txTo[2], 0);\n             if (i < j && i < 3 && j < 3)\n-                BOOST_CHECK_MESSAGE(VerifyScript(s, escrow, txTo[2], 0, true, 0), strprintf(\"escrow 1: %d %d\", i, j));\n+                BOOST_CHECK_MESSAGE(VerifyScript(s, escrow, txTo[2], 0, true, true, 0), strprintf(\"escrow 1: %d %d\", i, j));\n             else\n-                BOOST_CHECK_MESSAGE(!VerifyScript(s, escrow, txTo[2], 0, true, 0), strprintf(\"escrow 2: %d %d\", i, j));\n+                BOOST_CHECK_MESSAGE(!VerifyScript(s, escrow, txTo[2], 0, true, true, 0), strprintf(\"escrow 2: %d %d\", i, j));\n         }\n }\n "
      },
      {
        "sha": "9db584c1471f12291f274f4fce75dff7fc736b1e",
        "filename": "src/test/script_P2SH_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6/src/test/script_P2SH_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6/src/test/script_P2SH_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_P2SH_tests.cpp?ref=3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6",
        "patch": "@@ -14,7 +14,7 @@ using namespace std;\n // Test routines internal to script.cpp:\n extern uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n extern bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n-                         bool fValidatePayToScriptHash, int nHashType);\n+                         bool fValidatePayToScriptHash, bool fStrictEncodings, int nHashType);\n \n // Helpers:\n static std::vector<unsigned char>\n@@ -40,7 +40,7 @@ Verify(const CScript& scriptSig, const CScript& scriptPubKey, bool fStrict)\n     txTo.vin[0].scriptSig = scriptSig;\n     txTo.vout[0].nValue = 1;\n \n-    return VerifyScript(scriptSig, scriptPubKey, txTo, 0, fStrict, 0);\n+    return VerifyScript(scriptSig, scriptPubKey, txTo, 0, fStrict, true, 0);\n }\n \n \n@@ -105,7 +105,7 @@ BOOST_AUTO_TEST_CASE(sign)\n         {\n             CScript sigSave = txTo[i].vin[0].scriptSig;\n             txTo[i].vin[0].scriptSig = txTo[j].vin[0].scriptSig;\n-            bool sigOK = VerifySignature(txFrom, txTo[i], 0, true, 0);\n+            bool sigOK = VerifySignature(txFrom, txTo[i], 0, true, true, 0);\n             if (i == j)\n                 BOOST_CHECK_MESSAGE(sigOK, strprintf(\"VerifySignature %d %d\", i, j));\n             else"
      },
      {
        "sha": "f8e4fa8a49b407111be417f9f33b38dcb62e229c",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 20,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6",
        "patch": "@@ -21,7 +21,7 @@ using namespace boost::algorithm;\n \n extern uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n extern bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n-                         bool fValidatePayToScriptHash, int nHashType);\n+                         bool fValidatePayToScriptHash, bool fStrictEncodings, int nHashType);\n \n CScript\n ParseScript(string s)\n@@ -143,7 +143,7 @@ BOOST_AUTO_TEST_CASE(script_valid)\n         CScript scriptPubKey = ParseScript(scriptPubKeyString);\n \n         CTransaction tx;\n-        BOOST_CHECK_MESSAGE(VerifyScript(scriptSig, scriptPubKey, tx, 0, true, SIGHASH_NONE), strTest);\n+        BOOST_CHECK_MESSAGE(VerifyScript(scriptSig, scriptPubKey, tx, 0, true, true, SIGHASH_NONE), strTest);\n     }\n }\n \n@@ -167,7 +167,7 @@ BOOST_AUTO_TEST_CASE(script_invalid)\n         CScript scriptPubKey = ParseScript(scriptPubKeyString);\n \n         CTransaction tx;\n-        BOOST_CHECK_MESSAGE(!VerifyScript(scriptSig, scriptPubKey, tx, 0, true, SIGHASH_NONE), strTest);\n+        BOOST_CHECK_MESSAGE(!VerifyScript(scriptSig, scriptPubKey, tx, 0, true, true, SIGHASH_NONE), strTest);\n     }\n }\n \n@@ -181,18 +181,18 @@ BOOST_AUTO_TEST_CASE(script_PushData)\n     static const unsigned char pushdata4[] = { OP_PUSHDATA4, 1, 0, 0, 0, 0x5a };\n \n     vector<vector<unsigned char> > directStack;\n-    BOOST_CHECK(EvalScript(directStack, CScript(&direct[0], &direct[sizeof(direct)]), CTransaction(), 0, 0));\n+    BOOST_CHECK(EvalScript(directStack, CScript(&direct[0], &direct[sizeof(direct)]), CTransaction(), 0, true, 0));\n \n     vector<vector<unsigned char> > pushdata1Stack;\n-    BOOST_CHECK(EvalScript(pushdata1Stack, CScript(&pushdata1[0], &pushdata1[sizeof(pushdata1)]), CTransaction(), 0, 0));\n+    BOOST_CHECK(EvalScript(pushdata1Stack, CScript(&pushdata1[0], &pushdata1[sizeof(pushdata1)]), CTransaction(), 0, true, 0));\n     BOOST_CHECK(pushdata1Stack == directStack);\n \n     vector<vector<unsigned char> > pushdata2Stack;\n-    BOOST_CHECK(EvalScript(pushdata2Stack, CScript(&pushdata2[0], &pushdata2[sizeof(pushdata2)]), CTransaction(), 0, 0));\n+    BOOST_CHECK(EvalScript(pushdata2Stack, CScript(&pushdata2[0], &pushdata2[sizeof(pushdata2)]), CTransaction(), 0, true, 0));\n     BOOST_CHECK(pushdata2Stack == directStack);\n \n     vector<vector<unsigned char> > pushdata4Stack;\n-    BOOST_CHECK(EvalScript(pushdata4Stack, CScript(&pushdata4[0], &pushdata4[sizeof(pushdata4)]), CTransaction(), 0, 0));\n+    BOOST_CHECK(EvalScript(pushdata4Stack, CScript(&pushdata4[0], &pushdata4[sizeof(pushdata4)]), CTransaction(), 0, true, 0));\n     BOOST_CHECK(pushdata4Stack == directStack);\n }\n \n@@ -250,15 +250,15 @@ BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG12)\n     txTo12.vout[0].nValue = 1;\n \n     CScript goodsig1 = sign_multisig(scriptPubKey12, key1, txTo12);\n-    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey12, txTo12, 0, true, 0));\n+    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey12, txTo12, 0, true, true, 0));\n     txTo12.vout[0].nValue = 2;\n-    BOOST_CHECK(!VerifyScript(goodsig1, scriptPubKey12, txTo12, 0, true, 0));\n+    BOOST_CHECK(!VerifyScript(goodsig1, scriptPubKey12, txTo12, 0, true, true, 0));\n \n     CScript goodsig2 = sign_multisig(scriptPubKey12, key2, txTo12);\n-    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey12, txTo12, 0, true, 0));\n+    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey12, txTo12, 0, true, true, 0));\n \n     CScript badsig1 = sign_multisig(scriptPubKey12, key3, txTo12);\n-    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey12, txTo12, 0, true, 0));\n+    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey12, txTo12, 0, true, true, 0));\n }\n \n BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG23)\n@@ -286,46 +286,46 @@ BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG23)\n     std::vector<CKey> keys;\n     keys.push_back(key1); keys.push_back(key2);\n     CScript goodsig1 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey23, txTo23, 0, true, 0));\n+    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey23, txTo23, 0, true, true, 0));\n \n     keys.clear();\n     keys.push_back(key1); keys.push_back(key3);\n     CScript goodsig2 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey23, txTo23, 0, true, 0));\n+    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey23, txTo23, 0, true, true, 0));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key3);\n     CScript goodsig3 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(VerifyScript(goodsig3, scriptPubKey23, txTo23, 0, true, 0));\n+    BOOST_CHECK(VerifyScript(goodsig3, scriptPubKey23, txTo23, 0, true, true, 0));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key2); // Can't re-use sig\n     CScript badsig1 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey23, txTo23, 0, true, 0));\n+    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey23, txTo23, 0, true, true, 0));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key1); // sigs must be in correct order\n     CScript badsig2 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig2, scriptPubKey23, txTo23, 0, true, 0));\n+    BOOST_CHECK(!VerifyScript(badsig2, scriptPubKey23, txTo23, 0, true, true, 0));\n \n     keys.clear();\n     keys.push_back(key3); keys.push_back(key2); // sigs must be in correct order\n     CScript badsig3 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig3, scriptPubKey23, txTo23, 0, true, 0));\n+    BOOST_CHECK(!VerifyScript(badsig3, scriptPubKey23, txTo23, 0, true, true, 0));\n \n     keys.clear();\n     keys.push_back(key4); keys.push_back(key2); // sigs must match pubkeys\n     CScript badsig4 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig4, scriptPubKey23, txTo23, 0, true, 0));\n+    BOOST_CHECK(!VerifyScript(badsig4, scriptPubKey23, txTo23, 0, true, true, 0));\n \n     keys.clear();\n     keys.push_back(key1); keys.push_back(key4); // sigs must match pubkeys\n     CScript badsig5 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig5, scriptPubKey23, txTo23, 0, true, 0));\n+    BOOST_CHECK(!VerifyScript(badsig5, scriptPubKey23, txTo23, 0, true, true, 0));\n \n     keys.clear(); // Must have signatures\n     CScript badsig6 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig6, scriptPubKey23, txTo23, 0, true, 0));\n+    BOOST_CHECK(!VerifyScript(badsig6, scriptPubKey23, txTo23, 0, true, true, 0));\n }    \n \n BOOST_AUTO_TEST_CASE(script_combineSigs)"
      },
      {
        "sha": "1dacdeaa239295ef7d9f16d5a297dc6f5c3981da",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6",
        "patch": "@@ -76,7 +76,7 @@ BOOST_AUTO_TEST_CASE(tx_valid)\n                     break;\n                 }\n \n-                BOOST_CHECK_MESSAGE(VerifyScript(tx.vin[i].scriptSig, mapprevOutScriptPubKeys[tx.vin[i].prevout], tx, i, test[2].get_bool(), 0), strTest);\n+                BOOST_CHECK_MESSAGE(VerifyScript(tx.vin[i].scriptSig, mapprevOutScriptPubKeys[tx.vin[i].prevout], tx, i, test[2].get_bool(), false, 0), strTest);\n             }\n         }\n     }\n@@ -143,7 +143,7 @@ BOOST_AUTO_TEST_CASE(tx_invalid)\n                     break;\n                 }\n \n-                fValid = VerifyScript(tx.vin[i].scriptSig, mapprevOutScriptPubKeys[tx.vin[i].prevout], tx, i, test[2].get_bool(), 0);\n+                fValid = VerifyScript(tx.vin[i].scriptSig, mapprevOutScriptPubKeys[tx.vin[i].prevout], tx, i, test[2].get_bool(), true, 0);\n             }\n \n             BOOST_CHECK_MESSAGE(!fValid, strTest);"
      }
    ]
  },
  {
    "sha": "cc3e1f021e080cb4051ac26b088f89d690fb3354",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjYzNlMWYwMjFlMDgwY2I0MDUxYWMyNmIwODhmODlkNjkwZmIzMzU0",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-19T23:54:48Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-19T23:54:48Z"
      },
      "message": "Merge branch 'threadimport'",
      "tree": {
        "sha": "03ba74b23e9ccf077fc234e02af068cf40397fd1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/03ba74b23e9ccf077fc234e02af068cf40397fd1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cc3e1f021e080cb4051ac26b088f89d690fb3354",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cc3e1f021e080cb4051ac26b088f89d690fb3354",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cc3e1f021e080cb4051ac26b088f89d690fb3354",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cc3e1f021e080cb4051ac26b088f89d690fb3354/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3e4eec8cb6bf5b8cdfee448ce8df43e78b4c73a6"
      },
      {
        "sha": "66b02c93e69cfeaec6e7fa19a03bfb2649025a56",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/66b02c93e69cfeaec6e7fa19a03bfb2649025a56",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/66b02c93e69cfeaec6e7fa19a03bfb2649025a56"
      }
    ],
    "stats": {
      "total": 97,
      "additions": 70,
      "deletions": 27
    },
    "files": [
      {
        "sha": "92c752a8f5783d24ccc444c40ae7a19d56b9c94a",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 19,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cc3e1f021e080cb4051ac26b088f89d690fb3354/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cc3e1f021e080cb4051ac26b088f89d690fb3354/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=cc3e1f021e080cb4051ac26b088f89d690fb3354",
        "patch": "@@ -776,29 +776,13 @@ bool AppInit2()\n \n     // ********************************************************* Step 9: import blocks\n \n+    std::vector<boost::filesystem::path> *vPath = new std::vector<boost::filesystem::path>();\n     if (mapArgs.count(\"-loadblock\"))\n     {\n-        uiInterface.InitMessage(_(\"Importing blockchain data file.\"));\n-\n         BOOST_FOREACH(string strFile, mapMultiArgs[\"-loadblock\"])\n-        {\n-            FILE *file = fopen(strFile.c_str(), \"rb\");\n-            if (file)\n-                LoadExternalBlockFile(file);\n-        }\n-    }\n-\n-    filesystem::path pathBootstrap = GetDataDir() / \"bootstrap.dat\";\n-    if (filesystem::exists(pathBootstrap)) {\n-        uiInterface.InitMessage(_(\"Importing bootstrap blockchain data file.\"));\n-\n-        FILE *file = fopen(pathBootstrap.string().c_str(), \"rb\");\n-        if (file) {\n-            filesystem::path pathBootstrapOld = GetDataDir() / \"bootstrap.dat.old\";\n-            LoadExternalBlockFile(file);\n-            RenameOver(pathBootstrap, pathBootstrapOld);\n-        }\n+            vPath->push_back(strFile);\n     }\n+    NewThread(ThreadImport, vPath);\n \n     // ********************************************************* Step 10: load peers\n "
      },
      {
        "sha": "43bb4b179379057e7365e443a8815c9ebb4e3e1a",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 55,
        "deletions": 5,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cc3e1f021e080cb4051ac26b088f89d690fb3354/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cc3e1f021e080cb4051ac26b088f89d690fb3354/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=cc3e1f021e080cb4051ac26b088f89d690fb3354",
        "patch": "@@ -38,6 +38,7 @@ CBigNum bnBestInvalidWork = 0;\n uint256 hashBestChain = 0;\n CBlockIndex* pindexBest = NULL;\n int64 nTimeBestReceived = 0;\n+bool fImporting = false;\n \n CMedianFilter<int> cPeerBlockCounts(5, 0); // Amount of blocks that other nodes claim to have\n \n@@ -2251,7 +2252,6 @@ bool LoadExternalBlockFile(FILE* fileIn)\n \n     int nLoaded = 0;\n     {\n-        LOCK(cs_main);\n         try {\n             CAutoFile blkdat(fileIn, SER_DISK, CLIENT_VERSION);\n             unsigned int nPos = 0;\n@@ -2288,6 +2288,7 @@ bool LoadExternalBlockFile(FILE* fileIn)\n                 {\n                     CBlock block;\n                     blkdat >> block;\n+                    LOCK(cs_main);\n                     if (ProcessBlock(NULL,&block))\n                     {\n                         nLoaded++;\n@@ -2305,6 +2306,54 @@ bool LoadExternalBlockFile(FILE* fileIn)\n     return nLoaded > 0;\n }\n \n+struct CImportingNow\n+{\n+    CImportingNow() {\n+        assert(fImporting == false);\n+        fImporting = true;\n+    }\n+\n+    ~CImportingNow() {\n+        assert(fImporting == true);\n+        fImporting = false;\n+    }\n+};\n+\n+void ThreadImport(void *data) {\n+    std::vector<boost::filesystem::path> *vFiles = reinterpret_cast<std::vector<boost::filesystem::path>*>(data);\n+\n+    RenameThread(\"bitcoin-loadblk\");\n+\n+    CImportingNow imp;\n+    vnThreadsRunning[THREAD_IMPORT]++;\n+\n+    // -loadblock=\n+    uiInterface.InitMessage(_(\"Starting block import...\"));\n+    BOOST_FOREACH(boost::filesystem::path &path, *vFiles) {\n+        FILE *file = fopen(path.string().c_str(), \"rb\");\n+        if (file)\n+            LoadExternalBlockFile(file);\n+    }\n+\n+    // hardcoded $DATADIR/bootstrap.dat\n+    filesystem::path pathBootstrap = GetDataDir() / \"bootstrap.dat\";\n+    if (filesystem::exists(pathBootstrap)) {\n+        uiInterface.InitMessage(_(\"Importing bootstrap blockchain data file.\"));\n+\n+        FILE *file = fopen(pathBootstrap.string().c_str(), \"rb\");\n+        if (file) {\n+            filesystem::path pathBootstrapOld = GetDataDir() / \"bootstrap.dat.old\";\n+            LoadExternalBlockFile(file);\n+            RenameOver(pathBootstrap, pathBootstrapOld);\n+        }\n+    }\n+\n+    delete vFiles;\n+\n+    vnThreadsRunning[THREAD_IMPORT]--;\n+}\n+\n+\n \n \n \n@@ -2512,7 +2561,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n \n         // Ask the first connected node for block updates\n         static int nAskedForBlocks = 0;\n-        if (!pfrom->fClient && !pfrom->fOneShot &&\n+        if (!pfrom->fClient && !pfrom->fOneShot && !fImporting &&\n             (pfrom->nStartingHeight > (nBestHeight - 144)) &&\n             (pfrom->nVersion < NOBLKS_VERSION_START ||\n              pfrom->nVersion >= NOBLKS_VERSION_END) &&\n@@ -2649,9 +2698,10 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n             if (fDebug)\n                 printf(\"  got inventory: %s  %s\\n\", inv.ToString().c_str(), fAlreadyHave ? \"have\" : \"new\");\n \n-            if (!fAlreadyHave)\n-                pfrom->AskFor(inv);\n-            else if (inv.type == MSG_BLOCK && mapOrphanBlocks.count(inv.hash)) {\n+            if (!fAlreadyHave) {\n+                if (!fImporting)\n+                    pfrom->AskFor(inv);\n+            } else if (inv.type == MSG_BLOCK && mapOrphanBlocks.count(inv.hash)) {\n                 pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(mapOrphanBlocks[inv.hash]));\n             } else if (nInv == nLastBlock) {\n                 // In case we are on a very long side-chain, it is possible that we already have"
      },
      {
        "sha": "ea71baf902ed7e5b0253d4cda0417740c2421355",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cc3e1f021e080cb4051ac26b088f89d690fb3354/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cc3e1f021e080cb4051ac26b088f89d690fb3354/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=cc3e1f021e080cb4051ac26b088f89d690fb3354",
        "patch": "@@ -68,6 +68,7 @@ extern int64 nTimeBestReceived;\n extern CCriticalSection cs_setpwalletRegistered;\n extern std::set<CWallet*> setpwalletRegistered;\n extern unsigned char pchMessageStart[4];\n+extern bool fImporting;\n \n // Settings\n extern int64 nTransactionFee;\n@@ -92,7 +93,7 @@ void PrintBlockTree();\n CBlockIndex* FindBlockByHeight(int nHeight);\n bool ProcessMessages(CNode* pfrom);\n bool SendMessages(CNode* pto, bool fSendTrickle);\n-bool LoadExternalBlockFile(FILE* fileIn);\n+void ThreadImport(void *parg);\n void GenerateBitcoins(bool fGenerate, CWallet* pwallet);\n CBlock* CreateNewBlock(CReserveKey& reservekey);\n void IncrementExtraNonce(CBlock* pblock, CBlockIndex* pindexPrev, unsigned int& nExtraNonce);"
      },
      {
        "sha": "5e1564f9ca7c592c7a7acb2049a119b3ac0a0d73",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cc3e1f021e080cb4051ac26b088f89d690fb3354/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cc3e1f021e080cb4051ac26b088f89d690fb3354/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=cc3e1f021e080cb4051ac26b088f89d690fb3354",
        "patch": "@@ -106,6 +106,7 @@ enum threadId\n     THREAD_ADDEDCONNECTIONS,\n     THREAD_DUMPADDRESS,\n     THREAD_RPCHANDLER,\n+    THREAD_IMPORT,\n \n     THREAD_MAX\n };"
      },
      {
        "sha": "0d269ea210876d91ce563e0e07b8e79092e893cb",
        "filename": "src/qt/bitcoingui.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cc3e1f021e080cb4051ac26b088f89d690fb3354/src/qt/bitcoingui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cc3e1f021e080cb4051ac26b088f89d690fb3354/src/qt/bitcoingui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.cpp?ref=cc3e1f021e080cb4051ac26b088f89d690fb3354",
        "patch": "@@ -473,7 +473,7 @@ void BitcoinGUI::setNumConnections(int count)\n void BitcoinGUI::setNumBlocks(int count, int nTotalBlocks)\n {\n     // don't show / hide progress bar and its label if we have no connection to the network\n-    if (!clientModel || clientModel->getNumConnections() == 0)\n+    if (!clientModel || (clientModel->getNumConnections() == 0 && !clientModel->isImporting()))\n     {\n         progressBarLabel->setVisible(false);\n         progressBar->setVisible(false);\n@@ -491,7 +491,7 @@ void BitcoinGUI::setNumBlocks(int count, int nTotalBlocks)\n \n         if (strStatusBarWarnings.isEmpty())\n         {\n-            progressBarLabel->setText(tr(\"Synchronizing with network...\"));\n+            progressBarLabel->setText(tr(clientModel->isImporting() ? \"Importing blocks...\" : \"Synchronizing with network...\"));\n             progressBarLabel->setVisible(true);\n             progressBar->setFormat(tr(\"~%n block(s) remaining\", \"\", nRemainingBlocks));\n             progressBar->setMaximum(nTotalBlocks);"
      },
      {
        "sha": "990b364a94329ee95c902f4c8d930ee884cd3466",
        "filename": "src/qt/clientmodel.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cc3e1f021e080cb4051ac26b088f89d690fb3354/src/qt/clientmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cc3e1f021e080cb4051ac26b088f89d690fb3354/src/qt/clientmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.cpp?ref=cc3e1f021e080cb4051ac26b088f89d690fb3354",
        "patch": "@@ -103,6 +103,11 @@ bool ClientModel::inInitialBlockDownload() const\n     return IsInitialBlockDownload();\n }\n \n+bool ClientModel::isImporting() const\n+{\n+    return fImporting;\n+}\n+\n int ClientModel::getNumBlocksOfPeers() const\n {\n     return GetNumBlocksOfPeers();"
      },
      {
        "sha": "926390a07a6c9f3707a484c6d15dbee40b3028e4",
        "filename": "src/qt/clientmodel.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cc3e1f021e080cb4051ac26b088f89d690fb3354/src/qt/clientmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cc3e1f021e080cb4051ac26b088f89d690fb3354/src/qt/clientmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.h?ref=cc3e1f021e080cb4051ac26b088f89d690fb3354",
        "patch": "@@ -33,6 +33,8 @@ class ClientModel : public QObject\n     bool isTestNet() const;\n     //! Return true if core is doing initial block download\n     bool inInitialBlockDownload() const;\n+    //! Return true if core is importing blocks\n+    bool isImporting() const;\n     //! Return conservative estimate of total number of blocks, or 0 if unknown\n     int getNumBlocksOfPeers() const;\n     //! Return warnings to be displayed in status bar"
      }
    ]
  },
  {
    "sha": "398e837e8da881e4d3f13da83590626ae76bb977",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozOThlODM3ZThkYTg4MWU0ZDNmMTNkYTgzNTkwNjI2YWU3NmJiOTc3",
    "commit": {
      "author": {
        "name": "Mike Hearn",
        "email": "hearn@google.com",
        "date": "2012-06-25T09:17:22Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-19T23:55:51Z"
      },
      "message": "Import LevelDB 1.5, it will be used for the transaction database.",
      "tree": {
        "sha": "bef5ac4e7bfa9845b23ea975be58fa3fe108ef4b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bef5ac4e7bfa9845b23ea975be58fa3fe108ef4b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/398e837e8da881e4d3f13da83590626ae76bb977",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/398e837e8da881e4d3f13da83590626ae76bb977",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/398e837e8da881e4d3f13da83590626ae76bb977",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/398e837e8da881e4d3f13da83590626ae76bb977/comments",
    "author": null,
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "cc3e1f021e080cb4051ac26b088f89d690fb3354",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cc3e1f021e080cb4051ac26b088f89d690fb3354",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cc3e1f021e080cb4051ac26b088f89d690fb3354"
      }
    ],
    "stats": {
      "total": 25492,
      "additions": 25488,
      "deletions": 4
    },
    "files": [
      {
        "sha": "b11949171e9920dc699f160263b2eff6d3bae4d2",
        "filename": ".gitignore",
        "status": "modified",
        "additions": 10,
        "deletions": 4,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.gitignore?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -10,14 +10,20 @@ src/test_bitcoin\n *.o\n *.patch\n .bitcoin\n-#compilation and Qt preprocessor part\n+\n+# Compilation and Qt preprocessor part\n *.qm\n Makefile\n bitcoin-qt\n-#resources cpp\n+\n+# Resources cpp\n qrc_*.cpp\n-#qt creator\n+\n+# Qt creator\n *.pro.user\n-#mac specific\n+\n+# Mac specific\n .DS_Store\n build\n+\n+!src/leveldb-*/Makefile"
      },
      {
        "sha": "f0304305656c9c6d44971baa20f812c94536caf0",
        "filename": "src/leveldb/.gitignore",
        "status": "added",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/.gitignore?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,8 @@\n+build_config.mk\n+*.a\n+*.o\n+*.dylib*\n+*.so\n+*.so.*\n+*_test\n+db_bench"
      },
      {
        "sha": "27a9407e52fdc517f3ab28741e0426c3180d444e",
        "filename": "src/leveldb/AUTHORS",
        "status": "added",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/AUTHORS",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/AUTHORS",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/AUTHORS?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,8 @@\n+# Names should be added to this file like so:\n+# Name or Organization <email address>\n+\n+Google Inc.\n+\n+# Initial version authors:\n+Jeffrey Dean <jeff@google.com>\n+Sanjay Ghemawat <sanjay@google.com>"
      },
      {
        "sha": "8e80208cd72b3225c87d9111c4d7cab13af1c2ac",
        "filename": "src/leveldb/LICENSE",
        "status": "added",
        "additions": 27,
        "deletions": 0,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/LICENSE",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/LICENSE",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/LICENSE?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,27 @@\n+Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+   * Redistributions of source code must retain the above copyright\n+notice, this list of conditions and the following disclaimer.\n+   * Redistributions in binary form must reproduce the above\n+copyright notice, this list of conditions and the following disclaimer\n+in the documentation and/or other materials provided with the\n+distribution.\n+   * Neither the name of Google Inc. nor the names of its\n+contributors may be used to endorse or promote products derived from\n+this software without specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
      },
      {
        "sha": "c648a285ea0b8c295c010b6e3e5786983aa37125",
        "filename": "src/leveldb/Makefile",
        "status": "added",
        "additions": 200,
        "deletions": 0,
        "changes": 200,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/Makefile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/Makefile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/Makefile?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,200 @@\n+# Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+# Use of this source code is governed by a BSD-style license that can be\n+# found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+# Inherit some settings from environment variables, if available\n+INSTALL_PATH ?= $(CURDIR)\n+\n+#-----------------------------------------------\n+# Uncomment exactly one of the lines labelled (A), (B), and (C) below\n+# to switch between compilation modes.\n+\n+OPT ?= -O2 -DNDEBUG       # (A) Production use (optimized mode)\n+# OPT ?= -g2              # (B) Debug mode, w/ full line-level debugging symbols\n+# OPT ?= -O2 -g2 -DNDEBUG # (C) Profiling mode: opt, but w/debugging symbols\n+#-----------------------------------------------\n+\n+# detect what platform we're building on\n+$(shell ./build_detect_platform build_config.mk)\n+# this file is generated by the previous line to set build flags and sources\n+include build_config.mk\n+\n+CFLAGS += -I. -I./include $(PLATFORM_CCFLAGS) $(OPT)\n+CXXFLAGS += -I. -I./include $(PLATFORM_CXXFLAGS) $(OPT)\n+\n+LDFLAGS += $(PLATFORM_LDFLAGS)\n+\n+LIBOBJECTS = $(SOURCES:.cc=.o)\n+MEMENVOBJECTS = $(MEMENV_SOURCES:.cc=.o)\n+\n+TESTUTIL = ./util/testutil.o\n+TESTHARNESS = ./util/testharness.o $(TESTUTIL)\n+\n+TESTS = \\\n+\tarena_test \\\n+\tbloom_test \\\n+\tc_test \\\n+\tcache_test \\\n+\tcoding_test \\\n+\tcorruption_test \\\n+\tcrc32c_test \\\n+\tdb_test \\\n+\tdbformat_test \\\n+\tenv_test \\\n+\tfilename_test \\\n+\tfilter_block_test \\\n+\tlog_test \\\n+\tmemenv_test \\\n+\tskiplist_test \\\n+\ttable_test \\\n+\tversion_edit_test \\\n+\tversion_set_test \\\n+\twrite_batch_test\n+\n+PROGRAMS = db_bench $(TESTS)\n+BENCHMARKS = db_bench_sqlite3 db_bench_tree_db\n+\n+LIBRARY = libleveldb.a\n+MEMENVLIBRARY = libmemenv.a\n+\n+default: all\n+\n+# Should we build shared libraries?\n+ifneq ($(PLATFORM_SHARED_EXT),)\n+\n+ifneq ($(PLATFORM_SHARED_VERSIONED),true)\n+SHARED1 = libleveldb.$(PLATFORM_SHARED_EXT)\n+SHARED2 = $(SHARED1)\n+SHARED3 = $(SHARED1)\n+SHARED = $(SHARED1)\n+else\n+# Update db.h if you change these.\n+SHARED_MAJOR = 1\n+SHARED_MINOR = 5\n+SHARED1 = libleveldb.$(PLATFORM_SHARED_EXT)\n+SHARED2 = $(SHARED1).$(SHARED_MAJOR)\n+SHARED3 = $(SHARED1).$(SHARED_MAJOR).$(SHARED_MINOR)\n+SHARED = $(SHARED1) $(SHARED2) $(SHARED3)\n+$(SHARED1): $(SHARED3)\n+\tln -fs $(SHARED3) $(SHARED1)\n+$(SHARED2): $(SHARED3)\n+\tln -fs $(SHARED3) $(SHARED2)\n+endif\n+\n+$(SHARED3):\n+\t$(CXX) $(LDFLAGS) $(PLATFORM_SHARED_LDFLAGS)$(SHARED2) $(CXXFLAGS) $(PLATFORM_SHARED_CFLAGS) $(SOURCES) -o $(SHARED3)\n+\n+endif  # PLATFORM_SHARED_EXT\n+\n+all: $(SHARED) $(LIBRARY)\n+\n+check: all $(PROGRAMS) $(TESTS)\n+\tfor t in $(TESTS); do echo \"***** Running $$t\"; ./$$t || exit 1; done\n+\n+clean:\n+\t-rm -f $(PROGRAMS) $(BENCHMARKS) $(LIBRARY) $(SHARED) $(MEMENVLIBRARY) */*.o */*/*.o ios-x86/*/*.o ios-arm/*/*.o build_config.mk\n+\t-rm -rf ios-x86/* ios-arm/*\n+\n+$(LIBRARY): $(LIBOBJECTS)\n+\trm -f $@\n+\t$(AR) -rs $@ $(LIBOBJECTS)\n+\n+db_bench: db/db_bench.o $(LIBOBJECTS) $(TESTUTIL)\n+\t$(CXX) db/db_bench.o $(LIBOBJECTS) $(TESTUTIL) -o $@  $(LDFLAGS)\n+\n+db_bench_sqlite3: doc/bench/db_bench_sqlite3.o $(LIBOBJECTS) $(TESTUTIL)\n+\t$(CXX) doc/bench/db_bench_sqlite3.o $(LIBOBJECTS) $(TESTUTIL) -o $@ $(LDFLAGS) -lsqlite3\n+\n+db_bench_tree_db: doc/bench/db_bench_tree_db.o $(LIBOBJECTS) $(TESTUTIL)\n+\t$(CXX) doc/bench/db_bench_tree_db.o $(LIBOBJECTS) $(TESTUTIL) -o $@ $(LDFLAGS) -lkyotocabinet\n+\n+arena_test: util/arena_test.o $(LIBOBJECTS) $(TESTHARNESS)\n+\t$(CXX) util/arena_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\n+bloom_test: util/bloom_test.o $(LIBOBJECTS) $(TESTHARNESS)\n+\t$(CXX) util/bloom_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\n+c_test: db/c_test.o $(LIBOBJECTS) $(TESTHARNESS)\n+\t$(CXX) db/c_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\n+cache_test: util/cache_test.o $(LIBOBJECTS) $(TESTHARNESS)\n+\t$(CXX) util/cache_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\n+coding_test: util/coding_test.o $(LIBOBJECTS) $(TESTHARNESS)\n+\t$(CXX) util/coding_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\n+corruption_test: db/corruption_test.o $(LIBOBJECTS) $(TESTHARNESS)\n+\t$(CXX) db/corruption_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\n+crc32c_test: util/crc32c_test.o $(LIBOBJECTS) $(TESTHARNESS)\n+\t$(CXX) util/crc32c_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\n+db_test: db/db_test.o $(LIBOBJECTS) $(TESTHARNESS)\n+\t$(CXX) db/db_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\n+dbformat_test: db/dbformat_test.o $(LIBOBJECTS) $(TESTHARNESS)\n+\t$(CXX) db/dbformat_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\n+env_test: util/env_test.o $(LIBOBJECTS) $(TESTHARNESS)\n+\t$(CXX) util/env_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\n+filename_test: db/filename_test.o $(LIBOBJECTS) $(TESTHARNESS)\n+\t$(CXX) db/filename_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\n+filter_block_test: table/filter_block_test.o $(LIBOBJECTS) $(TESTHARNESS)\n+\t$(CXX) table/filter_block_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\n+log_test: db/log_test.o $(LIBOBJECTS) $(TESTHARNESS)\n+\t$(CXX) db/log_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\n+table_test: table/table_test.o $(LIBOBJECTS) $(TESTHARNESS)\n+\t$(CXX) table/table_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\n+skiplist_test: db/skiplist_test.o $(LIBOBJECTS) $(TESTHARNESS)\n+\t$(CXX) db/skiplist_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\n+version_edit_test: db/version_edit_test.o $(LIBOBJECTS) $(TESTHARNESS)\n+\t$(CXX) db/version_edit_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\n+version_set_test: db/version_set_test.o $(LIBOBJECTS) $(TESTHARNESS)\n+\t$(CXX) db/version_set_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\n+write_batch_test: db/write_batch_test.o $(LIBOBJECTS) $(TESTHARNESS)\n+\t$(CXX) db/write_batch_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\n+$(MEMENVLIBRARY) : $(MEMENVOBJECTS)\n+\trm -f $@\n+\t$(AR) -rs $@ $(MEMENVOBJECTS)\n+\n+memenv_test : helpers/memenv/memenv_test.o $(MEMENVLIBRARY) $(LIBRARY) $(TESTHARNESS)\n+\t$(CXX) helpers/memenv/memenv_test.o $(MEMENVLIBRARY) $(LIBRARY) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\n+ifeq ($(PLATFORM), IOS)\n+# For iOS, create universal object files to be used on both the simulator and\n+# a device.\n+PLATFORMSROOT=/Applications/Xcode.app/Contents/Developer/Platforms\n+SIMULATORROOT=$(PLATFORMSROOT)/iPhoneSimulator.platform/Developer\n+DEVICEROOT=$(PLATFORMSROOT)/iPhoneOS.platform/Developer\n+IOSVERSION=$(shell defaults read $(PLATFORMSROOT)/iPhoneOS.platform/version CFBundleShortVersionString)\n+\n+.cc.o:\n+\tmkdir -p ios-x86/$(dir $@)\n+\t$(SIMULATORROOT)/usr/bin/$(CXX) $(CXXFLAGS) -isysroot $(SIMULATORROOT)/SDKs/iPhoneSimulator$(IOSVERSION).sdk -arch i686 -c $< -o ios-x86/$@\n+\tmkdir -p ios-arm/$(dir $@)\n+\t$(DEVICEROOT)/usr/bin/$(CXX) $(CXXFLAGS) -isysroot $(DEVICEROOT)/SDKs/iPhoneOS$(IOSVERSION).sdk -arch armv6 -arch armv7 -c $< -o ios-arm/$@\n+\tlipo ios-x86/$@ ios-arm/$@ -create -output $@\n+\n+.c.o:\n+\tmkdir -p ios-x86/$(dir $@)\n+\t$(SIMULATORROOT)/usr/bin/$(CC) $(CFLAGS) -isysroot $(SIMULATORROOT)/SDKs/iPhoneSimulator$(IOSVERSION).sdk -arch i686 -c $< -o ios-x86/$@\n+\tmkdir -p ios-arm/$(dir $@)\n+\t$(DEVICEROOT)/usr/bin/$(CC) $(CFLAGS) -isysroot $(DEVICEROOT)/SDKs/iPhoneOS$(IOSVERSION).sdk -arch armv6 -arch armv7 -c $< -o ios-arm/$@\n+\tlipo ios-x86/$@ ios-arm/$@ -create -output $@\n+\n+else\n+.cc.o:\n+\t$(CXX) $(CXXFLAGS) -c $< -o $@\n+\n+.c.o:\n+\t$(CC) $(CFLAGS) -c $< -o $@\n+endif"
      },
      {
        "sha": "2bf787ef23a5fe16afbe079bd313baa57f6fbd01",
        "filename": "src/leveldb/README",
        "status": "added",
        "additions": 59,
        "deletions": 0,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/README",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/README",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/README?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,59 @@\n+LevelDB is a third party library used for the transaction database.\n+It is imported into the Bitcoin codebase due to being relatively new\n+and not widely packaged.\n+\n+\n+\n+---------------------------------------------------------------------\n+\n+leveldb: A key-value store\n+Authors: Sanjay Ghemawat (sanjay@google.com) and Jeff Dean (jeff@google.com)\n+\n+The code under this directory implements a system for maintaining a\n+persistent key/value store.\n+\n+See doc/index.html for more explanation.\n+See doc/impl.html for a brief overview of the implementation.\n+\n+The public interface is in include/*.h.  Callers should not include or\n+rely on the details of any other header files in this package.  Those\n+internal APIs may be changed without warning.\n+\n+Guide to header files:\n+\n+include/db.h\n+    Main interface to the DB: Start here\n+\n+include/options.h\n+    Control over the behavior of an entire database, and also\n+    control over the behavior of individual reads and writes.\n+\n+include/comparator.h\n+    Abstraction for user-specified comparison function.  If you want\n+    just bytewise comparison of keys, you can use the default comparator,\n+    but clients can write their own comparator implementations if they\n+    want custom ordering (e.g. to handle different character\n+    encodings, etc.)\n+\n+include/iterator.h\n+    Interface for iterating over data. You can get an iterator\n+    from a DB object.\n+\n+include/write_batch.h\n+    Interface for atomically applying multiple updates to a database.\n+\n+include/slice.h\n+    A simple module for maintaining a pointer and a length into some\n+    other byte array.\n+\n+include/status.h\n+    Status is returned from many of the public interfaces and is used\n+    to report success and various kinds of errors.\n+\n+include/env.h\n+    Abstraction of the OS environment.  A posix implementation of\n+    this interface is in util/env_posix.cc\n+\n+include/table.h\n+include/table_builder.h\n+    Lower-level modules that most clients probably won't use directly"
      },
      {
        "sha": "9130b6a9fad2982ce61541530521856cde503618",
        "filename": "src/leveldb/TODO",
        "status": "added",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/TODO",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/TODO",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/TODO?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,13 @@\n+ss\n+- Stats\n+\n+db\n+- Maybe implement DB::BulkDeleteForRange(start_key, end_key)\n+  that would blow away files whose ranges are entirely contained\n+  within [start_key..end_key]?  For Chrome, deletion of obsolete\n+  object stores, etc. can be done in the background anyway, so\n+  probably not that important.\n+\n+After a range is completely deleted, what gets rid of the\n+corresponding files if we do no future changes to that range.  Make\n+the conditions for triggering compactions fire in more situations?"
      },
      {
        "sha": "959a7d6f590f07b2527c48081cf55bae25e98865",
        "filename": "src/leveldb/build_detect_platform",
        "status": "added",
        "additions": 179,
        "deletions": 0,
        "changes": 179,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/build_detect_platform",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/build_detect_platform",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/build_detect_platform?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,179 @@\n+#!/bin/sh\n+#\n+# Detects OS we're compiling on and outputs a file specified by the first\n+# argument, which in turn gets read while processing Makefile.\n+#\n+# The output will set the following variables:\n+#   CC                          C Compiler path\n+#   CXX                         C++ Compiler path\n+#   PLATFORM_LDFLAGS            Linker flags\n+#   PLATFORM_SHARED_EXT         Extension for shared libraries\n+#   PLATFORM_SHARED_LDFLAGS     Flags for building shared library\n+#   PLATFORM_SHARED_CFLAGS      Flags for compiling objects for shared library\n+#   PLATFORM_CCFLAGS            C compiler flags\n+#   PLATFORM_CXXFLAGS           C++ compiler flags.  Will contain:\n+#   PLATFORM_SHARED_VERSIONED   Set to 'true' if platform supports versioned\n+#                               shared libraries, empty otherwise.\n+#\n+# The PLATFORM_CCFLAGS and PLATFORM_CXXFLAGS might include the following:\n+#\n+#       -DLEVELDB_CSTDATOMIC_PRESENT if <cstdatomic> is present\n+#       -DLEVELDB_PLATFORM_POSIX     for Posix-based platforms\n+#       -DSNAPPY                     if the Snappy library is present\n+#\n+\n+OUTPUT=$1\n+if test -z \"$OUTPUT\"; then\n+  echo \"usage: $0 <output-filename>\" >&2\n+  exit 1\n+fi\n+\n+# Delete existing output, if it exists\n+rm -f $OUTPUT\n+touch $OUTPUT\n+\n+if test -z \"$CC\"; then\n+    CC=cc\n+fi\n+\n+if test -z \"$CXX\"; then\n+    CXX=g++\n+fi\n+\n+# Detect OS\n+if test -z \"$TARGET_OS\"; then\n+    TARGET_OS=`uname -s`\n+fi\n+\n+COMMON_FLAGS=\n+CROSS_COMPILE=\n+PLATFORM_CCFLAGS=\n+PLATFORM_CXXFLAGS=\n+PLATFORM_LDFLAGS=\n+PLATFORM_SHARED_EXT=\"so\"\n+PLATFORM_SHARED_LDFLAGS=\"-shared -Wl,-soname -Wl,\"\n+PLATFORM_SHARED_CFLAGS=\"-fPIC\"\n+PLATFORM_SHARED_VERSIONED=true\n+\n+# On GCC, we pick libc's memcmp over GCC's memcmp via -fno-builtin-memcmp\n+case \"$TARGET_OS\" in\n+    Darwin)\n+        PLATFORM=OS_MACOSX\n+        COMMON_FLAGS=\"-fno-builtin-memcmp -DOS_MACOSX\"\n+        PLATFORM_SHARED_EXT=dylib\n+        PLATFORM_SHARED_LDFLAGS=\"-dynamiclib -install_name \"\n+        PORT_FILE=port/port_posix.cc\n+        ;;\n+    Linux)\n+        PLATFORM=OS_LINUX\n+        COMMON_FLAGS=\"-fno-builtin-memcmp -pthread -DOS_LINUX\"\n+        PLATFORM_LDFLAGS=\"-pthread\"\n+        PORT_FILE=port/port_posix.cc\n+        ;;\n+    SunOS)\n+        PLATFORM=OS_SOLARIS\n+        COMMON_FLAGS=\"-fno-builtin-memcmp -D_REENTRANT -DOS_SOLARIS\"\n+        PLATFORM_LDFLAGS=\"-lpthread -lrt\"\n+        PORT_FILE=port/port_posix.cc\n+        ;;\n+    FreeBSD)\n+        PLATFORM=OS_FREEBSD\n+        COMMON_FLAGS=\"-fno-builtin-memcmp -D_REENTRANT -DOS_FREEBSD\"\n+        PLATFORM_LDFLAGS=\"-lpthread\"\n+        PORT_FILE=port/port_posix.cc\n+        ;;\n+    NetBSD)\n+        PLATFORM=OS_NETBSD\n+        COMMON_FLAGS=\"-fno-builtin-memcmp -D_REENTRANT -DOS_NETBSD\"\n+        PLATFORM_LDFLAGS=\"-lpthread -lgcc_s\"\n+        PORT_FILE=port/port_posix.cc\n+        ;;\n+    OpenBSD)\n+        PLATFORM=OS_OPENBSD\n+        COMMON_FLAGS=\"-fno-builtin-memcmp -D_REENTRANT -DOS_OPENBSD\"\n+        PLATFORM_LDFLAGS=\"-pthread\"\n+        PORT_FILE=port/port_posix.cc\n+        ;;\n+    DragonFly)\n+        PLATFORM=OS_DRAGONFLYBSD\n+        COMMON_FLAGS=\"-fno-builtin-memcmp -D_REENTRANT -DOS_DRAGONFLYBSD\"\n+        PLATFORM_LDFLAGS=\"-lpthread\"\n+        PORT_FILE=port/port_posix.cc\n+        ;;\n+    OS_ANDROID_CROSSCOMPILE)\n+        PLATFORM=OS_ANDROID\n+        COMMON_FLAGS=\"-fno-builtin-memcmp -D_REENTRANT -DOS_ANDROID -DLEVELDB_PLATFORM_POSIX\"\n+        PLATFORM_LDFLAGS=\"\"  # All pthread features are in the Android C library\n+        PORT_FILE=port/port_posix.cc\n+        CROSS_COMPILE=true\n+        ;;\n+    *)\n+        echo \"Unknown platform!\" >&2\n+        exit 1\n+esac\n+\n+# We want to make a list of all cc files within util, db, table, and helpers\n+# except for the test and benchmark files. By default, find will output a list\n+# of all files matching either rule, so we need to append -print to make the\n+# prune take effect.\n+DIRS=\"util db table\"\n+set -f # temporarily disable globbing so that our patterns aren't expanded\n+PRUNE_TEST=\"-name *test*.cc -prune\"\n+PRUNE_BENCH=\"-name *_bench.cc -prune\"\n+PORTABLE_FILES=`find $DIRS $PRUNE_TEST -o $PRUNE_BENCH -o -name '*.cc' -print | sort | tr \"\\n\" \" \"`\n+set +f # re-enable globbing\n+\n+# The sources consist of the portable files, plus the platform-specific port\n+# file.\n+echo \"SOURCES=$PORTABLE_FILES $PORT_FILE\" >> $OUTPUT\n+echo \"MEMENV_SOURCES=helpers/memenv/memenv.cc\" >> $OUTPUT\n+\n+if [ \"$CROSS_COMPILE\" = \"true\" ]; then\n+    # Cross-compiling; do not try any compilation tests.\n+    true\n+else\n+    # If -std=c++0x works, use <cstdatomic>.  Otherwise use port_posix.h.\n+    $CXX $CFLAGS -std=c++0x -x c++ - -o /dev/null 2>/dev/null  <<EOF\n+      #include <cstdatomic>\n+      int main() {}\n+EOF\n+    if [ \"$?\" = 0 ]; then\n+        COMMON_FLAGS=\"$COMMON_FLAGS -DLEVELDB_PLATFORM_POSIX -DLEVELDB_CSTDATOMIC_PRESENT\"\n+        PLATFORM_CXXFLAGS=\"-std=c++0x\"\n+    else\n+        COMMON_FLAGS=\"$COMMON_FLAGS -DLEVELDB_PLATFORM_POSIX\"\n+    fi\n+\n+    # Test whether Snappy library is installed\n+    # http://code.google.com/p/snappy/\n+    $CXX $CFLAGS -x c++ - -o /dev/null 2>/dev/null  <<EOF\n+      #include <snappy.h>\n+      int main() {}\n+EOF\n+    if [ \"$?\" = 0 ]; then\n+        COMMON_FLAGS=\"$COMMON_FLAGS -DSNAPPY\"\n+        PLATFORM_LDFLAGS=\"$PLATFORM_LDFLAGS -lsnappy\"\n+    fi\n+\n+    # Test whether tcmalloc is available\n+    $CXX $CFLAGS -x c++ - -o /dev/null -ltcmalloc 2>/dev/null  <<EOF\n+      int main() {}\n+EOF\n+    if [ \"$?\" = 0 ]; then\n+        PLATFORM_LDFLAGS=\"$PLATFORM_LDFLAGS -ltcmalloc\"\n+    fi\n+fi\n+\n+PLATFORM_CCFLAGS=\"$PLATFORM_CCFLAGS $COMMON_FLAGS\"\n+PLATFORM_CXXFLAGS=\"$PLATFORM_CXXFLAGS $COMMON_FLAGS\"\n+\n+echo \"CC=$CC\" >> $OUTPUT\n+echo \"CXX=$CXX\" >> $OUTPUT\n+echo \"PLATFORM=$PLATFORM\" >> $OUTPUT\n+echo \"PLATFORM_LDFLAGS=$PLATFORM_LDFLAGS\" >> $OUTPUT\n+echo \"PLATFORM_CCFLAGS=$PLATFORM_CCFLAGS\" >> $OUTPUT\n+echo \"PLATFORM_CXXFLAGS=$PLATFORM_CXXFLAGS\" >> $OUTPUT\n+echo \"PLATFORM_SHARED_CFLAGS=$PLATFORM_SHARED_CFLAGS\" >> $OUTPUT\n+echo \"PLATFORM_SHARED_EXT=$PLATFORM_SHARED_EXT\" >> $OUTPUT\n+echo \"PLATFORM_SHARED_LDFLAGS=$PLATFORM_SHARED_LDFLAGS\" >> $OUTPUT\n+echo \"PLATFORM_SHARED_VERSIONED=$PLATFORM_SHARED_VERSIONED\" >> $OUTPUT"
      },
      {
        "sha": "f4198821973c94f2e28148f79a10ca2c48d8d1e6",
        "filename": "src/leveldb/db/builder.cc",
        "status": "added",
        "additions": 88,
        "deletions": 0,
        "changes": 88,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/builder.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/builder.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/builder.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,88 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include \"db/builder.h\"\n+\n+#include \"db/filename.h\"\n+#include \"db/dbformat.h\"\n+#include \"db/table_cache.h\"\n+#include \"db/version_edit.h\"\n+#include \"leveldb/db.h\"\n+#include \"leveldb/env.h\"\n+#include \"leveldb/iterator.h\"\n+\n+namespace leveldb {\n+\n+Status BuildTable(const std::string& dbname,\n+                  Env* env,\n+                  const Options& options,\n+                  TableCache* table_cache,\n+                  Iterator* iter,\n+                  FileMetaData* meta) {\n+  Status s;\n+  meta->file_size = 0;\n+  iter->SeekToFirst();\n+\n+  std::string fname = TableFileName(dbname, meta->number);\n+  if (iter->Valid()) {\n+    WritableFile* file;\n+    s = env->NewWritableFile(fname, &file);\n+    if (!s.ok()) {\n+      return s;\n+    }\n+\n+    TableBuilder* builder = new TableBuilder(options, file);\n+    meta->smallest.DecodeFrom(iter->key());\n+    for (; iter->Valid(); iter->Next()) {\n+      Slice key = iter->key();\n+      meta->largest.DecodeFrom(key);\n+      builder->Add(key, iter->value());\n+    }\n+\n+    // Finish and check for builder errors\n+    if (s.ok()) {\n+      s = builder->Finish();\n+      if (s.ok()) {\n+        meta->file_size = builder->FileSize();\n+        assert(meta->file_size > 0);\n+      }\n+    } else {\n+      builder->Abandon();\n+    }\n+    delete builder;\n+\n+    // Finish and check for file errors\n+    if (s.ok()) {\n+      s = file->Sync();\n+    }\n+    if (s.ok()) {\n+      s = file->Close();\n+    }\n+    delete file;\n+    file = NULL;\n+\n+    if (s.ok()) {\n+      // Verify that the table is usable\n+      Iterator* it = table_cache->NewIterator(ReadOptions(),\n+                                              meta->number,\n+                                              meta->file_size);\n+      s = it->status();\n+      delete it;\n+    }\n+  }\n+\n+  // Check for input iterator errors\n+  if (!iter->status().ok()) {\n+    s = iter->status();\n+  }\n+\n+  if (s.ok() && meta->file_size > 0) {\n+    // Keep it\n+  } else {\n+    env->DeleteFile(fname);\n+  }\n+  return s;\n+}\n+\n+}  // namespace leveldb"
      },
      {
        "sha": "62431fcf44f4545490291d8ec1ab098c2fc2ba88",
        "filename": "src/leveldb/db/builder.h",
        "status": "added",
        "additions": 34,
        "deletions": 0,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/builder.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/builder.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/builder.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,34 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#ifndef STORAGE_LEVELDB_DB_BUILDER_H_\n+#define STORAGE_LEVELDB_DB_BUILDER_H_\n+\n+#include \"leveldb/status.h\"\n+\n+namespace leveldb {\n+\n+struct Options;\n+struct FileMetaData;\n+\n+class Env;\n+class Iterator;\n+class TableCache;\n+class VersionEdit;\n+\n+// Build a Table file from the contents of *iter.  The generated file\n+// will be named according to meta->number.  On success, the rest of\n+// *meta will be filled with metadata about the generated table.\n+// If no data is present in *iter, meta->file_size will be set to\n+// zero, and no Table file will be produced.\n+extern Status BuildTable(const std::string& dbname,\n+                         Env* env,\n+                         const Options& options,\n+                         TableCache* table_cache,\n+                         Iterator* iter,\n+                         FileMetaData* meta);\n+\n+}  // namespace leveldb\n+\n+#endif  // STORAGE_LEVELDB_DB_BUILDER_H_"
      },
      {
        "sha": "2dde400e774c4e4aab7ff47e0978766866f041fa",
        "filename": "src/leveldb/db/c.cc",
        "status": "added",
        "additions": 581,
        "deletions": 0,
        "changes": 581,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/c.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/c.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/c.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,581 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include \"leveldb/c.h\"\n+\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include \"leveldb/cache.h\"\n+#include \"leveldb/comparator.h\"\n+#include \"leveldb/db.h\"\n+#include \"leveldb/env.h\"\n+#include \"leveldb/filter_policy.h\"\n+#include \"leveldb/iterator.h\"\n+#include \"leveldb/options.h\"\n+#include \"leveldb/status.h\"\n+#include \"leveldb/write_batch.h\"\n+\n+using leveldb::Cache;\n+using leveldb::Comparator;\n+using leveldb::CompressionType;\n+using leveldb::DB;\n+using leveldb::Env;\n+using leveldb::FileLock;\n+using leveldb::FilterPolicy;\n+using leveldb::Iterator;\n+using leveldb::Logger;\n+using leveldb::NewBloomFilterPolicy;\n+using leveldb::NewLRUCache;\n+using leveldb::Options;\n+using leveldb::RandomAccessFile;\n+using leveldb::Range;\n+using leveldb::ReadOptions;\n+using leveldb::SequentialFile;\n+using leveldb::Slice;\n+using leveldb::Snapshot;\n+using leveldb::Status;\n+using leveldb::WritableFile;\n+using leveldb::WriteBatch;\n+using leveldb::WriteOptions;\n+\n+extern \"C\" {\n+\n+struct leveldb_t              { DB*               rep; };\n+struct leveldb_iterator_t     { Iterator*         rep; };\n+struct leveldb_writebatch_t   { WriteBatch        rep; };\n+struct leveldb_snapshot_t     { const Snapshot*   rep; };\n+struct leveldb_readoptions_t  { ReadOptions       rep; };\n+struct leveldb_writeoptions_t { WriteOptions      rep; };\n+struct leveldb_options_t      { Options           rep; };\n+struct leveldb_cache_t        { Cache*            rep; };\n+struct leveldb_seqfile_t      { SequentialFile*   rep; };\n+struct leveldb_randomfile_t   { RandomAccessFile* rep; };\n+struct leveldb_writablefile_t { WritableFile*     rep; };\n+struct leveldb_logger_t       { Logger*           rep; };\n+struct leveldb_filelock_t     { FileLock*         rep; };\n+\n+struct leveldb_comparator_t : public Comparator {\n+  void* state_;\n+  void (*destructor_)(void*);\n+  int (*compare_)(\n+      void*,\n+      const char* a, size_t alen,\n+      const char* b, size_t blen);\n+  const char* (*name_)(void*);\n+\n+  virtual ~leveldb_comparator_t() {\n+    (*destructor_)(state_);\n+  }\n+\n+  virtual int Compare(const Slice& a, const Slice& b) const {\n+    return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());\n+  }\n+\n+  virtual const char* Name() const {\n+    return (*name_)(state_);\n+  }\n+\n+  // No-ops since the C binding does not support key shortening methods.\n+  virtual void FindShortestSeparator(std::string*, const Slice&) const { }\n+  virtual void FindShortSuccessor(std::string* key) const { }\n+};\n+\n+struct leveldb_filterpolicy_t : public FilterPolicy {\n+  void* state_;\n+  void (*destructor_)(void*);\n+  const char* (*name_)(void*);\n+  char* (*create_)(\n+      void*,\n+      const char* const* key_array, const size_t* key_length_array,\n+      int num_keys,\n+      size_t* filter_length);\n+  unsigned char (*key_match_)(\n+      void*,\n+      const char* key, size_t length,\n+      const char* filter, size_t filter_length);\n+\n+  virtual ~leveldb_filterpolicy_t() {\n+    (*destructor_)(state_);\n+  }\n+\n+  virtual const char* Name() const {\n+    return (*name_)(state_);\n+  }\n+\n+  virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const {\n+    std::vector<const char*> key_pointers(n);\n+    std::vector<size_t> key_sizes(n);\n+    for (int i = 0; i < n; i++) {\n+      key_pointers[i] = keys[i].data();\n+      key_sizes[i] = keys[i].size();\n+    }\n+    size_t len;\n+    char* filter = (*create_)(state_, &key_pointers[0], &key_sizes[0], n, &len);\n+    dst->append(filter, len);\n+    free(filter);\n+  }\n+\n+  virtual bool KeyMayMatch(const Slice& key, const Slice& filter) const {\n+    return (*key_match_)(state_, key.data(), key.size(),\n+                         filter.data(), filter.size());\n+  }\n+};\n+\n+struct leveldb_env_t {\n+  Env* rep;\n+  bool is_default;\n+};\n+\n+static bool SaveError(char** errptr, const Status& s) {\n+  assert(errptr != NULL);\n+  if (s.ok()) {\n+    return false;\n+  } else if (*errptr == NULL) {\n+    *errptr = strdup(s.ToString().c_str());\n+  } else {\n+    // TODO(sanjay): Merge with existing error?\n+    free(*errptr);\n+    *errptr = strdup(s.ToString().c_str());\n+  }\n+  return true;\n+}\n+\n+static char* CopyString(const std::string& str) {\n+  char* result = reinterpret_cast<char*>(malloc(sizeof(char) * str.size()));\n+  memcpy(result, str.data(), sizeof(char) * str.size());\n+  return result;\n+}\n+\n+leveldb_t* leveldb_open(\n+    const leveldb_options_t* options,\n+    const char* name,\n+    char** errptr) {\n+  DB* db;\n+  if (SaveError(errptr, DB::Open(options->rep, std::string(name), &db))) {\n+    return NULL;\n+  }\n+  leveldb_t* result = new leveldb_t;\n+  result->rep = db;\n+  return result;\n+}\n+\n+void leveldb_close(leveldb_t* db) {\n+  delete db->rep;\n+  delete db;\n+}\n+\n+void leveldb_put(\n+    leveldb_t* db,\n+    const leveldb_writeoptions_t* options,\n+    const char* key, size_t keylen,\n+    const char* val, size_t vallen,\n+    char** errptr) {\n+  SaveError(errptr,\n+            db->rep->Put(options->rep, Slice(key, keylen), Slice(val, vallen)));\n+}\n+\n+void leveldb_delete(\n+    leveldb_t* db,\n+    const leveldb_writeoptions_t* options,\n+    const char* key, size_t keylen,\n+    char** errptr) {\n+  SaveError(errptr, db->rep->Delete(options->rep, Slice(key, keylen)));\n+}\n+\n+\n+void leveldb_write(\n+    leveldb_t* db,\n+    const leveldb_writeoptions_t* options,\n+    leveldb_writebatch_t* batch,\n+    char** errptr) {\n+  SaveError(errptr, db->rep->Write(options->rep, &batch->rep));\n+}\n+\n+char* leveldb_get(\n+    leveldb_t* db,\n+    const leveldb_readoptions_t* options,\n+    const char* key, size_t keylen,\n+    size_t* vallen,\n+    char** errptr) {\n+  char* result = NULL;\n+  std::string tmp;\n+  Status s = db->rep->Get(options->rep, Slice(key, keylen), &tmp);\n+  if (s.ok()) {\n+    *vallen = tmp.size();\n+    result = CopyString(tmp);\n+  } else {\n+    *vallen = 0;\n+    if (!s.IsNotFound()) {\n+      SaveError(errptr, s);\n+    }\n+  }\n+  return result;\n+}\n+\n+leveldb_iterator_t* leveldb_create_iterator(\n+    leveldb_t* db,\n+    const leveldb_readoptions_t* options) {\n+  leveldb_iterator_t* result = new leveldb_iterator_t;\n+  result->rep = db->rep->NewIterator(options->rep);\n+  return result;\n+}\n+\n+const leveldb_snapshot_t* leveldb_create_snapshot(\n+    leveldb_t* db) {\n+  leveldb_snapshot_t* result = new leveldb_snapshot_t;\n+  result->rep = db->rep->GetSnapshot();\n+  return result;\n+}\n+\n+void leveldb_release_snapshot(\n+    leveldb_t* db,\n+    const leveldb_snapshot_t* snapshot) {\n+  db->rep->ReleaseSnapshot(snapshot->rep);\n+  delete snapshot;\n+}\n+\n+char* leveldb_property_value(\n+    leveldb_t* db,\n+    const char* propname) {\n+  std::string tmp;\n+  if (db->rep->GetProperty(Slice(propname), &tmp)) {\n+    // We use strdup() since we expect human readable output.\n+    return strdup(tmp.c_str());\n+  } else {\n+    return NULL;\n+  }\n+}\n+\n+void leveldb_approximate_sizes(\n+    leveldb_t* db,\n+    int num_ranges,\n+    const char* const* range_start_key, const size_t* range_start_key_len,\n+    const char* const* range_limit_key, const size_t* range_limit_key_len,\n+    uint64_t* sizes) {\n+  Range* ranges = new Range[num_ranges];\n+  for (int i = 0; i < num_ranges; i++) {\n+    ranges[i].start = Slice(range_start_key[i], range_start_key_len[i]);\n+    ranges[i].limit = Slice(range_limit_key[i], range_limit_key_len[i]);\n+  }\n+  db->rep->GetApproximateSizes(ranges, num_ranges, sizes);\n+  delete[] ranges;\n+}\n+\n+void leveldb_compact_range(\n+    leveldb_t* db,\n+    const char* start_key, size_t start_key_len,\n+    const char* limit_key, size_t limit_key_len) {\n+  Slice a, b;\n+  db->rep->CompactRange(\n+      // Pass NULL Slice if corresponding \"const char*\" is NULL\n+      (start_key ? (a = Slice(start_key, start_key_len), &a) : NULL),\n+      (limit_key ? (b = Slice(limit_key, limit_key_len), &b) : NULL));\n+}\n+\n+void leveldb_destroy_db(\n+    const leveldb_options_t* options,\n+    const char* name,\n+    char** errptr) {\n+  SaveError(errptr, DestroyDB(name, options->rep));\n+}\n+\n+void leveldb_repair_db(\n+    const leveldb_options_t* options,\n+    const char* name,\n+    char** errptr) {\n+  SaveError(errptr, RepairDB(name, options->rep));\n+}\n+\n+void leveldb_iter_destroy(leveldb_iterator_t* iter) {\n+  delete iter->rep;\n+  delete iter;\n+}\n+\n+unsigned char leveldb_iter_valid(const leveldb_iterator_t* iter) {\n+  return iter->rep->Valid();\n+}\n+\n+void leveldb_iter_seek_to_first(leveldb_iterator_t* iter) {\n+  iter->rep->SeekToFirst();\n+}\n+\n+void leveldb_iter_seek_to_last(leveldb_iterator_t* iter) {\n+  iter->rep->SeekToLast();\n+}\n+\n+void leveldb_iter_seek(leveldb_iterator_t* iter, const char* k, size_t klen) {\n+  iter->rep->Seek(Slice(k, klen));\n+}\n+\n+void leveldb_iter_next(leveldb_iterator_t* iter) {\n+  iter->rep->Next();\n+}\n+\n+void leveldb_iter_prev(leveldb_iterator_t* iter) {\n+  iter->rep->Prev();\n+}\n+\n+const char* leveldb_iter_key(const leveldb_iterator_t* iter, size_t* klen) {\n+  Slice s = iter->rep->key();\n+  *klen = s.size();\n+  return s.data();\n+}\n+\n+const char* leveldb_iter_value(const leveldb_iterator_t* iter, size_t* vlen) {\n+  Slice s = iter->rep->value();\n+  *vlen = s.size();\n+  return s.data();\n+}\n+\n+void leveldb_iter_get_error(const leveldb_iterator_t* iter, char** errptr) {\n+  SaveError(errptr, iter->rep->status());\n+}\n+\n+leveldb_writebatch_t* leveldb_writebatch_create() {\n+  return new leveldb_writebatch_t;\n+}\n+\n+void leveldb_writebatch_destroy(leveldb_writebatch_t* b) {\n+  delete b;\n+}\n+\n+void leveldb_writebatch_clear(leveldb_writebatch_t* b) {\n+  b->rep.Clear();\n+}\n+\n+void leveldb_writebatch_put(\n+    leveldb_writebatch_t* b,\n+    const char* key, size_t klen,\n+    const char* val, size_t vlen) {\n+  b->rep.Put(Slice(key, klen), Slice(val, vlen));\n+}\n+\n+void leveldb_writebatch_delete(\n+    leveldb_writebatch_t* b,\n+    const char* key, size_t klen) {\n+  b->rep.Delete(Slice(key, klen));\n+}\n+\n+void leveldb_writebatch_iterate(\n+    leveldb_writebatch_t* b,\n+    void* state,\n+    void (*put)(void*, const char* k, size_t klen, const char* v, size_t vlen),\n+    void (*deleted)(void*, const char* k, size_t klen)) {\n+  class H : public WriteBatch::Handler {\n+   public:\n+    void* state_;\n+    void (*put_)(void*, const char* k, size_t klen, const char* v, size_t vlen);\n+    void (*deleted_)(void*, const char* k, size_t klen);\n+    virtual void Put(const Slice& key, const Slice& value) {\n+      (*put_)(state_, key.data(), key.size(), value.data(), value.size());\n+    }\n+    virtual void Delete(const Slice& key) {\n+      (*deleted_)(state_, key.data(), key.size());\n+    }\n+  };\n+  H handler;\n+  handler.state_ = state;\n+  handler.put_ = put;\n+  handler.deleted_ = deleted;\n+  b->rep.Iterate(&handler);\n+}\n+\n+leveldb_options_t* leveldb_options_create() {\n+  return new leveldb_options_t;\n+}\n+\n+void leveldb_options_destroy(leveldb_options_t* options) {\n+  delete options;\n+}\n+\n+void leveldb_options_set_comparator(\n+    leveldb_options_t* opt,\n+    leveldb_comparator_t* cmp) {\n+  opt->rep.comparator = cmp;\n+}\n+\n+void leveldb_options_set_filter_policy(\n+    leveldb_options_t* opt,\n+    leveldb_filterpolicy_t* policy) {\n+  opt->rep.filter_policy = policy;\n+}\n+\n+void leveldb_options_set_create_if_missing(\n+    leveldb_options_t* opt, unsigned char v) {\n+  opt->rep.create_if_missing = v;\n+}\n+\n+void leveldb_options_set_error_if_exists(\n+    leveldb_options_t* opt, unsigned char v) {\n+  opt->rep.error_if_exists = v;\n+}\n+\n+void leveldb_options_set_paranoid_checks(\n+    leveldb_options_t* opt, unsigned char v) {\n+  opt->rep.paranoid_checks = v;\n+}\n+\n+void leveldb_options_set_env(leveldb_options_t* opt, leveldb_env_t* env) {\n+  opt->rep.env = (env ? env->rep : NULL);\n+}\n+\n+void leveldb_options_set_info_log(leveldb_options_t* opt, leveldb_logger_t* l) {\n+  opt->rep.info_log = (l ? l->rep : NULL);\n+}\n+\n+void leveldb_options_set_write_buffer_size(leveldb_options_t* opt, size_t s) {\n+  opt->rep.write_buffer_size = s;\n+}\n+\n+void leveldb_options_set_max_open_files(leveldb_options_t* opt, int n) {\n+  opt->rep.max_open_files = n;\n+}\n+\n+void leveldb_options_set_cache(leveldb_options_t* opt, leveldb_cache_t* c) {\n+  opt->rep.block_cache = c->rep;\n+}\n+\n+void leveldb_options_set_block_size(leveldb_options_t* opt, size_t s) {\n+  opt->rep.block_size = s;\n+}\n+\n+void leveldb_options_set_block_restart_interval(leveldb_options_t* opt, int n) {\n+  opt->rep.block_restart_interval = n;\n+}\n+\n+void leveldb_options_set_compression(leveldb_options_t* opt, int t) {\n+  opt->rep.compression = static_cast<CompressionType>(t);\n+}\n+\n+leveldb_comparator_t* leveldb_comparator_create(\n+    void* state,\n+    void (*destructor)(void*),\n+    int (*compare)(\n+        void*,\n+        const char* a, size_t alen,\n+        const char* b, size_t blen),\n+    const char* (*name)(void*)) {\n+  leveldb_comparator_t* result = new leveldb_comparator_t;\n+  result->state_ = state;\n+  result->destructor_ = destructor;\n+  result->compare_ = compare;\n+  result->name_ = name;\n+  return result;\n+}\n+\n+void leveldb_comparator_destroy(leveldb_comparator_t* cmp) {\n+  delete cmp;\n+}\n+\n+leveldb_filterpolicy_t* leveldb_filterpolicy_create(\n+    void* state,\n+    void (*destructor)(void*),\n+    char* (*create_filter)(\n+        void*,\n+        const char* const* key_array, const size_t* key_length_array,\n+        int num_keys,\n+        size_t* filter_length),\n+    unsigned char (*key_may_match)(\n+        void*,\n+        const char* key, size_t length,\n+        const char* filter, size_t filter_length),\n+    const char* (*name)(void*)) {\n+  leveldb_filterpolicy_t* result = new leveldb_filterpolicy_t;\n+  result->state_ = state;\n+  result->destructor_ = destructor;\n+  result->create_ = create_filter;\n+  result->key_match_ = key_may_match;\n+  result->name_ = name;\n+  return result;\n+}\n+\n+void leveldb_filterpolicy_destroy(leveldb_filterpolicy_t* filter) {\n+  delete filter;\n+}\n+\n+leveldb_filterpolicy_t* leveldb_filterpolicy_create_bloom(int bits_per_key) {\n+  // Make a leveldb_filterpolicy_t, but override all of its methods so\n+  // they delegate to a NewBloomFilterPolicy() instead of user\n+  // supplied C functions.\n+  struct Wrapper : public leveldb_filterpolicy_t {\n+    const FilterPolicy* rep_;\n+    ~Wrapper() { delete rep_; }\n+    const char* Name() const { return rep_->Name(); }\n+    void CreateFilter(const Slice* keys, int n, std::string* dst) const {\n+      return rep_->CreateFilter(keys, n, dst);\n+    }\n+    bool KeyMayMatch(const Slice& key, const Slice& filter) const {\n+      return rep_->KeyMayMatch(key, filter);\n+    }\n+    static void DoNothing(void*) { }\n+  };\n+  Wrapper* wrapper = new Wrapper;\n+  wrapper->rep_ = NewBloomFilterPolicy(bits_per_key);\n+  wrapper->state_ = NULL;\n+  wrapper->destructor_ = &Wrapper::DoNothing;\n+  return wrapper;\n+}\n+\n+leveldb_readoptions_t* leveldb_readoptions_create() {\n+  return new leveldb_readoptions_t;\n+}\n+\n+void leveldb_readoptions_destroy(leveldb_readoptions_t* opt) {\n+  delete opt;\n+}\n+\n+void leveldb_readoptions_set_verify_checksums(\n+    leveldb_readoptions_t* opt,\n+    unsigned char v) {\n+  opt->rep.verify_checksums = v;\n+}\n+\n+void leveldb_readoptions_set_fill_cache(\n+    leveldb_readoptions_t* opt, unsigned char v) {\n+  opt->rep.fill_cache = v;\n+}\n+\n+void leveldb_readoptions_set_snapshot(\n+    leveldb_readoptions_t* opt,\n+    const leveldb_snapshot_t* snap) {\n+  opt->rep.snapshot = (snap ? snap->rep : NULL);\n+}\n+\n+leveldb_writeoptions_t* leveldb_writeoptions_create() {\n+  return new leveldb_writeoptions_t;\n+}\n+\n+void leveldb_writeoptions_destroy(leveldb_writeoptions_t* opt) {\n+  delete opt;\n+}\n+\n+void leveldb_writeoptions_set_sync(\n+    leveldb_writeoptions_t* opt, unsigned char v) {\n+  opt->rep.sync = v;\n+}\n+\n+leveldb_cache_t* leveldb_cache_create_lru(size_t capacity) {\n+  leveldb_cache_t* c = new leveldb_cache_t;\n+  c->rep = NewLRUCache(capacity);\n+  return c;\n+}\n+\n+void leveldb_cache_destroy(leveldb_cache_t* cache) {\n+  delete cache->rep;\n+  delete cache;\n+}\n+\n+leveldb_env_t* leveldb_create_default_env() {\n+  leveldb_env_t* result = new leveldb_env_t;\n+  result->rep = Env::Default();\n+  result->is_default = true;\n+  return result;\n+}\n+\n+void leveldb_env_destroy(leveldb_env_t* env) {\n+  if (!env->is_default) delete env->rep;\n+  delete env;\n+}\n+\n+}  // end extern \"C\""
      },
      {
        "sha": "97924471574a83149c2cb971e83911a9f98ad236",
        "filename": "src/leveldb/db/c_test.c",
        "status": "added",
        "additions": 381,
        "deletions": 0,
        "changes": 381,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/c_test.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/c_test.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/c_test.c?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,381 @@\n+/* Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+   Use of this source code is governed by a BSD-style license that can be\n+   found in the LICENSE file. See the AUTHORS file for names of contributors. */\n+\n+#include \"leveldb/c.h\"\n+\n+#include <stddef.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <sys/types.h>\n+#include <unistd.h>\n+\n+const char* phase = \"\";\n+static char dbname[200];\n+\n+static void StartPhase(const char* name) {\n+  fprintf(stderr, \"=== Test %s\\n\", name);\n+  phase = name;\n+}\n+\n+static const char* GetTempDir(void) {\n+    const char* ret = getenv(\"TEST_TMPDIR\");\n+    if (ret == NULL || ret[0] == '\\0')\n+        ret = \"/tmp\";\n+    return ret;\n+}\n+\n+#define CheckNoError(err)                                               \\\n+  if ((err) != NULL) {                                                  \\\n+    fprintf(stderr, \"%s:%d: %s: %s\\n\", __FILE__, __LINE__, phase, (err)); \\\n+    abort();                                                            \\\n+  }\n+\n+#define CheckCondition(cond)                                            \\\n+  if (!(cond)) {                                                        \\\n+    fprintf(stderr, \"%s:%d: %s: %s\\n\", __FILE__, __LINE__, phase, #cond); \\\n+    abort();                                                            \\\n+  }\n+\n+static void CheckEqual(const char* expected, const char* v, size_t n) {\n+  if (expected == NULL && v == NULL) {\n+    // ok\n+  } else if (expected != NULL && v != NULL && n == strlen(expected) &&\n+             memcmp(expected, v, n) == 0) {\n+    // ok\n+    return;\n+  } else {\n+    fprintf(stderr, \"%s: expected '%s', got '%s'\\n\",\n+            phase,\n+            (expected ? expected : \"(null)\"),\n+            (v ? v : \"(null\"));\n+    abort();\n+  }\n+}\n+\n+static void Free(char** ptr) {\n+  if (*ptr) {\n+    free(*ptr);\n+    *ptr = NULL;\n+  }\n+}\n+\n+static void CheckGet(\n+    leveldb_t* db,\n+    const leveldb_readoptions_t* options,\n+    const char* key,\n+    const char* expected) {\n+  char* err = NULL;\n+  size_t val_len;\n+  char* val;\n+  val = leveldb_get(db, options, key, strlen(key), &val_len, &err);\n+  CheckNoError(err);\n+  CheckEqual(expected, val, val_len);\n+  Free(&val);\n+}\n+\n+static void CheckIter(leveldb_iterator_t* iter,\n+                      const char* key, const char* val) {\n+  size_t len;\n+  const char* str;\n+  str = leveldb_iter_key(iter, &len);\n+  CheckEqual(key, str, len);\n+  str = leveldb_iter_value(iter, &len);\n+  CheckEqual(val, str, len);\n+}\n+\n+// Callback from leveldb_writebatch_iterate()\n+static void CheckPut(void* ptr,\n+                     const char* k, size_t klen,\n+                     const char* v, size_t vlen) {\n+  int* state = (int*) ptr;\n+  CheckCondition(*state < 2);\n+  switch (*state) {\n+    case 0:\n+      CheckEqual(\"bar\", k, klen);\n+      CheckEqual(\"b\", v, vlen);\n+      break;\n+    case 1:\n+      CheckEqual(\"box\", k, klen);\n+      CheckEqual(\"c\", v, vlen);\n+      break;\n+  }\n+  (*state)++;\n+}\n+\n+// Callback from leveldb_writebatch_iterate()\n+static void CheckDel(void* ptr, const char* k, size_t klen) {\n+  int* state = (int*) ptr;\n+  CheckCondition(*state == 2);\n+  CheckEqual(\"bar\", k, klen);\n+  (*state)++;\n+}\n+\n+static void CmpDestroy(void* arg) { }\n+\n+static int CmpCompare(void* arg, const char* a, size_t alen,\n+                      const char* b, size_t blen) {\n+  int n = (alen < blen) ? alen : blen;\n+  int r = memcmp(a, b, n);\n+  if (r == 0) {\n+    if (alen < blen) r = -1;\n+    else if (alen > blen) r = +1;\n+  }\n+  return r;\n+}\n+\n+static const char* CmpName(void* arg) {\n+  return \"foo\";\n+}\n+\n+// Custom filter policy\n+static unsigned char fake_filter_result = 1;\n+static void FilterDestroy(void* arg) { }\n+static const char* FilterName(void* arg) {\n+  return \"TestFilter\";\n+}\n+static char* FilterCreate(\n+    void* arg,\n+    const char* const* key_array, const size_t* key_length_array,\n+    int num_keys,\n+    size_t* filter_length) {\n+  *filter_length = 4;\n+  char* result = malloc(4);\n+  memcpy(result, \"fake\", 4);\n+  return result;\n+}\n+unsigned char FilterKeyMatch(\n+    void* arg,\n+    const char* key, size_t length,\n+    const char* filter, size_t filter_length) {\n+  CheckCondition(filter_length == 4);\n+  CheckCondition(memcmp(filter, \"fake\", 4) == 0);\n+  return fake_filter_result;\n+}\n+\n+int main(int argc, char** argv) {\n+  leveldb_t* db;\n+  leveldb_comparator_t* cmp;\n+  leveldb_cache_t* cache;\n+  leveldb_env_t* env;\n+  leveldb_options_t* options;\n+  leveldb_readoptions_t* roptions;\n+  leveldb_writeoptions_t* woptions;\n+  char* err = NULL;\n+  int run = -1;\n+\n+  snprintf(dbname, sizeof(dbname),\n+           \"%s/leveldb_c_test-%d\",\n+           GetTempDir(),\n+           ((int) geteuid()));\n+\n+  StartPhase(\"create_objects\");\n+  cmp = leveldb_comparator_create(NULL, CmpDestroy, CmpCompare, CmpName);\n+  env = leveldb_create_default_env();\n+  cache = leveldb_cache_create_lru(100000);\n+\n+  options = leveldb_options_create();\n+  leveldb_options_set_comparator(options, cmp);\n+  leveldb_options_set_error_if_exists(options, 1);\n+  leveldb_options_set_cache(options, cache);\n+  leveldb_options_set_env(options, env);\n+  leveldb_options_set_info_log(options, NULL);\n+  leveldb_options_set_write_buffer_size(options, 100000);\n+  leveldb_options_set_paranoid_checks(options, 1);\n+  leveldb_options_set_max_open_files(options, 10);\n+  leveldb_options_set_block_size(options, 1024);\n+  leveldb_options_set_block_restart_interval(options, 8);\n+  leveldb_options_set_compression(options, leveldb_no_compression);\n+\n+  roptions = leveldb_readoptions_create();\n+  leveldb_readoptions_set_verify_checksums(roptions, 1);\n+  leveldb_readoptions_set_fill_cache(roptions, 0);\n+\n+  woptions = leveldb_writeoptions_create();\n+  leveldb_writeoptions_set_sync(woptions, 1);\n+\n+  StartPhase(\"destroy\");\n+  leveldb_destroy_db(options, dbname, &err);\n+  Free(&err);\n+\n+  StartPhase(\"open_error\");\n+  db = leveldb_open(options, dbname, &err);\n+  CheckCondition(err != NULL);\n+  Free(&err);\n+\n+  StartPhase(\"open\");\n+  leveldb_options_set_create_if_missing(options, 1);\n+  db = leveldb_open(options, dbname, &err);\n+  CheckNoError(err);\n+  CheckGet(db, roptions, \"foo\", NULL);\n+\n+  StartPhase(\"put\");\n+  leveldb_put(db, woptions, \"foo\", 3, \"hello\", 5, &err);\n+  CheckNoError(err);\n+  CheckGet(db, roptions, \"foo\", \"hello\");\n+\n+  StartPhase(\"compactall\");\n+  leveldb_compact_range(db, NULL, 0, NULL, 0);\n+  CheckGet(db, roptions, \"foo\", \"hello\");\n+\n+  StartPhase(\"compactrange\");\n+  leveldb_compact_range(db, \"a\", 1, \"z\", 1);\n+  CheckGet(db, roptions, \"foo\", \"hello\");\n+\n+  StartPhase(\"writebatch\");\n+  {\n+    leveldb_writebatch_t* wb = leveldb_writebatch_create();\n+    leveldb_writebatch_put(wb, \"foo\", 3, \"a\", 1);\n+    leveldb_writebatch_clear(wb);\n+    leveldb_writebatch_put(wb, \"bar\", 3, \"b\", 1);\n+    leveldb_writebatch_put(wb, \"box\", 3, \"c\", 1);\n+    leveldb_writebatch_delete(wb, \"bar\", 3);\n+    leveldb_write(db, woptions, wb, &err);\n+    CheckNoError(err);\n+    CheckGet(db, roptions, \"foo\", \"hello\");\n+    CheckGet(db, roptions, \"bar\", NULL);\n+    CheckGet(db, roptions, \"box\", \"c\");\n+    int pos = 0;\n+    leveldb_writebatch_iterate(wb, &pos, CheckPut, CheckDel);\n+    CheckCondition(pos == 3);\n+    leveldb_writebatch_destroy(wb);\n+  }\n+\n+  StartPhase(\"iter\");\n+  {\n+    leveldb_iterator_t* iter = leveldb_create_iterator(db, roptions);\n+    CheckCondition(!leveldb_iter_valid(iter));\n+    leveldb_iter_seek_to_first(iter);\n+    CheckCondition(leveldb_iter_valid(iter));\n+    CheckIter(iter, \"box\", \"c\");\n+    leveldb_iter_next(iter);\n+    CheckIter(iter, \"foo\", \"hello\");\n+    leveldb_iter_prev(iter);\n+    CheckIter(iter, \"box\", \"c\");\n+    leveldb_iter_prev(iter);\n+    CheckCondition(!leveldb_iter_valid(iter));\n+    leveldb_iter_seek_to_last(iter);\n+    CheckIter(iter, \"foo\", \"hello\");\n+    leveldb_iter_seek(iter, \"b\", 1);\n+    CheckIter(iter, \"box\", \"c\");\n+    leveldb_iter_get_error(iter, &err);\n+    CheckNoError(err);\n+    leveldb_iter_destroy(iter);\n+  }\n+\n+  StartPhase(\"approximate_sizes\");\n+  {\n+    int i;\n+    int n = 20000;\n+    char keybuf[100];\n+    char valbuf[100];\n+    uint64_t sizes[2];\n+    const char* start[2] = { \"a\", \"k00000000000000010000\" };\n+    size_t start_len[2] = { 1, 21 };\n+    const char* limit[2] = { \"k00000000000000010000\", \"z\" };\n+    size_t limit_len[2] = { 21, 1 };\n+    leveldb_writeoptions_set_sync(woptions, 0);\n+    for (i = 0; i < n; i++) {\n+      snprintf(keybuf, sizeof(keybuf), \"k%020d\", i);\n+      snprintf(valbuf, sizeof(valbuf), \"v%020d\", i);\n+      leveldb_put(db, woptions, keybuf, strlen(keybuf), valbuf, strlen(valbuf),\n+                  &err);\n+      CheckNoError(err);\n+    }\n+    leveldb_approximate_sizes(db, 2, start, start_len, limit, limit_len, sizes);\n+    CheckCondition(sizes[0] > 0);\n+    CheckCondition(sizes[1] > 0);\n+  }\n+\n+  StartPhase(\"property\");\n+  {\n+    char* prop = leveldb_property_value(db, \"nosuchprop\");\n+    CheckCondition(prop == NULL);\n+    prop = leveldb_property_value(db, \"leveldb.stats\");\n+    CheckCondition(prop != NULL);\n+    Free(&prop);\n+  }\n+\n+  StartPhase(\"snapshot\");\n+  {\n+    const leveldb_snapshot_t* snap;\n+    snap = leveldb_create_snapshot(db);\n+    leveldb_delete(db, woptions, \"foo\", 3, &err);\n+    CheckNoError(err);\n+    leveldb_readoptions_set_snapshot(roptions, snap);\n+    CheckGet(db, roptions, \"foo\", \"hello\");\n+    leveldb_readoptions_set_snapshot(roptions, NULL);\n+    CheckGet(db, roptions, \"foo\", NULL);\n+    leveldb_release_snapshot(db, snap);\n+  }\n+\n+  StartPhase(\"repair\");\n+  {\n+    leveldb_close(db);\n+    leveldb_options_set_create_if_missing(options, 0);\n+    leveldb_options_set_error_if_exists(options, 0);\n+    leveldb_repair_db(options, dbname, &err);\n+    CheckNoError(err);\n+    db = leveldb_open(options, dbname, &err);\n+    CheckNoError(err);\n+    CheckGet(db, roptions, \"foo\", NULL);\n+    CheckGet(db, roptions, \"bar\", NULL);\n+    CheckGet(db, roptions, \"box\", \"c\");\n+    leveldb_options_set_create_if_missing(options, 1);\n+    leveldb_options_set_error_if_exists(options, 1);\n+  }\n+\n+  StartPhase(\"filter\");\n+  for (run = 0; run < 2; run++) {\n+    // First run uses custom filter, second run uses bloom filter\n+    CheckNoError(err);\n+    leveldb_filterpolicy_t* policy;\n+    if (run == 0) {\n+      policy = leveldb_filterpolicy_create(\n+          NULL, FilterDestroy, FilterCreate, FilterKeyMatch, FilterName);\n+    } else {\n+      policy = leveldb_filterpolicy_create_bloom(10);\n+    }\n+\n+    // Create new database\n+    leveldb_close(db);\n+    leveldb_destroy_db(options, dbname, &err);\n+    leveldb_options_set_filter_policy(options, policy);\n+    db = leveldb_open(options, dbname, &err);\n+    CheckNoError(err);\n+    leveldb_put(db, woptions, \"foo\", 3, \"foovalue\", 8, &err);\n+    CheckNoError(err);\n+    leveldb_put(db, woptions, \"bar\", 3, \"barvalue\", 8, &err);\n+    CheckNoError(err);\n+    leveldb_compact_range(db, NULL, 0, NULL, 0);\n+\n+    fake_filter_result = 1;\n+    CheckGet(db, roptions, \"foo\", \"foovalue\");\n+    CheckGet(db, roptions, \"bar\", \"barvalue\");\n+    if (phase == 0) {\n+      // Must not find value when custom filter returns false\n+      fake_filter_result = 0;\n+      CheckGet(db, roptions, \"foo\", NULL);\n+      CheckGet(db, roptions, \"bar\", NULL);\n+      fake_filter_result = 1;\n+\n+      CheckGet(db, roptions, \"foo\", \"foovalue\");\n+      CheckGet(db, roptions, \"bar\", \"barvalue\");\n+    }\n+    leveldb_options_set_filter_policy(options, NULL);\n+    leveldb_filterpolicy_destroy(policy);\n+  }\n+\n+  StartPhase(\"cleanup\");\n+  leveldb_close(db);\n+  leveldb_options_destroy(options);\n+  leveldb_readoptions_destroy(roptions);\n+  leveldb_writeoptions_destroy(woptions);\n+  leveldb_cache_destroy(cache);\n+  leveldb_comparator_destroy(cmp);\n+  leveldb_env_destroy(env);\n+\n+  fprintf(stderr, \"PASS\\n\");\n+  return 0;\n+}"
      },
      {
        "sha": "31b2d5f4166bc200122c1773b1a3e7fdcff7c640",
        "filename": "src/leveldb/db/corruption_test.cc",
        "status": "added",
        "additions": 359,
        "deletions": 0,
        "changes": 359,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/corruption_test.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/corruption_test.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/corruption_test.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,359 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include \"leveldb/db.h\"\n+\n+#include <errno.h>\n+#include <fcntl.h>\n+#include <sys/stat.h>\n+#include <sys/types.h>\n+#include \"leveldb/cache.h\"\n+#include \"leveldb/env.h\"\n+#include \"leveldb/table.h\"\n+#include \"leveldb/write_batch.h\"\n+#include \"db/db_impl.h\"\n+#include \"db/filename.h\"\n+#include \"db/log_format.h\"\n+#include \"db/version_set.h\"\n+#include \"util/logging.h\"\n+#include \"util/testharness.h\"\n+#include \"util/testutil.h\"\n+\n+namespace leveldb {\n+\n+static const int kValueSize = 1000;\n+\n+class CorruptionTest {\n+ public:\n+  test::ErrorEnv env_;\n+  std::string dbname_;\n+  Cache* tiny_cache_;\n+  Options options_;\n+  DB* db_;\n+\n+  CorruptionTest() {\n+    tiny_cache_ = NewLRUCache(100);\n+    options_.env = &env_;\n+    dbname_ = test::TmpDir() + \"/db_test\";\n+    DestroyDB(dbname_, options_);\n+\n+    db_ = NULL;\n+    options_.create_if_missing = true;\n+    Reopen();\n+    options_.create_if_missing = false;\n+  }\n+\n+  ~CorruptionTest() {\n+     delete db_;\n+     DestroyDB(dbname_, Options());\n+     delete tiny_cache_;\n+  }\n+\n+  Status TryReopen(Options* options = NULL) {\n+    delete db_;\n+    db_ = NULL;\n+    Options opt = (options ? *options : options_);\n+    opt.env = &env_;\n+    opt.block_cache = tiny_cache_;\n+    return DB::Open(opt, dbname_, &db_);\n+  }\n+\n+  void Reopen(Options* options = NULL) {\n+    ASSERT_OK(TryReopen(options));\n+  }\n+\n+  void RepairDB() {\n+    delete db_;\n+    db_ = NULL;\n+    ASSERT_OK(::leveldb::RepairDB(dbname_, options_));\n+  }\n+\n+  void Build(int n) {\n+    std::string key_space, value_space;\n+    WriteBatch batch;\n+    for (int i = 0; i < n; i++) {\n+      //if ((i % 100) == 0) fprintf(stderr, \"@ %d of %d\\n\", i, n);\n+      Slice key = Key(i, &key_space);\n+      batch.Clear();\n+      batch.Put(key, Value(i, &value_space));\n+      ASSERT_OK(db_->Write(WriteOptions(), &batch));\n+    }\n+  }\n+\n+  void Check(int min_expected, int max_expected) {\n+    int next_expected = 0;\n+    int missed = 0;\n+    int bad_keys = 0;\n+    int bad_values = 0;\n+    int correct = 0;\n+    std::string value_space;\n+    Iterator* iter = db_->NewIterator(ReadOptions());\n+    for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n+      uint64_t key;\n+      Slice in(iter->key());\n+      if (!ConsumeDecimalNumber(&in, &key) ||\n+          !in.empty() ||\n+          key < next_expected) {\n+        bad_keys++;\n+        continue;\n+      }\n+      missed += (key - next_expected);\n+      next_expected = key + 1;\n+      if (iter->value() != Value(key, &value_space)) {\n+        bad_values++;\n+      } else {\n+        correct++;\n+      }\n+    }\n+    delete iter;\n+\n+    fprintf(stderr,\n+            \"expected=%d..%d; got=%d; bad_keys=%d; bad_values=%d; missed=%d\\n\",\n+            min_expected, max_expected, correct, bad_keys, bad_values, missed);\n+    ASSERT_LE(min_expected, correct);\n+    ASSERT_GE(max_expected, correct);\n+  }\n+\n+  void Corrupt(FileType filetype, int offset, int bytes_to_corrupt) {\n+    // Pick file to corrupt\n+    std::vector<std::string> filenames;\n+    ASSERT_OK(env_.GetChildren(dbname_, &filenames));\n+    uint64_t number;\n+    FileType type;\n+    std::string fname;\n+    int picked_number = -1;\n+    for (int i = 0; i < filenames.size(); i++) {\n+      if (ParseFileName(filenames[i], &number, &type) &&\n+          type == filetype &&\n+          int(number) > picked_number) {  // Pick latest file\n+        fname = dbname_ + \"/\" + filenames[i];\n+        picked_number = number;\n+      }\n+    }\n+    ASSERT_TRUE(!fname.empty()) << filetype;\n+\n+    struct stat sbuf;\n+    if (stat(fname.c_str(), &sbuf) != 0) {\n+      const char* msg = strerror(errno);\n+      ASSERT_TRUE(false) << fname << \": \" << msg;\n+    }\n+\n+    if (offset < 0) {\n+      // Relative to end of file; make it absolute\n+      if (-offset > sbuf.st_size) {\n+        offset = 0;\n+      } else {\n+        offset = sbuf.st_size + offset;\n+      }\n+    }\n+    if (offset > sbuf.st_size) {\n+      offset = sbuf.st_size;\n+    }\n+    if (offset + bytes_to_corrupt > sbuf.st_size) {\n+      bytes_to_corrupt = sbuf.st_size - offset;\n+    }\n+\n+    // Do it\n+    std::string contents;\n+    Status s = ReadFileToString(Env::Default(), fname, &contents);\n+    ASSERT_TRUE(s.ok()) << s.ToString();\n+    for (int i = 0; i < bytes_to_corrupt; i++) {\n+      contents[i + offset] ^= 0x80;\n+    }\n+    s = WriteStringToFile(Env::Default(), contents, fname);\n+    ASSERT_TRUE(s.ok()) << s.ToString();\n+  }\n+\n+  int Property(const std::string& name) {\n+    std::string property;\n+    int result;\n+    if (db_->GetProperty(name, &property) &&\n+        sscanf(property.c_str(), \"%d\", &result) == 1) {\n+      return result;\n+    } else {\n+      return -1;\n+    }\n+  }\n+\n+  // Return the ith key\n+  Slice Key(int i, std::string* storage) {\n+    char buf[100];\n+    snprintf(buf, sizeof(buf), \"%016d\", i);\n+    storage->assign(buf, strlen(buf));\n+    return Slice(*storage);\n+  }\n+\n+  // Return the value to associate with the specified key\n+  Slice Value(int k, std::string* storage) {\n+    Random r(k);\n+    return test::RandomString(&r, kValueSize, storage);\n+  }\n+};\n+\n+TEST(CorruptionTest, Recovery) {\n+  Build(100);\n+  Check(100, 100);\n+  Corrupt(kLogFile, 19, 1);      // WriteBatch tag for first record\n+  Corrupt(kLogFile, log::kBlockSize + 1000, 1);  // Somewhere in second block\n+  Reopen();\n+\n+  // The 64 records in the first two log blocks are completely lost.\n+  Check(36, 36);\n+}\n+\n+TEST(CorruptionTest, RecoverWriteError) {\n+  env_.writable_file_error_ = true;\n+  Status s = TryReopen();\n+  ASSERT_TRUE(!s.ok());\n+}\n+\n+TEST(CorruptionTest, NewFileErrorDuringWrite) {\n+  // Do enough writing to force minor compaction\n+  env_.writable_file_error_ = true;\n+  const int num = 3 + (Options().write_buffer_size / kValueSize);\n+  std::string value_storage;\n+  Status s;\n+  for (int i = 0; s.ok() && i < num; i++) {\n+    WriteBatch batch;\n+    batch.Put(\"a\", Value(100, &value_storage));\n+    s = db_->Write(WriteOptions(), &batch);\n+  }\n+  ASSERT_TRUE(!s.ok());\n+  ASSERT_GE(env_.num_writable_file_errors_, 1);\n+  env_.writable_file_error_ = false;\n+  Reopen();\n+}\n+\n+TEST(CorruptionTest, TableFile) {\n+  Build(100);\n+  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);\n+  dbi->TEST_CompactMemTable();\n+  dbi->TEST_CompactRange(0, NULL, NULL);\n+  dbi->TEST_CompactRange(1, NULL, NULL);\n+\n+  Corrupt(kTableFile, 100, 1);\n+  Check(99, 99);\n+}\n+\n+TEST(CorruptionTest, TableFileIndexData) {\n+  Build(10000);  // Enough to build multiple Tables\n+  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);\n+  dbi->TEST_CompactMemTable();\n+\n+  Corrupt(kTableFile, -2000, 500);\n+  Reopen();\n+  Check(5000, 9999);\n+}\n+\n+TEST(CorruptionTest, MissingDescriptor) {\n+  Build(1000);\n+  RepairDB();\n+  Reopen();\n+  Check(1000, 1000);\n+}\n+\n+TEST(CorruptionTest, SequenceNumberRecovery) {\n+  ASSERT_OK(db_->Put(WriteOptions(), \"foo\", \"v1\"));\n+  ASSERT_OK(db_->Put(WriteOptions(), \"foo\", \"v2\"));\n+  ASSERT_OK(db_->Put(WriteOptions(), \"foo\", \"v3\"));\n+  ASSERT_OK(db_->Put(WriteOptions(), \"foo\", \"v4\"));\n+  ASSERT_OK(db_->Put(WriteOptions(), \"foo\", \"v5\"));\n+  RepairDB();\n+  Reopen();\n+  std::string v;\n+  ASSERT_OK(db_->Get(ReadOptions(), \"foo\", &v));\n+  ASSERT_EQ(\"v5\", v);\n+  // Write something.  If sequence number was not recovered properly,\n+  // it will be hidden by an earlier write.\n+  ASSERT_OK(db_->Put(WriteOptions(), \"foo\", \"v6\"));\n+  ASSERT_OK(db_->Get(ReadOptions(), \"foo\", &v));\n+  ASSERT_EQ(\"v6\", v);\n+  Reopen();\n+  ASSERT_OK(db_->Get(ReadOptions(), \"foo\", &v));\n+  ASSERT_EQ(\"v6\", v);\n+}\n+\n+TEST(CorruptionTest, CorruptedDescriptor) {\n+  ASSERT_OK(db_->Put(WriteOptions(), \"foo\", \"hello\"));\n+  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);\n+  dbi->TEST_CompactMemTable();\n+  dbi->TEST_CompactRange(0, NULL, NULL);\n+\n+  Corrupt(kDescriptorFile, 0, 1000);\n+  Status s = TryReopen();\n+  ASSERT_TRUE(!s.ok());\n+\n+  RepairDB();\n+  Reopen();\n+  std::string v;\n+  ASSERT_OK(db_->Get(ReadOptions(), \"foo\", &v));\n+  ASSERT_EQ(\"hello\", v);\n+}\n+\n+TEST(CorruptionTest, CompactionInputError) {\n+  Build(10);\n+  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);\n+  dbi->TEST_CompactMemTable();\n+  const int last = config::kMaxMemCompactLevel;\n+  ASSERT_EQ(1, Property(\"leveldb.num-files-at-level\" + NumberToString(last)));\n+\n+  Corrupt(kTableFile, 100, 1);\n+  Check(9, 9);\n+\n+  // Force compactions by writing lots of values\n+  Build(10000);\n+  Check(10000, 10000);\n+}\n+\n+TEST(CorruptionTest, CompactionInputErrorParanoid) {\n+  Options options;\n+  options.paranoid_checks = true;\n+  options.write_buffer_size = 1048576;\n+  Reopen(&options);\n+  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);\n+\n+  // Fill levels >= 1 so memtable compaction outputs to level 1\n+  for (int level = 1; level < config::kNumLevels; level++) {\n+    dbi->Put(WriteOptions(), \"\", \"begin\");\n+    dbi->Put(WriteOptions(), \"~\", \"end\");\n+    dbi->TEST_CompactMemTable();\n+  }\n+\n+  Build(10);\n+  dbi->TEST_CompactMemTable();\n+  ASSERT_EQ(1, Property(\"leveldb.num-files-at-level0\"));\n+\n+  Corrupt(kTableFile, 100, 1);\n+  Check(9, 9);\n+\n+  // Write must eventually fail because of corrupted table\n+  Status s;\n+  std::string tmp1, tmp2;\n+  for (int i = 0; i < 10000 && s.ok(); i++) {\n+    s = db_->Put(WriteOptions(), Key(i, &tmp1), Value(i, &tmp2));\n+  }\n+  ASSERT_TRUE(!s.ok()) << \"write did not fail in corrupted paranoid db\";\n+}\n+\n+TEST(CorruptionTest, UnrelatedKeys) {\n+  Build(10);\n+  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);\n+  dbi->TEST_CompactMemTable();\n+  Corrupt(kTableFile, 100, 1);\n+\n+  std::string tmp1, tmp2;\n+  ASSERT_OK(db_->Put(WriteOptions(), Key(1000, &tmp1), Value(1000, &tmp2)));\n+  std::string v;\n+  ASSERT_OK(db_->Get(ReadOptions(), Key(1000, &tmp1), &v));\n+  ASSERT_EQ(Value(1000, &tmp2).ToString(), v);\n+  dbi->TEST_CompactMemTable();\n+  ASSERT_OK(db_->Get(ReadOptions(), Key(1000, &tmp1), &v));\n+  ASSERT_EQ(Value(1000, &tmp2).ToString(), v);\n+}\n+\n+}  // namespace leveldb\n+\n+int main(int argc, char** argv) {\n+  return leveldb::test::RunAllTests();\n+}"
      },
      {
        "sha": "21d3e25f31f65541b88f0f3e6ed2503f12e1d828",
        "filename": "src/leveldb/db/db_bench.cc",
        "status": "added",
        "additions": 978,
        "deletions": 0,
        "changes": 978,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/db_bench.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/db_bench.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/db_bench.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,978 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include <sys/types.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include \"db/db_impl.h\"\n+#include \"db/version_set.h\"\n+#include \"leveldb/cache.h\"\n+#include \"leveldb/db.h\"\n+#include \"leveldb/env.h\"\n+#include \"leveldb/write_batch.h\"\n+#include \"port/port.h\"\n+#include \"util/crc32c.h\"\n+#include \"util/histogram.h\"\n+#include \"util/mutexlock.h\"\n+#include \"util/random.h\"\n+#include \"util/testutil.h\"\n+\n+// Comma-separated list of operations to run in the specified order\n+//   Actual benchmarks:\n+//      fillseq       -- write N values in sequential key order in async mode\n+//      fillrandom    -- write N values in random key order in async mode\n+//      overwrite     -- overwrite N values in random key order in async mode\n+//      fillsync      -- write N/100 values in random key order in sync mode\n+//      fill100K      -- write N/1000 100K values in random order in async mode\n+//      deleteseq     -- delete N keys in sequential order\n+//      deleterandom  -- delete N keys in random order\n+//      readseq       -- read N times sequentially\n+//      readreverse   -- read N times in reverse order\n+//      readrandom    -- read N times in random order\n+//      readmissing   -- read N missing keys in random order\n+//      readhot       -- read N times in random order from 1% section of DB\n+//      seekrandom    -- N random seeks\n+//      crc32c        -- repeated crc32c of 4K of data\n+//      acquireload   -- load N*1000 times\n+//   Meta operations:\n+//      compact     -- Compact the entire DB\n+//      stats       -- Print DB stats\n+//      sstables    -- Print sstable info\n+//      heapprofile -- Dump a heap profile (if supported by this port)\n+static const char* FLAGS_benchmarks =\n+    \"fillseq,\"\n+    \"fillsync,\"\n+    \"fillrandom,\"\n+    \"overwrite,\"\n+    \"readrandom,\"\n+    \"readrandom,\"  // Extra run to allow previous compactions to quiesce\n+    \"readseq,\"\n+    \"readreverse,\"\n+    \"compact,\"\n+    \"readrandom,\"\n+    \"readseq,\"\n+    \"readreverse,\"\n+    \"fill100K,\"\n+    \"crc32c,\"\n+    \"snappycomp,\"\n+    \"snappyuncomp,\"\n+    \"acquireload,\"\n+    ;\n+\n+// Number of key/values to place in database\n+static int FLAGS_num = 1000000;\n+\n+// Number of read operations to do.  If negative, do FLAGS_num reads.\n+static int FLAGS_reads = -1;\n+\n+// Number of concurrent threads to run.\n+static int FLAGS_threads = 1;\n+\n+// Size of each value\n+static int FLAGS_value_size = 100;\n+\n+// Arrange to generate values that shrink to this fraction of\n+// their original size after compression\n+static double FLAGS_compression_ratio = 0.5;\n+\n+// Print histogram of operation timings\n+static bool FLAGS_histogram = false;\n+\n+// Number of bytes to buffer in memtable before compacting\n+// (initialized to default value by \"main\")\n+static int FLAGS_write_buffer_size = 0;\n+\n+// Number of bytes to use as a cache of uncompressed data.\n+// Negative means use default settings.\n+static int FLAGS_cache_size = -1;\n+\n+// Maximum number of files to keep open at the same time (use default if == 0)\n+static int FLAGS_open_files = 0;\n+\n+// Bloom filter bits per key.\n+// Negative means use default settings.\n+static int FLAGS_bloom_bits = -1;\n+\n+// If true, do not destroy the existing database.  If you set this\n+// flag and also specify a benchmark that wants a fresh database, that\n+// benchmark will fail.\n+static bool FLAGS_use_existing_db = false;\n+\n+// Use the db with the following name.\n+static const char* FLAGS_db = NULL;\n+\n+namespace leveldb {\n+\n+namespace {\n+\n+// Helper for quickly generating random data.\n+class RandomGenerator {\n+ private:\n+  std::string data_;\n+  int pos_;\n+\n+ public:\n+  RandomGenerator() {\n+    // We use a limited amount of data over and over again and ensure\n+    // that it is larger than the compression window (32KB), and also\n+    // large enough to serve all typical value sizes we want to write.\n+    Random rnd(301);\n+    std::string piece;\n+    while (data_.size() < 1048576) {\n+      // Add a short fragment that is as compressible as specified\n+      // by FLAGS_compression_ratio.\n+      test::CompressibleString(&rnd, FLAGS_compression_ratio, 100, &piece);\n+      data_.append(piece);\n+    }\n+    pos_ = 0;\n+  }\n+\n+  Slice Generate(int len) {\n+    if (pos_ + len > data_.size()) {\n+      pos_ = 0;\n+      assert(len < data_.size());\n+    }\n+    pos_ += len;\n+    return Slice(data_.data() + pos_ - len, len);\n+  }\n+};\n+\n+static Slice TrimSpace(Slice s) {\n+  int start = 0;\n+  while (start < s.size() && isspace(s[start])) {\n+    start++;\n+  }\n+  int limit = s.size();\n+  while (limit > start && isspace(s[limit-1])) {\n+    limit--;\n+  }\n+  return Slice(s.data() + start, limit - start);\n+}\n+\n+static void AppendWithSpace(std::string* str, Slice msg) {\n+  if (msg.empty()) return;\n+  if (!str->empty()) {\n+    str->push_back(' ');\n+  }\n+  str->append(msg.data(), msg.size());\n+}\n+\n+class Stats {\n+ private:\n+  double start_;\n+  double finish_;\n+  double seconds_;\n+  int done_;\n+  int next_report_;\n+  int64_t bytes_;\n+  double last_op_finish_;\n+  Histogram hist_;\n+  std::string message_;\n+\n+ public:\n+  Stats() { Start(); }\n+\n+  void Start() {\n+    next_report_ = 100;\n+    last_op_finish_ = start_;\n+    hist_.Clear();\n+    done_ = 0;\n+    bytes_ = 0;\n+    seconds_ = 0;\n+    start_ = Env::Default()->NowMicros();\n+    finish_ = start_;\n+    message_.clear();\n+  }\n+\n+  void Merge(const Stats& other) {\n+    hist_.Merge(other.hist_);\n+    done_ += other.done_;\n+    bytes_ += other.bytes_;\n+    seconds_ += other.seconds_;\n+    if (other.start_ < start_) start_ = other.start_;\n+    if (other.finish_ > finish_) finish_ = other.finish_;\n+\n+    // Just keep the messages from one thread\n+    if (message_.empty()) message_ = other.message_;\n+  }\n+\n+  void Stop() {\n+    finish_ = Env::Default()->NowMicros();\n+    seconds_ = (finish_ - start_) * 1e-6;\n+  }\n+\n+  void AddMessage(Slice msg) {\n+    AppendWithSpace(&message_, msg);\n+  }\n+\n+  void FinishedSingleOp() {\n+    if (FLAGS_histogram) {\n+      double now = Env::Default()->NowMicros();\n+      double micros = now - last_op_finish_;\n+      hist_.Add(micros);\n+      if (micros > 20000) {\n+        fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n+        fflush(stderr);\n+      }\n+      last_op_finish_ = now;\n+    }\n+\n+    done_++;\n+    if (done_ >= next_report_) {\n+      if      (next_report_ < 1000)   next_report_ += 100;\n+      else if (next_report_ < 5000)   next_report_ += 500;\n+      else if (next_report_ < 10000)  next_report_ += 1000;\n+      else if (next_report_ < 50000)  next_report_ += 5000;\n+      else if (next_report_ < 100000) next_report_ += 10000;\n+      else if (next_report_ < 500000) next_report_ += 50000;\n+      else                            next_report_ += 100000;\n+      fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n+      fflush(stderr);\n+    }\n+  }\n+\n+  void AddBytes(int64_t n) {\n+    bytes_ += n;\n+  }\n+\n+  void Report(const Slice& name) {\n+    // Pretend at least one op was done in case we are running a benchmark\n+    // that does not call FinishedSingleOp().\n+    if (done_ < 1) done_ = 1;\n+\n+    std::string extra;\n+    if (bytes_ > 0) {\n+      // Rate is computed on actual elapsed time, not the sum of per-thread\n+      // elapsed times.\n+      double elapsed = (finish_ - start_) * 1e-6;\n+      char rate[100];\n+      snprintf(rate, sizeof(rate), \"%6.1f MB/s\",\n+               (bytes_ / 1048576.0) / elapsed);\n+      extra = rate;\n+    }\n+    AppendWithSpace(&extra, message_);\n+\n+    fprintf(stdout, \"%-12s : %11.3f micros/op;%s%s\\n\",\n+            name.ToString().c_str(),\n+            seconds_ * 1e6 / done_,\n+            (extra.empty() ? \"\" : \" \"),\n+            extra.c_str());\n+    if (FLAGS_histogram) {\n+      fprintf(stdout, \"Microseconds per op:\\n%s\\n\", hist_.ToString().c_str());\n+    }\n+    fflush(stdout);\n+  }\n+};\n+\n+// State shared by all concurrent executions of the same benchmark.\n+struct SharedState {\n+  port::Mutex mu;\n+  port::CondVar cv;\n+  int total;\n+\n+  // Each thread goes through the following states:\n+  //    (1) initializing\n+  //    (2) waiting for others to be initialized\n+  //    (3) running\n+  //    (4) done\n+\n+  int num_initialized;\n+  int num_done;\n+  bool start;\n+\n+  SharedState() : cv(&mu) { }\n+};\n+\n+// Per-thread state for concurrent executions of the same benchmark.\n+struct ThreadState {\n+  int tid;             // 0..n-1 when running in n threads\n+  Random rand;         // Has different seeds for different threads\n+  Stats stats;\n+  SharedState* shared;\n+\n+  ThreadState(int index)\n+      : tid(index),\n+        rand(1000 + index) {\n+  }\n+};\n+\n+}  // namespace\n+\n+class Benchmark {\n+ private:\n+  Cache* cache_;\n+  const FilterPolicy* filter_policy_;\n+  DB* db_;\n+  int num_;\n+  int value_size_;\n+  int entries_per_batch_;\n+  WriteOptions write_options_;\n+  int reads_;\n+  int heap_counter_;\n+\n+  void PrintHeader() {\n+    const int kKeySize = 16;\n+    PrintEnvironment();\n+    fprintf(stdout, \"Keys:       %d bytes each\\n\", kKeySize);\n+    fprintf(stdout, \"Values:     %d bytes each (%d bytes after compression)\\n\",\n+            FLAGS_value_size,\n+            static_cast<int>(FLAGS_value_size * FLAGS_compression_ratio + 0.5));\n+    fprintf(stdout, \"Entries:    %d\\n\", num_);\n+    fprintf(stdout, \"RawSize:    %.1f MB (estimated)\\n\",\n+            ((static_cast<int64_t>(kKeySize + FLAGS_value_size) * num_)\n+             / 1048576.0));\n+    fprintf(stdout, \"FileSize:   %.1f MB (estimated)\\n\",\n+            (((kKeySize + FLAGS_value_size * FLAGS_compression_ratio) * num_)\n+             / 1048576.0));\n+    PrintWarnings();\n+    fprintf(stdout, \"------------------------------------------------\\n\");\n+  }\n+\n+  void PrintWarnings() {\n+#if defined(__GNUC__) && !defined(__OPTIMIZE__)\n+    fprintf(stdout,\n+            \"WARNING: Optimization is disabled: benchmarks unnecessarily slow\\n\"\n+            );\n+#endif\n+#ifndef NDEBUG\n+    fprintf(stdout,\n+            \"WARNING: Assertions are enabled; benchmarks unnecessarily slow\\n\");\n+#endif\n+\n+    // See if snappy is working by attempting to compress a compressible string\n+    const char text[] = \"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\";\n+    std::string compressed;\n+    if (!port::Snappy_Compress(text, sizeof(text), &compressed)) {\n+      fprintf(stdout, \"WARNING: Snappy compression is not enabled\\n\");\n+    } else if (compressed.size() >= sizeof(text)) {\n+      fprintf(stdout, \"WARNING: Snappy compression is not effective\\n\");\n+    }\n+  }\n+\n+  void PrintEnvironment() {\n+    fprintf(stderr, \"LevelDB:    version %d.%d\\n\",\n+            kMajorVersion, kMinorVersion);\n+\n+#if defined(__linux)\n+    time_t now = time(NULL);\n+    fprintf(stderr, \"Date:       %s\", ctime(&now));  // ctime() adds newline\n+\n+    FILE* cpuinfo = fopen(\"/proc/cpuinfo\", \"r\");\n+    if (cpuinfo != NULL) {\n+      char line[1000];\n+      int num_cpus = 0;\n+      std::string cpu_type;\n+      std::string cache_size;\n+      while (fgets(line, sizeof(line), cpuinfo) != NULL) {\n+        const char* sep = strchr(line, ':');\n+        if (sep == NULL) {\n+          continue;\n+        }\n+        Slice key = TrimSpace(Slice(line, sep - 1 - line));\n+        Slice val = TrimSpace(Slice(sep + 1));\n+        if (key == \"model name\") {\n+          ++num_cpus;\n+          cpu_type = val.ToString();\n+        } else if (key == \"cache size\") {\n+          cache_size = val.ToString();\n+        }\n+      }\n+      fclose(cpuinfo);\n+      fprintf(stderr, \"CPU:        %d * %s\\n\", num_cpus, cpu_type.c_str());\n+      fprintf(stderr, \"CPUCache:   %s\\n\", cache_size.c_str());\n+    }\n+#endif\n+  }\n+\n+ public:\n+  Benchmark()\n+  : cache_(FLAGS_cache_size >= 0 ? NewLRUCache(FLAGS_cache_size) : NULL),\n+    filter_policy_(FLAGS_bloom_bits >= 0\n+                   ? NewBloomFilterPolicy(FLAGS_bloom_bits)\n+                   : NULL),\n+    db_(NULL),\n+    num_(FLAGS_num),\n+    value_size_(FLAGS_value_size),\n+    entries_per_batch_(1),\n+    reads_(FLAGS_reads < 0 ? FLAGS_num : FLAGS_reads),\n+    heap_counter_(0) {\n+    std::vector<std::string> files;\n+    Env::Default()->GetChildren(FLAGS_db, &files);\n+    for (int i = 0; i < files.size(); i++) {\n+      if (Slice(files[i]).starts_with(\"heap-\")) {\n+        Env::Default()->DeleteFile(std::string(FLAGS_db) + \"/\" + files[i]);\n+      }\n+    }\n+    if (!FLAGS_use_existing_db) {\n+      DestroyDB(FLAGS_db, Options());\n+    }\n+  }\n+\n+  ~Benchmark() {\n+    delete db_;\n+    delete cache_;\n+    delete filter_policy_;\n+  }\n+\n+  void Run() {\n+    PrintHeader();\n+    Open();\n+\n+    const char* benchmarks = FLAGS_benchmarks;\n+    while (benchmarks != NULL) {\n+      const char* sep = strchr(benchmarks, ',');\n+      Slice name;\n+      if (sep == NULL) {\n+        name = benchmarks;\n+        benchmarks = NULL;\n+      } else {\n+        name = Slice(benchmarks, sep - benchmarks);\n+        benchmarks = sep + 1;\n+      }\n+\n+      // Reset parameters that may be overriddden bwlow\n+      num_ = FLAGS_num;\n+      reads_ = (FLAGS_reads < 0 ? FLAGS_num : FLAGS_reads);\n+      value_size_ = FLAGS_value_size;\n+      entries_per_batch_ = 1;\n+      write_options_ = WriteOptions();\n+\n+      void (Benchmark::*method)(ThreadState*) = NULL;\n+      bool fresh_db = false;\n+      int num_threads = FLAGS_threads;\n+\n+      if (name == Slice(\"fillseq\")) {\n+        fresh_db = true;\n+        method = &Benchmark::WriteSeq;\n+      } else if (name == Slice(\"fillbatch\")) {\n+        fresh_db = true;\n+        entries_per_batch_ = 1000;\n+        method = &Benchmark::WriteSeq;\n+      } else if (name == Slice(\"fillrandom\")) {\n+        fresh_db = true;\n+        method = &Benchmark::WriteRandom;\n+      } else if (name == Slice(\"overwrite\")) {\n+        fresh_db = false;\n+        method = &Benchmark::WriteRandom;\n+      } else if (name == Slice(\"fillsync\")) {\n+        fresh_db = true;\n+        num_ /= 1000;\n+        write_options_.sync = true;\n+        method = &Benchmark::WriteRandom;\n+      } else if (name == Slice(\"fill100K\")) {\n+        fresh_db = true;\n+        num_ /= 1000;\n+        value_size_ = 100 * 1000;\n+        method = &Benchmark::WriteRandom;\n+      } else if (name == Slice(\"readseq\")) {\n+        method = &Benchmark::ReadSequential;\n+      } else if (name == Slice(\"readreverse\")) {\n+        method = &Benchmark::ReadReverse;\n+      } else if (name == Slice(\"readrandom\")) {\n+        method = &Benchmark::ReadRandom;\n+      } else if (name == Slice(\"readmissing\")) {\n+        method = &Benchmark::ReadMissing;\n+      } else if (name == Slice(\"seekrandom\")) {\n+        method = &Benchmark::SeekRandom;\n+      } else if (name == Slice(\"readhot\")) {\n+        method = &Benchmark::ReadHot;\n+      } else if (name == Slice(\"readrandomsmall\")) {\n+        reads_ /= 1000;\n+        method = &Benchmark::ReadRandom;\n+      } else if (name == Slice(\"deleteseq\")) {\n+        method = &Benchmark::DeleteSeq;\n+      } else if (name == Slice(\"deleterandom\")) {\n+        method = &Benchmark::DeleteRandom;\n+      } else if (name == Slice(\"readwhilewriting\")) {\n+        num_threads++;  // Add extra thread for writing\n+        method = &Benchmark::ReadWhileWriting;\n+      } else if (name == Slice(\"compact\")) {\n+        method = &Benchmark::Compact;\n+      } else if (name == Slice(\"crc32c\")) {\n+        method = &Benchmark::Crc32c;\n+      } else if (name == Slice(\"acquireload\")) {\n+        method = &Benchmark::AcquireLoad;\n+      } else if (name == Slice(\"snappycomp\")) {\n+        method = &Benchmark::SnappyCompress;\n+      } else if (name == Slice(\"snappyuncomp\")) {\n+        method = &Benchmark::SnappyUncompress;\n+      } else if (name == Slice(\"heapprofile\")) {\n+        HeapProfile();\n+      } else if (name == Slice(\"stats\")) {\n+        PrintStats(\"leveldb.stats\");\n+      } else if (name == Slice(\"sstables\")) {\n+        PrintStats(\"leveldb.sstables\");\n+      } else {\n+        if (name != Slice()) {  // No error message for empty name\n+          fprintf(stderr, \"unknown benchmark '%s'\\n\", name.ToString().c_str());\n+        }\n+      }\n+\n+      if (fresh_db) {\n+        if (FLAGS_use_existing_db) {\n+          fprintf(stdout, \"%-12s : skipped (--use_existing_db is true)\\n\",\n+                  name.ToString().c_str());\n+          method = NULL;\n+        } else {\n+          delete db_;\n+          db_ = NULL;\n+          DestroyDB(FLAGS_db, Options());\n+          Open();\n+        }\n+      }\n+\n+      if (method != NULL) {\n+        RunBenchmark(num_threads, name, method);\n+      }\n+    }\n+  }\n+\n+ private:\n+  struct ThreadArg {\n+    Benchmark* bm;\n+    SharedState* shared;\n+    ThreadState* thread;\n+    void (Benchmark::*method)(ThreadState*);\n+  };\n+\n+  static void ThreadBody(void* v) {\n+    ThreadArg* arg = reinterpret_cast<ThreadArg*>(v);\n+    SharedState* shared = arg->shared;\n+    ThreadState* thread = arg->thread;\n+    {\n+      MutexLock l(&shared->mu);\n+      shared->num_initialized++;\n+      if (shared->num_initialized >= shared->total) {\n+        shared->cv.SignalAll();\n+      }\n+      while (!shared->start) {\n+        shared->cv.Wait();\n+      }\n+    }\n+\n+    thread->stats.Start();\n+    (arg->bm->*(arg->method))(thread);\n+    thread->stats.Stop();\n+\n+    {\n+      MutexLock l(&shared->mu);\n+      shared->num_done++;\n+      if (shared->num_done >= shared->total) {\n+        shared->cv.SignalAll();\n+      }\n+    }\n+  }\n+\n+  void RunBenchmark(int n, Slice name,\n+                    void (Benchmark::*method)(ThreadState*)) {\n+    SharedState shared;\n+    shared.total = n;\n+    shared.num_initialized = 0;\n+    shared.num_done = 0;\n+    shared.start = false;\n+\n+    ThreadArg* arg = new ThreadArg[n];\n+    for (int i = 0; i < n; i++) {\n+      arg[i].bm = this;\n+      arg[i].method = method;\n+      arg[i].shared = &shared;\n+      arg[i].thread = new ThreadState(i);\n+      arg[i].thread->shared = &shared;\n+      Env::Default()->StartThread(ThreadBody, &arg[i]);\n+    }\n+\n+    shared.mu.Lock();\n+    while (shared.num_initialized < n) {\n+      shared.cv.Wait();\n+    }\n+\n+    shared.start = true;\n+    shared.cv.SignalAll();\n+    while (shared.num_done < n) {\n+      shared.cv.Wait();\n+    }\n+    shared.mu.Unlock();\n+\n+    for (int i = 1; i < n; i++) {\n+      arg[0].thread->stats.Merge(arg[i].thread->stats);\n+    }\n+    arg[0].thread->stats.Report(name);\n+\n+    for (int i = 0; i < n; i++) {\n+      delete arg[i].thread;\n+    }\n+    delete[] arg;\n+  }\n+\n+  void Crc32c(ThreadState* thread) {\n+    // Checksum about 500MB of data total\n+    const int size = 4096;\n+    const char* label = \"(4K per op)\";\n+    std::string data(size, 'x');\n+    int64_t bytes = 0;\n+    uint32_t crc = 0;\n+    while (bytes < 500 * 1048576) {\n+      crc = crc32c::Value(data.data(), size);\n+      thread->stats.FinishedSingleOp();\n+      bytes += size;\n+    }\n+    // Print so result is not dead\n+    fprintf(stderr, \"... crc=0x%x\\r\", static_cast<unsigned int>(crc));\n+\n+    thread->stats.AddBytes(bytes);\n+    thread->stats.AddMessage(label);\n+  }\n+\n+  void AcquireLoad(ThreadState* thread) {\n+    int dummy;\n+    port::AtomicPointer ap(&dummy);\n+    int count = 0;\n+    void *ptr = NULL;\n+    thread->stats.AddMessage(\"(each op is 1000 loads)\");\n+    while (count < 100000) {\n+      for (int i = 0; i < 1000; i++) {\n+        ptr = ap.Acquire_Load();\n+      }\n+      count++;\n+      thread->stats.FinishedSingleOp();\n+    }\n+    if (ptr == NULL) exit(1); // Disable unused variable warning.\n+  }\n+\n+  void SnappyCompress(ThreadState* thread) {\n+    RandomGenerator gen;\n+    Slice input = gen.Generate(Options().block_size);\n+    int64_t bytes = 0;\n+    int64_t produced = 0;\n+    bool ok = true;\n+    std::string compressed;\n+    while (ok && bytes < 1024 * 1048576) {  // Compress 1G\n+      ok = port::Snappy_Compress(input.data(), input.size(), &compressed);\n+      produced += compressed.size();\n+      bytes += input.size();\n+      thread->stats.FinishedSingleOp();\n+    }\n+\n+    if (!ok) {\n+      thread->stats.AddMessage(\"(snappy failure)\");\n+    } else {\n+      char buf[100];\n+      snprintf(buf, sizeof(buf), \"(output: %.1f%%)\",\n+               (produced * 100.0) / bytes);\n+      thread->stats.AddMessage(buf);\n+      thread->stats.AddBytes(bytes);\n+    }\n+  }\n+\n+  void SnappyUncompress(ThreadState* thread) {\n+    RandomGenerator gen;\n+    Slice input = gen.Generate(Options().block_size);\n+    std::string compressed;\n+    bool ok = port::Snappy_Compress(input.data(), input.size(), &compressed);\n+    int64_t bytes = 0;\n+    char* uncompressed = new char[input.size()];\n+    while (ok && bytes < 1024 * 1048576) {  // Compress 1G\n+      ok =  port::Snappy_Uncompress(compressed.data(), compressed.size(),\n+                                    uncompressed);\n+      bytes += input.size();\n+      thread->stats.FinishedSingleOp();\n+    }\n+    delete[] uncompressed;\n+\n+    if (!ok) {\n+      thread->stats.AddMessage(\"(snappy failure)\");\n+    } else {\n+      thread->stats.AddBytes(bytes);\n+    }\n+  }\n+\n+  void Open() {\n+    assert(db_ == NULL);\n+    Options options;\n+    options.create_if_missing = !FLAGS_use_existing_db;\n+    options.block_cache = cache_;\n+    options.write_buffer_size = FLAGS_write_buffer_size;\n+    options.filter_policy = filter_policy_;\n+    Status s = DB::Open(options, FLAGS_db, &db_);\n+    if (!s.ok()) {\n+      fprintf(stderr, \"open error: %s\\n\", s.ToString().c_str());\n+      exit(1);\n+    }\n+  }\n+\n+  void WriteSeq(ThreadState* thread) {\n+    DoWrite(thread, true);\n+  }\n+\n+  void WriteRandom(ThreadState* thread) {\n+    DoWrite(thread, false);\n+  }\n+\n+  void DoWrite(ThreadState* thread, bool seq) {\n+    if (num_ != FLAGS_num) {\n+      char msg[100];\n+      snprintf(msg, sizeof(msg), \"(%d ops)\", num_);\n+      thread->stats.AddMessage(msg);\n+    }\n+\n+    RandomGenerator gen;\n+    WriteBatch batch;\n+    Status s;\n+    int64_t bytes = 0;\n+    for (int i = 0; i < num_; i += entries_per_batch_) {\n+      batch.Clear();\n+      for (int j = 0; j < entries_per_batch_; j++) {\n+        const int k = seq ? i+j : (thread->rand.Next() % FLAGS_num);\n+        char key[100];\n+        snprintf(key, sizeof(key), \"%016d\", k);\n+        batch.Put(key, gen.Generate(value_size_));\n+        bytes += value_size_ + strlen(key);\n+        thread->stats.FinishedSingleOp();\n+      }\n+      s = db_->Write(write_options_, &batch);\n+      if (!s.ok()) {\n+        fprintf(stderr, \"put error: %s\\n\", s.ToString().c_str());\n+        exit(1);\n+      }\n+    }\n+    thread->stats.AddBytes(bytes);\n+  }\n+\n+  void ReadSequential(ThreadState* thread) {\n+    Iterator* iter = db_->NewIterator(ReadOptions());\n+    int i = 0;\n+    int64_t bytes = 0;\n+    for (iter->SeekToFirst(); i < reads_ && iter->Valid(); iter->Next()) {\n+      bytes += iter->key().size() + iter->value().size();\n+      thread->stats.FinishedSingleOp();\n+      ++i;\n+    }\n+    delete iter;\n+    thread->stats.AddBytes(bytes);\n+  }\n+\n+  void ReadReverse(ThreadState* thread) {\n+    Iterator* iter = db_->NewIterator(ReadOptions());\n+    int i = 0;\n+    int64_t bytes = 0;\n+    for (iter->SeekToLast(); i < reads_ && iter->Valid(); iter->Prev()) {\n+      bytes += iter->key().size() + iter->value().size();\n+      thread->stats.FinishedSingleOp();\n+      ++i;\n+    }\n+    delete iter;\n+    thread->stats.AddBytes(bytes);\n+  }\n+\n+  void ReadRandom(ThreadState* thread) {\n+    ReadOptions options;\n+    std::string value;\n+    int found = 0;\n+    for (int i = 0; i < reads_; i++) {\n+      char key[100];\n+      const int k = thread->rand.Next() % FLAGS_num;\n+      snprintf(key, sizeof(key), \"%016d\", k);\n+      if (db_->Get(options, key, &value).ok()) {\n+        found++;\n+      }\n+      thread->stats.FinishedSingleOp();\n+    }\n+    char msg[100];\n+    snprintf(msg, sizeof(msg), \"(%d of %d found)\", found, num_);\n+    thread->stats.AddMessage(msg);\n+  }\n+\n+  void ReadMissing(ThreadState* thread) {\n+    ReadOptions options;\n+    std::string value;\n+    for (int i = 0; i < reads_; i++) {\n+      char key[100];\n+      const int k = thread->rand.Next() % FLAGS_num;\n+      snprintf(key, sizeof(key), \"%016d.\", k);\n+      db_->Get(options, key, &value);\n+      thread->stats.FinishedSingleOp();\n+    }\n+  }\n+\n+  void ReadHot(ThreadState* thread) {\n+    ReadOptions options;\n+    std::string value;\n+    const int range = (FLAGS_num + 99) / 100;\n+    for (int i = 0; i < reads_; i++) {\n+      char key[100];\n+      const int k = thread->rand.Next() % range;\n+      snprintf(key, sizeof(key), \"%016d\", k);\n+      db_->Get(options, key, &value);\n+      thread->stats.FinishedSingleOp();\n+    }\n+  }\n+\n+  void SeekRandom(ThreadState* thread) {\n+    ReadOptions options;\n+    std::string value;\n+    int found = 0;\n+    for (int i = 0; i < reads_; i++) {\n+      Iterator* iter = db_->NewIterator(options);\n+      char key[100];\n+      const int k = thread->rand.Next() % FLAGS_num;\n+      snprintf(key, sizeof(key), \"%016d\", k);\n+      iter->Seek(key);\n+      if (iter->Valid() && iter->key() == key) found++;\n+      delete iter;\n+      thread->stats.FinishedSingleOp();\n+    }\n+    char msg[100];\n+    snprintf(msg, sizeof(msg), \"(%d of %d found)\", found, num_);\n+    thread->stats.AddMessage(msg);\n+  }\n+\n+  void DoDelete(ThreadState* thread, bool seq) {\n+    RandomGenerator gen;\n+    WriteBatch batch;\n+    Status s;\n+    for (int i = 0; i < num_; i += entries_per_batch_) {\n+      batch.Clear();\n+      for (int j = 0; j < entries_per_batch_; j++) {\n+        const int k = seq ? i+j : (thread->rand.Next() % FLAGS_num);\n+        char key[100];\n+        snprintf(key, sizeof(key), \"%016d\", k);\n+        batch.Delete(key);\n+        thread->stats.FinishedSingleOp();\n+      }\n+      s = db_->Write(write_options_, &batch);\n+      if (!s.ok()) {\n+        fprintf(stderr, \"del error: %s\\n\", s.ToString().c_str());\n+        exit(1);\n+      }\n+    }\n+  }\n+\n+  void DeleteSeq(ThreadState* thread) {\n+    DoDelete(thread, true);\n+  }\n+\n+  void DeleteRandom(ThreadState* thread) {\n+    DoDelete(thread, false);\n+  }\n+\n+  void ReadWhileWriting(ThreadState* thread) {\n+    if (thread->tid > 0) {\n+      ReadRandom(thread);\n+    } else {\n+      // Special thread that keeps writing until other threads are done.\n+      RandomGenerator gen;\n+      while (true) {\n+        {\n+          MutexLock l(&thread->shared->mu);\n+          if (thread->shared->num_done + 1 >= thread->shared->num_initialized) {\n+            // Other threads have finished\n+            break;\n+          }\n+        }\n+\n+        const int k = thread->rand.Next() % FLAGS_num;\n+        char key[100];\n+        snprintf(key, sizeof(key), \"%016d\", k);\n+        Status s = db_->Put(write_options_, key, gen.Generate(value_size_));\n+        if (!s.ok()) {\n+          fprintf(stderr, \"put error: %s\\n\", s.ToString().c_str());\n+          exit(1);\n+        }\n+      }\n+\n+      // Do not count any of the preceding work/delay in stats.\n+      thread->stats.Start();\n+    }\n+  }\n+\n+  void Compact(ThreadState* thread) {\n+    db_->CompactRange(NULL, NULL);\n+  }\n+\n+  void PrintStats(const char* key) {\n+    std::string stats;\n+    if (!db_->GetProperty(key, &stats)) {\n+      stats = \"(failed)\";\n+    }\n+    fprintf(stdout, \"\\n%s\\n\", stats.c_str());\n+  }\n+\n+  static void WriteToFile(void* arg, const char* buf, int n) {\n+    reinterpret_cast<WritableFile*>(arg)->Append(Slice(buf, n));\n+  }\n+\n+  void HeapProfile() {\n+    char fname[100];\n+    snprintf(fname, sizeof(fname), \"%s/heap-%04d\", FLAGS_db, ++heap_counter_);\n+    WritableFile* file;\n+    Status s = Env::Default()->NewWritableFile(fname, &file);\n+    if (!s.ok()) {\n+      fprintf(stderr, \"%s\\n\", s.ToString().c_str());\n+      return;\n+    }\n+    bool ok = port::GetHeapProfile(WriteToFile, file);\n+    delete file;\n+    if (!ok) {\n+      fprintf(stderr, \"heap profiling not supported\\n\");\n+      Env::Default()->DeleteFile(fname);\n+    }\n+  }\n+};\n+\n+}  // namespace leveldb\n+\n+int main(int argc, char** argv) {\n+  FLAGS_write_buffer_size = leveldb::Options().write_buffer_size;\n+  FLAGS_open_files = leveldb::Options().max_open_files;\n+  std::string default_db_path;\n+\n+  for (int i = 1; i < argc; i++) {\n+    double d;\n+    int n;\n+    char junk;\n+    if (leveldb::Slice(argv[i]).starts_with(\"--benchmarks=\")) {\n+      FLAGS_benchmarks = argv[i] + strlen(\"--benchmarks=\");\n+    } else if (sscanf(argv[i], \"--compression_ratio=%lf%c\", &d, &junk) == 1) {\n+      FLAGS_compression_ratio = d;\n+    } else if (sscanf(argv[i], \"--histogram=%d%c\", &n, &junk) == 1 &&\n+               (n == 0 || n == 1)) {\n+      FLAGS_histogram = n;\n+    } else if (sscanf(argv[i], \"--use_existing_db=%d%c\", &n, &junk) == 1 &&\n+               (n == 0 || n == 1)) {\n+      FLAGS_use_existing_db = n;\n+    } else if (sscanf(argv[i], \"--num=%d%c\", &n, &junk) == 1) {\n+      FLAGS_num = n;\n+    } else if (sscanf(argv[i], \"--reads=%d%c\", &n, &junk) == 1) {\n+      FLAGS_reads = n;\n+    } else if (sscanf(argv[i], \"--threads=%d%c\", &n, &junk) == 1) {\n+      FLAGS_threads = n;\n+    } else if (sscanf(argv[i], \"--value_size=%d%c\", &n, &junk) == 1) {\n+      FLAGS_value_size = n;\n+    } else if (sscanf(argv[i], \"--write_buffer_size=%d%c\", &n, &junk) == 1) {\n+      FLAGS_write_buffer_size = n;\n+    } else if (sscanf(argv[i], \"--cache_size=%d%c\", &n, &junk) == 1) {\n+      FLAGS_cache_size = n;\n+    } else if (sscanf(argv[i], \"--bloom_bits=%d%c\", &n, &junk) == 1) {\n+      FLAGS_bloom_bits = n;\n+    } else if (sscanf(argv[i], \"--open_files=%d%c\", &n, &junk) == 1) {\n+      FLAGS_open_files = n;\n+    } else if (strncmp(argv[i], \"--db=\", 5) == 0) {\n+      FLAGS_db = argv[i] + 5;\n+    } else {\n+      fprintf(stderr, \"Invalid flag '%s'\\n\", argv[i]);\n+      exit(1);\n+    }\n+  }\n+\n+  // Choose a location for the test database if none given with --db=<path>\n+  if (FLAGS_db == NULL) {\n+      leveldb::Env::Default()->GetTestDirectory(&default_db_path);\n+      default_db_path += \"/dbbench\";\n+      FLAGS_db = default_db_path.c_str();\n+  }\n+\n+  leveldb::Benchmark benchmark;\n+  benchmark.Run();\n+  return 0;\n+}"
      },
      {
        "sha": "90c1c811d88d1a5daa22c4a95e60c47afb51b716",
        "filename": "src/leveldb/db/db_impl.cc",
        "status": "added",
        "additions": 1463,
        "deletions": 0,
        "changes": 1463,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/db_impl.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/db_impl.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/db_impl.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,1463 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include \"db/db_impl.h\"\n+\n+#include <algorithm>\n+#include <set>\n+#include <string>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <vector>\n+#include \"db/builder.h\"\n+#include \"db/db_iter.h\"\n+#include \"db/dbformat.h\"\n+#include \"db/filename.h\"\n+#include \"db/log_reader.h\"\n+#include \"db/log_writer.h\"\n+#include \"db/memtable.h\"\n+#include \"db/table_cache.h\"\n+#include \"db/version_set.h\"\n+#include \"db/write_batch_internal.h\"\n+#include \"leveldb/db.h\"\n+#include \"leveldb/env.h\"\n+#include \"leveldb/status.h\"\n+#include \"leveldb/table.h\"\n+#include \"leveldb/table_builder.h\"\n+#include \"port/port.h\"\n+#include \"table/block.h\"\n+#include \"table/merger.h\"\n+#include \"table/two_level_iterator.h\"\n+#include \"util/coding.h\"\n+#include \"util/logging.h\"\n+#include \"util/mutexlock.h\"\n+\n+namespace leveldb {\n+\n+// Information kept for every waiting writer\n+struct DBImpl::Writer {\n+  Status status;\n+  WriteBatch* batch;\n+  bool sync;\n+  bool done;\n+  port::CondVar cv;\n+\n+  explicit Writer(port::Mutex* mu) : cv(mu) { }\n+};\n+\n+struct DBImpl::CompactionState {\n+  Compaction* const compaction;\n+\n+  // Sequence numbers < smallest_snapshot are not significant since we\n+  // will never have to service a snapshot below smallest_snapshot.\n+  // Therefore if we have seen a sequence number S <= smallest_snapshot,\n+  // we can drop all entries for the same key with sequence numbers < S.\n+  SequenceNumber smallest_snapshot;\n+\n+  // Files produced by compaction\n+  struct Output {\n+    uint64_t number;\n+    uint64_t file_size;\n+    InternalKey smallest, largest;\n+  };\n+  std::vector<Output> outputs;\n+\n+  // State kept for output being generated\n+  WritableFile* outfile;\n+  TableBuilder* builder;\n+\n+  uint64_t total_bytes;\n+\n+  Output* current_output() { return &outputs[outputs.size()-1]; }\n+\n+  explicit CompactionState(Compaction* c)\n+      : compaction(c),\n+        outfile(NULL),\n+        builder(NULL),\n+        total_bytes(0) {\n+  }\n+};\n+\n+// Fix user-supplied options to be reasonable\n+template <class T,class V>\n+static void ClipToRange(T* ptr, V minvalue, V maxvalue) {\n+  if (static_cast<V>(*ptr) > maxvalue) *ptr = maxvalue;\n+  if (static_cast<V>(*ptr) < minvalue) *ptr = minvalue;\n+}\n+Options SanitizeOptions(const std::string& dbname,\n+                        const InternalKeyComparator* icmp,\n+                        const InternalFilterPolicy* ipolicy,\n+                        const Options& src) {\n+  Options result = src;\n+  result.comparator = icmp;\n+  result.filter_policy = (src.filter_policy != NULL) ? ipolicy : NULL;\n+  ClipToRange(&result.max_open_files,            20,     50000);\n+  ClipToRange(&result.write_buffer_size,         64<<10, 1<<30);\n+  ClipToRange(&result.block_size,                1<<10,  4<<20);\n+  if (result.info_log == NULL) {\n+    // Open a log file in the same directory as the db\n+    src.env->CreateDir(dbname);  // In case it does not exist\n+    src.env->RenameFile(InfoLogFileName(dbname), OldInfoLogFileName(dbname));\n+    Status s = src.env->NewLogger(InfoLogFileName(dbname), &result.info_log);\n+    if (!s.ok()) {\n+      // No place suitable for logging\n+      result.info_log = NULL;\n+    }\n+  }\n+  if (result.block_cache == NULL) {\n+    result.block_cache = NewLRUCache(8 << 20);\n+  }\n+  return result;\n+}\n+\n+DBImpl::DBImpl(const Options& options, const std::string& dbname)\n+    : env_(options.env),\n+      internal_comparator_(options.comparator),\n+      internal_filter_policy_(options.filter_policy),\n+      options_(SanitizeOptions(\n+          dbname, &internal_comparator_, &internal_filter_policy_, options)),\n+      owns_info_log_(options_.info_log != options.info_log),\n+      owns_cache_(options_.block_cache != options.block_cache),\n+      dbname_(dbname),\n+      db_lock_(NULL),\n+      shutting_down_(NULL),\n+      bg_cv_(&mutex_),\n+      mem_(new MemTable(internal_comparator_)),\n+      imm_(NULL),\n+      logfile_(NULL),\n+      logfile_number_(0),\n+      log_(NULL),\n+      tmp_batch_(new WriteBatch),\n+      bg_compaction_scheduled_(false),\n+      manual_compaction_(NULL) {\n+  mem_->Ref();\n+  has_imm_.Release_Store(NULL);\n+\n+  // Reserve ten files or so for other uses and give the rest to TableCache.\n+  const int table_cache_size = options.max_open_files - 10;\n+  table_cache_ = new TableCache(dbname_, &options_, table_cache_size);\n+\n+  versions_ = new VersionSet(dbname_, &options_, table_cache_,\n+                             &internal_comparator_);\n+}\n+\n+DBImpl::~DBImpl() {\n+  // Wait for background work to finish\n+  mutex_.Lock();\n+  shutting_down_.Release_Store(this);  // Any non-NULL value is ok\n+  while (bg_compaction_scheduled_) {\n+    bg_cv_.Wait();\n+  }\n+  mutex_.Unlock();\n+\n+  if (db_lock_ != NULL) {\n+    env_->UnlockFile(db_lock_);\n+  }\n+\n+  delete versions_;\n+  if (mem_ != NULL) mem_->Unref();\n+  if (imm_ != NULL) imm_->Unref();\n+  delete tmp_batch_;\n+  delete log_;\n+  delete logfile_;\n+  delete table_cache_;\n+\n+  if (owns_info_log_) {\n+    delete options_.info_log;\n+  }\n+  if (owns_cache_) {\n+    delete options_.block_cache;\n+  }\n+}\n+\n+Status DBImpl::NewDB() {\n+  VersionEdit new_db;\n+  new_db.SetComparatorName(user_comparator()->Name());\n+  new_db.SetLogNumber(0);\n+  new_db.SetNextFile(2);\n+  new_db.SetLastSequence(0);\n+\n+  const std::string manifest = DescriptorFileName(dbname_, 1);\n+  WritableFile* file;\n+  Status s = env_->NewWritableFile(manifest, &file);\n+  if (!s.ok()) {\n+    return s;\n+  }\n+  {\n+    log::Writer log(file);\n+    std::string record;\n+    new_db.EncodeTo(&record);\n+    s = log.AddRecord(record);\n+    if (s.ok()) {\n+      s = file->Close();\n+    }\n+  }\n+  delete file;\n+  if (s.ok()) {\n+    // Make \"CURRENT\" file that points to the new manifest file.\n+    s = SetCurrentFile(env_, dbname_, 1);\n+  } else {\n+    env_->DeleteFile(manifest);\n+  }\n+  return s;\n+}\n+\n+void DBImpl::MaybeIgnoreError(Status* s) const {\n+  if (s->ok() || options_.paranoid_checks) {\n+    // No change needed\n+  } else {\n+    Log(options_.info_log, \"Ignoring error %s\", s->ToString().c_str());\n+    *s = Status::OK();\n+  }\n+}\n+\n+void DBImpl::DeleteObsoleteFiles() {\n+  // Make a set of all of the live files\n+  std::set<uint64_t> live = pending_outputs_;\n+  versions_->AddLiveFiles(&live);\n+\n+  std::vector<std::string> filenames;\n+  env_->GetChildren(dbname_, &filenames); // Ignoring errors on purpose\n+  uint64_t number;\n+  FileType type;\n+  for (size_t i = 0; i < filenames.size(); i++) {\n+    if (ParseFileName(filenames[i], &number, &type)) {\n+      bool keep = true;\n+      switch (type) {\n+        case kLogFile:\n+          keep = ((number >= versions_->LogNumber()) ||\n+                  (number == versions_->PrevLogNumber()));\n+          break;\n+        case kDescriptorFile:\n+          // Keep my manifest file, and any newer incarnations'\n+          // (in case there is a race that allows other incarnations)\n+          keep = (number >= versions_->ManifestFileNumber());\n+          break;\n+        case kTableFile:\n+          keep = (live.find(number) != live.end());\n+          break;\n+        case kTempFile:\n+          // Any temp files that are currently being written to must\n+          // be recorded in pending_outputs_, which is inserted into \"live\"\n+          keep = (live.find(number) != live.end());\n+          break;\n+        case kCurrentFile:\n+        case kDBLockFile:\n+        case kInfoLogFile:\n+          keep = true;\n+          break;\n+      }\n+\n+      if (!keep) {\n+        if (type == kTableFile) {\n+          table_cache_->Evict(number);\n+        }\n+        Log(options_.info_log, \"Delete type=%d #%lld\\n\",\n+            int(type),\n+            static_cast<unsigned long long>(number));\n+        env_->DeleteFile(dbname_ + \"/\" + filenames[i]);\n+      }\n+    }\n+  }\n+}\n+\n+Status DBImpl::Recover(VersionEdit* edit) {\n+  mutex_.AssertHeld();\n+\n+  // Ignore error from CreateDir since the creation of the DB is\n+  // committed only when the descriptor is created, and this directory\n+  // may already exist from a previous failed creation attempt.\n+  env_->CreateDir(dbname_);\n+  assert(db_lock_ == NULL);\n+  Status s = env_->LockFile(LockFileName(dbname_), &db_lock_);\n+  if (!s.ok()) {\n+    return s;\n+  }\n+\n+  if (!env_->FileExists(CurrentFileName(dbname_))) {\n+    if (options_.create_if_missing) {\n+      s = NewDB();\n+      if (!s.ok()) {\n+        return s;\n+      }\n+    } else {\n+      return Status::InvalidArgument(\n+          dbname_, \"does not exist (create_if_missing is false)\");\n+    }\n+  } else {\n+    if (options_.error_if_exists) {\n+      return Status::InvalidArgument(\n+          dbname_, \"exists (error_if_exists is true)\");\n+    }\n+  }\n+\n+  s = versions_->Recover();\n+  if (s.ok()) {\n+    SequenceNumber max_sequence(0);\n+\n+    // Recover from all newer log files than the ones named in the\n+    // descriptor (new log files may have been added by the previous\n+    // incarnation without registering them in the descriptor).\n+    //\n+    // Note that PrevLogNumber() is no longer used, but we pay\n+    // attention to it in case we are recovering a database\n+    // produced by an older version of leveldb.\n+    const uint64_t min_log = versions_->LogNumber();\n+    const uint64_t prev_log = versions_->PrevLogNumber();\n+    std::vector<std::string> filenames;\n+    s = env_->GetChildren(dbname_, &filenames);\n+    if (!s.ok()) {\n+      return s;\n+    }\n+    uint64_t number;\n+    FileType type;\n+    std::vector<uint64_t> logs;\n+    for (size_t i = 0; i < filenames.size(); i++) {\n+      if (ParseFileName(filenames[i], &number, &type)\n+          && type == kLogFile\n+          && ((number >= min_log) || (number == prev_log))) {\n+        logs.push_back(number);\n+      }\n+    }\n+\n+    // Recover in the order in which the logs were generated\n+    std::sort(logs.begin(), logs.end());\n+    for (size_t i = 0; i < logs.size(); i++) {\n+      s = RecoverLogFile(logs[i], edit, &max_sequence);\n+\n+      // The previous incarnation may not have written any MANIFEST\n+      // records after allocating this log number.  So we manually\n+      // update the file number allocation counter in VersionSet.\n+      versions_->MarkFileNumberUsed(logs[i]);\n+    }\n+\n+    if (s.ok()) {\n+      if (versions_->LastSequence() < max_sequence) {\n+        versions_->SetLastSequence(max_sequence);\n+      }\n+    }\n+  }\n+\n+  return s;\n+}\n+\n+Status DBImpl::RecoverLogFile(uint64_t log_number,\n+                              VersionEdit* edit,\n+                              SequenceNumber* max_sequence) {\n+  struct LogReporter : public log::Reader::Reporter {\n+    Env* env;\n+    Logger* info_log;\n+    const char* fname;\n+    Status* status;  // NULL if options_.paranoid_checks==false\n+    virtual void Corruption(size_t bytes, const Status& s) {\n+      Log(info_log, \"%s%s: dropping %d bytes; %s\",\n+          (this->status == NULL ? \"(ignoring error) \" : \"\"),\n+          fname, static_cast<int>(bytes), s.ToString().c_str());\n+      if (this->status != NULL && this->status->ok()) *this->status = s;\n+    }\n+  };\n+\n+  mutex_.AssertHeld();\n+\n+  // Open the log file\n+  std::string fname = LogFileName(dbname_, log_number);\n+  SequentialFile* file;\n+  Status status = env_->NewSequentialFile(fname, &file);\n+  if (!status.ok()) {\n+    MaybeIgnoreError(&status);\n+    return status;\n+  }\n+\n+  // Create the log reader.\n+  LogReporter reporter;\n+  reporter.env = env_;\n+  reporter.info_log = options_.info_log;\n+  reporter.fname = fname.c_str();\n+  reporter.status = (options_.paranoid_checks ? &status : NULL);\n+  // We intentially make log::Reader do checksumming even if\n+  // paranoid_checks==false so that corruptions cause entire commits\n+  // to be skipped instead of propagating bad information (like overly\n+  // large sequence numbers).\n+  log::Reader reader(file, &reporter, true/*checksum*/,\n+                     0/*initial_offset*/);\n+  Log(options_.info_log, \"Recovering log #%llu\",\n+      (unsigned long long) log_number);\n+\n+  // Read all the records and add to a memtable\n+  std::string scratch;\n+  Slice record;\n+  WriteBatch batch;\n+  MemTable* mem = NULL;\n+  while (reader.ReadRecord(&record, &scratch) &&\n+         status.ok()) {\n+    if (record.size() < 12) {\n+      reporter.Corruption(\n+          record.size(), Status::Corruption(\"log record too small\"));\n+      continue;\n+    }\n+    WriteBatchInternal::SetContents(&batch, record);\n+\n+    if (mem == NULL) {\n+      mem = new MemTable(internal_comparator_);\n+      mem->Ref();\n+    }\n+    status = WriteBatchInternal::InsertInto(&batch, mem);\n+    MaybeIgnoreError(&status);\n+    if (!status.ok()) {\n+      break;\n+    }\n+    const SequenceNumber last_seq =\n+        WriteBatchInternal::Sequence(&batch) +\n+        WriteBatchInternal::Count(&batch) - 1;\n+    if (last_seq > *max_sequence) {\n+      *max_sequence = last_seq;\n+    }\n+\n+    if (mem->ApproximateMemoryUsage() > options_.write_buffer_size) {\n+      status = WriteLevel0Table(mem, edit, NULL);\n+      if (!status.ok()) {\n+        // Reflect errors immediately so that conditions like full\n+        // file-systems cause the DB::Open() to fail.\n+        break;\n+      }\n+      mem->Unref();\n+      mem = NULL;\n+    }\n+  }\n+\n+  if (status.ok() && mem != NULL) {\n+    status = WriteLevel0Table(mem, edit, NULL);\n+    // Reflect errors immediately so that conditions like full\n+    // file-systems cause the DB::Open() to fail.\n+  }\n+\n+  if (mem != NULL) mem->Unref();\n+  delete file;\n+  return status;\n+}\n+\n+Status DBImpl::WriteLevel0Table(MemTable* mem, VersionEdit* edit,\n+                                Version* base) {\n+  mutex_.AssertHeld();\n+  const uint64_t start_micros = env_->NowMicros();\n+  FileMetaData meta;\n+  meta.number = versions_->NewFileNumber();\n+  pending_outputs_.insert(meta.number);\n+  Iterator* iter = mem->NewIterator();\n+  Log(options_.info_log, \"Level-0 table #%llu: started\",\n+      (unsigned long long) meta.number);\n+\n+  Status s;\n+  {\n+    mutex_.Unlock();\n+    s = BuildTable(dbname_, env_, options_, table_cache_, iter, &meta);\n+    mutex_.Lock();\n+  }\n+\n+  Log(options_.info_log, \"Level-0 table #%llu: %lld bytes %s\",\n+      (unsigned long long) meta.number,\n+      (unsigned long long) meta.file_size,\n+      s.ToString().c_str());\n+  delete iter;\n+  pending_outputs_.erase(meta.number);\n+\n+\n+  // Note that if file_size is zero, the file has been deleted and\n+  // should not be added to the manifest.\n+  int level = 0;\n+  if (s.ok() && meta.file_size > 0) {\n+    const Slice min_user_key = meta.smallest.user_key();\n+    const Slice max_user_key = meta.largest.user_key();\n+    if (base != NULL) {\n+      level = base->PickLevelForMemTableOutput(min_user_key, max_user_key);\n+    }\n+    edit->AddFile(level, meta.number, meta.file_size,\n+                  meta.smallest, meta.largest);\n+  }\n+\n+  CompactionStats stats;\n+  stats.micros = env_->NowMicros() - start_micros;\n+  stats.bytes_written = meta.file_size;\n+  stats_[level].Add(stats);\n+  return s;\n+}\n+\n+Status DBImpl::CompactMemTable() {\n+  mutex_.AssertHeld();\n+  assert(imm_ != NULL);\n+\n+  // Save the contents of the memtable as a new Table\n+  VersionEdit edit;\n+  Version* base = versions_->current();\n+  base->Ref();\n+  Status s = WriteLevel0Table(imm_, &edit, base);\n+  base->Unref();\n+\n+  if (s.ok() && shutting_down_.Acquire_Load()) {\n+    s = Status::IOError(\"Deleting DB during memtable compaction\");\n+  }\n+\n+  // Replace immutable memtable with the generated Table\n+  if (s.ok()) {\n+    edit.SetPrevLogNumber(0);\n+    edit.SetLogNumber(logfile_number_);  // Earlier logs no longer needed\n+    s = versions_->LogAndApply(&edit, &mutex_);\n+  }\n+\n+  if (s.ok()) {\n+    // Commit to the new state\n+    imm_->Unref();\n+    imm_ = NULL;\n+    has_imm_.Release_Store(NULL);\n+    DeleteObsoleteFiles();\n+  }\n+\n+  return s;\n+}\n+\n+void DBImpl::CompactRange(const Slice* begin, const Slice* end) {\n+  int max_level_with_files = 1;\n+  {\n+    MutexLock l(&mutex_);\n+    Version* base = versions_->current();\n+    for (int level = 1; level < config::kNumLevels; level++) {\n+      if (base->OverlapInLevel(level, begin, end)) {\n+        max_level_with_files = level;\n+      }\n+    }\n+  }\n+  TEST_CompactMemTable(); // TODO(sanjay): Skip if memtable does not overlap\n+  for (int level = 0; level < max_level_with_files; level++) {\n+    TEST_CompactRange(level, begin, end);\n+  }\n+}\n+\n+void DBImpl::TEST_CompactRange(int level, const Slice* begin,const Slice* end) {\n+  assert(level >= 0);\n+  assert(level + 1 < config::kNumLevels);\n+\n+  InternalKey begin_storage, end_storage;\n+\n+  ManualCompaction manual;\n+  manual.level = level;\n+  manual.done = false;\n+  if (begin == NULL) {\n+    manual.begin = NULL;\n+  } else {\n+    begin_storage = InternalKey(*begin, kMaxSequenceNumber, kValueTypeForSeek);\n+    manual.begin = &begin_storage;\n+  }\n+  if (end == NULL) {\n+    manual.end = NULL;\n+  } else {\n+    end_storage = InternalKey(*end, 0, static_cast<ValueType>(0));\n+    manual.end = &end_storage;\n+  }\n+\n+  MutexLock l(&mutex_);\n+  while (!manual.done) {\n+    while (manual_compaction_ != NULL) {\n+      bg_cv_.Wait();\n+    }\n+    manual_compaction_ = &manual;\n+    MaybeScheduleCompaction();\n+    while (manual_compaction_ == &manual) {\n+      bg_cv_.Wait();\n+    }\n+  }\n+}\n+\n+Status DBImpl::TEST_CompactMemTable() {\n+  // NULL batch means just wait for earlier writes to be done\n+  Status s = Write(WriteOptions(), NULL);\n+  if (s.ok()) {\n+    // Wait until the compaction completes\n+    MutexLock l(&mutex_);\n+    while (imm_ != NULL && bg_error_.ok()) {\n+      bg_cv_.Wait();\n+    }\n+    if (imm_ != NULL) {\n+      s = bg_error_;\n+    }\n+  }\n+  return s;\n+}\n+\n+void DBImpl::MaybeScheduleCompaction() {\n+  mutex_.AssertHeld();\n+  if (bg_compaction_scheduled_) {\n+    // Already scheduled\n+  } else if (shutting_down_.Acquire_Load()) {\n+    // DB is being deleted; no more background compactions\n+  } else if (imm_ == NULL &&\n+             manual_compaction_ == NULL &&\n+             !versions_->NeedsCompaction()) {\n+    // No work to be done\n+  } else {\n+    bg_compaction_scheduled_ = true;\n+    env_->Schedule(&DBImpl::BGWork, this);\n+  }\n+}\n+\n+void DBImpl::BGWork(void* db) {\n+  reinterpret_cast<DBImpl*>(db)->BackgroundCall();\n+}\n+\n+void DBImpl::BackgroundCall() {\n+  MutexLock l(&mutex_);\n+  assert(bg_compaction_scheduled_);\n+  if (!shutting_down_.Acquire_Load()) {\n+    Status s = BackgroundCompaction();\n+    if (!s.ok()) {\n+      // Wait a little bit before retrying background compaction in\n+      // case this is an environmental problem and we do not want to\n+      // chew up resources for failed compactions for the duration of\n+      // the problem.\n+      bg_cv_.SignalAll();  // In case a waiter can proceed despite the error\n+      Log(options_.info_log, \"Waiting after background compaction error: %s\",\n+          s.ToString().c_str());\n+      mutex_.Unlock();\n+      env_->SleepForMicroseconds(1000000);\n+      mutex_.Lock();\n+    }\n+  }\n+\n+  bg_compaction_scheduled_ = false;\n+\n+  // Previous compaction may have produced too many files in a level,\n+  // so reschedule another compaction if needed.\n+  MaybeScheduleCompaction();\n+  bg_cv_.SignalAll();\n+}\n+\n+Status DBImpl::BackgroundCompaction() {\n+  mutex_.AssertHeld();\n+\n+  if (imm_ != NULL) {\n+    return CompactMemTable();\n+  }\n+\n+  Compaction* c;\n+  bool is_manual = (manual_compaction_ != NULL);\n+  InternalKey manual_end;\n+  if (is_manual) {\n+    ManualCompaction* m = manual_compaction_;\n+    c = versions_->CompactRange(m->level, m->begin, m->end);\n+    m->done = (c == NULL);\n+    if (c != NULL) {\n+      manual_end = c->input(0, c->num_input_files(0) - 1)->largest;\n+    }\n+    Log(options_.info_log,\n+        \"Manual compaction at level-%d from %s .. %s; will stop at %s\\n\",\n+        m->level,\n+        (m->begin ? m->begin->DebugString().c_str() : \"(begin)\"),\n+        (m->end ? m->end->DebugString().c_str() : \"(end)\"),\n+        (m->done ? \"(end)\" : manual_end.DebugString().c_str()));\n+  } else {\n+    c = versions_->PickCompaction();\n+  }\n+\n+  Status status;\n+  if (c == NULL) {\n+    // Nothing to do\n+  } else if (!is_manual && c->IsTrivialMove()) {\n+    // Move file to next level\n+    assert(c->num_input_files(0) == 1);\n+    FileMetaData* f = c->input(0, 0);\n+    c->edit()->DeleteFile(c->level(), f->number);\n+    c->edit()->AddFile(c->level() + 1, f->number, f->file_size,\n+                       f->smallest, f->largest);\n+    status = versions_->LogAndApply(c->edit(), &mutex_);\n+    VersionSet::LevelSummaryStorage tmp;\n+    Log(options_.info_log, \"Moved #%lld to level-%d %lld bytes %s: %s\\n\",\n+        static_cast<unsigned long long>(f->number),\n+        c->level() + 1,\n+        static_cast<unsigned long long>(f->file_size),\n+        status.ToString().c_str(),\n+        versions_->LevelSummary(&tmp));\n+  } else {\n+    CompactionState* compact = new CompactionState(c);\n+    status = DoCompactionWork(compact);\n+    CleanupCompaction(compact);\n+    c->ReleaseInputs();\n+    DeleteObsoleteFiles();\n+  }\n+  delete c;\n+\n+  if (status.ok()) {\n+    // Done\n+  } else if (shutting_down_.Acquire_Load()) {\n+    // Ignore compaction errors found during shutting down\n+  } else {\n+    Log(options_.info_log,\n+        \"Compaction error: %s\", status.ToString().c_str());\n+    if (options_.paranoid_checks && bg_error_.ok()) {\n+      bg_error_ = status;\n+    }\n+  }\n+\n+  if (is_manual) {\n+    ManualCompaction* m = manual_compaction_;\n+    if (!status.ok()) {\n+      m->done = true;\n+    }\n+    if (!m->done) {\n+      // We only compacted part of the requested range.  Update *m\n+      // to the range that is left to be compacted.\n+      m->tmp_storage = manual_end;\n+      m->begin = &m->tmp_storage;\n+    }\n+    manual_compaction_ = NULL;\n+  }\n+  return status;\n+}\n+\n+void DBImpl::CleanupCompaction(CompactionState* compact) {\n+  mutex_.AssertHeld();\n+  if (compact->builder != NULL) {\n+    // May happen if we get a shutdown call in the middle of compaction\n+    compact->builder->Abandon();\n+    delete compact->builder;\n+  } else {\n+    assert(compact->outfile == NULL);\n+  }\n+  delete compact->outfile;\n+  for (size_t i = 0; i < compact->outputs.size(); i++) {\n+    const CompactionState::Output& out = compact->outputs[i];\n+    pending_outputs_.erase(out.number);\n+  }\n+  delete compact;\n+}\n+\n+Status DBImpl::OpenCompactionOutputFile(CompactionState* compact) {\n+  assert(compact != NULL);\n+  assert(compact->builder == NULL);\n+  uint64_t file_number;\n+  {\n+    mutex_.Lock();\n+    file_number = versions_->NewFileNumber();\n+    pending_outputs_.insert(file_number);\n+    CompactionState::Output out;\n+    out.number = file_number;\n+    out.smallest.Clear();\n+    out.largest.Clear();\n+    compact->outputs.push_back(out);\n+    mutex_.Unlock();\n+  }\n+\n+  // Make the output file\n+  std::string fname = TableFileName(dbname_, file_number);\n+  Status s = env_->NewWritableFile(fname, &compact->outfile);\n+  if (s.ok()) {\n+    compact->builder = new TableBuilder(options_, compact->outfile);\n+  }\n+  return s;\n+}\n+\n+Status DBImpl::FinishCompactionOutputFile(CompactionState* compact,\n+                                          Iterator* input) {\n+  assert(compact != NULL);\n+  assert(compact->outfile != NULL);\n+  assert(compact->builder != NULL);\n+\n+  const uint64_t output_number = compact->current_output()->number;\n+  assert(output_number != 0);\n+\n+  // Check for iterator errors\n+  Status s = input->status();\n+  const uint64_t current_entries = compact->builder->NumEntries();\n+  if (s.ok()) {\n+    s = compact->builder->Finish();\n+  } else {\n+    compact->builder->Abandon();\n+  }\n+  const uint64_t current_bytes = compact->builder->FileSize();\n+  compact->current_output()->file_size = current_bytes;\n+  compact->total_bytes += current_bytes;\n+  delete compact->builder;\n+  compact->builder = NULL;\n+\n+  // Finish and check for file errors\n+  if (s.ok()) {\n+    s = compact->outfile->Sync();\n+  }\n+  if (s.ok()) {\n+    s = compact->outfile->Close();\n+  }\n+  delete compact->outfile;\n+  compact->outfile = NULL;\n+\n+  if (s.ok() && current_entries > 0) {\n+    // Verify that the table is usable\n+    Iterator* iter = table_cache_->NewIterator(ReadOptions(),\n+                                               output_number,\n+                                               current_bytes);\n+    s = iter->status();\n+    delete iter;\n+    if (s.ok()) {\n+      Log(options_.info_log,\n+          \"Generated table #%llu: %lld keys, %lld bytes\",\n+          (unsigned long long) output_number,\n+          (unsigned long long) current_entries,\n+          (unsigned long long) current_bytes);\n+    }\n+  }\n+  return s;\n+}\n+\n+\n+Status DBImpl::InstallCompactionResults(CompactionState* compact) {\n+  mutex_.AssertHeld();\n+  Log(options_.info_log,  \"Compacted %d@%d + %d@%d files => %lld bytes\",\n+      compact->compaction->num_input_files(0),\n+      compact->compaction->level(),\n+      compact->compaction->num_input_files(1),\n+      compact->compaction->level() + 1,\n+      static_cast<long long>(compact->total_bytes));\n+\n+  // Add compaction outputs\n+  compact->compaction->AddInputDeletions(compact->compaction->edit());\n+  const int level = compact->compaction->level();\n+  for (size_t i = 0; i < compact->outputs.size(); i++) {\n+    const CompactionState::Output& out = compact->outputs[i];\n+    compact->compaction->edit()->AddFile(\n+        level + 1,\n+        out.number, out.file_size, out.smallest, out.largest);\n+  }\n+  return versions_->LogAndApply(compact->compaction->edit(), &mutex_);\n+}\n+\n+Status DBImpl::DoCompactionWork(CompactionState* compact) {\n+  const uint64_t start_micros = env_->NowMicros();\n+  int64_t imm_micros = 0;  // Micros spent doing imm_ compactions\n+\n+  Log(options_.info_log,  \"Compacting %d@%d + %d@%d files\",\n+      compact->compaction->num_input_files(0),\n+      compact->compaction->level(),\n+      compact->compaction->num_input_files(1),\n+      compact->compaction->level() + 1);\n+\n+  assert(versions_->NumLevelFiles(compact->compaction->level()) > 0);\n+  assert(compact->builder == NULL);\n+  assert(compact->outfile == NULL);\n+  if (snapshots_.empty()) {\n+    compact->smallest_snapshot = versions_->LastSequence();\n+  } else {\n+    compact->smallest_snapshot = snapshots_.oldest()->number_;\n+  }\n+\n+  // Release mutex while we're actually doing the compaction work\n+  mutex_.Unlock();\n+\n+  Iterator* input = versions_->MakeInputIterator(compact->compaction);\n+  input->SeekToFirst();\n+  Status status;\n+  ParsedInternalKey ikey;\n+  std::string current_user_key;\n+  bool has_current_user_key = false;\n+  SequenceNumber last_sequence_for_key = kMaxSequenceNumber;\n+  for (; input->Valid() && !shutting_down_.Acquire_Load(); ) {\n+    // Prioritize immutable compaction work\n+    if (has_imm_.NoBarrier_Load() != NULL) {\n+      const uint64_t imm_start = env_->NowMicros();\n+      mutex_.Lock();\n+      if (imm_ != NULL) {\n+        CompactMemTable();\n+        bg_cv_.SignalAll();  // Wakeup MakeRoomForWrite() if necessary\n+      }\n+      mutex_.Unlock();\n+      imm_micros += (env_->NowMicros() - imm_start);\n+    }\n+\n+    Slice key = input->key();\n+    if (compact->compaction->ShouldStopBefore(key) &&\n+        compact->builder != NULL) {\n+      status = FinishCompactionOutputFile(compact, input);\n+      if (!status.ok()) {\n+        break;\n+      }\n+    }\n+\n+    // Handle key/value, add to state, etc.\n+    bool drop = false;\n+    if (!ParseInternalKey(key, &ikey)) {\n+      // Do not hide error keys\n+      current_user_key.clear();\n+      has_current_user_key = false;\n+      last_sequence_for_key = kMaxSequenceNumber;\n+    } else {\n+      if (!has_current_user_key ||\n+          user_comparator()->Compare(ikey.user_key,\n+                                     Slice(current_user_key)) != 0) {\n+        // First occurrence of this user key\n+        current_user_key.assign(ikey.user_key.data(), ikey.user_key.size());\n+        has_current_user_key = true;\n+        last_sequence_for_key = kMaxSequenceNumber;\n+      }\n+\n+      if (last_sequence_for_key <= compact->smallest_snapshot) {\n+        // Hidden by an newer entry for same user key\n+        drop = true;    // (A)\n+      } else if (ikey.type == kTypeDeletion &&\n+                 ikey.sequence <= compact->smallest_snapshot &&\n+                 compact->compaction->IsBaseLevelForKey(ikey.user_key)) {\n+        // For this user key:\n+        // (1) there is no data in higher levels\n+        // (2) data in lower levels will have larger sequence numbers\n+        // (3) data in layers that are being compacted here and have\n+        //     smaller sequence numbers will be dropped in the next\n+        //     few iterations of this loop (by rule (A) above).\n+        // Therefore this deletion marker is obsolete and can be dropped.\n+        drop = true;\n+      }\n+\n+      last_sequence_for_key = ikey.sequence;\n+    }\n+#if 0\n+    Log(options_.info_log,\n+        \"  Compact: %s, seq %d, type: %d %d, drop: %d, is_base: %d, \"\n+        \"%d smallest_snapshot: %d\",\n+        ikey.user_key.ToString().c_str(),\n+        (int)ikey.sequence, ikey.type, kTypeValue, drop,\n+        compact->compaction->IsBaseLevelForKey(ikey.user_key),\n+        (int)last_sequence_for_key, (int)compact->smallest_snapshot);\n+#endif\n+\n+    if (!drop) {\n+      // Open output file if necessary\n+      if (compact->builder == NULL) {\n+        status = OpenCompactionOutputFile(compact);\n+        if (!status.ok()) {\n+          break;\n+        }\n+      }\n+      if (compact->builder->NumEntries() == 0) {\n+        compact->current_output()->smallest.DecodeFrom(key);\n+      }\n+      compact->current_output()->largest.DecodeFrom(key);\n+      compact->builder->Add(key, input->value());\n+\n+      // Close output file if it is big enough\n+      if (compact->builder->FileSize() >=\n+          compact->compaction->MaxOutputFileSize()) {\n+        status = FinishCompactionOutputFile(compact, input);\n+        if (!status.ok()) {\n+          break;\n+        }\n+      }\n+    }\n+\n+    input->Next();\n+  }\n+\n+  if (status.ok() && shutting_down_.Acquire_Load()) {\n+    status = Status::IOError(\"Deleting DB during compaction\");\n+  }\n+  if (status.ok() && compact->builder != NULL) {\n+    status = FinishCompactionOutputFile(compact, input);\n+  }\n+  if (status.ok()) {\n+    status = input->status();\n+  }\n+  delete input;\n+  input = NULL;\n+\n+  CompactionStats stats;\n+  stats.micros = env_->NowMicros() - start_micros - imm_micros;\n+  for (int which = 0; which < 2; which++) {\n+    for (int i = 0; i < compact->compaction->num_input_files(which); i++) {\n+      stats.bytes_read += compact->compaction->input(which, i)->file_size;\n+    }\n+  }\n+  for (size_t i = 0; i < compact->outputs.size(); i++) {\n+    stats.bytes_written += compact->outputs[i].file_size;\n+  }\n+\n+  mutex_.Lock();\n+  stats_[compact->compaction->level() + 1].Add(stats);\n+\n+  if (status.ok()) {\n+    status = InstallCompactionResults(compact);\n+  }\n+  VersionSet::LevelSummaryStorage tmp;\n+  Log(options_.info_log,\n+      \"compacted to: %s\", versions_->LevelSummary(&tmp));\n+  return status;\n+}\n+\n+namespace {\n+struct IterState {\n+  port::Mutex* mu;\n+  Version* version;\n+  MemTable* mem;\n+  MemTable* imm;\n+};\n+\n+static void CleanupIteratorState(void* arg1, void* arg2) {\n+  IterState* state = reinterpret_cast<IterState*>(arg1);\n+  state->mu->Lock();\n+  state->mem->Unref();\n+  if (state->imm != NULL) state->imm->Unref();\n+  state->version->Unref();\n+  state->mu->Unlock();\n+  delete state;\n+}\n+}  // namespace\n+\n+Iterator* DBImpl::NewInternalIterator(const ReadOptions& options,\n+                                      SequenceNumber* latest_snapshot) {\n+  IterState* cleanup = new IterState;\n+  mutex_.Lock();\n+  *latest_snapshot = versions_->LastSequence();\n+\n+  // Collect together all needed child iterators\n+  std::vector<Iterator*> list;\n+  list.push_back(mem_->NewIterator());\n+  mem_->Ref();\n+  if (imm_ != NULL) {\n+    list.push_back(imm_->NewIterator());\n+    imm_->Ref();\n+  }\n+  versions_->current()->AddIterators(options, &list);\n+  Iterator* internal_iter =\n+      NewMergingIterator(&internal_comparator_, &list[0], list.size());\n+  versions_->current()->Ref();\n+\n+  cleanup->mu = &mutex_;\n+  cleanup->mem = mem_;\n+  cleanup->imm = imm_;\n+  cleanup->version = versions_->current();\n+  internal_iter->RegisterCleanup(CleanupIteratorState, cleanup, NULL);\n+\n+  mutex_.Unlock();\n+  return internal_iter;\n+}\n+\n+Iterator* DBImpl::TEST_NewInternalIterator() {\n+  SequenceNumber ignored;\n+  return NewInternalIterator(ReadOptions(), &ignored);\n+}\n+\n+int64_t DBImpl::TEST_MaxNextLevelOverlappingBytes() {\n+  MutexLock l(&mutex_);\n+  return versions_->MaxNextLevelOverlappingBytes();\n+}\n+\n+Status DBImpl::Get(const ReadOptions& options,\n+                   const Slice& key,\n+                   std::string* value) {\n+  Status s;\n+  MutexLock l(&mutex_);\n+  SequenceNumber snapshot;\n+  if (options.snapshot != NULL) {\n+    snapshot = reinterpret_cast<const SnapshotImpl*>(options.snapshot)->number_;\n+  } else {\n+    snapshot = versions_->LastSequence();\n+  }\n+\n+  MemTable* mem = mem_;\n+  MemTable* imm = imm_;\n+  Version* current = versions_->current();\n+  mem->Ref();\n+  if (imm != NULL) imm->Ref();\n+  current->Ref();\n+\n+  bool have_stat_update = false;\n+  Version::GetStats stats;\n+\n+  // Unlock while reading from files and memtables\n+  {\n+    mutex_.Unlock();\n+    // First look in the memtable, then in the immutable memtable (if any).\n+    LookupKey lkey(key, snapshot);\n+    if (mem->Get(lkey, value, &s)) {\n+      // Done\n+    } else if (imm != NULL && imm->Get(lkey, value, &s)) {\n+      // Done\n+    } else {\n+      s = current->Get(options, lkey, value, &stats);\n+      have_stat_update = true;\n+    }\n+    mutex_.Lock();\n+  }\n+\n+  if (have_stat_update && current->UpdateStats(stats)) {\n+    MaybeScheduleCompaction();\n+  }\n+  mem->Unref();\n+  if (imm != NULL) imm->Unref();\n+  current->Unref();\n+  return s;\n+}\n+\n+Iterator* DBImpl::NewIterator(const ReadOptions& options) {\n+  SequenceNumber latest_snapshot;\n+  Iterator* internal_iter = NewInternalIterator(options, &latest_snapshot);\n+  return NewDBIterator(\n+      &dbname_, env_, user_comparator(), internal_iter,\n+      (options.snapshot != NULL\n+       ? reinterpret_cast<const SnapshotImpl*>(options.snapshot)->number_\n+       : latest_snapshot));\n+}\n+\n+const Snapshot* DBImpl::GetSnapshot() {\n+  MutexLock l(&mutex_);\n+  return snapshots_.New(versions_->LastSequence());\n+}\n+\n+void DBImpl::ReleaseSnapshot(const Snapshot* s) {\n+  MutexLock l(&mutex_);\n+  snapshots_.Delete(reinterpret_cast<const SnapshotImpl*>(s));\n+}\n+\n+// Convenience methods\n+Status DBImpl::Put(const WriteOptions& o, const Slice& key, const Slice& val) {\n+  return DB::Put(o, key, val);\n+}\n+\n+Status DBImpl::Delete(const WriteOptions& options, const Slice& key) {\n+  return DB::Delete(options, key);\n+}\n+\n+Status DBImpl::Write(const WriteOptions& options, WriteBatch* my_batch) {\n+  Writer w(&mutex_);\n+  w.batch = my_batch;\n+  w.sync = options.sync;\n+  w.done = false;\n+\n+  MutexLock l(&mutex_);\n+  writers_.push_back(&w);\n+  while (!w.done && &w != writers_.front()) {\n+    w.cv.Wait();\n+  }\n+  if (w.done) {\n+    return w.status;\n+  }\n+\n+  // May temporarily unlock and wait.\n+  Status status = MakeRoomForWrite(my_batch == NULL);\n+  uint64_t last_sequence = versions_->LastSequence();\n+  Writer* last_writer = &w;\n+  if (status.ok() && my_batch != NULL) {  // NULL batch is for compactions\n+    WriteBatch* updates = BuildBatchGroup(&last_writer);\n+    WriteBatchInternal::SetSequence(updates, last_sequence + 1);\n+    last_sequence += WriteBatchInternal::Count(updates);\n+\n+    // Add to log and apply to memtable.  We can release the lock\n+    // during this phase since &w is currently responsible for logging\n+    // and protects against concurrent loggers and concurrent writes\n+    // into mem_.\n+    {\n+      mutex_.Unlock();\n+      status = log_->AddRecord(WriteBatchInternal::Contents(updates));\n+      if (status.ok() && options.sync) {\n+        status = logfile_->Sync();\n+      }\n+      if (status.ok()) {\n+        status = WriteBatchInternal::InsertInto(updates, mem_);\n+      }\n+      mutex_.Lock();\n+    }\n+    if (updates == tmp_batch_) tmp_batch_->Clear();\n+\n+    versions_->SetLastSequence(last_sequence);\n+  }\n+\n+  while (true) {\n+    Writer* ready = writers_.front();\n+    writers_.pop_front();\n+    if (ready != &w) {\n+      ready->status = status;\n+      ready->done = true;\n+      ready->cv.Signal();\n+    }\n+    if (ready == last_writer) break;\n+  }\n+\n+  // Notify new head of write queue\n+  if (!writers_.empty()) {\n+    writers_.front()->cv.Signal();\n+  }\n+\n+  return status;\n+}\n+\n+// REQUIRES: Writer list must be non-empty\n+// REQUIRES: First writer must have a non-NULL batch\n+WriteBatch* DBImpl::BuildBatchGroup(Writer** last_writer) {\n+  assert(!writers_.empty());\n+  Writer* first = writers_.front();\n+  WriteBatch* result = first->batch;\n+  assert(result != NULL);\n+\n+  size_t size = WriteBatchInternal::ByteSize(first->batch);\n+\n+  // Allow the group to grow up to a maximum size, but if the\n+  // original write is small, limit the growth so we do not slow\n+  // down the small write too much.\n+  size_t max_size = 1 << 20;\n+  if (size <= (128<<10)) {\n+    max_size = size + (128<<10);\n+  }\n+\n+  *last_writer = first;\n+  std::deque<Writer*>::iterator iter = writers_.begin();\n+  ++iter;  // Advance past \"first\"\n+  for (; iter != writers_.end(); ++iter) {\n+    Writer* w = *iter;\n+    if (w->sync && !first->sync) {\n+      // Do not include a sync write into a batch handled by a non-sync write.\n+      break;\n+    }\n+\n+    if (w->batch != NULL) {\n+      size += WriteBatchInternal::ByteSize(w->batch);\n+      if (size > max_size) {\n+        // Do not make batch too big\n+        break;\n+      }\n+\n+      // Append to *reuslt\n+      if (result == first->batch) {\n+        // Switch to temporary batch instead of disturbing caller's batch\n+        result = tmp_batch_;\n+        assert(WriteBatchInternal::Count(result) == 0);\n+        WriteBatchInternal::Append(result, first->batch);\n+      }\n+      WriteBatchInternal::Append(result, w->batch);\n+    }\n+    *last_writer = w;\n+  }\n+  return result;\n+}\n+\n+// REQUIRES: mutex_ is held\n+// REQUIRES: this thread is currently at the front of the writer queue\n+Status DBImpl::MakeRoomForWrite(bool force) {\n+  mutex_.AssertHeld();\n+  assert(!writers_.empty());\n+  bool allow_delay = !force;\n+  Status s;\n+  while (true) {\n+    if (!bg_error_.ok()) {\n+      // Yield previous error\n+      s = bg_error_;\n+      break;\n+    } else if (\n+        allow_delay &&\n+        versions_->NumLevelFiles(0) >= config::kL0_SlowdownWritesTrigger) {\n+      // We are getting close to hitting a hard limit on the number of\n+      // L0 files.  Rather than delaying a single write by several\n+      // seconds when we hit the hard limit, start delaying each\n+      // individual write by 1ms to reduce latency variance.  Also,\n+      // this delay hands over some CPU to the compaction thread in\n+      // case it is sharing the same core as the writer.\n+      mutex_.Unlock();\n+      env_->SleepForMicroseconds(1000);\n+      allow_delay = false;  // Do not delay a single write more than once\n+      mutex_.Lock();\n+    } else if (!force &&\n+               (mem_->ApproximateMemoryUsage() <= options_.write_buffer_size)) {\n+      // There is room in current memtable\n+      break;\n+    } else if (imm_ != NULL) {\n+      // We have filled up the current memtable, but the previous\n+      // one is still being compacted, so we wait.\n+      bg_cv_.Wait();\n+    } else if (versions_->NumLevelFiles(0) >= config::kL0_StopWritesTrigger) {\n+      // There are too many level-0 files.\n+      Log(options_.info_log, \"waiting...\\n\");\n+      bg_cv_.Wait();\n+    } else {\n+      // Attempt to switch to a new memtable and trigger compaction of old\n+      assert(versions_->PrevLogNumber() == 0);\n+      uint64_t new_log_number = versions_->NewFileNumber();\n+      WritableFile* lfile = NULL;\n+      s = env_->NewWritableFile(LogFileName(dbname_, new_log_number), &lfile);\n+      if (!s.ok()) {\n+        // Avoid chewing through file number space in a tight loop.\n+        versions_->ReuseFileNumber(new_log_number);\n+        break;\n+      }\n+      delete log_;\n+      delete logfile_;\n+      logfile_ = lfile;\n+      logfile_number_ = new_log_number;\n+      log_ = new log::Writer(lfile);\n+      imm_ = mem_;\n+      has_imm_.Release_Store(imm_);\n+      mem_ = new MemTable(internal_comparator_);\n+      mem_->Ref();\n+      force = false;   // Do not force another compaction if have room\n+      MaybeScheduleCompaction();\n+    }\n+  }\n+  return s;\n+}\n+\n+bool DBImpl::GetProperty(const Slice& property, std::string* value) {\n+  value->clear();\n+\n+  MutexLock l(&mutex_);\n+  Slice in = property;\n+  Slice prefix(\"leveldb.\");\n+  if (!in.starts_with(prefix)) return false;\n+  in.remove_prefix(prefix.size());\n+\n+  if (in.starts_with(\"num-files-at-level\")) {\n+    in.remove_prefix(strlen(\"num-files-at-level\"));\n+    uint64_t level;\n+    bool ok = ConsumeDecimalNumber(&in, &level) && in.empty();\n+    if (!ok || level >= config::kNumLevels) {\n+      return false;\n+    } else {\n+      char buf[100];\n+      snprintf(buf, sizeof(buf), \"%d\",\n+               versions_->NumLevelFiles(static_cast<int>(level)));\n+      *value = buf;\n+      return true;\n+    }\n+  } else if (in == \"stats\") {\n+    char buf[200];\n+    snprintf(buf, sizeof(buf),\n+             \"                               Compactions\\n\"\n+             \"Level  Files Size(MB) Time(sec) Read(MB) Write(MB)\\n\"\n+             \"--------------------------------------------------\\n\"\n+             );\n+    value->append(buf);\n+    for (int level = 0; level < config::kNumLevels; level++) {\n+      int files = versions_->NumLevelFiles(level);\n+      if (stats_[level].micros > 0 || files > 0) {\n+        snprintf(\n+            buf, sizeof(buf),\n+            \"%3d %8d %8.0f %9.0f %8.0f %9.0f\\n\",\n+            level,\n+            files,\n+            versions_->NumLevelBytes(level) / 1048576.0,\n+            stats_[level].micros / 1e6,\n+            stats_[level].bytes_read / 1048576.0,\n+            stats_[level].bytes_written / 1048576.0);\n+        value->append(buf);\n+      }\n+    }\n+    return true;\n+  } else if (in == \"sstables\") {\n+    *value = versions_->current()->DebugString();\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+void DBImpl::GetApproximateSizes(\n+    const Range* range, int n,\n+    uint64_t* sizes) {\n+  // TODO(opt): better implementation\n+  Version* v;\n+  {\n+    MutexLock l(&mutex_);\n+    versions_->current()->Ref();\n+    v = versions_->current();\n+  }\n+\n+  for (int i = 0; i < n; i++) {\n+    // Convert user_key into a corresponding internal key.\n+    InternalKey k1(range[i].start, kMaxSequenceNumber, kValueTypeForSeek);\n+    InternalKey k2(range[i].limit, kMaxSequenceNumber, kValueTypeForSeek);\n+    uint64_t start = versions_->ApproximateOffsetOf(v, k1);\n+    uint64_t limit = versions_->ApproximateOffsetOf(v, k2);\n+    sizes[i] = (limit >= start ? limit - start : 0);\n+  }\n+\n+  {\n+    MutexLock l(&mutex_);\n+    v->Unref();\n+  }\n+}\n+\n+// Default implementations of convenience methods that subclasses of DB\n+// can call if they wish\n+Status DB::Put(const WriteOptions& opt, const Slice& key, const Slice& value) {\n+  WriteBatch batch;\n+  batch.Put(key, value);\n+  return Write(opt, &batch);\n+}\n+\n+Status DB::Delete(const WriteOptions& opt, const Slice& key) {\n+  WriteBatch batch;\n+  batch.Delete(key);\n+  return Write(opt, &batch);\n+}\n+\n+DB::~DB() { }\n+\n+Status DB::Open(const Options& options, const std::string& dbname,\n+                DB** dbptr) {\n+  *dbptr = NULL;\n+\n+  DBImpl* impl = new DBImpl(options, dbname);\n+  impl->mutex_.Lock();\n+  VersionEdit edit;\n+  Status s = impl->Recover(&edit); // Handles create_if_missing, error_if_exists\n+  if (s.ok()) {\n+    uint64_t new_log_number = impl->versions_->NewFileNumber();\n+    WritableFile* lfile;\n+    s = options.env->NewWritableFile(LogFileName(dbname, new_log_number),\n+                                     &lfile);\n+    if (s.ok()) {\n+      edit.SetLogNumber(new_log_number);\n+      impl->logfile_ = lfile;\n+      impl->logfile_number_ = new_log_number;\n+      impl->log_ = new log::Writer(lfile);\n+      s = impl->versions_->LogAndApply(&edit, &impl->mutex_);\n+    }\n+    if (s.ok()) {\n+      impl->DeleteObsoleteFiles();\n+      impl->MaybeScheduleCompaction();\n+    }\n+  }\n+  impl->mutex_.Unlock();\n+  if (s.ok()) {\n+    *dbptr = impl;\n+  } else {\n+    delete impl;\n+  }\n+  return s;\n+}\n+\n+Snapshot::~Snapshot() {\n+}\n+\n+Status DestroyDB(const std::string& dbname, const Options& options) {\n+  Env* env = options.env;\n+  std::vector<std::string> filenames;\n+  // Ignore error in case directory does not exist\n+  env->GetChildren(dbname, &filenames);\n+  if (filenames.empty()) {\n+    return Status::OK();\n+  }\n+\n+  FileLock* lock;\n+  const std::string lockname = LockFileName(dbname);\n+  Status result = env->LockFile(lockname, &lock);\n+  if (result.ok()) {\n+    uint64_t number;\n+    FileType type;\n+    for (size_t i = 0; i < filenames.size(); i++) {\n+      if (ParseFileName(filenames[i], &number, &type) &&\n+          type != kDBLockFile) {  // Lock file will be deleted at end\n+        Status del = env->DeleteFile(dbname + \"/\" + filenames[i]);\n+        if (result.ok() && !del.ok()) {\n+          result = del;\n+        }\n+      }\n+    }\n+    env->UnlockFile(lock);  // Ignore error since state is already gone\n+    env->DeleteFile(lockname);\n+    env->DeleteDir(dbname);  // Ignore error in case dir contains other files\n+  }\n+  return result;\n+}\n+\n+}  // namespace leveldb"
      },
      {
        "sha": "8d2bb3405ff6ddd2e92ccadcd3baf601cbf1e15c",
        "filename": "src/leveldb/db/db_impl.h",
        "status": "added",
        "additions": 194,
        "deletions": 0,
        "changes": 194,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/db_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/db_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/db_impl.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,194 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#ifndef STORAGE_LEVELDB_DB_DB_IMPL_H_\n+#define STORAGE_LEVELDB_DB_DB_IMPL_H_\n+\n+#include <deque>\n+#include <set>\n+#include \"db/dbformat.h\"\n+#include \"db/log_writer.h\"\n+#include \"db/snapshot.h\"\n+#include \"leveldb/db.h\"\n+#include \"leveldb/env.h\"\n+#include \"port/port.h\"\n+\n+namespace leveldb {\n+\n+class MemTable;\n+class TableCache;\n+class Version;\n+class VersionEdit;\n+class VersionSet;\n+\n+class DBImpl : public DB {\n+ public:\n+  DBImpl(const Options& options, const std::string& dbname);\n+  virtual ~DBImpl();\n+\n+  // Implementations of the DB interface\n+  virtual Status Put(const WriteOptions&, const Slice& key, const Slice& value);\n+  virtual Status Delete(const WriteOptions&, const Slice& key);\n+  virtual Status Write(const WriteOptions& options, WriteBatch* updates);\n+  virtual Status Get(const ReadOptions& options,\n+                     const Slice& key,\n+                     std::string* value);\n+  virtual Iterator* NewIterator(const ReadOptions&);\n+  virtual const Snapshot* GetSnapshot();\n+  virtual void ReleaseSnapshot(const Snapshot* snapshot);\n+  virtual bool GetProperty(const Slice& property, std::string* value);\n+  virtual void GetApproximateSizes(const Range* range, int n, uint64_t* sizes);\n+  virtual void CompactRange(const Slice* begin, const Slice* end);\n+\n+  // Extra methods (for testing) that are not in the public DB interface\n+\n+  // Compact any files in the named level that overlap [*begin,*end]\n+  void TEST_CompactRange(int level, const Slice* begin, const Slice* end);\n+\n+  // Force current memtable contents to be compacted.\n+  Status TEST_CompactMemTable();\n+\n+  // Return an internal iterator over the current state of the database.\n+  // The keys of this iterator are internal keys (see format.h).\n+  // The returned iterator should be deleted when no longer needed.\n+  Iterator* TEST_NewInternalIterator();\n+\n+  // Return the maximum overlapping data (in bytes) at next level for any\n+  // file at a level >= 1.\n+  int64_t TEST_MaxNextLevelOverlappingBytes();\n+\n+ private:\n+  friend class DB;\n+  struct CompactionState;\n+  struct Writer;\n+\n+  Iterator* NewInternalIterator(const ReadOptions&,\n+                                SequenceNumber* latest_snapshot);\n+\n+  Status NewDB();\n+\n+  // Recover the descriptor from persistent storage.  May do a significant\n+  // amount of work to recover recently logged updates.  Any changes to\n+  // be made to the descriptor are added to *edit.\n+  Status Recover(VersionEdit* edit);\n+\n+  void MaybeIgnoreError(Status* s) const;\n+\n+  // Delete any unneeded files and stale in-memory entries.\n+  void DeleteObsoleteFiles();\n+\n+  // Compact the in-memory write buffer to disk.  Switches to a new\n+  // log-file/memtable and writes a new descriptor iff successful.\n+  Status CompactMemTable();\n+\n+  Status RecoverLogFile(uint64_t log_number,\n+                        VersionEdit* edit,\n+                        SequenceNumber* max_sequence);\n+\n+  Status WriteLevel0Table(MemTable* mem, VersionEdit* edit, Version* base);\n+\n+  Status MakeRoomForWrite(bool force /* compact even if there is room? */);\n+  WriteBatch* BuildBatchGroup(Writer** last_writer);\n+\n+  void MaybeScheduleCompaction();\n+  static void BGWork(void* db);\n+  void BackgroundCall();\n+  Status BackgroundCompaction();\n+  void CleanupCompaction(CompactionState* compact);\n+  Status DoCompactionWork(CompactionState* compact);\n+\n+  Status OpenCompactionOutputFile(CompactionState* compact);\n+  Status FinishCompactionOutputFile(CompactionState* compact, Iterator* input);\n+  Status InstallCompactionResults(CompactionState* compact);\n+\n+  // Constant after construction\n+  Env* const env_;\n+  const InternalKeyComparator internal_comparator_;\n+  const InternalFilterPolicy internal_filter_policy_;\n+  const Options options_;  // options_.comparator == &internal_comparator_\n+  bool owns_info_log_;\n+  bool owns_cache_;\n+  const std::string dbname_;\n+\n+  // table_cache_ provides its own synchronization\n+  TableCache* table_cache_;\n+\n+  // Lock over the persistent DB state.  Non-NULL iff successfully acquired.\n+  FileLock* db_lock_;\n+\n+  // State below is protected by mutex_\n+  port::Mutex mutex_;\n+  port::AtomicPointer shutting_down_;\n+  port::CondVar bg_cv_;          // Signalled when background work finishes\n+  MemTable* mem_;\n+  MemTable* imm_;                // Memtable being compacted\n+  port::AtomicPointer has_imm_;  // So bg thread can detect non-NULL imm_\n+  WritableFile* logfile_;\n+  uint64_t logfile_number_;\n+  log::Writer* log_;\n+\n+  // Queue of writers.\n+  std::deque<Writer*> writers_;\n+  WriteBatch* tmp_batch_;\n+\n+  SnapshotList snapshots_;\n+\n+  // Set of table files to protect from deletion because they are\n+  // part of ongoing compactions.\n+  std::set<uint64_t> pending_outputs_;\n+\n+  // Has a background compaction been scheduled or is running?\n+  bool bg_compaction_scheduled_;\n+\n+  // Information for a manual compaction\n+  struct ManualCompaction {\n+    int level;\n+    bool done;\n+    const InternalKey* begin;   // NULL means beginning of key range\n+    const InternalKey* end;     // NULL means end of key range\n+    InternalKey tmp_storage;    // Used to keep track of compaction progress\n+  };\n+  ManualCompaction* manual_compaction_;\n+\n+  VersionSet* versions_;\n+\n+  // Have we encountered a background error in paranoid mode?\n+  Status bg_error_;\n+\n+  // Per level compaction stats.  stats_[level] stores the stats for\n+  // compactions that produced data for the specified \"level\".\n+  struct CompactionStats {\n+    int64_t micros;\n+    int64_t bytes_read;\n+    int64_t bytes_written;\n+\n+    CompactionStats() : micros(0), bytes_read(0), bytes_written(0) { }\n+\n+    void Add(const CompactionStats& c) {\n+      this->micros += c.micros;\n+      this->bytes_read += c.bytes_read;\n+      this->bytes_written += c.bytes_written;\n+    }\n+  };\n+  CompactionStats stats_[config::kNumLevels];\n+\n+  // No copying allowed\n+  DBImpl(const DBImpl&);\n+  void operator=(const DBImpl&);\n+\n+  const Comparator* user_comparator() const {\n+    return internal_comparator_.user_comparator();\n+  }\n+};\n+\n+// Sanitize db options.  The caller should delete result.info_log if\n+// it is not equal to src.info_log.\n+extern Options SanitizeOptions(const std::string& db,\n+                               const InternalKeyComparator* icmp,\n+                               const InternalFilterPolicy* ipolicy,\n+                               const Options& src);\n+\n+}  // namespace leveldb\n+\n+#endif  // STORAGE_LEVELDB_DB_DB_IMPL_H_"
      },
      {
        "sha": "87dca2ded46453dec5e04cef652d2545086af485",
        "filename": "src/leveldb/db/db_iter.cc",
        "status": "added",
        "additions": 299,
        "deletions": 0,
        "changes": 299,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/db_iter.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/db_iter.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/db_iter.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,299 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include \"db/db_iter.h\"\n+\n+#include \"db/filename.h\"\n+#include \"db/dbformat.h\"\n+#include \"leveldb/env.h\"\n+#include \"leveldb/iterator.h\"\n+#include \"port/port.h\"\n+#include \"util/logging.h\"\n+#include \"util/mutexlock.h\"\n+\n+namespace leveldb {\n+\n+#if 0\n+static void DumpInternalIter(Iterator* iter) {\n+  for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n+    ParsedInternalKey k;\n+    if (!ParseInternalKey(iter->key(), &k)) {\n+      fprintf(stderr, \"Corrupt '%s'\\n\", EscapeString(iter->key()).c_str());\n+    } else {\n+      fprintf(stderr, \"@ '%s'\\n\", k.DebugString().c_str());\n+    }\n+  }\n+}\n+#endif\n+\n+namespace {\n+\n+// Memtables and sstables that make the DB representation contain\n+// (userkey,seq,type) => uservalue entries.  DBIter\n+// combines multiple entries for the same userkey found in the DB\n+// representation into a single entry while accounting for sequence\n+// numbers, deletion markers, overwrites, etc.\n+class DBIter: public Iterator {\n+ public:\n+  // Which direction is the iterator currently moving?\n+  // (1) When moving forward, the internal iterator is positioned at\n+  //     the exact entry that yields this->key(), this->value()\n+  // (2) When moving backwards, the internal iterator is positioned\n+  //     just before all entries whose user key == this->key().\n+  enum Direction {\n+    kForward,\n+    kReverse\n+  };\n+\n+  DBIter(const std::string* dbname, Env* env,\n+         const Comparator* cmp, Iterator* iter, SequenceNumber s)\n+      : dbname_(dbname),\n+        env_(env),\n+        user_comparator_(cmp),\n+        iter_(iter),\n+        sequence_(s),\n+        direction_(kForward),\n+        valid_(false) {\n+  }\n+  virtual ~DBIter() {\n+    delete iter_;\n+  }\n+  virtual bool Valid() const { return valid_; }\n+  virtual Slice key() const {\n+    assert(valid_);\n+    return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;\n+  }\n+  virtual Slice value() const {\n+    assert(valid_);\n+    return (direction_ == kForward) ? iter_->value() : saved_value_;\n+  }\n+  virtual Status status() const {\n+    if (status_.ok()) {\n+      return iter_->status();\n+    } else {\n+      return status_;\n+    }\n+  }\n+\n+  virtual void Next();\n+  virtual void Prev();\n+  virtual void Seek(const Slice& target);\n+  virtual void SeekToFirst();\n+  virtual void SeekToLast();\n+\n+ private:\n+  void FindNextUserEntry(bool skipping, std::string* skip);\n+  void FindPrevUserEntry();\n+  bool ParseKey(ParsedInternalKey* key);\n+\n+  inline void SaveKey(const Slice& k, std::string* dst) {\n+    dst->assign(k.data(), k.size());\n+  }\n+\n+  inline void ClearSavedValue() {\n+    if (saved_value_.capacity() > 1048576) {\n+      std::string empty;\n+      swap(empty, saved_value_);\n+    } else {\n+      saved_value_.clear();\n+    }\n+  }\n+\n+  const std::string* const dbname_;\n+  Env* const env_;\n+  const Comparator* const user_comparator_;\n+  Iterator* const iter_;\n+  SequenceNumber const sequence_;\n+\n+  Status status_;\n+  std::string saved_key_;     // == current key when direction_==kReverse\n+  std::string saved_value_;   // == current raw value when direction_==kReverse\n+  Direction direction_;\n+  bool valid_;\n+\n+  // No copying allowed\n+  DBIter(const DBIter&);\n+  void operator=(const DBIter&);\n+};\n+\n+inline bool DBIter::ParseKey(ParsedInternalKey* ikey) {\n+  if (!ParseInternalKey(iter_->key(), ikey)) {\n+    status_ = Status::Corruption(\"corrupted internal key in DBIter\");\n+    return false;\n+  } else {\n+    return true;\n+  }\n+}\n+\n+void DBIter::Next() {\n+  assert(valid_);\n+\n+  if (direction_ == kReverse) {  // Switch directions?\n+    direction_ = kForward;\n+    // iter_ is pointing just before the entries for this->key(),\n+    // so advance into the range of entries for this->key() and then\n+    // use the normal skipping code below.\n+    if (!iter_->Valid()) {\n+      iter_->SeekToFirst();\n+    } else {\n+      iter_->Next();\n+    }\n+    if (!iter_->Valid()) {\n+      valid_ = false;\n+      saved_key_.clear();\n+      return;\n+    }\n+  }\n+\n+  // Temporarily use saved_key_ as storage for key to skip.\n+  std::string* skip = &saved_key_;\n+  SaveKey(ExtractUserKey(iter_->key()), skip);\n+  FindNextUserEntry(true, skip);\n+}\n+\n+void DBIter::FindNextUserEntry(bool skipping, std::string* skip) {\n+  // Loop until we hit an acceptable entry to yield\n+  assert(iter_->Valid());\n+  assert(direction_ == kForward);\n+  do {\n+    ParsedInternalKey ikey;\n+    if (ParseKey(&ikey) && ikey.sequence <= sequence_) {\n+      switch (ikey.type) {\n+        case kTypeDeletion:\n+          // Arrange to skip all upcoming entries for this key since\n+          // they are hidden by this deletion.\n+          SaveKey(ikey.user_key, skip);\n+          skipping = true;\n+          break;\n+        case kTypeValue:\n+          if (skipping &&\n+              user_comparator_->Compare(ikey.user_key, *skip) <= 0) {\n+            // Entry hidden\n+          } else {\n+            valid_ = true;\n+            saved_key_.clear();\n+            return;\n+          }\n+          break;\n+      }\n+    }\n+    iter_->Next();\n+  } while (iter_->Valid());\n+  saved_key_.clear();\n+  valid_ = false;\n+}\n+\n+void DBIter::Prev() {\n+  assert(valid_);\n+\n+  if (direction_ == kForward) {  // Switch directions?\n+    // iter_ is pointing at the current entry.  Scan backwards until\n+    // the key changes so we can use the normal reverse scanning code.\n+    assert(iter_->Valid());  // Otherwise valid_ would have been false\n+    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n+    while (true) {\n+      iter_->Prev();\n+      if (!iter_->Valid()) {\n+        valid_ = false;\n+        saved_key_.clear();\n+        ClearSavedValue();\n+        return;\n+      }\n+      if (user_comparator_->Compare(ExtractUserKey(iter_->key()),\n+                                    saved_key_) < 0) {\n+        break;\n+      }\n+    }\n+    direction_ = kReverse;\n+  }\n+\n+  FindPrevUserEntry();\n+}\n+\n+void DBIter::FindPrevUserEntry() {\n+  assert(direction_ == kReverse);\n+\n+  ValueType value_type = kTypeDeletion;\n+  if (iter_->Valid()) {\n+    do {\n+      ParsedInternalKey ikey;\n+      if (ParseKey(&ikey) && ikey.sequence <= sequence_) {\n+        if ((value_type != kTypeDeletion) &&\n+            user_comparator_->Compare(ikey.user_key, saved_key_) < 0) {\n+          // We encountered a non-deleted value in entries for previous keys,\n+          break;\n+        }\n+        value_type = ikey.type;\n+        if (value_type == kTypeDeletion) {\n+          saved_key_.clear();\n+          ClearSavedValue();\n+        } else {\n+          Slice raw_value = iter_->value();\n+          if (saved_value_.capacity() > raw_value.size() + 1048576) {\n+            std::string empty;\n+            swap(empty, saved_value_);\n+          }\n+          SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n+          saved_value_.assign(raw_value.data(), raw_value.size());\n+        }\n+      }\n+      iter_->Prev();\n+    } while (iter_->Valid());\n+  }\n+\n+  if (value_type == kTypeDeletion) {\n+    // End\n+    valid_ = false;\n+    saved_key_.clear();\n+    ClearSavedValue();\n+    direction_ = kForward;\n+  } else {\n+    valid_ = true;\n+  }\n+}\n+\n+void DBIter::Seek(const Slice& target) {\n+  direction_ = kForward;\n+  ClearSavedValue();\n+  saved_key_.clear();\n+  AppendInternalKey(\n+      &saved_key_, ParsedInternalKey(target, sequence_, kValueTypeForSeek));\n+  iter_->Seek(saved_key_);\n+  if (iter_->Valid()) {\n+    FindNextUserEntry(false, &saved_key_ /* temporary storage */);\n+  } else {\n+    valid_ = false;\n+  }\n+}\n+\n+void DBIter::SeekToFirst() {\n+  direction_ = kForward;\n+  ClearSavedValue();\n+  iter_->SeekToFirst();\n+  if (iter_->Valid()) {\n+    FindNextUserEntry(false, &saved_key_ /* temporary storage */);\n+  } else {\n+    valid_ = false;\n+  }\n+}\n+\n+void DBIter::SeekToLast() {\n+  direction_ = kReverse;\n+  ClearSavedValue();\n+  iter_->SeekToLast();\n+  FindPrevUserEntry();\n+}\n+\n+}  // anonymous namespace\n+\n+Iterator* NewDBIterator(\n+    const std::string* dbname,\n+    Env* env,\n+    const Comparator* user_key_comparator,\n+    Iterator* internal_iter,\n+    const SequenceNumber& sequence) {\n+  return new DBIter(dbname, env, user_key_comparator, internal_iter, sequence);\n+}\n+\n+}  // namespace leveldb"
      },
      {
        "sha": "d9e1b174ab8726eeca58197bb2c36f73099d13e5",
        "filename": "src/leveldb/db/db_iter.h",
        "status": "added",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/db_iter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/db_iter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/db_iter.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,26 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#ifndef STORAGE_LEVELDB_DB_DB_ITER_H_\n+#define STORAGE_LEVELDB_DB_DB_ITER_H_\n+\n+#include <stdint.h>\n+#include \"leveldb/db.h\"\n+#include \"db/dbformat.h\"\n+\n+namespace leveldb {\n+\n+// Return a new iterator that converts internal keys (yielded by\n+// \"*internal_iter\") that were live at the specified \"sequence\" number\n+// into appropriate user keys.\n+extern Iterator* NewDBIterator(\n+    const std::string* dbname,\n+    Env* env,\n+    const Comparator* user_key_comparator,\n+    Iterator* internal_iter,\n+    const SequenceNumber& sequence);\n+\n+}  // namespace leveldb\n+\n+#endif  // STORAGE_LEVELDB_DB_DB_ITER_H_"
      },
      {
        "sha": "3744d0e117924204e5c5ca67f6ec16fef30bd809",
        "filename": "src/leveldb/db/db_test.cc",
        "status": "added",
        "additions": 1946,
        "deletions": 0,
        "changes": 1946,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/db_test.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/db_test.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/db_test.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,1946 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include \"leveldb/db.h\"\n+#include \"leveldb/filter_policy.h\"\n+#include \"db/db_impl.h\"\n+#include \"db/filename.h\"\n+#include \"db/version_set.h\"\n+#include \"db/write_batch_internal.h\"\n+#include \"leveldb/cache.h\"\n+#include \"leveldb/env.h\"\n+#include \"leveldb/table.h\"\n+#include \"util/hash.h\"\n+#include \"util/logging.h\"\n+#include \"util/mutexlock.h\"\n+#include \"util/testharness.h\"\n+#include \"util/testutil.h\"\n+\n+namespace leveldb {\n+\n+static std::string RandomString(Random* rnd, int len) {\n+  std::string r;\n+  test::RandomString(rnd, len, &r);\n+  return r;\n+}\n+\n+namespace {\n+class AtomicCounter {\n+ private:\n+  port::Mutex mu_;\n+  int count_;\n+ public:\n+  AtomicCounter() : count_(0) { }\n+  void Increment() {\n+    MutexLock l(&mu_);\n+    count_++;\n+  }\n+  int Read() {\n+    MutexLock l(&mu_);\n+    return count_;\n+  }\n+  void Reset() {\n+    MutexLock l(&mu_);\n+    count_ = 0;\n+  }\n+};\n+}\n+\n+// Special Env used to delay background operations\n+class SpecialEnv : public EnvWrapper {\n+ public:\n+  // sstable Sync() calls are blocked while this pointer is non-NULL.\n+  port::AtomicPointer delay_sstable_sync_;\n+\n+  // Simulate no-space errors while this pointer is non-NULL.\n+  port::AtomicPointer no_space_;\n+\n+  // Simulate non-writable file system while this pointer is non-NULL\n+  port::AtomicPointer non_writable_;\n+\n+  bool count_random_reads_;\n+  AtomicCounter random_read_counter_;\n+\n+  AtomicCounter sleep_counter_;\n+\n+  explicit SpecialEnv(Env* base) : EnvWrapper(base) {\n+    delay_sstable_sync_.Release_Store(NULL);\n+    no_space_.Release_Store(NULL);\n+    non_writable_.Release_Store(NULL);\n+    count_random_reads_ = false;\n+  }\n+\n+  Status NewWritableFile(const std::string& f, WritableFile** r) {\n+    class SSTableFile : public WritableFile {\n+     private:\n+      SpecialEnv* env_;\n+      WritableFile* base_;\n+\n+     public:\n+      SSTableFile(SpecialEnv* env, WritableFile* base)\n+          : env_(env),\n+            base_(base) {\n+      }\n+      ~SSTableFile() { delete base_; }\n+      Status Append(const Slice& data) {\n+        if (env_->no_space_.Acquire_Load() != NULL) {\n+          // Drop writes on the floor\n+          return Status::OK();\n+        } else {\n+          return base_->Append(data);\n+        }\n+      }\n+      Status Close() { return base_->Close(); }\n+      Status Flush() { return base_->Flush(); }\n+      Status Sync() {\n+        while (env_->delay_sstable_sync_.Acquire_Load() != NULL) {\n+          env_->SleepForMicroseconds(100000);\n+        }\n+        return base_->Sync();\n+      }\n+    };\n+\n+    if (non_writable_.Acquire_Load() != NULL) {\n+      return Status::IOError(\"simulated write error\");\n+    }\n+\n+    Status s = target()->NewWritableFile(f, r);\n+    if (s.ok()) {\n+      if (strstr(f.c_str(), \".sst\") != NULL) {\n+        *r = new SSTableFile(this, *r);\n+      }\n+    }\n+    return s;\n+  }\n+\n+  Status NewRandomAccessFile(const std::string& f, RandomAccessFile** r) {\n+    class CountingFile : public RandomAccessFile {\n+     private:\n+      RandomAccessFile* target_;\n+      AtomicCounter* counter_;\n+     public:\n+      CountingFile(RandomAccessFile* target, AtomicCounter* counter)\n+          : target_(target), counter_(counter) {\n+      }\n+      virtual ~CountingFile() { delete target_; }\n+      virtual Status Read(uint64_t offset, size_t n, Slice* result,\n+                          char* scratch) const {\n+        counter_->Increment();\n+        return target_->Read(offset, n, result, scratch);\n+      }\n+    };\n+\n+    Status s = target()->NewRandomAccessFile(f, r);\n+    if (s.ok() && count_random_reads_) {\n+      *r = new CountingFile(*r, &random_read_counter_);\n+    }\n+    return s;\n+  }\n+\n+  virtual void SleepForMicroseconds(int micros) {\n+    sleep_counter_.Increment();\n+    target()->SleepForMicroseconds(micros);\n+  }\n+};\n+\n+class DBTest {\n+ private:\n+  const FilterPolicy* filter_policy_;\n+\n+  // Sequence of option configurations to try\n+  enum OptionConfig {\n+    kDefault,\n+    kFilter,\n+    kUncompressed,\n+    kEnd\n+  };\n+  int option_config_;\n+\n+ public:\n+  std::string dbname_;\n+  SpecialEnv* env_;\n+  DB* db_;\n+\n+  Options last_options_;\n+\n+  DBTest() : option_config_(kDefault),\n+             env_(new SpecialEnv(Env::Default())) {\n+    filter_policy_ = NewBloomFilterPolicy(10);\n+    dbname_ = test::TmpDir() + \"/db_test\";\n+    DestroyDB(dbname_, Options());\n+    db_ = NULL;\n+    Reopen();\n+  }\n+\n+  ~DBTest() {\n+    delete db_;\n+    DestroyDB(dbname_, Options());\n+    delete env_;\n+    delete filter_policy_;\n+  }\n+\n+  // Switch to a fresh database with the next option configuration to\n+  // test.  Return false if there are no more configurations to test.\n+  bool ChangeOptions() {\n+    option_config_++;\n+    if (option_config_ >= kEnd) {\n+      return false;\n+    } else {\n+      DestroyAndReopen();\n+      return true;\n+    }\n+  }\n+\n+  // Return the current option configuration.\n+  Options CurrentOptions() {\n+    Options options;\n+    switch (option_config_) {\n+      case kFilter:\n+        options.filter_policy = filter_policy_;\n+        break;\n+      case kUncompressed:\n+        options.compression = kNoCompression;\n+        break;\n+      default:\n+        break;\n+    }\n+    return options;\n+  }\n+\n+  DBImpl* dbfull() {\n+    return reinterpret_cast<DBImpl*>(db_);\n+  }\n+\n+  void Reopen(Options* options = NULL) {\n+    ASSERT_OK(TryReopen(options));\n+  }\n+\n+  void Close() {\n+    delete db_;\n+    db_ = NULL;\n+  }\n+\n+  void DestroyAndReopen(Options* options = NULL) {\n+    delete db_;\n+    db_ = NULL;\n+    DestroyDB(dbname_, Options());\n+    ASSERT_OK(TryReopen(options));\n+  }\n+\n+  Status TryReopen(Options* options) {\n+    delete db_;\n+    db_ = NULL;\n+    Options opts;\n+    if (options != NULL) {\n+      opts = *options;\n+    } else {\n+      opts = CurrentOptions();\n+      opts.create_if_missing = true;\n+    }\n+    last_options_ = opts;\n+\n+    return DB::Open(opts, dbname_, &db_);\n+  }\n+\n+  Status Put(const std::string& k, const std::string& v) {\n+    return db_->Put(WriteOptions(), k, v);\n+  }\n+\n+  Status Delete(const std::string& k) {\n+    return db_->Delete(WriteOptions(), k);\n+  }\n+\n+  std::string Get(const std::string& k, const Snapshot* snapshot = NULL) {\n+    ReadOptions options;\n+    options.snapshot = snapshot;\n+    std::string result;\n+    Status s = db_->Get(options, k, &result);\n+    if (s.IsNotFound()) {\n+      result = \"NOT_FOUND\";\n+    } else if (!s.ok()) {\n+      result = s.ToString();\n+    }\n+    return result;\n+  }\n+\n+  // Return a string that contains all key,value pairs in order,\n+  // formatted like \"(k1->v1)(k2->v2)\".\n+  std::string Contents() {\n+    std::vector<std::string> forward;\n+    std::string result;\n+    Iterator* iter = db_->NewIterator(ReadOptions());\n+    for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n+      std::string s = IterStatus(iter);\n+      result.push_back('(');\n+      result.append(s);\n+      result.push_back(')');\n+      forward.push_back(s);\n+    }\n+\n+    // Check reverse iteration results are the reverse of forward results\n+    int matched = 0;\n+    for (iter->SeekToLast(); iter->Valid(); iter->Prev()) {\n+      ASSERT_LT(matched, forward.size());\n+      ASSERT_EQ(IterStatus(iter), forward[forward.size() - matched - 1]);\n+      matched++;\n+    }\n+    ASSERT_EQ(matched, forward.size());\n+\n+    delete iter;\n+    return result;\n+  }\n+\n+  std::string AllEntriesFor(const Slice& user_key) {\n+    Iterator* iter = dbfull()->TEST_NewInternalIterator();\n+    InternalKey target(user_key, kMaxSequenceNumber, kTypeValue);\n+    iter->Seek(target.Encode());\n+    std::string result;\n+    if (!iter->status().ok()) {\n+      result = iter->status().ToString();\n+    } else {\n+      result = \"[ \";\n+      bool first = true;\n+      while (iter->Valid()) {\n+        ParsedInternalKey ikey;\n+        if (!ParseInternalKey(iter->key(), &ikey)) {\n+          result += \"CORRUPTED\";\n+        } else {\n+          if (last_options_.comparator->Compare(ikey.user_key, user_key) != 0) {\n+            break;\n+          }\n+          if (!first) {\n+            result += \", \";\n+          }\n+          first = false;\n+          switch (ikey.type) {\n+            case kTypeValue:\n+              result += iter->value().ToString();\n+              break;\n+            case kTypeDeletion:\n+              result += \"DEL\";\n+              break;\n+          }\n+        }\n+        iter->Next();\n+      }\n+      if (!first) {\n+        result += \" \";\n+      }\n+      result += \"]\";\n+    }\n+    delete iter;\n+    return result;\n+  }\n+\n+  int NumTableFilesAtLevel(int level) {\n+    std::string property;\n+    ASSERT_TRUE(\n+        db_->GetProperty(\"leveldb.num-files-at-level\" + NumberToString(level),\n+                         &property));\n+    return atoi(property.c_str());\n+  }\n+\n+  int TotalTableFiles() {\n+    int result = 0;\n+    for (int level = 0; level < config::kNumLevels; level++) {\n+      result += NumTableFilesAtLevel(level);\n+    }\n+    return result;\n+  }\n+\n+  // Return spread of files per level\n+  std::string FilesPerLevel() {\n+    std::string result;\n+    int last_non_zero_offset = 0;\n+    for (int level = 0; level < config::kNumLevels; level++) {\n+      int f = NumTableFilesAtLevel(level);\n+      char buf[100];\n+      snprintf(buf, sizeof(buf), \"%s%d\", (level ? \",\" : \"\"), f);\n+      result += buf;\n+      if (f > 0) {\n+        last_non_zero_offset = result.size();\n+      }\n+    }\n+    result.resize(last_non_zero_offset);\n+    return result;\n+  }\n+\n+  int CountFiles() {\n+    std::vector<std::string> files;\n+    env_->GetChildren(dbname_, &files);\n+    return static_cast<int>(files.size());\n+  }\n+\n+  uint64_t Size(const Slice& start, const Slice& limit) {\n+    Range r(start, limit);\n+    uint64_t size;\n+    db_->GetApproximateSizes(&r, 1, &size);\n+    return size;\n+  }\n+\n+  void Compact(const Slice& start, const Slice& limit) {\n+    db_->CompactRange(&start, &limit);\n+  }\n+\n+  // Do n memtable compactions, each of which produces an sstable\n+  // covering the range [small,large].\n+  void MakeTables(int n, const std::string& small, const std::string& large) {\n+    for (int i = 0; i < n; i++) {\n+      Put(small, \"begin\");\n+      Put(large, \"end\");\n+      dbfull()->TEST_CompactMemTable();\n+    }\n+  }\n+\n+  // Prevent pushing of new sstables into deeper levels by adding\n+  // tables that cover a specified range to all levels.\n+  void FillLevels(const std::string& smallest, const std::string& largest) {\n+    MakeTables(config::kNumLevels, smallest, largest);\n+  }\n+\n+  void DumpFileCounts(const char* label) {\n+    fprintf(stderr, \"---\\n%s:\\n\", label);\n+    fprintf(stderr, \"maxoverlap: %lld\\n\",\n+            static_cast<long long>(\n+                dbfull()->TEST_MaxNextLevelOverlappingBytes()));\n+    for (int level = 0; level < config::kNumLevels; level++) {\n+      int num = NumTableFilesAtLevel(level);\n+      if (num > 0) {\n+        fprintf(stderr, \"  level %3d : %d files\\n\", level, num);\n+      }\n+    }\n+  }\n+\n+  std::string DumpSSTableList() {\n+    std::string property;\n+    db_->GetProperty(\"leveldb.sstables\", &property);\n+    return property;\n+  }\n+\n+  std::string IterStatus(Iterator* iter) {\n+    std::string result;\n+    if (iter->Valid()) {\n+      result = iter->key().ToString() + \"->\" + iter->value().ToString();\n+    } else {\n+      result = \"(invalid)\";\n+    }\n+    return result;\n+  }\n+};\n+\n+TEST(DBTest, Empty) {\n+  do {\n+    ASSERT_TRUE(db_ != NULL);\n+    ASSERT_EQ(\"NOT_FOUND\", Get(\"foo\"));\n+  } while (ChangeOptions());\n+}\n+\n+TEST(DBTest, ReadWrite) {\n+  do {\n+    ASSERT_OK(Put(\"foo\", \"v1\"));\n+    ASSERT_EQ(\"v1\", Get(\"foo\"));\n+    ASSERT_OK(Put(\"bar\", \"v2\"));\n+    ASSERT_OK(Put(\"foo\", \"v3\"));\n+    ASSERT_EQ(\"v3\", Get(\"foo\"));\n+    ASSERT_EQ(\"v2\", Get(\"bar\"));\n+  } while (ChangeOptions());\n+}\n+\n+TEST(DBTest, PutDeleteGet) {\n+  do {\n+    ASSERT_OK(db_->Put(WriteOptions(), \"foo\", \"v1\"));\n+    ASSERT_EQ(\"v1\", Get(\"foo\"));\n+    ASSERT_OK(db_->Put(WriteOptions(), \"foo\", \"v2\"));\n+    ASSERT_EQ(\"v2\", Get(\"foo\"));\n+    ASSERT_OK(db_->Delete(WriteOptions(), \"foo\"));\n+    ASSERT_EQ(\"NOT_FOUND\", Get(\"foo\"));\n+  } while (ChangeOptions());\n+}\n+\n+TEST(DBTest, GetFromImmutableLayer) {\n+  do {\n+    Options options = CurrentOptions();\n+    options.env = env_;\n+    options.write_buffer_size = 100000;  // Small write buffer\n+    Reopen(&options);\n+\n+    ASSERT_OK(Put(\"foo\", \"v1\"));\n+    ASSERT_EQ(\"v1\", Get(\"foo\"));\n+\n+    env_->delay_sstable_sync_.Release_Store(env_);   // Block sync calls\n+    Put(\"k1\", std::string(100000, 'x'));             // Fill memtable\n+    Put(\"k2\", std::string(100000, 'y'));             // Trigger compaction\n+    ASSERT_EQ(\"v1\", Get(\"foo\"));\n+    env_->delay_sstable_sync_.Release_Store(NULL);   // Release sync calls\n+  } while (ChangeOptions());\n+}\n+\n+TEST(DBTest, GetFromVersions) {\n+  do {\n+    ASSERT_OK(Put(\"foo\", \"v1\"));\n+    dbfull()->TEST_CompactMemTable();\n+    ASSERT_EQ(\"v1\", Get(\"foo\"));\n+  } while (ChangeOptions());\n+}\n+\n+TEST(DBTest, GetSnapshot) {\n+  do {\n+    // Try with both a short key and a long key\n+    for (int i = 0; i < 2; i++) {\n+      std::string key = (i == 0) ? std::string(\"foo\") : std::string(200, 'x');\n+      ASSERT_OK(Put(key, \"v1\"));\n+      const Snapshot* s1 = db_->GetSnapshot();\n+      ASSERT_OK(Put(key, \"v2\"));\n+      ASSERT_EQ(\"v2\", Get(key));\n+      ASSERT_EQ(\"v1\", Get(key, s1));\n+      dbfull()->TEST_CompactMemTable();\n+      ASSERT_EQ(\"v2\", Get(key));\n+      ASSERT_EQ(\"v1\", Get(key, s1));\n+      db_->ReleaseSnapshot(s1);\n+    }\n+  } while (ChangeOptions());\n+}\n+\n+TEST(DBTest, GetLevel0Ordering) {\n+  do {\n+    // Check that we process level-0 files in correct order.  The code\n+    // below generates two level-0 files where the earlier one comes\n+    // before the later one in the level-0 file list since the earlier\n+    // one has a smaller \"smallest\" key.\n+    ASSERT_OK(Put(\"bar\", \"b\"));\n+    ASSERT_OK(Put(\"foo\", \"v1\"));\n+    dbfull()->TEST_CompactMemTable();\n+    ASSERT_OK(Put(\"foo\", \"v2\"));\n+    dbfull()->TEST_CompactMemTable();\n+    ASSERT_EQ(\"v2\", Get(\"foo\"));\n+  } while (ChangeOptions());\n+}\n+\n+TEST(DBTest, GetOrderedByLevels) {\n+  do {\n+    ASSERT_OK(Put(\"foo\", \"v1\"));\n+    Compact(\"a\", \"z\");\n+    ASSERT_EQ(\"v1\", Get(\"foo\"));\n+    ASSERT_OK(Put(\"foo\", \"v2\"));\n+    ASSERT_EQ(\"v2\", Get(\"foo\"));\n+    dbfull()->TEST_CompactMemTable();\n+    ASSERT_EQ(\"v2\", Get(\"foo\"));\n+  } while (ChangeOptions());\n+}\n+\n+TEST(DBTest, GetPicksCorrectFile) {\n+  do {\n+    // Arrange to have multiple files in a non-level-0 level.\n+    ASSERT_OK(Put(\"a\", \"va\"));\n+    Compact(\"a\", \"b\");\n+    ASSERT_OK(Put(\"x\", \"vx\"));\n+    Compact(\"x\", \"y\");\n+    ASSERT_OK(Put(\"f\", \"vf\"));\n+    Compact(\"f\", \"g\");\n+    ASSERT_EQ(\"va\", Get(\"a\"));\n+    ASSERT_EQ(\"vf\", Get(\"f\"));\n+    ASSERT_EQ(\"vx\", Get(\"x\"));\n+  } while (ChangeOptions());\n+}\n+\n+TEST(DBTest, GetEncountersEmptyLevel) {\n+  do {\n+    // Arrange for the following to happen:\n+    //   * sstable A in level 0\n+    //   * nothing in level 1\n+    //   * sstable B in level 2\n+    // Then do enough Get() calls to arrange for an automatic compaction\n+    // of sstable A.  A bug would cause the compaction to be marked as\n+    // occuring at level 1 (instead of the correct level 0).\n+\n+    // Step 1: First place sstables in levels 0 and 2\n+    int compaction_count = 0;\n+    while (NumTableFilesAtLevel(0) == 0 ||\n+           NumTableFilesAtLevel(2) == 0) {\n+      ASSERT_LE(compaction_count, 100) << \"could not fill levels 0 and 2\";\n+      compaction_count++;\n+      Put(\"a\", \"begin\");\n+      Put(\"z\", \"end\");\n+      dbfull()->TEST_CompactMemTable();\n+    }\n+\n+    // Step 2: clear level 1 if necessary.\n+    dbfull()->TEST_CompactRange(1, NULL, NULL);\n+    ASSERT_EQ(NumTableFilesAtLevel(0), 1);\n+    ASSERT_EQ(NumTableFilesAtLevel(1), 0);\n+    ASSERT_EQ(NumTableFilesAtLevel(2), 1);\n+\n+    // Step 3: read a bunch of times\n+    for (int i = 0; i < 1000; i++) {\n+      ASSERT_EQ(\"NOT_FOUND\", Get(\"missing\"));\n+    }\n+\n+    // Step 4: Wait for compaction to finish\n+    env_->SleepForMicroseconds(1000000);\n+\n+    ASSERT_EQ(NumTableFilesAtLevel(0), 0);\n+  } while (ChangeOptions());\n+}\n+\n+TEST(DBTest, IterEmpty) {\n+  Iterator* iter = db_->NewIterator(ReadOptions());\n+\n+  iter->SeekToFirst();\n+  ASSERT_EQ(IterStatus(iter), \"(invalid)\");\n+\n+  iter->SeekToLast();\n+  ASSERT_EQ(IterStatus(iter), \"(invalid)\");\n+\n+  iter->Seek(\"foo\");\n+  ASSERT_EQ(IterStatus(iter), \"(invalid)\");\n+\n+  delete iter;\n+}\n+\n+TEST(DBTest, IterSingle) {\n+  ASSERT_OK(Put(\"a\", \"va\"));\n+  Iterator* iter = db_->NewIterator(ReadOptions());\n+\n+  iter->SeekToFirst();\n+  ASSERT_EQ(IterStatus(iter), \"a->va\");\n+  iter->Next();\n+  ASSERT_EQ(IterStatus(iter), \"(invalid)\");\n+  iter->SeekToFirst();\n+  ASSERT_EQ(IterStatus(iter), \"a->va\");\n+  iter->Prev();\n+  ASSERT_EQ(IterStatus(iter), \"(invalid)\");\n+\n+  iter->SeekToLast();\n+  ASSERT_EQ(IterStatus(iter), \"a->va\");\n+  iter->Next();\n+  ASSERT_EQ(IterStatus(iter), \"(invalid)\");\n+  iter->SeekToLast();\n+  ASSERT_EQ(IterStatus(iter), \"a->va\");\n+  iter->Prev();\n+  ASSERT_EQ(IterStatus(iter), \"(invalid)\");\n+\n+  iter->Seek(\"\");\n+  ASSERT_EQ(IterStatus(iter), \"a->va\");\n+  iter->Next();\n+  ASSERT_EQ(IterStatus(iter), \"(invalid)\");\n+\n+  iter->Seek(\"a\");\n+  ASSERT_EQ(IterStatus(iter), \"a->va\");\n+  iter->Next();\n+  ASSERT_EQ(IterStatus(iter), \"(invalid)\");\n+\n+  iter->Seek(\"b\");\n+  ASSERT_EQ(IterStatus(iter), \"(invalid)\");\n+\n+  delete iter;\n+}\n+\n+TEST(DBTest, IterMulti) {\n+  ASSERT_OK(Put(\"a\", \"va\"));\n+  ASSERT_OK(Put(\"b\", \"vb\"));\n+  ASSERT_OK(Put(\"c\", \"vc\"));\n+  Iterator* iter = db_->NewIterator(ReadOptions());\n+\n+  iter->SeekToFirst();\n+  ASSERT_EQ(IterStatus(iter), \"a->va\");\n+  iter->Next();\n+  ASSERT_EQ(IterStatus(iter), \"b->vb\");\n+  iter->Next();\n+  ASSERT_EQ(IterStatus(iter), \"c->vc\");\n+  iter->Next();\n+  ASSERT_EQ(IterStatus(iter), \"(invalid)\");\n+  iter->SeekToFirst();\n+  ASSERT_EQ(IterStatus(iter), \"a->va\");\n+  iter->Prev();\n+  ASSERT_EQ(IterStatus(iter), \"(invalid)\");\n+\n+  iter->SeekToLast();\n+  ASSERT_EQ(IterStatus(iter), \"c->vc\");\n+  iter->Prev();\n+  ASSERT_EQ(IterStatus(iter), \"b->vb\");\n+  iter->Prev();\n+  ASSERT_EQ(IterStatus(iter), \"a->va\");\n+  iter->Prev();\n+  ASSERT_EQ(IterStatus(iter), \"(invalid)\");\n+  iter->SeekToLast();\n+  ASSERT_EQ(IterStatus(iter), \"c->vc\");\n+  iter->Next();\n+  ASSERT_EQ(IterStatus(iter), \"(invalid)\");\n+\n+  iter->Seek(\"\");\n+  ASSERT_EQ(IterStatus(iter), \"a->va\");\n+  iter->Seek(\"a\");\n+  ASSERT_EQ(IterStatus(iter), \"a->va\");\n+  iter->Seek(\"ax\");\n+  ASSERT_EQ(IterStatus(iter), \"b->vb\");\n+  iter->Seek(\"b\");\n+  ASSERT_EQ(IterStatus(iter), \"b->vb\");\n+  iter->Seek(\"z\");\n+  ASSERT_EQ(IterStatus(iter), \"(invalid)\");\n+\n+  // Switch from reverse to forward\n+  iter->SeekToLast();\n+  iter->Prev();\n+  iter->Prev();\n+  iter->Next();\n+  ASSERT_EQ(IterStatus(iter), \"b->vb\");\n+\n+  // Switch from forward to reverse\n+  iter->SeekToFirst();\n+  iter->Next();\n+  iter->Next();\n+  iter->Prev();\n+  ASSERT_EQ(IterStatus(iter), \"b->vb\");\n+\n+  // Make sure iter stays at snapshot\n+  ASSERT_OK(Put(\"a\",  \"va2\"));\n+  ASSERT_OK(Put(\"a2\", \"va3\"));\n+  ASSERT_OK(Put(\"b\",  \"vb2\"));\n+  ASSERT_OK(Put(\"c\",  \"vc2\"));\n+  ASSERT_OK(Delete(\"b\"));\n+  iter->SeekToFirst();\n+  ASSERT_EQ(IterStatus(iter), \"a->va\");\n+  iter->Next();\n+  ASSERT_EQ(IterStatus(iter), \"b->vb\");\n+  iter->Next();\n+  ASSERT_EQ(IterStatus(iter), \"c->vc\");\n+  iter->Next();\n+  ASSERT_EQ(IterStatus(iter), \"(invalid)\");\n+  iter->SeekToLast();\n+  ASSERT_EQ(IterStatus(iter), \"c->vc\");\n+  iter->Prev();\n+  ASSERT_EQ(IterStatus(iter), \"b->vb\");\n+  iter->Prev();\n+  ASSERT_EQ(IterStatus(iter), \"a->va\");\n+  iter->Prev();\n+  ASSERT_EQ(IterStatus(iter), \"(invalid)\");\n+\n+  delete iter;\n+}\n+\n+TEST(DBTest, IterSmallAndLargeMix) {\n+  ASSERT_OK(Put(\"a\", \"va\"));\n+  ASSERT_OK(Put(\"b\", std::string(100000, 'b')));\n+  ASSERT_OK(Put(\"c\", \"vc\"));\n+  ASSERT_OK(Put(\"d\", std::string(100000, 'd')));\n+  ASSERT_OK(Put(\"e\", std::string(100000, 'e')));\n+\n+  Iterator* iter = db_->NewIterator(ReadOptions());\n+\n+  iter->SeekToFirst();\n+  ASSERT_EQ(IterStatus(iter), \"a->va\");\n+  iter->Next();\n+  ASSERT_EQ(IterStatus(iter), \"b->\" + std::string(100000, 'b'));\n+  iter->Next();\n+  ASSERT_EQ(IterStatus(iter), \"c->vc\");\n+  iter->Next();\n+  ASSERT_EQ(IterStatus(iter), \"d->\" + std::string(100000, 'd'));\n+  iter->Next();\n+  ASSERT_EQ(IterStatus(iter), \"e->\" + std::string(100000, 'e'));\n+  iter->Next();\n+  ASSERT_EQ(IterStatus(iter), \"(invalid)\");\n+\n+  iter->SeekToLast();\n+  ASSERT_EQ(IterStatus(iter), \"e->\" + std::string(100000, 'e'));\n+  iter->Prev();\n+  ASSERT_EQ(IterStatus(iter), \"d->\" + std::string(100000, 'd'));\n+  iter->Prev();\n+  ASSERT_EQ(IterStatus(iter), \"c->vc\");\n+  iter->Prev();\n+  ASSERT_EQ(IterStatus(iter), \"b->\" + std::string(100000, 'b'));\n+  iter->Prev();\n+  ASSERT_EQ(IterStatus(iter), \"a->va\");\n+  iter->Prev();\n+  ASSERT_EQ(IterStatus(iter), \"(invalid)\");\n+\n+  delete iter;\n+}\n+\n+TEST(DBTest, IterMultiWithDelete) {\n+  do {\n+    ASSERT_OK(Put(\"a\", \"va\"));\n+    ASSERT_OK(Put(\"b\", \"vb\"));\n+    ASSERT_OK(Put(\"c\", \"vc\"));\n+    ASSERT_OK(Delete(\"b\"));\n+    ASSERT_EQ(\"NOT_FOUND\", Get(\"b\"));\n+\n+    Iterator* iter = db_->NewIterator(ReadOptions());\n+    iter->Seek(\"c\");\n+    ASSERT_EQ(IterStatus(iter), \"c->vc\");\n+    iter->Prev();\n+    ASSERT_EQ(IterStatus(iter), \"a->va\");\n+    delete iter;\n+  } while (ChangeOptions());\n+}\n+\n+TEST(DBTest, Recover) {\n+  do {\n+    ASSERT_OK(Put(\"foo\", \"v1\"));\n+    ASSERT_OK(Put(\"baz\", \"v5\"));\n+\n+    Reopen();\n+    ASSERT_EQ(\"v1\", Get(\"foo\"));\n+\n+    ASSERT_EQ(\"v1\", Get(\"foo\"));\n+    ASSERT_EQ(\"v5\", Get(\"baz\"));\n+    ASSERT_OK(Put(\"bar\", \"v2\"));\n+    ASSERT_OK(Put(\"foo\", \"v3\"));\n+\n+    Reopen();\n+    ASSERT_EQ(\"v3\", Get(\"foo\"));\n+    ASSERT_OK(Put(\"foo\", \"v4\"));\n+    ASSERT_EQ(\"v4\", Get(\"foo\"));\n+    ASSERT_EQ(\"v2\", Get(\"bar\"));\n+    ASSERT_EQ(\"v5\", Get(\"baz\"));\n+  } while (ChangeOptions());\n+}\n+\n+TEST(DBTest, RecoveryWithEmptyLog) {\n+  do {\n+    ASSERT_OK(Put(\"foo\", \"v1\"));\n+    ASSERT_OK(Put(\"foo\", \"v2\"));\n+    Reopen();\n+    Reopen();\n+    ASSERT_OK(Put(\"foo\", \"v3\"));\n+    Reopen();\n+    ASSERT_EQ(\"v3\", Get(\"foo\"));\n+  } while (ChangeOptions());\n+}\n+\n+// Check that writes done during a memtable compaction are recovered\n+// if the database is shutdown during the memtable compaction.\n+TEST(DBTest, RecoverDuringMemtableCompaction) {\n+  do {\n+    Options options = CurrentOptions();\n+    options.env = env_;\n+    options.write_buffer_size = 1000000;\n+    Reopen(&options);\n+\n+    // Trigger a long memtable compaction and reopen the database during it\n+    ASSERT_OK(Put(\"foo\", \"v1\"));                         // Goes to 1st log file\n+    ASSERT_OK(Put(\"big1\", std::string(10000000, 'x')));  // Fills memtable\n+    ASSERT_OK(Put(\"big2\", std::string(1000, 'y')));      // Triggers compaction\n+    ASSERT_OK(Put(\"bar\", \"v2\"));                         // Goes to new log file\n+\n+    Reopen(&options);\n+    ASSERT_EQ(\"v1\", Get(\"foo\"));\n+    ASSERT_EQ(\"v2\", Get(\"bar\"));\n+    ASSERT_EQ(std::string(10000000, 'x'), Get(\"big1\"));\n+    ASSERT_EQ(std::string(1000, 'y'), Get(\"big2\"));\n+  } while (ChangeOptions());\n+}\n+\n+static std::string Key(int i) {\n+  char buf[100];\n+  snprintf(buf, sizeof(buf), \"key%06d\", i);\n+  return std::string(buf);\n+}\n+\n+TEST(DBTest, MinorCompactionsHappen) {\n+  Options options = CurrentOptions();\n+  options.write_buffer_size = 10000;\n+  Reopen(&options);\n+\n+  const int N = 500;\n+\n+  int starting_num_tables = TotalTableFiles();\n+  for (int i = 0; i < N; i++) {\n+    ASSERT_OK(Put(Key(i), Key(i) + std::string(1000, 'v')));\n+  }\n+  int ending_num_tables = TotalTableFiles();\n+  ASSERT_GT(ending_num_tables, starting_num_tables);\n+\n+  for (int i = 0; i < N; i++) {\n+    ASSERT_EQ(Key(i) + std::string(1000, 'v'), Get(Key(i)));\n+  }\n+\n+  Reopen();\n+\n+  for (int i = 0; i < N; i++) {\n+    ASSERT_EQ(Key(i) + std::string(1000, 'v'), Get(Key(i)));\n+  }\n+}\n+\n+TEST(DBTest, RecoverWithLargeLog) {\n+  {\n+    Options options = CurrentOptions();\n+    Reopen(&options);\n+    ASSERT_OK(Put(\"big1\", std::string(200000, '1')));\n+    ASSERT_OK(Put(\"big2\", std::string(200000, '2')));\n+    ASSERT_OK(Put(\"small3\", std::string(10, '3')));\n+    ASSERT_OK(Put(\"small4\", std::string(10, '4')));\n+    ASSERT_EQ(NumTableFilesAtLevel(0), 0);\n+  }\n+\n+  // Make sure that if we re-open with a small write buffer size that\n+  // we flush table files in the middle of a large log file.\n+  Options options = CurrentOptions();\n+  options.write_buffer_size = 100000;\n+  Reopen(&options);\n+  ASSERT_EQ(NumTableFilesAtLevel(0), 3);\n+  ASSERT_EQ(std::string(200000, '1'), Get(\"big1\"));\n+  ASSERT_EQ(std::string(200000, '2'), Get(\"big2\"));\n+  ASSERT_EQ(std::string(10, '3'), Get(\"small3\"));\n+  ASSERT_EQ(std::string(10, '4'), Get(\"small4\"));\n+  ASSERT_GT(NumTableFilesAtLevel(0), 1);\n+}\n+\n+TEST(DBTest, CompactionsGenerateMultipleFiles) {\n+  Options options = CurrentOptions();\n+  options.write_buffer_size = 100000000;        // Large write buffer\n+  Reopen(&options);\n+\n+  Random rnd(301);\n+\n+  // Write 8MB (80 values, each 100K)\n+  ASSERT_EQ(NumTableFilesAtLevel(0), 0);\n+  std::vector<std::string> values;\n+  for (int i = 0; i < 80; i++) {\n+    values.push_back(RandomString(&rnd, 100000));\n+    ASSERT_OK(Put(Key(i), values[i]));\n+  }\n+\n+  // Reopening moves updates to level-0\n+  Reopen(&options);\n+  dbfull()->TEST_CompactRange(0, NULL, NULL);\n+\n+  ASSERT_EQ(NumTableFilesAtLevel(0), 0);\n+  ASSERT_GT(NumTableFilesAtLevel(1), 1);\n+  for (int i = 0; i < 80; i++) {\n+    ASSERT_EQ(Get(Key(i)), values[i]);\n+  }\n+}\n+\n+TEST(DBTest, RepeatedWritesToSameKey) {\n+  Options options = CurrentOptions();\n+  options.env = env_;\n+  options.write_buffer_size = 100000;  // Small write buffer\n+  Reopen(&options);\n+\n+  // We must have at most one file per level except for level-0,\n+  // which may have up to kL0_StopWritesTrigger files.\n+  const int kMaxFiles = config::kNumLevels + config::kL0_StopWritesTrigger;\n+\n+  Random rnd(301);\n+  std::string value = RandomString(&rnd, 2 * options.write_buffer_size);\n+  for (int i = 0; i < 5 * kMaxFiles; i++) {\n+    Put(\"key\", value);\n+    ASSERT_LE(TotalTableFiles(), kMaxFiles);\n+    fprintf(stderr, \"after %d: %d files\\n\", int(i+1), TotalTableFiles());\n+  }\n+}\n+\n+TEST(DBTest, SparseMerge) {\n+  Options options = CurrentOptions();\n+  options.compression = kNoCompression;\n+  Reopen(&options);\n+\n+  FillLevels(\"A\", \"Z\");\n+\n+  // Suppose there is:\n+  //    small amount of data with prefix A\n+  //    large amount of data with prefix B\n+  //    small amount of data with prefix C\n+  // and that recent updates have made small changes to all three prefixes.\n+  // Check that we do not do a compaction that merges all of B in one shot.\n+  const std::string value(1000, 'x');\n+  Put(\"A\", \"va\");\n+  // Write approximately 100MB of \"B\" values\n+  for (int i = 0; i < 100000; i++) {\n+    char key[100];\n+    snprintf(key, sizeof(key), \"B%010d\", i);\n+    Put(key, value);\n+  }\n+  Put(\"C\", \"vc\");\n+  dbfull()->TEST_CompactMemTable();\n+  dbfull()->TEST_CompactRange(0, NULL, NULL);\n+\n+  // Make sparse update\n+  Put(\"A\",    \"va2\");\n+  Put(\"B100\", \"bvalue2\");\n+  Put(\"C\",    \"vc2\");\n+  dbfull()->TEST_CompactMemTable();\n+\n+  // Compactions should not cause us to create a situation where\n+  // a file overlaps too much data at the next level.\n+  ASSERT_LE(dbfull()->TEST_MaxNextLevelOverlappingBytes(), 20*1048576);\n+  dbfull()->TEST_CompactRange(0, NULL, NULL);\n+  ASSERT_LE(dbfull()->TEST_MaxNextLevelOverlappingBytes(), 20*1048576);\n+  dbfull()->TEST_CompactRange(1, NULL, NULL);\n+  ASSERT_LE(dbfull()->TEST_MaxNextLevelOverlappingBytes(), 20*1048576);\n+}\n+\n+static bool Between(uint64_t val, uint64_t low, uint64_t high) {\n+  bool result = (val >= low) && (val <= high);\n+  if (!result) {\n+    fprintf(stderr, \"Value %llu is not in range [%llu, %llu]\\n\",\n+            (unsigned long long)(val),\n+            (unsigned long long)(low),\n+            (unsigned long long)(high));\n+  }\n+  return result;\n+}\n+\n+TEST(DBTest, ApproximateSizes) {\n+  do {\n+    Options options = CurrentOptions();\n+    options.write_buffer_size = 100000000;        // Large write buffer\n+    options.compression = kNoCompression;\n+    DestroyAndReopen();\n+\n+    ASSERT_TRUE(Between(Size(\"\", \"xyz\"), 0, 0));\n+    Reopen(&options);\n+    ASSERT_TRUE(Between(Size(\"\", \"xyz\"), 0, 0));\n+\n+    // Write 8MB (80 values, each 100K)\n+    ASSERT_EQ(NumTableFilesAtLevel(0), 0);\n+    const int N = 80;\n+    static const int S1 = 100000;\n+    static const int S2 = 105000;  // Allow some expansion from metadata\n+    Random rnd(301);\n+    for (int i = 0; i < N; i++) {\n+      ASSERT_OK(Put(Key(i), RandomString(&rnd, S1)));\n+    }\n+\n+    // 0 because GetApproximateSizes() does not account for memtable space\n+    ASSERT_TRUE(Between(Size(\"\", Key(50)), 0, 0));\n+\n+    // Check sizes across recovery by reopening a few times\n+    for (int run = 0; run < 3; run++) {\n+      Reopen(&options);\n+\n+      for (int compact_start = 0; compact_start < N; compact_start += 10) {\n+        for (int i = 0; i < N; i += 10) {\n+          ASSERT_TRUE(Between(Size(\"\", Key(i)), S1*i, S2*i));\n+          ASSERT_TRUE(Between(Size(\"\", Key(i)+\".suffix\"), S1*(i+1), S2*(i+1)));\n+          ASSERT_TRUE(Between(Size(Key(i), Key(i+10)), S1*10, S2*10));\n+        }\n+        ASSERT_TRUE(Between(Size(\"\", Key(50)), S1*50, S2*50));\n+        ASSERT_TRUE(Between(Size(\"\", Key(50)+\".suffix\"), S1*50, S2*50));\n+\n+        std::string cstart_str = Key(compact_start);\n+        std::string cend_str = Key(compact_start + 9);\n+        Slice cstart = cstart_str;\n+        Slice cend = cend_str;\n+        dbfull()->TEST_CompactRange(0, &cstart, &cend);\n+      }\n+\n+      ASSERT_EQ(NumTableFilesAtLevel(0), 0);\n+      ASSERT_GT(NumTableFilesAtLevel(1), 0);\n+    }\n+  } while (ChangeOptions());\n+}\n+\n+TEST(DBTest, ApproximateSizes_MixOfSmallAndLarge) {\n+  do {\n+    Options options = CurrentOptions();\n+    options.compression = kNoCompression;\n+    Reopen();\n+\n+    Random rnd(301);\n+    std::string big1 = RandomString(&rnd, 100000);\n+    ASSERT_OK(Put(Key(0), RandomString(&rnd, 10000)));\n+    ASSERT_OK(Put(Key(1), RandomString(&rnd, 10000)));\n+    ASSERT_OK(Put(Key(2), big1));\n+    ASSERT_OK(Put(Key(3), RandomString(&rnd, 10000)));\n+    ASSERT_OK(Put(Key(4), big1));\n+    ASSERT_OK(Put(Key(5), RandomString(&rnd, 10000)));\n+    ASSERT_OK(Put(Key(6), RandomString(&rnd, 300000)));\n+    ASSERT_OK(Put(Key(7), RandomString(&rnd, 10000)));\n+\n+    // Check sizes across recovery by reopening a few times\n+    for (int run = 0; run < 3; run++) {\n+      Reopen(&options);\n+\n+      ASSERT_TRUE(Between(Size(\"\", Key(0)), 0, 0));\n+      ASSERT_TRUE(Between(Size(\"\", Key(1)), 10000, 11000));\n+      ASSERT_TRUE(Between(Size(\"\", Key(2)), 20000, 21000));\n+      ASSERT_TRUE(Between(Size(\"\", Key(3)), 120000, 121000));\n+      ASSERT_TRUE(Between(Size(\"\", Key(4)), 130000, 131000));\n+      ASSERT_TRUE(Between(Size(\"\", Key(5)), 230000, 231000));\n+      ASSERT_TRUE(Between(Size(\"\", Key(6)), 240000, 241000));\n+      ASSERT_TRUE(Between(Size(\"\", Key(7)), 540000, 541000));\n+      ASSERT_TRUE(Between(Size(\"\", Key(8)), 550000, 560000));\n+\n+      ASSERT_TRUE(Between(Size(Key(3), Key(5)), 110000, 111000));\n+\n+      dbfull()->TEST_CompactRange(0, NULL, NULL);\n+    }\n+  } while (ChangeOptions());\n+}\n+\n+TEST(DBTest, IteratorPinsRef) {\n+  Put(\"foo\", \"hello\");\n+\n+  // Get iterator that will yield the current contents of the DB.\n+  Iterator* iter = db_->NewIterator(ReadOptions());\n+\n+  // Write to force compactions\n+  Put(\"foo\", \"newvalue1\");\n+  for (int i = 0; i < 100; i++) {\n+    ASSERT_OK(Put(Key(i), Key(i) + std::string(100000, 'v'))); // 100K values\n+  }\n+  Put(\"foo\", \"newvalue2\");\n+\n+  iter->SeekToFirst();\n+  ASSERT_TRUE(iter->Valid());\n+  ASSERT_EQ(\"foo\", iter->key().ToString());\n+  ASSERT_EQ(\"hello\", iter->value().ToString());\n+  iter->Next();\n+  ASSERT_TRUE(!iter->Valid());\n+  delete iter;\n+}\n+\n+TEST(DBTest, Snapshot) {\n+  do {\n+    Put(\"foo\", \"v1\");\n+    const Snapshot* s1 = db_->GetSnapshot();\n+    Put(\"foo\", \"v2\");\n+    const Snapshot* s2 = db_->GetSnapshot();\n+    Put(\"foo\", \"v3\");\n+    const Snapshot* s3 = db_->GetSnapshot();\n+\n+    Put(\"foo\", \"v4\");\n+    ASSERT_EQ(\"v1\", Get(\"foo\", s1));\n+    ASSERT_EQ(\"v2\", Get(\"foo\", s2));\n+    ASSERT_EQ(\"v3\", Get(\"foo\", s3));\n+    ASSERT_EQ(\"v4\", Get(\"foo\"));\n+\n+    db_->ReleaseSnapshot(s3);\n+    ASSERT_EQ(\"v1\", Get(\"foo\", s1));\n+    ASSERT_EQ(\"v2\", Get(\"foo\", s2));\n+    ASSERT_EQ(\"v4\", Get(\"foo\"));\n+\n+    db_->ReleaseSnapshot(s1);\n+    ASSERT_EQ(\"v2\", Get(\"foo\", s2));\n+    ASSERT_EQ(\"v4\", Get(\"foo\"));\n+\n+    db_->ReleaseSnapshot(s2);\n+    ASSERT_EQ(\"v4\", Get(\"foo\"));\n+  } while (ChangeOptions());\n+}\n+\n+TEST(DBTest, HiddenValuesAreRemoved) {\n+  do {\n+    Random rnd(301);\n+    FillLevels(\"a\", \"z\");\n+\n+    std::string big = RandomString(&rnd, 50000);\n+    Put(\"foo\", big);\n+    Put(\"pastfoo\", \"v\");\n+    const Snapshot* snapshot = db_->GetSnapshot();\n+    Put(\"foo\", \"tiny\");\n+    Put(\"pastfoo2\", \"v2\");        // Advance sequence number one more\n+\n+    ASSERT_OK(dbfull()->TEST_CompactMemTable());\n+    ASSERT_GT(NumTableFilesAtLevel(0), 0);\n+\n+    ASSERT_EQ(big, Get(\"foo\", snapshot));\n+    ASSERT_TRUE(Between(Size(\"\", \"pastfoo\"), 50000, 60000));\n+    db_->ReleaseSnapshot(snapshot);\n+    ASSERT_EQ(AllEntriesFor(\"foo\"), \"[ tiny, \" + big + \" ]\");\n+    Slice x(\"x\");\n+    dbfull()->TEST_CompactRange(0, NULL, &x);\n+    ASSERT_EQ(AllEntriesFor(\"foo\"), \"[ tiny ]\");\n+    ASSERT_EQ(NumTableFilesAtLevel(0), 0);\n+    ASSERT_GE(NumTableFilesAtLevel(1), 1);\n+    dbfull()->TEST_CompactRange(1, NULL, &x);\n+    ASSERT_EQ(AllEntriesFor(\"foo\"), \"[ tiny ]\");\n+\n+    ASSERT_TRUE(Between(Size(\"\", \"pastfoo\"), 0, 1000));\n+  } while (ChangeOptions());\n+}\n+\n+TEST(DBTest, DeletionMarkers1) {\n+  Put(\"foo\", \"v1\");\n+  ASSERT_OK(dbfull()->TEST_CompactMemTable());\n+  const int last = config::kMaxMemCompactLevel;\n+  ASSERT_EQ(NumTableFilesAtLevel(last), 1);   // foo => v1 is now in last level\n+\n+  // Place a table at level last-1 to prevent merging with preceding mutation\n+  Put(\"a\", \"begin\");\n+  Put(\"z\", \"end\");\n+  dbfull()->TEST_CompactMemTable();\n+  ASSERT_EQ(NumTableFilesAtLevel(last), 1);\n+  ASSERT_EQ(NumTableFilesAtLevel(last-1), 1);\n+\n+  Delete(\"foo\");\n+  Put(\"foo\", \"v2\");\n+  ASSERT_EQ(AllEntriesFor(\"foo\"), \"[ v2, DEL, v1 ]\");\n+  ASSERT_OK(dbfull()->TEST_CompactMemTable());  // Moves to level last-2\n+  ASSERT_EQ(AllEntriesFor(\"foo\"), \"[ v2, DEL, v1 ]\");\n+  Slice z(\"z\");\n+  dbfull()->TEST_CompactRange(last-2, NULL, &z);\n+  // DEL eliminated, but v1 remains because we aren't compacting that level\n+  // (DEL can be eliminated because v2 hides v1).\n+  ASSERT_EQ(AllEntriesFor(\"foo\"), \"[ v2, v1 ]\");\n+  dbfull()->TEST_CompactRange(last-1, NULL, NULL);\n+  // Merging last-1 w/ last, so we are the base level for \"foo\", so\n+  // DEL is removed.  (as is v1).\n+  ASSERT_EQ(AllEntriesFor(\"foo\"), \"[ v2 ]\");\n+}\n+\n+TEST(DBTest, DeletionMarkers2) {\n+  Put(\"foo\", \"v1\");\n+  ASSERT_OK(dbfull()->TEST_CompactMemTable());\n+  const int last = config::kMaxMemCompactLevel;\n+  ASSERT_EQ(NumTableFilesAtLevel(last), 1);   // foo => v1 is now in last level\n+\n+  // Place a table at level last-1 to prevent merging with preceding mutation\n+  Put(\"a\", \"begin\");\n+  Put(\"z\", \"end\");\n+  dbfull()->TEST_CompactMemTable();\n+  ASSERT_EQ(NumTableFilesAtLevel(last), 1);\n+  ASSERT_EQ(NumTableFilesAtLevel(last-1), 1);\n+\n+  Delete(\"foo\");\n+  ASSERT_EQ(AllEntriesFor(\"foo\"), \"[ DEL, v1 ]\");\n+  ASSERT_OK(dbfull()->TEST_CompactMemTable());  // Moves to level last-2\n+  ASSERT_EQ(AllEntriesFor(\"foo\"), \"[ DEL, v1 ]\");\n+  dbfull()->TEST_CompactRange(last-2, NULL, NULL);\n+  // DEL kept: \"last\" file overlaps\n+  ASSERT_EQ(AllEntriesFor(\"foo\"), \"[ DEL, v1 ]\");\n+  dbfull()->TEST_CompactRange(last-1, NULL, NULL);\n+  // Merging last-1 w/ last, so we are the base level for \"foo\", so\n+  // DEL is removed.  (as is v1).\n+  ASSERT_EQ(AllEntriesFor(\"foo\"), \"[ ]\");\n+}\n+\n+TEST(DBTest, OverlapInLevel0) {\n+  do {\n+    ASSERT_EQ(config::kMaxMemCompactLevel, 2) << \"Fix test to match config\";\n+\n+    // Fill levels 1 and 2 to disable the pushing of new memtables to levels > 0.\n+    ASSERT_OK(Put(\"100\", \"v100\"));\n+    ASSERT_OK(Put(\"999\", \"v999\"));\n+    dbfull()->TEST_CompactMemTable();\n+    ASSERT_OK(Delete(\"100\"));\n+    ASSERT_OK(Delete(\"999\"));\n+    dbfull()->TEST_CompactMemTable();\n+    ASSERT_EQ(\"0,1,1\", FilesPerLevel());\n+\n+    // Make files spanning the following ranges in level-0:\n+    //  files[0]  200 .. 900\n+    //  files[1]  300 .. 500\n+    // Note that files are sorted by smallest key.\n+    ASSERT_OK(Put(\"300\", \"v300\"));\n+    ASSERT_OK(Put(\"500\", \"v500\"));\n+    dbfull()->TEST_CompactMemTable();\n+    ASSERT_OK(Put(\"200\", \"v200\"));\n+    ASSERT_OK(Put(\"600\", \"v600\"));\n+    ASSERT_OK(Put(\"900\", \"v900\"));\n+    dbfull()->TEST_CompactMemTable();\n+    ASSERT_EQ(\"2,1,1\", FilesPerLevel());\n+\n+    // Compact away the placeholder files we created initially\n+    dbfull()->TEST_CompactRange(1, NULL, NULL);\n+    dbfull()->TEST_CompactRange(2, NULL, NULL);\n+    ASSERT_EQ(\"2\", FilesPerLevel());\n+\n+    // Do a memtable compaction.  Before bug-fix, the compaction would\n+    // not detect the overlap with level-0 files and would incorrectly place\n+    // the deletion in a deeper level.\n+    ASSERT_OK(Delete(\"600\"));\n+    dbfull()->TEST_CompactMemTable();\n+    ASSERT_EQ(\"3\", FilesPerLevel());\n+    ASSERT_EQ(\"NOT_FOUND\", Get(\"600\"));\n+  } while (ChangeOptions());\n+}\n+\n+TEST(DBTest, L0_CompactionBug_Issue44_a) {\n+  Reopen();\n+  ASSERT_OK(Put(\"b\", \"v\"));\n+  Reopen();\n+  ASSERT_OK(Delete(\"b\"));\n+  ASSERT_OK(Delete(\"a\"));\n+  Reopen();\n+  ASSERT_OK(Delete(\"a\"));\n+  Reopen();\n+  ASSERT_OK(Put(\"a\", \"v\"));\n+  Reopen();\n+  Reopen();\n+  ASSERT_EQ(\"(a->v)\", Contents());\n+  env_->SleepForMicroseconds(1000000);  // Wait for compaction to finish\n+  ASSERT_EQ(\"(a->v)\", Contents());\n+}\n+\n+TEST(DBTest, L0_CompactionBug_Issue44_b) {\n+  Reopen();\n+  Put(\"\",\"\");\n+  Reopen();\n+  Delete(\"e\");\n+  Put(\"\",\"\");\n+  Reopen();\n+  Put(\"c\", \"cv\");\n+  Reopen();\n+  Put(\"\",\"\");\n+  Reopen();\n+  Put(\"\",\"\");\n+  env_->SleepForMicroseconds(1000000);  // Wait for compaction to finish\n+  Reopen();\n+  Put(\"d\",\"dv\");\n+  Reopen();\n+  Put(\"\",\"\");\n+  Reopen();\n+  Delete(\"d\");\n+  Delete(\"b\");\n+  Reopen();\n+  ASSERT_EQ(\"(->)(c->cv)\", Contents());\n+  env_->SleepForMicroseconds(1000000);  // Wait for compaction to finish\n+  ASSERT_EQ(\"(->)(c->cv)\", Contents());\n+}\n+\n+TEST(DBTest, ComparatorCheck) {\n+  class NewComparator : public Comparator {\n+   public:\n+    virtual const char* Name() const { return \"leveldb.NewComparator\"; }\n+    virtual int Compare(const Slice& a, const Slice& b) const {\n+      return BytewiseComparator()->Compare(a, b);\n+    }\n+    virtual void FindShortestSeparator(std::string* s, const Slice& l) const {\n+      BytewiseComparator()->FindShortestSeparator(s, l);\n+    }\n+    virtual void FindShortSuccessor(std::string* key) const {\n+      BytewiseComparator()->FindShortSuccessor(key);\n+    }\n+  };\n+  NewComparator cmp;\n+  Options new_options = CurrentOptions();\n+  new_options.comparator = &cmp;\n+  Status s = TryReopen(&new_options);\n+  ASSERT_TRUE(!s.ok());\n+  ASSERT_TRUE(s.ToString().find(\"comparator\") != std::string::npos)\n+      << s.ToString();\n+}\n+\n+TEST(DBTest, CustomComparator) {\n+  class NumberComparator : public Comparator {\n+   public:\n+    virtual const char* Name() const { return \"test.NumberComparator\"; }\n+    virtual int Compare(const Slice& a, const Slice& b) const {\n+      return ToNumber(a) - ToNumber(b);\n+    }\n+    virtual void FindShortestSeparator(std::string* s, const Slice& l) const {\n+      ToNumber(*s);     // Check format\n+      ToNumber(l);      // Check format\n+    }\n+    virtual void FindShortSuccessor(std::string* key) const {\n+      ToNumber(*key);   // Check format\n+    }\n+   private:\n+    static int ToNumber(const Slice& x) {\n+      // Check that there are no extra characters.\n+      ASSERT_TRUE(x.size() >= 2 && x[0] == '[' && x[x.size()-1] == ']')\n+          << EscapeString(x);\n+      int val;\n+      char ignored;\n+      ASSERT_TRUE(sscanf(x.ToString().c_str(), \"[%i]%c\", &val, &ignored) == 1)\n+          << EscapeString(x);\n+      return val;\n+    }\n+  };\n+  NumberComparator cmp;\n+  Options new_options = CurrentOptions();\n+  new_options.create_if_missing = true;\n+  new_options.comparator = &cmp;\n+  new_options.filter_policy = NULL;     // Cannot use bloom filters\n+  new_options.write_buffer_size = 1000;  // Compact more often\n+  DestroyAndReopen(&new_options);\n+  ASSERT_OK(Put(\"[10]\", \"ten\"));\n+  ASSERT_OK(Put(\"[0x14]\", \"twenty\"));\n+  for (int i = 0; i < 2; i++) {\n+    ASSERT_EQ(\"ten\", Get(\"[10]\"));\n+    ASSERT_EQ(\"ten\", Get(\"[0xa]\"));\n+    ASSERT_EQ(\"twenty\", Get(\"[20]\"));\n+    ASSERT_EQ(\"twenty\", Get(\"[0x14]\"));\n+    ASSERT_EQ(\"NOT_FOUND\", Get(\"[15]\"));\n+    ASSERT_EQ(\"NOT_FOUND\", Get(\"[0xf]\"));\n+    Compact(\"[0]\", \"[9999]\");\n+  }\n+\n+  for (int run = 0; run < 2; run++) {\n+    for (int i = 0; i < 1000; i++) {\n+      char buf[100];\n+      snprintf(buf, sizeof(buf), \"[%d]\", i*10);\n+      ASSERT_OK(Put(buf, buf));\n+    }\n+    Compact(\"[0]\", \"[1000000]\");\n+  }\n+}\n+\n+TEST(DBTest, ManualCompaction) {\n+  ASSERT_EQ(config::kMaxMemCompactLevel, 2)\n+      << \"Need to update this test to match kMaxMemCompactLevel\";\n+\n+  MakeTables(3, \"p\", \"q\");\n+  ASSERT_EQ(\"1,1,1\", FilesPerLevel());\n+\n+  // Compaction range falls before files\n+  Compact(\"\", \"c\");\n+  ASSERT_EQ(\"1,1,1\", FilesPerLevel());\n+\n+  // Compaction range falls after files\n+  Compact(\"r\", \"z\");\n+  ASSERT_EQ(\"1,1,1\", FilesPerLevel());\n+\n+  // Compaction range overlaps files\n+  Compact(\"p1\", \"p9\");\n+  ASSERT_EQ(\"0,0,1\", FilesPerLevel());\n+\n+  // Populate a different range\n+  MakeTables(3, \"c\", \"e\");\n+  ASSERT_EQ(\"1,1,2\", FilesPerLevel());\n+\n+  // Compact just the new range\n+  Compact(\"b\", \"f\");\n+  ASSERT_EQ(\"0,0,2\", FilesPerLevel());\n+\n+  // Compact all\n+  MakeTables(1, \"a\", \"z\");\n+  ASSERT_EQ(\"0,1,2\", FilesPerLevel());\n+  db_->CompactRange(NULL, NULL);\n+  ASSERT_EQ(\"0,0,1\", FilesPerLevel());\n+}\n+\n+TEST(DBTest, DBOpen_Options) {\n+  std::string dbname = test::TmpDir() + \"/db_options_test\";\n+  DestroyDB(dbname, Options());\n+\n+  // Does not exist, and create_if_missing == false: error\n+  DB* db = NULL;\n+  Options opts;\n+  opts.create_if_missing = false;\n+  Status s = DB::Open(opts, dbname, &db);\n+  ASSERT_TRUE(strstr(s.ToString().c_str(), \"does not exist\") != NULL);\n+  ASSERT_TRUE(db == NULL);\n+\n+  // Does not exist, and create_if_missing == true: OK\n+  opts.create_if_missing = true;\n+  s = DB::Open(opts, dbname, &db);\n+  ASSERT_OK(s);\n+  ASSERT_TRUE(db != NULL);\n+\n+  delete db;\n+  db = NULL;\n+\n+  // Does exist, and error_if_exists == true: error\n+  opts.create_if_missing = false;\n+  opts.error_if_exists = true;\n+  s = DB::Open(opts, dbname, &db);\n+  ASSERT_TRUE(strstr(s.ToString().c_str(), \"exists\") != NULL);\n+  ASSERT_TRUE(db == NULL);\n+\n+  // Does exist, and error_if_exists == false: OK\n+  opts.create_if_missing = true;\n+  opts.error_if_exists = false;\n+  s = DB::Open(opts, dbname, &db);\n+  ASSERT_OK(s);\n+  ASSERT_TRUE(db != NULL);\n+\n+  delete db;\n+  db = NULL;\n+}\n+\n+// Check that number of files does not grow when we are out of space\n+TEST(DBTest, NoSpace) {\n+  Options options = CurrentOptions();\n+  options.env = env_;\n+  Reopen(&options);\n+\n+  ASSERT_OK(Put(\"foo\", \"v1\"));\n+  ASSERT_EQ(\"v1\", Get(\"foo\"));\n+  Compact(\"a\", \"z\");\n+  const int num_files = CountFiles();\n+  env_->no_space_.Release_Store(env_);   // Force out-of-space errors\n+  env_->sleep_counter_.Reset();\n+  for (int i = 0; i < 5; i++) {\n+    for (int level = 0; level < config::kNumLevels-1; level++) {\n+      dbfull()->TEST_CompactRange(level, NULL, NULL);\n+    }\n+  }\n+  env_->no_space_.Release_Store(NULL);\n+  ASSERT_LT(CountFiles(), num_files + 3);\n+\n+  // Check that compaction attempts slept after errors\n+  ASSERT_GE(env_->sleep_counter_.Read(), 5);\n+}\n+\n+TEST(DBTest, NonWritableFileSystem) {\n+  Options options = CurrentOptions();\n+  options.write_buffer_size = 1000;\n+  options.env = env_;\n+  Reopen(&options);\n+  ASSERT_OK(Put(\"foo\", \"v1\"));\n+  env_->non_writable_.Release_Store(env_);  // Force errors for new files\n+  std::string big(100000, 'x');\n+  int errors = 0;\n+  for (int i = 0; i < 20; i++) {\n+    fprintf(stderr, \"iter %d; errors %d\\n\", i, errors);\n+    if (!Put(\"foo\", big).ok()) {\n+      errors++;\n+      env_->SleepForMicroseconds(100000);\n+    }\n+  }\n+  ASSERT_GT(errors, 0);\n+  env_->non_writable_.Release_Store(NULL);\n+}\n+\n+TEST(DBTest, FilesDeletedAfterCompaction) {\n+  ASSERT_OK(Put(\"foo\", \"v2\"));\n+  Compact(\"a\", \"z\");\n+  const int num_files = CountFiles();\n+  for (int i = 0; i < 10; i++) {\n+    ASSERT_OK(Put(\"foo\", \"v2\"));\n+    Compact(\"a\", \"z\");\n+  }\n+  ASSERT_EQ(CountFiles(), num_files);\n+}\n+\n+TEST(DBTest, BloomFilter) {\n+  env_->count_random_reads_ = true;\n+  Options options = CurrentOptions();\n+  options.env = env_;\n+  options.block_cache = NewLRUCache(0);  // Prevent cache hits\n+  options.filter_policy = NewBloomFilterPolicy(10);\n+  Reopen(&options);\n+\n+  // Populate multiple layers\n+  const int N = 10000;\n+  for (int i = 0; i < N; i++) {\n+    ASSERT_OK(Put(Key(i), Key(i)));\n+  }\n+  Compact(\"a\", \"z\");\n+  for (int i = 0; i < N; i += 100) {\n+    ASSERT_OK(Put(Key(i), Key(i)));\n+  }\n+  dbfull()->TEST_CompactMemTable();\n+\n+  // Prevent auto compactions triggered by seeks\n+  env_->delay_sstable_sync_.Release_Store(env_);\n+\n+  // Lookup present keys.  Should rarely read from small sstable.\n+  env_->random_read_counter_.Reset();\n+  for (int i = 0; i < N; i++) {\n+    ASSERT_EQ(Key(i), Get(Key(i)));\n+  }\n+  int reads = env_->random_read_counter_.Read();\n+  fprintf(stderr, \"%d present => %d reads\\n\", N, reads);\n+  ASSERT_GE(reads, N);\n+  ASSERT_LE(reads, N + 2*N/100);\n+\n+  // Lookup present keys.  Should rarely read from either sstable.\n+  env_->random_read_counter_.Reset();\n+  for (int i = 0; i < N; i++) {\n+    ASSERT_EQ(\"NOT_FOUND\", Get(Key(i) + \".missing\"));\n+  }\n+  reads = env_->random_read_counter_.Read();\n+  fprintf(stderr, \"%d missing => %d reads\\n\", N, reads);\n+  ASSERT_LE(reads, 3*N/100);\n+\n+  env_->delay_sstable_sync_.Release_Store(NULL);\n+  Close();\n+  delete options.block_cache;\n+  delete options.filter_policy;\n+}\n+\n+// Multi-threaded test:\n+namespace {\n+\n+static const int kNumThreads = 4;\n+static const int kTestSeconds = 10;\n+static const int kNumKeys = 1000;\n+\n+struct MTState {\n+  DBTest* test;\n+  port::AtomicPointer stop;\n+  port::AtomicPointer counter[kNumThreads];\n+  port::AtomicPointer thread_done[kNumThreads];\n+};\n+\n+struct MTThread {\n+  MTState* state;\n+  int id;\n+};\n+\n+static void MTThreadBody(void* arg) {\n+  MTThread* t = reinterpret_cast<MTThread*>(arg);\n+  int id = t->id;\n+  DB* db = t->state->test->db_;\n+  uintptr_t counter = 0;\n+  fprintf(stderr, \"... starting thread %d\\n\", id);\n+  Random rnd(1000 + id);\n+  std::string value;\n+  char valbuf[1500];\n+  while (t->state->stop.Acquire_Load() == NULL) {\n+    t->state->counter[id].Release_Store(reinterpret_cast<void*>(counter));\n+\n+    int key = rnd.Uniform(kNumKeys);\n+    char keybuf[20];\n+    snprintf(keybuf, sizeof(keybuf), \"%016d\", key);\n+\n+    if (rnd.OneIn(2)) {\n+      // Write values of the form <key, my id, counter>.\n+      // We add some padding for force compactions.\n+      snprintf(valbuf, sizeof(valbuf), \"%d.%d.%-1000d\",\n+               key, id, static_cast<int>(counter));\n+      ASSERT_OK(db->Put(WriteOptions(), Slice(keybuf), Slice(valbuf)));\n+    } else {\n+      // Read a value and verify that it matches the pattern written above.\n+      Status s = db->Get(ReadOptions(), Slice(keybuf), &value);\n+      if (s.IsNotFound()) {\n+        // Key has not yet been written\n+      } else {\n+        // Check that the writer thread counter is >= the counter in the value\n+        ASSERT_OK(s);\n+        int k, w, c;\n+        ASSERT_EQ(3, sscanf(value.c_str(), \"%d.%d.%d\", &k, &w, &c)) << value;\n+        ASSERT_EQ(k, key);\n+        ASSERT_GE(w, 0);\n+        ASSERT_LT(w, kNumThreads);\n+        ASSERT_LE(c, reinterpret_cast<uintptr_t>(\n+            t->state->counter[w].Acquire_Load()));\n+      }\n+    }\n+    counter++;\n+  }\n+  t->state->thread_done[id].Release_Store(t);\n+  fprintf(stderr, \"... stopping thread %d after %d ops\\n\", id, int(counter));\n+}\n+\n+}  // namespace\n+\n+TEST(DBTest, MultiThreaded) {\n+  do {\n+    // Initialize state\n+    MTState mt;\n+    mt.test = this;\n+    mt.stop.Release_Store(0);\n+    for (int id = 0; id < kNumThreads; id++) {\n+      mt.counter[id].Release_Store(0);\n+      mt.thread_done[id].Release_Store(0);\n+    }\n+\n+    // Start threads\n+    MTThread thread[kNumThreads];\n+    for (int id = 0; id < kNumThreads; id++) {\n+      thread[id].state = &mt;\n+      thread[id].id = id;\n+      env_->StartThread(MTThreadBody, &thread[id]);\n+    }\n+\n+    // Let them run for a while\n+    env_->SleepForMicroseconds(kTestSeconds * 1000000);\n+\n+    // Stop the threads and wait for them to finish\n+    mt.stop.Release_Store(&mt);\n+    for (int id = 0; id < kNumThreads; id++) {\n+      while (mt.thread_done[id].Acquire_Load() == NULL) {\n+        env_->SleepForMicroseconds(100000);\n+      }\n+    }\n+  } while (ChangeOptions());\n+}\n+\n+namespace {\n+typedef std::map<std::string, std::string> KVMap;\n+}\n+\n+class ModelDB: public DB {\n+ public:\n+  class ModelSnapshot : public Snapshot {\n+   public:\n+    KVMap map_;\n+  };\n+\n+  explicit ModelDB(const Options& options): options_(options) { }\n+  ~ModelDB() { }\n+  virtual Status Put(const WriteOptions& o, const Slice& k, const Slice& v) {\n+    return DB::Put(o, k, v);\n+  }\n+  virtual Status Delete(const WriteOptions& o, const Slice& key) {\n+    return DB::Delete(o, key);\n+  }\n+  virtual Status Get(const ReadOptions& options,\n+                     const Slice& key, std::string* value) {\n+    assert(false);      // Not implemented\n+    return Status::NotFound(key);\n+  }\n+  virtual Iterator* NewIterator(const ReadOptions& options) {\n+    if (options.snapshot == NULL) {\n+      KVMap* saved = new KVMap;\n+      *saved = map_;\n+      return new ModelIter(saved, true);\n+    } else {\n+      const KVMap* snapshot_state =\n+          &(reinterpret_cast<const ModelSnapshot*>(options.snapshot)->map_);\n+      return new ModelIter(snapshot_state, false);\n+    }\n+  }\n+  virtual const Snapshot* GetSnapshot() {\n+    ModelSnapshot* snapshot = new ModelSnapshot;\n+    snapshot->map_ = map_;\n+    return snapshot;\n+  }\n+\n+  virtual void ReleaseSnapshot(const Snapshot* snapshot) {\n+    delete reinterpret_cast<const ModelSnapshot*>(snapshot);\n+  }\n+  virtual Status Write(const WriteOptions& options, WriteBatch* batch) {\n+    class Handler : public WriteBatch::Handler {\n+     public:\n+      KVMap* map_;\n+      virtual void Put(const Slice& key, const Slice& value) {\n+        (*map_)[key.ToString()] = value.ToString();\n+      }\n+      virtual void Delete(const Slice& key) {\n+        map_->erase(key.ToString());\n+      }\n+    };\n+    Handler handler;\n+    handler.map_ = &map_;\n+    return batch->Iterate(&handler);\n+  }\n+\n+  virtual bool GetProperty(const Slice& property, std::string* value) {\n+    return false;\n+  }\n+  virtual void GetApproximateSizes(const Range* r, int n, uint64_t* sizes) {\n+    for (int i = 0; i < n; i++) {\n+      sizes[i] = 0;\n+    }\n+  }\n+  virtual void CompactRange(const Slice* start, const Slice* end) {\n+  }\n+\n+ private:\n+  class ModelIter: public Iterator {\n+   public:\n+    ModelIter(const KVMap* map, bool owned)\n+        : map_(map), owned_(owned), iter_(map_->end()) {\n+    }\n+    ~ModelIter() {\n+      if (owned_) delete map_;\n+    }\n+    virtual bool Valid() const { return iter_ != map_->end(); }\n+    virtual void SeekToFirst() { iter_ = map_->begin(); }\n+    virtual void SeekToLast() {\n+      if (map_->empty()) {\n+        iter_ = map_->end();\n+      } else {\n+        iter_ = map_->find(map_->rbegin()->first);\n+      }\n+    }\n+    virtual void Seek(const Slice& k) {\n+      iter_ = map_->lower_bound(k.ToString());\n+    }\n+    virtual void Next() { ++iter_; }\n+    virtual void Prev() { --iter_; }\n+    virtual Slice key() const { return iter_->first; }\n+    virtual Slice value() const { return iter_->second; }\n+    virtual Status status() const { return Status::OK(); }\n+   private:\n+    const KVMap* const map_;\n+    const bool owned_;  // Do we own map_\n+    KVMap::const_iterator iter_;\n+  };\n+  const Options options_;\n+  KVMap map_;\n+};\n+\n+static std::string RandomKey(Random* rnd) {\n+  int len = (rnd->OneIn(3)\n+             ? 1                // Short sometimes to encourage collisions\n+             : (rnd->OneIn(100) ? rnd->Skewed(10) : rnd->Uniform(10)));\n+  return test::RandomKey(rnd, len);\n+}\n+\n+static bool CompareIterators(int step,\n+                             DB* model,\n+                             DB* db,\n+                             const Snapshot* model_snap,\n+                             const Snapshot* db_snap) {\n+  ReadOptions options;\n+  options.snapshot = model_snap;\n+  Iterator* miter = model->NewIterator(options);\n+  options.snapshot = db_snap;\n+  Iterator* dbiter = db->NewIterator(options);\n+  bool ok = true;\n+  int count = 0;\n+  for (miter->SeekToFirst(), dbiter->SeekToFirst();\n+       ok && miter->Valid() && dbiter->Valid();\n+       miter->Next(), dbiter->Next()) {\n+    count++;\n+    if (miter->key().compare(dbiter->key()) != 0) {\n+      fprintf(stderr, \"step %d: Key mismatch: '%s' vs. '%s'\\n\",\n+              step,\n+              EscapeString(miter->key()).c_str(),\n+              EscapeString(dbiter->key()).c_str());\n+      ok = false;\n+      break;\n+    }\n+\n+    if (miter->value().compare(dbiter->value()) != 0) {\n+      fprintf(stderr, \"step %d: Value mismatch for key '%s': '%s' vs. '%s'\\n\",\n+              step,\n+              EscapeString(miter->key()).c_str(),\n+              EscapeString(miter->value()).c_str(),\n+              EscapeString(miter->value()).c_str());\n+      ok = false;\n+    }\n+  }\n+\n+  if (ok) {\n+    if (miter->Valid() != dbiter->Valid()) {\n+      fprintf(stderr, \"step %d: Mismatch at end of iterators: %d vs. %d\\n\",\n+              step, miter->Valid(), dbiter->Valid());\n+      ok = false;\n+    }\n+  }\n+  fprintf(stderr, \"%d entries compared: ok=%d\\n\", count, ok);\n+  delete miter;\n+  delete dbiter;\n+  return ok;\n+}\n+\n+TEST(DBTest, Randomized) {\n+  Random rnd(test::RandomSeed());\n+  do {\n+    ModelDB model(CurrentOptions());\n+    const int N = 10000;\n+    const Snapshot* model_snap = NULL;\n+    const Snapshot* db_snap = NULL;\n+    std::string k, v;\n+    for (int step = 0; step < N; step++) {\n+      if (step % 100 == 0) {\n+        fprintf(stderr, \"Step %d of %d\\n\", step, N);\n+      }\n+      // TODO(sanjay): Test Get() works\n+      int p = rnd.Uniform(100);\n+      if (p < 45) {                               // Put\n+        k = RandomKey(&rnd);\n+        v = RandomString(&rnd,\n+                         rnd.OneIn(20)\n+                         ? 100 + rnd.Uniform(100)\n+                         : rnd.Uniform(8));\n+        ASSERT_OK(model.Put(WriteOptions(), k, v));\n+        ASSERT_OK(db_->Put(WriteOptions(), k, v));\n+\n+      } else if (p < 90) {                        // Delete\n+        k = RandomKey(&rnd);\n+        ASSERT_OK(model.Delete(WriteOptions(), k));\n+        ASSERT_OK(db_->Delete(WriteOptions(), k));\n+\n+\n+      } else {                                    // Multi-element batch\n+        WriteBatch b;\n+        const int num = rnd.Uniform(8);\n+        for (int i = 0; i < num; i++) {\n+          if (i == 0 || !rnd.OneIn(10)) {\n+            k = RandomKey(&rnd);\n+          } else {\n+            // Periodically re-use the same key from the previous iter, so\n+            // we have multiple entries in the write batch for the same key\n+          }\n+          if (rnd.OneIn(2)) {\n+            v = RandomString(&rnd, rnd.Uniform(10));\n+            b.Put(k, v);\n+          } else {\n+            b.Delete(k);\n+          }\n+        }\n+        ASSERT_OK(model.Write(WriteOptions(), &b));\n+        ASSERT_OK(db_->Write(WriteOptions(), &b));\n+      }\n+\n+      if ((step % 100) == 0) {\n+        ASSERT_TRUE(CompareIterators(step, &model, db_, NULL, NULL));\n+        ASSERT_TRUE(CompareIterators(step, &model, db_, model_snap, db_snap));\n+        // Save a snapshot from each DB this time that we'll use next\n+        // time we compare things, to make sure the current state is\n+        // preserved with the snapshot\n+        if (model_snap != NULL) model.ReleaseSnapshot(model_snap);\n+        if (db_snap != NULL) db_->ReleaseSnapshot(db_snap);\n+\n+        Reopen();\n+        ASSERT_TRUE(CompareIterators(step, &model, db_, NULL, NULL));\n+\n+        model_snap = model.GetSnapshot();\n+        db_snap = db_->GetSnapshot();\n+      }\n+    }\n+    if (model_snap != NULL) model.ReleaseSnapshot(model_snap);\n+    if (db_snap != NULL) db_->ReleaseSnapshot(db_snap);\n+  } while (ChangeOptions());\n+}\n+\n+std::string MakeKey(unsigned int num) {\n+  char buf[30];\n+  snprintf(buf, sizeof(buf), \"%016u\", num);\n+  return std::string(buf);\n+}\n+\n+void BM_LogAndApply(int iters, int num_base_files) {\n+  std::string dbname = test::TmpDir() + \"/leveldb_test_benchmark\";\n+  DestroyDB(dbname, Options());\n+\n+  DB* db = NULL;\n+  Options opts;\n+  opts.create_if_missing = true;\n+  Status s = DB::Open(opts, dbname, &db);\n+  ASSERT_OK(s);\n+  ASSERT_TRUE(db != NULL);\n+\n+  delete db;\n+  db = NULL;\n+\n+  Env* env = Env::Default();\n+\n+  port::Mutex mu;\n+  MutexLock l(&mu);\n+\n+  InternalKeyComparator cmp(BytewiseComparator());\n+  Options options;\n+  VersionSet vset(dbname, &options, NULL, &cmp);\n+  ASSERT_OK(vset.Recover());\n+  VersionEdit vbase;\n+  uint64_t fnum = 1;\n+  for (int i = 0; i < num_base_files; i++) {\n+    InternalKey start(MakeKey(2*fnum), 1, kTypeValue);\n+    InternalKey limit(MakeKey(2*fnum+1), 1, kTypeDeletion);\n+    vbase.AddFile(2, fnum++, 1 /* file size */, start, limit);\n+  }\n+  ASSERT_OK(vset.LogAndApply(&vbase, &mu));\n+\n+  uint64_t start_micros = env->NowMicros();\n+\n+  for (int i = 0; i < iters; i++) {\n+    VersionEdit vedit;\n+    vedit.DeleteFile(2, fnum);\n+    InternalKey start(MakeKey(2*fnum), 1, kTypeValue);\n+    InternalKey limit(MakeKey(2*fnum+1), 1, kTypeDeletion);\n+    vedit.AddFile(2, fnum++, 1 /* file size */, start, limit);\n+    vset.LogAndApply(&vedit, &mu);\n+  }\n+  uint64_t stop_micros = env->NowMicros();\n+  unsigned int us = stop_micros - start_micros;\n+  char buf[16];\n+  snprintf(buf, sizeof(buf), \"%d\", num_base_files);\n+  fprintf(stderr,\n+          \"BM_LogAndApply/%-6s   %8d iters : %9u us (%7.0f us / iter)\\n\",\n+          buf, iters, us, ((float)us) / iters);\n+}\n+\n+}  // namespace leveldb\n+\n+int main(int argc, char** argv) {\n+  if (argc > 1 && std::string(argv[1]) == \"--benchmark\") {\n+    leveldb::BM_LogAndApply(1000, 1);\n+    leveldb::BM_LogAndApply(1000, 100);\n+    leveldb::BM_LogAndApply(1000, 10000);\n+    leveldb::BM_LogAndApply(100, 100000);\n+    return 0;\n+  }\n+\n+  return leveldb::test::RunAllTests();\n+}"
      },
      {
        "sha": "28e11b398d03bf855cc232030e406e90fa35c544",
        "filename": "src/leveldb/db/dbformat.cc",
        "status": "added",
        "additions": 140,
        "deletions": 0,
        "changes": 140,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/dbformat.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/dbformat.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/dbformat.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,140 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include <stdio.h>\n+#include \"db/dbformat.h\"\n+#include \"port/port.h\"\n+#include \"util/coding.h\"\n+\n+namespace leveldb {\n+\n+static uint64_t PackSequenceAndType(uint64_t seq, ValueType t) {\n+  assert(seq <= kMaxSequenceNumber);\n+  assert(t <= kValueTypeForSeek);\n+  return (seq << 8) | t;\n+}\n+\n+void AppendInternalKey(std::string* result, const ParsedInternalKey& key) {\n+  result->append(key.user_key.data(), key.user_key.size());\n+  PutFixed64(result, PackSequenceAndType(key.sequence, key.type));\n+}\n+\n+std::string ParsedInternalKey::DebugString() const {\n+  char buf[50];\n+  snprintf(buf, sizeof(buf), \"' @ %llu : %d\",\n+           (unsigned long long) sequence,\n+           int(type));\n+  std::string result = \"'\";\n+  result += user_key.ToString();\n+  result += buf;\n+  return result;\n+}\n+\n+std::string InternalKey::DebugString() const {\n+  std::string result;\n+  ParsedInternalKey parsed;\n+  if (ParseInternalKey(rep_, &parsed)) {\n+    result = parsed.DebugString();\n+  } else {\n+    result = \"(bad)\";\n+    result.append(EscapeString(rep_));\n+  }\n+  return result;\n+}\n+\n+const char* InternalKeyComparator::Name() const {\n+  return \"leveldb.InternalKeyComparator\";\n+}\n+\n+int InternalKeyComparator::Compare(const Slice& akey, const Slice& bkey) const {\n+  // Order by:\n+  //    increasing user key (according to user-supplied comparator)\n+  //    decreasing sequence number\n+  //    decreasing type (though sequence# should be enough to disambiguate)\n+  int r = user_comparator_->Compare(ExtractUserKey(akey), ExtractUserKey(bkey));\n+  if (r == 0) {\n+    const uint64_t anum = DecodeFixed64(akey.data() + akey.size() - 8);\n+    const uint64_t bnum = DecodeFixed64(bkey.data() + bkey.size() - 8);\n+    if (anum > bnum) {\n+      r = -1;\n+    } else if (anum < bnum) {\n+      r = +1;\n+    }\n+  }\n+  return r;\n+}\n+\n+void InternalKeyComparator::FindShortestSeparator(\n+      std::string* start,\n+      const Slice& limit) const {\n+  // Attempt to shorten the user portion of the key\n+  Slice user_start = ExtractUserKey(*start);\n+  Slice user_limit = ExtractUserKey(limit);\n+  std::string tmp(user_start.data(), user_start.size());\n+  user_comparator_->FindShortestSeparator(&tmp, user_limit);\n+  if (tmp.size() < user_start.size() &&\n+      user_comparator_->Compare(user_start, tmp) < 0) {\n+    // User key has become shorter physically, but larger logically.\n+    // Tack on the earliest possible number to the shortened user key.\n+    PutFixed64(&tmp, PackSequenceAndType(kMaxSequenceNumber,kValueTypeForSeek));\n+    assert(this->Compare(*start, tmp) < 0);\n+    assert(this->Compare(tmp, limit) < 0);\n+    start->swap(tmp);\n+  }\n+}\n+\n+void InternalKeyComparator::FindShortSuccessor(std::string* key) const {\n+  Slice user_key = ExtractUserKey(*key);\n+  std::string tmp(user_key.data(), user_key.size());\n+  user_comparator_->FindShortSuccessor(&tmp);\n+  if (tmp.size() < user_key.size() &&\n+      user_comparator_->Compare(user_key, tmp) < 0) {\n+    // User key has become shorter physically, but larger logically.\n+    // Tack on the earliest possible number to the shortened user key.\n+    PutFixed64(&tmp, PackSequenceAndType(kMaxSequenceNumber,kValueTypeForSeek));\n+    assert(this->Compare(*key, tmp) < 0);\n+    key->swap(tmp);\n+  }\n+}\n+\n+const char* InternalFilterPolicy::Name() const {\n+  return user_policy_->Name();\n+}\n+\n+void InternalFilterPolicy::CreateFilter(const Slice* keys, int n,\n+                                        std::string* dst) const {\n+  // We rely on the fact that the code in table.cc does not mind us\n+  // adjusting keys[].\n+  Slice* mkey = const_cast<Slice*>(keys);\n+  for (int i = 0; i < n; i++) {\n+    mkey[i] = ExtractUserKey(keys[i]);\n+    // TODO(sanjay): Suppress dups?\n+  }\n+  user_policy_->CreateFilter(keys, n, dst);\n+}\n+\n+bool InternalFilterPolicy::KeyMayMatch(const Slice& key, const Slice& f) const {\n+  return user_policy_->KeyMayMatch(ExtractUserKey(key), f);\n+}\n+\n+LookupKey::LookupKey(const Slice& user_key, SequenceNumber s) {\n+  size_t usize = user_key.size();\n+  size_t needed = usize + 13;  // A conservative estimate\n+  char* dst;\n+  if (needed <= sizeof(space_)) {\n+    dst = space_;\n+  } else {\n+    dst = new char[needed];\n+  }\n+  start_ = dst;\n+  dst = EncodeVarint32(dst, usize + 8);\n+  kstart_ = dst;\n+  memcpy(dst, user_key.data(), usize);\n+  dst += usize;\n+  EncodeFixed64(dst, PackSequenceAndType(s, kValueTypeForSeek));\n+  dst += 8;\n+  end_ = dst;\n+}\n+\n+}  // namespace leveldb"
      },
      {
        "sha": "f7f64dafb6d5b3d676ecde9d0fc86ab2942b2494",
        "filename": "src/leveldb/db/dbformat.h",
        "status": "added",
        "additions": 227,
        "deletions": 0,
        "changes": 227,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/dbformat.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/dbformat.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/dbformat.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,227 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#ifndef STORAGE_LEVELDB_DB_FORMAT_H_\n+#define STORAGE_LEVELDB_DB_FORMAT_H_\n+\n+#include <stdio.h>\n+#include \"leveldb/comparator.h\"\n+#include \"leveldb/db.h\"\n+#include \"leveldb/filter_policy.h\"\n+#include \"leveldb/slice.h\"\n+#include \"leveldb/table_builder.h\"\n+#include \"util/coding.h\"\n+#include \"util/logging.h\"\n+\n+namespace leveldb {\n+\n+// Grouping of constants.  We may want to make some of these\n+// parameters set via options.\n+namespace config {\n+static const int kNumLevels = 7;\n+\n+// Level-0 compaction is started when we hit this many files.\n+static const int kL0_CompactionTrigger = 4;\n+\n+// Soft limit on number of level-0 files.  We slow down writes at this point.\n+static const int kL0_SlowdownWritesTrigger = 8;\n+\n+// Maximum number of level-0 files.  We stop writes at this point.\n+static const int kL0_StopWritesTrigger = 12;\n+\n+// Maximum level to which a new compacted memtable is pushed if it\n+// does not create overlap.  We try to push to level 2 to avoid the\n+// relatively expensive level 0=>1 compactions and to avoid some\n+// expensive manifest file operations.  We do not push all the way to\n+// the largest level since that can generate a lot of wasted disk\n+// space if the same key space is being repeatedly overwritten.\n+static const int kMaxMemCompactLevel = 2;\n+\n+}  // namespace config\n+\n+class InternalKey;\n+\n+// Value types encoded as the last component of internal keys.\n+// DO NOT CHANGE THESE ENUM VALUES: they are embedded in the on-disk\n+// data structures.\n+enum ValueType {\n+  kTypeDeletion = 0x0,\n+  kTypeValue = 0x1\n+};\n+// kValueTypeForSeek defines the ValueType that should be passed when\n+// constructing a ParsedInternalKey object for seeking to a particular\n+// sequence number (since we sort sequence numbers in decreasing order\n+// and the value type is embedded as the low 8 bits in the sequence\n+// number in internal keys, we need to use the highest-numbered\n+// ValueType, not the lowest).\n+static const ValueType kValueTypeForSeek = kTypeValue;\n+\n+typedef uint64_t SequenceNumber;\n+\n+// We leave eight bits empty at the bottom so a type and sequence#\n+// can be packed together into 64-bits.\n+static const SequenceNumber kMaxSequenceNumber =\n+    ((0x1ull << 56) - 1);\n+\n+struct ParsedInternalKey {\n+  Slice user_key;\n+  SequenceNumber sequence;\n+  ValueType type;\n+\n+  ParsedInternalKey() { }  // Intentionally left uninitialized (for speed)\n+  ParsedInternalKey(const Slice& u, const SequenceNumber& seq, ValueType t)\n+      : user_key(u), sequence(seq), type(t) { }\n+  std::string DebugString() const;\n+};\n+\n+// Return the length of the encoding of \"key\".\n+inline size_t InternalKeyEncodingLength(const ParsedInternalKey& key) {\n+  return key.user_key.size() + 8;\n+}\n+\n+// Append the serialization of \"key\" to *result.\n+extern void AppendInternalKey(std::string* result,\n+                              const ParsedInternalKey& key);\n+\n+// Attempt to parse an internal key from \"internal_key\".  On success,\n+// stores the parsed data in \"*result\", and returns true.\n+//\n+// On error, returns false, leaves \"*result\" in an undefined state.\n+extern bool ParseInternalKey(const Slice& internal_key,\n+                             ParsedInternalKey* result);\n+\n+// Returns the user key portion of an internal key.\n+inline Slice ExtractUserKey(const Slice& internal_key) {\n+  assert(internal_key.size() >= 8);\n+  return Slice(internal_key.data(), internal_key.size() - 8);\n+}\n+\n+inline ValueType ExtractValueType(const Slice& internal_key) {\n+  assert(internal_key.size() >= 8);\n+  const size_t n = internal_key.size();\n+  uint64_t num = DecodeFixed64(internal_key.data() + n - 8);\n+  unsigned char c = num & 0xff;\n+  return static_cast<ValueType>(c);\n+}\n+\n+// A comparator for internal keys that uses a specified comparator for\n+// the user key portion and breaks ties by decreasing sequence number.\n+class InternalKeyComparator : public Comparator {\n+ private:\n+  const Comparator* user_comparator_;\n+ public:\n+  explicit InternalKeyComparator(const Comparator* c) : user_comparator_(c) { }\n+  virtual const char* Name() const;\n+  virtual int Compare(const Slice& a, const Slice& b) const;\n+  virtual void FindShortestSeparator(\n+      std::string* start,\n+      const Slice& limit) const;\n+  virtual void FindShortSuccessor(std::string* key) const;\n+\n+  const Comparator* user_comparator() const { return user_comparator_; }\n+\n+  int Compare(const InternalKey& a, const InternalKey& b) const;\n+};\n+\n+// Filter policy wrapper that converts from internal keys to user keys\n+class InternalFilterPolicy : public FilterPolicy {\n+ private:\n+  const FilterPolicy* const user_policy_;\n+ public:\n+  explicit InternalFilterPolicy(const FilterPolicy* p) : user_policy_(p) { }\n+  virtual const char* Name() const;\n+  virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const;\n+  virtual bool KeyMayMatch(const Slice& key, const Slice& filter) const;\n+};\n+\n+// Modules in this directory should keep internal keys wrapped inside\n+// the following class instead of plain strings so that we do not\n+// incorrectly use string comparisons instead of an InternalKeyComparator.\n+class InternalKey {\n+ private:\n+  std::string rep_;\n+ public:\n+  InternalKey() { }   // Leave rep_ as empty to indicate it is invalid\n+  InternalKey(const Slice& user_key, SequenceNumber s, ValueType t) {\n+    AppendInternalKey(&rep_, ParsedInternalKey(user_key, s, t));\n+  }\n+\n+  void DecodeFrom(const Slice& s) { rep_.assign(s.data(), s.size()); }\n+  Slice Encode() const {\n+    assert(!rep_.empty());\n+    return rep_;\n+  }\n+\n+  Slice user_key() const { return ExtractUserKey(rep_); }\n+\n+  void SetFrom(const ParsedInternalKey& p) {\n+    rep_.clear();\n+    AppendInternalKey(&rep_, p);\n+  }\n+\n+  void Clear() { rep_.clear(); }\n+\n+  std::string DebugString() const;\n+};\n+\n+inline int InternalKeyComparator::Compare(\n+    const InternalKey& a, const InternalKey& b) const {\n+  return Compare(a.Encode(), b.Encode());\n+}\n+\n+inline bool ParseInternalKey(const Slice& internal_key,\n+                             ParsedInternalKey* result) {\n+  const size_t n = internal_key.size();\n+  if (n < 8) return false;\n+  uint64_t num = DecodeFixed64(internal_key.data() + n - 8);\n+  unsigned char c = num & 0xff;\n+  result->sequence = num >> 8;\n+  result->type = static_cast<ValueType>(c);\n+  result->user_key = Slice(internal_key.data(), n - 8);\n+  return (c <= static_cast<unsigned char>(kTypeValue));\n+}\n+\n+// A helper class useful for DBImpl::Get()\n+class LookupKey {\n+ public:\n+  // Initialize *this for looking up user_key at a snapshot with\n+  // the specified sequence number.\n+  LookupKey(const Slice& user_key, SequenceNumber sequence);\n+\n+  ~LookupKey();\n+\n+  // Return a key suitable for lookup in a MemTable.\n+  Slice memtable_key() const { return Slice(start_, end_ - start_); }\n+\n+  // Return an internal key (suitable for passing to an internal iterator)\n+  Slice internal_key() const { return Slice(kstart_, end_ - kstart_); }\n+\n+  // Return the user key\n+  Slice user_key() const { return Slice(kstart_, end_ - kstart_ - 8); }\n+\n+ private:\n+  // We construct a char array of the form:\n+  //    klength  varint32               <-- start_\n+  //    userkey  char[klength]          <-- kstart_\n+  //    tag      uint64\n+  //                                    <-- end_\n+  // The array is a suitable MemTable key.\n+  // The suffix starting with \"userkey\" can be used as an InternalKey.\n+  const char* start_;\n+  const char* kstart_;\n+  const char* end_;\n+  char space_[200];      // Avoid allocation for short keys\n+\n+  // No copying allowed\n+  LookupKey(const LookupKey&);\n+  void operator=(const LookupKey&);\n+};\n+\n+inline LookupKey::~LookupKey() {\n+  if (start_ != space_) delete[] start_;\n+}\n+\n+}  // namespace leveldb\n+\n+#endif  // STORAGE_LEVELDB_DB_FORMAT_H_"
      },
      {
        "sha": "5d82f5d313fad88ea4e1d079427bba13df667cfe",
        "filename": "src/leveldb/db/dbformat_test.cc",
        "status": "added",
        "additions": 112,
        "deletions": 0,
        "changes": 112,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/dbformat_test.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/dbformat_test.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/dbformat_test.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,112 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include \"db/dbformat.h\"\n+#include \"util/logging.h\"\n+#include \"util/testharness.h\"\n+\n+namespace leveldb {\n+\n+static std::string IKey(const std::string& user_key,\n+                        uint64_t seq,\n+                        ValueType vt) {\n+  std::string encoded;\n+  AppendInternalKey(&encoded, ParsedInternalKey(user_key, seq, vt));\n+  return encoded;\n+}\n+\n+static std::string Shorten(const std::string& s, const std::string& l) {\n+  std::string result = s;\n+  InternalKeyComparator(BytewiseComparator()).FindShortestSeparator(&result, l);\n+  return result;\n+}\n+\n+static std::string ShortSuccessor(const std::string& s) {\n+  std::string result = s;\n+  InternalKeyComparator(BytewiseComparator()).FindShortSuccessor(&result);\n+  return result;\n+}\n+\n+static void TestKey(const std::string& key,\n+                    uint64_t seq,\n+                    ValueType vt) {\n+  std::string encoded = IKey(key, seq, vt);\n+\n+  Slice in(encoded);\n+  ParsedInternalKey decoded(\"\", 0, kTypeValue);\n+\n+  ASSERT_TRUE(ParseInternalKey(in, &decoded));\n+  ASSERT_EQ(key, decoded.user_key.ToString());\n+  ASSERT_EQ(seq, decoded.sequence);\n+  ASSERT_EQ(vt, decoded.type);\n+\n+  ASSERT_TRUE(!ParseInternalKey(Slice(\"bar\"), &decoded));\n+}\n+\n+class FormatTest { };\n+\n+TEST(FormatTest, InternalKey_EncodeDecode) {\n+  const char* keys[] = { \"\", \"k\", \"hello\", \"longggggggggggggggggggggg\" };\n+  const uint64_t seq[] = {\n+    1, 2, 3,\n+    (1ull << 8) - 1, 1ull << 8, (1ull << 8) + 1,\n+    (1ull << 16) - 1, 1ull << 16, (1ull << 16) + 1,\n+    (1ull << 32) - 1, 1ull << 32, (1ull << 32) + 1\n+  };\n+  for (int k = 0; k < sizeof(keys) / sizeof(keys[0]); k++) {\n+    for (int s = 0; s < sizeof(seq) / sizeof(seq[0]); s++) {\n+      TestKey(keys[k], seq[s], kTypeValue);\n+      TestKey(\"hello\", 1, kTypeDeletion);\n+    }\n+  }\n+}\n+\n+TEST(FormatTest, InternalKeyShortSeparator) {\n+  // When user keys are same\n+  ASSERT_EQ(IKey(\"foo\", 100, kTypeValue),\n+            Shorten(IKey(\"foo\", 100, kTypeValue),\n+                    IKey(\"foo\", 99, kTypeValue)));\n+  ASSERT_EQ(IKey(\"foo\", 100, kTypeValue),\n+            Shorten(IKey(\"foo\", 100, kTypeValue),\n+                    IKey(\"foo\", 101, kTypeValue)));\n+  ASSERT_EQ(IKey(\"foo\", 100, kTypeValue),\n+            Shorten(IKey(\"foo\", 100, kTypeValue),\n+                    IKey(\"foo\", 100, kTypeValue)));\n+  ASSERT_EQ(IKey(\"foo\", 100, kTypeValue),\n+            Shorten(IKey(\"foo\", 100, kTypeValue),\n+                    IKey(\"foo\", 100, kTypeDeletion)));\n+\n+  // When user keys are misordered\n+  ASSERT_EQ(IKey(\"foo\", 100, kTypeValue),\n+            Shorten(IKey(\"foo\", 100, kTypeValue),\n+                    IKey(\"bar\", 99, kTypeValue)));\n+\n+  // When user keys are different, but correctly ordered\n+  ASSERT_EQ(IKey(\"g\", kMaxSequenceNumber, kValueTypeForSeek),\n+            Shorten(IKey(\"foo\", 100, kTypeValue),\n+                    IKey(\"hello\", 200, kTypeValue)));\n+\n+  // When start user key is prefix of limit user key\n+  ASSERT_EQ(IKey(\"foo\", 100, kTypeValue),\n+            Shorten(IKey(\"foo\", 100, kTypeValue),\n+                    IKey(\"foobar\", 200, kTypeValue)));\n+\n+  // When limit user key is prefix of start user key\n+  ASSERT_EQ(IKey(\"foobar\", 100, kTypeValue),\n+            Shorten(IKey(\"foobar\", 100, kTypeValue),\n+                    IKey(\"foo\", 200, kTypeValue)));\n+}\n+\n+TEST(FormatTest, InternalKeyShortestSuccessor) {\n+  ASSERT_EQ(IKey(\"g\", kMaxSequenceNumber, kValueTypeForSeek),\n+            ShortSuccessor(IKey(\"foo\", 100, kTypeValue)));\n+  ASSERT_EQ(IKey(\"\\xff\\xff\", 100, kTypeValue),\n+            ShortSuccessor(IKey(\"\\xff\\xff\", 100, kTypeValue)));\n+}\n+\n+}  // namespace leveldb\n+\n+int main(int argc, char** argv) {\n+  return leveldb::test::RunAllTests();\n+}"
      },
      {
        "sha": "3c4d49f64eb6dfbf9d3740cbfda3f6ad218a4f52",
        "filename": "src/leveldb/db/filename.cc",
        "status": "added",
        "additions": 139,
        "deletions": 0,
        "changes": 139,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/filename.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/filename.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/filename.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,139 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include <ctype.h>\n+#include <stdio.h>\n+#include \"db/filename.h\"\n+#include \"db/dbformat.h\"\n+#include \"leveldb/env.h\"\n+#include \"util/logging.h\"\n+\n+namespace leveldb {\n+\n+// A utility routine: write \"data\" to the named file and Sync() it.\n+extern Status WriteStringToFileSync(Env* env, const Slice& data,\n+                                    const std::string& fname);\n+\n+static std::string MakeFileName(const std::string& name, uint64_t number,\n+                                const char* suffix) {\n+  char buf[100];\n+  snprintf(buf, sizeof(buf), \"/%06llu.%s\",\n+           static_cast<unsigned long long>(number),\n+           suffix);\n+  return name + buf;\n+}\n+\n+std::string LogFileName(const std::string& name, uint64_t number) {\n+  assert(number > 0);\n+  return MakeFileName(name, number, \"log\");\n+}\n+\n+std::string TableFileName(const std::string& name, uint64_t number) {\n+  assert(number > 0);\n+  return MakeFileName(name, number, \"sst\");\n+}\n+\n+std::string DescriptorFileName(const std::string& dbname, uint64_t number) {\n+  assert(number > 0);\n+  char buf[100];\n+  snprintf(buf, sizeof(buf), \"/MANIFEST-%06llu\",\n+           static_cast<unsigned long long>(number));\n+  return dbname + buf;\n+}\n+\n+std::string CurrentFileName(const std::string& dbname) {\n+  return dbname + \"/CURRENT\";\n+}\n+\n+std::string LockFileName(const std::string& dbname) {\n+  return dbname + \"/LOCK\";\n+}\n+\n+std::string TempFileName(const std::string& dbname, uint64_t number) {\n+  assert(number > 0);\n+  return MakeFileName(dbname, number, \"dbtmp\");\n+}\n+\n+std::string InfoLogFileName(const std::string& dbname) {\n+  return dbname + \"/LOG\";\n+}\n+\n+// Return the name of the old info log file for \"dbname\".\n+std::string OldInfoLogFileName(const std::string& dbname) {\n+  return dbname + \"/LOG.old\";\n+}\n+\n+\n+// Owned filenames have the form:\n+//    dbname/CURRENT\n+//    dbname/LOCK\n+//    dbname/LOG\n+//    dbname/LOG.old\n+//    dbname/MANIFEST-[0-9]+\n+//    dbname/[0-9]+.(log|sst)\n+bool ParseFileName(const std::string& fname,\n+                   uint64_t* number,\n+                   FileType* type) {\n+  Slice rest(fname);\n+  if (rest == \"CURRENT\") {\n+    *number = 0;\n+    *type = kCurrentFile;\n+  } else if (rest == \"LOCK\") {\n+    *number = 0;\n+    *type = kDBLockFile;\n+  } else if (rest == \"LOG\" || rest == \"LOG.old\") {\n+    *number = 0;\n+    *type = kInfoLogFile;\n+  } else if (rest.starts_with(\"MANIFEST-\")) {\n+    rest.remove_prefix(strlen(\"MANIFEST-\"));\n+    uint64_t num;\n+    if (!ConsumeDecimalNumber(&rest, &num)) {\n+      return false;\n+    }\n+    if (!rest.empty()) {\n+      return false;\n+    }\n+    *type = kDescriptorFile;\n+    *number = num;\n+  } else {\n+    // Avoid strtoull() to keep filename format independent of the\n+    // current locale\n+    uint64_t num;\n+    if (!ConsumeDecimalNumber(&rest, &num)) {\n+      return false;\n+    }\n+    Slice suffix = rest;\n+    if (suffix == Slice(\".log\")) {\n+      *type = kLogFile;\n+    } else if (suffix == Slice(\".sst\")) {\n+      *type = kTableFile;\n+    } else if (suffix == Slice(\".dbtmp\")) {\n+      *type = kTempFile;\n+    } else {\n+      return false;\n+    }\n+    *number = num;\n+  }\n+  return true;\n+}\n+\n+Status SetCurrentFile(Env* env, const std::string& dbname,\n+                      uint64_t descriptor_number) {\n+  // Remove leading \"dbname/\" and add newline to manifest file name\n+  std::string manifest = DescriptorFileName(dbname, descriptor_number);\n+  Slice contents = manifest;\n+  assert(contents.starts_with(dbname + \"/\"));\n+  contents.remove_prefix(dbname.size() + 1);\n+  std::string tmp = TempFileName(dbname, descriptor_number);\n+  Status s = WriteStringToFileSync(env, contents.ToString() + \"\\n\", tmp);\n+  if (s.ok()) {\n+    s = env->RenameFile(tmp, CurrentFileName(dbname));\n+  }\n+  if (!s.ok()) {\n+    env->DeleteFile(tmp);\n+  }\n+  return s;\n+}\n+\n+}  // namespace leveldb"
      },
      {
        "sha": "d5d09b11468105324761761665bb8db72abf9540",
        "filename": "src/leveldb/db/filename.h",
        "status": "added",
        "additions": 80,
        "deletions": 0,
        "changes": 80,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/filename.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/filename.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/filename.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,80 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+//\n+// File names used by DB code\n+\n+#ifndef STORAGE_LEVELDB_DB_FILENAME_H_\n+#define STORAGE_LEVELDB_DB_FILENAME_H_\n+\n+#include <stdint.h>\n+#include <string>\n+#include \"leveldb/slice.h\"\n+#include \"leveldb/status.h\"\n+#include \"port/port.h\"\n+\n+namespace leveldb {\n+\n+class Env;\n+\n+enum FileType {\n+  kLogFile,\n+  kDBLockFile,\n+  kTableFile,\n+  kDescriptorFile,\n+  kCurrentFile,\n+  kTempFile,\n+  kInfoLogFile  // Either the current one, or an old one\n+};\n+\n+// Return the name of the log file with the specified number\n+// in the db named by \"dbname\".  The result will be prefixed with\n+// \"dbname\".\n+extern std::string LogFileName(const std::string& dbname, uint64_t number);\n+\n+// Return the name of the sstable with the specified number\n+// in the db named by \"dbname\".  The result will be prefixed with\n+// \"dbname\".\n+extern std::string TableFileName(const std::string& dbname, uint64_t number);\n+\n+// Return the name of the descriptor file for the db named by\n+// \"dbname\" and the specified incarnation number.  The result will be\n+// prefixed with \"dbname\".\n+extern std::string DescriptorFileName(const std::string& dbname,\n+                                      uint64_t number);\n+\n+// Return the name of the current file.  This file contains the name\n+// of the current manifest file.  The result will be prefixed with\n+// \"dbname\".\n+extern std::string CurrentFileName(const std::string& dbname);\n+\n+// Return the name of the lock file for the db named by\n+// \"dbname\".  The result will be prefixed with \"dbname\".\n+extern std::string LockFileName(const std::string& dbname);\n+\n+// Return the name of a temporary file owned by the db named \"dbname\".\n+// The result will be prefixed with \"dbname\".\n+extern std::string TempFileName(const std::string& dbname, uint64_t number);\n+\n+// Return the name of the info log file for \"dbname\".\n+extern std::string InfoLogFileName(const std::string& dbname);\n+\n+// Return the name of the old info log file for \"dbname\".\n+extern std::string OldInfoLogFileName(const std::string& dbname);\n+\n+// If filename is a leveldb file, store the type of the file in *type.\n+// The number encoded in the filename is stored in *number.  If the\n+// filename was successfully parsed, returns true.  Else return false.\n+extern bool ParseFileName(const std::string& filename,\n+                          uint64_t* number,\n+                          FileType* type);\n+\n+// Make the CURRENT file point to the descriptor file with the\n+// specified number.\n+extern Status SetCurrentFile(Env* env, const std::string& dbname,\n+                             uint64_t descriptor_number);\n+\n+\n+}  // namespace leveldb\n+\n+#endif  // STORAGE_LEVELDB_DB_FILENAME_H_"
      },
      {
        "sha": "47353d6c9aaf699be82fc632cdb8f00f8dae50d0",
        "filename": "src/leveldb/db/filename_test.cc",
        "status": "added",
        "additions": 122,
        "deletions": 0,
        "changes": 122,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/filename_test.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/filename_test.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/filename_test.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,122 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include \"db/filename.h\"\n+\n+#include \"db/dbformat.h\"\n+#include \"port/port.h\"\n+#include \"util/logging.h\"\n+#include \"util/testharness.h\"\n+\n+namespace leveldb {\n+\n+class FileNameTest { };\n+\n+TEST(FileNameTest, Parse) {\n+  Slice db;\n+  FileType type;\n+  uint64_t number;\n+\n+  // Successful parses\n+  static struct {\n+    const char* fname;\n+    uint64_t number;\n+    FileType type;\n+  } cases[] = {\n+    { \"100.log\",            100,   kLogFile },\n+    { \"0.log\",              0,     kLogFile },\n+    { \"0.sst\",              0,     kTableFile },\n+    { \"CURRENT\",            0,     kCurrentFile },\n+    { \"LOCK\",               0,     kDBLockFile },\n+    { \"MANIFEST-2\",         2,     kDescriptorFile },\n+    { \"MANIFEST-7\",         7,     kDescriptorFile },\n+    { \"LOG\",                0,     kInfoLogFile },\n+    { \"LOG.old\",            0,     kInfoLogFile },\n+    { \"18446744073709551615.log\", 18446744073709551615ull, kLogFile },\n+  };\n+  for (int i = 0; i < sizeof(cases) / sizeof(cases[0]); i++) {\n+    std::string f = cases[i].fname;\n+    ASSERT_TRUE(ParseFileName(f, &number, &type)) << f;\n+    ASSERT_EQ(cases[i].type, type) << f;\n+    ASSERT_EQ(cases[i].number, number) << f;\n+  }\n+\n+  // Errors\n+  static const char* errors[] = {\n+    \"\",\n+    \"foo\",\n+    \"foo-dx-100.log\",\n+    \".log\",\n+    \"\",\n+    \"manifest\",\n+    \"CURREN\",\n+    \"CURRENTX\",\n+    \"MANIFES\",\n+    \"MANIFEST\",\n+    \"MANIFEST-\",\n+    \"XMANIFEST-3\",\n+    \"MANIFEST-3x\",\n+    \"LOC\",\n+    \"LOCKx\",\n+    \"LO\",\n+    \"LOGx\",\n+    \"18446744073709551616.log\",\n+    \"184467440737095516150.log\",\n+    \"100\",\n+    \"100.\",\n+    \"100.lop\"\n+  };\n+  for (int i = 0; i < sizeof(errors) / sizeof(errors[0]); i++) {\n+    std::string f = errors[i];\n+    ASSERT_TRUE(!ParseFileName(f, &number, &type)) << f;\n+  };\n+}\n+\n+TEST(FileNameTest, Construction) {\n+  uint64_t number;\n+  FileType type;\n+  std::string fname;\n+\n+  fname = CurrentFileName(\"foo\");\n+  ASSERT_EQ(\"foo/\", std::string(fname.data(), 4));\n+  ASSERT_TRUE(ParseFileName(fname.c_str() + 4, &number, &type));\n+  ASSERT_EQ(0, number);\n+  ASSERT_EQ(kCurrentFile, type);\n+\n+  fname = LockFileName(\"foo\");\n+  ASSERT_EQ(\"foo/\", std::string(fname.data(), 4));\n+  ASSERT_TRUE(ParseFileName(fname.c_str() + 4, &number, &type));\n+  ASSERT_EQ(0, number);\n+  ASSERT_EQ(kDBLockFile, type);\n+\n+  fname = LogFileName(\"foo\", 192);\n+  ASSERT_EQ(\"foo/\", std::string(fname.data(), 4));\n+  ASSERT_TRUE(ParseFileName(fname.c_str() + 4, &number, &type));\n+  ASSERT_EQ(192, number);\n+  ASSERT_EQ(kLogFile, type);\n+\n+  fname = TableFileName(\"bar\", 200);\n+  ASSERT_EQ(\"bar/\", std::string(fname.data(), 4));\n+  ASSERT_TRUE(ParseFileName(fname.c_str() + 4, &number, &type));\n+  ASSERT_EQ(200, number);\n+  ASSERT_EQ(kTableFile, type);\n+\n+  fname = DescriptorFileName(\"bar\", 100);\n+  ASSERT_EQ(\"bar/\", std::string(fname.data(), 4));\n+  ASSERT_TRUE(ParseFileName(fname.c_str() + 4, &number, &type));\n+  ASSERT_EQ(100, number);\n+  ASSERT_EQ(kDescriptorFile, type);\n+\n+  fname = TempFileName(\"tmp\", 999);\n+  ASSERT_EQ(\"tmp/\", std::string(fname.data(), 4));\n+  ASSERT_TRUE(ParseFileName(fname.c_str() + 4, &number, &type));\n+  ASSERT_EQ(999, number);\n+  ASSERT_EQ(kTempFile, type);\n+}\n+\n+}  // namespace leveldb\n+\n+int main(int argc, char** argv) {\n+  return leveldb::test::RunAllTests();\n+}"
      },
      {
        "sha": "2690cb9789ee63e85260500a6736ec302d22f9b7",
        "filename": "src/leveldb/db/log_format.h",
        "status": "added",
        "additions": 35,
        "deletions": 0,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/log_format.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/log_format.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/log_format.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,35 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+//\n+// Log format information shared by reader and writer.\n+// See ../doc/log_format.txt for more detail.\n+\n+#ifndef STORAGE_LEVELDB_DB_LOG_FORMAT_H_\n+#define STORAGE_LEVELDB_DB_LOG_FORMAT_H_\n+\n+namespace leveldb {\n+namespace log {\n+\n+enum RecordType {\n+  // Zero is reserved for preallocated files\n+  kZeroType = 0,\n+\n+  kFullType = 1,\n+\n+  // For fragments\n+  kFirstType = 2,\n+  kMiddleType = 3,\n+  kLastType = 4\n+};\n+static const int kMaxRecordType = kLastType;\n+\n+static const int kBlockSize = 32768;\n+\n+// Header is checksum (4 bytes), type (1 byte), length (2 bytes).\n+static const int kHeaderSize = 4 + 1 + 2;\n+\n+}  // namespace log\n+}  // namespace leveldb\n+\n+#endif  // STORAGE_LEVELDB_DB_LOG_FORMAT_H_"
      },
      {
        "sha": "b35f115aadac28055b16fce6f133bd5148ecec16",
        "filename": "src/leveldb/db/log_reader.cc",
        "status": "added",
        "additions": 259,
        "deletions": 0,
        "changes": 259,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/log_reader.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/log_reader.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/log_reader.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,259 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include \"db/log_reader.h\"\n+\n+#include <stdio.h>\n+#include \"leveldb/env.h\"\n+#include \"util/coding.h\"\n+#include \"util/crc32c.h\"\n+\n+namespace leveldb {\n+namespace log {\n+\n+Reader::Reporter::~Reporter() {\n+}\n+\n+Reader::Reader(SequentialFile* file, Reporter* reporter, bool checksum,\n+               uint64_t initial_offset)\n+    : file_(file),\n+      reporter_(reporter),\n+      checksum_(checksum),\n+      backing_store_(new char[kBlockSize]),\n+      buffer_(),\n+      eof_(false),\n+      last_record_offset_(0),\n+      end_of_buffer_offset_(0),\n+      initial_offset_(initial_offset) {\n+}\n+\n+Reader::~Reader() {\n+  delete[] backing_store_;\n+}\n+\n+bool Reader::SkipToInitialBlock() {\n+  size_t offset_in_block = initial_offset_ % kBlockSize;\n+  uint64_t block_start_location = initial_offset_ - offset_in_block;\n+\n+  // Don't search a block if we'd be in the trailer\n+  if (offset_in_block > kBlockSize - 6) {\n+    offset_in_block = 0;\n+    block_start_location += kBlockSize;\n+  }\n+\n+  end_of_buffer_offset_ = block_start_location;\n+\n+  // Skip to start of first block that can contain the initial record\n+  if (block_start_location > 0) {\n+    Status skip_status = file_->Skip(block_start_location);\n+    if (!skip_status.ok()) {\n+      ReportDrop(block_start_location, skip_status);\n+      return false;\n+    }\n+  }\n+\n+  return true;\n+}\n+\n+bool Reader::ReadRecord(Slice* record, std::string* scratch) {\n+  if (last_record_offset_ < initial_offset_) {\n+    if (!SkipToInitialBlock()) {\n+      return false;\n+    }\n+  }\n+\n+  scratch->clear();\n+  record->clear();\n+  bool in_fragmented_record = false;\n+  // Record offset of the logical record that we're reading\n+  // 0 is a dummy value to make compilers happy\n+  uint64_t prospective_record_offset = 0;\n+\n+  Slice fragment;\n+  while (true) {\n+    uint64_t physical_record_offset = end_of_buffer_offset_ - buffer_.size();\n+    const unsigned int record_type = ReadPhysicalRecord(&fragment);\n+    switch (record_type) {\n+      case kFullType:\n+        if (in_fragmented_record) {\n+          // Handle bug in earlier versions of log::Writer where\n+          // it could emit an empty kFirstType record at the tail end\n+          // of a block followed by a kFullType or kFirstType record\n+          // at the beginning of the next block.\n+          if (scratch->empty()) {\n+            in_fragmented_record = false;\n+          } else {\n+            ReportCorruption(scratch->size(), \"partial record without end(1)\");\n+          }\n+        }\n+        prospective_record_offset = physical_record_offset;\n+        scratch->clear();\n+        *record = fragment;\n+        last_record_offset_ = prospective_record_offset;\n+        return true;\n+\n+      case kFirstType:\n+        if (in_fragmented_record) {\n+          // Handle bug in earlier versions of log::Writer where\n+          // it could emit an empty kFirstType record at the tail end\n+          // of a block followed by a kFullType or kFirstType record\n+          // at the beginning of the next block.\n+          if (scratch->empty()) {\n+            in_fragmented_record = false;\n+          } else {\n+            ReportCorruption(scratch->size(), \"partial record without end(2)\");\n+          }\n+        }\n+        prospective_record_offset = physical_record_offset;\n+        scratch->assign(fragment.data(), fragment.size());\n+        in_fragmented_record = true;\n+        break;\n+\n+      case kMiddleType:\n+        if (!in_fragmented_record) {\n+          ReportCorruption(fragment.size(),\n+                           \"missing start of fragmented record(1)\");\n+        } else {\n+          scratch->append(fragment.data(), fragment.size());\n+        }\n+        break;\n+\n+      case kLastType:\n+        if (!in_fragmented_record) {\n+          ReportCorruption(fragment.size(),\n+                           \"missing start of fragmented record(2)\");\n+        } else {\n+          scratch->append(fragment.data(), fragment.size());\n+          *record = Slice(*scratch);\n+          last_record_offset_ = prospective_record_offset;\n+          return true;\n+        }\n+        break;\n+\n+      case kEof:\n+        if (in_fragmented_record) {\n+          ReportCorruption(scratch->size(), \"partial record without end(3)\");\n+          scratch->clear();\n+        }\n+        return false;\n+\n+      case kBadRecord:\n+        if (in_fragmented_record) {\n+          ReportCorruption(scratch->size(), \"error in middle of record\");\n+          in_fragmented_record = false;\n+          scratch->clear();\n+        }\n+        break;\n+\n+      default: {\n+        char buf[40];\n+        snprintf(buf, sizeof(buf), \"unknown record type %u\", record_type);\n+        ReportCorruption(\n+            (fragment.size() + (in_fragmented_record ? scratch->size() : 0)),\n+            buf);\n+        in_fragmented_record = false;\n+        scratch->clear();\n+        break;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+uint64_t Reader::LastRecordOffset() {\n+  return last_record_offset_;\n+}\n+\n+void Reader::ReportCorruption(size_t bytes, const char* reason) {\n+  ReportDrop(bytes, Status::Corruption(reason));\n+}\n+\n+void Reader::ReportDrop(size_t bytes, const Status& reason) {\n+  if (reporter_ != NULL &&\n+      end_of_buffer_offset_ - buffer_.size() - bytes >= initial_offset_) {\n+    reporter_->Corruption(bytes, reason);\n+  }\n+}\n+\n+unsigned int Reader::ReadPhysicalRecord(Slice* result) {\n+  while (true) {\n+    if (buffer_.size() < kHeaderSize) {\n+      if (!eof_) {\n+        // Last read was a full read, so this is a trailer to skip\n+        buffer_.clear();\n+        Status status = file_->Read(kBlockSize, &buffer_, backing_store_);\n+        end_of_buffer_offset_ += buffer_.size();\n+        if (!status.ok()) {\n+          buffer_.clear();\n+          ReportDrop(kBlockSize, status);\n+          eof_ = true;\n+          return kEof;\n+        } else if (buffer_.size() < kBlockSize) {\n+          eof_ = true;\n+        }\n+        continue;\n+      } else if (buffer_.size() == 0) {\n+        // End of file\n+        return kEof;\n+      } else {\n+        size_t drop_size = buffer_.size();\n+        buffer_.clear();\n+        ReportCorruption(drop_size, \"truncated record at end of file\");\n+        return kEof;\n+      }\n+    }\n+\n+    // Parse the header\n+    const char* header = buffer_.data();\n+    const uint32_t a = static_cast<uint32_t>(header[4]) & 0xff;\n+    const uint32_t b = static_cast<uint32_t>(header[5]) & 0xff;\n+    const unsigned int type = header[6];\n+    const uint32_t length = a | (b << 8);\n+    if (kHeaderSize + length > buffer_.size()) {\n+      size_t drop_size = buffer_.size();\n+      buffer_.clear();\n+      ReportCorruption(drop_size, \"bad record length\");\n+      return kBadRecord;\n+    }\n+\n+    if (type == kZeroType && length == 0) {\n+      // Skip zero length record without reporting any drops since\n+      // such records are produced by the mmap based writing code in\n+      // env_posix.cc that preallocates file regions.\n+      buffer_.clear();\n+      return kBadRecord;\n+    }\n+\n+    // Check crc\n+    if (checksum_) {\n+      uint32_t expected_crc = crc32c::Unmask(DecodeFixed32(header));\n+      uint32_t actual_crc = crc32c::Value(header + 6, 1 + length);\n+      if (actual_crc != expected_crc) {\n+        // Drop the rest of the buffer since \"length\" itself may have\n+        // been corrupted and if we trust it, we could find some\n+        // fragment of a real log record that just happens to look\n+        // like a valid log record.\n+        size_t drop_size = buffer_.size();\n+        buffer_.clear();\n+        ReportCorruption(drop_size, \"checksum mismatch\");\n+        return kBadRecord;\n+      }\n+    }\n+\n+    buffer_.remove_prefix(kHeaderSize + length);\n+\n+    // Skip physical record that started before initial_offset_\n+    if (end_of_buffer_offset_ - buffer_.size() - kHeaderSize - length <\n+        initial_offset_) {\n+      result->clear();\n+      return kBadRecord;\n+    }\n+\n+    *result = Slice(header + kHeaderSize, length);\n+    return type;\n+  }\n+}\n+\n+}  // namespace log\n+}  // namespace leveldb"
      },
      {
        "sha": "82d4bee68d0eea3a7fdd270e91b49545a536f45e",
        "filename": "src/leveldb/db/log_reader.h",
        "status": "added",
        "additions": 108,
        "deletions": 0,
        "changes": 108,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/log_reader.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/log_reader.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/log_reader.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,108 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#ifndef STORAGE_LEVELDB_DB_LOG_READER_H_\n+#define STORAGE_LEVELDB_DB_LOG_READER_H_\n+\n+#include <stdint.h>\n+\n+#include \"db/log_format.h\"\n+#include \"leveldb/slice.h\"\n+#include \"leveldb/status.h\"\n+\n+namespace leveldb {\n+\n+class SequentialFile;\n+\n+namespace log {\n+\n+class Reader {\n+ public:\n+  // Interface for reporting errors.\n+  class Reporter {\n+   public:\n+    virtual ~Reporter();\n+\n+    // Some corruption was detected.  \"size\" is the approximate number\n+    // of bytes dropped due to the corruption.\n+    virtual void Corruption(size_t bytes, const Status& status) = 0;\n+  };\n+\n+  // Create a reader that will return log records from \"*file\".\n+  // \"*file\" must remain live while this Reader is in use.\n+  //\n+  // If \"reporter\" is non-NULL, it is notified whenever some data is\n+  // dropped due to a detected corruption.  \"*reporter\" must remain\n+  // live while this Reader is in use.\n+  //\n+  // If \"checksum\" is true, verify checksums if available.\n+  //\n+  // The Reader will start reading at the first record located at physical\n+  // position >= initial_offset within the file.\n+  Reader(SequentialFile* file, Reporter* reporter, bool checksum,\n+         uint64_t initial_offset);\n+\n+  ~Reader();\n+\n+  // Read the next record into *record.  Returns true if read\n+  // successfully, false if we hit end of the input.  May use\n+  // \"*scratch\" as temporary storage.  The contents filled in *record\n+  // will only be valid until the next mutating operation on this\n+  // reader or the next mutation to *scratch.\n+  bool ReadRecord(Slice* record, std::string* scratch);\n+\n+  // Returns the physical offset of the last record returned by ReadRecord.\n+  //\n+  // Undefined before the first call to ReadRecord.\n+  uint64_t LastRecordOffset();\n+\n+ private:\n+  SequentialFile* const file_;\n+  Reporter* const reporter_;\n+  bool const checksum_;\n+  char* const backing_store_;\n+  Slice buffer_;\n+  bool eof_;   // Last Read() indicated EOF by returning < kBlockSize\n+\n+  // Offset of the last record returned by ReadRecord.\n+  uint64_t last_record_offset_;\n+  // Offset of the first location past the end of buffer_.\n+  uint64_t end_of_buffer_offset_;\n+\n+  // Offset at which to start looking for the first record to return\n+  uint64_t const initial_offset_;\n+\n+  // Extend record types with the following special values\n+  enum {\n+    kEof = kMaxRecordType + 1,\n+    // Returned whenever we find an invalid physical record.\n+    // Currently there are three situations in which this happens:\n+    // * The record has an invalid CRC (ReadPhysicalRecord reports a drop)\n+    // * The record is a 0-length record (No drop is reported)\n+    // * The record is below constructor's initial_offset (No drop is reported)\n+    kBadRecord = kMaxRecordType + 2\n+  };\n+\n+  // Skips all blocks that are completely before \"initial_offset_\".\n+  //\n+  // Returns true on success. Handles reporting.\n+  bool SkipToInitialBlock();\n+\n+  // Return type, or one of the preceding special values\n+  unsigned int ReadPhysicalRecord(Slice* result);\n+\n+  // Reports dropped bytes to the reporter.\n+  // buffer_ must be updated to remove the dropped bytes prior to invocation.\n+  void ReportCorruption(size_t bytes, const char* reason);\n+  void ReportDrop(size_t bytes, const Status& reason);\n+\n+  // No copying allowed\n+  Reader(const Reader&);\n+  void operator=(const Reader&);\n+};\n+\n+}  // namespace log\n+}  // namespace leveldb\n+\n+#endif  // STORAGE_LEVELDB_DB_LOG_READER_H_"
      },
      {
        "sha": "4c5cf875733c16175743224e642f0507a0da663f",
        "filename": "src/leveldb/db/log_test.cc",
        "status": "added",
        "additions": 500,
        "deletions": 0,
        "changes": 500,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/log_test.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/log_test.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/log_test.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,500 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include \"db/log_reader.h\"\n+#include \"db/log_writer.h\"\n+#include \"leveldb/env.h\"\n+#include \"util/coding.h\"\n+#include \"util/crc32c.h\"\n+#include \"util/random.h\"\n+#include \"util/testharness.h\"\n+\n+namespace leveldb {\n+namespace log {\n+\n+// Construct a string of the specified length made out of the supplied\n+// partial string.\n+static std::string BigString(const std::string& partial_string, size_t n) {\n+  std::string result;\n+  while (result.size() < n) {\n+    result.append(partial_string);\n+  }\n+  result.resize(n);\n+  return result;\n+}\n+\n+// Construct a string from a number\n+static std::string NumberString(int n) {\n+  char buf[50];\n+  snprintf(buf, sizeof(buf), \"%d.\", n);\n+  return std::string(buf);\n+}\n+\n+// Return a skewed potentially long string\n+static std::string RandomSkewedString(int i, Random* rnd) {\n+  return BigString(NumberString(i), rnd->Skewed(17));\n+}\n+\n+class LogTest {\n+ private:\n+  class StringDest : public WritableFile {\n+   public:\n+    std::string contents_;\n+\n+    virtual Status Close() { return Status::OK(); }\n+    virtual Status Flush() { return Status::OK(); }\n+    virtual Status Sync() { return Status::OK(); }\n+    virtual Status Append(const Slice& slice) {\n+      contents_.append(slice.data(), slice.size());\n+      return Status::OK();\n+    }\n+  };\n+\n+  class StringSource : public SequentialFile {\n+   public:\n+    Slice contents_;\n+    bool force_error_;\n+    bool returned_partial_;\n+    StringSource() : force_error_(false), returned_partial_(false) { }\n+\n+    virtual Status Read(size_t n, Slice* result, char* scratch) {\n+      ASSERT_TRUE(!returned_partial_) << \"must not Read() after eof/error\";\n+\n+      if (force_error_) {\n+        force_error_ = false;\n+        returned_partial_ = true;\n+        return Status::Corruption(\"read error\");\n+      }\n+\n+      if (contents_.size() < n) {\n+        n = contents_.size();\n+        returned_partial_ = true;\n+      }\n+      *result = Slice(contents_.data(), n);\n+      contents_.remove_prefix(n);\n+      return Status::OK();\n+    }\n+\n+    virtual Status Skip(uint64_t n) {\n+      if (n > contents_.size()) {\n+        contents_.clear();\n+        return Status::NotFound(\"in-memory file skipepd past end\");\n+      }\n+\n+      contents_.remove_prefix(n);\n+\n+      return Status::OK();\n+    }\n+  };\n+\n+  class ReportCollector : public Reader::Reporter {\n+   public:\n+    size_t dropped_bytes_;\n+    std::string message_;\n+\n+    ReportCollector() : dropped_bytes_(0) { }\n+    virtual void Corruption(size_t bytes, const Status& status) {\n+      dropped_bytes_ += bytes;\n+      message_.append(status.ToString());\n+    }\n+  };\n+\n+  StringDest dest_;\n+  StringSource source_;\n+  ReportCollector report_;\n+  bool reading_;\n+  Writer writer_;\n+  Reader reader_;\n+\n+  // Record metadata for testing initial offset functionality\n+  static size_t initial_offset_record_sizes_[];\n+  static uint64_t initial_offset_last_record_offsets_[];\n+\n+ public:\n+  LogTest() : reading_(false),\n+              writer_(&dest_),\n+              reader_(&source_, &report_, true/*checksum*/,\n+                      0/*initial_offset*/) {\n+  }\n+\n+  void Write(const std::string& msg) {\n+    ASSERT_TRUE(!reading_) << \"Write() after starting to read\";\n+    writer_.AddRecord(Slice(msg));\n+  }\n+\n+  size_t WrittenBytes() const {\n+    return dest_.contents_.size();\n+  }\n+\n+  std::string Read() {\n+    if (!reading_) {\n+      reading_ = true;\n+      source_.contents_ = Slice(dest_.contents_);\n+    }\n+    std::string scratch;\n+    Slice record;\n+    if (reader_.ReadRecord(&record, &scratch)) {\n+      return record.ToString();\n+    } else {\n+      return \"EOF\";\n+    }\n+  }\n+\n+  void IncrementByte(int offset, int delta) {\n+    dest_.contents_[offset] += delta;\n+  }\n+\n+  void SetByte(int offset, char new_byte) {\n+    dest_.contents_[offset] = new_byte;\n+  }\n+\n+  void ShrinkSize(int bytes) {\n+    dest_.contents_.resize(dest_.contents_.size() - bytes);\n+  }\n+\n+  void FixChecksum(int header_offset, int len) {\n+    // Compute crc of type/len/data\n+    uint32_t crc = crc32c::Value(&dest_.contents_[header_offset+6], 1 + len);\n+    crc = crc32c::Mask(crc);\n+    EncodeFixed32(&dest_.contents_[header_offset], crc);\n+  }\n+\n+  void ForceError() {\n+    source_.force_error_ = true;\n+  }\n+\n+  size_t DroppedBytes() const {\n+    return report_.dropped_bytes_;\n+  }\n+\n+  std::string ReportMessage() const {\n+    return report_.message_;\n+  }\n+\n+  // Returns OK iff recorded error message contains \"msg\"\n+  std::string MatchError(const std::string& msg) const {\n+    if (report_.message_.find(msg) == std::string::npos) {\n+      return report_.message_;\n+    } else {\n+      return \"OK\";\n+    }\n+  }\n+\n+  void WriteInitialOffsetLog() {\n+    for (int i = 0; i < 4; i++) {\n+      std::string record(initial_offset_record_sizes_[i],\n+                         static_cast<char>('a' + i));\n+      Write(record);\n+    }\n+  }\n+\n+  void CheckOffsetPastEndReturnsNoRecords(uint64_t offset_past_end) {\n+    WriteInitialOffsetLog();\n+    reading_ = true;\n+    source_.contents_ = Slice(dest_.contents_);\n+    Reader* offset_reader = new Reader(&source_, &report_, true/*checksum*/,\n+                                       WrittenBytes() + offset_past_end);\n+    Slice record;\n+    std::string scratch;\n+    ASSERT_TRUE(!offset_reader->ReadRecord(&record, &scratch));\n+    delete offset_reader;\n+  }\n+\n+  void CheckInitialOffsetRecord(uint64_t initial_offset,\n+                                int expected_record_offset) {\n+    WriteInitialOffsetLog();\n+    reading_ = true;\n+    source_.contents_ = Slice(dest_.contents_);\n+    Reader* offset_reader = new Reader(&source_, &report_, true/*checksum*/,\n+                                       initial_offset);\n+    Slice record;\n+    std::string scratch;\n+    ASSERT_TRUE(offset_reader->ReadRecord(&record, &scratch));\n+    ASSERT_EQ(initial_offset_record_sizes_[expected_record_offset],\n+              record.size());\n+    ASSERT_EQ(initial_offset_last_record_offsets_[expected_record_offset],\n+              offset_reader->LastRecordOffset());\n+    ASSERT_EQ((char)('a' + expected_record_offset), record.data()[0]);\n+    delete offset_reader;\n+  }\n+\n+};\n+\n+size_t LogTest::initial_offset_record_sizes_[] =\n+    {10000,  // Two sizable records in first block\n+     10000,\n+     2 * log::kBlockSize - 1000,  // Span three blocks\n+     1};\n+\n+uint64_t LogTest::initial_offset_last_record_offsets_[] =\n+    {0,\n+     kHeaderSize + 10000,\n+     2 * (kHeaderSize + 10000),\n+     2 * (kHeaderSize + 10000) +\n+         (2 * log::kBlockSize - 1000) + 3 * kHeaderSize};\n+\n+\n+TEST(LogTest, Empty) {\n+  ASSERT_EQ(\"EOF\", Read());\n+}\n+\n+TEST(LogTest, ReadWrite) {\n+  Write(\"foo\");\n+  Write(\"bar\");\n+  Write(\"\");\n+  Write(\"xxxx\");\n+  ASSERT_EQ(\"foo\", Read());\n+  ASSERT_EQ(\"bar\", Read());\n+  ASSERT_EQ(\"\", Read());\n+  ASSERT_EQ(\"xxxx\", Read());\n+  ASSERT_EQ(\"EOF\", Read());\n+  ASSERT_EQ(\"EOF\", Read());  // Make sure reads at eof work\n+}\n+\n+TEST(LogTest, ManyBlocks) {\n+  for (int i = 0; i < 100000; i++) {\n+    Write(NumberString(i));\n+  }\n+  for (int i = 0; i < 100000; i++) {\n+    ASSERT_EQ(NumberString(i), Read());\n+  }\n+  ASSERT_EQ(\"EOF\", Read());\n+}\n+\n+TEST(LogTest, Fragmentation) {\n+  Write(\"small\");\n+  Write(BigString(\"medium\", 50000));\n+  Write(BigString(\"large\", 100000));\n+  ASSERT_EQ(\"small\", Read());\n+  ASSERT_EQ(BigString(\"medium\", 50000), Read());\n+  ASSERT_EQ(BigString(\"large\", 100000), Read());\n+  ASSERT_EQ(\"EOF\", Read());\n+}\n+\n+TEST(LogTest, MarginalTrailer) {\n+  // Make a trailer that is exactly the same length as an empty record.\n+  const int n = kBlockSize - 2*kHeaderSize;\n+  Write(BigString(\"foo\", n));\n+  ASSERT_EQ(kBlockSize - kHeaderSize, WrittenBytes());\n+  Write(\"\");\n+  Write(\"bar\");\n+  ASSERT_EQ(BigString(\"foo\", n), Read());\n+  ASSERT_EQ(\"\", Read());\n+  ASSERT_EQ(\"bar\", Read());\n+  ASSERT_EQ(\"EOF\", Read());\n+}\n+\n+TEST(LogTest, MarginalTrailer2) {\n+  // Make a trailer that is exactly the same length as an empty record.\n+  const int n = kBlockSize - 2*kHeaderSize;\n+  Write(BigString(\"foo\", n));\n+  ASSERT_EQ(kBlockSize - kHeaderSize, WrittenBytes());\n+  Write(\"bar\");\n+  ASSERT_EQ(BigString(\"foo\", n), Read());\n+  ASSERT_EQ(\"bar\", Read());\n+  ASSERT_EQ(\"EOF\", Read());\n+  ASSERT_EQ(0, DroppedBytes());\n+  ASSERT_EQ(\"\", ReportMessage());\n+}\n+\n+TEST(LogTest, ShortTrailer) {\n+  const int n = kBlockSize - 2*kHeaderSize + 4;\n+  Write(BigString(\"foo\", n));\n+  ASSERT_EQ(kBlockSize - kHeaderSize + 4, WrittenBytes());\n+  Write(\"\");\n+  Write(\"bar\");\n+  ASSERT_EQ(BigString(\"foo\", n), Read());\n+  ASSERT_EQ(\"\", Read());\n+  ASSERT_EQ(\"bar\", Read());\n+  ASSERT_EQ(\"EOF\", Read());\n+}\n+\n+TEST(LogTest, AlignedEof) {\n+  const int n = kBlockSize - 2*kHeaderSize + 4;\n+  Write(BigString(\"foo\", n));\n+  ASSERT_EQ(kBlockSize - kHeaderSize + 4, WrittenBytes());\n+  ASSERT_EQ(BigString(\"foo\", n), Read());\n+  ASSERT_EQ(\"EOF\", Read());\n+}\n+\n+TEST(LogTest, RandomRead) {\n+  const int N = 500;\n+  Random write_rnd(301);\n+  for (int i = 0; i < N; i++) {\n+    Write(RandomSkewedString(i, &write_rnd));\n+  }\n+  Random read_rnd(301);\n+  for (int i = 0; i < N; i++) {\n+    ASSERT_EQ(RandomSkewedString(i, &read_rnd), Read());\n+  }\n+  ASSERT_EQ(\"EOF\", Read());\n+}\n+\n+// Tests of all the error paths in log_reader.cc follow:\n+\n+TEST(LogTest, ReadError) {\n+  Write(\"foo\");\n+  ForceError();\n+  ASSERT_EQ(\"EOF\", Read());\n+  ASSERT_EQ(kBlockSize, DroppedBytes());\n+  ASSERT_EQ(\"OK\", MatchError(\"read error\"));\n+}\n+\n+TEST(LogTest, BadRecordType) {\n+  Write(\"foo\");\n+  // Type is stored in header[6]\n+  IncrementByte(6, 100);\n+  FixChecksum(0, 3);\n+  ASSERT_EQ(\"EOF\", Read());\n+  ASSERT_EQ(3, DroppedBytes());\n+  ASSERT_EQ(\"OK\", MatchError(\"unknown record type\"));\n+}\n+\n+TEST(LogTest, TruncatedTrailingRecord) {\n+  Write(\"foo\");\n+  ShrinkSize(4);   // Drop all payload as well as a header byte\n+  ASSERT_EQ(\"EOF\", Read());\n+  ASSERT_EQ(kHeaderSize - 1, DroppedBytes());\n+  ASSERT_EQ(\"OK\", MatchError(\"truncated record at end of file\"));\n+}\n+\n+TEST(LogTest, BadLength) {\n+  Write(\"foo\");\n+  ShrinkSize(1);\n+  ASSERT_EQ(\"EOF\", Read());\n+  ASSERT_EQ(kHeaderSize + 2, DroppedBytes());\n+  ASSERT_EQ(\"OK\", MatchError(\"bad record length\"));\n+}\n+\n+TEST(LogTest, ChecksumMismatch) {\n+  Write(\"foo\");\n+  IncrementByte(0, 10);\n+  ASSERT_EQ(\"EOF\", Read());\n+  ASSERT_EQ(10, DroppedBytes());\n+  ASSERT_EQ(\"OK\", MatchError(\"checksum mismatch\"));\n+}\n+\n+TEST(LogTest, UnexpectedMiddleType) {\n+  Write(\"foo\");\n+  SetByte(6, kMiddleType);\n+  FixChecksum(0, 3);\n+  ASSERT_EQ(\"EOF\", Read());\n+  ASSERT_EQ(3, DroppedBytes());\n+  ASSERT_EQ(\"OK\", MatchError(\"missing start\"));\n+}\n+\n+TEST(LogTest, UnexpectedLastType) {\n+  Write(\"foo\");\n+  SetByte(6, kLastType);\n+  FixChecksum(0, 3);\n+  ASSERT_EQ(\"EOF\", Read());\n+  ASSERT_EQ(3, DroppedBytes());\n+  ASSERT_EQ(\"OK\", MatchError(\"missing start\"));\n+}\n+\n+TEST(LogTest, UnexpectedFullType) {\n+  Write(\"foo\");\n+  Write(\"bar\");\n+  SetByte(6, kFirstType);\n+  FixChecksum(0, 3);\n+  ASSERT_EQ(\"bar\", Read());\n+  ASSERT_EQ(\"EOF\", Read());\n+  ASSERT_EQ(3, DroppedBytes());\n+  ASSERT_EQ(\"OK\", MatchError(\"partial record without end\"));\n+}\n+\n+TEST(LogTest, UnexpectedFirstType) {\n+  Write(\"foo\");\n+  Write(BigString(\"bar\", 100000));\n+  SetByte(6, kFirstType);\n+  FixChecksum(0, 3);\n+  ASSERT_EQ(BigString(\"bar\", 100000), Read());\n+  ASSERT_EQ(\"EOF\", Read());\n+  ASSERT_EQ(3, DroppedBytes());\n+  ASSERT_EQ(\"OK\", MatchError(\"partial record without end\"));\n+}\n+\n+TEST(LogTest, ErrorJoinsRecords) {\n+  // Consider two fragmented records:\n+  //    first(R1) last(R1) first(R2) last(R2)\n+  // where the middle two fragments disappear.  We do not want\n+  // first(R1),last(R2) to get joined and returned as a valid record.\n+\n+  // Write records that span two blocks\n+  Write(BigString(\"foo\", kBlockSize));\n+  Write(BigString(\"bar\", kBlockSize));\n+  Write(\"correct\");\n+\n+  // Wipe the middle block\n+  for (int offset = kBlockSize; offset < 2*kBlockSize; offset++) {\n+    SetByte(offset, 'x');\n+  }\n+\n+  ASSERT_EQ(\"correct\", Read());\n+  ASSERT_EQ(\"EOF\", Read());\n+  const int dropped = DroppedBytes();\n+  ASSERT_LE(dropped, 2*kBlockSize + 100);\n+  ASSERT_GE(dropped, 2*kBlockSize);\n+}\n+\n+TEST(LogTest, ReadStart) {\n+  CheckInitialOffsetRecord(0, 0);\n+}\n+\n+TEST(LogTest, ReadSecondOneOff) {\n+  CheckInitialOffsetRecord(1, 1);\n+}\n+\n+TEST(LogTest, ReadSecondTenThousand) {\n+  CheckInitialOffsetRecord(10000, 1);\n+}\n+\n+TEST(LogTest, ReadSecondStart) {\n+  CheckInitialOffsetRecord(10007, 1);\n+}\n+\n+TEST(LogTest, ReadThirdOneOff) {\n+  CheckInitialOffsetRecord(10008, 2);\n+}\n+\n+TEST(LogTest, ReadThirdStart) {\n+  CheckInitialOffsetRecord(20014, 2);\n+}\n+\n+TEST(LogTest, ReadFourthOneOff) {\n+  CheckInitialOffsetRecord(20015, 3);\n+}\n+\n+TEST(LogTest, ReadFourthFirstBlockTrailer) {\n+  CheckInitialOffsetRecord(log::kBlockSize - 4, 3);\n+}\n+\n+TEST(LogTest, ReadFourthMiddleBlock) {\n+  CheckInitialOffsetRecord(log::kBlockSize + 1, 3);\n+}\n+\n+TEST(LogTest, ReadFourthLastBlock) {\n+  CheckInitialOffsetRecord(2 * log::kBlockSize + 1, 3);\n+}\n+\n+TEST(LogTest, ReadFourthStart) {\n+  CheckInitialOffsetRecord(\n+      2 * (kHeaderSize + 1000) + (2 * log::kBlockSize - 1000) + 3 * kHeaderSize,\n+      3);\n+}\n+\n+TEST(LogTest, ReadEnd) {\n+  CheckOffsetPastEndReturnsNoRecords(0);\n+}\n+\n+TEST(LogTest, ReadPastEnd) {\n+  CheckOffsetPastEndReturnsNoRecords(5);\n+}\n+\n+}  // namespace log\n+}  // namespace leveldb\n+\n+int main(int argc, char** argv) {\n+  return leveldb::test::RunAllTests();\n+}"
      },
      {
        "sha": "2da99ac08866397270663a1203075944162ba290",
        "filename": "src/leveldb/db/log_writer.cc",
        "status": "added",
        "additions": 103,
        "deletions": 0,
        "changes": 103,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/log_writer.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/log_writer.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/log_writer.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,103 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include \"db/log_writer.h\"\n+\n+#include <stdint.h>\n+#include \"leveldb/env.h\"\n+#include \"util/coding.h\"\n+#include \"util/crc32c.h\"\n+\n+namespace leveldb {\n+namespace log {\n+\n+Writer::Writer(WritableFile* dest)\n+    : dest_(dest),\n+      block_offset_(0) {\n+  for (int i = 0; i <= kMaxRecordType; i++) {\n+    char t = static_cast<char>(i);\n+    type_crc_[i] = crc32c::Value(&t, 1);\n+  }\n+}\n+\n+Writer::~Writer() {\n+}\n+\n+Status Writer::AddRecord(const Slice& slice) {\n+  const char* ptr = slice.data();\n+  size_t left = slice.size();\n+\n+  // Fragment the record if necessary and emit it.  Note that if slice\n+  // is empty, we still want to iterate once to emit a single\n+  // zero-length record\n+  Status s;\n+  bool begin = true;\n+  do {\n+    const int leftover = kBlockSize - block_offset_;\n+    assert(leftover >= 0);\n+    if (leftover < kHeaderSize) {\n+      // Switch to a new block\n+      if (leftover > 0) {\n+        // Fill the trailer (literal below relies on kHeaderSize being 7)\n+        assert(kHeaderSize == 7);\n+        dest_->Append(Slice(\"\\x00\\x00\\x00\\x00\\x00\\x00\", leftover));\n+      }\n+      block_offset_ = 0;\n+    }\n+\n+    // Invariant: we never leave < kHeaderSize bytes in a block.\n+    assert(kBlockSize - block_offset_ - kHeaderSize >= 0);\n+\n+    const size_t avail = kBlockSize - block_offset_ - kHeaderSize;\n+    const size_t fragment_length = (left < avail) ? left : avail;\n+\n+    RecordType type;\n+    const bool end = (left == fragment_length);\n+    if (begin && end) {\n+      type = kFullType;\n+    } else if (begin) {\n+      type = kFirstType;\n+    } else if (end) {\n+      type = kLastType;\n+    } else {\n+      type = kMiddleType;\n+    }\n+\n+    s = EmitPhysicalRecord(type, ptr, fragment_length);\n+    ptr += fragment_length;\n+    left -= fragment_length;\n+    begin = false;\n+  } while (s.ok() && left > 0);\n+  return s;\n+}\n+\n+Status Writer::EmitPhysicalRecord(RecordType t, const char* ptr, size_t n) {\n+  assert(n <= 0xffff);  // Must fit in two bytes\n+  assert(block_offset_ + kHeaderSize + n <= kBlockSize);\n+\n+  // Format the header\n+  char buf[kHeaderSize];\n+  buf[4] = static_cast<char>(n & 0xff);\n+  buf[5] = static_cast<char>(n >> 8);\n+  buf[6] = static_cast<char>(t);\n+\n+  // Compute the crc of the record type and the payload.\n+  uint32_t crc = crc32c::Extend(type_crc_[t], ptr, n);\n+  crc = crc32c::Mask(crc);                 // Adjust for storage\n+  EncodeFixed32(buf, crc);\n+\n+  // Write the header and the payload\n+  Status s = dest_->Append(Slice(buf, kHeaderSize));\n+  if (s.ok()) {\n+    s = dest_->Append(Slice(ptr, n));\n+    if (s.ok()) {\n+      s = dest_->Flush();\n+    }\n+  }\n+  block_offset_ += kHeaderSize + n;\n+  return s;\n+}\n+\n+}  // namespace log\n+}  // namespace leveldb"
      },
      {
        "sha": "a3a954d96732542fac9aef1345ebd952075f737c",
        "filename": "src/leveldb/db/log_writer.h",
        "status": "added",
        "additions": 48,
        "deletions": 0,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/log_writer.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/log_writer.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/log_writer.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,48 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#ifndef STORAGE_LEVELDB_DB_LOG_WRITER_H_\n+#define STORAGE_LEVELDB_DB_LOG_WRITER_H_\n+\n+#include <stdint.h>\n+#include \"db/log_format.h\"\n+#include \"leveldb/slice.h\"\n+#include \"leveldb/status.h\"\n+\n+namespace leveldb {\n+\n+class WritableFile;\n+\n+namespace log {\n+\n+class Writer {\n+ public:\n+  // Create a writer that will append data to \"*dest\".\n+  // \"*dest\" must be initially empty.\n+  // \"*dest\" must remain live while this Writer is in use.\n+  explicit Writer(WritableFile* dest);\n+  ~Writer();\n+\n+  Status AddRecord(const Slice& slice);\n+\n+ private:\n+  WritableFile* dest_;\n+  int block_offset_;       // Current offset in block\n+\n+  // crc32c values for all supported record types.  These are\n+  // pre-computed to reduce the overhead of computing the crc of the\n+  // record type stored in the header.\n+  uint32_t type_crc_[kMaxRecordType + 1];\n+\n+  Status EmitPhysicalRecord(RecordType type, const char* ptr, size_t length);\n+\n+  // No copying allowed\n+  Writer(const Writer&);\n+  void operator=(const Writer&);\n+};\n+\n+}  // namespace log\n+}  // namespace leveldb\n+\n+#endif  // STORAGE_LEVELDB_DB_LOG_WRITER_H_"
      },
      {
        "sha": "bfec0a7e7a1dc210b44dd527b9547e33e829d9bb",
        "filename": "src/leveldb/db/memtable.cc",
        "status": "added",
        "additions": 145,
        "deletions": 0,
        "changes": 145,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/memtable.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/memtable.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/memtable.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,145 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include \"db/memtable.h\"\n+#include \"db/dbformat.h\"\n+#include \"leveldb/comparator.h\"\n+#include \"leveldb/env.h\"\n+#include \"leveldb/iterator.h\"\n+#include \"util/coding.h\"\n+\n+namespace leveldb {\n+\n+static Slice GetLengthPrefixedSlice(const char* data) {\n+  uint32_t len;\n+  const char* p = data;\n+  p = GetVarint32Ptr(p, p + 5, &len);  // +5: we assume \"p\" is not corrupted\n+  return Slice(p, len);\n+}\n+\n+MemTable::MemTable(const InternalKeyComparator& cmp)\n+    : comparator_(cmp),\n+      refs_(0),\n+      table_(comparator_, &arena_) {\n+}\n+\n+MemTable::~MemTable() {\n+  assert(refs_ == 0);\n+}\n+\n+size_t MemTable::ApproximateMemoryUsage() { return arena_.MemoryUsage(); }\n+\n+int MemTable::KeyComparator::operator()(const char* aptr, const char* bptr)\n+    const {\n+  // Internal keys are encoded as length-prefixed strings.\n+  Slice a = GetLengthPrefixedSlice(aptr);\n+  Slice b = GetLengthPrefixedSlice(bptr);\n+  return comparator.Compare(a, b);\n+}\n+\n+// Encode a suitable internal key target for \"target\" and return it.\n+// Uses *scratch as scratch space, and the returned pointer will point\n+// into this scratch space.\n+static const char* EncodeKey(std::string* scratch, const Slice& target) {\n+  scratch->clear();\n+  PutVarint32(scratch, target.size());\n+  scratch->append(target.data(), target.size());\n+  return scratch->data();\n+}\n+\n+class MemTableIterator: public Iterator {\n+ public:\n+  explicit MemTableIterator(MemTable::Table* table) : iter_(table) { }\n+\n+  virtual bool Valid() const { return iter_.Valid(); }\n+  virtual void Seek(const Slice& k) { iter_.Seek(EncodeKey(&tmp_, k)); }\n+  virtual void SeekToFirst() { iter_.SeekToFirst(); }\n+  virtual void SeekToLast() { iter_.SeekToLast(); }\n+  virtual void Next() { iter_.Next(); }\n+  virtual void Prev() { iter_.Prev(); }\n+  virtual Slice key() const { return GetLengthPrefixedSlice(iter_.key()); }\n+  virtual Slice value() const {\n+    Slice key_slice = GetLengthPrefixedSlice(iter_.key());\n+    return GetLengthPrefixedSlice(key_slice.data() + key_slice.size());\n+  }\n+\n+  virtual Status status() const { return Status::OK(); }\n+\n+ private:\n+  MemTable::Table::Iterator iter_;\n+  std::string tmp_;       // For passing to EncodeKey\n+\n+  // No copying allowed\n+  MemTableIterator(const MemTableIterator&);\n+  void operator=(const MemTableIterator&);\n+};\n+\n+Iterator* MemTable::NewIterator() {\n+  return new MemTableIterator(&table_);\n+}\n+\n+void MemTable::Add(SequenceNumber s, ValueType type,\n+                   const Slice& key,\n+                   const Slice& value) {\n+  // Format of an entry is concatenation of:\n+  //  key_size     : varint32 of internal_key.size()\n+  //  key bytes    : char[internal_key.size()]\n+  //  value_size   : varint32 of value.size()\n+  //  value bytes  : char[value.size()]\n+  size_t key_size = key.size();\n+  size_t val_size = value.size();\n+  size_t internal_key_size = key_size + 8;\n+  const size_t encoded_len =\n+      VarintLength(internal_key_size) + internal_key_size +\n+      VarintLength(val_size) + val_size;\n+  char* buf = arena_.Allocate(encoded_len);\n+  char* p = EncodeVarint32(buf, internal_key_size);\n+  memcpy(p, key.data(), key_size);\n+  p += key_size;\n+  EncodeFixed64(p, (s << 8) | type);\n+  p += 8;\n+  p = EncodeVarint32(p, val_size);\n+  memcpy(p, value.data(), val_size);\n+  assert((p + val_size) - buf == encoded_len);\n+  table_.Insert(buf);\n+}\n+\n+bool MemTable::Get(const LookupKey& key, std::string* value, Status* s) {\n+  Slice memkey = key.memtable_key();\n+  Table::Iterator iter(&table_);\n+  iter.Seek(memkey.data());\n+  if (iter.Valid()) {\n+    // entry format is:\n+    //    klength  varint32\n+    //    userkey  char[klength]\n+    //    tag      uint64\n+    //    vlength  varint32\n+    //    value    char[vlength]\n+    // Check that it belongs to same user key.  We do not check the\n+    // sequence number since the Seek() call above should have skipped\n+    // all entries with overly large sequence numbers.\n+    const char* entry = iter.key();\n+    uint32_t key_length;\n+    const char* key_ptr = GetVarint32Ptr(entry, entry+5, &key_length);\n+    if (comparator_.comparator.user_comparator()->Compare(\n+            Slice(key_ptr, key_length - 8),\n+            key.user_key()) == 0) {\n+      // Correct user key\n+      const uint64_t tag = DecodeFixed64(key_ptr + key_length - 8);\n+      switch (static_cast<ValueType>(tag & 0xff)) {\n+        case kTypeValue: {\n+          Slice v = GetLengthPrefixedSlice(key_ptr + key_length);\n+          value->assign(v.data(), v.size());\n+          return true;\n+        }\n+        case kTypeDeletion:\n+          *s = Status::NotFound(Slice());\n+          return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+}  // namespace leveldb"
      },
      {
        "sha": "92e90bb099f3356520c42d6bb887b2a35c6bbe39",
        "filename": "src/leveldb/db/memtable.h",
        "status": "added",
        "additions": 91,
        "deletions": 0,
        "changes": 91,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/memtable.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/memtable.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/memtable.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,91 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#ifndef STORAGE_LEVELDB_DB_MEMTABLE_H_\n+#define STORAGE_LEVELDB_DB_MEMTABLE_H_\n+\n+#include <string>\n+#include \"leveldb/db.h\"\n+#include \"db/dbformat.h\"\n+#include \"db/skiplist.h\"\n+#include \"util/arena.h\"\n+\n+namespace leveldb {\n+\n+class InternalKeyComparator;\n+class Mutex;\n+class MemTableIterator;\n+\n+class MemTable {\n+ public:\n+  // MemTables are reference counted.  The initial reference count\n+  // is zero and the caller must call Ref() at least once.\n+  explicit MemTable(const InternalKeyComparator& comparator);\n+\n+  // Increase reference count.\n+  void Ref() { ++refs_; }\n+\n+  // Drop reference count.  Delete if no more references exist.\n+  void Unref() {\n+    --refs_;\n+    assert(refs_ >= 0);\n+    if (refs_ <= 0) {\n+      delete this;\n+    }\n+  }\n+\n+  // Returns an estimate of the number of bytes of data in use by this\n+  // data structure.\n+  //\n+  // REQUIRES: external synchronization to prevent simultaneous\n+  // operations on the same MemTable.\n+  size_t ApproximateMemoryUsage();\n+\n+  // Return an iterator that yields the contents of the memtable.\n+  //\n+  // The caller must ensure that the underlying MemTable remains live\n+  // while the returned iterator is live.  The keys returned by this\n+  // iterator are internal keys encoded by AppendInternalKey in the\n+  // db/format.{h,cc} module.\n+  Iterator* NewIterator();\n+\n+  // Add an entry into memtable that maps key to value at the\n+  // specified sequence number and with the specified type.\n+  // Typically value will be empty if type==kTypeDeletion.\n+  void Add(SequenceNumber seq, ValueType type,\n+           const Slice& key,\n+           const Slice& value);\n+\n+  // If memtable contains a value for key, store it in *value and return true.\n+  // If memtable contains a deletion for key, store a NotFound() error\n+  // in *status and return true.\n+  // Else, return false.\n+  bool Get(const LookupKey& key, std::string* value, Status* s);\n+\n+ private:\n+  ~MemTable();  // Private since only Unref() should be used to delete it\n+\n+  struct KeyComparator {\n+    const InternalKeyComparator comparator;\n+    explicit KeyComparator(const InternalKeyComparator& c) : comparator(c) { }\n+    int operator()(const char* a, const char* b) const;\n+  };\n+  friend class MemTableIterator;\n+  friend class MemTableBackwardIterator;\n+\n+  typedef SkipList<const char*, KeyComparator> Table;\n+\n+  KeyComparator comparator_;\n+  int refs_;\n+  Arena arena_;\n+  Table table_;\n+\n+  // No copying allowed\n+  MemTable(const MemTable&);\n+  void operator=(const MemTable&);\n+};\n+\n+}  // namespace leveldb\n+\n+#endif  // STORAGE_LEVELDB_DB_MEMTABLE_H_"
      },
      {
        "sha": "022d52f3debe0c0e89a6825ca3778c5894c3783c",
        "filename": "src/leveldb/db/repair.cc",
        "status": "added",
        "additions": 389,
        "deletions": 0,
        "changes": 389,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/repair.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/repair.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/repair.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,389 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+//\n+// We recover the contents of the descriptor from the other files we find.\n+// (1) Any log files are first converted to tables\n+// (2) We scan every table to compute\n+//     (a) smallest/largest for the table\n+//     (b) largest sequence number in the table\n+// (3) We generate descriptor contents:\n+//      - log number is set to zero\n+//      - next-file-number is set to 1 + largest file number we found\n+//      - last-sequence-number is set to largest sequence# found across\n+//        all tables (see 2c)\n+//      - compaction pointers are cleared\n+//      - every table file is added at level 0\n+//\n+// Possible optimization 1:\n+//   (a) Compute total size and use to pick appropriate max-level M\n+//   (b) Sort tables by largest sequence# in the table\n+//   (c) For each table: if it overlaps earlier table, place in level-0,\n+//       else place in level-M.\n+// Possible optimization 2:\n+//   Store per-table metadata (smallest, largest, largest-seq#, ...)\n+//   in the table's meta section to speed up ScanTable.\n+\n+#include \"db/builder.h\"\n+#include \"db/db_impl.h\"\n+#include \"db/dbformat.h\"\n+#include \"db/filename.h\"\n+#include \"db/log_reader.h\"\n+#include \"db/log_writer.h\"\n+#include \"db/memtable.h\"\n+#include \"db/table_cache.h\"\n+#include \"db/version_edit.h\"\n+#include \"db/write_batch_internal.h\"\n+#include \"leveldb/comparator.h\"\n+#include \"leveldb/db.h\"\n+#include \"leveldb/env.h\"\n+\n+namespace leveldb {\n+\n+namespace {\n+\n+class Repairer {\n+ public:\n+  Repairer(const std::string& dbname, const Options& options)\n+      : dbname_(dbname),\n+        env_(options.env),\n+        icmp_(options.comparator),\n+        ipolicy_(options.filter_policy),\n+        options_(SanitizeOptions(dbname, &icmp_, &ipolicy_, options)),\n+        owns_info_log_(options_.info_log != options.info_log),\n+        owns_cache_(options_.block_cache != options.block_cache),\n+        next_file_number_(1) {\n+    // TableCache can be small since we expect each table to be opened once.\n+    table_cache_ = new TableCache(dbname_, &options_, 10);\n+  }\n+\n+  ~Repairer() {\n+    delete table_cache_;\n+    if (owns_info_log_) {\n+      delete options_.info_log;\n+    }\n+    if (owns_cache_) {\n+      delete options_.block_cache;\n+    }\n+  }\n+\n+  Status Run() {\n+    Status status = FindFiles();\n+    if (status.ok()) {\n+      ConvertLogFilesToTables();\n+      ExtractMetaData();\n+      status = WriteDescriptor();\n+    }\n+    if (status.ok()) {\n+      unsigned long long bytes = 0;\n+      for (size_t i = 0; i < tables_.size(); i++) {\n+        bytes += tables_[i].meta.file_size;\n+      }\n+      Log(options_.info_log,\n+          \"**** Repaired leveldb %s; \"\n+          \"recovered %d files; %llu bytes. \"\n+          \"Some data may have been lost. \"\n+          \"****\",\n+          dbname_.c_str(),\n+          static_cast<int>(tables_.size()),\n+          bytes);\n+    }\n+    return status;\n+  }\n+\n+ private:\n+  struct TableInfo {\n+    FileMetaData meta;\n+    SequenceNumber max_sequence;\n+  };\n+\n+  std::string const dbname_;\n+  Env* const env_;\n+  InternalKeyComparator const icmp_;\n+  InternalFilterPolicy const ipolicy_;\n+  Options const options_;\n+  bool owns_info_log_;\n+  bool owns_cache_;\n+  TableCache* table_cache_;\n+  VersionEdit edit_;\n+\n+  std::vector<std::string> manifests_;\n+  std::vector<uint64_t> table_numbers_;\n+  std::vector<uint64_t> logs_;\n+  std::vector<TableInfo> tables_;\n+  uint64_t next_file_number_;\n+\n+  Status FindFiles() {\n+    std::vector<std::string> filenames;\n+    Status status = env_->GetChildren(dbname_, &filenames);\n+    if (!status.ok()) {\n+      return status;\n+    }\n+    if (filenames.empty()) {\n+      return Status::IOError(dbname_, \"repair found no files\");\n+    }\n+\n+    uint64_t number;\n+    FileType type;\n+    for (size_t i = 0; i < filenames.size(); i++) {\n+      if (ParseFileName(filenames[i], &number, &type)) {\n+        if (type == kDescriptorFile) {\n+          manifests_.push_back(filenames[i]);\n+        } else {\n+          if (number + 1 > next_file_number_) {\n+            next_file_number_ = number + 1;\n+          }\n+          if (type == kLogFile) {\n+            logs_.push_back(number);\n+          } else if (type == kTableFile) {\n+            table_numbers_.push_back(number);\n+          } else {\n+            // Ignore other files\n+          }\n+        }\n+      }\n+    }\n+    return status;\n+  }\n+\n+  void ConvertLogFilesToTables() {\n+    for (size_t i = 0; i < logs_.size(); i++) {\n+      std::string logname = LogFileName(dbname_, logs_[i]);\n+      Status status = ConvertLogToTable(logs_[i]);\n+      if (!status.ok()) {\n+        Log(options_.info_log, \"Log #%llu: ignoring conversion error: %s\",\n+            (unsigned long long) logs_[i],\n+            status.ToString().c_str());\n+      }\n+      ArchiveFile(logname);\n+    }\n+  }\n+\n+  Status ConvertLogToTable(uint64_t log) {\n+    struct LogReporter : public log::Reader::Reporter {\n+      Env* env;\n+      Logger* info_log;\n+      uint64_t lognum;\n+      virtual void Corruption(size_t bytes, const Status& s) {\n+        // We print error messages for corruption, but continue repairing.\n+        Log(info_log, \"Log #%llu: dropping %d bytes; %s\",\n+            (unsigned long long) lognum,\n+            static_cast<int>(bytes),\n+            s.ToString().c_str());\n+      }\n+    };\n+\n+    // Open the log file\n+    std::string logname = LogFileName(dbname_, log);\n+    SequentialFile* lfile;\n+    Status status = env_->NewSequentialFile(logname, &lfile);\n+    if (!status.ok()) {\n+      return status;\n+    }\n+\n+    // Create the log reader.\n+    LogReporter reporter;\n+    reporter.env = env_;\n+    reporter.info_log = options_.info_log;\n+    reporter.lognum = log;\n+    // We intentially make log::Reader do checksumming so that\n+    // corruptions cause entire commits to be skipped instead of\n+    // propagating bad information (like overly large sequence\n+    // numbers).\n+    log::Reader reader(lfile, &reporter, false/*do not checksum*/,\n+                       0/*initial_offset*/);\n+\n+    // Read all the records and add to a memtable\n+    std::string scratch;\n+    Slice record;\n+    WriteBatch batch;\n+    MemTable* mem = new MemTable(icmp_);\n+    mem->Ref();\n+    int counter = 0;\n+    while (reader.ReadRecord(&record, &scratch)) {\n+      if (record.size() < 12) {\n+        reporter.Corruption(\n+            record.size(), Status::Corruption(\"log record too small\"));\n+        continue;\n+      }\n+      WriteBatchInternal::SetContents(&batch, record);\n+      status = WriteBatchInternal::InsertInto(&batch, mem);\n+      if (status.ok()) {\n+        counter += WriteBatchInternal::Count(&batch);\n+      } else {\n+        Log(options_.info_log, \"Log #%llu: ignoring %s\",\n+            (unsigned long long) log,\n+            status.ToString().c_str());\n+        status = Status::OK();  // Keep going with rest of file\n+      }\n+    }\n+    delete lfile;\n+\n+    // Do not record a version edit for this conversion to a Table\n+    // since ExtractMetaData() will also generate edits.\n+    FileMetaData meta;\n+    meta.number = next_file_number_++;\n+    Iterator* iter = mem->NewIterator();\n+    status = BuildTable(dbname_, env_, options_, table_cache_, iter, &meta);\n+    delete iter;\n+    mem->Unref();\n+    mem = NULL;\n+    if (status.ok()) {\n+      if (meta.file_size > 0) {\n+        table_numbers_.push_back(meta.number);\n+      }\n+    }\n+    Log(options_.info_log, \"Log #%llu: %d ops saved to Table #%llu %s\",\n+        (unsigned long long) log,\n+        counter,\n+        (unsigned long long) meta.number,\n+        status.ToString().c_str());\n+    return status;\n+  }\n+\n+  void ExtractMetaData() {\n+    std::vector<TableInfo> kept;\n+    for (size_t i = 0; i < table_numbers_.size(); i++) {\n+      TableInfo t;\n+      t.meta.number = table_numbers_[i];\n+      Status status = ScanTable(&t);\n+      if (!status.ok()) {\n+        std::string fname = TableFileName(dbname_, table_numbers_[i]);\n+        Log(options_.info_log, \"Table #%llu: ignoring %s\",\n+            (unsigned long long) table_numbers_[i],\n+            status.ToString().c_str());\n+        ArchiveFile(fname);\n+      } else {\n+        tables_.push_back(t);\n+      }\n+    }\n+  }\n+\n+  Status ScanTable(TableInfo* t) {\n+    std::string fname = TableFileName(dbname_, t->meta.number);\n+    int counter = 0;\n+    Status status = env_->GetFileSize(fname, &t->meta.file_size);\n+    if (status.ok()) {\n+      Iterator* iter = table_cache_->NewIterator(\n+          ReadOptions(), t->meta.number, t->meta.file_size);\n+      bool empty = true;\n+      ParsedInternalKey parsed;\n+      t->max_sequence = 0;\n+      for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n+        Slice key = iter->key();\n+        if (!ParseInternalKey(key, &parsed)) {\n+          Log(options_.info_log, \"Table #%llu: unparsable key %s\",\n+              (unsigned long long) t->meta.number,\n+              EscapeString(key).c_str());\n+          continue;\n+        }\n+\n+        counter++;\n+        if (empty) {\n+          empty = false;\n+          t->meta.smallest.DecodeFrom(key);\n+        }\n+        t->meta.largest.DecodeFrom(key);\n+        if (parsed.sequence > t->max_sequence) {\n+          t->max_sequence = parsed.sequence;\n+        }\n+      }\n+      if (!iter->status().ok()) {\n+        status = iter->status();\n+      }\n+      delete iter;\n+    }\n+    Log(options_.info_log, \"Table #%llu: %d entries %s\",\n+        (unsigned long long) t->meta.number,\n+        counter,\n+        status.ToString().c_str());\n+    return status;\n+  }\n+\n+  Status WriteDescriptor() {\n+    std::string tmp = TempFileName(dbname_, 1);\n+    WritableFile* file;\n+    Status status = env_->NewWritableFile(tmp, &file);\n+    if (!status.ok()) {\n+      return status;\n+    }\n+\n+    SequenceNumber max_sequence = 0;\n+    for (size_t i = 0; i < tables_.size(); i++) {\n+      if (max_sequence < tables_[i].max_sequence) {\n+        max_sequence = tables_[i].max_sequence;\n+      }\n+    }\n+\n+    edit_.SetComparatorName(icmp_.user_comparator()->Name());\n+    edit_.SetLogNumber(0);\n+    edit_.SetNextFile(next_file_number_);\n+    edit_.SetLastSequence(max_sequence);\n+\n+    for (size_t i = 0; i < tables_.size(); i++) {\n+      // TODO(opt): separate out into multiple levels\n+      const TableInfo& t = tables_[i];\n+      edit_.AddFile(0, t.meta.number, t.meta.file_size,\n+                    t.meta.smallest, t.meta.largest);\n+    }\n+\n+    //fprintf(stderr, \"NewDescriptor:\\n%s\\n\", edit_.DebugString().c_str());\n+    {\n+      log::Writer log(file);\n+      std::string record;\n+      edit_.EncodeTo(&record);\n+      status = log.AddRecord(record);\n+    }\n+    if (status.ok()) {\n+      status = file->Close();\n+    }\n+    delete file;\n+    file = NULL;\n+\n+    if (!status.ok()) {\n+      env_->DeleteFile(tmp);\n+    } else {\n+      // Discard older manifests\n+      for (size_t i = 0; i < manifests_.size(); i++) {\n+        ArchiveFile(dbname_ + \"/\" + manifests_[i]);\n+      }\n+\n+      // Install new manifest\n+      status = env_->RenameFile(tmp, DescriptorFileName(dbname_, 1));\n+      if (status.ok()) {\n+        status = SetCurrentFile(env_, dbname_, 1);\n+      } else {\n+        env_->DeleteFile(tmp);\n+      }\n+    }\n+    return status;\n+  }\n+\n+  void ArchiveFile(const std::string& fname) {\n+    // Move into another directory.  E.g., for\n+    //    dir/foo\n+    // rename to\n+    //    dir/lost/foo\n+    const char* slash = strrchr(fname.c_str(), '/');\n+    std::string new_dir;\n+    if (slash != NULL) {\n+      new_dir.assign(fname.data(), slash - fname.data());\n+    }\n+    new_dir.append(\"/lost\");\n+    env_->CreateDir(new_dir);  // Ignore error\n+    std::string new_file = new_dir;\n+    new_file.append(\"/\");\n+    new_file.append((slash == NULL) ? fname.c_str() : slash + 1);\n+    Status s = env_->RenameFile(fname, new_file);\n+    Log(options_.info_log, \"Archiving %s: %s\\n\",\n+        fname.c_str(), s.ToString().c_str());\n+  }\n+};\n+}  // namespace\n+\n+Status RepairDB(const std::string& dbname, const Options& options) {\n+  Repairer repairer(dbname, options);\n+  return repairer.Run();\n+}\n+\n+}  // namespace leveldb"
      },
      {
        "sha": "af85be6d01621b249f1756b2af5fd6078dd2ee25",
        "filename": "src/leveldb/db/skiplist.h",
        "status": "added",
        "additions": 379,
        "deletions": 0,
        "changes": 379,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/skiplist.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/skiplist.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/skiplist.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,379 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+//\n+// Thread safety\n+// -------------\n+//\n+// Writes require external synchronization, most likely a mutex.\n+// Reads require a guarantee that the SkipList will not be destroyed\n+// while the read is in progress.  Apart from that, reads progress\n+// without any internal locking or synchronization.\n+//\n+// Invariants:\n+//\n+// (1) Allocated nodes are never deleted until the SkipList is\n+// destroyed.  This is trivially guaranteed by the code since we\n+// never delete any skip list nodes.\n+//\n+// (2) The contents of a Node except for the next/prev pointers are\n+// immutable after the Node has been linked into the SkipList.\n+// Only Insert() modifies the list, and it is careful to initialize\n+// a node and use release-stores to publish the nodes in one or\n+// more lists.\n+//\n+// ... prev vs. next pointer ordering ...\n+\n+#include <assert.h>\n+#include <stdlib.h>\n+#include \"port/port.h\"\n+#include \"util/arena.h\"\n+#include \"util/random.h\"\n+\n+namespace leveldb {\n+\n+class Arena;\n+\n+template<typename Key, class Comparator>\n+class SkipList {\n+ private:\n+  struct Node;\n+\n+ public:\n+  // Create a new SkipList object that will use \"cmp\" for comparing keys,\n+  // and will allocate memory using \"*arena\".  Objects allocated in the arena\n+  // must remain allocated for the lifetime of the skiplist object.\n+  explicit SkipList(Comparator cmp, Arena* arena);\n+\n+  // Insert key into the list.\n+  // REQUIRES: nothing that compares equal to key is currently in the list.\n+  void Insert(const Key& key);\n+\n+  // Returns true iff an entry that compares equal to key is in the list.\n+  bool Contains(const Key& key) const;\n+\n+  // Iteration over the contents of a skip list\n+  class Iterator {\n+   public:\n+    // Initialize an iterator over the specified list.\n+    // The returned iterator is not valid.\n+    explicit Iterator(const SkipList* list);\n+\n+    // Returns true iff the iterator is positioned at a valid node.\n+    bool Valid() const;\n+\n+    // Returns the key at the current position.\n+    // REQUIRES: Valid()\n+    const Key& key() const;\n+\n+    // Advances to the next position.\n+    // REQUIRES: Valid()\n+    void Next();\n+\n+    // Advances to the previous position.\n+    // REQUIRES: Valid()\n+    void Prev();\n+\n+    // Advance to the first entry with a key >= target\n+    void Seek(const Key& target);\n+\n+    // Position at the first entry in list.\n+    // Final state of iterator is Valid() iff list is not empty.\n+    void SeekToFirst();\n+\n+    // Position at the last entry in list.\n+    // Final state of iterator is Valid() iff list is not empty.\n+    void SeekToLast();\n+\n+   private:\n+    const SkipList* list_;\n+    Node* node_;\n+    // Intentionally copyable\n+  };\n+\n+ private:\n+  enum { kMaxHeight = 12 };\n+\n+  // Immutable after construction\n+  Comparator const compare_;\n+  Arena* const arena_;    // Arena used for allocations of nodes\n+\n+  Node* const head_;\n+\n+  // Modified only by Insert().  Read racily by readers, but stale\n+  // values are ok.\n+  port::AtomicPointer max_height_;   // Height of the entire list\n+\n+  inline int GetMaxHeight() const {\n+    return static_cast<int>(\n+        reinterpret_cast<intptr_t>(max_height_.NoBarrier_Load()));\n+  }\n+\n+  // Read/written only by Insert().\n+  Random rnd_;\n+\n+  Node* NewNode(const Key& key, int height);\n+  int RandomHeight();\n+  bool Equal(const Key& a, const Key& b) const { return (compare_(a, b) == 0); }\n+\n+  // Return true if key is greater than the data stored in \"n\"\n+  bool KeyIsAfterNode(const Key& key, Node* n) const;\n+\n+  // Return the earliest node that comes at or after key.\n+  // Return NULL if there is no such node.\n+  //\n+  // If prev is non-NULL, fills prev[level] with pointer to previous\n+  // node at \"level\" for every level in [0..max_height_-1].\n+  Node* FindGreaterOrEqual(const Key& key, Node** prev) const;\n+\n+  // Return the latest node with a key < key.\n+  // Return head_ if there is no such node.\n+  Node* FindLessThan(const Key& key) const;\n+\n+  // Return the last node in the list.\n+  // Return head_ if list is empty.\n+  Node* FindLast() const;\n+\n+  // No copying allowed\n+  SkipList(const SkipList&);\n+  void operator=(const SkipList&);\n+};\n+\n+// Implementation details follow\n+template<typename Key, class Comparator>\n+struct SkipList<Key,Comparator>::Node {\n+  explicit Node(const Key& k) : key(k) { }\n+\n+  Key const key;\n+\n+  // Accessors/mutators for links.  Wrapped in methods so we can\n+  // add the appropriate barriers as necessary.\n+  Node* Next(int n) {\n+    assert(n >= 0);\n+    // Use an 'acquire load' so that we observe a fully initialized\n+    // version of the returned Node.\n+    return reinterpret_cast<Node*>(next_[n].Acquire_Load());\n+  }\n+  void SetNext(int n, Node* x) {\n+    assert(n >= 0);\n+    // Use a 'release store' so that anybody who reads through this\n+    // pointer observes a fully initialized version of the inserted node.\n+    next_[n].Release_Store(x);\n+  }\n+\n+  // No-barrier variants that can be safely used in a few locations.\n+  Node* NoBarrier_Next(int n) {\n+    assert(n >= 0);\n+    return reinterpret_cast<Node*>(next_[n].NoBarrier_Load());\n+  }\n+  void NoBarrier_SetNext(int n, Node* x) {\n+    assert(n >= 0);\n+    next_[n].NoBarrier_Store(x);\n+  }\n+\n+ private:\n+  // Array of length equal to the node height.  next_[0] is lowest level link.\n+  port::AtomicPointer next_[1];\n+};\n+\n+template<typename Key, class Comparator>\n+typename SkipList<Key,Comparator>::Node*\n+SkipList<Key,Comparator>::NewNode(const Key& key, int height) {\n+  char* mem = arena_->AllocateAligned(\n+      sizeof(Node) + sizeof(port::AtomicPointer) * (height - 1));\n+  return new (mem) Node(key);\n+}\n+\n+template<typename Key, class Comparator>\n+inline SkipList<Key,Comparator>::Iterator::Iterator(const SkipList* list) {\n+  list_ = list;\n+  node_ = NULL;\n+}\n+\n+template<typename Key, class Comparator>\n+inline bool SkipList<Key,Comparator>::Iterator::Valid() const {\n+  return node_ != NULL;\n+}\n+\n+template<typename Key, class Comparator>\n+inline const Key& SkipList<Key,Comparator>::Iterator::key() const {\n+  assert(Valid());\n+  return node_->key;\n+}\n+\n+template<typename Key, class Comparator>\n+inline void SkipList<Key,Comparator>::Iterator::Next() {\n+  assert(Valid());\n+  node_ = node_->Next(0);\n+}\n+\n+template<typename Key, class Comparator>\n+inline void SkipList<Key,Comparator>::Iterator::Prev() {\n+  // Instead of using explicit \"prev\" links, we just search for the\n+  // last node that falls before key.\n+  assert(Valid());\n+  node_ = list_->FindLessThan(node_->key);\n+  if (node_ == list_->head_) {\n+    node_ = NULL;\n+  }\n+}\n+\n+template<typename Key, class Comparator>\n+inline void SkipList<Key,Comparator>::Iterator::Seek(const Key& target) {\n+  node_ = list_->FindGreaterOrEqual(target, NULL);\n+}\n+\n+template<typename Key, class Comparator>\n+inline void SkipList<Key,Comparator>::Iterator::SeekToFirst() {\n+  node_ = list_->head_->Next(0);\n+}\n+\n+template<typename Key, class Comparator>\n+inline void SkipList<Key,Comparator>::Iterator::SeekToLast() {\n+  node_ = list_->FindLast();\n+  if (node_ == list_->head_) {\n+    node_ = NULL;\n+  }\n+}\n+\n+template<typename Key, class Comparator>\n+int SkipList<Key,Comparator>::RandomHeight() {\n+  // Increase height with probability 1 in kBranching\n+  static const unsigned int kBranching = 4;\n+  int height = 1;\n+  while (height < kMaxHeight && ((rnd_.Next() % kBranching) == 0)) {\n+    height++;\n+  }\n+  assert(height > 0);\n+  assert(height <= kMaxHeight);\n+  return height;\n+}\n+\n+template<typename Key, class Comparator>\n+bool SkipList<Key,Comparator>::KeyIsAfterNode(const Key& key, Node* n) const {\n+  // NULL n is considered infinite\n+  return (n != NULL) && (compare_(n->key, key) < 0);\n+}\n+\n+template<typename Key, class Comparator>\n+typename SkipList<Key,Comparator>::Node* SkipList<Key,Comparator>::FindGreaterOrEqual(const Key& key, Node** prev)\n+    const {\n+  Node* x = head_;\n+  int level = GetMaxHeight() - 1;\n+  while (true) {\n+    Node* next = x->Next(level);\n+    if (KeyIsAfterNode(key, next)) {\n+      // Keep searching in this list\n+      x = next;\n+    } else {\n+      if (prev != NULL) prev[level] = x;\n+      if (level == 0) {\n+        return next;\n+      } else {\n+        // Switch to next list\n+        level--;\n+      }\n+    }\n+  }\n+}\n+\n+template<typename Key, class Comparator>\n+typename SkipList<Key,Comparator>::Node*\n+SkipList<Key,Comparator>::FindLessThan(const Key& key) const {\n+  Node* x = head_;\n+  int level = GetMaxHeight() - 1;\n+  while (true) {\n+    assert(x == head_ || compare_(x->key, key) < 0);\n+    Node* next = x->Next(level);\n+    if (next == NULL || compare_(next->key, key) >= 0) {\n+      if (level == 0) {\n+        return x;\n+      } else {\n+        // Switch to next list\n+        level--;\n+      }\n+    } else {\n+      x = next;\n+    }\n+  }\n+}\n+\n+template<typename Key, class Comparator>\n+typename SkipList<Key,Comparator>::Node* SkipList<Key,Comparator>::FindLast()\n+    const {\n+  Node* x = head_;\n+  int level = GetMaxHeight() - 1;\n+  while (true) {\n+    Node* next = x->Next(level);\n+    if (next == NULL) {\n+      if (level == 0) {\n+        return x;\n+      } else {\n+        // Switch to next list\n+        level--;\n+      }\n+    } else {\n+      x = next;\n+    }\n+  }\n+}\n+\n+template<typename Key, class Comparator>\n+SkipList<Key,Comparator>::SkipList(Comparator cmp, Arena* arena)\n+    : compare_(cmp),\n+      arena_(arena),\n+      head_(NewNode(0 /* any key will do */, kMaxHeight)),\n+      max_height_(reinterpret_cast<void*>(1)),\n+      rnd_(0xdeadbeef) {\n+  for (int i = 0; i < kMaxHeight; i++) {\n+    head_->SetNext(i, NULL);\n+  }\n+}\n+\n+template<typename Key, class Comparator>\n+void SkipList<Key,Comparator>::Insert(const Key& key) {\n+  // TODO(opt): We can use a barrier-free variant of FindGreaterOrEqual()\n+  // here since Insert() is externally synchronized.\n+  Node* prev[kMaxHeight];\n+  Node* x = FindGreaterOrEqual(key, prev);\n+\n+  // Our data structure does not allow duplicate insertion\n+  assert(x == NULL || !Equal(key, x->key));\n+\n+  int height = RandomHeight();\n+  if (height > GetMaxHeight()) {\n+    for (int i = GetMaxHeight(); i < height; i++) {\n+      prev[i] = head_;\n+    }\n+    //fprintf(stderr, \"Change height from %d to %d\\n\", max_height_, height);\n+\n+    // It is ok to mutate max_height_ without any synchronization\n+    // with concurrent readers.  A concurrent reader that observes\n+    // the new value of max_height_ will see either the old value of\n+    // new level pointers from head_ (NULL), or a new value set in\n+    // the loop below.  In the former case the reader will\n+    // immediately drop to the next level since NULL sorts after all\n+    // keys.  In the latter case the reader will use the new node.\n+    max_height_.NoBarrier_Store(reinterpret_cast<void*>(height));\n+  }\n+\n+  x = NewNode(key, height);\n+  for (int i = 0; i < height; i++) {\n+    // NoBarrier_SetNext() suffices since we will add a barrier when\n+    // we publish a pointer to \"x\" in prev[i].\n+    x->NoBarrier_SetNext(i, prev[i]->NoBarrier_Next(i));\n+    prev[i]->SetNext(i, x);\n+  }\n+}\n+\n+template<typename Key, class Comparator>\n+bool SkipList<Key,Comparator>::Contains(const Key& key) const {\n+  Node* x = FindGreaterOrEqual(key, NULL);\n+  if (x != NULL && Equal(key, x->key)) {\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+}  // namespace leveldb"
      },
      {
        "sha": "c78f4b4fb1a0fc7fb5aadbefa0f7d19eaf06ba1b",
        "filename": "src/leveldb/db/skiplist_test.cc",
        "status": "added",
        "additions": 378,
        "deletions": 0,
        "changes": 378,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/skiplist_test.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/skiplist_test.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/skiplist_test.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,378 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include \"db/skiplist.h\"\n+#include <set>\n+#include \"leveldb/env.h\"\n+#include \"util/arena.h\"\n+#include \"util/hash.h\"\n+#include \"util/random.h\"\n+#include \"util/testharness.h\"\n+\n+namespace leveldb {\n+\n+typedef uint64_t Key;\n+\n+struct Comparator {\n+  int operator()(const Key& a, const Key& b) const {\n+    if (a < b) {\n+      return -1;\n+    } else if (a > b) {\n+      return +1;\n+    } else {\n+      return 0;\n+    }\n+  }\n+};\n+\n+class SkipTest { };\n+\n+TEST(SkipTest, Empty) {\n+  Arena arena;\n+  Comparator cmp;\n+  SkipList<Key, Comparator> list(cmp, &arena);\n+  ASSERT_TRUE(!list.Contains(10));\n+\n+  SkipList<Key, Comparator>::Iterator iter(&list);\n+  ASSERT_TRUE(!iter.Valid());\n+  iter.SeekToFirst();\n+  ASSERT_TRUE(!iter.Valid());\n+  iter.Seek(100);\n+  ASSERT_TRUE(!iter.Valid());\n+  iter.SeekToLast();\n+  ASSERT_TRUE(!iter.Valid());\n+}\n+\n+TEST(SkipTest, InsertAndLookup) {\n+  const int N = 2000;\n+  const int R = 5000;\n+  Random rnd(1000);\n+  std::set<Key> keys;\n+  Arena arena;\n+  Comparator cmp;\n+  SkipList<Key, Comparator> list(cmp, &arena);\n+  for (int i = 0; i < N; i++) {\n+    Key key = rnd.Next() % R;\n+    if (keys.insert(key).second) {\n+      list.Insert(key);\n+    }\n+  }\n+\n+  for (int i = 0; i < R; i++) {\n+    if (list.Contains(i)) {\n+      ASSERT_EQ(keys.count(i), 1);\n+    } else {\n+      ASSERT_EQ(keys.count(i), 0);\n+    }\n+  }\n+\n+  // Simple iterator tests\n+  {\n+    SkipList<Key, Comparator>::Iterator iter(&list);\n+    ASSERT_TRUE(!iter.Valid());\n+\n+    iter.Seek(0);\n+    ASSERT_TRUE(iter.Valid());\n+    ASSERT_EQ(*(keys.begin()), iter.key());\n+\n+    iter.SeekToFirst();\n+    ASSERT_TRUE(iter.Valid());\n+    ASSERT_EQ(*(keys.begin()), iter.key());\n+\n+    iter.SeekToLast();\n+    ASSERT_TRUE(iter.Valid());\n+    ASSERT_EQ(*(keys.rbegin()), iter.key());\n+  }\n+\n+  // Forward iteration test\n+  for (int i = 0; i < R; i++) {\n+    SkipList<Key, Comparator>::Iterator iter(&list);\n+    iter.Seek(i);\n+\n+    // Compare against model iterator\n+    std::set<Key>::iterator model_iter = keys.lower_bound(i);\n+    for (int j = 0; j < 3; j++) {\n+      if (model_iter == keys.end()) {\n+        ASSERT_TRUE(!iter.Valid());\n+        break;\n+      } else {\n+        ASSERT_TRUE(iter.Valid());\n+        ASSERT_EQ(*model_iter, iter.key());\n+        ++model_iter;\n+        iter.Next();\n+      }\n+    }\n+  }\n+\n+  // Backward iteration test\n+  {\n+    SkipList<Key, Comparator>::Iterator iter(&list);\n+    iter.SeekToLast();\n+\n+    // Compare against model iterator\n+    for (std::set<Key>::reverse_iterator model_iter = keys.rbegin();\n+         model_iter != keys.rend();\n+         ++model_iter) {\n+      ASSERT_TRUE(iter.Valid());\n+      ASSERT_EQ(*model_iter, iter.key());\n+      iter.Prev();\n+    }\n+    ASSERT_TRUE(!iter.Valid());\n+  }\n+}\n+\n+// We want to make sure that with a single writer and multiple\n+// concurrent readers (with no synchronization other than when a\n+// reader's iterator is created), the reader always observes all the\n+// data that was present in the skip list when the iterator was\n+// constructor.  Because insertions are happening concurrently, we may\n+// also observe new values that were inserted since the iterator was\n+// constructed, but we should never miss any values that were present\n+// at iterator construction time.\n+//\n+// We generate multi-part keys:\n+//     <key,gen,hash>\n+// where:\n+//     key is in range [0..K-1]\n+//     gen is a generation number for key\n+//     hash is hash(key,gen)\n+//\n+// The insertion code picks a random key, sets gen to be 1 + the last\n+// generation number inserted for that key, and sets hash to Hash(key,gen).\n+//\n+// At the beginning of a read, we snapshot the last inserted\n+// generation number for each key.  We then iterate, including random\n+// calls to Next() and Seek().  For every key we encounter, we\n+// check that it is either expected given the initial snapshot or has\n+// been concurrently added since the iterator started.\n+class ConcurrentTest {\n+ private:\n+  static const uint32_t K = 4;\n+\n+  static uint64_t key(Key key) { return (key >> 40); }\n+  static uint64_t gen(Key key) { return (key >> 8) & 0xffffffffu; }\n+  static uint64_t hash(Key key) { return key & 0xff; }\n+\n+  static uint64_t HashNumbers(uint64_t k, uint64_t g) {\n+    uint64_t data[2] = { k, g };\n+    return Hash(reinterpret_cast<char*>(data), sizeof(data), 0);\n+  }\n+\n+  static Key MakeKey(uint64_t k, uint64_t g) {\n+    assert(sizeof(Key) == sizeof(uint64_t));\n+    assert(k <= K);  // We sometimes pass K to seek to the end of the skiplist\n+    assert(g <= 0xffffffffu);\n+    return ((k << 40) | (g << 8) | (HashNumbers(k, g) & 0xff));\n+  }\n+\n+  static bool IsValidKey(Key k) {\n+    return hash(k) == (HashNumbers(key(k), gen(k)) & 0xff);\n+  }\n+\n+  static Key RandomTarget(Random* rnd) {\n+    switch (rnd->Next() % 10) {\n+      case 0:\n+        // Seek to beginning\n+        return MakeKey(0, 0);\n+      case 1:\n+        // Seek to end\n+        return MakeKey(K, 0);\n+      default:\n+        // Seek to middle\n+        return MakeKey(rnd->Next() % K, 0);\n+    }\n+  }\n+\n+  // Per-key generation\n+  struct State {\n+    port::AtomicPointer generation[K];\n+    void Set(int k, intptr_t v) {\n+      generation[k].Release_Store(reinterpret_cast<void*>(v));\n+    }\n+    intptr_t Get(int k) {\n+      return reinterpret_cast<intptr_t>(generation[k].Acquire_Load());\n+    }\n+\n+    State() {\n+      for (int k = 0; k < K; k++) {\n+        Set(k, 0);\n+      }\n+    }\n+  };\n+\n+  // Current state of the test\n+  State current_;\n+\n+  Arena arena_;\n+\n+  // SkipList is not protected by mu_.  We just use a single writer\n+  // thread to modify it.\n+  SkipList<Key, Comparator> list_;\n+\n+ public:\n+  ConcurrentTest() : list_(Comparator(), &arena_) { }\n+\n+  // REQUIRES: External synchronization\n+  void WriteStep(Random* rnd) {\n+    const uint32_t k = rnd->Next() % K;\n+    const intptr_t g = current_.Get(k) + 1;\n+    const Key key = MakeKey(k, g);\n+    list_.Insert(key);\n+    current_.Set(k, g);\n+  }\n+\n+  void ReadStep(Random* rnd) {\n+    // Remember the initial committed state of the skiplist.\n+    State initial_state;\n+    for (int k = 0; k < K; k++) {\n+      initial_state.Set(k, current_.Get(k));\n+    }\n+\n+    Key pos = RandomTarget(rnd);\n+    SkipList<Key, Comparator>::Iterator iter(&list_);\n+    iter.Seek(pos);\n+    while (true) {\n+      Key current;\n+      if (!iter.Valid()) {\n+        current = MakeKey(K, 0);\n+      } else {\n+        current = iter.key();\n+        ASSERT_TRUE(IsValidKey(current)) << current;\n+      }\n+      ASSERT_LE(pos, current) << \"should not go backwards\";\n+\n+      // Verify that everything in [pos,current) was not present in\n+      // initial_state.\n+      while (pos < current) {\n+        ASSERT_LT(key(pos), K) << pos;\n+\n+        // Note that generation 0 is never inserted, so it is ok if\n+        // <*,0,*> is missing.\n+        ASSERT_TRUE((gen(pos) == 0) ||\n+                    (gen(pos) > initial_state.Get(key(pos)))\n+                    ) << \"key: \" << key(pos)\n+                      << \"; gen: \" << gen(pos)\n+                      << \"; initgen: \"\n+                      << initial_state.Get(key(pos));\n+\n+        // Advance to next key in the valid key space\n+        if (key(pos) < key(current)) {\n+          pos = MakeKey(key(pos) + 1, 0);\n+        } else {\n+          pos = MakeKey(key(pos), gen(pos) + 1);\n+        }\n+      }\n+\n+      if (!iter.Valid()) {\n+        break;\n+      }\n+\n+      if (rnd->Next() % 2) {\n+        iter.Next();\n+        pos = MakeKey(key(pos), gen(pos) + 1);\n+      } else {\n+        Key new_target = RandomTarget(rnd);\n+        if (new_target > pos) {\n+          pos = new_target;\n+          iter.Seek(new_target);\n+        }\n+      }\n+    }\n+  }\n+};\n+const uint32_t ConcurrentTest::K;\n+\n+// Simple test that does single-threaded testing of the ConcurrentTest\n+// scaffolding.\n+TEST(SkipTest, ConcurrentWithoutThreads) {\n+  ConcurrentTest test;\n+  Random rnd(test::RandomSeed());\n+  for (int i = 0; i < 10000; i++) {\n+    test.ReadStep(&rnd);\n+    test.WriteStep(&rnd);\n+  }\n+}\n+\n+class TestState {\n+ public:\n+  ConcurrentTest t_;\n+  int seed_;\n+  port::AtomicPointer quit_flag_;\n+\n+  enum ReaderState {\n+    STARTING,\n+    RUNNING,\n+    DONE\n+  };\n+\n+  explicit TestState(int s)\n+      : seed_(s),\n+        quit_flag_(NULL),\n+        state_(STARTING),\n+        state_cv_(&mu_) {}\n+\n+  void Wait(ReaderState s) {\n+    mu_.Lock();\n+    while (state_ != s) {\n+      state_cv_.Wait();\n+    }\n+    mu_.Unlock();\n+  }\n+\n+  void Change(ReaderState s) {\n+    mu_.Lock();\n+    state_ = s;\n+    state_cv_.Signal();\n+    mu_.Unlock();\n+  }\n+\n+ private:\n+  port::Mutex mu_;\n+  ReaderState state_;\n+  port::CondVar state_cv_;\n+};\n+\n+static void ConcurrentReader(void* arg) {\n+  TestState* state = reinterpret_cast<TestState*>(arg);\n+  Random rnd(state->seed_);\n+  int64_t reads = 0;\n+  state->Change(TestState::RUNNING);\n+  while (!state->quit_flag_.Acquire_Load()) {\n+    state->t_.ReadStep(&rnd);\n+    ++reads;\n+  }\n+  state->Change(TestState::DONE);\n+}\n+\n+static void RunConcurrent(int run) {\n+  const int seed = test::RandomSeed() + (run * 100);\n+  Random rnd(seed);\n+  const int N = 1000;\n+  const int kSize = 1000;\n+  for (int i = 0; i < N; i++) {\n+    if ((i % 100) == 0) {\n+      fprintf(stderr, \"Run %d of %d\\n\", i, N);\n+    }\n+    TestState state(seed + 1);\n+    Env::Default()->Schedule(ConcurrentReader, &state);\n+    state.Wait(TestState::RUNNING);\n+    for (int i = 0; i < kSize; i++) {\n+      state.t_.WriteStep(&rnd);\n+    }\n+    state.quit_flag_.Release_Store(&state);  // Any non-NULL arg will do\n+    state.Wait(TestState::DONE);\n+  }\n+}\n+\n+TEST(SkipTest, Concurrent1) { RunConcurrent(1); }\n+TEST(SkipTest, Concurrent2) { RunConcurrent(2); }\n+TEST(SkipTest, Concurrent3) { RunConcurrent(3); }\n+TEST(SkipTest, Concurrent4) { RunConcurrent(4); }\n+TEST(SkipTest, Concurrent5) { RunConcurrent(5); }\n+\n+}  // namespace leveldb\n+\n+int main(int argc, char** argv) {\n+  return leveldb::test::RunAllTests();\n+}"
      },
      {
        "sha": "e7f8fd2c37cf8a482c45f5524aa729e74f7b3aa7",
        "filename": "src/leveldb/db/snapshot.h",
        "status": "added",
        "additions": 66,
        "deletions": 0,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/snapshot.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/snapshot.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/snapshot.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,66 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#ifndef STORAGE_LEVELDB_DB_SNAPSHOT_H_\n+#define STORAGE_LEVELDB_DB_SNAPSHOT_H_\n+\n+#include \"leveldb/db.h\"\n+\n+namespace leveldb {\n+\n+class SnapshotList;\n+\n+// Snapshots are kept in a doubly-linked list in the DB.\n+// Each SnapshotImpl corresponds to a particular sequence number.\n+class SnapshotImpl : public Snapshot {\n+ public:\n+  SequenceNumber number_;  // const after creation\n+\n+ private:\n+  friend class SnapshotList;\n+\n+  // SnapshotImpl is kept in a doubly-linked circular list\n+  SnapshotImpl* prev_;\n+  SnapshotImpl* next_;\n+\n+  SnapshotList* list_;                 // just for sanity checks\n+};\n+\n+class SnapshotList {\n+ public:\n+  SnapshotList() {\n+    list_.prev_ = &list_;\n+    list_.next_ = &list_;\n+  }\n+\n+  bool empty() const { return list_.next_ == &list_; }\n+  SnapshotImpl* oldest() const { assert(!empty()); return list_.next_; }\n+  SnapshotImpl* newest() const { assert(!empty()); return list_.prev_; }\n+\n+  const SnapshotImpl* New(SequenceNumber seq) {\n+    SnapshotImpl* s = new SnapshotImpl;\n+    s->number_ = seq;\n+    s->list_ = this;\n+    s->next_ = &list_;\n+    s->prev_ = list_.prev_;\n+    s->prev_->next_ = s;\n+    s->next_->prev_ = s;\n+    return s;\n+  }\n+\n+  void Delete(const SnapshotImpl* s) {\n+    assert(s->list_ == this);\n+    s->prev_->next_ = s->next_;\n+    s->next_->prev_ = s->prev_;\n+    delete s;\n+  }\n+\n+ private:\n+  // Dummy head of doubly-linked list of snapshots\n+  SnapshotImpl list_;\n+};\n+\n+}  // namespace leveldb\n+\n+#endif  // STORAGE_LEVELDB_DB_SNAPSHOT_H_"
      },
      {
        "sha": "497db270766d8857ddb355ad09ed0892e4ab2daa",
        "filename": "src/leveldb/db/table_cache.cc",
        "status": "added",
        "additions": 121,
        "deletions": 0,
        "changes": 121,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/table_cache.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/table_cache.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/table_cache.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,121 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include \"db/table_cache.h\"\n+\n+#include \"db/filename.h\"\n+#include \"leveldb/env.h\"\n+#include \"leveldb/table.h\"\n+#include \"util/coding.h\"\n+\n+namespace leveldb {\n+\n+struct TableAndFile {\n+  RandomAccessFile* file;\n+  Table* table;\n+};\n+\n+static void DeleteEntry(const Slice& key, void* value) {\n+  TableAndFile* tf = reinterpret_cast<TableAndFile*>(value);\n+  delete tf->table;\n+  delete tf->file;\n+  delete tf;\n+}\n+\n+static void UnrefEntry(void* arg1, void* arg2) {\n+  Cache* cache = reinterpret_cast<Cache*>(arg1);\n+  Cache::Handle* h = reinterpret_cast<Cache::Handle*>(arg2);\n+  cache->Release(h);\n+}\n+\n+TableCache::TableCache(const std::string& dbname,\n+                       const Options* options,\n+                       int entries)\n+    : env_(options->env),\n+      dbname_(dbname),\n+      options_(options),\n+      cache_(NewLRUCache(entries)) {\n+}\n+\n+TableCache::~TableCache() {\n+  delete cache_;\n+}\n+\n+Status TableCache::FindTable(uint64_t file_number, uint64_t file_size,\n+                             Cache::Handle** handle) {\n+  Status s;\n+  char buf[sizeof(file_number)];\n+  EncodeFixed64(buf, file_number);\n+  Slice key(buf, sizeof(buf));\n+  *handle = cache_->Lookup(key);\n+  if (*handle == NULL) {\n+    std::string fname = TableFileName(dbname_, file_number);\n+    RandomAccessFile* file = NULL;\n+    Table* table = NULL;\n+    s = env_->NewRandomAccessFile(fname, &file);\n+    if (s.ok()) {\n+      s = Table::Open(*options_, file, file_size, &table);\n+    }\n+\n+    if (!s.ok()) {\n+      assert(table == NULL);\n+      delete file;\n+      // We do not cache error results so that if the error is transient,\n+      // or somebody repairs the file, we recover automatically.\n+    } else {\n+      TableAndFile* tf = new TableAndFile;\n+      tf->file = file;\n+      tf->table = table;\n+      *handle = cache_->Insert(key, tf, 1, &DeleteEntry);\n+    }\n+  }\n+  return s;\n+}\n+\n+Iterator* TableCache::NewIterator(const ReadOptions& options,\n+                                  uint64_t file_number,\n+                                  uint64_t file_size,\n+                                  Table** tableptr) {\n+  if (tableptr != NULL) {\n+    *tableptr = NULL;\n+  }\n+\n+  Cache::Handle* handle = NULL;\n+  Status s = FindTable(file_number, file_size, &handle);\n+  if (!s.ok()) {\n+    return NewErrorIterator(s);\n+  }\n+\n+  Table* table = reinterpret_cast<TableAndFile*>(cache_->Value(handle))->table;\n+  Iterator* result = table->NewIterator(options);\n+  result->RegisterCleanup(&UnrefEntry, cache_, handle);\n+  if (tableptr != NULL) {\n+    *tableptr = table;\n+  }\n+  return result;\n+}\n+\n+Status TableCache::Get(const ReadOptions& options,\n+                       uint64_t file_number,\n+                       uint64_t file_size,\n+                       const Slice& k,\n+                       void* arg,\n+                       void (*saver)(void*, const Slice&, const Slice&)) {\n+  Cache::Handle* handle = NULL;\n+  Status s = FindTable(file_number, file_size, &handle);\n+  if (s.ok()) {\n+    Table* t = reinterpret_cast<TableAndFile*>(cache_->Value(handle))->table;\n+    s = t->InternalGet(options, k, arg, saver);\n+    cache_->Release(handle);\n+  }\n+  return s;\n+}\n+\n+void TableCache::Evict(uint64_t file_number) {\n+  char buf[sizeof(file_number)];\n+  EncodeFixed64(buf, file_number);\n+  cache_->Erase(Slice(buf, sizeof(buf)));\n+}\n+\n+}  // namespace leveldb"
      },
      {
        "sha": "8cf4aaf12d8ed1a02bd7d1962b79cc8506575b6f",
        "filename": "src/leveldb/db/table_cache.h",
        "status": "added",
        "additions": 61,
        "deletions": 0,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/table_cache.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/table_cache.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/table_cache.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,61 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+//\n+// Thread-safe (provides internal synchronization)\n+\n+#ifndef STORAGE_LEVELDB_DB_TABLE_CACHE_H_\n+#define STORAGE_LEVELDB_DB_TABLE_CACHE_H_\n+\n+#include <string>\n+#include <stdint.h>\n+#include \"db/dbformat.h\"\n+#include \"leveldb/cache.h\"\n+#include \"leveldb/table.h\"\n+#include \"port/port.h\"\n+\n+namespace leveldb {\n+\n+class Env;\n+\n+class TableCache {\n+ public:\n+  TableCache(const std::string& dbname, const Options* options, int entries);\n+  ~TableCache();\n+\n+  // Return an iterator for the specified file number (the corresponding\n+  // file length must be exactly \"file_size\" bytes).  If \"tableptr\" is\n+  // non-NULL, also sets \"*tableptr\" to point to the Table object\n+  // underlying the returned iterator, or NULL if no Table object underlies\n+  // the returned iterator.  The returned \"*tableptr\" object is owned by\n+  // the cache and should not be deleted, and is valid for as long as the\n+  // returned iterator is live.\n+  Iterator* NewIterator(const ReadOptions& options,\n+                        uint64_t file_number,\n+                        uint64_t file_size,\n+                        Table** tableptr = NULL);\n+\n+  // If a seek to internal key \"k\" in specified file finds an entry,\n+  // call (*handle_result)(arg, found_key, found_value).\n+  Status Get(const ReadOptions& options,\n+             uint64_t file_number,\n+             uint64_t file_size,\n+             const Slice& k,\n+             void* arg,\n+             void (*handle_result)(void*, const Slice&, const Slice&));\n+\n+  // Evict any entry for the specified file number\n+  void Evict(uint64_t file_number);\n+\n+ private:\n+  Env* const env_;\n+  const std::string dbname_;\n+  const Options* options_;\n+  Cache* cache_;\n+\n+  Status FindTable(uint64_t file_number, uint64_t file_size, Cache::Handle**);\n+};\n+\n+}  // namespace leveldb\n+\n+#endif  // STORAGE_LEVELDB_DB_TABLE_CACHE_H_"
      },
      {
        "sha": "f10a2d58b211cb16becb0ac0298210f0dacbd2a5",
        "filename": "src/leveldb/db/version_edit.cc",
        "status": "added",
        "additions": 266,
        "deletions": 0,
        "changes": 266,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/version_edit.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/version_edit.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/version_edit.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,266 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include \"db/version_edit.h\"\n+\n+#include \"db/version_set.h\"\n+#include \"util/coding.h\"\n+\n+namespace leveldb {\n+\n+// Tag numbers for serialized VersionEdit.  These numbers are written to\n+// disk and should not be changed.\n+enum Tag {\n+  kComparator           = 1,\n+  kLogNumber            = 2,\n+  kNextFileNumber       = 3,\n+  kLastSequence         = 4,\n+  kCompactPointer       = 5,\n+  kDeletedFile          = 6,\n+  kNewFile              = 7,\n+  // 8 was used for large value refs\n+  kPrevLogNumber        = 9\n+};\n+\n+void VersionEdit::Clear() {\n+  comparator_.clear();\n+  log_number_ = 0;\n+  prev_log_number_ = 0;\n+  last_sequence_ = 0;\n+  next_file_number_ = 0;\n+  has_comparator_ = false;\n+  has_log_number_ = false;\n+  has_prev_log_number_ = false;\n+  has_next_file_number_ = false;\n+  has_last_sequence_ = false;\n+  deleted_files_.clear();\n+  new_files_.clear();\n+}\n+\n+void VersionEdit::EncodeTo(std::string* dst) const {\n+  if (has_comparator_) {\n+    PutVarint32(dst, kComparator);\n+    PutLengthPrefixedSlice(dst, comparator_);\n+  }\n+  if (has_log_number_) {\n+    PutVarint32(dst, kLogNumber);\n+    PutVarint64(dst, log_number_);\n+  }\n+  if (has_prev_log_number_) {\n+    PutVarint32(dst, kPrevLogNumber);\n+    PutVarint64(dst, prev_log_number_);\n+  }\n+  if (has_next_file_number_) {\n+    PutVarint32(dst, kNextFileNumber);\n+    PutVarint64(dst, next_file_number_);\n+  }\n+  if (has_last_sequence_) {\n+    PutVarint32(dst, kLastSequence);\n+    PutVarint64(dst, last_sequence_);\n+  }\n+\n+  for (size_t i = 0; i < compact_pointers_.size(); i++) {\n+    PutVarint32(dst, kCompactPointer);\n+    PutVarint32(dst, compact_pointers_[i].first);  // level\n+    PutLengthPrefixedSlice(dst, compact_pointers_[i].second.Encode());\n+  }\n+\n+  for (DeletedFileSet::const_iterator iter = deleted_files_.begin();\n+       iter != deleted_files_.end();\n+       ++iter) {\n+    PutVarint32(dst, kDeletedFile);\n+    PutVarint32(dst, iter->first);   // level\n+    PutVarint64(dst, iter->second);  // file number\n+  }\n+\n+  for (size_t i = 0; i < new_files_.size(); i++) {\n+    const FileMetaData& f = new_files_[i].second;\n+    PutVarint32(dst, kNewFile);\n+    PutVarint32(dst, new_files_[i].first);  // level\n+    PutVarint64(dst, f.number);\n+    PutVarint64(dst, f.file_size);\n+    PutLengthPrefixedSlice(dst, f.smallest.Encode());\n+    PutLengthPrefixedSlice(dst, f.largest.Encode());\n+  }\n+}\n+\n+static bool GetInternalKey(Slice* input, InternalKey* dst) {\n+  Slice str;\n+  if (GetLengthPrefixedSlice(input, &str)) {\n+    dst->DecodeFrom(str);\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+static bool GetLevel(Slice* input, int* level) {\n+  uint32_t v;\n+  if (GetVarint32(input, &v) &&\n+      v < config::kNumLevels) {\n+    *level = v;\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+Status VersionEdit::DecodeFrom(const Slice& src) {\n+  Clear();\n+  Slice input = src;\n+  const char* msg = NULL;\n+  uint32_t tag;\n+\n+  // Temporary storage for parsing\n+  int level;\n+  uint64_t number;\n+  FileMetaData f;\n+  Slice str;\n+  InternalKey key;\n+\n+  while (msg == NULL && GetVarint32(&input, &tag)) {\n+    switch (tag) {\n+      case kComparator:\n+        if (GetLengthPrefixedSlice(&input, &str)) {\n+          comparator_ = str.ToString();\n+          has_comparator_ = true;\n+        } else {\n+          msg = \"comparator name\";\n+        }\n+        break;\n+\n+      case kLogNumber:\n+        if (GetVarint64(&input, &log_number_)) {\n+          has_log_number_ = true;\n+        } else {\n+          msg = \"log number\";\n+        }\n+        break;\n+\n+      case kPrevLogNumber:\n+        if (GetVarint64(&input, &prev_log_number_)) {\n+          has_prev_log_number_ = true;\n+        } else {\n+          msg = \"previous log number\";\n+        }\n+        break;\n+\n+      case kNextFileNumber:\n+        if (GetVarint64(&input, &next_file_number_)) {\n+          has_next_file_number_ = true;\n+        } else {\n+          msg = \"next file number\";\n+        }\n+        break;\n+\n+      case kLastSequence:\n+        if (GetVarint64(&input, &last_sequence_)) {\n+          has_last_sequence_ = true;\n+        } else {\n+          msg = \"last sequence number\";\n+        }\n+        break;\n+\n+      case kCompactPointer:\n+        if (GetLevel(&input, &level) &&\n+            GetInternalKey(&input, &key)) {\n+          compact_pointers_.push_back(std::make_pair(level, key));\n+        } else {\n+          msg = \"compaction pointer\";\n+        }\n+        break;\n+\n+      case kDeletedFile:\n+        if (GetLevel(&input, &level) &&\n+            GetVarint64(&input, &number)) {\n+          deleted_files_.insert(std::make_pair(level, number));\n+        } else {\n+          msg = \"deleted file\";\n+        }\n+        break;\n+\n+      case kNewFile:\n+        if (GetLevel(&input, &level) &&\n+            GetVarint64(&input, &f.number) &&\n+            GetVarint64(&input, &f.file_size) &&\n+            GetInternalKey(&input, &f.smallest) &&\n+            GetInternalKey(&input, &f.largest)) {\n+          new_files_.push_back(std::make_pair(level, f));\n+        } else {\n+          msg = \"new-file entry\";\n+        }\n+        break;\n+\n+      default:\n+        msg = \"unknown tag\";\n+        break;\n+    }\n+  }\n+\n+  if (msg == NULL && !input.empty()) {\n+    msg = \"invalid tag\";\n+  }\n+\n+  Status result;\n+  if (msg != NULL) {\n+    result = Status::Corruption(\"VersionEdit\", msg);\n+  }\n+  return result;\n+}\n+\n+std::string VersionEdit::DebugString() const {\n+  std::string r;\n+  r.append(\"VersionEdit {\");\n+  if (has_comparator_) {\n+    r.append(\"\\n  Comparator: \");\n+    r.append(comparator_);\n+  }\n+  if (has_log_number_) {\n+    r.append(\"\\n  LogNumber: \");\n+    AppendNumberTo(&r, log_number_);\n+  }\n+  if (has_prev_log_number_) {\n+    r.append(\"\\n  PrevLogNumber: \");\n+    AppendNumberTo(&r, prev_log_number_);\n+  }\n+  if (has_next_file_number_) {\n+    r.append(\"\\n  NextFile: \");\n+    AppendNumberTo(&r, next_file_number_);\n+  }\n+  if (has_last_sequence_) {\n+    r.append(\"\\n  LastSeq: \");\n+    AppendNumberTo(&r, last_sequence_);\n+  }\n+  for (size_t i = 0; i < compact_pointers_.size(); i++) {\n+    r.append(\"\\n  CompactPointer: \");\n+    AppendNumberTo(&r, compact_pointers_[i].first);\n+    r.append(\" \");\n+    r.append(compact_pointers_[i].second.DebugString());\n+  }\n+  for (DeletedFileSet::const_iterator iter = deleted_files_.begin();\n+       iter != deleted_files_.end();\n+       ++iter) {\n+    r.append(\"\\n  DeleteFile: \");\n+    AppendNumberTo(&r, iter->first);\n+    r.append(\" \");\n+    AppendNumberTo(&r, iter->second);\n+  }\n+  for (size_t i = 0; i < new_files_.size(); i++) {\n+    const FileMetaData& f = new_files_[i].second;\n+    r.append(\"\\n  AddFile: \");\n+    AppendNumberTo(&r, new_files_[i].first);\n+    r.append(\" \");\n+    AppendNumberTo(&r, f.number);\n+    r.append(\" \");\n+    AppendNumberTo(&r, f.file_size);\n+    r.append(\" \");\n+    r.append(f.smallest.DebugString());\n+    r.append(\" .. \");\n+    r.append(f.largest.DebugString());\n+  }\n+  r.append(\"\\n}\\n\");\n+  return r;\n+}\n+\n+}  // namespace leveldb"
      },
      {
        "sha": "eaef77b327c64a3756a5f2512bc1786530907cbd",
        "filename": "src/leveldb/db/version_edit.h",
        "status": "added",
        "additions": 107,
        "deletions": 0,
        "changes": 107,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/version_edit.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/version_edit.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/version_edit.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,107 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#ifndef STORAGE_LEVELDB_DB_VERSION_EDIT_H_\n+#define STORAGE_LEVELDB_DB_VERSION_EDIT_H_\n+\n+#include <set>\n+#include <utility>\n+#include <vector>\n+#include \"db/dbformat.h\"\n+\n+namespace leveldb {\n+\n+class VersionSet;\n+\n+struct FileMetaData {\n+  int refs;\n+  int allowed_seeks;          // Seeks allowed until compaction\n+  uint64_t number;\n+  uint64_t file_size;         // File size in bytes\n+  InternalKey smallest;       // Smallest internal key served by table\n+  InternalKey largest;        // Largest internal key served by table\n+\n+  FileMetaData() : refs(0), allowed_seeks(1 << 30), file_size(0) { }\n+};\n+\n+class VersionEdit {\n+ public:\n+  VersionEdit() { Clear(); }\n+  ~VersionEdit() { }\n+\n+  void Clear();\n+\n+  void SetComparatorName(const Slice& name) {\n+    has_comparator_ = true;\n+    comparator_ = name.ToString();\n+  }\n+  void SetLogNumber(uint64_t num) {\n+    has_log_number_ = true;\n+    log_number_ = num;\n+  }\n+  void SetPrevLogNumber(uint64_t num) {\n+    has_prev_log_number_ = true;\n+    prev_log_number_ = num;\n+  }\n+  void SetNextFile(uint64_t num) {\n+    has_next_file_number_ = true;\n+    next_file_number_ = num;\n+  }\n+  void SetLastSequence(SequenceNumber seq) {\n+    has_last_sequence_ = true;\n+    last_sequence_ = seq;\n+  }\n+  void SetCompactPointer(int level, const InternalKey& key) {\n+    compact_pointers_.push_back(std::make_pair(level, key));\n+  }\n+\n+  // Add the specified file at the specified number.\n+  // REQUIRES: This version has not been saved (see VersionSet::SaveTo)\n+  // REQUIRES: \"smallest\" and \"largest\" are smallest and largest keys in file\n+  void AddFile(int level, uint64_t file,\n+               uint64_t file_size,\n+               const InternalKey& smallest,\n+               const InternalKey& largest) {\n+    FileMetaData f;\n+    f.number = file;\n+    f.file_size = file_size;\n+    f.smallest = smallest;\n+    f.largest = largest;\n+    new_files_.push_back(std::make_pair(level, f));\n+  }\n+\n+  // Delete the specified \"file\" from the specified \"level\".\n+  void DeleteFile(int level, uint64_t file) {\n+    deleted_files_.insert(std::make_pair(level, file));\n+  }\n+\n+  void EncodeTo(std::string* dst) const;\n+  Status DecodeFrom(const Slice& src);\n+\n+  std::string DebugString() const;\n+\n+ private:\n+  friend class VersionSet;\n+\n+  typedef std::set< std::pair<int, uint64_t> > DeletedFileSet;\n+\n+  std::string comparator_;\n+  uint64_t log_number_;\n+  uint64_t prev_log_number_;\n+  uint64_t next_file_number_;\n+  SequenceNumber last_sequence_;\n+  bool has_comparator_;\n+  bool has_log_number_;\n+  bool has_prev_log_number_;\n+  bool has_next_file_number_;\n+  bool has_last_sequence_;\n+\n+  std::vector< std::pair<int, InternalKey> > compact_pointers_;\n+  DeletedFileSet deleted_files_;\n+  std::vector< std::pair<int, FileMetaData> > new_files_;\n+};\n+\n+}  // namespace leveldb\n+\n+#endif  // STORAGE_LEVELDB_DB_VERSION_EDIT_H_"
      },
      {
        "sha": "280310b49d846e245df0d000ca1407724582daa2",
        "filename": "src/leveldb/db/version_edit_test.cc",
        "status": "added",
        "additions": 46,
        "deletions": 0,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/version_edit_test.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/version_edit_test.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/version_edit_test.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,46 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include \"db/version_edit.h\"\n+#include \"util/testharness.h\"\n+\n+namespace leveldb {\n+\n+static void TestEncodeDecode(const VersionEdit& edit) {\n+  std::string encoded, encoded2;\n+  edit.EncodeTo(&encoded);\n+  VersionEdit parsed;\n+  Status s = parsed.DecodeFrom(encoded);\n+  ASSERT_TRUE(s.ok()) << s.ToString();\n+  parsed.EncodeTo(&encoded2);\n+  ASSERT_EQ(encoded, encoded2);\n+}\n+\n+class VersionEditTest { };\n+\n+TEST(VersionEditTest, EncodeDecode) {\n+  static const uint64_t kBig = 1ull << 50;\n+\n+  VersionEdit edit;\n+  for (int i = 0; i < 4; i++) {\n+    TestEncodeDecode(edit);\n+    edit.AddFile(3, kBig + 300 + i, kBig + 400 + i,\n+                 InternalKey(\"foo\", kBig + 500 + i, kTypeValue),\n+                 InternalKey(\"zoo\", kBig + 600 + i, kTypeDeletion));\n+    edit.DeleteFile(4, kBig + 700 + i);\n+    edit.SetCompactPointer(i, InternalKey(\"x\", kBig + 900 + i, kTypeValue));\n+  }\n+\n+  edit.SetComparatorName(\"foo\");\n+  edit.SetLogNumber(kBig + 100);\n+  edit.SetNextFile(kBig + 200);\n+  edit.SetLastSequence(kBig + 1000);\n+  TestEncodeDecode(edit);\n+}\n+\n+}  // namespace leveldb\n+\n+int main(int argc, char** argv) {\n+  return leveldb::test::RunAllTests();\n+}"
      },
      {
        "sha": "cf976b437ef9d582cade22fccab72bb0ef2a3019",
        "filename": "src/leveldb/db/version_set.cc",
        "status": "added",
        "additions": 1402,
        "deletions": 0,
        "changes": 1402,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/version_set.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/version_set.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/version_set.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,1402 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include \"db/version_set.h\"\n+\n+#include <algorithm>\n+#include <stdio.h>\n+#include \"db/filename.h\"\n+#include \"db/log_reader.h\"\n+#include \"db/log_writer.h\"\n+#include \"db/memtable.h\"\n+#include \"db/table_cache.h\"\n+#include \"leveldb/env.h\"\n+#include \"leveldb/table_builder.h\"\n+#include \"table/merger.h\"\n+#include \"table/two_level_iterator.h\"\n+#include \"util/coding.h\"\n+#include \"util/logging.h\"\n+\n+namespace leveldb {\n+\n+static const int kTargetFileSize = 2 * 1048576;\n+\n+// Maximum bytes of overlaps in grandparent (i.e., level+2) before we\n+// stop building a single file in a level->level+1 compaction.\n+static const int64_t kMaxGrandParentOverlapBytes = 10 * kTargetFileSize;\n+\n+// Maximum number of bytes in all compacted files.  We avoid expanding\n+// the lower level file set of a compaction if it would make the\n+// total compaction cover more than this many bytes.\n+static const int64_t kExpandedCompactionByteSizeLimit = 25 * kTargetFileSize;\n+\n+static double MaxBytesForLevel(int level) {\n+  // Note: the result for level zero is not really used since we set\n+  // the level-0 compaction threshold based on number of files.\n+  double result = 10 * 1048576.0;  // Result for both level-0 and level-1\n+  while (level > 1) {\n+    result *= 10;\n+    level--;\n+  }\n+  return result;\n+}\n+\n+static uint64_t MaxFileSizeForLevel(int level) {\n+  return kTargetFileSize;  // We could vary per level to reduce number of files?\n+}\n+\n+static int64_t TotalFileSize(const std::vector<FileMetaData*>& files) {\n+  int64_t sum = 0;\n+  for (size_t i = 0; i < files.size(); i++) {\n+    sum += files[i]->file_size;\n+  }\n+  return sum;\n+}\n+\n+namespace {\n+std::string IntSetToString(const std::set<uint64_t>& s) {\n+  std::string result = \"{\";\n+  for (std::set<uint64_t>::const_iterator it = s.begin();\n+       it != s.end();\n+       ++it) {\n+    result += (result.size() > 1) ? \",\" : \"\";\n+    result += NumberToString(*it);\n+  }\n+  result += \"}\";\n+  return result;\n+}\n+}  // namespace\n+\n+Version::~Version() {\n+  assert(refs_ == 0);\n+\n+  // Remove from linked list\n+  prev_->next_ = next_;\n+  next_->prev_ = prev_;\n+\n+  // Drop references to files\n+  for (int level = 0; level < config::kNumLevels; level++) {\n+    for (size_t i = 0; i < files_[level].size(); i++) {\n+      FileMetaData* f = files_[level][i];\n+      assert(f->refs > 0);\n+      f->refs--;\n+      if (f->refs <= 0) {\n+        delete f;\n+      }\n+    }\n+  }\n+}\n+\n+int FindFile(const InternalKeyComparator& icmp,\n+             const std::vector<FileMetaData*>& files,\n+             const Slice& key) {\n+  uint32_t left = 0;\n+  uint32_t right = files.size();\n+  while (left < right) {\n+    uint32_t mid = (left + right) / 2;\n+    const FileMetaData* f = files[mid];\n+    if (icmp.InternalKeyComparator::Compare(f->largest.Encode(), key) < 0) {\n+      // Key at \"mid.largest\" is < \"target\".  Therefore all\n+      // files at or before \"mid\" are uninteresting.\n+      left = mid + 1;\n+    } else {\n+      // Key at \"mid.largest\" is >= \"target\".  Therefore all files\n+      // after \"mid\" are uninteresting.\n+      right = mid;\n+    }\n+  }\n+  return right;\n+}\n+\n+static bool AfterFile(const Comparator* ucmp,\n+                      const Slice* user_key, const FileMetaData* f) {\n+  // NULL user_key occurs before all keys and is therefore never after *f\n+  return (user_key != NULL &&\n+          ucmp->Compare(*user_key, f->largest.user_key()) > 0);\n+}\n+\n+static bool BeforeFile(const Comparator* ucmp,\n+                       const Slice* user_key, const FileMetaData* f) {\n+  // NULL user_key occurs after all keys and is therefore never before *f\n+  return (user_key != NULL &&\n+          ucmp->Compare(*user_key, f->smallest.user_key()) < 0);\n+}\n+\n+bool SomeFileOverlapsRange(\n+    const InternalKeyComparator& icmp,\n+    bool disjoint_sorted_files,\n+    const std::vector<FileMetaData*>& files,\n+    const Slice* smallest_user_key,\n+    const Slice* largest_user_key) {\n+  const Comparator* ucmp = icmp.user_comparator();\n+  if (!disjoint_sorted_files) {\n+    // Need to check against all files\n+    for (size_t i = 0; i < files.size(); i++) {\n+      const FileMetaData* f = files[i];\n+      if (AfterFile(ucmp, smallest_user_key, f) ||\n+          BeforeFile(ucmp, largest_user_key, f)) {\n+        // No overlap\n+      } else {\n+        return true;  // Overlap\n+      }\n+    }\n+    return false;\n+  }\n+\n+  // Binary search over file list\n+  uint32_t index = 0;\n+  if (smallest_user_key != NULL) {\n+    // Find the earliest possible internal key for smallest_user_key\n+    InternalKey small(*smallest_user_key, kMaxSequenceNumber,kValueTypeForSeek);\n+    index = FindFile(icmp, files, small.Encode());\n+  }\n+\n+  if (index >= files.size()) {\n+    // beginning of range is after all files, so no overlap.\n+    return false;\n+  }\n+\n+  return !BeforeFile(ucmp, largest_user_key, files[index]);\n+}\n+\n+// An internal iterator.  For a given version/level pair, yields\n+// information about the files in the level.  For a given entry, key()\n+// is the largest key that occurs in the file, and value() is an\n+// 16-byte value containing the file number and file size, both\n+// encoded using EncodeFixed64.\n+class Version::LevelFileNumIterator : public Iterator {\n+ public:\n+  LevelFileNumIterator(const InternalKeyComparator& icmp,\n+                       const std::vector<FileMetaData*>* flist)\n+      : icmp_(icmp),\n+        flist_(flist),\n+        index_(flist->size()) {        // Marks as invalid\n+  }\n+  virtual bool Valid() const {\n+    return index_ < flist_->size();\n+  }\n+  virtual void Seek(const Slice& target) {\n+    index_ = FindFile(icmp_, *flist_, target);\n+  }\n+  virtual void SeekToFirst() { index_ = 0; }\n+  virtual void SeekToLast() {\n+    index_ = flist_->empty() ? 0 : flist_->size() - 1;\n+  }\n+  virtual void Next() {\n+    assert(Valid());\n+    index_++;\n+  }\n+  virtual void Prev() {\n+    assert(Valid());\n+    if (index_ == 0) {\n+      index_ = flist_->size();  // Marks as invalid\n+    } else {\n+      index_--;\n+    }\n+  }\n+  Slice key() const {\n+    assert(Valid());\n+    return (*flist_)[index_]->largest.Encode();\n+  }\n+  Slice value() const {\n+    assert(Valid());\n+    EncodeFixed64(value_buf_, (*flist_)[index_]->number);\n+    EncodeFixed64(value_buf_+8, (*flist_)[index_]->file_size);\n+    return Slice(value_buf_, sizeof(value_buf_));\n+  }\n+  virtual Status status() const { return Status::OK(); }\n+ private:\n+  const InternalKeyComparator icmp_;\n+  const std::vector<FileMetaData*>* const flist_;\n+  uint32_t index_;\n+\n+  // Backing store for value().  Holds the file number and size.\n+  mutable char value_buf_[16];\n+};\n+\n+static Iterator* GetFileIterator(void* arg,\n+                                 const ReadOptions& options,\n+                                 const Slice& file_value) {\n+  TableCache* cache = reinterpret_cast<TableCache*>(arg);\n+  if (file_value.size() != 16) {\n+    return NewErrorIterator(\n+        Status::Corruption(\"FileReader invoked with unexpected value\"));\n+  } else {\n+    return cache->NewIterator(options,\n+                              DecodeFixed64(file_value.data()),\n+                              DecodeFixed64(file_value.data() + 8));\n+  }\n+}\n+\n+Iterator* Version::NewConcatenatingIterator(const ReadOptions& options,\n+                                            int level) const {\n+  return NewTwoLevelIterator(\n+      new LevelFileNumIterator(vset_->icmp_, &files_[level]),\n+      &GetFileIterator, vset_->table_cache_, options);\n+}\n+\n+void Version::AddIterators(const ReadOptions& options,\n+                           std::vector<Iterator*>* iters) {\n+  // Merge all level zero files together since they may overlap\n+  for (size_t i = 0; i < files_[0].size(); i++) {\n+    iters->push_back(\n+        vset_->table_cache_->NewIterator(\n+            options, files_[0][i]->number, files_[0][i]->file_size));\n+  }\n+\n+  // For levels > 0, we can use a concatenating iterator that sequentially\n+  // walks through the non-overlapping files in the level, opening them\n+  // lazily.\n+  for (int level = 1; level < config::kNumLevels; level++) {\n+    if (!files_[level].empty()) {\n+      iters->push_back(NewConcatenatingIterator(options, level));\n+    }\n+  }\n+}\n+\n+// Callback from TableCache::Get()\n+namespace {\n+enum SaverState {\n+  kNotFound,\n+  kFound,\n+  kDeleted,\n+  kCorrupt,\n+};\n+struct Saver {\n+  SaverState state;\n+  const Comparator* ucmp;\n+  Slice user_key;\n+  std::string* value;\n+};\n+}\n+static void SaveValue(void* arg, const Slice& ikey, const Slice& v) {\n+  Saver* s = reinterpret_cast<Saver*>(arg);\n+  ParsedInternalKey parsed_key;\n+  if (!ParseInternalKey(ikey, &parsed_key)) {\n+    s->state = kCorrupt;\n+  } else {\n+    if (s->ucmp->Compare(parsed_key.user_key, s->user_key) == 0) {\n+      s->state = (parsed_key.type == kTypeValue) ? kFound : kDeleted;\n+      if (s->state == kFound) {\n+        s->value->assign(v.data(), v.size());\n+      }\n+    }\n+  }\n+}\n+\n+static bool NewestFirst(FileMetaData* a, FileMetaData* b) {\n+  return a->number > b->number;\n+}\n+\n+Status Version::Get(const ReadOptions& options,\n+                    const LookupKey& k,\n+                    std::string* value,\n+                    GetStats* stats) {\n+  Slice ikey = k.internal_key();\n+  Slice user_key = k.user_key();\n+  const Comparator* ucmp = vset_->icmp_.user_comparator();\n+  Status s;\n+\n+  stats->seek_file = NULL;\n+  stats->seek_file_level = -1;\n+  FileMetaData* last_file_read = NULL;\n+  int last_file_read_level = -1;\n+\n+  // We can search level-by-level since entries never hop across\n+  // levels.  Therefore we are guaranteed that if we find data\n+  // in an smaller level, later levels are irrelevant.\n+  std::vector<FileMetaData*> tmp;\n+  FileMetaData* tmp2;\n+  for (int level = 0; level < config::kNumLevels; level++) {\n+    size_t num_files = files_[level].size();\n+    if (num_files == 0) continue;\n+\n+    // Get the list of files to search in this level\n+    FileMetaData* const* files = &files_[level][0];\n+    if (level == 0) {\n+      // Level-0 files may overlap each other.  Find all files that\n+      // overlap user_key and process them in order from newest to oldest.\n+      tmp.reserve(num_files);\n+      for (uint32_t i = 0; i < num_files; i++) {\n+        FileMetaData* f = files[i];\n+        if (ucmp->Compare(user_key, f->smallest.user_key()) >= 0 &&\n+            ucmp->Compare(user_key, f->largest.user_key()) <= 0) {\n+          tmp.push_back(f);\n+        }\n+      }\n+      if (tmp.empty()) continue;\n+\n+      std::sort(tmp.begin(), tmp.end(), NewestFirst);\n+      files = &tmp[0];\n+      num_files = tmp.size();\n+    } else {\n+      // Binary search to find earliest index whose largest key >= ikey.\n+      uint32_t index = FindFile(vset_->icmp_, files_[level], ikey);\n+      if (index >= num_files) {\n+        files = NULL;\n+        num_files = 0;\n+      } else {\n+        tmp2 = files[index];\n+        if (ucmp->Compare(user_key, tmp2->smallest.user_key()) < 0) {\n+          // All of \"tmp2\" is past any data for user_key\n+          files = NULL;\n+          num_files = 0;\n+        } else {\n+          files = &tmp2;\n+          num_files = 1;\n+        }\n+      }\n+    }\n+\n+    for (uint32_t i = 0; i < num_files; ++i) {\n+      if (last_file_read != NULL && stats->seek_file == NULL) {\n+        // We have had more than one seek for this read.  Charge the 1st file.\n+        stats->seek_file = last_file_read;\n+        stats->seek_file_level = last_file_read_level;\n+      }\n+\n+      FileMetaData* f = files[i];\n+      last_file_read = f;\n+      last_file_read_level = level;\n+\n+      Saver saver;\n+      saver.state = kNotFound;\n+      saver.ucmp = ucmp;\n+      saver.user_key = user_key;\n+      saver.value = value;\n+      s = vset_->table_cache_->Get(options, f->number, f->file_size,\n+                                   ikey, &saver, SaveValue);\n+      if (!s.ok()) {\n+        return s;\n+      }\n+      switch (saver.state) {\n+        case kNotFound:\n+          break;      // Keep searching in other files\n+        case kFound:\n+          return s;\n+        case kDeleted:\n+          s = Status::NotFound(Slice());  // Use empty error message for speed\n+          return s;\n+        case kCorrupt:\n+          s = Status::Corruption(\"corrupted key for \", user_key);\n+          return s;\n+      }\n+    }\n+  }\n+\n+  return Status::NotFound(Slice());  // Use an empty error message for speed\n+}\n+\n+bool Version::UpdateStats(const GetStats& stats) {\n+  FileMetaData* f = stats.seek_file;\n+  if (f != NULL) {\n+    f->allowed_seeks--;\n+    if (f->allowed_seeks <= 0 && file_to_compact_ == NULL) {\n+      file_to_compact_ = f;\n+      file_to_compact_level_ = stats.seek_file_level;\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+void Version::Ref() {\n+  ++refs_;\n+}\n+\n+void Version::Unref() {\n+  assert(this != &vset_->dummy_versions_);\n+  assert(refs_ >= 1);\n+  --refs_;\n+  if (refs_ == 0) {\n+    delete this;\n+  }\n+}\n+\n+bool Version::OverlapInLevel(int level,\n+                             const Slice* smallest_user_key,\n+                             const Slice* largest_user_key) {\n+  return SomeFileOverlapsRange(vset_->icmp_, (level > 0), files_[level],\n+                               smallest_user_key, largest_user_key);\n+}\n+\n+int Version::PickLevelForMemTableOutput(\n+    const Slice& smallest_user_key,\n+    const Slice& largest_user_key) {\n+  int level = 0;\n+  if (!OverlapInLevel(0, &smallest_user_key, &largest_user_key)) {\n+    // Push to next level if there is no overlap in next level,\n+    // and the #bytes overlapping in the level after that are limited.\n+    InternalKey start(smallest_user_key, kMaxSequenceNumber, kValueTypeForSeek);\n+    InternalKey limit(largest_user_key, 0, static_cast<ValueType>(0));\n+    std::vector<FileMetaData*> overlaps;\n+    while (level < config::kMaxMemCompactLevel) {\n+      if (OverlapInLevel(level + 1, &smallest_user_key, &largest_user_key)) {\n+        break;\n+      }\n+      GetOverlappingInputs(level + 2, &start, &limit, &overlaps);\n+      const int64_t sum = TotalFileSize(overlaps);\n+      if (sum > kMaxGrandParentOverlapBytes) {\n+        break;\n+      }\n+      level++;\n+    }\n+  }\n+  return level;\n+}\n+\n+// Store in \"*inputs\" all files in \"level\" that overlap [begin,end]\n+void Version::GetOverlappingInputs(\n+    int level,\n+    const InternalKey* begin,\n+    const InternalKey* end,\n+    std::vector<FileMetaData*>* inputs) {\n+  inputs->clear();\n+  Slice user_begin, user_end;\n+  if (begin != NULL) {\n+    user_begin = begin->user_key();\n+  }\n+  if (end != NULL) {\n+    user_end = end->user_key();\n+  }\n+  const Comparator* user_cmp = vset_->icmp_.user_comparator();\n+  for (size_t i = 0; i < files_[level].size(); ) {\n+    FileMetaData* f = files_[level][i++];\n+    const Slice file_start = f->smallest.user_key();\n+    const Slice file_limit = f->largest.user_key();\n+    if (begin != NULL && user_cmp->Compare(file_limit, user_begin) < 0) {\n+      // \"f\" is completely before specified range; skip it\n+    } else if (end != NULL && user_cmp->Compare(file_start, user_end) > 0) {\n+      // \"f\" is completely after specified range; skip it\n+    } else {\n+      inputs->push_back(f);\n+      if (level == 0) {\n+        // Level-0 files may overlap each other.  So check if the newly\n+        // added file has expanded the range.  If so, restart search.\n+        if (begin != NULL && user_cmp->Compare(file_start, user_begin) < 0) {\n+          user_begin = file_start;\n+          inputs->clear();\n+          i = 0;\n+        } else if (end != NULL && user_cmp->Compare(file_limit, user_end) > 0) {\n+          user_end = file_limit;\n+          inputs->clear();\n+          i = 0;\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+std::string Version::DebugString() const {\n+  std::string r;\n+  for (int level = 0; level < config::kNumLevels; level++) {\n+    // E.g.,\n+    //   --- level 1 ---\n+    //   17:123['a' .. 'd']\n+    //   20:43['e' .. 'g']\n+    r.append(\"--- level \");\n+    AppendNumberTo(&r, level);\n+    r.append(\" ---\\n\");\n+    const std::vector<FileMetaData*>& files = files_[level];\n+    for (size_t i = 0; i < files.size(); i++) {\n+      r.push_back(' ');\n+      AppendNumberTo(&r, files[i]->number);\n+      r.push_back(':');\n+      AppendNumberTo(&r, files[i]->file_size);\n+      r.append(\"[\");\n+      r.append(files[i]->smallest.DebugString());\n+      r.append(\" .. \");\n+      r.append(files[i]->largest.DebugString());\n+      r.append(\"]\\n\");\n+    }\n+  }\n+  return r;\n+}\n+\n+// A helper class so we can efficiently apply a whole sequence\n+// of edits to a particular state without creating intermediate\n+// Versions that contain full copies of the intermediate state.\n+class VersionSet::Builder {\n+ private:\n+  // Helper to sort by v->files_[file_number].smallest\n+  struct BySmallestKey {\n+    const InternalKeyComparator* internal_comparator;\n+\n+    bool operator()(FileMetaData* f1, FileMetaData* f2) const {\n+      int r = internal_comparator->Compare(f1->smallest, f2->smallest);\n+      if (r != 0) {\n+        return (r < 0);\n+      } else {\n+        // Break ties by file number\n+        return (f1->number < f2->number);\n+      }\n+    }\n+  };\n+\n+  typedef std::set<FileMetaData*, BySmallestKey> FileSet;\n+  struct LevelState {\n+    std::set<uint64_t> deleted_files;\n+    FileSet* added_files;\n+  };\n+\n+  VersionSet* vset_;\n+  Version* base_;\n+  LevelState levels_[config::kNumLevels];\n+\n+ public:\n+  // Initialize a builder with the files from *base and other info from *vset\n+  Builder(VersionSet* vset, Version* base)\n+      : vset_(vset),\n+        base_(base) {\n+    base_->Ref();\n+    BySmallestKey cmp;\n+    cmp.internal_comparator = &vset_->icmp_;\n+    for (int level = 0; level < config::kNumLevels; level++) {\n+      levels_[level].added_files = new FileSet(cmp);\n+    }\n+  }\n+\n+  ~Builder() {\n+    for (int level = 0; level < config::kNumLevels; level++) {\n+      const FileSet* added = levels_[level].added_files;\n+      std::vector<FileMetaData*> to_unref;\n+      to_unref.reserve(added->size());\n+      for (FileSet::const_iterator it = added->begin();\n+          it != added->end(); ++it) {\n+        to_unref.push_back(*it);\n+      }\n+      delete added;\n+      for (uint32_t i = 0; i < to_unref.size(); i++) {\n+        FileMetaData* f = to_unref[i];\n+        f->refs--;\n+        if (f->refs <= 0) {\n+          delete f;\n+        }\n+      }\n+    }\n+    base_->Unref();\n+  }\n+\n+  // Apply all of the edits in *edit to the current state.\n+  void Apply(VersionEdit* edit) {\n+    // Update compaction pointers\n+    for (size_t i = 0; i < edit->compact_pointers_.size(); i++) {\n+      const int level = edit->compact_pointers_[i].first;\n+      vset_->compact_pointer_[level] =\n+          edit->compact_pointers_[i].second.Encode().ToString();\n+    }\n+\n+    // Delete files\n+    const VersionEdit::DeletedFileSet& del = edit->deleted_files_;\n+    for (VersionEdit::DeletedFileSet::const_iterator iter = del.begin();\n+         iter != del.end();\n+         ++iter) {\n+      const int level = iter->first;\n+      const uint64_t number = iter->second;\n+      levels_[level].deleted_files.insert(number);\n+    }\n+\n+    // Add new files\n+    for (size_t i = 0; i < edit->new_files_.size(); i++) {\n+      const int level = edit->new_files_[i].first;\n+      FileMetaData* f = new FileMetaData(edit->new_files_[i].second);\n+      f->refs = 1;\n+\n+      // We arrange to automatically compact this file after\n+      // a certain number of seeks.  Let's assume:\n+      //   (1) One seek costs 10ms\n+      //   (2) Writing or reading 1MB costs 10ms (100MB/s)\n+      //   (3) A compaction of 1MB does 25MB of IO:\n+      //         1MB read from this level\n+      //         10-12MB read from next level (boundaries may be misaligned)\n+      //         10-12MB written to next level\n+      // This implies that 25 seeks cost the same as the compaction\n+      // of 1MB of data.  I.e., one seek costs approximately the\n+      // same as the compaction of 40KB of data.  We are a little\n+      // conservative and allow approximately one seek for every 16KB\n+      // of data before triggering a compaction.\n+      f->allowed_seeks = (f->file_size / 16384);\n+      if (f->allowed_seeks < 100) f->allowed_seeks = 100;\n+\n+      levels_[level].deleted_files.erase(f->number);\n+      levels_[level].added_files->insert(f);\n+    }\n+  }\n+\n+  // Save the current state in *v.\n+  void SaveTo(Version* v) {\n+    BySmallestKey cmp;\n+    cmp.internal_comparator = &vset_->icmp_;\n+    for (int level = 0; level < config::kNumLevels; level++) {\n+      // Merge the set of added files with the set of pre-existing files.\n+      // Drop any deleted files.  Store the result in *v.\n+      const std::vector<FileMetaData*>& base_files = base_->files_[level];\n+      std::vector<FileMetaData*>::const_iterator base_iter = base_files.begin();\n+      std::vector<FileMetaData*>::const_iterator base_end = base_files.end();\n+      const FileSet* added = levels_[level].added_files;\n+      v->files_[level].reserve(base_files.size() + added->size());\n+      for (FileSet::const_iterator added_iter = added->begin();\n+           added_iter != added->end();\n+           ++added_iter) {\n+        // Add all smaller files listed in base_\n+        for (std::vector<FileMetaData*>::const_iterator bpos\n+                 = std::upper_bound(base_iter, base_end, *added_iter, cmp);\n+             base_iter != bpos;\n+             ++base_iter) {\n+          MaybeAddFile(v, level, *base_iter);\n+        }\n+\n+        MaybeAddFile(v, level, *added_iter);\n+      }\n+\n+      // Add remaining base files\n+      for (; base_iter != base_end; ++base_iter) {\n+        MaybeAddFile(v, level, *base_iter);\n+      }\n+\n+#ifndef NDEBUG\n+      // Make sure there is no overlap in levels > 0\n+      if (level > 0) {\n+        for (uint32_t i = 1; i < v->files_[level].size(); i++) {\n+          const InternalKey& prev_end = v->files_[level][i-1]->largest;\n+          const InternalKey& this_begin = v->files_[level][i]->smallest;\n+          if (vset_->icmp_.Compare(prev_end, this_begin) >= 0) {\n+            fprintf(stderr, \"overlapping ranges in same level %s vs. %s\\n\",\n+                    prev_end.DebugString().c_str(),\n+                    this_begin.DebugString().c_str());\n+            abort();\n+          }\n+        }\n+      }\n+#endif\n+    }\n+  }\n+\n+  void MaybeAddFile(Version* v, int level, FileMetaData* f) {\n+    if (levels_[level].deleted_files.count(f->number) > 0) {\n+      // File is deleted: do nothing\n+    } else {\n+      std::vector<FileMetaData*>* files = &v->files_[level];\n+      if (level > 0 && !files->empty()) {\n+        // Must not overlap\n+        assert(vset_->icmp_.Compare((*files)[files->size()-1]->largest,\n+                                    f->smallest) < 0);\n+      }\n+      f->refs++;\n+      files->push_back(f);\n+    }\n+  }\n+};\n+\n+VersionSet::VersionSet(const std::string& dbname,\n+                       const Options* options,\n+                       TableCache* table_cache,\n+                       const InternalKeyComparator* cmp)\n+    : env_(options->env),\n+      dbname_(dbname),\n+      options_(options),\n+      table_cache_(table_cache),\n+      icmp_(*cmp),\n+      next_file_number_(2),\n+      manifest_file_number_(0),  // Filled by Recover()\n+      last_sequence_(0),\n+      log_number_(0),\n+      prev_log_number_(0),\n+      descriptor_file_(NULL),\n+      descriptor_log_(NULL),\n+      dummy_versions_(this),\n+      current_(NULL) {\n+  AppendVersion(new Version(this));\n+}\n+\n+VersionSet::~VersionSet() {\n+  current_->Unref();\n+  assert(dummy_versions_.next_ == &dummy_versions_);  // List must be empty\n+  delete descriptor_log_;\n+  delete descriptor_file_;\n+}\n+\n+void VersionSet::AppendVersion(Version* v) {\n+  // Make \"v\" current\n+  assert(v->refs_ == 0);\n+  assert(v != current_);\n+  if (current_ != NULL) {\n+    current_->Unref();\n+  }\n+  current_ = v;\n+  v->Ref();\n+\n+  // Append to linked list\n+  v->prev_ = dummy_versions_.prev_;\n+  v->next_ = &dummy_versions_;\n+  v->prev_->next_ = v;\n+  v->next_->prev_ = v;\n+}\n+\n+Status VersionSet::LogAndApply(VersionEdit* edit, port::Mutex* mu) {\n+  if (edit->has_log_number_) {\n+    assert(edit->log_number_ >= log_number_);\n+    assert(edit->log_number_ < next_file_number_);\n+  } else {\n+    edit->SetLogNumber(log_number_);\n+  }\n+\n+  if (!edit->has_prev_log_number_) {\n+    edit->SetPrevLogNumber(prev_log_number_);\n+  }\n+\n+  edit->SetNextFile(next_file_number_);\n+  edit->SetLastSequence(last_sequence_);\n+\n+  Version* v = new Version(this);\n+  {\n+    Builder builder(this, current_);\n+    builder.Apply(edit);\n+    builder.SaveTo(v);\n+  }\n+  Finalize(v);\n+\n+  // Initialize new descriptor log file if necessary by creating\n+  // a temporary file that contains a snapshot of the current version.\n+  std::string new_manifest_file;\n+  Status s;\n+  if (descriptor_log_ == NULL) {\n+    // No reason to unlock *mu here since we only hit this path in the\n+    // first call to LogAndApply (when opening the database).\n+    assert(descriptor_file_ == NULL);\n+    new_manifest_file = DescriptorFileName(dbname_, manifest_file_number_);\n+    edit->SetNextFile(next_file_number_);\n+    s = env_->NewWritableFile(new_manifest_file, &descriptor_file_);\n+    if (s.ok()) {\n+      descriptor_log_ = new log::Writer(descriptor_file_);\n+      s = WriteSnapshot(descriptor_log_);\n+    }\n+  }\n+\n+  // Unlock during expensive MANIFEST log write\n+  {\n+    mu->Unlock();\n+\n+    // Write new record to MANIFEST log\n+    if (s.ok()) {\n+      std::string record;\n+      edit->EncodeTo(&record);\n+      s = descriptor_log_->AddRecord(record);\n+      if (s.ok()) {\n+        s = descriptor_file_->Sync();\n+      }\n+    }\n+\n+    // If we just created a new descriptor file, install it by writing a\n+    // new CURRENT file that points to it.\n+    if (s.ok() && !new_manifest_file.empty()) {\n+      s = SetCurrentFile(env_, dbname_, manifest_file_number_);\n+    }\n+\n+    mu->Lock();\n+  }\n+\n+  // Install the new version\n+  if (s.ok()) {\n+    AppendVersion(v);\n+    log_number_ = edit->log_number_;\n+    prev_log_number_ = edit->prev_log_number_;\n+  } else {\n+    delete v;\n+    if (!new_manifest_file.empty()) {\n+      delete descriptor_log_;\n+      delete descriptor_file_;\n+      descriptor_log_ = NULL;\n+      descriptor_file_ = NULL;\n+      env_->DeleteFile(new_manifest_file);\n+    }\n+  }\n+\n+  return s;\n+}\n+\n+Status VersionSet::Recover() {\n+  struct LogReporter : public log::Reader::Reporter {\n+    Status* status;\n+    virtual void Corruption(size_t bytes, const Status& s) {\n+      if (this->status->ok()) *this->status = s;\n+    }\n+  };\n+\n+  // Read \"CURRENT\" file, which contains a pointer to the current manifest file\n+  std::string current;\n+  Status s = ReadFileToString(env_, CurrentFileName(dbname_), &current);\n+  if (!s.ok()) {\n+    return s;\n+  }\n+  if (current.empty() || current[current.size()-1] != '\\n') {\n+    return Status::Corruption(\"CURRENT file does not end with newline\");\n+  }\n+  current.resize(current.size() - 1);\n+\n+  std::string dscname = dbname_ + \"/\" + current;\n+  SequentialFile* file;\n+  s = env_->NewSequentialFile(dscname, &file);\n+  if (!s.ok()) {\n+    return s;\n+  }\n+\n+  bool have_log_number = false;\n+  bool have_prev_log_number = false;\n+  bool have_next_file = false;\n+  bool have_last_sequence = false;\n+  uint64_t next_file = 0;\n+  uint64_t last_sequence = 0;\n+  uint64_t log_number = 0;\n+  uint64_t prev_log_number = 0;\n+  Builder builder(this, current_);\n+\n+  {\n+    LogReporter reporter;\n+    reporter.status = &s;\n+    log::Reader reader(file, &reporter, true/*checksum*/, 0/*initial_offset*/);\n+    Slice record;\n+    std::string scratch;\n+    while (reader.ReadRecord(&record, &scratch) && s.ok()) {\n+      VersionEdit edit;\n+      s = edit.DecodeFrom(record);\n+      if (s.ok()) {\n+        if (edit.has_comparator_ &&\n+            edit.comparator_ != icmp_.user_comparator()->Name()) {\n+          s = Status::InvalidArgument(\n+              edit.comparator_ + \"does not match existing comparator \",\n+              icmp_.user_comparator()->Name());\n+        }\n+      }\n+\n+      if (s.ok()) {\n+        builder.Apply(&edit);\n+      }\n+\n+      if (edit.has_log_number_) {\n+        log_number = edit.log_number_;\n+        have_log_number = true;\n+      }\n+\n+      if (edit.has_prev_log_number_) {\n+        prev_log_number = edit.prev_log_number_;\n+        have_prev_log_number = true;\n+      }\n+\n+      if (edit.has_next_file_number_) {\n+        next_file = edit.next_file_number_;\n+        have_next_file = true;\n+      }\n+\n+      if (edit.has_last_sequence_) {\n+        last_sequence = edit.last_sequence_;\n+        have_last_sequence = true;\n+      }\n+    }\n+  }\n+  delete file;\n+  file = NULL;\n+\n+  if (s.ok()) {\n+    if (!have_next_file) {\n+      s = Status::Corruption(\"no meta-nextfile entry in descriptor\");\n+    } else if (!have_log_number) {\n+      s = Status::Corruption(\"no meta-lognumber entry in descriptor\");\n+    } else if (!have_last_sequence) {\n+      s = Status::Corruption(\"no last-sequence-number entry in descriptor\");\n+    }\n+\n+    if (!have_prev_log_number) {\n+      prev_log_number = 0;\n+    }\n+\n+    MarkFileNumberUsed(prev_log_number);\n+    MarkFileNumberUsed(log_number);\n+  }\n+\n+  if (s.ok()) {\n+    Version* v = new Version(this);\n+    builder.SaveTo(v);\n+    // Install recovered version\n+    Finalize(v);\n+    AppendVersion(v);\n+    manifest_file_number_ = next_file;\n+    next_file_number_ = next_file + 1;\n+    last_sequence_ = last_sequence;\n+    log_number_ = log_number;\n+    prev_log_number_ = prev_log_number;\n+  }\n+\n+  return s;\n+}\n+\n+void VersionSet::MarkFileNumberUsed(uint64_t number) {\n+  if (next_file_number_ <= number) {\n+    next_file_number_ = number + 1;\n+  }\n+}\n+\n+void VersionSet::Finalize(Version* v) {\n+  // Precomputed best level for next compaction\n+  int best_level = -1;\n+  double best_score = -1;\n+\n+  for (int level = 0; level < config::kNumLevels-1; level++) {\n+    double score;\n+    if (level == 0) {\n+      // We treat level-0 specially by bounding the number of files\n+      // instead of number of bytes for two reasons:\n+      //\n+      // (1) With larger write-buffer sizes, it is nice not to do too\n+      // many level-0 compactions.\n+      //\n+      // (2) The files in level-0 are merged on every read and\n+      // therefore we wish to avoid too many files when the individual\n+      // file size is small (perhaps because of a small write-buffer\n+      // setting, or very high compression ratios, or lots of\n+      // overwrites/deletions).\n+      score = v->files_[level].size() /\n+          static_cast<double>(config::kL0_CompactionTrigger);\n+    } else {\n+      // Compute the ratio of current size to size limit.\n+      const uint64_t level_bytes = TotalFileSize(v->files_[level]);\n+      score = static_cast<double>(level_bytes) / MaxBytesForLevel(level);\n+    }\n+\n+    if (score > best_score) {\n+      best_level = level;\n+      best_score = score;\n+    }\n+  }\n+\n+  v->compaction_level_ = best_level;\n+  v->compaction_score_ = best_score;\n+}\n+\n+Status VersionSet::WriteSnapshot(log::Writer* log) {\n+  // TODO: Break up into multiple records to reduce memory usage on recovery?\n+\n+  // Save metadata\n+  VersionEdit edit;\n+  edit.SetComparatorName(icmp_.user_comparator()->Name());\n+\n+  // Save compaction pointers\n+  for (int level = 0; level < config::kNumLevels; level++) {\n+    if (!compact_pointer_[level].empty()) {\n+      InternalKey key;\n+      key.DecodeFrom(compact_pointer_[level]);\n+      edit.SetCompactPointer(level, key);\n+    }\n+  }\n+\n+  // Save files\n+  for (int level = 0; level < config::kNumLevels; level++) {\n+    const std::vector<FileMetaData*>& files = current_->files_[level];\n+    for (size_t i = 0; i < files.size(); i++) {\n+      const FileMetaData* f = files[i];\n+      edit.AddFile(level, f->number, f->file_size, f->smallest, f->largest);\n+    }\n+  }\n+\n+  std::string record;\n+  edit.EncodeTo(&record);\n+  return log->AddRecord(record);\n+}\n+\n+int VersionSet::NumLevelFiles(int level) const {\n+  assert(level >= 0);\n+  assert(level < config::kNumLevels);\n+  return current_->files_[level].size();\n+}\n+\n+const char* VersionSet::LevelSummary(LevelSummaryStorage* scratch) const {\n+  // Update code if kNumLevels changes\n+  assert(config::kNumLevels == 7);\n+  snprintf(scratch->buffer, sizeof(scratch->buffer),\n+           \"files[ %d %d %d %d %d %d %d ]\",\n+           int(current_->files_[0].size()),\n+           int(current_->files_[1].size()),\n+           int(current_->files_[2].size()),\n+           int(current_->files_[3].size()),\n+           int(current_->files_[4].size()),\n+           int(current_->files_[5].size()),\n+           int(current_->files_[6].size()));\n+  return scratch->buffer;\n+}\n+\n+uint64_t VersionSet::ApproximateOffsetOf(Version* v, const InternalKey& ikey) {\n+  uint64_t result = 0;\n+  for (int level = 0; level < config::kNumLevels; level++) {\n+    const std::vector<FileMetaData*>& files = v->files_[level];\n+    for (size_t i = 0; i < files.size(); i++) {\n+      if (icmp_.Compare(files[i]->largest, ikey) <= 0) {\n+        // Entire file is before \"ikey\", so just add the file size\n+        result += files[i]->file_size;\n+      } else if (icmp_.Compare(files[i]->smallest, ikey) > 0) {\n+        // Entire file is after \"ikey\", so ignore\n+        if (level > 0) {\n+          // Files other than level 0 are sorted by meta->smallest, so\n+          // no further files in this level will contain data for\n+          // \"ikey\".\n+          break;\n+        }\n+      } else {\n+        // \"ikey\" falls in the range for this table.  Add the\n+        // approximate offset of \"ikey\" within the table.\n+        Table* tableptr;\n+        Iterator* iter = table_cache_->NewIterator(\n+            ReadOptions(), files[i]->number, files[i]->file_size, &tableptr);\n+        if (tableptr != NULL) {\n+          result += tableptr->ApproximateOffsetOf(ikey.Encode());\n+        }\n+        delete iter;\n+      }\n+    }\n+  }\n+  return result;\n+}\n+\n+void VersionSet::AddLiveFiles(std::set<uint64_t>* live) {\n+  for (Version* v = dummy_versions_.next_;\n+       v != &dummy_versions_;\n+       v = v->next_) {\n+    for (int level = 0; level < config::kNumLevels; level++) {\n+      const std::vector<FileMetaData*>& files = v->files_[level];\n+      for (size_t i = 0; i < files.size(); i++) {\n+        live->insert(files[i]->number);\n+      }\n+    }\n+  }\n+}\n+\n+int64_t VersionSet::NumLevelBytes(int level) const {\n+  assert(level >= 0);\n+  assert(level < config::kNumLevels);\n+  return TotalFileSize(current_->files_[level]);\n+}\n+\n+int64_t VersionSet::MaxNextLevelOverlappingBytes() {\n+  int64_t result = 0;\n+  std::vector<FileMetaData*> overlaps;\n+  for (int level = 1; level < config::kNumLevels - 1; level++) {\n+    for (size_t i = 0; i < current_->files_[level].size(); i++) {\n+      const FileMetaData* f = current_->files_[level][i];\n+      current_->GetOverlappingInputs(level+1, &f->smallest, &f->largest,\n+                                     &overlaps);\n+      const int64_t sum = TotalFileSize(overlaps);\n+      if (sum > result) {\n+        result = sum;\n+      }\n+    }\n+  }\n+  return result;\n+}\n+\n+// Stores the minimal range that covers all entries in inputs in\n+// *smallest, *largest.\n+// REQUIRES: inputs is not empty\n+void VersionSet::GetRange(const std::vector<FileMetaData*>& inputs,\n+                          InternalKey* smallest,\n+                          InternalKey* largest) {\n+  assert(!inputs.empty());\n+  smallest->Clear();\n+  largest->Clear();\n+  for (size_t i = 0; i < inputs.size(); i++) {\n+    FileMetaData* f = inputs[i];\n+    if (i == 0) {\n+      *smallest = f->smallest;\n+      *largest = f->largest;\n+    } else {\n+      if (icmp_.Compare(f->smallest, *smallest) < 0) {\n+        *smallest = f->smallest;\n+      }\n+      if (icmp_.Compare(f->largest, *largest) > 0) {\n+        *largest = f->largest;\n+      }\n+    }\n+  }\n+}\n+\n+// Stores the minimal range that covers all entries in inputs1 and inputs2\n+// in *smallest, *largest.\n+// REQUIRES: inputs is not empty\n+void VersionSet::GetRange2(const std::vector<FileMetaData*>& inputs1,\n+                           const std::vector<FileMetaData*>& inputs2,\n+                           InternalKey* smallest,\n+                           InternalKey* largest) {\n+  std::vector<FileMetaData*> all = inputs1;\n+  all.insert(all.end(), inputs2.begin(), inputs2.end());\n+  GetRange(all, smallest, largest);\n+}\n+\n+Iterator* VersionSet::MakeInputIterator(Compaction* c) {\n+  ReadOptions options;\n+  options.verify_checksums = options_->paranoid_checks;\n+  options.fill_cache = false;\n+\n+  // Level-0 files have to be merged together.  For other levels,\n+  // we will make a concatenating iterator per level.\n+  // TODO(opt): use concatenating iterator for level-0 if there is no overlap\n+  const int space = (c->level() == 0 ? c->inputs_[0].size() + 1 : 2);\n+  Iterator** list = new Iterator*[space];\n+  int num = 0;\n+  for (int which = 0; which < 2; which++) {\n+    if (!c->inputs_[which].empty()) {\n+      if (c->level() + which == 0) {\n+        const std::vector<FileMetaData*>& files = c->inputs_[which];\n+        for (size_t i = 0; i < files.size(); i++) {\n+          list[num++] = table_cache_->NewIterator(\n+              options, files[i]->number, files[i]->file_size);\n+        }\n+      } else {\n+        // Create concatenating iterator for the files from this level\n+        list[num++] = NewTwoLevelIterator(\n+            new Version::LevelFileNumIterator(icmp_, &c->inputs_[which]),\n+            &GetFileIterator, table_cache_, options);\n+      }\n+    }\n+  }\n+  assert(num <= space);\n+  Iterator* result = NewMergingIterator(&icmp_, list, num);\n+  delete[] list;\n+  return result;\n+}\n+\n+Compaction* VersionSet::PickCompaction() {\n+  Compaction* c;\n+  int level;\n+\n+  // We prefer compactions triggered by too much data in a level over\n+  // the compactions triggered by seeks.\n+  const bool size_compaction = (current_->compaction_score_ >= 1);\n+  const bool seek_compaction = (current_->file_to_compact_ != NULL);\n+  if (size_compaction) {\n+    level = current_->compaction_level_;\n+    assert(level >= 0);\n+    assert(level+1 < config::kNumLevels);\n+    c = new Compaction(level);\n+\n+    // Pick the first file that comes after compact_pointer_[level]\n+    for (size_t i = 0; i < current_->files_[level].size(); i++) {\n+      FileMetaData* f = current_->files_[level][i];\n+      if (compact_pointer_[level].empty() ||\n+          icmp_.Compare(f->largest.Encode(), compact_pointer_[level]) > 0) {\n+        c->inputs_[0].push_back(f);\n+        break;\n+      }\n+    }\n+    if (c->inputs_[0].empty()) {\n+      // Wrap-around to the beginning of the key space\n+      c->inputs_[0].push_back(current_->files_[level][0]);\n+    }\n+  } else if (seek_compaction) {\n+    level = current_->file_to_compact_level_;\n+    c = new Compaction(level);\n+    c->inputs_[0].push_back(current_->file_to_compact_);\n+  } else {\n+    return NULL;\n+  }\n+\n+  c->input_version_ = current_;\n+  c->input_version_->Ref();\n+\n+  // Files in level 0 may overlap each other, so pick up all overlapping ones\n+  if (level == 0) {\n+    InternalKey smallest, largest;\n+    GetRange(c->inputs_[0], &smallest, &largest);\n+    // Note that the next call will discard the file we placed in\n+    // c->inputs_[0] earlier and replace it with an overlapping set\n+    // which will include the picked file.\n+    current_->GetOverlappingInputs(0, &smallest, &largest, &c->inputs_[0]);\n+    assert(!c->inputs_[0].empty());\n+  }\n+\n+  SetupOtherInputs(c);\n+\n+  return c;\n+}\n+\n+void VersionSet::SetupOtherInputs(Compaction* c) {\n+  const int level = c->level();\n+  InternalKey smallest, largest;\n+  GetRange(c->inputs_[0], &smallest, &largest);\n+\n+  current_->GetOverlappingInputs(level+1, &smallest, &largest, &c->inputs_[1]);\n+\n+  // Get entire range covered by compaction\n+  InternalKey all_start, all_limit;\n+  GetRange2(c->inputs_[0], c->inputs_[1], &all_start, &all_limit);\n+\n+  // See if we can grow the number of inputs in \"level\" without\n+  // changing the number of \"level+1\" files we pick up.\n+  if (!c->inputs_[1].empty()) {\n+    std::vector<FileMetaData*> expanded0;\n+    current_->GetOverlappingInputs(level, &all_start, &all_limit, &expanded0);\n+    const int64_t inputs0_size = TotalFileSize(c->inputs_[0]);\n+    const int64_t inputs1_size = TotalFileSize(c->inputs_[1]);\n+    const int64_t expanded0_size = TotalFileSize(expanded0);\n+    if (expanded0.size() > c->inputs_[0].size() &&\n+        inputs1_size + expanded0_size < kExpandedCompactionByteSizeLimit) {\n+      InternalKey new_start, new_limit;\n+      GetRange(expanded0, &new_start, &new_limit);\n+      std::vector<FileMetaData*> expanded1;\n+      current_->GetOverlappingInputs(level+1, &new_start, &new_limit,\n+                                     &expanded1);\n+      if (expanded1.size() == c->inputs_[1].size()) {\n+        Log(options_->info_log,\n+            \"Expanding@%d %d+%d (%ld+%ld bytes) to %d+%d (%ld+%ld bytes)\\n\",\n+            level,\n+            int(c->inputs_[0].size()),\n+            int(c->inputs_[1].size()),\n+            long(inputs0_size), long(inputs1_size),\n+            int(expanded0.size()),\n+            int(expanded1.size()),\n+            long(expanded0_size), long(inputs1_size));\n+        smallest = new_start;\n+        largest = new_limit;\n+        c->inputs_[0] = expanded0;\n+        c->inputs_[1] = expanded1;\n+        GetRange2(c->inputs_[0], c->inputs_[1], &all_start, &all_limit);\n+      }\n+    }\n+  }\n+\n+  // Compute the set of grandparent files that overlap this compaction\n+  // (parent == level+1; grandparent == level+2)\n+  if (level + 2 < config::kNumLevels) {\n+    current_->GetOverlappingInputs(level + 2, &all_start, &all_limit,\n+                                   &c->grandparents_);\n+  }\n+\n+  if (false) {\n+    Log(options_->info_log, \"Compacting %d '%s' .. '%s'\",\n+        level,\n+        smallest.DebugString().c_str(),\n+        largest.DebugString().c_str());\n+  }\n+\n+  // Update the place where we will do the next compaction for this level.\n+  // We update this immediately instead of waiting for the VersionEdit\n+  // to be applied so that if the compaction fails, we will try a different\n+  // key range next time.\n+  compact_pointer_[level] = largest.Encode().ToString();\n+  c->edit_.SetCompactPointer(level, largest);\n+}\n+\n+Compaction* VersionSet::CompactRange(\n+    int level,\n+    const InternalKey* begin,\n+    const InternalKey* end) {\n+  std::vector<FileMetaData*> inputs;\n+  current_->GetOverlappingInputs(level, begin, end, &inputs);\n+  if (inputs.empty()) {\n+    return NULL;\n+  }\n+\n+  // Avoid compacting too much in one shot in case the range is large.\n+  const uint64_t limit = MaxFileSizeForLevel(level);\n+  uint64_t total = 0;\n+  for (size_t i = 0; i < inputs.size(); i++) {\n+    uint64_t s = inputs[i]->file_size;\n+    total += s;\n+    if (total >= limit) {\n+      inputs.resize(i + 1);\n+      break;\n+    }\n+  }\n+\n+  Compaction* c = new Compaction(level);\n+  c->input_version_ = current_;\n+  c->input_version_->Ref();\n+  c->inputs_[0] = inputs;\n+  SetupOtherInputs(c);\n+  return c;\n+}\n+\n+Compaction::Compaction(int level)\n+    : level_(level),\n+      max_output_file_size_(MaxFileSizeForLevel(level)),\n+      input_version_(NULL),\n+      grandparent_index_(0),\n+      seen_key_(false),\n+      overlapped_bytes_(0) {\n+  for (int i = 0; i < config::kNumLevels; i++) {\n+    level_ptrs_[i] = 0;\n+  }\n+}\n+\n+Compaction::~Compaction() {\n+  if (input_version_ != NULL) {\n+    input_version_->Unref();\n+  }\n+}\n+\n+bool Compaction::IsTrivialMove() const {\n+  // Avoid a move if there is lots of overlapping grandparent data.\n+  // Otherwise, the move could create a parent file that will require\n+  // a very expensive merge later on.\n+  return (num_input_files(0) == 1 &&\n+          num_input_files(1) == 0 &&\n+          TotalFileSize(grandparents_) <= kMaxGrandParentOverlapBytes);\n+}\n+\n+void Compaction::AddInputDeletions(VersionEdit* edit) {\n+  for (int which = 0; which < 2; which++) {\n+    for (size_t i = 0; i < inputs_[which].size(); i++) {\n+      edit->DeleteFile(level_ + which, inputs_[which][i]->number);\n+    }\n+  }\n+}\n+\n+bool Compaction::IsBaseLevelForKey(const Slice& user_key) {\n+  // Maybe use binary search to find right entry instead of linear search?\n+  const Comparator* user_cmp = input_version_->vset_->icmp_.user_comparator();\n+  for (int lvl = level_ + 2; lvl < config::kNumLevels; lvl++) {\n+    const std::vector<FileMetaData*>& files = input_version_->files_[lvl];\n+    for (; level_ptrs_[lvl] < files.size(); ) {\n+      FileMetaData* f = files[level_ptrs_[lvl]];\n+      if (user_cmp->Compare(user_key, f->largest.user_key()) <= 0) {\n+        // We've advanced far enough\n+        if (user_cmp->Compare(user_key, f->smallest.user_key()) >= 0) {\n+          // Key falls in this file's range, so definitely not base level\n+          return false;\n+        }\n+        break;\n+      }\n+      level_ptrs_[lvl]++;\n+    }\n+  }\n+  return true;\n+}\n+\n+bool Compaction::ShouldStopBefore(const Slice& internal_key) {\n+  // Scan to find earliest grandparent file that contains key.\n+  const InternalKeyComparator* icmp = &input_version_->vset_->icmp_;\n+  while (grandparent_index_ < grandparents_.size() &&\n+      icmp->Compare(internal_key,\n+                    grandparents_[grandparent_index_]->largest.Encode()) > 0) {\n+    if (seen_key_) {\n+      overlapped_bytes_ += grandparents_[grandparent_index_]->file_size;\n+    }\n+    grandparent_index_++;\n+  }\n+  seen_key_ = true;\n+\n+  if (overlapped_bytes_ > kMaxGrandParentOverlapBytes) {\n+    // Too much overlap for current output; start new output\n+    overlapped_bytes_ = 0;\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+void Compaction::ReleaseInputs() {\n+  if (input_version_ != NULL) {\n+    input_version_->Unref();\n+    input_version_ = NULL;\n+  }\n+}\n+\n+}  // namespace leveldb"
      },
      {
        "sha": "61c4c99a08636344fff7369be294e6f5c39c6597",
        "filename": "src/leveldb/db/version_set.h",
        "status": "added",
        "additions": 379,
        "deletions": 0,
        "changes": 379,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/version_set.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/version_set.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/version_set.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,379 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+//\n+// The representation of a DBImpl consists of a set of Versions.  The\n+// newest version is called \"current\".  Older versions may be kept\n+// around to provide a consistent view to live iterators.\n+//\n+// Each Version keeps track of a set of Table files per level.  The\n+// entire set of versions is maintained in a VersionSet.\n+//\n+// Version,VersionSet are thread-compatible, but require external\n+// synchronization on all accesses.\n+\n+#ifndef STORAGE_LEVELDB_DB_VERSION_SET_H_\n+#define STORAGE_LEVELDB_DB_VERSION_SET_H_\n+\n+#include <map>\n+#include <set>\n+#include <vector>\n+#include \"db/dbformat.h\"\n+#include \"db/version_edit.h\"\n+#include \"port/port.h\"\n+\n+namespace leveldb {\n+\n+namespace log { class Writer; }\n+\n+class Compaction;\n+class Iterator;\n+class MemTable;\n+class TableBuilder;\n+class TableCache;\n+class Version;\n+class VersionSet;\n+class WritableFile;\n+\n+// Return the smallest index i such that files[i]->largest >= key.\n+// Return files.size() if there is no such file.\n+// REQUIRES: \"files\" contains a sorted list of non-overlapping files.\n+extern int FindFile(const InternalKeyComparator& icmp,\n+                    const std::vector<FileMetaData*>& files,\n+                    const Slice& key);\n+\n+// Returns true iff some file in \"files\" overlaps the user key range\n+// [*smallest,*largest].\n+// smallest==NULL represents a key smaller than all keys in the DB.\n+// largest==NULL represents a key largest than all keys in the DB.\n+// REQUIRES: If disjoint_sorted_files, files[] contains disjoint ranges\n+//           in sorted order.\n+extern bool SomeFileOverlapsRange(\n+    const InternalKeyComparator& icmp,\n+    bool disjoint_sorted_files,\n+    const std::vector<FileMetaData*>& files,\n+    const Slice* smallest_user_key,\n+    const Slice* largest_user_key);\n+\n+class Version {\n+ public:\n+  // Append to *iters a sequence of iterators that will\n+  // yield the contents of this Version when merged together.\n+  // REQUIRES: This version has been saved (see VersionSet::SaveTo)\n+  void AddIterators(const ReadOptions&, std::vector<Iterator*>* iters);\n+\n+  // Lookup the value for key.  If found, store it in *val and\n+  // return OK.  Else return a non-OK status.  Fills *stats.\n+  // REQUIRES: lock is not held\n+  struct GetStats {\n+    FileMetaData* seek_file;\n+    int seek_file_level;\n+  };\n+  Status Get(const ReadOptions&, const LookupKey& key, std::string* val,\n+             GetStats* stats);\n+\n+  // Adds \"stats\" into the current state.  Returns true if a new\n+  // compaction may need to be triggered, false otherwise.\n+  // REQUIRES: lock is held\n+  bool UpdateStats(const GetStats& stats);\n+\n+  // Reference count management (so Versions do not disappear out from\n+  // under live iterators)\n+  void Ref();\n+  void Unref();\n+\n+  void GetOverlappingInputs(\n+      int level,\n+      const InternalKey* begin,         // NULL means before all keys\n+      const InternalKey* end,           // NULL means after all keys\n+      std::vector<FileMetaData*>* inputs);\n+\n+  // Returns true iff some file in the specified level overlaps\n+  // some part of [*smallest_user_key,*largest_user_key].\n+  // smallest_user_key==NULL represents a key smaller than all keys in the DB.\n+  // largest_user_key==NULL represents a key largest than all keys in the DB.\n+  bool OverlapInLevel(int level,\n+                      const Slice* smallest_user_key,\n+                      const Slice* largest_user_key);\n+\n+  // Return the level at which we should place a new memtable compaction\n+  // result that covers the range [smallest_user_key,largest_user_key].\n+  int PickLevelForMemTableOutput(const Slice& smallest_user_key,\n+                                 const Slice& largest_user_key);\n+\n+  int NumFiles(int level) const { return files_[level].size(); }\n+\n+  // Return a human readable string that describes this version's contents.\n+  std::string DebugString() const;\n+\n+ private:\n+  friend class Compaction;\n+  friend class VersionSet;\n+\n+  class LevelFileNumIterator;\n+  Iterator* NewConcatenatingIterator(const ReadOptions&, int level) const;\n+\n+  VersionSet* vset_;            // VersionSet to which this Version belongs\n+  Version* next_;               // Next version in linked list\n+  Version* prev_;               // Previous version in linked list\n+  int refs_;                    // Number of live refs to this version\n+\n+  // List of files per level\n+  std::vector<FileMetaData*> files_[config::kNumLevels];\n+\n+  // Next file to compact based on seek stats.\n+  FileMetaData* file_to_compact_;\n+  int file_to_compact_level_;\n+\n+  // Level that should be compacted next and its compaction score.\n+  // Score < 1 means compaction is not strictly needed.  These fields\n+  // are initialized by Finalize().\n+  double compaction_score_;\n+  int compaction_level_;\n+\n+  explicit Version(VersionSet* vset)\n+      : vset_(vset), next_(this), prev_(this), refs_(0),\n+        file_to_compact_(NULL),\n+        file_to_compact_level_(-1),\n+        compaction_score_(-1),\n+        compaction_level_(-1) {\n+  }\n+\n+  ~Version();\n+\n+  // No copying allowed\n+  Version(const Version&);\n+  void operator=(const Version&);\n+};\n+\n+class VersionSet {\n+ public:\n+  VersionSet(const std::string& dbname,\n+             const Options* options,\n+             TableCache* table_cache,\n+             const InternalKeyComparator*);\n+  ~VersionSet();\n+\n+  // Apply *edit to the current version to form a new descriptor that\n+  // is both saved to persistent state and installed as the new\n+  // current version.  Will release *mu while actually writing to the file.\n+  // REQUIRES: *mu is held on entry.\n+  // REQUIRES: no other thread concurrently calls LogAndApply()\n+  Status LogAndApply(VersionEdit* edit, port::Mutex* mu);\n+\n+  // Recover the last saved descriptor from persistent storage.\n+  Status Recover();\n+\n+  // Return the current version.\n+  Version* current() const { return current_; }\n+\n+  // Return the current manifest file number\n+  uint64_t ManifestFileNumber() const { return manifest_file_number_; }\n+\n+  // Allocate and return a new file number\n+  uint64_t NewFileNumber() { return next_file_number_++; }\n+\n+  // Arrange to reuse \"file_number\" unless a newer file number has\n+  // already been allocated.\n+  // REQUIRES: \"file_number\" was returned by a call to NewFileNumber().\n+  void ReuseFileNumber(uint64_t file_number) {\n+    if (next_file_number_ == file_number + 1) {\n+      next_file_number_ = file_number;\n+    }\n+  }\n+\n+  // Return the number of Table files at the specified level.\n+  int NumLevelFiles(int level) const;\n+\n+  // Return the combined file size of all files at the specified level.\n+  int64_t NumLevelBytes(int level) const;\n+\n+  // Return the last sequence number.\n+  uint64_t LastSequence() const { return last_sequence_; }\n+\n+  // Set the last sequence number to s.\n+  void SetLastSequence(uint64_t s) {\n+    assert(s >= last_sequence_);\n+    last_sequence_ = s;\n+  }\n+\n+  // Mark the specified file number as used.\n+  void MarkFileNumberUsed(uint64_t number);\n+\n+  // Return the current log file number.\n+  uint64_t LogNumber() const { return log_number_; }\n+\n+  // Return the log file number for the log file that is currently\n+  // being compacted, or zero if there is no such log file.\n+  uint64_t PrevLogNumber() const { return prev_log_number_; }\n+\n+  // Pick level and inputs for a new compaction.\n+  // Returns NULL if there is no compaction to be done.\n+  // Otherwise returns a pointer to a heap-allocated object that\n+  // describes the compaction.  Caller should delete the result.\n+  Compaction* PickCompaction();\n+\n+  // Return a compaction object for compacting the range [begin,end] in\n+  // the specified level.  Returns NULL if there is nothing in that\n+  // level that overlaps the specified range.  Caller should delete\n+  // the result.\n+  Compaction* CompactRange(\n+      int level,\n+      const InternalKey* begin,\n+      const InternalKey* end);\n+\n+  // Return the maximum overlapping data (in bytes) at next level for any\n+  // file at a level >= 1.\n+  int64_t MaxNextLevelOverlappingBytes();\n+\n+  // Create an iterator that reads over the compaction inputs for \"*c\".\n+  // The caller should delete the iterator when no longer needed.\n+  Iterator* MakeInputIterator(Compaction* c);\n+\n+  // Returns true iff some level needs a compaction.\n+  bool NeedsCompaction() const {\n+    Version* v = current_;\n+    return (v->compaction_score_ >= 1) || (v->file_to_compact_ != NULL);\n+  }\n+\n+  // Add all files listed in any live version to *live.\n+  // May also mutate some internal state.\n+  void AddLiveFiles(std::set<uint64_t>* live);\n+\n+  // Return the approximate offset in the database of the data for\n+  // \"key\" as of version \"v\".\n+  uint64_t ApproximateOffsetOf(Version* v, const InternalKey& key);\n+\n+  // Return a human-readable short (single-line) summary of the number\n+  // of files per level.  Uses *scratch as backing store.\n+  struct LevelSummaryStorage {\n+    char buffer[100];\n+  };\n+  const char* LevelSummary(LevelSummaryStorage* scratch) const;\n+\n+ private:\n+  class Builder;\n+\n+  friend class Compaction;\n+  friend class Version;\n+\n+  void Finalize(Version* v);\n+\n+  void GetRange(const std::vector<FileMetaData*>& inputs,\n+                InternalKey* smallest,\n+                InternalKey* largest);\n+\n+  void GetRange2(const std::vector<FileMetaData*>& inputs1,\n+                 const std::vector<FileMetaData*>& inputs2,\n+                 InternalKey* smallest,\n+                 InternalKey* largest);\n+\n+  void SetupOtherInputs(Compaction* c);\n+\n+  // Save current contents to *log\n+  Status WriteSnapshot(log::Writer* log);\n+\n+  void AppendVersion(Version* v);\n+\n+  Env* const env_;\n+  const std::string dbname_;\n+  const Options* const options_;\n+  TableCache* const table_cache_;\n+  const InternalKeyComparator icmp_;\n+  uint64_t next_file_number_;\n+  uint64_t manifest_file_number_;\n+  uint64_t last_sequence_;\n+  uint64_t log_number_;\n+  uint64_t prev_log_number_;  // 0 or backing store for memtable being compacted\n+\n+  // Opened lazily\n+  WritableFile* descriptor_file_;\n+  log::Writer* descriptor_log_;\n+  Version dummy_versions_;  // Head of circular doubly-linked list of versions.\n+  Version* current_;        // == dummy_versions_.prev_\n+\n+  // Per-level key at which the next compaction at that level should start.\n+  // Either an empty string, or a valid InternalKey.\n+  std::string compact_pointer_[config::kNumLevels];\n+\n+  // No copying allowed\n+  VersionSet(const VersionSet&);\n+  void operator=(const VersionSet&);\n+};\n+\n+// A Compaction encapsulates information about a compaction.\n+class Compaction {\n+ public:\n+  ~Compaction();\n+\n+  // Return the level that is being compacted.  Inputs from \"level\"\n+  // and \"level+1\" will be merged to produce a set of \"level+1\" files.\n+  int level() const { return level_; }\n+\n+  // Return the object that holds the edits to the descriptor done\n+  // by this compaction.\n+  VersionEdit* edit() { return &edit_; }\n+\n+  // \"which\" must be either 0 or 1\n+  int num_input_files(int which) const { return inputs_[which].size(); }\n+\n+  // Return the ith input file at \"level()+which\" (\"which\" must be 0 or 1).\n+  FileMetaData* input(int which, int i) const { return inputs_[which][i]; }\n+\n+  // Maximum size of files to build during this compaction.\n+  uint64_t MaxOutputFileSize() const { return max_output_file_size_; }\n+\n+  // Is this a trivial compaction that can be implemented by just\n+  // moving a single input file to the next level (no merging or splitting)\n+  bool IsTrivialMove() const;\n+\n+  // Add all inputs to this compaction as delete operations to *edit.\n+  void AddInputDeletions(VersionEdit* edit);\n+\n+  // Returns true if the information we have available guarantees that\n+  // the compaction is producing data in \"level+1\" for which no data exists\n+  // in levels greater than \"level+1\".\n+  bool IsBaseLevelForKey(const Slice& user_key);\n+\n+  // Returns true iff we should stop building the current output\n+  // before processing \"internal_key\".\n+  bool ShouldStopBefore(const Slice& internal_key);\n+\n+  // Release the input version for the compaction, once the compaction\n+  // is successful.\n+  void ReleaseInputs();\n+\n+ private:\n+  friend class Version;\n+  friend class VersionSet;\n+\n+  explicit Compaction(int level);\n+\n+  int level_;\n+  uint64_t max_output_file_size_;\n+  Version* input_version_;\n+  VersionEdit edit_;\n+\n+  // Each compaction reads inputs from \"level_\" and \"level_+1\"\n+  std::vector<FileMetaData*> inputs_[2];      // The two sets of inputs\n+\n+  // State used to check for number of of overlapping grandparent files\n+  // (parent == level_ + 1, grandparent == level_ + 2)\n+  std::vector<FileMetaData*> grandparents_;\n+  size_t grandparent_index_;  // Index in grandparent_starts_\n+  bool seen_key_;             // Some output key has been seen\n+  int64_t overlapped_bytes_;  // Bytes of overlap between current output\n+                              // and grandparent files\n+\n+  // State for implementing IsBaseLevelForKey\n+\n+  // level_ptrs_ holds indices into input_version_->levels_: our state\n+  // is that we are positioned at one of the file ranges for each\n+  // higher level than the ones involved in this compaction (i.e. for\n+  // all L >= level_ + 2).\n+  size_t level_ptrs_[config::kNumLevels];\n+};\n+\n+}  // namespace leveldb\n+\n+#endif  // STORAGE_LEVELDB_DB_VERSION_SET_H_"
      },
      {
        "sha": "501e34d1337d3917185b70369d9982db54e787aa",
        "filename": "src/leveldb/db/version_set_test.cc",
        "status": "added",
        "additions": 179,
        "deletions": 0,
        "changes": 179,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/version_set_test.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/version_set_test.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/version_set_test.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,179 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include \"db/version_set.h\"\n+#include \"util/logging.h\"\n+#include \"util/testharness.h\"\n+#include \"util/testutil.h\"\n+\n+namespace leveldb {\n+\n+class FindFileTest {\n+ public:\n+  std::vector<FileMetaData*> files_;\n+  bool disjoint_sorted_files_;\n+\n+  FindFileTest() : disjoint_sorted_files_(true) { }\n+\n+  ~FindFileTest() {\n+    for (int i = 0; i < files_.size(); i++) {\n+      delete files_[i];\n+    }\n+  }\n+\n+  void Add(const char* smallest, const char* largest,\n+           SequenceNumber smallest_seq = 100,\n+           SequenceNumber largest_seq = 100) {\n+    FileMetaData* f = new FileMetaData;\n+    f->number = files_.size() + 1;\n+    f->smallest = InternalKey(smallest, smallest_seq, kTypeValue);\n+    f->largest = InternalKey(largest, largest_seq, kTypeValue);\n+    files_.push_back(f);\n+  }\n+\n+  int Find(const char* key) {\n+    InternalKey target(key, 100, kTypeValue);\n+    InternalKeyComparator cmp(BytewiseComparator());\n+    return FindFile(cmp, files_, target.Encode());\n+  }\n+\n+  bool Overlaps(const char* smallest, const char* largest) {\n+    InternalKeyComparator cmp(BytewiseComparator());\n+    Slice s(smallest != NULL ? smallest : \"\");\n+    Slice l(largest != NULL ? largest : \"\");\n+    return SomeFileOverlapsRange(cmp, disjoint_sorted_files_, files_,\n+                                 (smallest != NULL ? &s : NULL),\n+                                 (largest != NULL ? &l : NULL));\n+  }\n+};\n+\n+TEST(FindFileTest, Empty) {\n+  ASSERT_EQ(0, Find(\"foo\"));\n+  ASSERT_TRUE(! Overlaps(\"a\", \"z\"));\n+  ASSERT_TRUE(! Overlaps(NULL, \"z\"));\n+  ASSERT_TRUE(! Overlaps(\"a\", NULL));\n+  ASSERT_TRUE(! Overlaps(NULL, NULL));\n+}\n+\n+TEST(FindFileTest, Single) {\n+  Add(\"p\", \"q\");\n+  ASSERT_EQ(0, Find(\"a\"));\n+  ASSERT_EQ(0, Find(\"p\"));\n+  ASSERT_EQ(0, Find(\"p1\"));\n+  ASSERT_EQ(0, Find(\"q\"));\n+  ASSERT_EQ(1, Find(\"q1\"));\n+  ASSERT_EQ(1, Find(\"z\"));\n+\n+  ASSERT_TRUE(! Overlaps(\"a\", \"b\"));\n+  ASSERT_TRUE(! Overlaps(\"z1\", \"z2\"));\n+  ASSERT_TRUE(Overlaps(\"a\", \"p\"));\n+  ASSERT_TRUE(Overlaps(\"a\", \"q\"));\n+  ASSERT_TRUE(Overlaps(\"a\", \"z\"));\n+  ASSERT_TRUE(Overlaps(\"p\", \"p1\"));\n+  ASSERT_TRUE(Overlaps(\"p\", \"q\"));\n+  ASSERT_TRUE(Overlaps(\"p\", \"z\"));\n+  ASSERT_TRUE(Overlaps(\"p1\", \"p2\"));\n+  ASSERT_TRUE(Overlaps(\"p1\", \"z\"));\n+  ASSERT_TRUE(Overlaps(\"q\", \"q\"));\n+  ASSERT_TRUE(Overlaps(\"q\", \"q1\"));\n+\n+  ASSERT_TRUE(! Overlaps(NULL, \"j\"));\n+  ASSERT_TRUE(! Overlaps(\"r\", NULL));\n+  ASSERT_TRUE(Overlaps(NULL, \"p\"));\n+  ASSERT_TRUE(Overlaps(NULL, \"p1\"));\n+  ASSERT_TRUE(Overlaps(\"q\", NULL));\n+  ASSERT_TRUE(Overlaps(NULL, NULL));\n+}\n+\n+\n+TEST(FindFileTest, Multiple) {\n+  Add(\"150\", \"200\");\n+  Add(\"200\", \"250\");\n+  Add(\"300\", \"350\");\n+  Add(\"400\", \"450\");\n+  ASSERT_EQ(0, Find(\"100\"));\n+  ASSERT_EQ(0, Find(\"150\"));\n+  ASSERT_EQ(0, Find(\"151\"));\n+  ASSERT_EQ(0, Find(\"199\"));\n+  ASSERT_EQ(0, Find(\"200\"));\n+  ASSERT_EQ(1, Find(\"201\"));\n+  ASSERT_EQ(1, Find(\"249\"));\n+  ASSERT_EQ(1, Find(\"250\"));\n+  ASSERT_EQ(2, Find(\"251\"));\n+  ASSERT_EQ(2, Find(\"299\"));\n+  ASSERT_EQ(2, Find(\"300\"));\n+  ASSERT_EQ(2, Find(\"349\"));\n+  ASSERT_EQ(2, Find(\"350\"));\n+  ASSERT_EQ(3, Find(\"351\"));\n+  ASSERT_EQ(3, Find(\"400\"));\n+  ASSERT_EQ(3, Find(\"450\"));\n+  ASSERT_EQ(4, Find(\"451\"));\n+\n+  ASSERT_TRUE(! Overlaps(\"100\", \"149\"));\n+  ASSERT_TRUE(! Overlaps(\"251\", \"299\"));\n+  ASSERT_TRUE(! Overlaps(\"451\", \"500\"));\n+  ASSERT_TRUE(! Overlaps(\"351\", \"399\"));\n+\n+  ASSERT_TRUE(Overlaps(\"100\", \"150\"));\n+  ASSERT_TRUE(Overlaps(\"100\", \"200\"));\n+  ASSERT_TRUE(Overlaps(\"100\", \"300\"));\n+  ASSERT_TRUE(Overlaps(\"100\", \"400\"));\n+  ASSERT_TRUE(Overlaps(\"100\", \"500\"));\n+  ASSERT_TRUE(Overlaps(\"375\", \"400\"));\n+  ASSERT_TRUE(Overlaps(\"450\", \"450\"));\n+  ASSERT_TRUE(Overlaps(\"450\", \"500\"));\n+}\n+\n+TEST(FindFileTest, MultipleNullBoundaries) {\n+  Add(\"150\", \"200\");\n+  Add(\"200\", \"250\");\n+  Add(\"300\", \"350\");\n+  Add(\"400\", \"450\");\n+  ASSERT_TRUE(! Overlaps(NULL, \"149\"));\n+  ASSERT_TRUE(! Overlaps(\"451\", NULL));\n+  ASSERT_TRUE(Overlaps(NULL, NULL));\n+  ASSERT_TRUE(Overlaps(NULL, \"150\"));\n+  ASSERT_TRUE(Overlaps(NULL, \"199\"));\n+  ASSERT_TRUE(Overlaps(NULL, \"200\"));\n+  ASSERT_TRUE(Overlaps(NULL, \"201\"));\n+  ASSERT_TRUE(Overlaps(NULL, \"400\"));\n+  ASSERT_TRUE(Overlaps(NULL, \"800\"));\n+  ASSERT_TRUE(Overlaps(\"100\", NULL));\n+  ASSERT_TRUE(Overlaps(\"200\", NULL));\n+  ASSERT_TRUE(Overlaps(\"449\", NULL));\n+  ASSERT_TRUE(Overlaps(\"450\", NULL));\n+}\n+\n+TEST(FindFileTest, OverlapSequenceChecks) {\n+  Add(\"200\", \"200\", 5000, 3000);\n+  ASSERT_TRUE(! Overlaps(\"199\", \"199\"));\n+  ASSERT_TRUE(! Overlaps(\"201\", \"300\"));\n+  ASSERT_TRUE(Overlaps(\"200\", \"200\"));\n+  ASSERT_TRUE(Overlaps(\"190\", \"200\"));\n+  ASSERT_TRUE(Overlaps(\"200\", \"210\"));\n+}\n+\n+TEST(FindFileTest, OverlappingFiles) {\n+  Add(\"150\", \"600\");\n+  Add(\"400\", \"500\");\n+  disjoint_sorted_files_ = false;\n+  ASSERT_TRUE(! Overlaps(\"100\", \"149\"));\n+  ASSERT_TRUE(! Overlaps(\"601\", \"700\"));\n+  ASSERT_TRUE(Overlaps(\"100\", \"150\"));\n+  ASSERT_TRUE(Overlaps(\"100\", \"200\"));\n+  ASSERT_TRUE(Overlaps(\"100\", \"300\"));\n+  ASSERT_TRUE(Overlaps(\"100\", \"400\"));\n+  ASSERT_TRUE(Overlaps(\"100\", \"500\"));\n+  ASSERT_TRUE(Overlaps(\"375\", \"400\"));\n+  ASSERT_TRUE(Overlaps(\"450\", \"450\"));\n+  ASSERT_TRUE(Overlaps(\"450\", \"500\"));\n+  ASSERT_TRUE(Overlaps(\"450\", \"700\"));\n+  ASSERT_TRUE(Overlaps(\"600\", \"700\"));\n+}\n+\n+}  // namespace leveldb\n+\n+int main(int argc, char** argv) {\n+  return leveldb::test::RunAllTests();\n+}"
      },
      {
        "sha": "33f4a4257ea94e0105a9368de79d761ac7bf979a",
        "filename": "src/leveldb/db/write_batch.cc",
        "status": "added",
        "additions": 147,
        "deletions": 0,
        "changes": 147,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/write_batch.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/write_batch.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/write_batch.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,147 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+//\n+// WriteBatch::rep_ :=\n+//    sequence: fixed64\n+//    count: fixed32\n+//    data: record[count]\n+// record :=\n+//    kTypeValue varstring varstring         |\n+//    kTypeDeletion varstring\n+// varstring :=\n+//    len: varint32\n+//    data: uint8[len]\n+\n+#include \"leveldb/write_batch.h\"\n+\n+#include \"leveldb/db.h\"\n+#include \"db/dbformat.h\"\n+#include \"db/memtable.h\"\n+#include \"db/write_batch_internal.h\"\n+#include \"util/coding.h\"\n+\n+namespace leveldb {\n+\n+// WriteBatch header has an 8-byte sequence number followed by a 4-byte count.\n+static const size_t kHeader = 12;\n+\n+WriteBatch::WriteBatch() {\n+  Clear();\n+}\n+\n+WriteBatch::~WriteBatch() { }\n+\n+WriteBatch::Handler::~Handler() { }\n+\n+void WriteBatch::Clear() {\n+  rep_.clear();\n+  rep_.resize(kHeader);\n+}\n+\n+Status WriteBatch::Iterate(Handler* handler) const {\n+  Slice input(rep_);\n+  if (input.size() < kHeader) {\n+    return Status::Corruption(\"malformed WriteBatch (too small)\");\n+  }\n+\n+  input.remove_prefix(kHeader);\n+  Slice key, value;\n+  int found = 0;\n+  while (!input.empty()) {\n+    found++;\n+    char tag = input[0];\n+    input.remove_prefix(1);\n+    switch (tag) {\n+      case kTypeValue:\n+        if (GetLengthPrefixedSlice(&input, &key) &&\n+            GetLengthPrefixedSlice(&input, &value)) {\n+          handler->Put(key, value);\n+        } else {\n+          return Status::Corruption(\"bad WriteBatch Put\");\n+        }\n+        break;\n+      case kTypeDeletion:\n+        if (GetLengthPrefixedSlice(&input, &key)) {\n+          handler->Delete(key);\n+        } else {\n+          return Status::Corruption(\"bad WriteBatch Delete\");\n+        }\n+        break;\n+      default:\n+        return Status::Corruption(\"unknown WriteBatch tag\");\n+    }\n+  }\n+  if (found != WriteBatchInternal::Count(this)) {\n+    return Status::Corruption(\"WriteBatch has wrong count\");\n+  } else {\n+    return Status::OK();\n+  }\n+}\n+\n+int WriteBatchInternal::Count(const WriteBatch* b) {\n+  return DecodeFixed32(b->rep_.data() + 8);\n+}\n+\n+void WriteBatchInternal::SetCount(WriteBatch* b, int n) {\n+  EncodeFixed32(&b->rep_[8], n);\n+}\n+\n+SequenceNumber WriteBatchInternal::Sequence(const WriteBatch* b) {\n+  return SequenceNumber(DecodeFixed64(b->rep_.data()));\n+}\n+\n+void WriteBatchInternal::SetSequence(WriteBatch* b, SequenceNumber seq) {\n+  EncodeFixed64(&b->rep_[0], seq);\n+}\n+\n+void WriteBatch::Put(const Slice& key, const Slice& value) {\n+  WriteBatchInternal::SetCount(this, WriteBatchInternal::Count(this) + 1);\n+  rep_.push_back(static_cast<char>(kTypeValue));\n+  PutLengthPrefixedSlice(&rep_, key);\n+  PutLengthPrefixedSlice(&rep_, value);\n+}\n+\n+void WriteBatch::Delete(const Slice& key) {\n+  WriteBatchInternal::SetCount(this, WriteBatchInternal::Count(this) + 1);\n+  rep_.push_back(static_cast<char>(kTypeDeletion));\n+  PutLengthPrefixedSlice(&rep_, key);\n+}\n+\n+namespace {\n+class MemTableInserter : public WriteBatch::Handler {\n+ public:\n+  SequenceNumber sequence_;\n+  MemTable* mem_;\n+\n+  virtual void Put(const Slice& key, const Slice& value) {\n+    mem_->Add(sequence_, kTypeValue, key, value);\n+    sequence_++;\n+  }\n+  virtual void Delete(const Slice& key) {\n+    mem_->Add(sequence_, kTypeDeletion, key, Slice());\n+    sequence_++;\n+  }\n+};\n+}  // namespace\n+\n+Status WriteBatchInternal::InsertInto(const WriteBatch* b,\n+                                      MemTable* memtable) {\n+  MemTableInserter inserter;\n+  inserter.sequence_ = WriteBatchInternal::Sequence(b);\n+  inserter.mem_ = memtable;\n+  return b->Iterate(&inserter);\n+}\n+\n+void WriteBatchInternal::SetContents(WriteBatch* b, const Slice& contents) {\n+  assert(contents.size() >= kHeader);\n+  b->rep_.assign(contents.data(), contents.size());\n+}\n+\n+void WriteBatchInternal::Append(WriteBatch* dst, const WriteBatch* src) {\n+  SetCount(dst, Count(dst) + Count(src));\n+  assert(src->rep_.size() >= kHeader);\n+  dst->rep_.append(src->rep_.data() + kHeader, src->rep_.size() - kHeader);\n+}\n+\n+}  // namespace leveldb"
      },
      {
        "sha": "4423a7f31842457dea62d43547616b2f5ec852f8",
        "filename": "src/leveldb/db/write_batch_internal.h",
        "status": "added",
        "additions": 49,
        "deletions": 0,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/write_batch_internal.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/write_batch_internal.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/write_batch_internal.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,49 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#ifndef STORAGE_LEVELDB_DB_WRITE_BATCH_INTERNAL_H_\n+#define STORAGE_LEVELDB_DB_WRITE_BATCH_INTERNAL_H_\n+\n+#include \"leveldb/write_batch.h\"\n+\n+namespace leveldb {\n+\n+class MemTable;\n+\n+// WriteBatchInternal provides static methods for manipulating a\n+// WriteBatch that we don't want in the public WriteBatch interface.\n+class WriteBatchInternal {\n+ public:\n+  // Return the number of entries in the batch.\n+  static int Count(const WriteBatch* batch);\n+\n+  // Set the count for the number of entries in the batch.\n+  static void SetCount(WriteBatch* batch, int n);\n+\n+  // Return the seqeunce number for the start of this batch.\n+  static SequenceNumber Sequence(const WriteBatch* batch);\n+\n+  // Store the specified number as the seqeunce number for the start of\n+  // this batch.\n+  static void SetSequence(WriteBatch* batch, SequenceNumber seq);\n+\n+  static Slice Contents(const WriteBatch* batch) {\n+    return Slice(batch->rep_);\n+  }\n+\n+  static size_t ByteSize(const WriteBatch* batch) {\n+    return batch->rep_.size();\n+  }\n+\n+  static void SetContents(WriteBatch* batch, const Slice& contents);\n+\n+  static Status InsertInto(const WriteBatch* batch, MemTable* memtable);\n+\n+  static void Append(WriteBatch* dst, const WriteBatch* src);\n+};\n+\n+}  // namespace leveldb\n+\n+\n+#endif  // STORAGE_LEVELDB_DB_WRITE_BATCH_INTERNAL_H_"
      },
      {
        "sha": "9064e3d85eb35f32d20ef4c7456b0866d525aee8",
        "filename": "src/leveldb/db/write_batch_test.cc",
        "status": "added",
        "additions": 120,
        "deletions": 0,
        "changes": 120,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/write_batch_test.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/db/write_batch_test.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/write_batch_test.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,120 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include \"leveldb/db.h\"\n+\n+#include \"db/memtable.h\"\n+#include \"db/write_batch_internal.h\"\n+#include \"leveldb/env.h\"\n+#include \"util/logging.h\"\n+#include \"util/testharness.h\"\n+\n+namespace leveldb {\n+\n+static std::string PrintContents(WriteBatch* b) {\n+  InternalKeyComparator cmp(BytewiseComparator());\n+  MemTable* mem = new MemTable(cmp);\n+  mem->Ref();\n+  std::string state;\n+  Status s = WriteBatchInternal::InsertInto(b, mem);\n+  int count = 0;\n+  Iterator* iter = mem->NewIterator();\n+  for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n+    ParsedInternalKey ikey;\n+    ASSERT_TRUE(ParseInternalKey(iter->key(), &ikey));\n+    switch (ikey.type) {\n+      case kTypeValue:\n+        state.append(\"Put(\");\n+        state.append(ikey.user_key.ToString());\n+        state.append(\", \");\n+        state.append(iter->value().ToString());\n+        state.append(\")\");\n+        count++;\n+        break;\n+      case kTypeDeletion:\n+        state.append(\"Delete(\");\n+        state.append(ikey.user_key.ToString());\n+        state.append(\")\");\n+        count++;\n+        break;\n+    }\n+    state.append(\"@\");\n+    state.append(NumberToString(ikey.sequence));\n+  }\n+  delete iter;\n+  if (!s.ok()) {\n+    state.append(\"ParseError()\");\n+  } else if (count != WriteBatchInternal::Count(b)) {\n+    state.append(\"CountMismatch()\");\n+  }\n+  mem->Unref();\n+  return state;\n+}\n+\n+class WriteBatchTest { };\n+\n+TEST(WriteBatchTest, Empty) {\n+  WriteBatch batch;\n+  ASSERT_EQ(\"\", PrintContents(&batch));\n+  ASSERT_EQ(0, WriteBatchInternal::Count(&batch));\n+}\n+\n+TEST(WriteBatchTest, Multiple) {\n+  WriteBatch batch;\n+  batch.Put(Slice(\"foo\"), Slice(\"bar\"));\n+  batch.Delete(Slice(\"box\"));\n+  batch.Put(Slice(\"baz\"), Slice(\"boo\"));\n+  WriteBatchInternal::SetSequence(&batch, 100);\n+  ASSERT_EQ(100, WriteBatchInternal::Sequence(&batch));\n+  ASSERT_EQ(3, WriteBatchInternal::Count(&batch));\n+  ASSERT_EQ(\"Put(baz, boo)@102\"\n+            \"Delete(box)@101\"\n+            \"Put(foo, bar)@100\",\n+            PrintContents(&batch));\n+}\n+\n+TEST(WriteBatchTest, Corruption) {\n+  WriteBatch batch;\n+  batch.Put(Slice(\"foo\"), Slice(\"bar\"));\n+  batch.Delete(Slice(\"box\"));\n+  WriteBatchInternal::SetSequence(&batch, 200);\n+  Slice contents = WriteBatchInternal::Contents(&batch);\n+  WriteBatchInternal::SetContents(&batch,\n+                                  Slice(contents.data(),contents.size()-1));\n+  ASSERT_EQ(\"Put(foo, bar)@200\"\n+            \"ParseError()\",\n+            PrintContents(&batch));\n+}\n+\n+TEST(WriteBatchTest, Append) {\n+  WriteBatch b1, b2;\n+  WriteBatchInternal::SetSequence(&b1, 200);\n+  WriteBatchInternal::SetSequence(&b2, 300);\n+  WriteBatchInternal::Append(&b1, &b2);\n+  ASSERT_EQ(\"\",\n+            PrintContents(&b1));\n+  b2.Put(\"a\", \"va\");\n+  WriteBatchInternal::Append(&b1, &b2);\n+  ASSERT_EQ(\"Put(a, va)@200\",\n+            PrintContents(&b1));\n+  b2.Clear();\n+  b2.Put(\"b\", \"vb\");\n+  WriteBatchInternal::Append(&b1, &b2);\n+  ASSERT_EQ(\"Put(a, va)@200\"\n+            \"Put(b, vb)@201\",\n+            PrintContents(&b1));\n+  b2.Delete(\"foo\");\n+  WriteBatchInternal::Append(&b1, &b2);\n+  ASSERT_EQ(\"Put(a, va)@200\"\n+            \"Put(b, vb)@202\"\n+            \"Put(b, vb)@201\"\n+            \"Delete(foo)@203\",\n+            PrintContents(&b1));\n+}\n+\n+}  // namespace leveldb\n+\n+int main(int argc, char** argv) {\n+  return leveldb::test::RunAllTests();\n+}"
      },
      {
        "sha": "256793a9db77646c398eb4267ca62ad2cadacb55",
        "filename": "src/leveldb/doc/bench/db_bench_sqlite3.cc",
        "status": "added",
        "additions": 718,
        "deletions": 0,
        "changes": 718,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/doc/bench/db_bench_sqlite3.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/doc/bench/db_bench_sqlite3.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/bench/db_bench_sqlite3.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,718 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <sqlite3.h>\n+#include \"util/histogram.h\"\n+#include \"util/random.h\"\n+#include \"util/testutil.h\"\n+\n+// Comma-separated list of operations to run in the specified order\n+//   Actual benchmarks:\n+//\n+//   fillseq       -- write N values in sequential key order in async mode\n+//   fillseqsync   -- write N/100 values in sequential key order in sync mode\n+//   fillseqbatch  -- batch write N values in sequential key order in async mode\n+//   fillrandom    -- write N values in random key order in async mode\n+//   fillrandsync  -- write N/100 values in random key order in sync mode\n+//   fillrandbatch -- batch write N values in sequential key order in async mode\n+//   overwrite     -- overwrite N values in random key order in async mode\n+//   fillrand100K  -- write N/1000 100K values in random order in async mode\n+//   fillseq100K   -- write N/1000 100K values in sequential order in async mode\n+//   readseq       -- read N times sequentially\n+//   readrandom    -- read N times in random order\n+//   readrand100K  -- read N/1000 100K values in sequential order in async mode\n+static const char* FLAGS_benchmarks =\n+    \"fillseq,\"\n+    \"fillseqsync,\"\n+    \"fillseqbatch,\"\n+    \"fillrandom,\"\n+    \"fillrandsync,\"\n+    \"fillrandbatch,\"\n+    \"overwrite,\"\n+    \"overwritebatch,\"\n+    \"readrandom,\"\n+    \"readseq,\"\n+    \"fillrand100K,\"\n+    \"fillseq100K,\"\n+    \"readseq,\"\n+    \"readrand100K,\"\n+    ;\n+\n+// Number of key/values to place in database\n+static int FLAGS_num = 1000000;\n+\n+// Number of read operations to do.  If negative, do FLAGS_num reads.\n+static int FLAGS_reads = -1;\n+\n+// Size of each value\n+static int FLAGS_value_size = 100;\n+\n+// Print histogram of operation timings\n+static bool FLAGS_histogram = false;\n+\n+// Arrange to generate values that shrink to this fraction of\n+// their original size after compression\n+static double FLAGS_compression_ratio = 0.5;\n+\n+// Page size. Default 1 KB.\n+static int FLAGS_page_size = 1024;\n+\n+// Number of pages.\n+// Default cache size = FLAGS_page_size * FLAGS_num_pages = 4 MB.\n+static int FLAGS_num_pages = 4096;\n+\n+// If true, do not destroy the existing database.  If you set this\n+// flag and also specify a benchmark that wants a fresh database, that\n+// benchmark will fail.\n+static bool FLAGS_use_existing_db = false;\n+\n+// If true, we allow batch writes to occur\n+static bool FLAGS_transaction = true;\n+\n+// If true, we enable Write-Ahead Logging\n+static bool FLAGS_WAL_enabled = true;\n+\n+// Use the db with the following name.\n+static const char* FLAGS_db = NULL;\n+\n+inline\n+static void ExecErrorCheck(int status, char *err_msg) {\n+  if (status != SQLITE_OK) {\n+    fprintf(stderr, \"SQL error: %s\\n\", err_msg);\n+    sqlite3_free(err_msg);\n+    exit(1);\n+  }\n+}\n+\n+inline\n+static void StepErrorCheck(int status) {\n+  if (status != SQLITE_DONE) {\n+    fprintf(stderr, \"SQL step error: status = %d\\n\", status);\n+    exit(1);\n+  }\n+}\n+\n+inline\n+static void ErrorCheck(int status) {\n+  if (status != SQLITE_OK) {\n+    fprintf(stderr, \"sqlite3 error: status = %d\\n\", status);\n+    exit(1);\n+  }\n+}\n+\n+inline\n+static void WalCheckpoint(sqlite3* db_) {\n+  // Flush all writes to disk\n+  if (FLAGS_WAL_enabled) {\n+    sqlite3_wal_checkpoint_v2(db_, NULL, SQLITE_CHECKPOINT_FULL, NULL, NULL);\n+  }\n+}\n+\n+namespace leveldb {\n+\n+// Helper for quickly generating random data.\n+namespace {\n+class RandomGenerator {\n+ private:\n+  std::string data_;\n+  int pos_;\n+\n+ public:\n+  RandomGenerator() {\n+    // We use a limited amount of data over and over again and ensure\n+    // that it is larger than the compression window (32KB), and also\n+    // large enough to serve all typical value sizes we want to write.\n+    Random rnd(301);\n+    std::string piece;\n+    while (data_.size() < 1048576) {\n+      // Add a short fragment that is as compressible as specified\n+      // by FLAGS_compression_ratio.\n+      test::CompressibleString(&rnd, FLAGS_compression_ratio, 100, &piece);\n+      data_.append(piece);\n+    }\n+    pos_ = 0;\n+  }\n+\n+  Slice Generate(int len) {\n+    if (pos_ + len > data_.size()) {\n+      pos_ = 0;\n+      assert(len < data_.size());\n+    }\n+    pos_ += len;\n+    return Slice(data_.data() + pos_ - len, len);\n+  }\n+};\n+\n+static Slice TrimSpace(Slice s) {\n+  int start = 0;\n+  while (start < s.size() && isspace(s[start])) {\n+    start++;\n+  }\n+  int limit = s.size();\n+  while (limit > start && isspace(s[limit-1])) {\n+    limit--;\n+  }\n+  return Slice(s.data() + start, limit - start);\n+}\n+\n+}  // namespace\n+\n+class Benchmark {\n+ private:\n+  sqlite3* db_;\n+  int db_num_;\n+  int num_;\n+  int reads_;\n+  double start_;\n+  double last_op_finish_;\n+  int64_t bytes_;\n+  std::string message_;\n+  Histogram hist_;\n+  RandomGenerator gen_;\n+  Random rand_;\n+\n+  // State kept for progress messages\n+  int done_;\n+  int next_report_;     // When to report next\n+\n+  void PrintHeader() {\n+    const int kKeySize = 16;\n+    PrintEnvironment();\n+    fprintf(stdout, \"Keys:       %d bytes each\\n\", kKeySize);\n+    fprintf(stdout, \"Values:     %d bytes each\\n\", FLAGS_value_size);\n+    fprintf(stdout, \"Entries:    %d\\n\", num_);\n+    fprintf(stdout, \"RawSize:    %.1f MB (estimated)\\n\",\n+            ((static_cast<int64_t>(kKeySize + FLAGS_value_size) * num_)\n+             / 1048576.0));\n+    PrintWarnings();\n+    fprintf(stdout, \"------------------------------------------------\\n\");\n+  }\n+\n+  void PrintWarnings() {\n+#if defined(__GNUC__) && !defined(__OPTIMIZE__)\n+    fprintf(stdout,\n+            \"WARNING: Optimization is disabled: benchmarks unnecessarily slow\\n\"\n+            );\n+#endif\n+#ifndef NDEBUG\n+    fprintf(stdout,\n+            \"WARNING: Assertions are enabled; benchmarks unnecessarily slow\\n\");\n+#endif\n+  }\n+\n+  void PrintEnvironment() {\n+    fprintf(stderr, \"SQLite:     version %s\\n\", SQLITE_VERSION);\n+\n+#if defined(__linux)\n+    time_t now = time(NULL);\n+    fprintf(stderr, \"Date:       %s\", ctime(&now));  // ctime() adds newline\n+\n+    FILE* cpuinfo = fopen(\"/proc/cpuinfo\", \"r\");\n+    if (cpuinfo != NULL) {\n+      char line[1000];\n+      int num_cpus = 0;\n+      std::string cpu_type;\n+      std::string cache_size;\n+      while (fgets(line, sizeof(line), cpuinfo) != NULL) {\n+        const char* sep = strchr(line, ':');\n+        if (sep == NULL) {\n+          continue;\n+        }\n+        Slice key = TrimSpace(Slice(line, sep - 1 - line));\n+        Slice val = TrimSpace(Slice(sep + 1));\n+        if (key == \"model name\") {\n+          ++num_cpus;\n+          cpu_type = val.ToString();\n+        } else if (key == \"cache size\") {\n+          cache_size = val.ToString();\n+        }\n+      }\n+      fclose(cpuinfo);\n+      fprintf(stderr, \"CPU:        %d * %s\\n\", num_cpus, cpu_type.c_str());\n+      fprintf(stderr, \"CPUCache:   %s\\n\", cache_size.c_str());\n+    }\n+#endif\n+  }\n+\n+  void Start() {\n+    start_ = Env::Default()->NowMicros() * 1e-6;\n+    bytes_ = 0;\n+    message_.clear();\n+    last_op_finish_ = start_;\n+    hist_.Clear();\n+    done_ = 0;\n+    next_report_ = 100;\n+  }\n+\n+  void FinishedSingleOp() {\n+    if (FLAGS_histogram) {\n+      double now = Env::Default()->NowMicros() * 1e-6;\n+      double micros = (now - last_op_finish_) * 1e6;\n+      hist_.Add(micros);\n+      if (micros > 20000) {\n+        fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n+        fflush(stderr);\n+      }\n+      last_op_finish_ = now;\n+    }\n+\n+    done_++;\n+    if (done_ >= next_report_) {\n+      if      (next_report_ < 1000)   next_report_ += 100;\n+      else if (next_report_ < 5000)   next_report_ += 500;\n+      else if (next_report_ < 10000)  next_report_ += 1000;\n+      else if (next_report_ < 50000)  next_report_ += 5000;\n+      else if (next_report_ < 100000) next_report_ += 10000;\n+      else if (next_report_ < 500000) next_report_ += 50000;\n+      else                            next_report_ += 100000;\n+      fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n+      fflush(stderr);\n+    }\n+  }\n+\n+  void Stop(const Slice& name) {\n+    double finish = Env::Default()->NowMicros() * 1e-6;\n+\n+    // Pretend at least one op was done in case we are running a benchmark\n+    // that does not call FinishedSingleOp().\n+    if (done_ < 1) done_ = 1;\n+\n+    if (bytes_ > 0) {\n+      char rate[100];\n+      snprintf(rate, sizeof(rate), \"%6.1f MB/s\",\n+               (bytes_ / 1048576.0) / (finish - start_));\n+      if (!message_.empty()) {\n+        message_  = std::string(rate) + \" \" + message_;\n+      } else {\n+        message_ = rate;\n+      }\n+    }\n+\n+    fprintf(stdout, \"%-12s : %11.3f micros/op;%s%s\\n\",\n+            name.ToString().c_str(),\n+            (finish - start_) * 1e6 / done_,\n+            (message_.empty() ? \"\" : \" \"),\n+            message_.c_str());\n+    if (FLAGS_histogram) {\n+      fprintf(stdout, \"Microseconds per op:\\n%s\\n\", hist_.ToString().c_str());\n+    }\n+    fflush(stdout);\n+  }\n+\n+ public:\n+  enum Order {\n+    SEQUENTIAL,\n+    RANDOM\n+  };\n+  enum DBState {\n+    FRESH,\n+    EXISTING\n+  };\n+\n+  Benchmark()\n+  : db_(NULL),\n+    db_num_(0),\n+    num_(FLAGS_num),\n+    reads_(FLAGS_reads < 0 ? FLAGS_num : FLAGS_reads),\n+    bytes_(0),\n+    rand_(301) {\n+    std::vector<std::string> files;\n+    std::string test_dir;\n+    Env::Default()->GetTestDirectory(&test_dir);\n+    Env::Default()->GetChildren(test_dir, &files);\n+    if (!FLAGS_use_existing_db) {\n+      for (int i = 0; i < files.size(); i++) {\n+        if (Slice(files[i]).starts_with(\"dbbench_sqlite3\")) {\n+          std::string file_name(test_dir);\n+          file_name += \"/\";\n+          file_name += files[i];\n+          Env::Default()->DeleteFile(file_name.c_str());\n+        }\n+      }\n+    }\n+  }\n+\n+  ~Benchmark() {\n+    int status = sqlite3_close(db_);\n+    ErrorCheck(status);\n+  }\n+\n+  void Run() {\n+    PrintHeader();\n+    Open();\n+\n+    const char* benchmarks = FLAGS_benchmarks;\n+    while (benchmarks != NULL) {\n+      const char* sep = strchr(benchmarks, ',');\n+      Slice name;\n+      if (sep == NULL) {\n+        name = benchmarks;\n+        benchmarks = NULL;\n+      } else {\n+        name = Slice(benchmarks, sep - benchmarks);\n+        benchmarks = sep + 1;\n+      }\n+\n+      bytes_ = 0;\n+      Start();\n+\n+      bool known = true;\n+      bool write_sync = false;\n+      if (name == Slice(\"fillseq\")) {\n+        Write(write_sync, SEQUENTIAL, FRESH, num_, FLAGS_value_size, 1);\n+        WalCheckpoint(db_);\n+      } else if (name == Slice(\"fillseqbatch\")) {\n+        Write(write_sync, SEQUENTIAL, FRESH, num_, FLAGS_value_size, 1000);\n+        WalCheckpoint(db_);\n+      } else if (name == Slice(\"fillrandom\")) {\n+        Write(write_sync, RANDOM, FRESH, num_, FLAGS_value_size, 1);\n+        WalCheckpoint(db_);\n+      } else if (name == Slice(\"fillrandbatch\")) {\n+        Write(write_sync, RANDOM, FRESH, num_, FLAGS_value_size, 1000);\n+        WalCheckpoint(db_);\n+      } else if (name == Slice(\"overwrite\")) {\n+        Write(write_sync, RANDOM, EXISTING, num_, FLAGS_value_size, 1);\n+        WalCheckpoint(db_);\n+      } else if (name == Slice(\"overwritebatch\")) {\n+        Write(write_sync, RANDOM, EXISTING, num_, FLAGS_value_size, 1000);\n+        WalCheckpoint(db_);\n+      } else if (name == Slice(\"fillrandsync\")) {\n+        write_sync = true;\n+        Write(write_sync, RANDOM, FRESH, num_ / 100, FLAGS_value_size, 1);\n+        WalCheckpoint(db_);\n+      } else if (name == Slice(\"fillseqsync\")) {\n+        write_sync = true;\n+        Write(write_sync, SEQUENTIAL, FRESH, num_ / 100, FLAGS_value_size, 1);\n+        WalCheckpoint(db_);\n+      } else if (name == Slice(\"fillrand100K\")) {\n+        Write(write_sync, RANDOM, FRESH, num_ / 1000, 100 * 1000, 1);\n+        WalCheckpoint(db_);\n+      } else if (name == Slice(\"fillseq100K\")) {\n+        Write(write_sync, SEQUENTIAL, FRESH, num_ / 1000, 100 * 1000, 1);\n+        WalCheckpoint(db_);\n+      } else if (name == Slice(\"readseq\")) {\n+        ReadSequential();\n+      } else if (name == Slice(\"readrandom\")) {\n+        Read(RANDOM, 1);\n+      } else if (name == Slice(\"readrand100K\")) {\n+        int n = reads_;\n+        reads_ /= 1000;\n+        Read(RANDOM, 1);\n+        reads_ = n;\n+      } else {\n+        known = false;\n+        if (name != Slice()) {  // No error message for empty name\n+          fprintf(stderr, \"unknown benchmark '%s'\\n\", name.ToString().c_str());\n+        }\n+      }\n+      if (known) {\n+        Stop(name);\n+      }\n+    }\n+  }\n+\n+  void Open() {\n+    assert(db_ == NULL);\n+\n+    int status;\n+    char file_name[100];\n+    char* err_msg = NULL;\n+    db_num_++;\n+\n+    // Open database\n+    std::string tmp_dir;\n+    Env::Default()->GetTestDirectory(&tmp_dir);\n+    snprintf(file_name, sizeof(file_name),\n+             \"%s/dbbench_sqlite3-%d.db\",\n+             tmp_dir.c_str(),\n+             db_num_);\n+    status = sqlite3_open(file_name, &db_);\n+    if (status) {\n+      fprintf(stderr, \"open error: %s\\n\", sqlite3_errmsg(db_));\n+      exit(1);\n+    }\n+\n+    // Change SQLite cache size\n+    char cache_size[100];\n+    snprintf(cache_size, sizeof(cache_size), \"PRAGMA cache_size = %d\",\n+             FLAGS_num_pages);\n+    status = sqlite3_exec(db_, cache_size, NULL, NULL, &err_msg);\n+    ExecErrorCheck(status, err_msg);\n+\n+    // FLAGS_page_size is defaulted to 1024\n+    if (FLAGS_page_size != 1024) {\n+      char page_size[100];\n+      snprintf(page_size, sizeof(page_size), \"PRAGMA page_size = %d\",\n+               FLAGS_page_size);\n+      status = sqlite3_exec(db_, page_size, NULL, NULL, &err_msg);\n+      ExecErrorCheck(status, err_msg);\n+    }\n+\n+    // Change journal mode to WAL if WAL enabled flag is on\n+    if (FLAGS_WAL_enabled) {\n+      std::string WAL_stmt = \"PRAGMA journal_mode = WAL\";\n+\n+      // LevelDB's default cache size is a combined 4 MB\n+      std::string WAL_checkpoint = \"PRAGMA wal_autocheckpoint = 4096\";\n+      status = sqlite3_exec(db_, WAL_stmt.c_str(), NULL, NULL, &err_msg);\n+      ExecErrorCheck(status, err_msg);\n+      status = sqlite3_exec(db_, WAL_checkpoint.c_str(), NULL, NULL, &err_msg);\n+      ExecErrorCheck(status, err_msg);\n+    }\n+\n+    // Change locking mode to exclusive and create tables/index for database\n+    std::string locking_stmt = \"PRAGMA locking_mode = EXCLUSIVE\";\n+    std::string create_stmt =\n+          \"CREATE TABLE test (key blob, value blob, PRIMARY KEY(key))\";\n+    std::string stmt_array[] = { locking_stmt, create_stmt };\n+    int stmt_array_length = sizeof(stmt_array) / sizeof(std::string);\n+    for (int i = 0; i < stmt_array_length; i++) {\n+      status = sqlite3_exec(db_, stmt_array[i].c_str(), NULL, NULL, &err_msg);\n+      ExecErrorCheck(status, err_msg);\n+    }\n+  }\n+\n+  void Write(bool write_sync, Order order, DBState state,\n+             int num_entries, int value_size, int entries_per_batch) {\n+    // Create new database if state == FRESH\n+    if (state == FRESH) {\n+      if (FLAGS_use_existing_db) {\n+        message_ = \"skipping (--use_existing_db is true)\";\n+        return;\n+      }\n+      sqlite3_close(db_);\n+      db_ = NULL;\n+      Open();\n+      Start();\n+    }\n+\n+    if (num_entries != num_) {\n+      char msg[100];\n+      snprintf(msg, sizeof(msg), \"(%d ops)\", num_entries);\n+      message_ = msg;\n+    }\n+\n+    char* err_msg = NULL;\n+    int status;\n+\n+    sqlite3_stmt *replace_stmt, *begin_trans_stmt, *end_trans_stmt;\n+    std::string replace_str = \"REPLACE INTO test (key, value) VALUES (?, ?)\";\n+    std::string begin_trans_str = \"BEGIN TRANSACTION;\";\n+    std::string end_trans_str = \"END TRANSACTION;\";\n+\n+    // Check for synchronous flag in options\n+    std::string sync_stmt = (write_sync) ? \"PRAGMA synchronous = FULL\" :\n+                                           \"PRAGMA synchronous = OFF\";\n+    status = sqlite3_exec(db_, sync_stmt.c_str(), NULL, NULL, &err_msg);\n+    ExecErrorCheck(status, err_msg);\n+\n+    // Preparing sqlite3 statements\n+    status = sqlite3_prepare_v2(db_, replace_str.c_str(), -1,\n+                                &replace_stmt, NULL);\n+    ErrorCheck(status);\n+    status = sqlite3_prepare_v2(db_, begin_trans_str.c_str(), -1,\n+                                &begin_trans_stmt, NULL);\n+    ErrorCheck(status);\n+    status = sqlite3_prepare_v2(db_, end_trans_str.c_str(), -1,\n+                                &end_trans_stmt, NULL);\n+    ErrorCheck(status);\n+\n+    bool transaction = (entries_per_batch > 1);\n+    for (int i = 0; i < num_entries; i += entries_per_batch) {\n+      // Begin write transaction\n+      if (FLAGS_transaction && transaction) {\n+        status = sqlite3_step(begin_trans_stmt);\n+        StepErrorCheck(status);\n+        status = sqlite3_reset(begin_trans_stmt);\n+        ErrorCheck(status);\n+      }\n+\n+      // Create and execute SQL statements\n+      for (int j = 0; j < entries_per_batch; j++) {\n+        const char* value = gen_.Generate(value_size).data();\n+\n+        // Create values for key-value pair\n+        const int k = (order == SEQUENTIAL) ? i + j :\n+                      (rand_.Next() % num_entries);\n+        char key[100];\n+        snprintf(key, sizeof(key), \"%016d\", k);\n+\n+        // Bind KV values into replace_stmt\n+        status = sqlite3_bind_blob(replace_stmt, 1, key, 16, SQLITE_STATIC);\n+        ErrorCheck(status);\n+        status = sqlite3_bind_blob(replace_stmt, 2, value,\n+                                   value_size, SQLITE_STATIC);\n+        ErrorCheck(status);\n+\n+        // Execute replace_stmt\n+        bytes_ += value_size + strlen(key);\n+        status = sqlite3_step(replace_stmt);\n+        StepErrorCheck(status);\n+\n+        // Reset SQLite statement for another use\n+        status = sqlite3_clear_bindings(replace_stmt);\n+        ErrorCheck(status);\n+        status = sqlite3_reset(replace_stmt);\n+        ErrorCheck(status);\n+\n+        FinishedSingleOp();\n+      }\n+\n+      // End write transaction\n+      if (FLAGS_transaction && transaction) {\n+        status = sqlite3_step(end_trans_stmt);\n+        StepErrorCheck(status);\n+        status = sqlite3_reset(end_trans_stmt);\n+        ErrorCheck(status);\n+      }\n+    }\n+\n+    status = sqlite3_finalize(replace_stmt);\n+    ErrorCheck(status);\n+    status = sqlite3_finalize(begin_trans_stmt);\n+    ErrorCheck(status);\n+    status = sqlite3_finalize(end_trans_stmt);\n+    ErrorCheck(status);\n+  }\n+\n+  void Read(Order order, int entries_per_batch) {\n+    int status;\n+    sqlite3_stmt *read_stmt, *begin_trans_stmt, *end_trans_stmt;\n+\n+    std::string read_str = \"SELECT * FROM test WHERE key = ?\";\n+    std::string begin_trans_str = \"BEGIN TRANSACTION;\";\n+    std::string end_trans_str = \"END TRANSACTION;\";\n+\n+    // Preparing sqlite3 statements\n+    status = sqlite3_prepare_v2(db_, begin_trans_str.c_str(), -1,\n+                                &begin_trans_stmt, NULL);\n+    ErrorCheck(status);\n+    status = sqlite3_prepare_v2(db_, end_trans_str.c_str(), -1,\n+                                &end_trans_stmt, NULL);\n+    ErrorCheck(status);\n+    status = sqlite3_prepare_v2(db_, read_str.c_str(), -1, &read_stmt, NULL);\n+    ErrorCheck(status);\n+\n+    bool transaction = (entries_per_batch > 1);\n+    for (int i = 0; i < reads_; i += entries_per_batch) {\n+      // Begin read transaction\n+      if (FLAGS_transaction && transaction) {\n+        status = sqlite3_step(begin_trans_stmt);\n+        StepErrorCheck(status);\n+        status = sqlite3_reset(begin_trans_stmt);\n+        ErrorCheck(status);\n+      }\n+\n+      // Create and execute SQL statements\n+      for (int j = 0; j < entries_per_batch; j++) {\n+        // Create key value\n+        char key[100];\n+        int k = (order == SEQUENTIAL) ? i + j : (rand_.Next() % reads_);\n+        snprintf(key, sizeof(key), \"%016d\", k);\n+\n+        // Bind key value into read_stmt\n+        status = sqlite3_bind_blob(read_stmt, 1, key, 16, SQLITE_STATIC);\n+        ErrorCheck(status);\n+\n+        // Execute read statement\n+        while ((status = sqlite3_step(read_stmt)) == SQLITE_ROW);\n+        StepErrorCheck(status);\n+\n+        // Reset SQLite statement for another use\n+        status = sqlite3_clear_bindings(read_stmt);\n+        ErrorCheck(status);\n+        status = sqlite3_reset(read_stmt);\n+        ErrorCheck(status);\n+        FinishedSingleOp();\n+      }\n+\n+      // End read transaction\n+      if (FLAGS_transaction && transaction) {\n+        status = sqlite3_step(end_trans_stmt);\n+        StepErrorCheck(status);\n+        status = sqlite3_reset(end_trans_stmt);\n+        ErrorCheck(status);\n+      }\n+    }\n+\n+    status = sqlite3_finalize(read_stmt);\n+    ErrorCheck(status);\n+    status = sqlite3_finalize(begin_trans_stmt);\n+    ErrorCheck(status);\n+    status = sqlite3_finalize(end_trans_stmt);\n+    ErrorCheck(status);\n+  }\n+\n+  void ReadSequential() {\n+    int status;\n+    sqlite3_stmt *pStmt;\n+    std::string read_str = \"SELECT * FROM test ORDER BY key\";\n+\n+    status = sqlite3_prepare_v2(db_, read_str.c_str(), -1, &pStmt, NULL);\n+    ErrorCheck(status);\n+    for (int i = 0; i < reads_ && SQLITE_ROW == sqlite3_step(pStmt); i++) {\n+      bytes_ += sqlite3_column_bytes(pStmt, 1) + sqlite3_column_bytes(pStmt, 2);\n+      FinishedSingleOp();\n+    }\n+\n+    status = sqlite3_finalize(pStmt);\n+    ErrorCheck(status);\n+  }\n+\n+};\n+\n+}  // namespace leveldb\n+\n+int main(int argc, char** argv) {\n+  std::string default_db_path;\n+  for (int i = 1; i < argc; i++) {\n+    double d;\n+    int n;\n+    char junk;\n+    if (leveldb::Slice(argv[i]).starts_with(\"--benchmarks=\")) {\n+      FLAGS_benchmarks = argv[i] + strlen(\"--benchmarks=\");\n+    } else if (sscanf(argv[i], \"--histogram=%d%c\", &n, &junk) == 1 &&\n+               (n == 0 || n == 1)) {\n+      FLAGS_histogram = n;\n+    } else if (sscanf(argv[i], \"--compression_ratio=%lf%c\", &d, &junk) == 1) {\n+      FLAGS_compression_ratio = d;\n+    } else if (sscanf(argv[i], \"--use_existing_db=%d%c\", &n, &junk) == 1 &&\n+               (n == 0 || n == 1)) {\n+      FLAGS_use_existing_db = n;\n+    } else if (sscanf(argv[i], \"--num=%d%c\", &n, &junk) == 1) {\n+      FLAGS_num = n;\n+    } else if (sscanf(argv[i], \"--reads=%d%c\", &n, &junk) == 1) {\n+      FLAGS_reads = n;\n+    } else if (sscanf(argv[i], \"--value_size=%d%c\", &n, &junk) == 1) {\n+      FLAGS_value_size = n;\n+    } else if (leveldb::Slice(argv[i]) == leveldb::Slice(\"--no_transaction\")) {\n+      FLAGS_transaction = false;\n+    } else if (sscanf(argv[i], \"--page_size=%d%c\", &n, &junk) == 1) {\n+      FLAGS_page_size = n;\n+    } else if (sscanf(argv[i], \"--num_pages=%d%c\", &n, &junk) == 1) {\n+      FLAGS_num_pages = n;\n+    } else if (sscanf(argv[i], \"--WAL_enabled=%d%c\", &n, &junk) == 1 &&\n+               (n == 0 || n == 1)) {\n+      FLAGS_WAL_enabled = n;\n+    } else if (strncmp(argv[i], \"--db=\", 5) == 0) {\n+      FLAGS_db = argv[i] + 5;\n+    } else {\n+      fprintf(stderr, \"Invalid flag '%s'\\n\", argv[i]);\n+      exit(1);\n+    }\n+  }\n+\n+  // Choose a location for the test database if none given with --db=<path>\n+  if (FLAGS_db == NULL) {\n+      leveldb::Env::Default()->GetTestDirectory(&default_db_path);\n+      default_db_path += \"/dbbench\";\n+      FLAGS_db = default_db_path.c_str();\n+  }\n+\n+  leveldb::Benchmark benchmark;\n+  benchmark.Run();\n+  return 0;\n+}"
      },
      {
        "sha": "ed86f031c25fe931b0e3a05f4501269afd233f02",
        "filename": "src/leveldb/doc/bench/db_bench_tree_db.cc",
        "status": "added",
        "additions": 528,
        "deletions": 0,
        "changes": 528,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/doc/bench/db_bench_tree_db.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/doc/bench/db_bench_tree_db.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/bench/db_bench_tree_db.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,528 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <kcpolydb.h>\n+#include \"util/histogram.h\"\n+#include \"util/random.h\"\n+#include \"util/testutil.h\"\n+\n+// Comma-separated list of operations to run in the specified order\n+//   Actual benchmarks:\n+//\n+//   fillseq       -- write N values in sequential key order in async mode\n+//   fillrandom    -- write N values in random key order in async mode\n+//   overwrite     -- overwrite N values in random key order in async mode\n+//   fillseqsync   -- write N/100 values in sequential key order in sync mode\n+//   fillrandsync  -- write N/100 values in random key order in sync mode\n+//   fillrand100K  -- write N/1000 100K values in random order in async mode\n+//   fillseq100K   -- write N/1000 100K values in seq order in async mode\n+//   readseq       -- read N times sequentially\n+//   readseq100K   -- read N/1000 100K values in sequential order in async mode\n+//   readrand100K  -- read N/1000 100K values in sequential order in async mode\n+//   readrandom    -- read N times in random order\n+static const char* FLAGS_benchmarks =\n+    \"fillseq,\"\n+    \"fillseqsync,\"\n+    \"fillrandsync,\"\n+    \"fillrandom,\"\n+    \"overwrite,\"\n+    \"readrandom,\"\n+    \"readseq,\"\n+    \"fillrand100K,\"\n+    \"fillseq100K,\"\n+    \"readseq100K,\"\n+    \"readrand100K,\"\n+    ;\n+\n+// Number of key/values to place in database\n+static int FLAGS_num = 1000000;\n+\n+// Number of read operations to do.  If negative, do FLAGS_num reads.\n+static int FLAGS_reads = -1;\n+\n+// Size of each value\n+static int FLAGS_value_size = 100;\n+\n+// Arrange to generate values that shrink to this fraction of\n+// their original size after compression\n+static double FLAGS_compression_ratio = 0.5;\n+\n+// Print histogram of operation timings\n+static bool FLAGS_histogram = false;\n+\n+// Cache size. Default 4 MB\n+static int FLAGS_cache_size = 4194304;\n+\n+// Page size. Default 1 KB\n+static int FLAGS_page_size = 1024;\n+\n+// If true, do not destroy the existing database.  If you set this\n+// flag and also specify a benchmark that wants a fresh database, that\n+// benchmark will fail.\n+static bool FLAGS_use_existing_db = false;\n+\n+// Compression flag. If true, compression is on. If false, compression\n+// is off.\n+static bool FLAGS_compression = true;\n+\n+// Use the db with the following name.\n+static const char* FLAGS_db = NULL;\n+\n+inline\n+static void DBSynchronize(kyotocabinet::TreeDB* db_)\n+{\n+  // Synchronize will flush writes to disk\n+  if (!db_->synchronize()) {\n+    fprintf(stderr, \"synchronize error: %s\\n\", db_->error().name());\n+  }\n+}\n+\n+namespace leveldb {\n+\n+// Helper for quickly generating random data.\n+namespace {\n+class RandomGenerator {\n+ private:\n+  std::string data_;\n+  int pos_;\n+\n+ public:\n+  RandomGenerator() {\n+    // We use a limited amount of data over and over again and ensure\n+    // that it is larger than the compression window (32KB), and also\n+    // large enough to serve all typical value sizes we want to write.\n+    Random rnd(301);\n+    std::string piece;\n+    while (data_.size() < 1048576) {\n+      // Add a short fragment that is as compressible as specified\n+      // by FLAGS_compression_ratio.\n+      test::CompressibleString(&rnd, FLAGS_compression_ratio, 100, &piece);\n+      data_.append(piece);\n+    }\n+    pos_ = 0;\n+  }\n+\n+  Slice Generate(int len) {\n+    if (pos_ + len > data_.size()) {\n+      pos_ = 0;\n+      assert(len < data_.size());\n+    }\n+    pos_ += len;\n+    return Slice(data_.data() + pos_ - len, len);\n+  }\n+};\n+\n+static Slice TrimSpace(Slice s) {\n+  int start = 0;\n+  while (start < s.size() && isspace(s[start])) {\n+    start++;\n+  }\n+  int limit = s.size();\n+  while (limit > start && isspace(s[limit-1])) {\n+    limit--;\n+  }\n+  return Slice(s.data() + start, limit - start);\n+}\n+\n+}  // namespace\n+\n+class Benchmark {\n+ private:\n+  kyotocabinet::TreeDB* db_;\n+  int db_num_;\n+  int num_;\n+  int reads_;\n+  double start_;\n+  double last_op_finish_;\n+  int64_t bytes_;\n+  std::string message_;\n+  Histogram hist_;\n+  RandomGenerator gen_;\n+  Random rand_;\n+  kyotocabinet::LZOCompressor<kyotocabinet::LZO::RAW> comp_;\n+\n+  // State kept for progress messages\n+  int done_;\n+  int next_report_;     // When to report next\n+\n+  void PrintHeader() {\n+    const int kKeySize = 16;\n+    PrintEnvironment();\n+    fprintf(stdout, \"Keys:       %d bytes each\\n\", kKeySize);\n+    fprintf(stdout, \"Values:     %d bytes each (%d bytes after compression)\\n\",\n+            FLAGS_value_size,\n+            static_cast<int>(FLAGS_value_size * FLAGS_compression_ratio + 0.5));\n+    fprintf(stdout, \"Entries:    %d\\n\", num_);\n+    fprintf(stdout, \"RawSize:    %.1f MB (estimated)\\n\",\n+            ((static_cast<int64_t>(kKeySize + FLAGS_value_size) * num_)\n+             / 1048576.0));\n+    fprintf(stdout, \"FileSize:   %.1f MB (estimated)\\n\",\n+            (((kKeySize + FLAGS_value_size * FLAGS_compression_ratio) * num_)\n+             / 1048576.0));\n+    PrintWarnings();\n+    fprintf(stdout, \"------------------------------------------------\\n\");\n+  }\n+\n+  void PrintWarnings() {\n+#if defined(__GNUC__) && !defined(__OPTIMIZE__)\n+    fprintf(stdout,\n+            \"WARNING: Optimization is disabled: benchmarks unnecessarily slow\\n\"\n+            );\n+#endif\n+#ifndef NDEBUG\n+    fprintf(stdout,\n+            \"WARNING: Assertions are enabled; benchmarks unnecessarily slow\\n\");\n+#endif\n+  }\n+\n+  void PrintEnvironment() {\n+    fprintf(stderr, \"Kyoto Cabinet:    version %s, lib ver %d, lib rev %d\\n\",\n+            kyotocabinet::VERSION, kyotocabinet::LIBVER, kyotocabinet::LIBREV);\n+\n+#if defined(__linux)\n+    time_t now = time(NULL);\n+    fprintf(stderr, \"Date:           %s\", ctime(&now));  // ctime() adds newline\n+\n+    FILE* cpuinfo = fopen(\"/proc/cpuinfo\", \"r\");\n+    if (cpuinfo != NULL) {\n+      char line[1000];\n+      int num_cpus = 0;\n+      std::string cpu_type;\n+      std::string cache_size;\n+      while (fgets(line, sizeof(line), cpuinfo) != NULL) {\n+        const char* sep = strchr(line, ':');\n+        if (sep == NULL) {\n+          continue;\n+        }\n+        Slice key = TrimSpace(Slice(line, sep - 1 - line));\n+        Slice val = TrimSpace(Slice(sep + 1));\n+        if (key == \"model name\") {\n+          ++num_cpus;\n+          cpu_type = val.ToString();\n+        } else if (key == \"cache size\") {\n+          cache_size = val.ToString();\n+        }\n+      }\n+      fclose(cpuinfo);\n+      fprintf(stderr, \"CPU:            %d * %s\\n\", num_cpus, cpu_type.c_str());\n+      fprintf(stderr, \"CPUCache:       %s\\n\", cache_size.c_str());\n+    }\n+#endif\n+  }\n+\n+  void Start() {\n+    start_ = Env::Default()->NowMicros() * 1e-6;\n+    bytes_ = 0;\n+    message_.clear();\n+    last_op_finish_ = start_;\n+    hist_.Clear();\n+    done_ = 0;\n+    next_report_ = 100;\n+  }\n+\n+  void FinishedSingleOp() {\n+    if (FLAGS_histogram) {\n+      double now = Env::Default()->NowMicros() * 1e-6;\n+      double micros = (now - last_op_finish_) * 1e6;\n+      hist_.Add(micros);\n+      if (micros > 20000) {\n+        fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n+        fflush(stderr);\n+      }\n+      last_op_finish_ = now;\n+    }\n+\n+    done_++;\n+    if (done_ >= next_report_) {\n+      if      (next_report_ < 1000)   next_report_ += 100;\n+      else if (next_report_ < 5000)   next_report_ += 500;\n+      else if (next_report_ < 10000)  next_report_ += 1000;\n+      else if (next_report_ < 50000)  next_report_ += 5000;\n+      else if (next_report_ < 100000) next_report_ += 10000;\n+      else if (next_report_ < 500000) next_report_ += 50000;\n+      else                            next_report_ += 100000;\n+      fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n+      fflush(stderr);\n+    }\n+  }\n+\n+  void Stop(const Slice& name) {\n+    double finish = Env::Default()->NowMicros() * 1e-6;\n+\n+    // Pretend at least one op was done in case we are running a benchmark\n+    // that does not call FinishedSingleOp().\n+    if (done_ < 1) done_ = 1;\n+\n+    if (bytes_ > 0) {\n+      char rate[100];\n+      snprintf(rate, sizeof(rate), \"%6.1f MB/s\",\n+               (bytes_ / 1048576.0) / (finish - start_));\n+      if (!message_.empty()) {\n+        message_  = std::string(rate) + \" \" + message_;\n+      } else {\n+        message_ = rate;\n+      }\n+    }\n+\n+    fprintf(stdout, \"%-12s : %11.3f micros/op;%s%s\\n\",\n+            name.ToString().c_str(),\n+            (finish - start_) * 1e6 / done_,\n+            (message_.empty() ? \"\" : \" \"),\n+            message_.c_str());\n+    if (FLAGS_histogram) {\n+      fprintf(stdout, \"Microseconds per op:\\n%s\\n\", hist_.ToString().c_str());\n+    }\n+    fflush(stdout);\n+  }\n+\n+ public:\n+  enum Order {\n+    SEQUENTIAL,\n+    RANDOM\n+  };\n+  enum DBState {\n+    FRESH,\n+    EXISTING\n+  };\n+\n+  Benchmark()\n+  : db_(NULL),\n+    num_(FLAGS_num),\n+    reads_(FLAGS_reads < 0 ? FLAGS_num : FLAGS_reads),\n+    bytes_(0),\n+    rand_(301) {\n+    std::vector<std::string> files;\n+    std::string test_dir;\n+    Env::Default()->GetTestDirectory(&test_dir);\n+    Env::Default()->GetChildren(test_dir.c_str(), &files);\n+    if (!FLAGS_use_existing_db) {\n+      for (int i = 0; i < files.size(); i++) {\n+        if (Slice(files[i]).starts_with(\"dbbench_polyDB\")) {\n+          std::string file_name(test_dir);\n+          file_name += \"/\";\n+          file_name += files[i];\n+          Env::Default()->DeleteFile(file_name.c_str());\n+        }\n+      }\n+    }\n+  }\n+\n+  ~Benchmark() {\n+    if (!db_->close()) {\n+      fprintf(stderr, \"close error: %s\\n\", db_->error().name());\n+    }\n+  }\n+\n+  void Run() {\n+    PrintHeader();\n+    Open(false);\n+\n+    const char* benchmarks = FLAGS_benchmarks;\n+    while (benchmarks != NULL) {\n+      const char* sep = strchr(benchmarks, ',');\n+      Slice name;\n+      if (sep == NULL) {\n+        name = benchmarks;\n+        benchmarks = NULL;\n+      } else {\n+        name = Slice(benchmarks, sep - benchmarks);\n+        benchmarks = sep + 1;\n+      }\n+\n+      Start();\n+\n+      bool known = true;\n+      bool write_sync = false;\n+      if (name == Slice(\"fillseq\")) {\n+        Write(write_sync, SEQUENTIAL, FRESH, num_, FLAGS_value_size, 1);\n+        \n+      } else if (name == Slice(\"fillrandom\")) {\n+        Write(write_sync, RANDOM, FRESH, num_, FLAGS_value_size, 1);\n+        DBSynchronize(db_);\n+      } else if (name == Slice(\"overwrite\")) {\n+        Write(write_sync, RANDOM, EXISTING, num_, FLAGS_value_size, 1);\n+        DBSynchronize(db_);\n+      } else if (name == Slice(\"fillrandsync\")) {\n+        write_sync = true;\n+        Write(write_sync, RANDOM, FRESH, num_ / 100, FLAGS_value_size, 1);\n+        DBSynchronize(db_);\n+      } else if (name == Slice(\"fillseqsync\")) {\n+        write_sync = true;\n+        Write(write_sync, SEQUENTIAL, FRESH, num_ / 100, FLAGS_value_size, 1);\n+        DBSynchronize(db_);\n+      } else if (name == Slice(\"fillrand100K\")) {\n+        Write(write_sync, RANDOM, FRESH, num_ / 1000, 100 * 1000, 1);\n+        DBSynchronize(db_);\n+      } else if (name == Slice(\"fillseq100K\")) {\n+        Write(write_sync, SEQUENTIAL, FRESH, num_ / 1000, 100 * 1000, 1);\n+        DBSynchronize(db_);\n+      } else if (name == Slice(\"readseq\")) {\n+        ReadSequential();\n+      } else if (name == Slice(\"readrandom\")) {\n+        ReadRandom();\n+      } else if (name == Slice(\"readrand100K\")) {\n+        int n = reads_;\n+        reads_ /= 1000;\n+        ReadRandom();\n+        reads_ = n;\n+      } else if (name == Slice(\"readseq100K\")) {\n+        int n = reads_;\n+        reads_ /= 1000;\n+        ReadSequential();\n+        reads_ = n;\n+      } else {\n+        known = false;\n+        if (name != Slice()) {  // No error message for empty name\n+          fprintf(stderr, \"unknown benchmark '%s'\\n\", name.ToString().c_str());\n+        }\n+      }\n+      if (known) {\n+        Stop(name);\n+      }\n+    }\n+  }\n+\n+ private:\n+    void Open(bool sync) {\n+    assert(db_ == NULL);\n+\n+    // Initialize db_\n+    db_ = new kyotocabinet::TreeDB();\n+    char file_name[100];\n+    db_num_++;\n+    std::string test_dir;\n+    Env::Default()->GetTestDirectory(&test_dir);\n+    snprintf(file_name, sizeof(file_name),\n+             \"%s/dbbench_polyDB-%d.kct\",\n+             test_dir.c_str(),\n+             db_num_);\n+\n+    // Create tuning options and open the database\n+    int open_options = kyotocabinet::PolyDB::OWRITER |\n+                       kyotocabinet::PolyDB::OCREATE;\n+    int tune_options = kyotocabinet::TreeDB::TSMALL |\n+        kyotocabinet::TreeDB::TLINEAR;\n+    if (FLAGS_compression) {\n+      tune_options |= kyotocabinet::TreeDB::TCOMPRESS;\n+      db_->tune_compressor(&comp_);\n+    }\n+    db_->tune_options(tune_options);\n+    db_->tune_page_cache(FLAGS_cache_size);\n+    db_->tune_page(FLAGS_page_size);\n+    db_->tune_map(256LL<<20);\n+    if (sync) {\n+      open_options |= kyotocabinet::PolyDB::OAUTOSYNC;\n+    }\n+    if (!db_->open(file_name, open_options)) {\n+      fprintf(stderr, \"open error: %s\\n\", db_->error().name());\n+    }\n+  }\n+\n+  void Write(bool sync, Order order, DBState state,\n+             int num_entries, int value_size, int entries_per_batch) {\n+    // Create new database if state == FRESH\n+    if (state == FRESH) {\n+      if (FLAGS_use_existing_db) {\n+        message_ = \"skipping (--use_existing_db is true)\";\n+        return;\n+      }\n+      delete db_;\n+      db_ = NULL;\n+      Open(sync);\n+      Start();  // Do not count time taken to destroy/open\n+    }\n+\n+    if (num_entries != num_) {\n+      char msg[100];\n+      snprintf(msg, sizeof(msg), \"(%d ops)\", num_entries);\n+      message_ = msg;\n+    }\n+\n+    // Write to database\n+    for (int i = 0; i < num_entries; i++)\n+    {\n+      const int k = (order == SEQUENTIAL) ? i : (rand_.Next() % num_entries);\n+      char key[100];\n+      snprintf(key, sizeof(key), \"%016d\", k);\n+      bytes_ += value_size + strlen(key);\n+      std::string cpp_key = key;\n+      if (!db_->set(cpp_key, gen_.Generate(value_size).ToString())) {\n+        fprintf(stderr, \"set error: %s\\n\", db_->error().name());\n+      }\n+      FinishedSingleOp();\n+    }\n+  }\n+\n+  void ReadSequential() {\n+    kyotocabinet::DB::Cursor* cur = db_->cursor();\n+    cur->jump();\n+    std::string ckey, cvalue;\n+    while (cur->get(&ckey, &cvalue, true)) {\n+      bytes_ += ckey.size() + cvalue.size();\n+      FinishedSingleOp();\n+    }\n+    delete cur;\n+  }\n+\n+  void ReadRandom() {\n+    std::string value;\n+    for (int i = 0; i < reads_; i++) {\n+      char key[100];\n+      const int k = rand_.Next() % reads_;\n+      snprintf(key, sizeof(key), \"%016d\", k);\n+      db_->get(key, &value);\n+      FinishedSingleOp();\n+    }\n+  }\n+};\n+\n+}  // namespace leveldb\n+\n+int main(int argc, char** argv) {\n+  std::string default_db_path;\n+  for (int i = 1; i < argc; i++) {\n+    double d;\n+    int n;\n+    char junk;\n+    if (leveldb::Slice(argv[i]).starts_with(\"--benchmarks=\")) {\n+      FLAGS_benchmarks = argv[i] + strlen(\"--benchmarks=\");\n+    } else if (sscanf(argv[i], \"--compression_ratio=%lf%c\", &d, &junk) == 1) {\n+      FLAGS_compression_ratio = d;\n+    } else if (sscanf(argv[i], \"--histogram=%d%c\", &n, &junk) == 1 &&\n+               (n == 0 || n == 1)) {\n+      FLAGS_histogram = n;\n+    } else if (sscanf(argv[i], \"--num=%d%c\", &n, &junk) == 1) {\n+      FLAGS_num = n;\n+    } else if (sscanf(argv[i], \"--reads=%d%c\", &n, &junk) == 1) {\n+      FLAGS_reads = n;\n+    } else if (sscanf(argv[i], \"--value_size=%d%c\", &n, &junk) == 1) {\n+      FLAGS_value_size = n;\n+    } else if (sscanf(argv[i], \"--cache_size=%d%c\", &n, &junk) == 1) {\n+      FLAGS_cache_size = n;\n+    } else if (sscanf(argv[i], \"--page_size=%d%c\", &n, &junk) == 1) {\n+      FLAGS_page_size = n;\n+    } else if (sscanf(argv[i], \"--compression=%d%c\", &n, &junk) == 1 &&\n+               (n == 0 || n == 1)) {\n+      FLAGS_compression = (n == 1) ? true : false;\n+    } else if (strncmp(argv[i], \"--db=\", 5) == 0) {\n+      FLAGS_db = argv[i] + 5;\n+    } else {\n+      fprintf(stderr, \"Invalid flag '%s'\\n\", argv[i]);\n+      exit(1);\n+    }\n+  }\n+\n+  // Choose a location for the test database if none given with --db=<path>\n+  if (FLAGS_db == NULL) {\n+      leveldb::Env::Default()->GetTestDirectory(&default_db_path);\n+      default_db_path += \"/dbbench\";\n+      FLAGS_db = default_db_path.c_str();\n+  }\n+\n+  leveldb::Benchmark benchmark;\n+  benchmark.Run();\n+  return 0;\n+}"
      },
      {
        "sha": "c4639772c175b463f6f41eeb0cd0c73fe7c16d68",
        "filename": "src/leveldb/doc/benchmark.html",
        "status": "added",
        "additions": 459,
        "deletions": 0,
        "changes": 459,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/doc/benchmark.html",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/doc/benchmark.html",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/benchmark.html?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,459 @@\n+<!DOCTYPE html>\n+<html>\n+<head>\n+<title>LevelDB Benchmarks</title>\n+<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n+<style>\n+body {\n+  font-family:Helvetica,sans-serif;\n+  padding:20px;\n+}\n+\n+h2 {\n+  padding-top:30px;\n+}\n+\n+table.bn {\n+  width:800px;\n+  border-collapse:collapse;\n+  border:0;\n+  padding:0;\n+}\n+\n+table.bnbase {\n+  width:650px;\n+}\n+\n+table.bn td {\n+  padding:2px 0;\n+}\n+\n+table.bn td.c1 {\n+  font-weight:bold;\n+  width:150px;\n+}\n+\n+table.bn td.c1 div.e {\n+  float:right;\n+  font-weight:normal;\n+}\n+\n+table.bn td.c2 {\n+  width:150px;\n+  text-align:right;\n+  padding:2px;\n+}\n+\n+table.bn td.c3 {\n+  width:350px;\n+}\n+\n+table.bn td.c4 {\n+  width:150px;\n+  font-size:small;\n+  padding-left:4px;\n+}\n+\n+/* chart bars */\n+div.bldb {\n+  background-color:#0255df;\n+}\n+\n+div.bkct {\n+  background-color:#df5555;\n+}\n+\n+div.bsql {\n+  background-color:#aadf55;\n+}\n+\n+.code {\n+  font-family:monospace;\n+  font-size:large;\n+}\n+\n+.todo {\n+  color: red;\n+}\n+\n+</style>\n+</head>\n+<body>\n+<h1>LevelDB Benchmarks</h1>\n+<p>Google, July 2011</p>\n+<hr>\n+\n+<p>In order to test LevelDB's performance, we benchmark it against other well-established database implementations. We compare LevelDB (revision 39) against <a href=\"http://www.sqlite.org/\">SQLite3</a> (version 3.7.6.3) and <a href=\"http://fallabs.com/kyotocabinet/spex.html\">Kyoto Cabinet's</a> (version 1.2.67) TreeDB (a B+Tree based key-value store). We would like to acknowledge Scott Hess and Mikio Hirabayashi for their suggestions and contributions to the SQLite3 and Kyoto Cabinet benchmarks, respectively.</p>\n+\n+<p>Benchmarks were all performed on a six-core Intel(R) Xeon(R) CPU X5650 @ 2.67GHz, with 12288 KB of total L3 cache and 12 GB of DDR3 RAM at 1333 MHz. (Note that LevelDB uses at most two CPUs since the benchmarks are single threaded: one to run the benchmark, and one for background compactions.) We ran the benchmarks on two machines (with identical processors), one with an Ext3 file system and one with an Ext4 file system. The machine with the Ext3 file system has a SATA Hitachi HDS721050CLA362 hard drive. The machine with the Ext4 file system has a SATA Samsung HD502HJ hard drive. Both hard drives spin at 7200 RPM and have hard drive write-caching enabled (using `hdparm -W 1 [device]`). The numbers reported below are the median of three measurements.</p>\n+\n+<h4>Benchmark Source Code</h4>\n+<p>We wrote benchmark tools for SQLite and Kyoto TreeDB based on LevelDB's <span class=\"code\">db_bench</span>. The code for each of the benchmarks resides here:</p>\n+<ul>\n+\t<li> <b>LevelDB:</b> <a href=\"http://code.google.com/p/leveldb/source/browse/trunk/db/db_bench.cc\">db/db_bench.cc</a>.</li>\n+\t<li> <b>SQLite:</b> <a href=\"http://code.google.com/p/leveldb/source/browse/#svn%2Ftrunk%2Fdoc%2Fbench%2Fdb_bench_sqlite3.cc\">doc/bench/db_bench_sqlite3.cc</a>.</li>\n+\t<li> <b>Kyoto TreeDB:</b> <a href=\"http://code.google.com/p/leveldb/source/browse/#svn%2Ftrunk%2Fdoc%2Fbench%2Fdb_bench_tree_db.cc\">doc/bench/db_bench_tree_db.cc</a>.</li>\n+</ul>\n+\n+<h4>Custom Build Specifications</h4>\n+<ul>\n+<li>LevelDB: LevelDB was compiled with the <a href=\"http://code.google.com/p/google-perftools\">tcmalloc</a> library and the <a href=\"http://code.google.com/p/snappy/\">Snappy</a> compression library (revision 33).  Assertions were disabled.</li>\n+<li>TreeDB: TreeDB was compiled using the <a href=\"http://www.oberhumer.com/opensource/lzo/\">LZO</a> compression library (version 2.03). Furthermore, we enabled the TSMALL and TLINEAR options when opening the database in order to reduce the footprint of each record.</li>\n+<li>SQLite: We tuned SQLite's performance, by setting its locking mode to exclusive.  We also enabled SQLite's <a href=\"http://www.sqlite.org/draft/wal.html\">write-ahead logging</a>.</li>\n+</ul>\n+\n+<h2>1. Baseline Performance</h2>\n+<p>This section gives the baseline performance of all the\n+databases.  Following sections show how performance changes as various\n+parameters are varied.  For the baseline:</p>\n+<ul>\n+\t<li> Each database is allowed 4 MB of cache memory.</li>\n+        <li> Databases are opened in <em>asynchronous</em> write mode.\n+             (LevelDB's sync option, TreeDB's OAUTOSYNC option, and\n+             SQLite3's synchronous options are all turned off).  I.e.,\n+             every write is pushed to the operating system, but the\n+             benchmark does not wait for the write to reach the disk.</li>\n+\t<li> Keys are 16 bytes each.</li>\n+        <li> Value are 100 bytes each (with enough redundancy so that\n+             a simple compressor shrinks them to 50% of their original\n+             size).</li>\n+\t<li> Sequential reads/writes traverse the key space in increasing order.</li>\n+\t<li> Random reads/writes traverse the key space in random order.</li>\n+</ul>\n+\n+<h3>A. Sequential Reads</h3>\n+<table class=\"bn bnbase\">\n+<tr><td class=\"c1\">LevelDB</td>\n+    <td class=\"c2\">4,030,000 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bldb\" style=\"width:350px\">&nbsp;</div></td>\n+<tr><td class=\"c1\">Kyoto TreeDB</td>\n+    <td class=\"c2\">1,010,000 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bkct\" style=\"width:95px\">&nbsp;</div></td>\n+<tr><td class=\"c1\">SQLite3</td>\n+    <td class=\"c2\">383,000 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bsql\" style=\"width:33px\">&nbsp;</div></td>\n+</table>\n+<h3>B. Random Reads</h3>\n+<table class=\"bn bnbase\">\n+<tr><td class=\"c1\">LevelDB</td>\n+    <td class=\"c2\">129,000 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bldb\" style=\"width:298px\">&nbsp;</div></td>\n+<tr><td class=\"c1\">Kyoto TreeDB</td>\n+    <td class=\"c2\">151,000 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bkct\" style=\"width:350px\">&nbsp;</div></td>\n+<tr><td class=\"c1\">SQLite3</td>\n+    <td class=\"c2\">134,000 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bsql\" style=\"width:310px\">&nbsp;</div></td>\n+</table>\n+<h3>C. Sequential Writes</h3>\n+<table class=\"bn bnbase\">\n+<tr><td class=\"c1\">LevelDB</td>\n+    <td class=\"c2\">779,000 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bldb\" style=\"width:350px\">&nbsp;</div></td>\n+<tr><td class=\"c1\">Kyoto TreeDB</td>\n+    <td class=\"c2\">342,000 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bkct\" style=\"width:154px\">&nbsp;</div></td>\n+<tr><td class=\"c1\">SQLite3</td>\n+    <td class=\"c2\">48,600 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bsql\" style=\"width:22px\">&nbsp;</div></td>\n+</table>\n+<h3>D. Random Writes</h3>\n+<table class=\"bn bnbase\">\n+<tr><td class=\"c1\">LevelDB</td>\n+    <td class=\"c2\">164,000 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bldb\" style=\"width:350px\">&nbsp;</div></td>\n+<tr><td class=\"c1\">Kyoto TreeDB</td>\n+    <td class=\"c2\">88,500 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bkct\" style=\"width:188px\">&nbsp;</div></td>\n+<tr><td class=\"c1\">SQLite3</td>\n+    <td class=\"c2\">9,860 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bsql\" style=\"width:21px\">&nbsp;</div></td>\n+</table>\n+\n+<p>LevelDB outperforms both SQLite3 and TreeDB in sequential and random write operations and sequential read operations. Kyoto Cabinet has the fastest random read operations.</p>\n+\n+<h2>2. Write Performance under Different Configurations</h2>\n+<h3>A. Large Values </h3>\n+<p>For this benchmark, we start with an empty database, and write 100,000 byte values (~50% compressible). To keep the benchmark running time reasonable, we stop after writing 1000 values.</p>\n+<h4>Sequential Writes</h4>\n+<table class=\"bn bnbase\">\n+<tr><td class=\"c1\">LevelDB</td>\n+    <td class=\"c2\">1,100 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bldb\" style=\"width:234px\">&nbsp;</div></td></tr>\n+<tr><td class=\"c1\">Kyoto TreeDB</td>\n+    <td class=\"c2\">1,000 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bkct\" style=\"width:224px\">&nbsp;</div></td></tr>\n+<tr><td class=\"c1\">SQLite3</td>\n+    <td class=\"c2\">1,600 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bsql\" style=\"width:350px\">&nbsp;</div></td></tr>\n+</table>\n+<h4>Random Writes</h4>\n+<table class=\"bn bnbase\">\n+<tr><td class=\"c1\">LevelDB</td>\n+    <td class=\"c2\">480 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bldb\" style=\"width:105px\">&nbsp;</div></td></tr>\n+<tr><td class=\"c1\">Kyoto TreeDB</td>\n+    <td class=\"c2\">1,100 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bkct\" style=\"width:240px\">&nbsp;</div></td></tr>\n+<tr><td class=\"c1\">SQLite3</td>\n+    <td class=\"c2\">1,600 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bsql\" style=\"width:350px\">&nbsp;</div></td></tr>\n+</table>\n+<p>LevelDB doesn't perform as well with large values of 100,000 bytes each. This is because LevelDB writes keys and values at least twice: first time to the transaction log, and second time (during a compaction) to a sorted file.\n+With larger values, LevelDB's per-operation efficiency is swamped by the\n+cost of extra copies of large values.</p>\n+<h3>B. Batch Writes</h3>\n+<p>A batch write is a set of writes that are applied atomically to the underlying database. A single batch of N writes may be significantly faster than N individual writes. The following benchmark writes one thousand batches where each batch contains one thousand 100-byte values. TreeDB does not support batch writes and is omitted from this benchmark.</p>\n+<h4>Sequential Writes</h4>\n+<table class=\"bn\">\n+<tr><td class=\"c1\">LevelDB</td>\n+    <td class=\"c2\">840,000 entries/sec</td>\n+    <td class=\"c3\"><div class=\"bldb\" style=\"width:350px\">&nbsp;</div></td>\n+    <td class=\"c4\">(1.08x baseline)</td></tr>\n+<tr><td class=\"c1\">SQLite3</td>\n+    <td class=\"c2\">124,000 entries/sec</td>\n+    <td class=\"c3\"><div class=\"bsql\" style=\"width:52px\">&nbsp;</div></td>\n+    <td class=\"c4\">(2.55x baseline)</td></tr>\n+</table>\n+<h4>Random Writes</h4>\n+<table class=\"bn\">\n+<tr><td class=\"c1\">LevelDB</td>\n+    <td class=\"c2\">221,000 entries/sec</td>\n+    <td class=\"c3\"><div class=\"bldb\" style=\"width:350px\">&nbsp;</div></td>\n+    <td class=\"c4\">(1.35x baseline)</td></tr>\n+<tr><td class=\"c1\">SQLite3</td>\n+    <td class=\"c2\">22,000 entries/sec</td>\n+    <td class=\"c3\"><div class=\"bsql\" style=\"width:34px\">&nbsp;</div></td>\n+    <td class=\"c4\">(2.23x baseline)</td></tr>\n+</table>\n+\n+<p>Because of the way LevelDB persistent storage is organized, batches of\n+random writes are not much slower (only a factor of 4x) than batches\n+of sequential writes.</p>\n+\n+<h3>C. Synchronous Writes</h3>\n+<p>In the following benchmark, we enable the synchronous writing modes\n+of all of the databases.  Since this change significantly slows down the\n+benchmark, we stop after 10,000 writes. For synchronous write tests, we've\n+disabled hard drive write-caching (using `hdparm -W 0 [device]`).</p>\n+<ul>\n+    <li>For LevelDB, we set WriteOptions.sync = true.</li>\n+    <li>In TreeDB, we enabled TreeDB's OAUTOSYNC option.</li>\n+    <li>For SQLite3, we set \"PRAGMA synchronous = FULL\".</li>\n+</ul>\n+<h4>Sequential Writes</h4>\n+<table class=\"bn\">\n+<tr><td class=\"c1\">LevelDB</td>\n+    <td class=\"c2\">100 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bldb\" style=\"width:350px\">&nbsp;</div></td>\n+    <td class=\"c4\">(0.003x baseline)</td></tr>\n+<tr><td class=\"c1\">Kyoto TreeDB</td>\n+    <td class=\"c2\">7 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bkct\" style=\"width:27px\">&nbsp;</div></td>\n+    <td class=\"c4\">(0.0004x baseline)</td></tr>\n+<tr><td class=\"c1\">SQLite3</td>\n+    <td class=\"c2\">88 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bsql\" style=\"width:315px\">&nbsp;</div></td>\n+    <td class=\"c4\">(0.002x baseline)</td></tr>\n+</table>\n+<h4>Random Writes</h4>\n+<table class=\"bn\">\n+<tr><td class=\"c1\">LevelDB</td>\n+    <td class=\"c2\">100 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bldb\" style=\"width:350px\">&nbsp;</div></td>\n+    <td class=\"c4\">(0.015x baseline)</td></tr>\n+<tr><td class=\"c1\">Kyoto TreeDB</td>\n+    <td class=\"c2\">8 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bkct\" style=\"width:29px\">&nbsp;</div></td>\n+    <td class=\"c4\">(0.001x baseline)</td></tr>\n+<tr><td class=\"c1\">SQLite3</td>\n+    <td class=\"c2\">88 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bsql\" style=\"width:314px\">&nbsp;</div></td>\n+    <td class=\"c4\">(0.009x baseline)</td></tr>\n+</table>\n+\n+<p>Also see the <code>ext4</code> performance numbers below\n+since synchronous writes behave significantly differently\n+on <code>ext3</code> and <code>ext4</code>.</p>\n+\n+<h3>D. Turning Compression Off</h3>\n+\n+<p>In the baseline measurements, LevelDB and TreeDB were using\n+light-weight compression\n+(<a href=\"http://code.google.com/p/snappy/\">Snappy</a> for LevelDB,\n+and <a href=\"http://www.oberhumer.com/opensource/lzo/\">LZO</a> for\n+TreeDB). SQLite3, by default does not use compression.  The\n+experiments below show what happens when compression is disabled in\n+all of the databases (the SQLite3 numbers are just a copy of\n+its baseline measurements):</p>\n+\n+<h4>Sequential Writes</h4>\n+<table class=\"bn\">\n+<tr><td class=\"c1\">LevelDB</td>\n+    <td class=\"c2\">594,000 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bldb\" style=\"width:350px\">&nbsp;</div></td>\n+    <td class=\"c4\">(0.76x baseline)</td></tr>\n+<tr><td class=\"c1\">Kyoto TreeDB</td>\n+    <td class=\"c2\">485,000 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bkct\" style=\"width:239px\">&nbsp;</div></td>\n+    <td class=\"c4\">(1.42x baseline)</td></tr>\n+<tr><td class=\"c1\">SQLite3</td>\n+    <td class=\"c2\">48,600 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bsql\" style=\"width:29px\">&nbsp;</div></td>\n+    <td class=\"c4\">(1.00x baseline)</td></tr>\n+</table>\n+<h4>Random Writes</h4>\n+<table class=\"bn\">\n+<tr><td class=\"c1\">LevelDB</td>\n+    <td class=\"c2\">135,000 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bldb\" style=\"width:296px\">&nbsp;</div></td>\n+    <td class=\"c4\">(0.82x baseline)</td></tr>\n+<tr><td class=\"c1\">Kyoto TreeDB</td>\n+    <td class=\"c2\">159,000 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bkct\" style=\"width:350px\">&nbsp;</div></td>\n+    <td class=\"c4\">(1.80x baseline)</td></tr>\n+<tr><td class=\"c1\">SQLite3</td>\n+    <td class=\"c2\">9,860 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bsql\" style=\"width:22px\">&nbsp;</div></td>\n+    <td class=\"c4\">(1.00x baseline)</td></tr>\n+</table>\n+\n+<p>LevelDB's write performance is better with compression than without\n+since compression decreases the amount of data that has to be written\n+to disk.  Therefore LevelDB users can leave compression enabled in\n+most scenarios without having worry about a tradeoff between space\n+usage and performance.  TreeDB's performance on the other hand is\n+better without compression than with compression.  Presumably this is\n+because TreeDB's compression library (LZO) is more expensive than\n+LevelDB's compression library (Snappy).<p>\n+\n+<h3>E. Using More Memory</h3>\n+<p>We increased the overall cache size for each database to 128 MB. For LevelDB, we partitioned 128 MB into a 120 MB write buffer and 8 MB of cache (up from 2 MB of write buffer and 2 MB of cache). For SQLite3, we kept the page size at 1024 bytes, but increased the number of pages to 131,072 (up from 4096). For TreeDB, we also kept the page size at 1024 bytes, but increased the cache size to 128 MB (up from 4 MB).</p>\n+<h4>Sequential Writes</h4>\n+<table class=\"bn\">\n+<tr><td class=\"c1\">LevelDB</td>\n+    <td class=\"c2\">812,000 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bldb\" style=\"width:350px\">&nbsp;</div></td>\n+    <td class=\"c4\">(1.04x baseline)</td></tr>\n+<tr><td class=\"c1\">Kyoto TreeDB</td>\n+    <td class=\"c2\">321,000 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bkct\" style=\"width:138px\">&nbsp;</div></td>\n+    <td class=\"c4\">(0.94x baseline)</td></tr>\n+<tr><td class=\"c1\">SQLite3</td>\n+    <td class=\"c2\">48,500 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bsql\" style=\"width:21px\">&nbsp;</div></td>\n+    <td class=\"c4\">(1.00x baseline)</td></tr>\n+</table>\n+<h4>Random Writes</h4>\n+<table class=\"bn\">\n+<tr><td class=\"c1\">LevelDB</td>\n+    <td class=\"c2\">355,000 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bldb\" style=\"width:350px\">&nbsp;</div></td>\n+    <td class=\"c4\">(2.16x baseline)</td></tr>\n+<tr><td class=\"c1\">Kyoto TreeDB</td>\n+    <td class=\"c2\">284,000 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bkct\" style=\"width:280px\">&nbsp;</div></td>\n+    <td class=\"c4\">(3.21x baseline)</td></tr>\n+<tr><td class=\"c1\">SQLite3</td>\n+    <td class=\"c2\">9,670 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bsql\" style=\"width:10px\">&nbsp;</div></td>\n+    <td class=\"c4\">(0.98x baseline)</td></tr>\n+</table>\n+\n+<p>SQLite's performance does not change substantially when compared to\n+the baseline, but the random write performance for both LevelDB and\n+TreeDB increases significantly.  LevelDB's performance improves\n+because a larger write buffer reduces the need to merge sorted files\n+(since it creates a smaller number of larger sorted files).  TreeDB's\n+performance goes up because the entire database is available in memory\n+for fast in-place updates.</p>\n+\n+  <h2>3. Read Performance under Different Configurations</h2>\n+<h3>A. Larger Caches</h3>\n+<p>We increased the overall memory usage to 128 MB for each database.\n+For LevelDB, we allocated 8 MB to LevelDB's write buffer and 120 MB\n+to LevelDB's cache. The other databases don't differentiate between a\n+write buffer and a cache, so we simply set their cache size to 128\n+MB.</p>\n+<h4>Sequential Reads</h4>\n+<table class=\"bn\">\n+<tr><td class=\"c1\">LevelDB</td>\n+    <td class=\"c2\">5,210,000 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bldb\" style=\"width:350px\">&nbsp;</div></td>\n+    <td class=\"c4\">(1.29x baseline)</td></tr>\n+<tr><td class=\"c1\">Kyoto TreeDB</td>\n+    <td class=\"c2\">1,070,000 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bkct\" style=\"width:72px\">&nbsp;</div></td>\n+    <td class=\"c4\">(1.06x baseline)</td></tr>\n+<tr><td class=\"c1\">SQLite3</td>\n+    <td class=\"c2\">609,000 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bsql\" style=\"width:41px\">&nbsp;</div></td>\n+    <td class=\"c4\">(1.59x baseline)</td></tr>\n+</table>\n+\n+<h4>Random Reads</h4>\n+<table class=\"bn\">\n+<tr><td class=\"c1\">LevelDB</td>\n+    <td class=\"c2\">190,000 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bldb\" style=\"width:144px\">&nbsp;</div></td>\n+    <td class=\"c4\">(1.47x baseline)</td></tr>\n+<tr><td class=\"c1\">Kyoto TreeDB</td>\n+    <td class=\"c2\">463,000 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bkct\" style=\"width:350px\">&nbsp;</div></td>\n+    <td class=\"c4\">(3.07x baseline)</td></tr>\n+<tr><td class=\"c1\">SQLite3</td>\n+    <td class=\"c2\">186,000 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bsql\" style=\"width:141px\">&nbsp;</div></td>\n+    <td class=\"c4\">(1.39x baseline)</td></tr>\n+</table>\n+\n+<p>As expected, the read performance of all of the databases increases\n+when the caches are enlarged.  In particular, TreeDB seems to make\n+very effective use of a cache that is large enough to hold the entire\n+database.</p>\n+\n+<h3>B. No Compression Reads </h3>\n+<p>For this benchmark, we populated a database with 1 million entries consisting of 16 byte keys and 100 byte values. We compiled LevelDB and Kyoto Cabinet without compression support, so results that are read out from the database are already uncompressed. We've listed the SQLite3 baseline read performance as a point of comparison.</p>\n+<h4>Sequential Reads</h4>\n+<table class=\"bn\">\n+<tr><td class=\"c1\">LevelDB</td>\n+    <td class=\"c2\">4,880,000 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bldb\" style=\"width:350px\">&nbsp;</div></td>\n+    <td class=\"c4\">(1.21x baseline)</td></tr>\n+<tr><td class=\"c1\">Kyoto TreeDB</td>\n+    <td class=\"c2\">1,230,000 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bkct\" style=\"width:88px\">&nbsp;</div></td>\n+    <td class=\"c4\">(3.60x baseline)</td></tr>\n+<tr><td class=\"c1\">SQLite3</td>\n+    <td class=\"c2\">383,000 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bsql\" style=\"width:27px\">&nbsp;</div></td>\n+    <td class=\"c4\">(1.00x baseline)</td></tr>\n+</table>\n+<h4>Random Reads</h4>\n+<table class=\"bn\">\n+<tr><td class=\"c1\">LevelDB</td>\n+    <td class=\"c2\">149,000 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bldb\" style=\"width:300px\">&nbsp;</div></td>\n+    <td class=\"c4\">(1.16x baseline)</td></tr>\n+<tr><td class=\"c1\">Kyoto TreeDB</td>\n+    <td class=\"c2\">175,000 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bkct\" style=\"width:350px\">&nbsp;</div></td>\n+    <td class=\"c4\">(1.16x baseline)</td></tr>\n+<tr><td class=\"c1\">SQLite3</td>\n+    <td class=\"c2\">134,000 ops/sec</td>\n+    <td class=\"c3\"><div class=\"bsql\" style=\"width:268px\">&nbsp;</div></td>\n+    <td class=\"c4\">(1.00x baseline)</td></tr>\n+</table>\n+\n+<p>Performance of both LevelDB and TreeDB improves a small amount when\n+compression is disabled.  Note however that under different workloads,\n+performance may very well be better with compression if it allows more\n+of the working set to fit in memory.</p>\n+\n+<h2>Note about Ext4 Filesystems</h2>\n+<p>The preceding numbers are for an ext3 file system. Synchronous writes are much slower under <a href=\"http://en.wikipedia.org/wiki/Ext4\">ext4</a> (LevelDB drops to ~31 writes / second and TreeDB drops to ~5 writes / second; SQLite3's synchronous writes do not noticeably drop) due to ext4's different handling of <span class=\"code\">fsync</span> / <span class=\"code\">msync</span> calls. Even LevelDB's asynchronous write performance drops somewhat since it spreads its storage across multiple files and issues <span class=\"code\">fsync</span> calls when switching to a new file.</p>\n+\n+<h2>Acknowledgements</h2>\n+<p>Jeff Dean and Sanjay Ghemawat wrote LevelDB. Kevin Tseng wrote and compiled these benchmarks. Mikio Hirabayashi, Scott Hess, and Gabor Cselle provided help and advice.</p>\n+</body>\n+</html>"
      },
      {
        "sha": "700c564e433827c311cd8a26896ceaa7c8260818",
        "filename": "src/leveldb/doc/doc.css",
        "status": "added",
        "additions": 89,
        "deletions": 0,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/doc/doc.css",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/doc/doc.css",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/doc.css?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,89 @@\n+body {\n+  margin-left: 0.5in;\n+  margin-right: 0.5in;\n+  background: white;\n+  color: black;\n+}\n+\n+h1 {\n+  margin-left: -0.2in;\n+  font-size: 14pt;\n+}\n+h2 {\n+  margin-left: -0in;\n+  font-size: 12pt;\n+}\n+h3 {\n+  margin-left: -0in;\n+}\n+h4 {\n+  margin-left: -0in;\n+}\n+hr {\n+  margin-left: -0in;\n+}\n+\n+/* Definition lists: definition term bold */\n+dt {\n+  font-weight: bold;\n+}\n+\n+address {\n+  text-align: center;\n+}\n+code,samp,var {\n+  color: blue;\n+}\n+kbd {\n+  color: #600000;\n+}\n+div.note p {\n+  float: right;\n+  width: 3in;\n+  margin-right: 0%;\n+  padding: 1px;\n+  border: 2px solid #6060a0;\n+  background-color: #fffff0;\n+}\n+\n+ul {\n+  margin-top: -0em;\n+  margin-bottom: -0em;\n+}\n+\n+ol {\n+  margin-top: -0em;\n+  margin-bottom: -0em;\n+}\n+\n+UL.nobullets {\n+  list-style-type: none;\n+  list-style-image: none;\n+  margin-left: -1em;\n+}\n+\n+p {\n+  margin: 1em 0 1em 0;\n+  padding: 0 0 0 0;\n+}\n+\n+pre {\n+  line-height: 1.3em;\n+  padding: 0.4em 0 0.8em 0;\n+  margin:  0 0 0 0;\n+  border:  0 0 0 0;\n+  color: blue;\n+}\n+\n+.datatable {\n+  margin-left: auto;\n+  margin-right: auto;\n+  margin-top: 2em;\n+  margin-bottom: 2em;\n+  border: 1px solid;\n+}\n+\n+.datatable td,th {\n+  padding: 0 0.5em 0 0.5em;\n+  text-align: right;\n+}"
      },
      {
        "sha": "e870795d231463b167d5b79efdc16b80107de93e",
        "filename": "src/leveldb/doc/impl.html",
        "status": "added",
        "additions": 213,
        "deletions": 0,
        "changes": 213,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/doc/impl.html",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/doc/impl.html",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/impl.html?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,213 @@\n+<!DOCTYPE html>\n+<html>\n+<head>\n+<link rel=\"stylesheet\" type=\"text/css\" href=\"doc.css\" />\n+<title>Leveldb file layout and compactions</title>\n+</head>\n+\n+<body>\n+\n+<h1>Files</h1>\n+\n+The implementation of leveldb is similar in spirit to the\n+representation of a single\n+<a href=\"http://labs.google.com/papers/bigtable.html\">\n+Bigtable tablet (section 5.3)</a>.\n+However the organization of the files that make up the representation\n+is somewhat different and is explained below.\n+\n+<p>\n+Each database is represented by a set of files stored in a directory.\n+There are several different types of files as documented below:\n+<p>\n+<h2>Log files</h2>\n+<p>\n+A log file (*.log) stores a sequence of recent updates.  Each update\n+is appended to the current log file.  When the log file reaches a\n+pre-determined size (approximately 4MB by default), it is converted\n+to a sorted table (see below) and a new log file is created for future\n+updates.\n+<p>\n+A copy of the current log file is kept in an in-memory structure (the\n+<code>memtable</code>).  This copy is consulted on every read so that read\n+operations reflect all logged updates.\n+<p>\n+<h2>Sorted tables</h2>\n+<p>\n+A sorted table (*.sst) stores a sequence of entries sorted by key.\n+Each entry is either a value for the key, or a deletion marker for the\n+key.  (Deletion markers are kept around to hide obsolete values\n+present in older sorted tables).\n+<p>\n+The set of sorted tables are organized into a sequence of levels.  The\n+sorted table generated from a log file is placed in a special <code>young</code>\n+level (also called level-0).  When the number of young files exceeds a\n+certain threshold (currently four), all of the young files are merged\n+together with all of the overlapping level-1 files to produce a\n+sequence of new level-1 files (we create a new level-1 file for every\n+2MB of data.)\n+<p>\n+Files in the young level may contain overlapping keys.  However files\n+in other levels have distinct non-overlapping key ranges.  Consider\n+level number L where L >= 1.  When the combined size of files in\n+level-L exceeds (10^L) MB (i.e., 10MB for level-1, 100MB for level-2,\n+...), one file in level-L, and all of the overlapping files in\n+level-(L+1) are merged to form a set of new files for level-(L+1).\n+These merges have the effect of gradually migrating new updates from\n+the young level to the largest level using only bulk reads and writes\n+(i.e., minimizing expensive seeks).\n+\n+<h2>Manifest</h2>\n+<p>\n+A MANIFEST file lists the set of sorted tables that make up each\n+level, the corresponding key ranges, and other important metadata.\n+A new MANIFEST file (with a new number embedded in the file name)\n+is created whenever the database is reopened.  The MANIFEST file is\n+formatted as a log, and changes made to the serving state (as files\n+are added or removed) are appended to this log.\n+<p>\n+<h2>Current</h2>\n+<p>\n+CURRENT is a simple text file that contains the name of the latest\n+MANIFEST file.\n+<p>\n+<h2>Info logs</h2>\n+<p>\n+Informational messages are printed to files named LOG and LOG.old.\n+<p>\n+<h2>Others</h2>\n+<p>\n+Other files used for miscellaneous purposes may also be present\n+(LOCK, *.dbtmp).\n+\n+<h1>Level 0</h1>\n+When the log file grows above a certain size (1MB by default):\n+<ul>\n+<li>Create a brand new memtable and log file and direct future updates here\n+<li>In the background:\n+<ul>\n+<li>Write the contents of the previous memtable to an sstable\n+<li>Discard the memtable\n+<li>Delete the old log file and the old memtable\n+<li>Add the new sstable to the young (level-0) level.\n+</ul>\n+</ul>\n+\n+<h1>Compactions</h1>\n+\n+<p>\n+When the size of level L exceeds its limit, we compact it in a\n+background thread.  The compaction picks a file from level L and all\n+overlapping files from the next level L+1.  Note that if a level-L\n+file overlaps only part of a level-(L+1) file, the entire file at\n+level-(L+1) is used as an input to the compaction and will be\n+discarded after the compaction.  Aside: because level-0 is special\n+(files in it may overlap each other), we treat compactions from\n+level-0 to level-1 specially: a level-0 compaction may pick more than\n+one level-0 file in case some of these files overlap each other.\n+\n+<p>\n+A compaction merges the contents of the picked files to produce a\n+sequence of level-(L+1) files.  We switch to producing a new\n+level-(L+1) file after the current output file has reached the target\n+file size (2MB).  We also switch to a new output file when the key\n+range of the current output file has grown enough to overlap more then\n+ten level-(L+2) files.  This last rule ensures that a later compaction\n+of a level-(L+1) file will not pick up too much data from level-(L+2).\n+\n+<p>\n+The old files are discarded and the new files are added to the serving\n+state.\n+\n+<p>\n+Compactions for a particular level rotate through the key space.  In\n+more detail, for each level L, we remember the ending key of the last\n+compaction at level L.  The next compaction for level L will pick the\n+first file that starts after this key (wrapping around to the\n+beginning of the key space if there is no such file).\n+\n+<p>\n+Compactions drop overwritten values.  They also drop deletion markers\n+if there are no higher numbered levels that contain a file whose range\n+overlaps the current key.\n+\n+<h2>Timing</h2>\n+\n+Level-0 compactions will read up to four 1MB files from level-0, and\n+at worst all the level-1 files (10MB).  I.e., we will read 14MB and\n+write 14MB.\n+\n+<p>\n+Other than the special level-0 compactions, we will pick one 2MB file\n+from level L.  In the worst case, this will overlap ~ 12 files from\n+level L+1 (10 because level-(L+1) is ten times the size of level-L,\n+and another two at the boundaries since the file ranges at level-L\n+will usually not be aligned with the file ranges at level-L+1).  The\n+compaction will therefore read 26MB and write 26MB.  Assuming a disk\n+IO rate of 100MB/s (ballpark range for modern drives), the worst\n+compaction cost will be approximately 0.5 second.\n+\n+<p>\n+If we throttle the background writing to something small, say 10% of\n+the full 100MB/s speed, a compaction may take up to 5 seconds.  If the\n+user is writing at 10MB/s, we might build up lots of level-0 files\n+(~50 to hold the 5*10MB).  This may signficantly increase the cost of\n+reads due to the overhead of merging more files together on every\n+read.\n+\n+<p>\n+Solution 1: To reduce this problem, we might want to increase the log\n+switching threshold when the number of level-0 files is large.  Though\n+the downside is that the larger this threshold, the more memory we will\n+need to hold the corresponding memtable.\n+\n+<p>\n+Solution 2: We might want to decrease write rate artificially when the\n+number of level-0 files goes up.\n+\n+<p>\n+Solution 3: We work on reducing the cost of very wide merges.\n+Perhaps most of the level-0 files will have their blocks sitting\n+uncompressed in the cache and we will only need to worry about the\n+O(N) complexity in the merging iterator.\n+\n+<h2>Number of files</h2>\n+\n+Instead of always making 2MB files, we could make larger files for\n+larger levels to reduce the total file count, though at the expense of\n+more bursty compactions.  Alternatively, we could shard the set of\n+files into multiple directories.\n+\n+<p>\n+An experiment on an <code>ext3</code> filesystem on Feb 04, 2011 shows\n+the following timings to do 100K file opens in directories with\n+varying number of files:\n+<table class=\"datatable\">\n+<tr><th>Files in directory</th><th>Microseconds to open a file</th></tr>\n+<tr><td>1000</td><td>9</td>\n+<tr><td>10000</td><td>10</td>\n+<tr><td>100000</td><td>16</td>\n+</table>\n+So maybe even the sharding is not necessary on modern filesystems?\n+\n+<h1>Recovery</h1>\n+\n+<ul>\n+<li> Read CURRENT to find name of the latest committed MANIFEST\n+<li> Read the named MANIFEST file\n+<li> Clean up stale files\n+<li> We could open all sstables here, but it is probably better to be lazy...\n+<li> Convert log chunk to a new level-0 sstable\n+<li> Start directing new writes to a new log file with recovered sequence#\n+</ul>\n+\n+<h1>Garbage collection of files</h1>\n+\n+<code>DeleteObsoleteFiles()</code> is called at the end of every\n+compaction and at the end of recovery.  It finds the names of all\n+files in the database.  It deletes all log files that are not the\n+current log file.  It deletes all table files that are not referenced\n+from some level and are not the output of an active compaction.\n+\n+</body>\n+</html>"
      },
      {
        "sha": "521d2baf41b6609e39e0044d9b25d9857d743e4f",
        "filename": "src/leveldb/doc/index.html",
        "status": "added",
        "additions": 549,
        "deletions": 0,
        "changes": 549,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/doc/index.html",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/doc/index.html",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/index.html?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,549 @@\n+<!DOCTYPE html>\n+<html>\n+<head>\n+<link rel=\"stylesheet\" type=\"text/css\" href=\"doc.css\" />\n+<title>Leveldb</title>\n+</head>\n+\n+<body>\n+<h1>Leveldb</h1>\n+<address>Jeff Dean, Sanjay Ghemawat</address>\n+<p>\n+The <code>leveldb</code> library provides a persistent key value store.  Keys and\n+values are arbitrary byte arrays.  The keys are ordered within the key\n+value store according to a user-specified comparator function.\n+\n+<p>\n+<h1>Opening A Database</h1>\n+<p>\n+A <code>leveldb</code> database has a name which corresponds to a file system\n+directory.  All of the contents of database are stored in this\n+directory.  The following example shows how to open a database,\n+creating it if necessary:\n+<p>\n+<pre>\n+  #include &lt;assert&gt;\n+  #include \"leveldb/db.h\"\n+\n+  leveldb::DB* db;\n+  leveldb::Options options;\n+  options.create_if_missing = true;\n+  leveldb::Status status = leveldb::DB::Open(options, \"/tmp/testdb\", &amp;db);\n+  assert(status.ok());\n+  ...\n+</pre>\n+If you want to raise an error if the database already exists, add\n+the following line before the <code>leveldb::DB::Open</code> call:\n+<pre>\n+  options.error_if_exists = true;\n+</pre>\n+<h1>Status</h1>\n+<p>\n+You may have noticed the <code>leveldb::Status</code> type above.  Values of this\n+type are returned by most functions in <code>leveldb</code> that may encounter an\n+error.  You can check if such a result is ok, and also print an\n+associated error message:\n+<p>\n+<pre>\n+   leveldb::Status s = ...;\n+   if (!s.ok()) cerr &lt;&lt; s.ToString() &lt;&lt; endl;\n+</pre>\n+<h1>Closing A Database</h1>\n+<p>\n+When you are done with a database, just delete the database object.\n+Example:\n+<p>\n+<pre>\n+  ... open the db as described above ...\n+  ... do something with db ...\n+  delete db;\n+</pre>\n+<h1>Reads And Writes</h1>\n+<p>\n+The database provides <code>Put</code>, <code>Delete</code>, and <code>Get</code> methods to\n+modify/query the database.  For example, the following code\n+moves the value stored under key1 to key2.\n+<pre>\n+  std::string value;\n+  leveldb::Status s = db-&gt;Get(leveldb::ReadOptions(), key1, &amp;value);\n+  if (s.ok()) s = db-&gt;Put(leveldb::WriteOptions(), key2, value);\n+  if (s.ok()) s = db-&gt;Delete(leveldb::WriteOptions(), key1);\n+</pre>\n+\n+<h1>Atomic Updates</h1>\n+<p>\n+Note that if the process dies after the Put of key2 but before the\n+delete of key1, the same value may be left stored under multiple keys.\n+Such problems can be avoided by using the <code>WriteBatch</code> class to\n+atomically apply a set of updates:\n+<p>\n+<pre>\n+  #include \"leveldb/write_batch.h\"\n+  ...\n+  std::string value;\n+  leveldb::Status s = db-&gt;Get(leveldb::ReadOptions(), key1, &amp;value);\n+  if (s.ok()) {\n+    leveldb::WriteBatch batch;\n+    batch.Delete(key1);\n+    batch.Put(key2, value);\n+    s = db-&gt;Write(leveldb::WriteOptions(), &amp;batch);\n+  }\n+</pre>\n+The <code>WriteBatch</code> holds a sequence of edits to be made to the database,\n+and these edits within the batch are applied in order.  Note that we\n+called <code>Delete</code> before <code>Put</code> so that if <code>key1</code> is identical to <code>key2</code>,\n+we do not end up erroneously dropping the value entirely.\n+<p>\n+Apart from its atomicity benefits, <code>WriteBatch</code> may also be used to\n+speed up bulk updates by placing lots of individual mutations into the\n+same batch.\n+\n+<h1>Synchronous Writes</h1>\n+By default, each write to <code>leveldb</code> is asynchronous: it\n+returns after pushing the write from the process into the operating\n+system.  The transfer from operating system memory to the underlying\n+persistent storage happens asynchronously.  The <code>sync</code> flag\n+can be turned on for a particular write to make the write operation\n+not return until the data being written has been pushed all the way to\n+persistent storage.  (On Posix systems, this is implemented by calling\n+either <code>fsync(...)</code> or <code>fdatasync(...)</code> or\n+<code>msync(..., MS_SYNC)</code> before the write operation returns.)\n+<pre>\n+  leveldb::WriteOptions write_options;\n+  write_options.sync = true;\n+  db-&gt;Put(write_options, ...);\n+</pre>\n+Asynchronous writes are often more than a thousand times as fast as\n+synchronous writes.  The downside of asynchronous writes is that a\n+crash of the machine may cause the last few updates to be lost.  Note\n+that a crash of just the writing process (i.e., not a reboot) will not\n+cause any loss since even when <code>sync</code> is false, an update\n+is pushed from the process memory into the operating system before it\n+is considered done.\n+\n+<p>\n+Asynchronous writes can often be used safely.  For example, when\n+loading a large amount of data into the database you can handle lost\n+updates by restarting the bulk load after a crash.  A hybrid scheme is\n+also possible where every Nth write is synchronous, and in the event\n+of a crash, the bulk load is restarted just after the last synchronous\n+write finished by the previous run.  (The synchronous write can update\n+a marker that describes where to restart on a crash.)\n+\n+<p>\n+<code>WriteBatch</code> provides an alternative to asynchronous writes.\n+Multiple updates may be placed in the same <code>WriteBatch</code> and\n+applied together using a synchronous write (i.e.,\n+<code>write_options.sync</code> is set to true).  The extra cost of\n+the synchronous write will be amortized across all of the writes in\n+the batch.\n+\n+<p>\n+<h1>Concurrency</h1>\n+<p>\n+A database may only be opened by one process at a time.\n+The <code>leveldb</code> implementation acquires a lock from the\n+operating system to prevent misuse.  Within a single process, the\n+same <code>leveldb::DB</code> object may be safely shared by multiple\n+concurrent threads.  I.e., different threads may write into or fetch\n+iterators or call <code>Get</code> on the same database without any\n+external synchronization (the leveldb implementation will\n+automatically do the required synchronization).  However other objects\n+(like Iterator and WriteBatch) may require external synchronization.\n+If two threads share such an object, they must protect access to it\n+using their own locking protocol.  More details are available in\n+the public header files.\n+<p>\n+<h1>Iteration</h1>\n+<p>\n+The following example demonstrates how to print all key,value pairs\n+in a database.\n+<p>\n+<pre>\n+  leveldb::Iterator* it = db-&gt;NewIterator(leveldb::ReadOptions());\n+  for (it-&gt;SeekToFirst(); it-&gt;Valid(); it-&gt;Next()) {\n+    cout &lt;&lt; it-&gt;key().ToString() &lt;&lt; \": \"  &lt;&lt; it-&gt;value().ToString() &lt;&lt; endl;\n+  }\n+  assert(it-&gt;status().ok());  // Check for any errors found during the scan\n+  delete it;\n+</pre>\n+The following variation shows how to process just the keys in the\n+range <code>[start,limit)</code>:\n+<p>\n+<pre>\n+  for (it-&gt;Seek(start);\n+       it-&gt;Valid() &amp;&amp; it-&gt;key().ToString() &lt; limit;\n+       it-&gt;Next()) {\n+    ...\n+  }\n+</pre>\n+You can also process entries in reverse order.  (Caveat: reverse\n+iteration may be somewhat slower than forward iteration.)\n+<p>\n+<pre>\n+  for (it-&gt;SeekToLast(); it-&gt;Valid(); it-&gt;Prev()) {\n+    ...\n+  }\n+</pre>\n+<h1>Snapshots</h1>\n+<p>\n+Snapshots provide consistent read-only views over the entire state of\n+the key-value store.  <code>ReadOptions::snapshot</code> may be non-NULL to indicate\n+that a read should operate on a particular version of the DB state.\n+If <code>ReadOptions::snapshot</code> is NULL, the read will operate on an\n+implicit snapshot of the current state.\n+<p>\n+Snapshots are created by the DB::GetSnapshot() method:\n+<p>\n+<pre>\n+  leveldb::ReadOptions options;\n+  options.snapshot = db-&gt;GetSnapshot();\n+  ... apply some updates to db ...\n+  leveldb::Iterator* iter = db-&gt;NewIterator(options);\n+  ... read using iter to view the state when the snapshot was created ...\n+  delete iter;\n+  db-&gt;ReleaseSnapshot(options.snapshot);\n+</pre>\n+Note that when a snapshot is no longer needed, it should be released\n+using the DB::ReleaseSnapshot interface.  This allows the\n+implementation to get rid of state that was being maintained just to\n+support reading as of that snapshot.\n+<h1>Slice</h1>\n+<p>\n+The return value of the <code>it->key()</code> and <code>it->value()</code> calls above\n+are instances of the <code>leveldb::Slice</code> type.  <code>Slice</code> is a simple\n+structure that contains a length and a pointer to an external byte\n+array.  Returning a <code>Slice</code> is a cheaper alternative to returning a\n+<code>std::string</code> since we do not need to copy potentially large keys and\n+values.  In addition, <code>leveldb</code> methods do not return null-terminated\n+C-style strings since <code>leveldb</code> keys and values are allowed to\n+contain '\\0' bytes.\n+<p>\n+C++ strings and null-terminated C-style strings can be easily converted\n+to a Slice:\n+<p>\n+<pre>\n+   leveldb::Slice s1 = \"hello\";\n+\n+   std::string str(\"world\");\n+   leveldb::Slice s2 = str;\n+</pre>\n+A Slice can be easily converted back to a C++ string:\n+<pre>\n+   std::string str = s1.ToString();\n+   assert(str == std::string(\"hello\"));\n+</pre>\n+Be careful when using Slices since it is up to the caller to ensure that\n+the external byte array into which the Slice points remains live while\n+the Slice is in use.  For example, the following is buggy:\n+<p>\n+<pre>\n+   leveldb::Slice slice;\n+   if (...) {\n+     std::string str = ...;\n+     slice = str;\n+   }\n+   Use(slice);\n+</pre>\n+When the <code>if</code> statement goes out of scope, <code>str</code> will be destroyed and the\n+backing storage for <code>slice</code> will disappear.\n+<p>\n+<h1>Comparators</h1>\n+<p>\n+The preceding examples used the default ordering function for key,\n+which orders bytes lexicographically.  You can however supply a custom\n+comparator when opening a database.  For example, suppose each\n+database key consists of two numbers and we should sort by the first\n+number, breaking ties by the second number.  First, define a proper\n+subclass of <code>leveldb::Comparator</code> that expresses these rules:\n+<p>\n+<pre>\n+  class TwoPartComparator : public leveldb::Comparator {\n+   public:\n+    // Three-way comparison function:\n+    //   if a &lt; b: negative result\n+    //   if a &gt; b: positive result\n+    //   else: zero result\n+    int Compare(const leveldb::Slice&amp; a, const leveldb::Slice&amp; b) const {\n+      int a1, a2, b1, b2;\n+      ParseKey(a, &amp;a1, &amp;a2);\n+      ParseKey(b, &amp;b1, &amp;b2);\n+      if (a1 &lt; b1) return -1;\n+      if (a1 &gt; b1) return +1;\n+      if (a2 &lt; b2) return -1;\n+      if (a2 &gt; b2) return +1;\n+      return 0;\n+    }\n+\n+    // Ignore the following methods for now:\n+    const char* Name() const { return \"TwoPartComparator\"; }\n+    void FindShortestSeparator(std::string*, const leveldb::Slice&amp;) const { }\n+    void FindShortSuccessor(std::string*) const { }\n+  };\n+</pre>\n+Now create a database using this custom comparator:\n+<p>\n+<pre>\n+  TwoPartComparator cmp;\n+  leveldb::DB* db;\n+  leveldb::Options options;\n+  options.create_if_missing = true;\n+  options.comparator = &amp;cmp;\n+  leveldb::Status status = leveldb::DB::Open(options, \"/tmp/testdb\", &amp;db);\n+  ...\n+</pre>\n+<h2>Backwards compatibility</h2>\n+<p>\n+The result of the comparator's <code>Name</code> method is attached to the\n+database when it is created, and is checked on every subsequent\n+database open.  If the name changes, the <code>leveldb::DB::Open</code> call will\n+fail.  Therefore, change the name if and only if the new key format\n+and comparison function are incompatible with existing databases, and\n+it is ok to discard the contents of all existing databases.\n+<p>\n+You can however still gradually evolve your key format over time with\n+a little bit of pre-planning.  For example, you could store a version\n+number at the end of each key (one byte should suffice for most uses).\n+When you wish to switch to a new key format (e.g., adding an optional\n+third part to the keys processed by <code>TwoPartComparator</code>),\n+(a) keep the same comparator name (b) increment the version number\n+for new keys (c) change the comparator function so it uses the\n+version numbers found in the keys to decide how to interpret them.\n+<p>\n+<h1>Performance</h1>\n+<p>\n+Performance can be tuned by changing the default values of the\n+types defined in <code>include/leveldb/options.h</code>.\n+\n+<p>\n+<h2>Block size</h2>\n+<p>\n+<code>leveldb</code> groups adjacent keys together into the same block and such a\n+block is the unit of transfer to and from persistent storage.  The\n+default block size is approximately 4096 uncompressed bytes.\n+Applications that mostly do bulk scans over the contents of the\n+database may wish to increase this size.  Applications that do a lot\n+of point reads of small values may wish to switch to a smaller block\n+size if performance measurements indicate an improvement.  There isn't\n+much benefit in using blocks smaller than one kilobyte, or larger than\n+a few megabytes.  Also note that compression will be more effective\n+with larger block sizes.\n+<p>\n+<h2>Compression</h2>\n+<p>\n+Each block is individually compressed before being written to\n+persistent storage.  Compression is on by default since the default\n+compression method is very fast, and is automatically disabled for\n+uncompressible data.  In rare cases, applications may want to disable\n+compression entirely, but should only do so if benchmarks show a\n+performance improvement:\n+<p>\n+<pre>\n+  leveldb::Options options;\n+  options.compression = leveldb::kNoCompression;\n+  ... leveldb::DB::Open(options, name, ...) ....\n+</pre>\n+<h2>Cache</h2>\n+<p>\n+The contents of the database are stored in a set of files in the\n+filesystem and each file stores a sequence of compressed blocks.  If\n+<code>options.cache</code> is non-NULL, it is used to cache frequently used\n+uncompressed block contents.\n+<p>\n+<pre>\n+  #include \"leveldb/cache.h\"\n+\n+  leveldb::Options options;\n+  options.cache = leveldb::NewLRUCache(100 * 1048576);  // 100MB cache\n+  leveldb::DB* db;\n+  leveldb::DB::Open(options, name, &db);\n+  ... use the db ...\n+  delete db\n+  delete options.cache;\n+</pre>\n+Note that the cache holds uncompressed data, and therefore it should\n+be sized according to application level data sizes, without any\n+reduction from compression.  (Caching of compressed blocks is left to\n+the operating system buffer cache, or any custom <code>Env</code>\n+implementation provided by the client.)\n+<p>\n+When performing a bulk read, the application may wish to disable\n+caching so that the data processed by the bulk read does not end up\n+displacing most of the cached contents.  A per-iterator option can be\n+used to achieve this:\n+<p>\n+<pre>\n+  leveldb::ReadOptions options;\n+  options.fill_cache = false;\n+  leveldb::Iterator* it = db-&gt;NewIterator(options);\n+  for (it-&gt;SeekToFirst(); it-&gt;Valid(); it-&gt;Next()) {\n+    ...\n+  }\n+</pre>\n+<h2>Key Layout</h2>\n+<p>\n+Note that the unit of disk transfer and caching is a block.  Adjacent\n+keys (according to the database sort order) will usually be placed in\n+the same block.  Therefore the application can improve its performance\n+by placing keys that are accessed together near each other and placing\n+infrequently used keys in a separate region of the key space.\n+<p>\n+For example, suppose we are implementing a simple file system on top\n+of <code>leveldb</code>.  The types of entries we might wish to store are:\n+<p>\n+<pre>\n+   filename -&gt; permission-bits, length, list of file_block_ids\n+   file_block_id -&gt; data\n+</pre>\n+We might want to prefix <code>filename</code> keys with one letter (say '/') and the\n+<code>file_block_id</code> keys with a different letter (say '0') so that scans\n+over just the metadata do not force us to fetch and cache bulky file\n+contents.\n+<p>\n+<h2>Filters</h2>\n+<p>\n+Because of the way <code>leveldb</code> data is organized on disk,\n+a single <code>Get()</code> call may involve multiple reads from disk.\n+The optional <code>FilterPolicy</code> mechanism can be used to reduce\n+the number of disk reads substantially.\n+<pre>\n+   leveldb::Options options;\n+   options.filter_policy = NewBloomFilter(10);\n+   leveldb::DB* db;\n+   leveldb::DB::Open(options, \"/tmp/testdb\", &amp;db);\n+   ... use the database ...\n+   delete db;\n+   delete options.filter_policy;\n+</pre>\n+The preceding code associates a\n+<a href=\"http://en.wikipedia.org/wiki/Bloom_filter\">Bloom filter</a>\n+based filtering policy with the database.  Bloom filter based\n+filtering relies on keeping some number of bits of data in memory per\n+key (in this case 10 bits per key since that is the argument we passed\n+to NewBloomFilter).  This filter will reduce the number of unnecessary\n+disk reads needed for <code>Get()</code> calls by a factor of\n+approximately a 100.  Increasing the bits per key will lead to a\n+larger reduction at the cost of more memory usage.  We recommend that\n+applications whose working set does not fit in memory and that do a\n+lot of random reads set a filter policy.\n+<p>\n+If you are using a custom comparator, you should ensure that the filter\n+policy you are using is compatible with your comparator.  For example,\n+consider a comparator that ignores trailing spaces when comparing keys.\n+<code>NewBloomFilter</code> must not be used with such a comparator.\n+Instead, the application should provide a custom filter policy that\n+also ignores trailing spaces.  For example:\n+<pre>\n+  class CustomFilterPolicy : public leveldb::FilterPolicy {\n+   private:\n+    FilterPolicy* builtin_policy_;\n+   public:\n+    CustomFilterPolicy() : builtin_policy_(NewBloomFilter(10)) { }\n+    ~CustomFilterPolicy() { delete builtin_policy_; }\n+\n+    const char* Name() const { return \"IgnoreTrailingSpacesFilter\"; }\n+\n+    void CreateFilter(const Slice* keys, int n, std::string* dst) const {\n+      // Use builtin bloom filter code after removing trailing spaces\n+      std::vector&lt;Slice&gt; trimmed(n);\n+      for (int i = 0; i &lt; n; i++) {\n+        trimmed[i] = RemoveTrailingSpaces(keys[i]);\n+      }\n+      return builtin_policy_-&gt;CreateFilter(&amp;trimmed[i], n, dst);\n+    }\n+\n+    bool KeyMayMatch(const Slice& key, const Slice& filter) const {\n+      // Use builtin bloom filter code after removing trailing spaces\n+      return builtin_policy_-&gt;KeyMayMatch(RemoveTrailingSpaces(key), filter);\n+    }\n+  };\n+</pre>\n+<p>\n+Advanced applications may provide a filter policy that does not use\n+a bloom filter but uses some other mechanism for summarizing a set\n+of keys.  See <code>leveldb/filter_policy.h</code> for detail.\n+<p>\n+<h1>Checksums</h1>\n+<p>\n+<code>leveldb</code> associates checksums with all data it stores in the file system.\n+There are two separate controls provided over how aggressively these\n+checksums are verified:\n+<p>\n+<ul>\n+<li> <code>ReadOptions::verify_checksums</code> may be set to true to force\n+  checksum verification of all data that is read from the file system on\n+  behalf of a particular read.  By default, no such verification is\n+  done.\n+<p>\n+<li> <code>Options::paranoid_checks</code> may be set to true before opening a\n+  database to make the database implementation raise an error as soon as\n+  it detects an internal corruption.  Depending on which portion of the\n+  database has been corrupted, the error may be raised when the database\n+  is opened, or later by another database operation.  By default,\n+  paranoid checking is off so that the database can be used even if\n+  parts of its persistent storage have been corrupted.\n+<p>\n+  If a database is corrupted (perhaps it cannot be opened when\n+  paranoid checking is turned on), the <code>leveldb::RepairDB</code> function\n+  may be used to recover as much of the data as possible\n+<p>\n+</ul>\n+<h1>Approximate Sizes</h1>\n+<p>\n+The <code>GetApproximateSizes</code> method can used to get the approximate\n+number of bytes of file system space used by one or more key ranges.\n+<p>\n+<pre>\n+   leveldb::Range ranges[2];\n+   ranges[0] = leveldb::Range(\"a\", \"c\");\n+   ranges[1] = leveldb::Range(\"x\", \"z\");\n+   uint64_t sizes[2];\n+   leveldb::Status s = db-&gt;GetApproximateSizes(ranges, 2, sizes);\n+</pre>\n+The preceding call will set <code>sizes[0]</code> to the approximate number of\n+bytes of file system space used by the key range <code>[a..c)</code> and\n+<code>sizes[1]</code> to the approximate number of bytes used by the key range\n+<code>[x..z)</code>.\n+<p>\n+<h1>Environment</h1>\n+<p>\n+All file operations (and other operating system calls) issued by the\n+<code>leveldb</code> implementation are routed through a <code>leveldb::Env</code> object.\n+Sophisticated clients may wish to provide their own <code>Env</code>\n+implementation to get better control.  For example, an application may\n+introduce artificial delays in the file IO paths to limit the impact\n+of <code>leveldb</code> on other activities in the system.\n+<p>\n+<pre>\n+  class SlowEnv : public leveldb::Env {\n+    .. implementation of the Env interface ...\n+  };\n+\n+  SlowEnv env;\n+  leveldb::Options options;\n+  options.env = &amp;env;\n+  Status s = leveldb::DB::Open(options, ...);\n+</pre>\n+<h1>Porting</h1>\n+<p>\n+<code>leveldb</code> may be ported to a new platform by providing platform\n+specific implementations of the types/methods/functions exported by\n+<code>leveldb/port/port.h</code>.  See <code>leveldb/port/port_example.h</code> for more\n+details.\n+<p>\n+In addition, the new platform may need a new default <code>leveldb::Env</code>\n+implementation.  See <code>leveldb/util/env_posix.h</code> for an example.\n+\n+<h1>Other Information</h1>\n+\n+<p>\n+Details about the <code>leveldb</code> implementation may be found in\n+the following documents:\n+<ul>\n+<li> <a href=\"impl.html\">Implementation notes</a>\n+<li> <a href=\"table_format.txt\">Format of an immutable Table file</a>\n+<li> <a href=\"log_format.txt\">Format of a log file</a>\n+</ul>\n+\n+</body>\n+</html>"
      },
      {
        "sha": "3a0414b65ac7e3ed4ddfd626ae88435297f619a2",
        "filename": "src/leveldb/doc/log_format.txt",
        "status": "added",
        "additions": 75,
        "deletions": 0,
        "changes": 75,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/doc/log_format.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/doc/log_format.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/log_format.txt?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,75 @@\n+The log file contents are a sequence of 32KB blocks.  The only\n+exception is that the tail of the file may contain a partial block.\n+\n+Each block consists of a sequence of records:\n+   block := record* trailer?\n+   record :=\n+\tchecksum: uint32\t// crc32c of type and data[]\n+\tlength: uint16\n+\ttype: uint8\t\t// One of FULL, FIRST, MIDDLE, LAST\n+\tdata: uint8[length]\n+\n+A record never starts within the last six bytes of a block (since it\n+won't fit).  Any leftover bytes here form the trailer, which must\n+consist entirely of zero bytes and must be skipped by readers.  \n+\n+Aside: if exactly seven bytes are left in the current block, and a new\n+non-zero length record is added, the writer must emit a FIRST record\n+(which contains zero bytes of user data) to fill up the trailing seven\n+bytes of the block and then emit all of the user data in subsequent\n+blocks.\n+\n+More types may be added in the future.  Some Readers may skip record\n+types they do not understand, others may report that some data was\n+skipped.\n+\n+FULL == 1\n+FIRST == 2\n+MIDDLE == 3\n+LAST == 4\n+\n+The FULL record contains the contents of an entire user record.\n+\n+FIRST, MIDDLE, LAST are types used for user records that have been\n+split into multiple fragments (typically because of block boundaries).\n+FIRST is the type of the first fragment of a user record, LAST is the\n+type of the last fragment of a user record, and MID is the type of all\n+interior fragments of a user record.\n+\n+Example: consider a sequence of user records:\n+   A: length 1000\n+   B: length 97270\n+   C: length 8000\n+A will be stored as a FULL record in the first block.\n+\n+B will be split into three fragments: first fragment occupies the rest\n+of the first block, second fragment occupies the entirety of the\n+second block, and the third fragment occupies a prefix of the third\n+block.  This will leave six bytes free in the third block, which will\n+be left empty as the trailer.\n+\n+C will be stored as a FULL record in the fourth block.\n+\n+===================\n+\n+Some benefits over the recordio format:\n+\n+(1) We do not need any heuristics for resyncing - just go to next\n+block boundary and scan.  If there is a corruption, skip to the next\n+block.  As a side-benefit, we do not get confused when part of the\n+contents of one log file are embedded as a record inside another log\n+file.\n+\n+(2) Splitting at approximate boundaries (e.g., for mapreduce) is\n+simple: find the next block boundary and skip records until we\n+hit a FULL or FIRST record.\n+\n+(3) We do not need extra buffering for large records.\n+\n+Some downsides compared to recordio format:\n+\n+(1) No packing of tiny records.  This could be fixed by adding a new\n+record type, so it is a shortcoming of the current implementation,\n+not necessarily the format.\n+\n+(2) No compression.  Again, this could be fixed by adding new record types."
      },
      {
        "sha": "d0f3065ed02d40f581d56e699d62b71e7a4f3396",
        "filename": "src/leveldb/doc/table_format.txt",
        "status": "added",
        "additions": 102,
        "deletions": 0,
        "changes": 102,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/doc/table_format.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/doc/table_format.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/table_format.txt?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,102 @@\n+File format\n+===========\n+\n+  <beginning_of_file>\n+  [data block 1]\n+  [data block 2]\n+  ...\n+  [data block N]\n+  [meta block 1]\n+  ...\n+  [meta block K]\n+  [metaindex block]\n+  [index block]\n+  [Footer]        (fixed size; starts at file_size - sizeof(Footer))\n+  <end_of_file>\n+\n+The file contains internal pointers.  Each such pointer is called\n+a BlockHandle and contains the following information:\n+  offset:\t    varint64\n+  size:\t\t    varint64\n+\n+(1) The sequence of key/value pairs in the file are stored in sorted\n+order and partitioned into a sequence of data blocks.  These blocks\n+come one after another at the beginning of the file.  Each data block\n+is formatted according to the code in block_builder.cc, and then\n+optionally compressed.\n+\n+(2) After the data blocks we store a bunch of meta blocks.  The\n+supported meta block types are described below.  More meta block types\n+may be added in the future.  Each meta block is again formatted using\n+block_builder.cc and then optionally compressed.\n+\n+(3) A \"metaindex\" block.  It contains one entry for every other meta\n+block where the key is the name of the meta block and the value is a\n+BlockHandle pointing to that meta block.\n+\n+(4) An \"index\" block.  This block contains one entry per data block,\n+where the key is a string >= last key in that data block and before\n+the first key in the successive data block.  The value is the\n+BlockHandle for the data block.\n+\n+(6) At the very end of the file is a fixed length footer that contains\n+the BlockHandle of the metaindex and index blocks as well as a magic number.\n+       metaindex_handle:       char[p];    // Block handle for metaindex\n+       index_handle:\t       char[q];    // Block handle for index\n+       padding:\t\t       char[40-p-q]; // 0 bytes to make fixed length\n+       \t\t\t \t       // (40==2*BlockHandle::kMaxEncodedLength)\n+       magic:\t\t       fixed64;    // == 0xdb4775248b80fb57\n+\n+\"filter\" Meta Block\n+-------------------\n+\n+If a \"FilterPolicy\" was specified when the database was opened, a\n+filter block is stored in each table.  The \"metaindex\" block contains\n+an entry that maps from \"filter.<N>\" to the BlockHandle for the filter\n+block where \"<N>\" is the string returned by the filter policy's\n+\"Name()\" method.\n+\n+The filter block stores a sequence of filters, where filter i contains\n+the output of FilterPolicy::CreateFilter() on all keys that are stored\n+in a block whose file offset falls within the range\n+\n+    [ i*base ... (i+1)*base-1 ]\n+\n+Currently, \"base\" is 2KB.  So for example, if blocks X and Y start in\n+the range [ 0KB .. 2KB-1 ], all of the keys in X and Y will be\n+converted to a filter by calling FilterPolicy::CreateFilter(), and the\n+resulting filter will be stored as the first filter in the filter\n+block.\n+\n+The filter block is formatted as follows:\n+\n+     [filter 0]\n+     [filter 1]\n+     [filter 2]\n+     ...\n+     [filter N-1]\n+\n+     [offset of filter 0]                  : 4 bytes\n+     [offset of filter 1]                  : 4 bytes\n+     [offset of filter 2]                  : 4 bytes\n+     ...\n+     [offset of filter N-1]                : 4 bytes\n+\n+     [offset of beginning of offset array] : 4 bytes\n+     lg(base)                              : 1 byte\n+\n+The offset array at the end of the filter block allows efficient\n+mapping from a data block offset to the corresponding filter.\n+\n+\"stats\" Meta Block\n+------------------\n+\n+This meta block contains a bunch of stats.  The key is the name\n+of the statistic.  The value contains the statistic.\n+TODO(postrelease): record following stats.\n+  data size\n+  index size\n+  key size (uncompressed)\n+  value size (uncompressed)\n+  number of entries\n+  number of data blocks"
      },
      {
        "sha": "2082083b3f5c30e0f23e70a50e5909c2ba56862c",
        "filename": "src/leveldb/helpers/memenv/memenv.cc",
        "status": "added",
        "additions": 374,
        "deletions": 0,
        "changes": 374,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/helpers/memenv/memenv.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/helpers/memenv/memenv.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/helpers/memenv/memenv.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,374 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include \"helpers/memenv/memenv.h\"\n+\n+#include \"leveldb/env.h\"\n+#include \"leveldb/status.h\"\n+#include \"port/port.h\"\n+#include \"util/mutexlock.h\"\n+#include <map>\n+#include <string.h>\n+#include <string>\n+#include <vector>\n+\n+namespace leveldb {\n+\n+namespace {\n+\n+class FileState {\n+ public:\n+  // FileStates are reference counted. The initial reference count is zero\n+  // and the caller must call Ref() at least once.\n+  FileState() : refs_(0), size_(0) {}\n+\n+  // Increase the reference count.\n+  void Ref() {\n+    MutexLock lock(&refs_mutex_);\n+    ++refs_;\n+  }\n+\n+  // Decrease the reference count. Delete if this is the last reference.\n+  void Unref() {\n+    bool do_delete = false;\n+\n+    {\n+      MutexLock lock(&refs_mutex_);\n+      --refs_;\n+      assert(refs_ >= 0);\n+      if (refs_ <= 0) {\n+        do_delete = true;\n+      }\n+    }\n+\n+    if (do_delete) {\n+      delete this;\n+    }\n+  }\n+\n+  uint64_t Size() const { return size_; }\n+\n+  Status Read(uint64_t offset, size_t n, Slice* result, char* scratch) const {\n+    if (offset > size_) {\n+      return Status::IOError(\"Offset greater than file size.\");\n+    }\n+    const uint64_t available = size_ - offset;\n+    if (n > available) {\n+      n = available;\n+    }\n+    if (n == 0) {\n+      *result = Slice();\n+      return Status::OK();\n+    }\n+\n+    size_t block = offset / kBlockSize;\n+    size_t block_offset = offset % kBlockSize;\n+\n+    if (n <= kBlockSize - block_offset) {\n+      // The requested bytes are all in the first block.\n+      *result = Slice(blocks_[block] + block_offset, n);\n+      return Status::OK();\n+    }\n+\n+    size_t bytes_to_copy = n;\n+    char* dst = scratch;\n+\n+    while (bytes_to_copy > 0) {\n+      size_t avail = kBlockSize - block_offset;\n+      if (avail > bytes_to_copy) {\n+        avail = bytes_to_copy;\n+      }\n+      memcpy(dst, blocks_[block] + block_offset, avail);\n+\n+      bytes_to_copy -= avail;\n+      dst += avail;\n+      block++;\n+      block_offset = 0;\n+    }\n+\n+    *result = Slice(scratch, n);\n+    return Status::OK();\n+  }\n+\n+  Status Append(const Slice& data) {\n+    const char* src = data.data();\n+    size_t src_len = data.size();\n+\n+    while (src_len > 0) {\n+      size_t avail;\n+      size_t offset = size_ % kBlockSize;\n+\n+      if (offset != 0) {\n+        // There is some room in the last block.\n+        avail = kBlockSize - offset;\n+      } else {\n+        // No room in the last block; push new one.\n+        blocks_.push_back(new char[kBlockSize]);\n+        avail = kBlockSize;\n+      }\n+\n+      if (avail > src_len) {\n+        avail = src_len;\n+      }\n+      memcpy(blocks_.back() + offset, src, avail);\n+      src_len -= avail;\n+      src += avail;\n+      size_ += avail;\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+ private:\n+  // Private since only Unref() should be used to delete it.\n+  ~FileState() {\n+    for (std::vector<char*>::iterator i = blocks_.begin(); i != blocks_.end();\n+         ++i) {\n+      delete [] *i;\n+    }\n+  }\n+\n+  // No copying allowed.\n+  FileState(const FileState&);\n+  void operator=(const FileState&);\n+\n+  port::Mutex refs_mutex_;\n+  int refs_;  // Protected by refs_mutex_;\n+\n+  // The following fields are not protected by any mutex. They are only mutable\n+  // while the file is being written, and concurrent access is not allowed\n+  // to writable files.\n+  std::vector<char*> blocks_;\n+  uint64_t size_;\n+\n+  enum { kBlockSize = 8 * 1024 };\n+};\n+\n+class SequentialFileImpl : public SequentialFile {\n+ public:\n+  explicit SequentialFileImpl(FileState* file) : file_(file), pos_(0) {\n+    file_->Ref();\n+  }\n+\n+  ~SequentialFileImpl() {\n+    file_->Unref();\n+  }\n+\n+  virtual Status Read(size_t n, Slice* result, char* scratch) {\n+    Status s = file_->Read(pos_, n, result, scratch);\n+    if (s.ok()) {\n+      pos_ += result->size();\n+    }\n+    return s;\n+  }\n+\n+  virtual Status Skip(uint64_t n) {\n+    if (pos_ > file_->Size()) {\n+      return Status::IOError(\"pos_ > file_->Size()\");\n+    }\n+    const size_t available = file_->Size() - pos_;\n+    if (n > available) {\n+      n = available;\n+    }\n+    pos_ += n;\n+    return Status::OK();\n+  }\n+\n+ private:\n+  FileState* file_;\n+  size_t pos_;\n+};\n+\n+class RandomAccessFileImpl : public RandomAccessFile {\n+ public:\n+  explicit RandomAccessFileImpl(FileState* file) : file_(file) {\n+    file_->Ref();\n+  }\n+\n+  ~RandomAccessFileImpl() {\n+    file_->Unref();\n+  }\n+\n+  virtual Status Read(uint64_t offset, size_t n, Slice* result,\n+                      char* scratch) const {\n+    return file_->Read(offset, n, result, scratch);\n+  }\n+\n+ private:\n+  FileState* file_;\n+};\n+\n+class WritableFileImpl : public WritableFile {\n+ public:\n+  WritableFileImpl(FileState* file) : file_(file) {\n+    file_->Ref();\n+  }\n+\n+  ~WritableFileImpl() {\n+    file_->Unref();\n+  }\n+\n+  virtual Status Append(const Slice& data) {\n+    return file_->Append(data);\n+  }\n+\n+  virtual Status Close() { return Status::OK(); }\n+  virtual Status Flush() { return Status::OK(); }\n+  virtual Status Sync() { return Status::OK(); }\n+\n+ private:\n+  FileState* file_;\n+};\n+\n+class InMemoryEnv : public EnvWrapper {\n+ public:\n+  explicit InMemoryEnv(Env* base_env) : EnvWrapper(base_env) { }\n+\n+  virtual ~InMemoryEnv() {\n+    for (FileSystem::iterator i = file_map_.begin(); i != file_map_.end(); ++i){\n+      i->second->Unref();\n+    }\n+  }\n+\n+  // Partial implementation of the Env interface.\n+  virtual Status NewSequentialFile(const std::string& fname,\n+                                   SequentialFile** result) {\n+    MutexLock lock(&mutex_);\n+    if (file_map_.find(fname) == file_map_.end()) {\n+      *result = NULL;\n+      return Status::IOError(fname, \"File not found\");\n+    }\n+\n+    *result = new SequentialFileImpl(file_map_[fname]);\n+    return Status::OK();\n+  }\n+\n+  virtual Status NewRandomAccessFile(const std::string& fname,\n+                                     RandomAccessFile** result) {\n+    MutexLock lock(&mutex_);\n+    if (file_map_.find(fname) == file_map_.end()) {\n+      *result = NULL;\n+      return Status::IOError(fname, \"File not found\");\n+    }\n+\n+    *result = new RandomAccessFileImpl(file_map_[fname]);\n+    return Status::OK();\n+  }\n+\n+  virtual Status NewWritableFile(const std::string& fname,\n+                                 WritableFile** result) {\n+    MutexLock lock(&mutex_);\n+    if (file_map_.find(fname) != file_map_.end()) {\n+      DeleteFileInternal(fname);\n+    }\n+\n+    FileState* file = new FileState();\n+    file->Ref();\n+    file_map_[fname] = file;\n+\n+    *result = new WritableFileImpl(file);\n+    return Status::OK();\n+  }\n+\n+  virtual bool FileExists(const std::string& fname) {\n+    MutexLock lock(&mutex_);\n+    return file_map_.find(fname) != file_map_.end();\n+  }\n+\n+  virtual Status GetChildren(const std::string& dir,\n+                             std::vector<std::string>* result) {\n+    MutexLock lock(&mutex_);\n+    result->clear();\n+\n+    for (FileSystem::iterator i = file_map_.begin(); i != file_map_.end(); ++i){\n+      const std::string& filename = i->first;\n+\n+      if (filename.size() >= dir.size() + 1 && filename[dir.size()] == '/' &&\n+          Slice(filename).starts_with(Slice(dir))) {\n+        result->push_back(filename.substr(dir.size() + 1));\n+      }\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  void DeleteFileInternal(const std::string& fname) {\n+    if (file_map_.find(fname) == file_map_.end()) {\n+      return;\n+    }\n+\n+    file_map_[fname]->Unref();\n+    file_map_.erase(fname);\n+  }\n+\n+  virtual Status DeleteFile(const std::string& fname) {\n+    MutexLock lock(&mutex_);\n+    if (file_map_.find(fname) == file_map_.end()) {\n+      return Status::IOError(fname, \"File not found\");\n+    }\n+\n+    DeleteFileInternal(fname);\n+    return Status::OK();\n+  }\n+\n+  virtual Status CreateDir(const std::string& dirname) {\n+    return Status::OK();\n+  }\n+\n+  virtual Status DeleteDir(const std::string& dirname) {\n+    return Status::OK();\n+  }\n+\n+  virtual Status GetFileSize(const std::string& fname, uint64_t* file_size) {\n+    MutexLock lock(&mutex_);\n+    if (file_map_.find(fname) == file_map_.end()) {\n+      return Status::IOError(fname, \"File not found\");\n+    }\n+\n+    *file_size = file_map_[fname]->Size();\n+    return Status::OK();\n+  }\n+\n+  virtual Status RenameFile(const std::string& src,\n+                            const std::string& target) {\n+    MutexLock lock(&mutex_);\n+    if (file_map_.find(src) == file_map_.end()) {\n+      return Status::IOError(src, \"File not found\");\n+    }\n+\n+    DeleteFileInternal(target);\n+    file_map_[target] = file_map_[src];\n+    file_map_.erase(src);\n+    return Status::OK();\n+  }\n+\n+  virtual Status LockFile(const std::string& fname, FileLock** lock) {\n+    *lock = new FileLock;\n+    return Status::OK();\n+  }\n+\n+  virtual Status UnlockFile(FileLock* lock) {\n+    delete lock;\n+    return Status::OK();\n+  }\n+\n+  virtual Status GetTestDirectory(std::string* path) {\n+    *path = \"/test\";\n+    return Status::OK();\n+  }\n+\n+ private:\n+  // Map from filenames to FileState objects, representing a simple file system.\n+  typedef std::map<std::string, FileState*> FileSystem;\n+  port::Mutex mutex_;\n+  FileSystem file_map_;  // Protected by mutex_.\n+};\n+\n+}  // namespace\n+\n+Env* NewMemEnv(Env* base_env) {\n+  return new InMemoryEnv(base_env);\n+}\n+\n+}  // namespace leveldb"
      },
      {
        "sha": "03b88de761dc732e09dec54baddd34e94ee17613",
        "filename": "src/leveldb/helpers/memenv/memenv.h",
        "status": "added",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/helpers/memenv/memenv.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/helpers/memenv/memenv.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/helpers/memenv/memenv.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,20 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#ifndef STORAGE_LEVELDB_HELPERS_MEMENV_MEMENV_H_\n+#define STORAGE_LEVELDB_HELPERS_MEMENV_MEMENV_H_\n+\n+namespace leveldb {\n+\n+class Env;\n+\n+// Returns a new environment that stores its data in memory and delegates\n+// all non-file-storage tasks to base_env. The caller must delete the result\n+// when it is no longer needed.\n+// *base_env must remain live while the result is in use.\n+Env* NewMemEnv(Env* base_env);\n+\n+}  // namespace leveldb\n+\n+#endif  // STORAGE_LEVELDB_HELPERS_MEMENV_MEMENV_H_"
      },
      {
        "sha": "a44310fed80cd7f210d64b2c8e79ceb74284217a",
        "filename": "src/leveldb/helpers/memenv/memenv_test.cc",
        "status": "added",
        "additions": 232,
        "deletions": 0,
        "changes": 232,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/helpers/memenv/memenv_test.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/helpers/memenv/memenv_test.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/helpers/memenv/memenv_test.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,232 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include \"helpers/memenv/memenv.h\"\n+\n+#include \"db/db_impl.h\"\n+#include \"leveldb/db.h\"\n+#include \"leveldb/env.h\"\n+#include \"util/testharness.h\"\n+#include <string>\n+#include <vector>\n+\n+namespace leveldb {\n+\n+class MemEnvTest {\n+ public:\n+  Env* env_;\n+\n+  MemEnvTest()\n+      : env_(NewMemEnv(Env::Default())) {\n+  }\n+  ~MemEnvTest() {\n+    delete env_;\n+  }\n+};\n+\n+TEST(MemEnvTest, Basics) {\n+  uint64_t file_size;\n+  WritableFile* writable_file;\n+  std::vector<std::string> children;\n+\n+  ASSERT_OK(env_->CreateDir(\"/dir\"));\n+\n+  // Check that the directory is empty.\n+  ASSERT_TRUE(!env_->FileExists(\"/dir/non_existent\"));\n+  ASSERT_TRUE(!env_->GetFileSize(\"/dir/non_existent\", &file_size).ok());\n+  ASSERT_OK(env_->GetChildren(\"/dir\", &children));\n+  ASSERT_EQ(0, children.size());\n+\n+  // Create a file.\n+  ASSERT_OK(env_->NewWritableFile(\"/dir/f\", &writable_file));\n+  delete writable_file;\n+\n+  // Check that the file exists.\n+  ASSERT_TRUE(env_->FileExists(\"/dir/f\"));\n+  ASSERT_OK(env_->GetFileSize(\"/dir/f\", &file_size));\n+  ASSERT_EQ(0, file_size);\n+  ASSERT_OK(env_->GetChildren(\"/dir\", &children));\n+  ASSERT_EQ(1, children.size());\n+  ASSERT_EQ(\"f\", children[0]);\n+\n+  // Write to the file.\n+  ASSERT_OK(env_->NewWritableFile(\"/dir/f\", &writable_file));\n+  ASSERT_OK(writable_file->Append(\"abc\"));\n+  delete writable_file;\n+\n+  // Check for expected size.\n+  ASSERT_OK(env_->GetFileSize(\"/dir/f\", &file_size));\n+  ASSERT_EQ(3, file_size);\n+\n+  // Check that renaming works.\n+  ASSERT_TRUE(!env_->RenameFile(\"/dir/non_existent\", \"/dir/g\").ok());\n+  ASSERT_OK(env_->RenameFile(\"/dir/f\", \"/dir/g\"));\n+  ASSERT_TRUE(!env_->FileExists(\"/dir/f\"));\n+  ASSERT_TRUE(env_->FileExists(\"/dir/g\"));\n+  ASSERT_OK(env_->GetFileSize(\"/dir/g\", &file_size));\n+  ASSERT_EQ(3, file_size);\n+\n+  // Check that opening non-existent file fails.\n+  SequentialFile* seq_file;\n+  RandomAccessFile* rand_file;\n+  ASSERT_TRUE(!env_->NewSequentialFile(\"/dir/non_existent\", &seq_file).ok());\n+  ASSERT_TRUE(!seq_file);\n+  ASSERT_TRUE(!env_->NewRandomAccessFile(\"/dir/non_existent\", &rand_file).ok());\n+  ASSERT_TRUE(!rand_file);\n+\n+  // Check that deleting works.\n+  ASSERT_TRUE(!env_->DeleteFile(\"/dir/non_existent\").ok());\n+  ASSERT_OK(env_->DeleteFile(\"/dir/g\"));\n+  ASSERT_TRUE(!env_->FileExists(\"/dir/g\"));\n+  ASSERT_OK(env_->GetChildren(\"/dir\", &children));\n+  ASSERT_EQ(0, children.size());\n+  ASSERT_OK(env_->DeleteDir(\"/dir\"));\n+}\n+\n+TEST(MemEnvTest, ReadWrite) {\n+  WritableFile* writable_file;\n+  SequentialFile* seq_file;\n+  RandomAccessFile* rand_file;\n+  Slice result;\n+  char scratch[100];\n+\n+  ASSERT_OK(env_->CreateDir(\"/dir\"));\n+\n+  ASSERT_OK(env_->NewWritableFile(\"/dir/f\", &writable_file));\n+  ASSERT_OK(writable_file->Append(\"hello \"));\n+  ASSERT_OK(writable_file->Append(\"world\"));\n+  delete writable_file;\n+\n+  // Read sequentially.\n+  ASSERT_OK(env_->NewSequentialFile(\"/dir/f\", &seq_file));\n+  ASSERT_OK(seq_file->Read(5, &result, scratch)); // Read \"hello\".\n+  ASSERT_EQ(0, result.compare(\"hello\"));\n+  ASSERT_OK(seq_file->Skip(1));\n+  ASSERT_OK(seq_file->Read(1000, &result, scratch)); // Read \"world\".\n+  ASSERT_EQ(0, result.compare(\"world\"));\n+  ASSERT_OK(seq_file->Read(1000, &result, scratch)); // Try reading past EOF.\n+  ASSERT_EQ(0, result.size());\n+  ASSERT_OK(seq_file->Skip(100)); // Try to skip past end of file.\n+  ASSERT_OK(seq_file->Read(1000, &result, scratch));\n+  ASSERT_EQ(0, result.size());\n+  delete seq_file;\n+\n+  // Random reads.\n+  ASSERT_OK(env_->NewRandomAccessFile(\"/dir/f\", &rand_file));\n+  ASSERT_OK(rand_file->Read(6, 5, &result, scratch)); // Read \"world\".\n+  ASSERT_EQ(0, result.compare(\"world\"));\n+  ASSERT_OK(rand_file->Read(0, 5, &result, scratch)); // Read \"hello\".\n+  ASSERT_EQ(0, result.compare(\"hello\"));\n+  ASSERT_OK(rand_file->Read(10, 100, &result, scratch)); // Read \"d\".\n+  ASSERT_EQ(0, result.compare(\"d\"));\n+\n+  // Too high offset.\n+  ASSERT_TRUE(!rand_file->Read(1000, 5, &result, scratch).ok());\n+  delete rand_file;\n+}\n+\n+TEST(MemEnvTest, Locks) {\n+  FileLock* lock;\n+\n+  // These are no-ops, but we test they return success.\n+  ASSERT_OK(env_->LockFile(\"some file\", &lock));\n+  ASSERT_OK(env_->UnlockFile(lock));\n+}\n+\n+TEST(MemEnvTest, Misc) {\n+  std::string test_dir;\n+  ASSERT_OK(env_->GetTestDirectory(&test_dir));\n+  ASSERT_TRUE(!test_dir.empty());\n+\n+  WritableFile* writable_file;\n+  ASSERT_OK(env_->NewWritableFile(\"/a/b\", &writable_file));\n+\n+  // These are no-ops, but we test they return success.\n+  ASSERT_OK(writable_file->Sync());\n+  ASSERT_OK(writable_file->Flush());\n+  ASSERT_OK(writable_file->Close());\n+  delete writable_file;\n+}\n+\n+TEST(MemEnvTest, LargeWrite) {\n+  const size_t kWriteSize = 300 * 1024;\n+  char* scratch = new char[kWriteSize * 2];\n+\n+  std::string write_data;\n+  for (size_t i = 0; i < kWriteSize; ++i) {\n+    write_data.append(1, static_cast<char>(i));\n+  }\n+\n+  WritableFile* writable_file;\n+  ASSERT_OK(env_->NewWritableFile(\"/dir/f\", &writable_file));\n+  ASSERT_OK(writable_file->Append(\"foo\"));\n+  ASSERT_OK(writable_file->Append(write_data));\n+  delete writable_file;\n+\n+  SequentialFile* seq_file;\n+  Slice result;\n+  ASSERT_OK(env_->NewSequentialFile(\"/dir/f\", &seq_file));\n+  ASSERT_OK(seq_file->Read(3, &result, scratch)); // Read \"foo\".\n+  ASSERT_EQ(0, result.compare(\"foo\"));\n+\n+  size_t read = 0;\n+  std::string read_data;\n+  while (read < kWriteSize) {\n+    ASSERT_OK(seq_file->Read(kWriteSize - read, &result, scratch));\n+    read_data.append(result.data(), result.size());\n+    read += result.size();\n+  }\n+  ASSERT_TRUE(write_data == read_data);\n+  delete seq_file;\n+  delete [] scratch;\n+}\n+\n+TEST(MemEnvTest, DBTest) {\n+  Options options;\n+  options.create_if_missing = true;\n+  options.env = env_;\n+  DB* db;\n+\n+  const Slice keys[] = {Slice(\"aaa\"), Slice(\"bbb\"), Slice(\"ccc\")};\n+  const Slice vals[] = {Slice(\"foo\"), Slice(\"bar\"), Slice(\"baz\")};\n+\n+  ASSERT_OK(DB::Open(options, \"/dir/db\", &db));\n+  for (size_t i = 0; i < 3; ++i) {\n+    ASSERT_OK(db->Put(WriteOptions(), keys[i], vals[i]));\n+  }\n+\n+  for (size_t i = 0; i < 3; ++i) {\n+    std::string res;\n+    ASSERT_OK(db->Get(ReadOptions(), keys[i], &res));\n+    ASSERT_TRUE(res == vals[i]);\n+  }\n+\n+  Iterator* iterator = db->NewIterator(ReadOptions());\n+  iterator->SeekToFirst();\n+  for (size_t i = 0; i < 3; ++i) {\n+    ASSERT_TRUE(iterator->Valid());\n+    ASSERT_TRUE(keys[i] == iterator->key());\n+    ASSERT_TRUE(vals[i] == iterator->value());\n+    iterator->Next();\n+  }\n+  ASSERT_TRUE(!iterator->Valid());\n+  delete iterator;\n+\n+  DBImpl* dbi = reinterpret_cast<DBImpl*>(db);\n+  ASSERT_OK(dbi->TEST_CompactMemTable());\n+\n+  for (size_t i = 0; i < 3; ++i) {\n+    std::string res;\n+    ASSERT_OK(db->Get(ReadOptions(), keys[i], &res));\n+    ASSERT_TRUE(res == vals[i]);\n+  }\n+\n+  delete db;\n+}\n+\n+}  // namespace leveldb\n+\n+int main(int argc, char** argv) {\n+  return leveldb::test::RunAllTests();\n+}"
      },
      {
        "sha": "70e3cc65284b49084bd30cc035774e3ced562ba9",
        "filename": "src/leveldb/include/leveldb/c.h",
        "status": "added",
        "additions": 275,
        "deletions": 0,
        "changes": 275,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/include/leveldb/c.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/include/leveldb/c.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/include/leveldb/c.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,275 @@\n+/* Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+  Use of this source code is governed by a BSD-style license that can be\n+  found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+  C bindings for leveldb.  May be useful as a stable ABI that can be\n+  used by programs that keep leveldb in a shared library, or for\n+  a JNI api.\n+\n+  Does not support:\n+  . getters for the option types\n+  . custom comparators that implement key shortening\n+  . capturing post-write-snapshot\n+  . custom iter, db, env, cache implementations using just the C bindings\n+\n+  Some conventions:\n+\n+  (1) We expose just opaque struct pointers and functions to clients.\n+  This allows us to change internal representations without having to\n+  recompile clients.\n+\n+  (2) For simplicity, there is no equivalent to the Slice type.  Instead,\n+  the caller has to pass the pointer and length as separate\n+  arguments.\n+\n+  (3) Errors are represented by a null-terminated c string.  NULL\n+  means no error.  All operations that can raise an error are passed\n+  a \"char** errptr\" as the last argument.  One of the following must\n+  be true on entry:\n+     *errptr == NULL\n+     *errptr points to a malloc()ed null-terminated error message\n+  On success, a leveldb routine leaves *errptr unchanged.\n+  On failure, leveldb frees the old value of *errptr and\n+  set *errptr to a malloc()ed error message.\n+\n+  (4) Bools have the type unsigned char (0 == false; rest == true)\n+\n+  (5) All of the pointer arguments must be non-NULL.\n+*/\n+\n+#ifndef STORAGE_LEVELDB_INCLUDE_C_H_\n+#define STORAGE_LEVELDB_INCLUDE_C_H_\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stdarg.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+/* Exported types */\n+\n+typedef struct leveldb_t               leveldb_t;\n+typedef struct leveldb_cache_t         leveldb_cache_t;\n+typedef struct leveldb_comparator_t    leveldb_comparator_t;\n+typedef struct leveldb_env_t           leveldb_env_t;\n+typedef struct leveldb_filelock_t      leveldb_filelock_t;\n+typedef struct leveldb_filterpolicy_t  leveldb_filterpolicy_t;\n+typedef struct leveldb_iterator_t      leveldb_iterator_t;\n+typedef struct leveldb_logger_t        leveldb_logger_t;\n+typedef struct leveldb_options_t       leveldb_options_t;\n+typedef struct leveldb_randomfile_t    leveldb_randomfile_t;\n+typedef struct leveldb_readoptions_t   leveldb_readoptions_t;\n+typedef struct leveldb_seqfile_t       leveldb_seqfile_t;\n+typedef struct leveldb_snapshot_t      leveldb_snapshot_t;\n+typedef struct leveldb_writablefile_t  leveldb_writablefile_t;\n+typedef struct leveldb_writebatch_t    leveldb_writebatch_t;\n+typedef struct leveldb_writeoptions_t  leveldb_writeoptions_t;\n+\n+/* DB operations */\n+\n+extern leveldb_t* leveldb_open(\n+    const leveldb_options_t* options,\n+    const char* name,\n+    char** errptr);\n+\n+extern void leveldb_close(leveldb_t* db);\n+\n+extern void leveldb_put(\n+    leveldb_t* db,\n+    const leveldb_writeoptions_t* options,\n+    const char* key, size_t keylen,\n+    const char* val, size_t vallen,\n+    char** errptr);\n+\n+extern void leveldb_delete(\n+    leveldb_t* db,\n+    const leveldb_writeoptions_t* options,\n+    const char* key, size_t keylen,\n+    char** errptr);\n+\n+extern void leveldb_write(\n+    leveldb_t* db,\n+    const leveldb_writeoptions_t* options,\n+    leveldb_writebatch_t* batch,\n+    char** errptr);\n+\n+/* Returns NULL if not found.  A malloc()ed array otherwise.\n+   Stores the length of the array in *vallen. */\n+extern char* leveldb_get(\n+    leveldb_t* db,\n+    const leveldb_readoptions_t* options,\n+    const char* key, size_t keylen,\n+    size_t* vallen,\n+    char** errptr);\n+\n+extern leveldb_iterator_t* leveldb_create_iterator(\n+    leveldb_t* db,\n+    const leveldb_readoptions_t* options);\n+\n+extern const leveldb_snapshot_t* leveldb_create_snapshot(\n+    leveldb_t* db);\n+\n+extern void leveldb_release_snapshot(\n+    leveldb_t* db,\n+    const leveldb_snapshot_t* snapshot);\n+\n+/* Returns NULL if property name is unknown.\n+   Else returns a pointer to a malloc()-ed null-terminated value. */\n+extern char* leveldb_property_value(\n+    leveldb_t* db,\n+    const char* propname);\n+\n+extern void leveldb_approximate_sizes(\n+    leveldb_t* db,\n+    int num_ranges,\n+    const char* const* range_start_key, const size_t* range_start_key_len,\n+    const char* const* range_limit_key, const size_t* range_limit_key_len,\n+    uint64_t* sizes);\n+\n+extern void leveldb_compact_range(\n+    leveldb_t* db,\n+    const char* start_key, size_t start_key_len,\n+    const char* limit_key, size_t limit_key_len);\n+\n+/* Management operations */\n+\n+extern void leveldb_destroy_db(\n+    const leveldb_options_t* options,\n+    const char* name,\n+    char** errptr);\n+\n+extern void leveldb_repair_db(\n+    const leveldb_options_t* options,\n+    const char* name,\n+    char** errptr);\n+\n+/* Iterator */\n+\n+extern void leveldb_iter_destroy(leveldb_iterator_t*);\n+extern unsigned char leveldb_iter_valid(const leveldb_iterator_t*);\n+extern void leveldb_iter_seek_to_first(leveldb_iterator_t*);\n+extern void leveldb_iter_seek_to_last(leveldb_iterator_t*);\n+extern void leveldb_iter_seek(leveldb_iterator_t*, const char* k, size_t klen);\n+extern void leveldb_iter_next(leveldb_iterator_t*);\n+extern void leveldb_iter_prev(leveldb_iterator_t*);\n+extern const char* leveldb_iter_key(const leveldb_iterator_t*, size_t* klen);\n+extern const char* leveldb_iter_value(const leveldb_iterator_t*, size_t* vlen);\n+extern void leveldb_iter_get_error(const leveldb_iterator_t*, char** errptr);\n+\n+/* Write batch */\n+\n+extern leveldb_writebatch_t* leveldb_writebatch_create();\n+extern void leveldb_writebatch_destroy(leveldb_writebatch_t*);\n+extern void leveldb_writebatch_clear(leveldb_writebatch_t*);\n+extern void leveldb_writebatch_put(\n+    leveldb_writebatch_t*,\n+    const char* key, size_t klen,\n+    const char* val, size_t vlen);\n+extern void leveldb_writebatch_delete(\n+    leveldb_writebatch_t*,\n+    const char* key, size_t klen);\n+extern void leveldb_writebatch_iterate(\n+    leveldb_writebatch_t*,\n+    void* state,\n+    void (*put)(void*, const char* k, size_t klen, const char* v, size_t vlen),\n+    void (*deleted)(void*, const char* k, size_t klen));\n+\n+/* Options */\n+\n+extern leveldb_options_t* leveldb_options_create();\n+extern void leveldb_options_destroy(leveldb_options_t*);\n+extern void leveldb_options_set_comparator(\n+    leveldb_options_t*,\n+    leveldb_comparator_t*);\n+extern void leveldb_options_set_filter_policy(\n+    leveldb_options_t*,\n+    leveldb_filterpolicy_t*);\n+extern void leveldb_options_set_create_if_missing(\n+    leveldb_options_t*, unsigned char);\n+extern void leveldb_options_set_error_if_exists(\n+    leveldb_options_t*, unsigned char);\n+extern void leveldb_options_set_paranoid_checks(\n+    leveldb_options_t*, unsigned char);\n+extern void leveldb_options_set_env(leveldb_options_t*, leveldb_env_t*);\n+extern void leveldb_options_set_info_log(leveldb_options_t*, leveldb_logger_t*);\n+extern void leveldb_options_set_write_buffer_size(leveldb_options_t*, size_t);\n+extern void leveldb_options_set_max_open_files(leveldb_options_t*, int);\n+extern void leveldb_options_set_cache(leveldb_options_t*, leveldb_cache_t*);\n+extern void leveldb_options_set_block_size(leveldb_options_t*, size_t);\n+extern void leveldb_options_set_block_restart_interval(leveldb_options_t*, int);\n+\n+enum {\n+  leveldb_no_compression = 0,\n+  leveldb_snappy_compression = 1\n+};\n+extern void leveldb_options_set_compression(leveldb_options_t*, int);\n+\n+/* Comparator */\n+\n+extern leveldb_comparator_t* leveldb_comparator_create(\n+    void* state,\n+    void (*destructor)(void*),\n+    int (*compare)(\n+        void*,\n+        const char* a, size_t alen,\n+        const char* b, size_t blen),\n+    const char* (*name)(void*));\n+extern void leveldb_comparator_destroy(leveldb_comparator_t*);\n+\n+/* Filter policy */\n+\n+extern leveldb_filterpolicy_t* leveldb_filterpolicy_create(\n+    void* state,\n+    void (*destructor)(void*),\n+    char* (*create_filter)(\n+        void*,\n+        const char* const* key_array, const size_t* key_length_array,\n+        int num_keys,\n+        size_t* filter_length),\n+    unsigned char (*key_may_match)(\n+        void*,\n+        const char* key, size_t length,\n+        const char* filter, size_t filter_length),\n+    const char* (*name)(void*));\n+extern void leveldb_filterpolicy_destroy(leveldb_filterpolicy_t*);\n+\n+extern leveldb_filterpolicy_t* leveldb_filterpolicy_create_bloom(\n+    int bits_per_key);\n+\n+/* Read options */\n+\n+extern leveldb_readoptions_t* leveldb_readoptions_create();\n+extern void leveldb_readoptions_destroy(leveldb_readoptions_t*);\n+extern void leveldb_readoptions_set_verify_checksums(\n+    leveldb_readoptions_t*,\n+    unsigned char);\n+extern void leveldb_readoptions_set_fill_cache(\n+    leveldb_readoptions_t*, unsigned char);\n+extern void leveldb_readoptions_set_snapshot(\n+    leveldb_readoptions_t*,\n+    const leveldb_snapshot_t*);\n+\n+/* Write options */\n+\n+extern leveldb_writeoptions_t* leveldb_writeoptions_create();\n+extern void leveldb_writeoptions_destroy(leveldb_writeoptions_t*);\n+extern void leveldb_writeoptions_set_sync(\n+    leveldb_writeoptions_t*, unsigned char);\n+\n+/* Cache */\n+\n+extern leveldb_cache_t* leveldb_cache_create_lru(size_t capacity);\n+extern void leveldb_cache_destroy(leveldb_cache_t* cache);\n+\n+/* Env */\n+\n+extern leveldb_env_t* leveldb_create_default_env();\n+extern void leveldb_env_destroy(leveldb_env_t*);\n+\n+#ifdef __cplusplus\n+}  /* end extern \"C\" */\n+#endif\n+\n+#endif  /* STORAGE_LEVELDB_INCLUDE_C_H_ */"
      },
      {
        "sha": "5e3b47637d49e9f963b141dc5a011e1272615750",
        "filename": "src/leveldb/include/leveldb/cache.h",
        "status": "added",
        "additions": 99,
        "deletions": 0,
        "changes": 99,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/include/leveldb/cache.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/include/leveldb/cache.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/include/leveldb/cache.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,99 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+//\n+// A Cache is an interface that maps keys to values.  It has internal\n+// synchronization and may be safely accessed concurrently from\n+// multiple threads.  It may automatically evict entries to make room\n+// for new entries.  Values have a specified charge against the cache\n+// capacity.  For example, a cache where the values are variable\n+// length strings, may use the length of the string as the charge for\n+// the string.\n+//\n+// A builtin cache implementation with a least-recently-used eviction\n+// policy is provided.  Clients may use their own implementations if\n+// they want something more sophisticated (like scan-resistance, a\n+// custom eviction policy, variable cache sizing, etc.)\n+\n+#ifndef STORAGE_LEVELDB_INCLUDE_CACHE_H_\n+#define STORAGE_LEVELDB_INCLUDE_CACHE_H_\n+\n+#include <stdint.h>\n+#include \"leveldb/slice.h\"\n+\n+namespace leveldb {\n+\n+class Cache;\n+\n+// Create a new cache with a fixed size capacity.  This implementation\n+// of Cache uses a least-recently-used eviction policy.\n+extern Cache* NewLRUCache(size_t capacity);\n+\n+class Cache {\n+ public:\n+  Cache() { }\n+\n+  // Destroys all existing entries by calling the \"deleter\"\n+  // function that was passed to the constructor.\n+  virtual ~Cache();\n+\n+  // Opaque handle to an entry stored in the cache.\n+  struct Handle { };\n+\n+  // Insert a mapping from key->value into the cache and assign it\n+  // the specified charge against the total cache capacity.\n+  //\n+  // Returns a handle that corresponds to the mapping.  The caller\n+  // must call this->Release(handle) when the returned mapping is no\n+  // longer needed.\n+  //\n+  // When the inserted entry is no longer needed, the key and\n+  // value will be passed to \"deleter\".\n+  virtual Handle* Insert(const Slice& key, void* value, size_t charge,\n+                         void (*deleter)(const Slice& key, void* value)) = 0;\n+\n+  // If the cache has no mapping for \"key\", returns NULL.\n+  //\n+  // Else return a handle that corresponds to the mapping.  The caller\n+  // must call this->Release(handle) when the returned mapping is no\n+  // longer needed.\n+  virtual Handle* Lookup(const Slice& key) = 0;\n+\n+  // Release a mapping returned by a previous Lookup().\n+  // REQUIRES: handle must not have been released yet.\n+  // REQUIRES: handle must have been returned by a method on *this.\n+  virtual void Release(Handle* handle) = 0;\n+\n+  // Return the value encapsulated in a handle returned by a\n+  // successful Lookup().\n+  // REQUIRES: handle must not have been released yet.\n+  // REQUIRES: handle must have been returned by a method on *this.\n+  virtual void* Value(Handle* handle) = 0;\n+\n+  // If the cache contains entry for key, erase it.  Note that the\n+  // underlying entry will be kept around until all existing handles\n+  // to it have been released.\n+  virtual void Erase(const Slice& key) = 0;\n+\n+  // Return a new numeric id.  May be used by multiple clients who are\n+  // sharing the same cache to partition the key space.  Typically the\n+  // client will allocate a new id at startup and prepend the id to\n+  // its cache keys.\n+  virtual uint64_t NewId() = 0;\n+\n+ private:\n+  void LRU_Remove(Handle* e);\n+  void LRU_Append(Handle* e);\n+  void Unref(Handle* e);\n+\n+  struct Rep;\n+  Rep* rep_;\n+\n+  // No copying allowed\n+  Cache(const Cache&);\n+  void operator=(const Cache&);\n+};\n+\n+}  // namespace leveldb\n+\n+#endif  // STORAGE_LEVELDB_UTIL_CACHE_H_"
      },
      {
        "sha": "556b984c7694f6520088754f3017bf58c7cafc9d",
        "filename": "src/leveldb/include/leveldb/comparator.h",
        "status": "added",
        "additions": 63,
        "deletions": 0,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/include/leveldb/comparator.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/include/leveldb/comparator.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/include/leveldb/comparator.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,63 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#ifndef STORAGE_LEVELDB_INCLUDE_COMPARATOR_H_\n+#define STORAGE_LEVELDB_INCLUDE_COMPARATOR_H_\n+\n+#include <string>\n+\n+namespace leveldb {\n+\n+class Slice;\n+\n+// A Comparator object provides a total order across slices that are\n+// used as keys in an sstable or a database.  A Comparator implementation\n+// must be thread-safe since leveldb may invoke its methods concurrently\n+// from multiple threads.\n+class Comparator {\n+ public:\n+  virtual ~Comparator();\n+\n+  // Three-way comparison.  Returns value:\n+  //   < 0 iff \"a\" < \"b\",\n+  //   == 0 iff \"a\" == \"b\",\n+  //   > 0 iff \"a\" > \"b\"\n+  virtual int Compare(const Slice& a, const Slice& b) const = 0;\n+\n+  // The name of the comparator.  Used to check for comparator\n+  // mismatches (i.e., a DB created with one comparator is\n+  // accessed using a different comparator.\n+  //\n+  // The client of this package should switch to a new name whenever\n+  // the comparator implementation changes in a way that will cause\n+  // the relative ordering of any two keys to change.\n+  //\n+  // Names starting with \"leveldb.\" are reserved and should not be used\n+  // by any clients of this package.\n+  virtual const char* Name() const = 0;\n+\n+  // Advanced functions: these are used to reduce the space requirements\n+  // for internal data structures like index blocks.\n+\n+  // If *start < limit, changes *start to a short string in [start,limit).\n+  // Simple comparator implementations may return with *start unchanged,\n+  // i.e., an implementation of this method that does nothing is correct.\n+  virtual void FindShortestSeparator(\n+      std::string* start,\n+      const Slice& limit) const = 0;\n+\n+  // Changes *key to a short string >= *key.\n+  // Simple comparator implementations may return with *key unchanged,\n+  // i.e., an implementation of this method that does nothing is correct.\n+  virtual void FindShortSuccessor(std::string* key) const = 0;\n+};\n+\n+// Return a builtin comparator that uses lexicographic byte-wise\n+// ordering.  The result remains the property of this module and\n+// must not be deleted.\n+extern const Comparator* BytewiseComparator();\n+\n+}  // namespace leveldb\n+\n+#endif  // STORAGE_LEVELDB_INCLUDE_COMPARATOR_H_"
      },
      {
        "sha": "ed56b87c38afb8d72abe3a58ce49c6250311dcd1",
        "filename": "src/leveldb/include/leveldb/db.h",
        "status": "added",
        "additions": 161,
        "deletions": 0,
        "changes": 161,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/include/leveldb/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/include/leveldb/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/include/leveldb/db.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,161 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#ifndef STORAGE_LEVELDB_INCLUDE_DB_H_\n+#define STORAGE_LEVELDB_INCLUDE_DB_H_\n+\n+#include <stdint.h>\n+#include <stdio.h>\n+#include \"leveldb/iterator.h\"\n+#include \"leveldb/options.h\"\n+\n+namespace leveldb {\n+\n+// Update Makefile if you change these\n+static const int kMajorVersion = 1;\n+static const int kMinorVersion = 5;\n+\n+struct Options;\n+struct ReadOptions;\n+struct WriteOptions;\n+class WriteBatch;\n+\n+// Abstract handle to particular state of a DB.\n+// A Snapshot is an immutable object and can therefore be safely\n+// accessed from multiple threads without any external synchronization.\n+class Snapshot {\n+ protected:\n+  virtual ~Snapshot();\n+};\n+\n+// A range of keys\n+struct Range {\n+  Slice start;          // Included in the range\n+  Slice limit;          // Not included in the range\n+\n+  Range() { }\n+  Range(const Slice& s, const Slice& l) : start(s), limit(l) { }\n+};\n+\n+// A DB is a persistent ordered map from keys to values.\n+// A DB is safe for concurrent access from multiple threads without\n+// any external synchronization.\n+class DB {\n+ public:\n+  // Open the database with the specified \"name\".\n+  // Stores a pointer to a heap-allocated database in *dbptr and returns\n+  // OK on success.\n+  // Stores NULL in *dbptr and returns a non-OK status on error.\n+  // Caller should delete *dbptr when it is no longer needed.\n+  static Status Open(const Options& options,\n+                     const std::string& name,\n+                     DB** dbptr);\n+\n+  DB() { }\n+  virtual ~DB();\n+\n+  // Set the database entry for \"key\" to \"value\".  Returns OK on success,\n+  // and a non-OK status on error.\n+  // Note: consider setting options.sync = true.\n+  virtual Status Put(const WriteOptions& options,\n+                     const Slice& key,\n+                     const Slice& value) = 0;\n+\n+  // Remove the database entry (if any) for \"key\".  Returns OK on\n+  // success, and a non-OK status on error.  It is not an error if \"key\"\n+  // did not exist in the database.\n+  // Note: consider setting options.sync = true.\n+  virtual Status Delete(const WriteOptions& options, const Slice& key) = 0;\n+\n+  // Apply the specified updates to the database.\n+  // Returns OK on success, non-OK on failure.\n+  // Note: consider setting options.sync = true.\n+  virtual Status Write(const WriteOptions& options, WriteBatch* updates) = 0;\n+\n+  // If the database contains an entry for \"key\" store the\n+  // corresponding value in *value and return OK.\n+  //\n+  // If there is no entry for \"key\" leave *value unchanged and return\n+  // a status for which Status::IsNotFound() returns true.\n+  //\n+  // May return some other Status on an error.\n+  virtual Status Get(const ReadOptions& options,\n+                     const Slice& key, std::string* value) = 0;\n+\n+  // Return a heap-allocated iterator over the contents of the database.\n+  // The result of NewIterator() is initially invalid (caller must\n+  // call one of the Seek methods on the iterator before using it).\n+  //\n+  // Caller should delete the iterator when it is no longer needed.\n+  // The returned iterator should be deleted before this db is deleted.\n+  virtual Iterator* NewIterator(const ReadOptions& options) = 0;\n+\n+  // Return a handle to the current DB state.  Iterators created with\n+  // this handle will all observe a stable snapshot of the current DB\n+  // state.  The caller must call ReleaseSnapshot(result) when the\n+  // snapshot is no longer needed.\n+  virtual const Snapshot* GetSnapshot() = 0;\n+\n+  // Release a previously acquired snapshot.  The caller must not\n+  // use \"snapshot\" after this call.\n+  virtual void ReleaseSnapshot(const Snapshot* snapshot) = 0;\n+\n+  // DB implementations can export properties about their state\n+  // via this method.  If \"property\" is a valid property understood by this\n+  // DB implementation, fills \"*value\" with its current value and returns\n+  // true.  Otherwise returns false.\n+  //\n+  //\n+  // Valid property names include:\n+  //\n+  //  \"leveldb.num-files-at-level<N>\" - return the number of files at level <N>,\n+  //     where <N> is an ASCII representation of a level number (e.g. \"0\").\n+  //  \"leveldb.stats\" - returns a multi-line string that describes statistics\n+  //     about the internal operation of the DB.\n+  //  \"leveldb.sstables\" - returns a multi-line string that describes all\n+  //     of the sstables that make up the db contents.\n+  virtual bool GetProperty(const Slice& property, std::string* value) = 0;\n+\n+  // For each i in [0,n-1], store in \"sizes[i]\", the approximate\n+  // file system space used by keys in \"[range[i].start .. range[i].limit)\".\n+  //\n+  // Note that the returned sizes measure file system space usage, so\n+  // if the user data compresses by a factor of ten, the returned\n+  // sizes will be one-tenth the size of the corresponding user data size.\n+  //\n+  // The results may not include the sizes of recently written data.\n+  virtual void GetApproximateSizes(const Range* range, int n,\n+                                   uint64_t* sizes) = 0;\n+\n+  // Compact the underlying storage for the key range [*begin,*end].\n+  // In particular, deleted and overwritten versions are discarded,\n+  // and the data is rearranged to reduce the cost of operations\n+  // needed to access the data.  This operation should typically only\n+  // be invoked by users who understand the underlying implementation.\n+  //\n+  // begin==NULL is treated as a key before all keys in the database.\n+  // end==NULL is treated as a key after all keys in the database.\n+  // Therefore the following call will compact the entire database:\n+  //    db->CompactRange(NULL, NULL);\n+  virtual void CompactRange(const Slice* begin, const Slice* end) = 0;\n+\n+ private:\n+  // No copying allowed\n+  DB(const DB&);\n+  void operator=(const DB&);\n+};\n+\n+// Destroy the contents of the specified database.\n+// Be very careful using this method.\n+Status DestroyDB(const std::string& name, const Options& options);\n+\n+// If a DB cannot be opened, you may attempt to call this method to\n+// resurrect as much of the contents of the database as possible.\n+// Some data may be lost, so be careful when calling this function\n+// on a database that contains important information.\n+Status RepairDB(const std::string& dbname, const Options& options);\n+\n+}  // namespace leveldb\n+\n+#endif  // STORAGE_LEVELDB_INCLUDE_DB_H_"
      },
      {
        "sha": "27206671853a78a2621fb0ff3e310a631023f6ec",
        "filename": "src/leveldb/include/leveldb/env.h",
        "status": "added",
        "additions": 323,
        "deletions": 0,
        "changes": 323,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/include/leveldb/env.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/include/leveldb/env.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/include/leveldb/env.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,323 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+//\n+// An Env is an interface used by the leveldb implementation to access\n+// operating system functionality like the filesystem etc.  Callers\n+// may wish to provide a custom Env object when opening a database to\n+// get fine gain control; e.g., to rate limit file system operations.\n+//\n+// All Env implementations are safe for concurrent access from\n+// multiple threads without any external synchronization.\n+\n+#ifndef STORAGE_LEVELDB_INCLUDE_ENV_H_\n+#define STORAGE_LEVELDB_INCLUDE_ENV_H_\n+\n+#include <cstdarg>\n+#include <string>\n+#include <vector>\n+#include <stdint.h>\n+#include \"leveldb/status.h\"\n+\n+namespace leveldb {\n+\n+class FileLock;\n+class Logger;\n+class RandomAccessFile;\n+class SequentialFile;\n+class Slice;\n+class WritableFile;\n+\n+class Env {\n+ public:\n+  Env() { }\n+  virtual ~Env();\n+\n+  // Return a default environment suitable for the current operating\n+  // system.  Sophisticated users may wish to provide their own Env\n+  // implementation instead of relying on this default environment.\n+  //\n+  // The result of Default() belongs to leveldb and must never be deleted.\n+  static Env* Default();\n+\n+  // Create a brand new sequentially-readable file with the specified name.\n+  // On success, stores a pointer to the new file in *result and returns OK.\n+  // On failure stores NULL in *result and returns non-OK.  If the file does\n+  // not exist, returns a non-OK status.\n+  //\n+  // The returned file will only be accessed by one thread at a time.\n+  virtual Status NewSequentialFile(const std::string& fname,\n+                                   SequentialFile** result) = 0;\n+\n+  // Create a brand new random access read-only file with the\n+  // specified name.  On success, stores a pointer to the new file in\n+  // *result and returns OK.  On failure stores NULL in *result and\n+  // returns non-OK.  If the file does not exist, returns a non-OK\n+  // status.\n+  //\n+  // The returned file may be concurrently accessed by multiple threads.\n+  virtual Status NewRandomAccessFile(const std::string& fname,\n+                                     RandomAccessFile** result) = 0;\n+\n+  // Create an object that writes to a new file with the specified\n+  // name.  Deletes any existing file with the same name and creates a\n+  // new file.  On success, stores a pointer to the new file in\n+  // *result and returns OK.  On failure stores NULL in *result and\n+  // returns non-OK.\n+  //\n+  // The returned file will only be accessed by one thread at a time.\n+  virtual Status NewWritableFile(const std::string& fname,\n+                                 WritableFile** result) = 0;\n+\n+  // Returns true iff the named file exists.\n+  virtual bool FileExists(const std::string& fname) = 0;\n+\n+  // Store in *result the names of the children of the specified directory.\n+  // The names are relative to \"dir\".\n+  // Original contents of *results are dropped.\n+  virtual Status GetChildren(const std::string& dir,\n+                             std::vector<std::string>* result) = 0;\n+\n+  // Delete the named file.\n+  virtual Status DeleteFile(const std::string& fname) = 0;\n+\n+  // Create the specified directory.\n+  virtual Status CreateDir(const std::string& dirname) = 0;\n+\n+  // Delete the specified directory.\n+  virtual Status DeleteDir(const std::string& dirname) = 0;\n+\n+  // Store the size of fname in *file_size.\n+  virtual Status GetFileSize(const std::string& fname, uint64_t* file_size) = 0;\n+\n+  // Rename file src to target.\n+  virtual Status RenameFile(const std::string& src,\n+                            const std::string& target) = 0;\n+\n+  // Lock the specified file.  Used to prevent concurrent access to\n+  // the same db by multiple processes.  On failure, stores NULL in\n+  // *lock and returns non-OK.\n+  //\n+  // On success, stores a pointer to the object that represents the\n+  // acquired lock in *lock and returns OK.  The caller should call\n+  // UnlockFile(*lock) to release the lock.  If the process exits,\n+  // the lock will be automatically released.\n+  //\n+  // If somebody else already holds the lock, finishes immediately\n+  // with a failure.  I.e., this call does not wait for existing locks\n+  // to go away.\n+  //\n+  // May create the named file if it does not already exist.\n+  virtual Status LockFile(const std::string& fname, FileLock** lock) = 0;\n+\n+  // Release the lock acquired by a previous successful call to LockFile.\n+  // REQUIRES: lock was returned by a successful LockFile() call\n+  // REQUIRES: lock has not already been unlocked.\n+  virtual Status UnlockFile(FileLock* lock) = 0;\n+\n+  // Arrange to run \"(*function)(arg)\" once in a background thread.\n+  //\n+  // \"function\" may run in an unspecified thread.  Multiple functions\n+  // added to the same Env may run concurrently in different threads.\n+  // I.e., the caller may not assume that background work items are\n+  // serialized.\n+  virtual void Schedule(\n+      void (*function)(void* arg),\n+      void* arg) = 0;\n+\n+  // Start a new thread, invoking \"function(arg)\" within the new thread.\n+  // When \"function(arg)\" returns, the thread will be destroyed.\n+  virtual void StartThread(void (*function)(void* arg), void* arg) = 0;\n+\n+  // *path is set to a temporary directory that can be used for testing. It may\n+  // or many not have just been created. The directory may or may not differ\n+  // between runs of the same process, but subsequent calls will return the\n+  // same directory.\n+  virtual Status GetTestDirectory(std::string* path) = 0;\n+\n+  // Create and return a log file for storing informational messages.\n+  virtual Status NewLogger(const std::string& fname, Logger** result) = 0;\n+\n+  // Returns the number of micro-seconds since some fixed point in time. Only\n+  // useful for computing deltas of time.\n+  virtual uint64_t NowMicros() = 0;\n+\n+  // Sleep/delay the thread for the perscribed number of micro-seconds.\n+  virtual void SleepForMicroseconds(int micros) = 0;\n+\n+ private:\n+  // No copying allowed\n+  Env(const Env&);\n+  void operator=(const Env&);\n+};\n+\n+// A file abstraction for reading sequentially through a file\n+class SequentialFile {\n+ public:\n+  SequentialFile() { }\n+  virtual ~SequentialFile();\n+\n+  // Read up to \"n\" bytes from the file.  \"scratch[0..n-1]\" may be\n+  // written by this routine.  Sets \"*result\" to the data that was\n+  // read (including if fewer than \"n\" bytes were successfully read).\n+  // May set \"*result\" to point at data in \"scratch[0..n-1]\", so\n+  // \"scratch[0..n-1]\" must be live when \"*result\" is used.\n+  // If an error was encountered, returns a non-OK status.\n+  //\n+  // REQUIRES: External synchronization\n+  virtual Status Read(size_t n, Slice* result, char* scratch) = 0;\n+\n+  // Skip \"n\" bytes from the file. This is guaranteed to be no\n+  // slower that reading the same data, but may be faster.\n+  //\n+  // If end of file is reached, skipping will stop at the end of the\n+  // file, and Skip will return OK.\n+  //\n+  // REQUIRES: External synchronization\n+  virtual Status Skip(uint64_t n) = 0;\n+};\n+\n+// A file abstraction for randomly reading the contents of a file.\n+class RandomAccessFile {\n+ public:\n+  RandomAccessFile() { }\n+  virtual ~RandomAccessFile();\n+\n+  // Read up to \"n\" bytes from the file starting at \"offset\".\n+  // \"scratch[0..n-1]\" may be written by this routine.  Sets \"*result\"\n+  // to the data that was read (including if fewer than \"n\" bytes were\n+  // successfully read).  May set \"*result\" to point at data in\n+  // \"scratch[0..n-1]\", so \"scratch[0..n-1]\" must be live when\n+  // \"*result\" is used.  If an error was encountered, returns a non-OK\n+  // status.\n+  //\n+  // Safe for concurrent use by multiple threads.\n+  virtual Status Read(uint64_t offset, size_t n, Slice* result,\n+                      char* scratch) const = 0;\n+};\n+\n+// A file abstraction for sequential writing.  The implementation\n+// must provide buffering since callers may append small fragments\n+// at a time to the file.\n+class WritableFile {\n+ public:\n+  WritableFile() { }\n+  virtual ~WritableFile();\n+\n+  virtual Status Append(const Slice& data) = 0;\n+  virtual Status Close() = 0;\n+  virtual Status Flush() = 0;\n+  virtual Status Sync() = 0;\n+\n+ private:\n+  // No copying allowed\n+  WritableFile(const WritableFile&);\n+  void operator=(const WritableFile&);\n+};\n+\n+// An interface for writing log messages.\n+class Logger {\n+ public:\n+  Logger() { }\n+  virtual ~Logger();\n+\n+  // Write an entry to the log file with the specified format.\n+  virtual void Logv(const char* format, va_list ap) = 0;\n+\n+ private:\n+  // No copying allowed\n+  Logger(const Logger&);\n+  void operator=(const Logger&);\n+};\n+\n+\n+// Identifies a locked file.\n+class FileLock {\n+ public:\n+  FileLock() { }\n+  virtual ~FileLock();\n+ private:\n+  // No copying allowed\n+  FileLock(const FileLock&);\n+  void operator=(const FileLock&);\n+};\n+\n+// Log the specified data to *info_log if info_log is non-NULL.\n+extern void Log(Logger* info_log, const char* format, ...)\n+#   if defined(__GNUC__) || defined(__clang__)\n+    __attribute__((__format__ (__printf__, 2, 3)))\n+#   endif\n+    ;\n+\n+// A utility routine: write \"data\" to the named file.\n+extern Status WriteStringToFile(Env* env, const Slice& data,\n+                                const std::string& fname);\n+\n+// A utility routine: read contents of named file into *data\n+extern Status ReadFileToString(Env* env, const std::string& fname,\n+                               std::string* data);\n+\n+// An implementation of Env that forwards all calls to another Env.\n+// May be useful to clients who wish to override just part of the\n+// functionality of another Env.\n+class EnvWrapper : public Env {\n+ public:\n+  // Initialize an EnvWrapper that delegates all calls to *t\n+  explicit EnvWrapper(Env* t) : target_(t) { }\n+  virtual ~EnvWrapper();\n+\n+  // Return the target to which this Env forwards all calls\n+  Env* target() const { return target_; }\n+\n+  // The following text is boilerplate that forwards all methods to target()\n+  Status NewSequentialFile(const std::string& f, SequentialFile** r) {\n+    return target_->NewSequentialFile(f, r);\n+  }\n+  Status NewRandomAccessFile(const std::string& f, RandomAccessFile** r) {\n+    return target_->NewRandomAccessFile(f, r);\n+  }\n+  Status NewWritableFile(const std::string& f, WritableFile** r) {\n+    return target_->NewWritableFile(f, r);\n+  }\n+  bool FileExists(const std::string& f) { return target_->FileExists(f); }\n+  Status GetChildren(const std::string& dir, std::vector<std::string>* r) {\n+    return target_->GetChildren(dir, r);\n+  }\n+  Status DeleteFile(const std::string& f) { return target_->DeleteFile(f); }\n+  Status CreateDir(const std::string& d) { return target_->CreateDir(d); }\n+  Status DeleteDir(const std::string& d) { return target_->DeleteDir(d); }\n+  Status GetFileSize(const std::string& f, uint64_t* s) {\n+    return target_->GetFileSize(f, s);\n+  }\n+  Status RenameFile(const std::string& s, const std::string& t) {\n+    return target_->RenameFile(s, t);\n+  }\n+  Status LockFile(const std::string& f, FileLock** l) {\n+    return target_->LockFile(f, l);\n+  }\n+  Status UnlockFile(FileLock* l) { return target_->UnlockFile(l); }\n+  void Schedule(void (*f)(void*), void* a) {\n+    return target_->Schedule(f, a);\n+  }\n+  void StartThread(void (*f)(void*), void* a) {\n+    return target_->StartThread(f, a);\n+  }\n+  virtual Status GetTestDirectory(std::string* path) {\n+    return target_->GetTestDirectory(path);\n+  }\n+  virtual Status NewLogger(const std::string& fname, Logger** result) {\n+    return target_->NewLogger(fname, result);\n+  }\n+  uint64_t NowMicros() {\n+    return target_->NowMicros();\n+  }\n+  void SleepForMicroseconds(int micros) {\n+    target_->SleepForMicroseconds(micros);\n+  }\n+ private:\n+  Env* target_;\n+};\n+\n+}  // namespace leveldb\n+\n+#endif  // STORAGE_LEVELDB_INCLUDE_ENV_H_"
      },
      {
        "sha": "1fba08001fc335a14bde90fa5a1c5d58025ae038",
        "filename": "src/leveldb/include/leveldb/filter_policy.h",
        "status": "added",
        "additions": 70,
        "deletions": 0,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/include/leveldb/filter_policy.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/include/leveldb/filter_policy.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/include/leveldb/filter_policy.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,70 @@\n+// Copyright (c) 2012 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+//\n+// A database can be configured with a custom FilterPolicy object.\n+// This object is responsible for creating a small filter from a set\n+// of keys.  These filters are stored in leveldb and are consulted\n+// automatically by leveldb to decide whether or not to read some\n+// information from disk. In many cases, a filter can cut down the\n+// number of disk seeks form a handful to a single disk seek per\n+// DB::Get() call.\n+//\n+// Most people will want to use the builtin bloom filter support (see\n+// NewBloomFilterPolicy() below).\n+\n+#ifndef STORAGE_LEVELDB_INCLUDE_FILTER_POLICY_H_\n+#define STORAGE_LEVELDB_INCLUDE_FILTER_POLICY_H_\n+\n+#include <string>\n+\n+namespace leveldb {\n+\n+class Slice;\n+\n+class FilterPolicy {\n+ public:\n+  virtual ~FilterPolicy();\n+\n+  // Return the name of this policy.  Note that if the filter encoding\n+  // changes in an incompatible way, the name returned by this method\n+  // must be changed.  Otherwise, old incompatible filters may be\n+  // passed to methods of this type.\n+  virtual const char* Name() const = 0;\n+\n+  // keys[0,n-1] contains a list of keys (potentially with duplicates)\n+  // that are ordered according to the user supplied comparator.\n+  // Append a filter that summarizes keys[0,n-1] to *dst.\n+  //\n+  // Warning: do not change the initial contents of *dst.  Instead,\n+  // append the newly constructed filter to *dst.\n+  virtual void CreateFilter(const Slice* keys, int n, std::string* dst)\n+      const = 0;\n+\n+  // \"filter\" contains the data appended by a preceding call to\n+  // CreateFilter() on this class.  This method must return true if\n+  // the key was in the list of keys passed to CreateFilter().\n+  // This method may return true or false if the key was not on the\n+  // list, but it should aim to return false with a high probability.\n+  virtual bool KeyMayMatch(const Slice& key, const Slice& filter) const = 0;\n+};\n+\n+// Return a new filter policy that uses a bloom filter with approximately\n+// the specified number of bits per key.  A good value for bits_per_key\n+// is 10, which yields a filter with ~ 1% false positive rate.\n+//\n+// Callers must delete the result after any database that is using the\n+// result has been closed.\n+//\n+// Note: if you are using a custom comparator that ignores some parts\n+// of the keys being compared, you must not use NewBloomFilterPolicy()\n+// and must provide your own FilterPolicy that also ignores the\n+// corresponding parts of the keys.  For example, if the comparator\n+// ignores trailing spaces, it would be incorrect to use a\n+// FilterPolicy (like NewBloomFilterPolicy) that does not ignore\n+// trailing spaces in keys.\n+extern const FilterPolicy* NewBloomFilterPolicy(int bits_per_key);\n+\n+}\n+\n+#endif  // STORAGE_LEVELDB_INCLUDE_FILTER_POLICY_H_"
      },
      {
        "sha": "ad543eb46cde9af30f9250ee2eaa7f0979cc2994",
        "filename": "src/leveldb/include/leveldb/iterator.h",
        "status": "added",
        "additions": 100,
        "deletions": 0,
        "changes": 100,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/include/leveldb/iterator.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/include/leveldb/iterator.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/include/leveldb/iterator.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,100 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+//\n+// An iterator yields a sequence of key/value pairs from a source.\n+// The following class defines the interface.  Multiple implementations\n+// are provided by this library.  In particular, iterators are provided\n+// to access the contents of a Table or a DB.\n+//\n+// Multiple threads can invoke const methods on an Iterator without\n+// external synchronization, but if any of the threads may call a\n+// non-const method, all threads accessing the same Iterator must use\n+// external synchronization.\n+\n+#ifndef STORAGE_LEVELDB_INCLUDE_ITERATOR_H_\n+#define STORAGE_LEVELDB_INCLUDE_ITERATOR_H_\n+\n+#include \"leveldb/slice.h\"\n+#include \"leveldb/status.h\"\n+\n+namespace leveldb {\n+\n+class Iterator {\n+ public:\n+  Iterator();\n+  virtual ~Iterator();\n+\n+  // An iterator is either positioned at a key/value pair, or\n+  // not valid.  This method returns true iff the iterator is valid.\n+  virtual bool Valid() const = 0;\n+\n+  // Position at the first key in the source.  The iterator is Valid()\n+  // after this call iff the source is not empty.\n+  virtual void SeekToFirst() = 0;\n+\n+  // Position at the last key in the source.  The iterator is\n+  // Valid() after this call iff the source is not empty.\n+  virtual void SeekToLast() = 0;\n+\n+  // Position at the first key in the source that at or past target\n+  // The iterator is Valid() after this call iff the source contains\n+  // an entry that comes at or past target.\n+  virtual void Seek(const Slice& target) = 0;\n+\n+  // Moves to the next entry in the source.  After this call, Valid() is\n+  // true iff the iterator was not positioned at the last entry in the source.\n+  // REQUIRES: Valid()\n+  virtual void Next() = 0;\n+\n+  // Moves to the previous entry in the source.  After this call, Valid() is\n+  // true iff the iterator was not positioned at the first entry in source.\n+  // REQUIRES: Valid()\n+  virtual void Prev() = 0;\n+\n+  // Return the key for the current entry.  The underlying storage for\n+  // the returned slice is valid only until the next modification of\n+  // the iterator.\n+  // REQUIRES: Valid()\n+  virtual Slice key() const = 0;\n+\n+  // Return the value for the current entry.  The underlying storage for\n+  // the returned slice is valid only until the next modification of\n+  // the iterator.\n+  // REQUIRES: !AtEnd() && !AtStart()\n+  virtual Slice value() const = 0;\n+\n+  // If an error has occurred, return it.  Else return an ok status.\n+  virtual Status status() const = 0;\n+\n+  // Clients are allowed to register function/arg1/arg2 triples that\n+  // will be invoked when this iterator is destroyed.\n+  //\n+  // Note that unlike all of the preceding methods, this method is\n+  // not abstract and therefore clients should not override it.\n+  typedef void (*CleanupFunction)(void* arg1, void* arg2);\n+  void RegisterCleanup(CleanupFunction function, void* arg1, void* arg2);\n+\n+ private:\n+  struct Cleanup {\n+    CleanupFunction function;\n+    void* arg1;\n+    void* arg2;\n+    Cleanup* next;\n+  };\n+  Cleanup cleanup_;\n+\n+  // No copying allowed\n+  Iterator(const Iterator&);\n+  void operator=(const Iterator&);\n+};\n+\n+// Return an empty iterator (yields nothing).\n+extern Iterator* NewEmptyIterator();\n+\n+// Return an empty iterator with the specified status.\n+extern Iterator* NewErrorIterator(const Status& status);\n+\n+}  // namespace leveldb\n+\n+#endif  // STORAGE_LEVELDB_INCLUDE_ITERATOR_H_"
      },
      {
        "sha": "fdda718d3090638c7378f4418e4d024dd2e68bda",
        "filename": "src/leveldb/include/leveldb/options.h",
        "status": "added",
        "additions": 195,
        "deletions": 0,
        "changes": 195,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/include/leveldb/options.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/include/leveldb/options.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/include/leveldb/options.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,195 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#ifndef STORAGE_LEVELDB_INCLUDE_OPTIONS_H_\n+#define STORAGE_LEVELDB_INCLUDE_OPTIONS_H_\n+\n+#include <stddef.h>\n+\n+namespace leveldb {\n+\n+class Cache;\n+class Comparator;\n+class Env;\n+class FilterPolicy;\n+class Logger;\n+class Snapshot;\n+\n+// DB contents are stored in a set of blocks, each of which holds a\n+// sequence of key,value pairs.  Each block may be compressed before\n+// being stored in a file.  The following enum describes which\n+// compression method (if any) is used to compress a block.\n+enum CompressionType {\n+  // NOTE: do not change the values of existing entries, as these are\n+  // part of the persistent format on disk.\n+  kNoCompression     = 0x0,\n+  kSnappyCompression = 0x1\n+};\n+\n+// Options to control the behavior of a database (passed to DB::Open)\n+struct Options {\n+  // -------------------\n+  // Parameters that affect behavior\n+\n+  // Comparator used to define the order of keys in the table.\n+  // Default: a comparator that uses lexicographic byte-wise ordering\n+  //\n+  // REQUIRES: The client must ensure that the comparator supplied\n+  // here has the same name and orders keys *exactly* the same as the\n+  // comparator provided to previous open calls on the same DB.\n+  const Comparator* comparator;\n+\n+  // If true, the database will be created if it is missing.\n+  // Default: false\n+  bool create_if_missing;\n+\n+  // If true, an error is raised if the database already exists.\n+  // Default: false\n+  bool error_if_exists;\n+\n+  // If true, the implementation will do aggressive checking of the\n+  // data it is processing and will stop early if it detects any\n+  // errors.  This may have unforeseen ramifications: for example, a\n+  // corruption of one DB entry may cause a large number of entries to\n+  // become unreadable or for the entire DB to become unopenable.\n+  // Default: false\n+  bool paranoid_checks;\n+\n+  // Use the specified object to interact with the environment,\n+  // e.g. to read/write files, schedule background work, etc.\n+  // Default: Env::Default()\n+  Env* env;\n+\n+  // Any internal progress/error information generated by the db will\n+  // be written to info_log if it is non-NULL, or to a file stored\n+  // in the same directory as the DB contents if info_log is NULL.\n+  // Default: NULL\n+  Logger* info_log;\n+\n+  // -------------------\n+  // Parameters that affect performance\n+\n+  // Amount of data to build up in memory (backed by an unsorted log\n+  // on disk) before converting to a sorted on-disk file.\n+  //\n+  // Larger values increase performance, especially during bulk loads.\n+  // Up to two write buffers may be held in memory at the same time,\n+  // so you may wish to adjust this parameter to control memory usage.\n+  // Also, a larger write buffer will result in a longer recovery time\n+  // the next time the database is opened.\n+  //\n+  // Default: 4MB\n+  size_t write_buffer_size;\n+\n+  // Number of open files that can be used by the DB.  You may need to\n+  // increase this if your database has a large working set (budget\n+  // one open file per 2MB of working set).\n+  //\n+  // Default: 1000\n+  int max_open_files;\n+\n+  // Control over blocks (user data is stored in a set of blocks, and\n+  // a block is the unit of reading from disk).\n+\n+  // If non-NULL, use the specified cache for blocks.\n+  // If NULL, leveldb will automatically create and use an 8MB internal cache.\n+  // Default: NULL\n+  Cache* block_cache;\n+\n+  // Approximate size of user data packed per block.  Note that the\n+  // block size specified here corresponds to uncompressed data.  The\n+  // actual size of the unit read from disk may be smaller if\n+  // compression is enabled.  This parameter can be changed dynamically.\n+  //\n+  // Default: 4K\n+  size_t block_size;\n+\n+  // Number of keys between restart points for delta encoding of keys.\n+  // This parameter can be changed dynamically.  Most clients should\n+  // leave this parameter alone.\n+  //\n+  // Default: 16\n+  int block_restart_interval;\n+\n+  // Compress blocks using the specified compression algorithm.  This\n+  // parameter can be changed dynamically.\n+  //\n+  // Default: kSnappyCompression, which gives lightweight but fast\n+  // compression.\n+  //\n+  // Typical speeds of kSnappyCompression on an Intel(R) Core(TM)2 2.4GHz:\n+  //    ~200-500MB/s compression\n+  //    ~400-800MB/s decompression\n+  // Note that these speeds are significantly faster than most\n+  // persistent storage speeds, and therefore it is typically never\n+  // worth switching to kNoCompression.  Even if the input data is\n+  // incompressible, the kSnappyCompression implementation will\n+  // efficiently detect that and will switch to uncompressed mode.\n+  CompressionType compression;\n+\n+  // If non-NULL, use the specified filter policy to reduce disk reads.\n+  // Many applications will benefit from passing the result of\n+  // NewBloomFilterPolicy() here.\n+  //\n+  // Default: NULL\n+  const FilterPolicy* filter_policy;\n+\n+  // Create an Options object with default values for all fields.\n+  Options();\n+};\n+\n+// Options that control read operations\n+struct ReadOptions {\n+  // If true, all data read from underlying storage will be\n+  // verified against corresponding checksums.\n+  // Default: false\n+  bool verify_checksums;\n+\n+  // Should the data read for this iteration be cached in memory?\n+  // Callers may wish to set this field to false for bulk scans.\n+  // Default: true\n+  bool fill_cache;\n+\n+  // If \"snapshot\" is non-NULL, read as of the supplied snapshot\n+  // (which must belong to the DB that is being read and which must\n+  // not have been released).  If \"snapshot\" is NULL, use an impliicit\n+  // snapshot of the state at the beginning of this read operation.\n+  // Default: NULL\n+  const Snapshot* snapshot;\n+\n+  ReadOptions()\n+      : verify_checksums(false),\n+        fill_cache(true),\n+        snapshot(NULL) {\n+  }\n+};\n+\n+// Options that control write operations\n+struct WriteOptions {\n+  // If true, the write will be flushed from the operating system\n+  // buffer cache (by calling WritableFile::Sync()) before the write\n+  // is considered complete.  If this flag is true, writes will be\n+  // slower.\n+  //\n+  // If this flag is false, and the machine crashes, some recent\n+  // writes may be lost.  Note that if it is just the process that\n+  // crashes (i.e., the machine does not reboot), no writes will be\n+  // lost even if sync==false.\n+  //\n+  // In other words, a DB write with sync==false has similar\n+  // crash semantics as the \"write()\" system call.  A DB write\n+  // with sync==true has similar crash semantics to a \"write()\"\n+  // system call followed by \"fsync()\".\n+  //\n+  // Default: false\n+  bool sync;\n+\n+  WriteOptions()\n+      : sync(false) {\n+  }\n+};\n+\n+}  // namespace leveldb\n+\n+#endif  // STORAGE_LEVELDB_INCLUDE_OPTIONS_H_"
      },
      {
        "sha": "74ea8fa49af6782b54ba07528844e665e8ea8095",
        "filename": "src/leveldb/include/leveldb/slice.h",
        "status": "added",
        "additions": 109,
        "deletions": 0,
        "changes": 109,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/include/leveldb/slice.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/include/leveldb/slice.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/include/leveldb/slice.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,109 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+//\n+// Slice is a simple structure containing a pointer into some external\n+// storage and a size.  The user of a Slice must ensure that the slice\n+// is not used after the corresponding external storage has been\n+// deallocated.\n+//\n+// Multiple threads can invoke const methods on a Slice without\n+// external synchronization, but if any of the threads may call a\n+// non-const method, all threads accessing the same Slice must use\n+// external synchronization.\n+\n+#ifndef STORAGE_LEVELDB_INCLUDE_SLICE_H_\n+#define STORAGE_LEVELDB_INCLUDE_SLICE_H_\n+\n+#include <assert.h>\n+#include <stddef.h>\n+#include <string.h>\n+#include <string>\n+\n+namespace leveldb {\n+\n+class Slice {\n+ public:\n+  // Create an empty slice.\n+  Slice() : data_(\"\"), size_(0) { }\n+\n+  // Create a slice that refers to d[0,n-1].\n+  Slice(const char* d, size_t n) : data_(d), size_(n) { }\n+\n+  // Create a slice that refers to the contents of \"s\"\n+  Slice(const std::string& s) : data_(s.data()), size_(s.size()) { }\n+\n+  // Create a slice that refers to s[0,strlen(s)-1]\n+  Slice(const char* s) : data_(s), size_(strlen(s)) { }\n+\n+  // Return a pointer to the beginning of the referenced data\n+  const char* data() const { return data_; }\n+\n+  // Return the length (in bytes) of the referenced data\n+  size_t size() const { return size_; }\n+\n+  // Return true iff the length of the referenced data is zero\n+  bool empty() const { return size_ == 0; }\n+\n+  // Return the ith byte in the referenced data.\n+  // REQUIRES: n < size()\n+  char operator[](size_t n) const {\n+    assert(n < size());\n+    return data_[n];\n+  }\n+\n+  // Change this slice to refer to an empty array\n+  void clear() { data_ = \"\"; size_ = 0; }\n+\n+  // Drop the first \"n\" bytes from this slice.\n+  void remove_prefix(size_t n) {\n+    assert(n <= size());\n+    data_ += n;\n+    size_ -= n;\n+  }\n+\n+  // Return a string that contains the copy of the referenced data.\n+  std::string ToString() const { return std::string(data_, size_); }\n+\n+  // Three-way comparison.  Returns value:\n+  //   <  0 iff \"*this\" <  \"b\",\n+  //   == 0 iff \"*this\" == \"b\",\n+  //   >  0 iff \"*this\" >  \"b\"\n+  int compare(const Slice& b) const;\n+\n+  // Return true iff \"x\" is a prefix of \"*this\"\n+  bool starts_with(const Slice& x) const {\n+    return ((size_ >= x.size_) &&\n+            (memcmp(data_, x.data_, x.size_) == 0));\n+  }\n+\n+ private:\n+  const char* data_;\n+  size_t size_;\n+\n+  // Intentionally copyable\n+};\n+\n+inline bool operator==(const Slice& x, const Slice& y) {\n+  return ((x.size() == y.size()) &&\n+          (memcmp(x.data(), y.data(), x.size()) == 0));\n+}\n+\n+inline bool operator!=(const Slice& x, const Slice& y) {\n+  return !(x == y);\n+}\n+\n+inline int Slice::compare(const Slice& b) const {\n+  const int min_len = (size_ < b.size_) ? size_ : b.size_;\n+  int r = memcmp(data_, b.data_, min_len);\n+  if (r == 0) {\n+    if (size_ < b.size_) r = -1;\n+    else if (size_ > b.size_) r = +1;\n+  }\n+  return r;\n+}\n+\n+}  // namespace leveldb\n+\n+\n+#endif  // STORAGE_LEVELDB_INCLUDE_SLICE_H_"
      },
      {
        "sha": "11dbd4b47ed3883b7dd5092c21685441f6000c26",
        "filename": "src/leveldb/include/leveldb/status.h",
        "status": "added",
        "additions": 106,
        "deletions": 0,
        "changes": 106,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/include/leveldb/status.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/include/leveldb/status.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/include/leveldb/status.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,106 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+//\n+// A Status encapsulates the result of an operation.  It may indicate success,\n+// or it may indicate an error with an associated error message.\n+//\n+// Multiple threads can invoke const methods on a Status without\n+// external synchronization, but if any of the threads may call a\n+// non-const method, all threads accessing the same Status must use\n+// external synchronization.\n+\n+#ifndef STORAGE_LEVELDB_INCLUDE_STATUS_H_\n+#define STORAGE_LEVELDB_INCLUDE_STATUS_H_\n+\n+#include <string>\n+#include \"leveldb/slice.h\"\n+\n+namespace leveldb {\n+\n+class Status {\n+ public:\n+  // Create a success status.\n+  Status() : state_(NULL) { }\n+  ~Status() { delete[] state_; }\n+\n+  // Copy the specified status.\n+  Status(const Status& s);\n+  void operator=(const Status& s);\n+\n+  // Return a success status.\n+  static Status OK() { return Status(); }\n+\n+  // Return error status of an appropriate type.\n+  static Status NotFound(const Slice& msg, const Slice& msg2 = Slice()) {\n+    return Status(kNotFound, msg, msg2);\n+  }\n+  static Status Corruption(const Slice& msg, const Slice& msg2 = Slice()) {\n+    return Status(kCorruption, msg, msg2);\n+  }\n+  static Status NotSupported(const Slice& msg, const Slice& msg2 = Slice()) {\n+    return Status(kNotSupported, msg, msg2);\n+  }\n+  static Status InvalidArgument(const Slice& msg, const Slice& msg2 = Slice()) {\n+    return Status(kInvalidArgument, msg, msg2);\n+  }\n+  static Status IOError(const Slice& msg, const Slice& msg2 = Slice()) {\n+    return Status(kIOError, msg, msg2);\n+  }\n+\n+  // Returns true iff the status indicates success.\n+  bool ok() const { return (state_ == NULL); }\n+\n+  // Returns true iff the status indicates a NotFound error.\n+  bool IsNotFound() const { return code() == kNotFound; }\n+\n+  // Returns true iff the status indicates a Corruption error.\n+  bool IsCorruption() const { return code() == kCorruption; }\n+\n+  // Returns true iff the status indicates an IOError.\n+  bool IsIOError() const { return code() == kIOError; }\n+\n+  // Return a string representation of this status suitable for printing.\n+  // Returns the string \"OK\" for success.\n+  std::string ToString() const;\n+\n+ private:\n+  // OK status has a NULL state_.  Otherwise, state_ is a new[] array\n+  // of the following form:\n+  //    state_[0..3] == length of message\n+  //    state_[4]    == code\n+  //    state_[5..]  == message\n+  const char* state_;\n+\n+  enum Code {\n+    kOk = 0,\n+    kNotFound = 1,\n+    kCorruption = 2,\n+    kNotSupported = 3,\n+    kInvalidArgument = 4,\n+    kIOError = 5\n+  };\n+\n+  Code code() const {\n+    return (state_ == NULL) ? kOk : static_cast<Code>(state_[4]);\n+  }\n+\n+  Status(Code code, const Slice& msg, const Slice& msg2);\n+  static const char* CopyState(const char* s);\n+};\n+\n+inline Status::Status(const Status& s) {\n+  state_ = (s.state_ == NULL) ? NULL : CopyState(s.state_);\n+}\n+inline void Status::operator=(const Status& s) {\n+  // The following condition catches both aliasing (when this == &s),\n+  // and the common case where both s and *this are ok.\n+  if (state_ != s.state_) {\n+    delete[] state_;\n+    state_ = (s.state_ == NULL) ? NULL : CopyState(s.state_);\n+  }\n+}\n+\n+}  // namespace leveldb\n+\n+#endif  // STORAGE_LEVELDB_INCLUDE_STATUS_H_"
      },
      {
        "sha": "a9746c3f5ea90250d8bde12d9ec7e9091fd5bd51",
        "filename": "src/leveldb/include/leveldb/table.h",
        "status": "added",
        "additions": 85,
        "deletions": 0,
        "changes": 85,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/include/leveldb/table.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/include/leveldb/table.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/include/leveldb/table.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,85 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#ifndef STORAGE_LEVELDB_INCLUDE_TABLE_H_\n+#define STORAGE_LEVELDB_INCLUDE_TABLE_H_\n+\n+#include <stdint.h>\n+#include \"leveldb/iterator.h\"\n+\n+namespace leveldb {\n+\n+class Block;\n+class BlockHandle;\n+class Footer;\n+struct Options;\n+class RandomAccessFile;\n+struct ReadOptions;\n+class TableCache;\n+\n+// A Table is a sorted map from strings to strings.  Tables are\n+// immutable and persistent.  A Table may be safely accessed from\n+// multiple threads without external synchronization.\n+class Table {\n+ public:\n+  // Attempt to open the table that is stored in bytes [0..file_size)\n+  // of \"file\", and read the metadata entries necessary to allow\n+  // retrieving data from the table.\n+  //\n+  // If successful, returns ok and sets \"*table\" to the newly opened\n+  // table.  The client should delete \"*table\" when no longer needed.\n+  // If there was an error while initializing the table, sets \"*table\"\n+  // to NULL and returns a non-ok status.  Does not take ownership of\n+  // \"*source\", but the client must ensure that \"source\" remains live\n+  // for the duration of the returned table's lifetime.\n+  //\n+  // *file must remain live while this Table is in use.\n+  static Status Open(const Options& options,\n+                     RandomAccessFile* file,\n+                     uint64_t file_size,\n+                     Table** table);\n+\n+  ~Table();\n+\n+  // Returns a new iterator over the table contents.\n+  // The result of NewIterator() is initially invalid (caller must\n+  // call one of the Seek methods on the iterator before using it).\n+  Iterator* NewIterator(const ReadOptions&) const;\n+\n+  // Given a key, return an approximate byte offset in the file where\n+  // the data for that key begins (or would begin if the key were\n+  // present in the file).  The returned value is in terms of file\n+  // bytes, and so includes effects like compression of the underlying data.\n+  // E.g., the approximate offset of the last key in the table will\n+  // be close to the file length.\n+  uint64_t ApproximateOffsetOf(const Slice& key) const;\n+\n+ private:\n+  struct Rep;\n+  Rep* rep_;\n+\n+  explicit Table(Rep* rep) { rep_ = rep; }\n+  static Iterator* BlockReader(void*, const ReadOptions&, const Slice&);\n+\n+  // Calls (*handle_result)(arg, ...) with the entry found after a call\n+  // to Seek(key).  May not make such a call if filter policy says\n+  // that key is not present.\n+  friend class TableCache;\n+  Status InternalGet(\n+      const ReadOptions&, const Slice& key,\n+      void* arg,\n+      void (*handle_result)(void* arg, const Slice& k, const Slice& v));\n+\n+\n+  void ReadMeta(const Footer& footer);\n+  void ReadFilter(const Slice& filter_handle_value);\n+\n+  // No copying allowed\n+  Table(const Table&);\n+  void operator=(const Table&);\n+};\n+\n+}  // namespace leveldb\n+\n+#endif  // STORAGE_LEVELDB_INCLUDE_TABLE_H_"
      },
      {
        "sha": "5fd1dc71f1cb7541ef62397b6795946ad8c20652",
        "filename": "src/leveldb/include/leveldb/table_builder.h",
        "status": "added",
        "additions": 92,
        "deletions": 0,
        "changes": 92,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/include/leveldb/table_builder.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/include/leveldb/table_builder.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/include/leveldb/table_builder.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,92 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+//\n+// TableBuilder provides the interface used to build a Table\n+// (an immutable and sorted map from keys to values).\n+//\n+// Multiple threads can invoke const methods on a TableBuilder without\n+// external synchronization, but if any of the threads may call a\n+// non-const method, all threads accessing the same TableBuilder must use\n+// external synchronization.\n+\n+#ifndef STORAGE_LEVELDB_INCLUDE_TABLE_BUILDER_H_\n+#define STORAGE_LEVELDB_INCLUDE_TABLE_BUILDER_H_\n+\n+#include <stdint.h>\n+#include \"leveldb/options.h\"\n+#include \"leveldb/status.h\"\n+\n+namespace leveldb {\n+\n+class BlockBuilder;\n+class BlockHandle;\n+class WritableFile;\n+\n+class TableBuilder {\n+ public:\n+  // Create a builder that will store the contents of the table it is\n+  // building in *file.  Does not close the file.  It is up to the\n+  // caller to close the file after calling Finish().\n+  TableBuilder(const Options& options, WritableFile* file);\n+\n+  // REQUIRES: Either Finish() or Abandon() has been called.\n+  ~TableBuilder();\n+\n+  // Change the options used by this builder.  Note: only some of the\n+  // option fields can be changed after construction.  If a field is\n+  // not allowed to change dynamically and its value in the structure\n+  // passed to the constructor is different from its value in the\n+  // structure passed to this method, this method will return an error\n+  // without changing any fields.\n+  Status ChangeOptions(const Options& options);\n+\n+  // Add key,value to the table being constructed.\n+  // REQUIRES: key is after any previously added key according to comparator.\n+  // REQUIRES: Finish(), Abandon() have not been called\n+  void Add(const Slice& key, const Slice& value);\n+\n+  // Advanced operation: flush any buffered key/value pairs to file.\n+  // Can be used to ensure that two adjacent entries never live in\n+  // the same data block.  Most clients should not need to use this method.\n+  // REQUIRES: Finish(), Abandon() have not been called\n+  void Flush();\n+\n+  // Return non-ok iff some error has been detected.\n+  Status status() const;\n+\n+  // Finish building the table.  Stops using the file passed to the\n+  // constructor after this function returns.\n+  // REQUIRES: Finish(), Abandon() have not been called\n+  Status Finish();\n+\n+  // Indicate that the contents of this builder should be abandoned.  Stops\n+  // using the file passed to the constructor after this function returns.\n+  // If the caller is not going to call Finish(), it must call Abandon()\n+  // before destroying this builder.\n+  // REQUIRES: Finish(), Abandon() have not been called\n+  void Abandon();\n+\n+  // Number of calls to Add() so far.\n+  uint64_t NumEntries() const;\n+\n+  // Size of the file generated so far.  If invoked after a successful\n+  // Finish() call, returns the size of the final generated file.\n+  uint64_t FileSize() const;\n+\n+ private:\n+  bool ok() const { return status().ok(); }\n+  void WriteBlock(BlockBuilder* block, BlockHandle* handle);\n+  void WriteRawBlock(const Slice& data, CompressionType, BlockHandle* handle);\n+\n+  struct Rep;\n+  Rep* rep_;\n+\n+  // No copying allowed\n+  TableBuilder(const TableBuilder&);\n+  void operator=(const TableBuilder&);\n+};\n+\n+}  // namespace leveldb\n+\n+#endif  // STORAGE_LEVELDB_INCLUDE_TABLE_BUILDER_H_"
      },
      {
        "sha": "ee9aab68e0d83dc4d94835ee21cf926c1ff0c0db",
        "filename": "src/leveldb/include/leveldb/write_batch.h",
        "status": "added",
        "additions": 64,
        "deletions": 0,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/include/leveldb/write_batch.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/include/leveldb/write_batch.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/include/leveldb/write_batch.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,64 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+//\n+// WriteBatch holds a collection of updates to apply atomically to a DB.\n+//\n+// The updates are applied in the order in which they are added\n+// to the WriteBatch.  For example, the value of \"key\" will be \"v3\"\n+// after the following batch is written:\n+//\n+//    batch.Put(\"key\", \"v1\");\n+//    batch.Delete(\"key\");\n+//    batch.Put(\"key\", \"v2\");\n+//    batch.Put(\"key\", \"v3\");\n+//\n+// Multiple threads can invoke const methods on a WriteBatch without\n+// external synchronization, but if any of the threads may call a\n+// non-const method, all threads accessing the same WriteBatch must use\n+// external synchronization.\n+\n+#ifndef STORAGE_LEVELDB_INCLUDE_WRITE_BATCH_H_\n+#define STORAGE_LEVELDB_INCLUDE_WRITE_BATCH_H_\n+\n+#include <string>\n+#include \"leveldb/status.h\"\n+\n+namespace leveldb {\n+\n+class Slice;\n+\n+class WriteBatch {\n+ public:\n+  WriteBatch();\n+  ~WriteBatch();\n+\n+  // Store the mapping \"key->value\" in the database.\n+  void Put(const Slice& key, const Slice& value);\n+\n+  // If the database contains a mapping for \"key\", erase it.  Else do nothing.\n+  void Delete(const Slice& key);\n+\n+  // Clear all updates buffered in this batch.\n+  void Clear();\n+\n+  // Support for iterating over the contents of a batch.\n+  class Handler {\n+   public:\n+    virtual ~Handler();\n+    virtual void Put(const Slice& key, const Slice& value) = 0;\n+    virtual void Delete(const Slice& key) = 0;\n+  };\n+  Status Iterate(Handler* handler) const;\n+\n+ private:\n+  friend class WriteBatchInternal;\n+\n+  std::string rep_;  // See comment in write_batch.cc for the format of rep_\n+\n+  // Intentionally copyable\n+};\n+\n+}  // namespace leveldb\n+\n+#endif  // STORAGE_LEVELDB_INCLUDE_WRITE_BATCH_H_"
      },
      {
        "sha": "422563e25ce0230d92373637799da8d28ab60223",
        "filename": "src/leveldb/port/README",
        "status": "added",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/port/README",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/port/README",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/README?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,10 @@\n+This directory contains interfaces and implementations that isolate the\n+rest of the package from platform details.\n+\n+Code in the rest of the package includes \"port.h\" from this directory.\n+\"port.h\" in turn includes a platform specific \"port_<platform>.h\" file\n+that provides the platform specific implementation.\n+\n+See port_posix.h for an example of what must be provided in a platform\n+specific header file.\n+"
      },
      {
        "sha": "c58bffbf1b1a022cc8e8c4cf364c7d40fe6abc78",
        "filename": "src/leveldb/port/atomic_pointer.h",
        "status": "added",
        "additions": 152,
        "deletions": 0,
        "changes": 152,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/port/atomic_pointer.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/port/atomic_pointer.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/atomic_pointer.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,152 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+// AtomicPointer provides storage for a lock-free pointer.\n+// Platform-dependent implementation of AtomicPointer:\n+// - If the platform provides a cheap barrier, we use it with raw pointers\n+// - If cstdatomic is present (on newer versions of gcc, it is), we use\n+//   a cstdatomic-based AtomicPointer.  However we prefer the memory\n+//   barrier based version, because at least on a gcc 4.4 32-bit build\n+//   on linux, we have encountered a buggy <cstdatomic>\n+//   implementation.  Also, some <cstdatomic> implementations are much\n+//   slower than a memory-barrier based implementation (~16ns for\n+//   <cstdatomic> based acquire-load vs. ~1ns for a barrier based\n+//   acquire-load).\n+// This code is based on atomicops-internals-* in Google's perftools:\n+// http://code.google.com/p/google-perftools/source/browse/#svn%2Ftrunk%2Fsrc%2Fbase\n+\n+#ifndef PORT_ATOMIC_POINTER_H_\n+#define PORT_ATOMIC_POINTER_H_\n+\n+#include <stdint.h>\n+#ifdef LEVELDB_CSTDATOMIC_PRESENT\n+#include <cstdatomic>\n+#endif\n+#ifdef OS_WIN\n+#include <windows.h>\n+#endif\n+#ifdef OS_MACOSX\n+#include <libkern/OSAtomic.h>\n+#endif\n+\n+#if defined(_M_X64) || defined(__x86_64__)\n+#define ARCH_CPU_X86_FAMILY 1\n+#elif defined(_M_IX86) || defined(__i386__) || defined(__i386)\n+#define ARCH_CPU_X86_FAMILY 1\n+#elif defined(__ARMEL__)\n+#define ARCH_CPU_ARM_FAMILY 1\n+#endif\n+\n+namespace leveldb {\n+namespace port {\n+\n+// Define MemoryBarrier() if available\n+// Windows on x86\n+#if defined(OS_WIN) && defined(COMPILER_MSVC) && defined(ARCH_CPU_X86_FAMILY)\n+// windows.h already provides a MemoryBarrier(void) macro\n+// http://msdn.microsoft.com/en-us/library/ms684208(v=vs.85).aspx\n+#define LEVELDB_HAVE_MEMORY_BARRIER\n+\n+// Gcc on x86\n+#elif defined(ARCH_CPU_X86_FAMILY) && defined(__GNUC__)\n+inline void MemoryBarrier() {\n+  // See http://gcc.gnu.org/ml/gcc/2003-04/msg01180.html for a discussion on\n+  // this idiom. Also see http://en.wikipedia.org/wiki/Memory_ordering.\n+  __asm__ __volatile__(\"\" : : : \"memory\");\n+}\n+#define LEVELDB_HAVE_MEMORY_BARRIER\n+\n+// Sun Studio\n+#elif defined(ARCH_CPU_X86_FAMILY) && defined(__SUNPRO_CC)\n+inline void MemoryBarrier() {\n+  // See http://gcc.gnu.org/ml/gcc/2003-04/msg01180.html for a discussion on\n+  // this idiom. Also see http://en.wikipedia.org/wiki/Memory_ordering.\n+  asm volatile(\"\" : : : \"memory\");\n+}\n+#define LEVELDB_HAVE_MEMORY_BARRIER\n+\n+// Mac OS\n+#elif defined(OS_MACOSX)\n+inline void MemoryBarrier() {\n+  OSMemoryBarrier();\n+}\n+#define LEVELDB_HAVE_MEMORY_BARRIER\n+\n+// ARM Linux\n+#elif defined(ARCH_CPU_ARM_FAMILY) && defined(__linux__)\n+typedef void (*LinuxKernelMemoryBarrierFunc)(void);\n+// The Linux ARM kernel provides a highly optimized device-specific memory\n+// barrier function at a fixed memory address that is mapped in every\n+// user-level process.\n+//\n+// This beats using CPU-specific instructions which are, on single-core\n+// devices, un-necessary and very costly (e.g. ARMv7-A \"dmb\" takes more\n+// than 180ns on a Cortex-A8 like the one on a Nexus One). Benchmarking\n+// shows that the extra function call cost is completely negligible on\n+// multi-core devices.\n+//\n+inline void MemoryBarrier() {\n+  (*(LinuxKernelMemoryBarrierFunc)0xffff0fa0)();\n+}\n+#define LEVELDB_HAVE_MEMORY_BARRIER\n+\n+#endif\n+\n+// AtomicPointer built using platform-specific MemoryBarrier()\n+#if defined(LEVELDB_HAVE_MEMORY_BARRIER)\n+class AtomicPointer {\n+ private:\n+  void* rep_;\n+ public:\n+  AtomicPointer() { }\n+  explicit AtomicPointer(void* p) : rep_(p) {}\n+  inline void* NoBarrier_Load() const { return rep_; }\n+  inline void NoBarrier_Store(void* v) { rep_ = v; }\n+  inline void* Acquire_Load() const {\n+    void* result = rep_;\n+    MemoryBarrier();\n+    return result;\n+  }\n+  inline void Release_Store(void* v) {\n+    MemoryBarrier();\n+    rep_ = v;\n+  }\n+};\n+\n+// AtomicPointer based on <cstdatomic>\n+#elif defined(LEVELDB_CSTDATOMIC_PRESENT)\n+class AtomicPointer {\n+ private:\n+  std::atomic<void*> rep_;\n+ public:\n+  AtomicPointer() { }\n+  explicit AtomicPointer(void* v) : rep_(v) { }\n+  inline void* Acquire_Load() const {\n+    return rep_.load(std::memory_order_acquire);\n+  }\n+  inline void Release_Store(void* v) {\n+    rep_.store(v, std::memory_order_release);\n+  }\n+  inline void* NoBarrier_Load() const {\n+    return rep_.load(std::memory_order_relaxed);\n+  }\n+  inline void NoBarrier_Store(void* v) {\n+    rep_.store(v, std::memory_order_relaxed);\n+  }\n+};\n+\n+// We have neither MemoryBarrier(), nor <cstdatomic>\n+#else\n+#error Please implement AtomicPointer for this platform.\n+\n+#endif\n+\n+#undef LEVELDB_HAVE_MEMORY_BARRIER\n+#undef ARCH_CPU_X86_FAMILY\n+#undef ARCH_CPU_ARM_FAMILY\n+\n+}  // namespace port\n+}  // namespace leveldb\n+\n+#endif  // PORT_ATOMIC_POINTER_H_"
      },
      {
        "sha": "e667db40d0d5046da2d68d45f1e83f8529cefa4e",
        "filename": "src/leveldb/port/port.h",
        "status": "added",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/port/port.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/port/port.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/port.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,19 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#ifndef STORAGE_LEVELDB_PORT_PORT_H_\n+#define STORAGE_LEVELDB_PORT_PORT_H_\n+\n+#include <string.h>\n+\n+// Include the appropriate platform specific file below.  If you are\n+// porting to a new platform, see \"port_example.h\" for documentation\n+// of what the new port_<platform>.h file must provide.\n+#if defined(LEVELDB_PLATFORM_POSIX)\n+#  include \"port/port_posix.h\"\n+#elif defined(LEVELDB_PLATFORM_CHROMIUM)\n+#  include \"port/port_chromium.h\"\n+#endif\n+\n+#endif  // STORAGE_LEVELDB_PORT_PORT_H_"
      },
      {
        "sha": "ab9e489b32d8eb4ec8a43da07a20ad917fb35a1b",
        "filename": "src/leveldb/port/port_example.h",
        "status": "added",
        "additions": 135,
        "deletions": 0,
        "changes": 135,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/port/port_example.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/port/port_example.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/port_example.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,135 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+//\n+// This file contains the specification, but not the implementations,\n+// of the types/operations/etc. that should be defined by a platform\n+// specific port_<platform>.h file.  Use this file as a reference for\n+// how to port this package to a new platform.\n+\n+#ifndef STORAGE_LEVELDB_PORT_PORT_EXAMPLE_H_\n+#define STORAGE_LEVELDB_PORT_PORT_EXAMPLE_H_\n+\n+namespace leveldb {\n+namespace port {\n+\n+// TODO(jorlow): Many of these belong more in the environment class rather than\n+//               here. We should try moving them and see if it affects perf.\n+\n+// The following boolean constant must be true on a little-endian machine\n+// and false otherwise.\n+static const bool kLittleEndian = true /* or some other expression */;\n+\n+// ------------------ Threading -------------------\n+\n+// A Mutex represents an exclusive lock.\n+class Mutex {\n+ public:\n+  Mutex();\n+  ~Mutex();\n+\n+  // Lock the mutex.  Waits until other lockers have exited.\n+  // Will deadlock if the mutex is already locked by this thread.\n+  void Lock();\n+\n+  // Unlock the mutex.\n+  // REQUIRES: This mutex was locked by this thread.\n+  void Unlock();\n+\n+  // Optionally crash if this thread does not hold this mutex.\n+  // The implementation must be fast, especially if NDEBUG is\n+  // defined.  The implementation is allowed to skip all checks.\n+  void AssertHeld();\n+};\n+\n+class CondVar {\n+ public:\n+  explicit CondVar(Mutex* mu);\n+  ~CondVar();\n+\n+  // Atomically release *mu and block on this condition variable until\n+  // either a call to SignalAll(), or a call to Signal() that picks\n+  // this thread to wakeup.\n+  // REQUIRES: this thread holds *mu\n+  void Wait();\n+\n+  // If there are some threads waiting, wake up at least one of them.\n+  void Signal();\n+\n+  // Wake up all waiting threads.\n+  void SignallAll();\n+};\n+\n+// Thread-safe initialization.\n+// Used as follows:\n+//      static port::OnceType init_control = LEVELDB_ONCE_INIT;\n+//      static void Initializer() { ... do something ...; }\n+//      ...\n+//      port::InitOnce(&init_control, &Initializer);\n+typedef intptr_t OnceType;\n+#define LEVELDB_ONCE_INIT 0\n+extern void InitOnce(port::OnceType*, void (*initializer)());\n+\n+// A type that holds a pointer that can be read or written atomically\n+// (i.e., without word-tearing.)\n+class AtomicPointer {\n+ private:\n+  intptr_t rep_;\n+ public:\n+  // Initialize to arbitrary value\n+  AtomicPointer();\n+\n+  // Initialize to hold v\n+  explicit AtomicPointer(void* v) : rep_(v) { }\n+\n+  // Read and return the stored pointer with the guarantee that no\n+  // later memory access (read or write) by this thread can be\n+  // reordered ahead of this read.\n+  void* Acquire_Load() const;\n+\n+  // Set v as the stored pointer with the guarantee that no earlier\n+  // memory access (read or write) by this thread can be reordered\n+  // after this store.\n+  void Release_Store(void* v);\n+\n+  // Read the stored pointer with no ordering guarantees.\n+  void* NoBarrier_Load() const;\n+\n+  // Set va as the stored pointer with no ordering guarantees.\n+  void NoBarrier_Store(void* v);\n+};\n+\n+// ------------------ Compression -------------------\n+\n+// Store the snappy compression of \"input[0,input_length-1]\" in *output.\n+// Returns false if snappy is not supported by this port.\n+extern bool Snappy_Compress(const char* input, size_t input_length,\n+                            std::string* output);\n+\n+// If input[0,input_length-1] looks like a valid snappy compressed\n+// buffer, store the size of the uncompressed data in *result and\n+// return true.  Else return false.\n+extern bool Snappy_GetUncompressedLength(const char* input, size_t length,\n+                                         size_t* result);\n+\n+// Attempt to snappy uncompress input[0,input_length-1] into *output.\n+// Returns true if successful, false if the input is invalid lightweight\n+// compressed data.\n+//\n+// REQUIRES: at least the first \"n\" bytes of output[] must be writable\n+// where \"n\" is the result of a successful call to\n+// Snappy_GetUncompressedLength.\n+extern bool Snappy_Uncompress(const char* input_data, size_t input_length,\n+                              char* output);\n+\n+// ------------------ Miscellaneous -------------------\n+\n+// If heap profiling is not supported, returns false.\n+// Else repeatedly calls (*func)(arg, data, n) and then returns true.\n+// The concatenation of all \"data[0,n-1]\" fragments is the heap profile.\n+extern bool GetHeapProfile(void (*func)(void*, const char*, int), void* arg);\n+\n+}  // namespace port\n+}  // namespace leveldb\n+\n+#endif  // STORAGE_LEVELDB_PORT_PORT_EXAMPLE_H_"
      },
      {
        "sha": "5ba127a5b91bfa036189aa29ee2aeb9b02a034d8",
        "filename": "src/leveldb/port/port_posix.cc",
        "status": "added",
        "additions": 54,
        "deletions": 0,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/port/port_posix.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/port/port_posix.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/port_posix.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,54 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include \"port/port_posix.h\"\n+\n+#include <cstdlib>\n+#include <stdio.h>\n+#include <string.h>\n+#include \"util/logging.h\"\n+\n+namespace leveldb {\n+namespace port {\n+\n+static void PthreadCall(const char* label, int result) {\n+  if (result != 0) {\n+    fprintf(stderr, \"pthread %s: %s\\n\", label, strerror(result));\n+    abort();\n+  }\n+}\n+\n+Mutex::Mutex() { PthreadCall(\"init mutex\", pthread_mutex_init(&mu_, NULL)); }\n+\n+Mutex::~Mutex() { PthreadCall(\"destroy mutex\", pthread_mutex_destroy(&mu_)); }\n+\n+void Mutex::Lock() { PthreadCall(\"lock\", pthread_mutex_lock(&mu_)); }\n+\n+void Mutex::Unlock() { PthreadCall(\"unlock\", pthread_mutex_unlock(&mu_)); }\n+\n+CondVar::CondVar(Mutex* mu)\n+    : mu_(mu) {\n+    PthreadCall(\"init cv\", pthread_cond_init(&cv_, NULL));\n+}\n+\n+CondVar::~CondVar() { PthreadCall(\"destroy cv\", pthread_cond_destroy(&cv_)); }\n+\n+void CondVar::Wait() {\n+  PthreadCall(\"wait\", pthread_cond_wait(&cv_, &mu_->mu_));\n+}\n+\n+void CondVar::Signal() {\n+  PthreadCall(\"signal\", pthread_cond_signal(&cv_));\n+}\n+\n+void CondVar::SignalAll() {\n+  PthreadCall(\"broadcast\", pthread_cond_broadcast(&cv_));\n+}\n+\n+void InitOnce(OnceType* once, void (*initializer)()) {\n+  PthreadCall(\"once\", pthread_once(once, initializer));\n+}\n+\n+}  // namespace port\n+}  // namespace leveldb"
      },
      {
        "sha": "654a4b9d3d354e6128b4ee13065bab13fd98f7e9",
        "filename": "src/leveldb/port/port_posix.h",
        "status": "added",
        "additions": 144,
        "deletions": 0,
        "changes": 144,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/port/port_posix.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/port/port_posix.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/port_posix.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,144 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+//\n+// See port_example.h for documentation for the following types/functions.\n+\n+#ifndef STORAGE_LEVELDB_PORT_PORT_POSIX_H_\n+#define STORAGE_LEVELDB_PORT_PORT_POSIX_H_\n+\n+#undef PLATFORM_IS_LITTLE_ENDIAN\n+#if defined(OS_MACOSX)\n+  #include <machine/endian.h>\n+  #if defined(__DARWIN_LITTLE_ENDIAN) && defined(__DARWIN_BYTE_ORDER)\n+    #define PLATFORM_IS_LITTLE_ENDIAN \\\n+        (__DARWIN_BYTE_ORDER == __DARWIN_LITTLE_ENDIAN)\n+  #endif\n+#elif defined(OS_SOLARIS)\n+  #include <sys/isa_defs.h>\n+  #ifdef _LITTLE_ENDIAN\n+    #define PLATFORM_IS_LITTLE_ENDIAN true\n+  #else\n+    #define PLATFORM_IS_LITTLE_ENDIAN false\n+  #endif\n+#elif defined(OS_FREEBSD) || defined(OS_OPENBSD) || defined(OS_NETBSD) ||\\\n+      defined(OS_DRAGONFLYBSD) || defined(OS_ANDROID)\n+  #include <sys/types.h>\n+  #include <sys/endian.h>\n+#else\n+  #include <endian.h>\n+#endif\n+#include <pthread.h>\n+#ifdef SNAPPY\n+#include <snappy.h>\n+#endif\n+#include <stdint.h>\n+#include <string>\n+#include \"port/atomic_pointer.h\"\n+\n+#ifndef PLATFORM_IS_LITTLE_ENDIAN\n+#define PLATFORM_IS_LITTLE_ENDIAN (__BYTE_ORDER == __LITTLE_ENDIAN)\n+#endif\n+\n+#if defined(OS_MACOSX) || defined(OS_SOLARIS) || defined(OS_FREEBSD) ||\\\n+    defined(OS_NETBSD) || defined(OS_OPENBSD) || defined(OS_DRAGONFLYBSD) ||\\\n+    defined(OS_ANDROID)\n+// Use fread/fwrite/fflush on platforms without _unlocked variants\n+#define fread_unlocked fread\n+#define fwrite_unlocked fwrite\n+#define fflush_unlocked fflush\n+#endif\n+\n+#if defined(OS_MACOSX) || defined(OS_FREEBSD) ||\\\n+    defined(OS_OPENBSD) || defined(OS_DRAGONFLYBSD)\n+// Use fsync() on platforms without fdatasync()\n+#define fdatasync fsync\n+#endif\n+\n+#if defined(OS_ANDROID) && __ANDROID_API__ < 9\n+// fdatasync() was only introduced in API level 9 on Android. Use fsync()\n+// when targetting older platforms.\n+#define fdatasync fsync\n+#endif\n+\n+namespace leveldb {\n+namespace port {\n+\n+static const bool kLittleEndian = PLATFORM_IS_LITTLE_ENDIAN;\n+#undef PLATFORM_IS_LITTLE_ENDIAN\n+\n+class CondVar;\n+\n+class Mutex {\n+ public:\n+  Mutex();\n+  ~Mutex();\n+\n+  void Lock();\n+  void Unlock();\n+  void AssertHeld() { }\n+\n+ private:\n+  friend class CondVar;\n+  pthread_mutex_t mu_;\n+\n+  // No copying\n+  Mutex(const Mutex&);\n+  void operator=(const Mutex&);\n+};\n+\n+class CondVar {\n+ public:\n+  explicit CondVar(Mutex* mu);\n+  ~CondVar();\n+  void Wait();\n+  void Signal();\n+  void SignalAll();\n+ private:\n+  pthread_cond_t cv_;\n+  Mutex* mu_;\n+};\n+\n+typedef pthread_once_t OnceType;\n+#define LEVELDB_ONCE_INIT PTHREAD_ONCE_INIT\n+extern void InitOnce(OnceType* once, void (*initializer)());\n+\n+inline bool Snappy_Compress(const char* input, size_t length,\n+                            ::std::string* output) {\n+#ifdef SNAPPY\n+  output->resize(snappy::MaxCompressedLength(length));\n+  size_t outlen;\n+  snappy::RawCompress(input, length, &(*output)[0], &outlen);\n+  output->resize(outlen);\n+  return true;\n+#endif\n+\n+  return false;\n+}\n+\n+inline bool Snappy_GetUncompressedLength(const char* input, size_t length,\n+                                         size_t* result) {\n+#ifdef SNAPPY\n+  return snappy::GetUncompressedLength(input, length, result);\n+#else\n+  return false;\n+#endif\n+}\n+\n+inline bool Snappy_Uncompress(const char* input, size_t length,\n+                              char* output) {\n+#ifdef SNAPPY\n+  return snappy::RawUncompress(input, length, output);\n+#else\n+  return false;\n+#endif\n+}\n+\n+inline bool GetHeapProfile(void (*func)(void*, const char*, int), void* arg) {\n+  return false;\n+}\n+\n+} // namespace port\n+} // namespace leveldb\n+\n+#endif  // STORAGE_LEVELDB_PORT_PORT_POSIX_H_"
      },
      {
        "sha": "39edd0db13f436dc57dd28ed4013ab4d55a28a31",
        "filename": "src/leveldb/port/win/stdint.h",
        "status": "added",
        "additions": 24,
        "deletions": 0,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/port/win/stdint.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/port/win/stdint.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/win/stdint.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,24 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+// MSVC didn't ship with this file until the 2010 version.\n+\n+#ifndef STORAGE_LEVELDB_PORT_WIN_STDINT_H_\n+#define STORAGE_LEVELDB_PORT_WIN_STDINT_H_\n+\n+#if !defined(_MSC_VER)\n+#error This file should only be included when compiling with MSVC.\n+#endif\n+\n+// Define C99 equivalent types.\n+typedef signed char           int8_t;\n+typedef signed short          int16_t;\n+typedef signed int            int32_t;\n+typedef signed long long      int64_t;\n+typedef unsigned char         uint8_t;\n+typedef unsigned short        uint16_t;\n+typedef unsigned int          uint32_t;\n+typedef unsigned long long    uint64_t;\n+\n+#endif  // STORAGE_LEVELDB_PORT_WIN_STDINT_H_"
      },
      {
        "sha": "199d453773ae1d915fb5fe8763312e85cd2b9f9f",
        "filename": "src/leveldb/table/block.cc",
        "status": "added",
        "additions": 267,
        "deletions": 0,
        "changes": 267,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/table/block.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/table/block.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/table/block.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,267 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+//\n+// Decodes the blocks generated by block_builder.cc.\n+\n+#include \"table/block.h\"\n+\n+#include <vector>\n+#include <algorithm>\n+#include \"leveldb/comparator.h\"\n+#include \"table/format.h\"\n+#include \"util/coding.h\"\n+#include \"util/logging.h\"\n+\n+namespace leveldb {\n+\n+inline uint32_t Block::NumRestarts() const {\n+  assert(size_ >= 2*sizeof(uint32_t));\n+  return DecodeFixed32(data_ + size_ - sizeof(uint32_t));\n+}\n+\n+Block::Block(const BlockContents& contents)\n+    : data_(contents.data.data()),\n+      size_(contents.data.size()),\n+      owned_(contents.heap_allocated) {\n+  if (size_ < sizeof(uint32_t)) {\n+    size_ = 0;  // Error marker\n+  } else {\n+    restart_offset_ = size_ - (1 + NumRestarts()) * sizeof(uint32_t);\n+    if (restart_offset_ > size_ - sizeof(uint32_t)) {\n+      // The size is too small for NumRestarts() and therefore\n+      // restart_offset_ wrapped around.\n+      size_ = 0;\n+    }\n+  }\n+}\n+\n+Block::~Block() {\n+  if (owned_) {\n+    delete[] data_;\n+  }\n+}\n+\n+// Helper routine: decode the next block entry starting at \"p\",\n+// storing the number of shared key bytes, non_shared key bytes,\n+// and the length of the value in \"*shared\", \"*non_shared\", and\n+// \"*value_length\", respectively.  Will not derefence past \"limit\".\n+//\n+// If any errors are detected, returns NULL.  Otherwise, returns a\n+// pointer to the key delta (just past the three decoded values).\n+static inline const char* DecodeEntry(const char* p, const char* limit,\n+                                      uint32_t* shared,\n+                                      uint32_t* non_shared,\n+                                      uint32_t* value_length) {\n+  if (limit - p < 3) return NULL;\n+  *shared = reinterpret_cast<const unsigned char*>(p)[0];\n+  *non_shared = reinterpret_cast<const unsigned char*>(p)[1];\n+  *value_length = reinterpret_cast<const unsigned char*>(p)[2];\n+  if ((*shared | *non_shared | *value_length) < 128) {\n+    // Fast path: all three values are encoded in one byte each\n+    p += 3;\n+  } else {\n+    if ((p = GetVarint32Ptr(p, limit, shared)) == NULL) return NULL;\n+    if ((p = GetVarint32Ptr(p, limit, non_shared)) == NULL) return NULL;\n+    if ((p = GetVarint32Ptr(p, limit, value_length)) == NULL) return NULL;\n+  }\n+\n+  if (static_cast<uint32_t>(limit - p) < (*non_shared + *value_length)) {\n+    return NULL;\n+  }\n+  return p;\n+}\n+\n+class Block::Iter : public Iterator {\n+ private:\n+  const Comparator* const comparator_;\n+  const char* const data_;      // underlying block contents\n+  uint32_t const restarts_;     // Offset of restart array (list of fixed32)\n+  uint32_t const num_restarts_; // Number of uint32_t entries in restart array\n+\n+  // current_ is offset in data_ of current entry.  >= restarts_ if !Valid\n+  uint32_t current_;\n+  uint32_t restart_index_;  // Index of restart block in which current_ falls\n+  std::string key_;\n+  Slice value_;\n+  Status status_;\n+\n+  inline int Compare(const Slice& a, const Slice& b) const {\n+    return comparator_->Compare(a, b);\n+  }\n+\n+  // Return the offset in data_ just past the end of the current entry.\n+  inline uint32_t NextEntryOffset() const {\n+    return (value_.data() + value_.size()) - data_;\n+  }\n+\n+  uint32_t GetRestartPoint(uint32_t index) {\n+    assert(index < num_restarts_);\n+    return DecodeFixed32(data_ + restarts_ + index * sizeof(uint32_t));\n+  }\n+\n+  void SeekToRestartPoint(uint32_t index) {\n+    key_.clear();\n+    restart_index_ = index;\n+    // current_ will be fixed by ParseNextKey();\n+\n+    // ParseNextKey() starts at the end of value_, so set value_ accordingly\n+    uint32_t offset = GetRestartPoint(index);\n+    value_ = Slice(data_ + offset, 0);\n+  }\n+\n+ public:\n+  Iter(const Comparator* comparator,\n+       const char* data,\n+       uint32_t restarts,\n+       uint32_t num_restarts)\n+      : comparator_(comparator),\n+        data_(data),\n+        restarts_(restarts),\n+        num_restarts_(num_restarts),\n+        current_(restarts_),\n+        restart_index_(num_restarts_) {\n+    assert(num_restarts_ > 0);\n+  }\n+\n+  virtual bool Valid() const { return current_ < restarts_; }\n+  virtual Status status() const { return status_; }\n+  virtual Slice key() const {\n+    assert(Valid());\n+    return key_;\n+  }\n+  virtual Slice value() const {\n+    assert(Valid());\n+    return value_;\n+  }\n+\n+  virtual void Next() {\n+    assert(Valid());\n+    ParseNextKey();\n+  }\n+\n+  virtual void Prev() {\n+    assert(Valid());\n+\n+    // Scan backwards to a restart point before current_\n+    const uint32_t original = current_;\n+    while (GetRestartPoint(restart_index_) >= original) {\n+      if (restart_index_ == 0) {\n+        // No more entries\n+        current_ = restarts_;\n+        restart_index_ = num_restarts_;\n+        return;\n+      }\n+      restart_index_--;\n+    }\n+\n+    SeekToRestartPoint(restart_index_);\n+    do {\n+      // Loop until end of current entry hits the start of original entry\n+    } while (ParseNextKey() && NextEntryOffset() < original);\n+  }\n+\n+  virtual void Seek(const Slice& target) {\n+    // Binary search in restart array to find the first restart point\n+    // with a key >= target\n+    uint32_t left = 0;\n+    uint32_t right = num_restarts_ - 1;\n+    while (left < right) {\n+      uint32_t mid = (left + right + 1) / 2;\n+      uint32_t region_offset = GetRestartPoint(mid);\n+      uint32_t shared, non_shared, value_length;\n+      const char* key_ptr = DecodeEntry(data_ + region_offset,\n+                                        data_ + restarts_,\n+                                        &shared, &non_shared, &value_length);\n+      if (key_ptr == NULL || (shared != 0)) {\n+        CorruptionError();\n+        return;\n+      }\n+      Slice mid_key(key_ptr, non_shared);\n+      if (Compare(mid_key, target) < 0) {\n+        // Key at \"mid\" is smaller than \"target\".  Therefore all\n+        // blocks before \"mid\" are uninteresting.\n+        left = mid;\n+      } else {\n+        // Key at \"mid\" is >= \"target\".  Therefore all blocks at or\n+        // after \"mid\" are uninteresting.\n+        right = mid - 1;\n+      }\n+    }\n+\n+    // Linear search (within restart block) for first key >= target\n+    SeekToRestartPoint(left);\n+    while (true) {\n+      if (!ParseNextKey()) {\n+        return;\n+      }\n+      if (Compare(key_, target) >= 0) {\n+        return;\n+      }\n+    }\n+  }\n+\n+  virtual void SeekToFirst() {\n+    SeekToRestartPoint(0);\n+    ParseNextKey();\n+  }\n+\n+  virtual void SeekToLast() {\n+    SeekToRestartPoint(num_restarts_ - 1);\n+    while (ParseNextKey() && NextEntryOffset() < restarts_) {\n+      // Keep skipping\n+    }\n+  }\n+\n+ private:\n+  void CorruptionError() {\n+    current_ = restarts_;\n+    restart_index_ = num_restarts_;\n+    status_ = Status::Corruption(\"bad entry in block\");\n+    key_.clear();\n+    value_.clear();\n+  }\n+\n+  bool ParseNextKey() {\n+    current_ = NextEntryOffset();\n+    const char* p = data_ + current_;\n+    const char* limit = data_ + restarts_;  // Restarts come right after data\n+    if (p >= limit) {\n+      // No more entries to return.  Mark as invalid.\n+      current_ = restarts_;\n+      restart_index_ = num_restarts_;\n+      return false;\n+    }\n+\n+    // Decode next entry\n+    uint32_t shared, non_shared, value_length;\n+    p = DecodeEntry(p, limit, &shared, &non_shared, &value_length);\n+    if (p == NULL || key_.size() < shared) {\n+      CorruptionError();\n+      return false;\n+    } else {\n+      key_.resize(shared);\n+      key_.append(p, non_shared);\n+      value_ = Slice(p + non_shared, value_length);\n+      while (restart_index_ + 1 < num_restarts_ &&\n+             GetRestartPoint(restart_index_ + 1) < current_) {\n+        ++restart_index_;\n+      }\n+      return true;\n+    }\n+  }\n+};\n+\n+Iterator* Block::NewIterator(const Comparator* cmp) {\n+  if (size_ < 2*sizeof(uint32_t)) {\n+    return NewErrorIterator(Status::Corruption(\"bad block contents\"));\n+  }\n+  const uint32_t num_restarts = NumRestarts();\n+  if (num_restarts == 0) {\n+    return NewEmptyIterator();\n+  } else {\n+    return new Iter(cmp, data_, restart_offset_, num_restarts);\n+  }\n+}\n+\n+}  // namespace leveldb"
      },
      {
        "sha": "2493eb9f9fd9da41aafcac80180c3f831928a32d",
        "filename": "src/leveldb/table/block.h",
        "status": "added",
        "additions": 44,
        "deletions": 0,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/table/block.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/table/block.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/table/block.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,44 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#ifndef STORAGE_LEVELDB_TABLE_BLOCK_H_\n+#define STORAGE_LEVELDB_TABLE_BLOCK_H_\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+#include \"leveldb/iterator.h\"\n+\n+namespace leveldb {\n+\n+struct BlockContents;\n+class Comparator;\n+\n+class Block {\n+ public:\n+  // Initialize the block with the specified contents.\n+  explicit Block(const BlockContents& contents);\n+\n+  ~Block();\n+\n+  size_t size() const { return size_; }\n+  Iterator* NewIterator(const Comparator* comparator);\n+\n+ private:\n+  uint32_t NumRestarts() const;\n+\n+  const char* data_;\n+  size_t size_;\n+  uint32_t restart_offset_;     // Offset in data_ of restart array\n+  bool owned_;                  // Block owns data_[]\n+\n+  // No copying allowed\n+  Block(const Block&);\n+  void operator=(const Block&);\n+\n+  class Iter;\n+};\n+\n+}  // namespace leveldb\n+\n+#endif  // STORAGE_LEVELDB_TABLE_BLOCK_H_"
      },
      {
        "sha": "db660cd07cf50ad1b54310c21b22108ab6994802",
        "filename": "src/leveldb/table/block_builder.cc",
        "status": "added",
        "additions": 109,
        "deletions": 0,
        "changes": 109,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/table/block_builder.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/table/block_builder.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/table/block_builder.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,109 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+//\n+// BlockBuilder generates blocks where keys are prefix-compressed:\n+//\n+// When we store a key, we drop the prefix shared with the previous\n+// string.  This helps reduce the space requirement significantly.\n+// Furthermore, once every K keys, we do not apply the prefix\n+// compression and store the entire key.  We call this a \"restart\n+// point\".  The tail end of the block stores the offsets of all of the\n+// restart points, and can be used to do a binary search when looking\n+// for a particular key.  Values are stored as-is (without compression)\n+// immediately following the corresponding key.\n+//\n+// An entry for a particular key-value pair has the form:\n+//     shared_bytes: varint32\n+//     unshared_bytes: varint32\n+//     value_length: varint32\n+//     key_delta: char[unshared_bytes]\n+//     value: char[value_length]\n+// shared_bytes == 0 for restart points.\n+//\n+// The trailer of the block has the form:\n+//     restarts: uint32[num_restarts]\n+//     num_restarts: uint32\n+// restarts[i] contains the offset within the block of the ith restart point.\n+\n+#include \"table/block_builder.h\"\n+\n+#include <algorithm>\n+#include <assert.h>\n+#include \"leveldb/comparator.h\"\n+#include \"leveldb/table_builder.h\"\n+#include \"util/coding.h\"\n+\n+namespace leveldb {\n+\n+BlockBuilder::BlockBuilder(const Options* options)\n+    : options_(options),\n+      restarts_(),\n+      counter_(0),\n+      finished_(false) {\n+  assert(options->block_restart_interval >= 1);\n+  restarts_.push_back(0);       // First restart point is at offset 0\n+}\n+\n+void BlockBuilder::Reset() {\n+  buffer_.clear();\n+  restarts_.clear();\n+  restarts_.push_back(0);       // First restart point is at offset 0\n+  counter_ = 0;\n+  finished_ = false;\n+  last_key_.clear();\n+}\n+\n+size_t BlockBuilder::CurrentSizeEstimate() const {\n+  return (buffer_.size() +                        // Raw data buffer\n+          restarts_.size() * sizeof(uint32_t) +   // Restart array\n+          sizeof(uint32_t));                      // Restart array length\n+}\n+\n+Slice BlockBuilder::Finish() {\n+  // Append restart array\n+  for (size_t i = 0; i < restarts_.size(); i++) {\n+    PutFixed32(&buffer_, restarts_[i]);\n+  }\n+  PutFixed32(&buffer_, restarts_.size());\n+  finished_ = true;\n+  return Slice(buffer_);\n+}\n+\n+void BlockBuilder::Add(const Slice& key, const Slice& value) {\n+  Slice last_key_piece(last_key_);\n+  assert(!finished_);\n+  assert(counter_ <= options_->block_restart_interval);\n+  assert(buffer_.empty() // No values yet?\n+         || options_->comparator->Compare(key, last_key_piece) > 0);\n+  size_t shared = 0;\n+  if (counter_ < options_->block_restart_interval) {\n+    // See how much sharing to do with previous string\n+    const size_t min_length = std::min(last_key_piece.size(), key.size());\n+    while ((shared < min_length) && (last_key_piece[shared] == key[shared])) {\n+      shared++;\n+    }\n+  } else {\n+    // Restart compression\n+    restarts_.push_back(buffer_.size());\n+    counter_ = 0;\n+  }\n+  const size_t non_shared = key.size() - shared;\n+\n+  // Add \"<shared><non_shared><value_size>\" to buffer_\n+  PutVarint32(&buffer_, shared);\n+  PutVarint32(&buffer_, non_shared);\n+  PutVarint32(&buffer_, value.size());\n+\n+  // Add string delta to buffer_ followed by value\n+  buffer_.append(key.data() + shared, non_shared);\n+  buffer_.append(value.data(), value.size());\n+\n+  // Update state\n+  last_key_.resize(shared);\n+  last_key_.append(key.data() + shared, non_shared);\n+  assert(Slice(last_key_) == key);\n+  counter_++;\n+}\n+\n+}  // namespace leveldb"
      },
      {
        "sha": "5b545bd1afb4f4e65c36d8430dde09e0f543259f",
        "filename": "src/leveldb/table/block_builder.h",
        "status": "added",
        "additions": 57,
        "deletions": 0,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/table/block_builder.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/table/block_builder.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/table/block_builder.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,57 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#ifndef STORAGE_LEVELDB_TABLE_BLOCK_BUILDER_H_\n+#define STORAGE_LEVELDB_TABLE_BLOCK_BUILDER_H_\n+\n+#include <vector>\n+\n+#include <stdint.h>\n+#include \"leveldb/slice.h\"\n+\n+namespace leveldb {\n+\n+struct Options;\n+\n+class BlockBuilder {\n+ public:\n+  explicit BlockBuilder(const Options* options);\n+\n+  // Reset the contents as if the BlockBuilder was just constructed.\n+  void Reset();\n+\n+  // REQUIRES: Finish() has not been callled since the last call to Reset().\n+  // REQUIRES: key is larger than any previously added key\n+  void Add(const Slice& key, const Slice& value);\n+\n+  // Finish building the block and return a slice that refers to the\n+  // block contents.  The returned slice will remain valid for the\n+  // lifetime of this builder or until Reset() is called.\n+  Slice Finish();\n+\n+  // Returns an estimate of the current (uncompressed) size of the block\n+  // we are building.\n+  size_t CurrentSizeEstimate() const;\n+\n+  // Return true iff no entries have been added since the last Reset()\n+  bool empty() const {\n+    return buffer_.empty();\n+  }\n+\n+ private:\n+  const Options*        options_;\n+  std::string           buffer_;      // Destination buffer\n+  std::vector<uint32_t> restarts_;    // Restart points\n+  int                   counter_;     // Number of entries emitted since restart\n+  bool                  finished_;    // Has Finish() been called?\n+  std::string           last_key_;\n+\n+  // No copying allowed\n+  BlockBuilder(const BlockBuilder&);\n+  void operator=(const BlockBuilder&);\n+};\n+\n+}  // namespace leveldb\n+\n+#endif  // STORAGE_LEVELDB_TABLE_BLOCK_BUILDER_H_"
      },
      {
        "sha": "203e15c8bcb13b8776842052a725ad2a3909fcf5",
        "filename": "src/leveldb/table/filter_block.cc",
        "status": "added",
        "additions": 111,
        "deletions": 0,
        "changes": 111,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/table/filter_block.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/table/filter_block.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/table/filter_block.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,111 @@\n+// Copyright (c) 2012 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include \"table/filter_block.h\"\n+\n+#include \"leveldb/filter_policy.h\"\n+#include \"util/coding.h\"\n+\n+namespace leveldb {\n+\n+// See doc/table_format.txt for an explanation of the filter block format.\n+\n+// Generate new filter every 2KB of data\n+static const size_t kFilterBaseLg = 11;\n+static const size_t kFilterBase = 1 << kFilterBaseLg;\n+\n+FilterBlockBuilder::FilterBlockBuilder(const FilterPolicy* policy)\n+    : policy_(policy) {\n+}\n+\n+void FilterBlockBuilder::StartBlock(uint64_t block_offset) {\n+  uint64_t filter_index = (block_offset / kFilterBase);\n+  assert(filter_index >= filter_offsets_.size());\n+  while (filter_index > filter_offsets_.size()) {\n+    GenerateFilter();\n+  }\n+}\n+\n+void FilterBlockBuilder::AddKey(const Slice& key) {\n+  Slice k = key;\n+  start_.push_back(keys_.size());\n+  keys_.append(k.data(), k.size());\n+}\n+\n+Slice FilterBlockBuilder::Finish() {\n+  if (!start_.empty()) {\n+    GenerateFilter();\n+  }\n+\n+  // Append array of per-filter offsets\n+  const uint32_t array_offset = result_.size();\n+  for (size_t i = 0; i < filter_offsets_.size(); i++) {\n+    PutFixed32(&result_, filter_offsets_[i]);\n+  }\n+\n+  PutFixed32(&result_, array_offset);\n+  result_.push_back(kFilterBaseLg);  // Save encoding parameter in result\n+  return Slice(result_);\n+}\n+\n+void FilterBlockBuilder::GenerateFilter() {\n+  const size_t num_keys = start_.size();\n+  if (num_keys == 0) {\n+    // Fast path if there are no keys for this filter\n+    filter_offsets_.push_back(result_.size());\n+    return;\n+  }\n+\n+  // Make list of keys from flattened key structure\n+  start_.push_back(keys_.size());  // Simplify length computation\n+  tmp_keys_.resize(num_keys);\n+  for (size_t i = 0; i < num_keys; i++) {\n+    const char* base = keys_.data() + start_[i];\n+    size_t length = start_[i+1] - start_[i];\n+    tmp_keys_[i] = Slice(base, length);\n+  }\n+\n+  // Generate filter for current set of keys and append to result_.\n+  filter_offsets_.push_back(result_.size());\n+  policy_->CreateFilter(&tmp_keys_[0], num_keys, &result_);\n+\n+  tmp_keys_.clear();\n+  keys_.clear();\n+  start_.clear();\n+}\n+\n+FilterBlockReader::FilterBlockReader(const FilterPolicy* policy,\n+                                     const Slice& contents)\n+    : policy_(policy),\n+      data_(NULL),\n+      offset_(NULL),\n+      num_(0),\n+      base_lg_(0) {\n+  size_t n = contents.size();\n+  if (n < 5) return;  // 1 byte for base_lg_ and 4 for start of offset array\n+  base_lg_ = contents[n-1];\n+  uint32_t last_word = DecodeFixed32(contents.data() + n - 5);\n+  if (last_word > n - 5) return;\n+  data_ = contents.data();\n+  offset_ = data_ + last_word;\n+  num_ = (n - 5 - last_word) / 4;\n+}\n+\n+bool FilterBlockReader::KeyMayMatch(uint64_t block_offset, const Slice& key) {\n+  uint64_t index = block_offset >> base_lg_;\n+  if (index < num_) {\n+    uint32_t start = DecodeFixed32(offset_ + index*4);\n+    uint32_t limit = DecodeFixed32(offset_ + index*4 + 4);\n+    if (start <= limit && limit <= (offset_ - data_)) {\n+      Slice filter = Slice(data_ + start, limit - start);\n+      return policy_->KeyMayMatch(key, filter);\n+    } else if (start == limit) {\n+      // Empty filters do not match any keys\n+      return false;\n+    }\n+  }\n+  return true;  // Errors are treated as potential matches\n+}\n+\n+}"
      },
      {
        "sha": "c67d010bd106756c456dea013c5babdf0a18494f",
        "filename": "src/leveldb/table/filter_block.h",
        "status": "added",
        "additions": 68,
        "deletions": 0,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/table/filter_block.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/table/filter_block.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/table/filter_block.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,68 @@\n+// Copyright (c) 2012 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+//\n+// A filter block is stored near the end of a Table file.  It contains\n+// filters (e.g., bloom filters) for all data blocks in the table combined\n+// into a single filter block.\n+\n+#ifndef STORAGE_LEVELDB_TABLE_FILTER_BLOCK_H_\n+#define STORAGE_LEVELDB_TABLE_FILTER_BLOCK_H_\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+#include <string>\n+#include <vector>\n+#include \"leveldb/slice.h\"\n+#include \"util/hash.h\"\n+\n+namespace leveldb {\n+\n+class FilterPolicy;\n+\n+// A FilterBlockBuilder is used to construct all of the filters for a\n+// particular Table.  It generates a single string which is stored as\n+// a special block in the Table.\n+//\n+// The sequence of calls to FilterBlockBuilder must match the regexp:\n+//      (StartBlock AddKey*)* Finish\n+class FilterBlockBuilder {\n+ public:\n+  explicit FilterBlockBuilder(const FilterPolicy*);\n+\n+  void StartBlock(uint64_t block_offset);\n+  void AddKey(const Slice& key);\n+  Slice Finish();\n+\n+ private:\n+  void GenerateFilter();\n+\n+  const FilterPolicy* policy_;\n+  std::string keys_;              // Flattened key contents\n+  std::vector<size_t> start_;     // Starting index in keys_ of each key\n+  std::string result_;            // Filter data computed so far\n+  std::vector<Slice> tmp_keys_;   // policy_->CreateFilter() argument\n+  std::vector<uint32_t> filter_offsets_;\n+\n+  // No copying allowed\n+  FilterBlockBuilder(const FilterBlockBuilder&);\n+  void operator=(const FilterBlockBuilder&);\n+};\n+\n+class FilterBlockReader {\n+ public:\n+ // REQUIRES: \"contents\" and *policy must stay live while *this is live.\n+  FilterBlockReader(const FilterPolicy* policy, const Slice& contents);\n+  bool KeyMayMatch(uint64_t block_offset, const Slice& key);\n+\n+ private:\n+  const FilterPolicy* policy_;\n+  const char* data_;    // Pointer to filter data (at block-start)\n+  const char* offset_;  // Pointer to beginning of offset array (at block-end)\n+  size_t num_;          // Number of entries in offset array\n+  size_t base_lg_;      // Encoding parameter (see kFilterBaseLg in .cc file)\n+};\n+\n+}\n+\n+#endif  // STORAGE_LEVELDB_TABLE_FILTER_BLOCK_H_"
      },
      {
        "sha": "3a2a07cf53ca606b2d0e9890e6b9cfa02a678398",
        "filename": "src/leveldb/table/filter_block_test.cc",
        "status": "added",
        "additions": 128,
        "deletions": 0,
        "changes": 128,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/table/filter_block_test.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/table/filter_block_test.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/table/filter_block_test.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,128 @@\n+// Copyright (c) 2012 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include \"table/filter_block.h\"\n+\n+#include \"leveldb/filter_policy.h\"\n+#include \"util/coding.h\"\n+#include \"util/hash.h\"\n+#include \"util/logging.h\"\n+#include \"util/testharness.h\"\n+#include \"util/testutil.h\"\n+\n+namespace leveldb {\n+\n+// For testing: emit an array with one hash value per key\n+class TestHashFilter : public FilterPolicy {\n+ public:\n+  virtual const char* Name() const {\n+    return \"TestHashFilter\";\n+  }\n+\n+  virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const {\n+    for (int i = 0; i < n; i++) {\n+      uint32_t h = Hash(keys[i].data(), keys[i].size(), 1);\n+      PutFixed32(dst, h);\n+    }\n+  }\n+\n+  virtual bool KeyMayMatch(const Slice& key, const Slice& filter) const {\n+    uint32_t h = Hash(key.data(), key.size(), 1);\n+    for (int i = 0; i + 4 <= filter.size(); i += 4) {\n+      if (h == DecodeFixed32(filter.data() + i)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+};\n+\n+class FilterBlockTest {\n+ public:\n+  TestHashFilter policy_;\n+};\n+\n+TEST(FilterBlockTest, EmptyBuilder) {\n+  FilterBlockBuilder builder(&policy_);\n+  Slice block = builder.Finish();\n+  ASSERT_EQ(\"\\\\x00\\\\x00\\\\x00\\\\x00\\\\x0b\", EscapeString(block));\n+  FilterBlockReader reader(&policy_, block);\n+  ASSERT_TRUE(reader.KeyMayMatch(0, \"foo\"));\n+  ASSERT_TRUE(reader.KeyMayMatch(100000, \"foo\"));\n+}\n+\n+TEST(FilterBlockTest, SingleChunk) {\n+  FilterBlockBuilder builder(&policy_);\n+  builder.StartBlock(100);\n+  builder.AddKey(\"foo\");\n+  builder.AddKey(\"bar\");\n+  builder.AddKey(\"box\");\n+  builder.StartBlock(200);\n+  builder.AddKey(\"box\");\n+  builder.StartBlock(300);\n+  builder.AddKey(\"hello\");\n+  Slice block = builder.Finish();\n+  FilterBlockReader reader(&policy_, block);\n+  ASSERT_TRUE(reader.KeyMayMatch(100, \"foo\"));\n+  ASSERT_TRUE(reader.KeyMayMatch(100, \"bar\"));\n+  ASSERT_TRUE(reader.KeyMayMatch(100, \"box\"));\n+  ASSERT_TRUE(reader.KeyMayMatch(100, \"hello\"));\n+  ASSERT_TRUE(reader.KeyMayMatch(100, \"foo\"));\n+  ASSERT_TRUE(! reader.KeyMayMatch(100, \"missing\"));\n+  ASSERT_TRUE(! reader.KeyMayMatch(100, \"other\"));\n+}\n+\n+TEST(FilterBlockTest, MultiChunk) {\n+  FilterBlockBuilder builder(&policy_);\n+\n+  // First filter\n+  builder.StartBlock(0);\n+  builder.AddKey(\"foo\");\n+  builder.StartBlock(2000);\n+  builder.AddKey(\"bar\");\n+\n+  // Second filter\n+  builder.StartBlock(3100);\n+  builder.AddKey(\"box\");\n+\n+  // Third filter is empty\n+\n+  // Last filter\n+  builder.StartBlock(9000);\n+  builder.AddKey(\"box\");\n+  builder.AddKey(\"hello\");\n+\n+  Slice block = builder.Finish();\n+  FilterBlockReader reader(&policy_, block);\n+\n+  // Check first filter\n+  ASSERT_TRUE(reader.KeyMayMatch(0, \"foo\"));\n+  ASSERT_TRUE(reader.KeyMayMatch(2000, \"bar\"));\n+  ASSERT_TRUE(! reader.KeyMayMatch(0, \"box\"));\n+  ASSERT_TRUE(! reader.KeyMayMatch(0, \"hello\"));\n+\n+  // Check second filter\n+  ASSERT_TRUE(reader.KeyMayMatch(3100, \"box\"));\n+  ASSERT_TRUE(! reader.KeyMayMatch(3100, \"foo\"));\n+  ASSERT_TRUE(! reader.KeyMayMatch(3100, \"bar\"));\n+  ASSERT_TRUE(! reader.KeyMayMatch(3100, \"hello\"));\n+\n+  // Check third filter (empty)\n+  ASSERT_TRUE(! reader.KeyMayMatch(4100, \"foo\"));\n+  ASSERT_TRUE(! reader.KeyMayMatch(4100, \"bar\"));\n+  ASSERT_TRUE(! reader.KeyMayMatch(4100, \"box\"));\n+  ASSERT_TRUE(! reader.KeyMayMatch(4100, \"hello\"));\n+\n+  // Check last filter\n+  ASSERT_TRUE(reader.KeyMayMatch(9000, \"box\"));\n+  ASSERT_TRUE(reader.KeyMayMatch(9000, \"hello\"));\n+  ASSERT_TRUE(! reader.KeyMayMatch(9000, \"foo\"));\n+  ASSERT_TRUE(! reader.KeyMayMatch(9000, \"bar\"));\n+}\n+\n+}  // namespace leveldb\n+\n+int main(int argc, char** argv) {\n+  return leveldb::test::RunAllTests();\n+}"
      },
      {
        "sha": "cda1decdf35476ecd5c44d7f3a8e69111e620124",
        "filename": "src/leveldb/table/format.cc",
        "status": "added",
        "additions": 145,
        "deletions": 0,
        "changes": 145,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/table/format.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/table/format.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/table/format.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,145 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include \"table/format.h\"\n+\n+#include \"leveldb/env.h\"\n+#include \"port/port.h\"\n+#include \"table/block.h\"\n+#include \"util/coding.h\"\n+#include \"util/crc32c.h\"\n+\n+namespace leveldb {\n+\n+void BlockHandle::EncodeTo(std::string* dst) const {\n+  // Sanity check that all fields have been set\n+  assert(offset_ != ~static_cast<uint64_t>(0));\n+  assert(size_ != ~static_cast<uint64_t>(0));\n+  PutVarint64(dst, offset_);\n+  PutVarint64(dst, size_);\n+}\n+\n+Status BlockHandle::DecodeFrom(Slice* input) {\n+  if (GetVarint64(input, &offset_) &&\n+      GetVarint64(input, &size_)) {\n+    return Status::OK();\n+  } else {\n+    return Status::Corruption(\"bad block handle\");\n+  }\n+}\n+\n+void Footer::EncodeTo(std::string* dst) const {\n+#ifndef NDEBUG\n+  const size_t original_size = dst->size();\n+#endif\n+  metaindex_handle_.EncodeTo(dst);\n+  index_handle_.EncodeTo(dst);\n+  dst->resize(2 * BlockHandle::kMaxEncodedLength);  // Padding\n+  PutFixed32(dst, static_cast<uint32_t>(kTableMagicNumber & 0xffffffffu));\n+  PutFixed32(dst, static_cast<uint32_t>(kTableMagicNumber >> 32));\n+  assert(dst->size() == original_size + kEncodedLength);\n+}\n+\n+Status Footer::DecodeFrom(Slice* input) {\n+  const char* magic_ptr = input->data() + kEncodedLength - 8;\n+  const uint32_t magic_lo = DecodeFixed32(magic_ptr);\n+  const uint32_t magic_hi = DecodeFixed32(magic_ptr + 4);\n+  const uint64_t magic = ((static_cast<uint64_t>(magic_hi) << 32) |\n+                          (static_cast<uint64_t>(magic_lo)));\n+  if (magic != kTableMagicNumber) {\n+    return Status::InvalidArgument(\"not an sstable (bad magic number)\");\n+  }\n+\n+  Status result = metaindex_handle_.DecodeFrom(input);\n+  if (result.ok()) {\n+    result = index_handle_.DecodeFrom(input);\n+  }\n+  if (result.ok()) {\n+    // We skip over any leftover data (just padding for now) in \"input\"\n+    const char* end = magic_ptr + 8;\n+    *input = Slice(end, input->data() + input->size() - end);\n+  }\n+  return result;\n+}\n+\n+Status ReadBlock(RandomAccessFile* file,\n+                 const ReadOptions& options,\n+                 const BlockHandle& handle,\n+                 BlockContents* result) {\n+  result->data = Slice();\n+  result->cachable = false;\n+  result->heap_allocated = false;\n+\n+  // Read the block contents as well as the type/crc footer.\n+  // See table_builder.cc for the code that built this structure.\n+  size_t n = static_cast<size_t>(handle.size());\n+  char* buf = new char[n + kBlockTrailerSize];\n+  Slice contents;\n+  Status s = file->Read(handle.offset(), n + kBlockTrailerSize, &contents, buf);\n+  if (!s.ok()) {\n+    delete[] buf;\n+    return s;\n+  }\n+  if (contents.size() != n + kBlockTrailerSize) {\n+    delete[] buf;\n+    return Status::Corruption(\"truncated block read\");\n+  }\n+\n+  // Check the crc of the type and the block contents\n+  const char* data = contents.data();    // Pointer to where Read put the data\n+  if (options.verify_checksums) {\n+    const uint32_t crc = crc32c::Unmask(DecodeFixed32(data + n + 1));\n+    const uint32_t actual = crc32c::Value(data, n + 1);\n+    if (actual != crc) {\n+      delete[] buf;\n+      s = Status::Corruption(\"block checksum mismatch\");\n+      return s;\n+    }\n+  }\n+\n+  switch (data[n]) {\n+    case kNoCompression:\n+      if (data != buf) {\n+        // File implementation gave us pointer to some other data.\n+        // Use it directly under the assumption that it will be live\n+        // while the file is open.\n+        delete[] buf;\n+        result->data = Slice(data, n);\n+        result->heap_allocated = false;\n+        result->cachable = false;  // Do not double-cache\n+      } else {\n+        result->data = Slice(buf, n);\n+        result->heap_allocated = true;\n+        result->cachable = true;\n+      }\n+\n+      // Ok\n+      break;\n+    case kSnappyCompression: {\n+      size_t ulength = 0;\n+      if (!port::Snappy_GetUncompressedLength(data, n, &ulength)) {\n+        delete[] buf;\n+        return Status::Corruption(\"corrupted compressed block contents\");\n+      }\n+      char* ubuf = new char[ulength];\n+      if (!port::Snappy_Uncompress(data, n, ubuf)) {\n+        delete[] buf;\n+        delete[] ubuf;\n+        return Status::Corruption(\"corrupted compressed block contents\");\n+      }\n+      delete[] buf;\n+      result->data = Slice(ubuf, ulength);\n+      result->heap_allocated = true;\n+      result->cachable = true;\n+      break;\n+    }\n+    default:\n+      delete[] buf;\n+      return Status::Corruption(\"bad block type\");\n+  }\n+\n+  return Status::OK();\n+}\n+\n+}  // namespace leveldb"
      },
      {
        "sha": "6c0b80c0179c7fffbf6ee2af802a10ec02d73998",
        "filename": "src/leveldb/table/format.h",
        "status": "added",
        "additions": 108,
        "deletions": 0,
        "changes": 108,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/table/format.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/table/format.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/table/format.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,108 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#ifndef STORAGE_LEVELDB_TABLE_FORMAT_H_\n+#define STORAGE_LEVELDB_TABLE_FORMAT_H_\n+\n+#include <string>\n+#include <stdint.h>\n+#include \"leveldb/slice.h\"\n+#include \"leveldb/status.h\"\n+#include \"leveldb/table_builder.h\"\n+\n+namespace leveldb {\n+\n+class Block;\n+class RandomAccessFile;\n+struct ReadOptions;\n+\n+// BlockHandle is a pointer to the extent of a file that stores a data\n+// block or a meta block.\n+class BlockHandle {\n+ public:\n+  BlockHandle();\n+\n+  // The offset of the block in the file.\n+  uint64_t offset() const { return offset_; }\n+  void set_offset(uint64_t offset) { offset_ = offset; }\n+\n+  // The size of the stored block\n+  uint64_t size() const { return size_; }\n+  void set_size(uint64_t size) { size_ = size; }\n+\n+  void EncodeTo(std::string* dst) const;\n+  Status DecodeFrom(Slice* input);\n+\n+  // Maximum encoding length of a BlockHandle\n+  enum { kMaxEncodedLength = 10 + 10 };\n+\n+ private:\n+  uint64_t offset_;\n+  uint64_t size_;\n+};\n+\n+// Footer encapsulates the fixed information stored at the tail\n+// end of every table file.\n+class Footer {\n+ public:\n+  Footer() { }\n+\n+  // The block handle for the metaindex block of the table\n+  const BlockHandle& metaindex_handle() const { return metaindex_handle_; }\n+  void set_metaindex_handle(const BlockHandle& h) { metaindex_handle_ = h; }\n+\n+  // The block handle for the index block of the table\n+  const BlockHandle& index_handle() const {\n+    return index_handle_;\n+  }\n+  void set_index_handle(const BlockHandle& h) {\n+    index_handle_ = h;\n+  }\n+\n+  void EncodeTo(std::string* dst) const;\n+  Status DecodeFrom(Slice* input);\n+\n+  // Encoded length of a Footer.  Note that the serialization of a\n+  // Footer will always occupy exactly this many bytes.  It consists\n+  // of two block handles and a magic number.\n+  enum {\n+    kEncodedLength = 2*BlockHandle::kMaxEncodedLength + 8\n+  };\n+\n+ private:\n+  BlockHandle metaindex_handle_;\n+  BlockHandle index_handle_;\n+};\n+\n+// kTableMagicNumber was picked by running\n+//    echo http://code.google.com/p/leveldb/ | sha1sum\n+// and taking the leading 64 bits.\n+static const uint64_t kTableMagicNumber = 0xdb4775248b80fb57ull;\n+\n+// 1-byte type + 32-bit crc\n+static const size_t kBlockTrailerSize = 5;\n+\n+struct BlockContents {\n+  Slice data;           // Actual contents of data\n+  bool cachable;        // True iff data can be cached\n+  bool heap_allocated;  // True iff caller should delete[] data.data()\n+};\n+\n+// Read the block identified by \"handle\" from \"file\".  On failure\n+// return non-OK.  On success fill *result and return OK.\n+extern Status ReadBlock(RandomAccessFile* file,\n+                        const ReadOptions& options,\n+                        const BlockHandle& handle,\n+                        BlockContents* result);\n+\n+// Implementation details follow.  Clients should ignore,\n+\n+inline BlockHandle::BlockHandle()\n+    : offset_(~static_cast<uint64_t>(0)),\n+      size_(~static_cast<uint64_t>(0)) {\n+}\n+\n+}  // namespace leveldb\n+\n+#endif  // STORAGE_LEVELDB_TABLE_FORMAT_H_"
      },
      {
        "sha": "3d1c87fdece73d4c1ef16a0a762f70059b9443e6",
        "filename": "src/leveldb/table/iterator.cc",
        "status": "added",
        "additions": 67,
        "deletions": 0,
        "changes": 67,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/table/iterator.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/table/iterator.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/table/iterator.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,67 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include \"leveldb/iterator.h\"\n+\n+namespace leveldb {\n+\n+Iterator::Iterator() {\n+  cleanup_.function = NULL;\n+  cleanup_.next = NULL;\n+}\n+\n+Iterator::~Iterator() {\n+  if (cleanup_.function != NULL) {\n+    (*cleanup_.function)(cleanup_.arg1, cleanup_.arg2);\n+    for (Cleanup* c = cleanup_.next; c != NULL; ) {\n+      (*c->function)(c->arg1, c->arg2);\n+      Cleanup* next = c->next;\n+      delete c;\n+      c = next;\n+    }\n+  }\n+}\n+\n+void Iterator::RegisterCleanup(CleanupFunction func, void* arg1, void* arg2) {\n+  assert(func != NULL);\n+  Cleanup* c;\n+  if (cleanup_.function == NULL) {\n+    c = &cleanup_;\n+  } else {\n+    c = new Cleanup;\n+    c->next = cleanup_.next;\n+    cleanup_.next = c;\n+  }\n+  c->function = func;\n+  c->arg1 = arg1;\n+  c->arg2 = arg2;\n+}\n+\n+namespace {\n+class EmptyIterator : public Iterator {\n+ public:\n+  EmptyIterator(const Status& s) : status_(s) { }\n+  virtual bool Valid() const { return false; }\n+  virtual void Seek(const Slice& target) { }\n+  virtual void SeekToFirst() { }\n+  virtual void SeekToLast() { }\n+  virtual void Next() { assert(false); }\n+  virtual void Prev() { assert(false); }\n+  Slice key() const { assert(false); return Slice(); }\n+  Slice value() const { assert(false); return Slice(); }\n+  virtual Status status() const { return status_; }\n+ private:\n+  Status status_;\n+};\n+}  // namespace\n+\n+Iterator* NewEmptyIterator() {\n+  return new EmptyIterator(Status::OK());\n+}\n+\n+Iterator* NewErrorIterator(const Status& status) {\n+  return new EmptyIterator(status);\n+}\n+\n+}  // namespace leveldb"
      },
      {
        "sha": "9e16b3dbedebe65f36fbbfa9e180fd1fa80e84a3",
        "filename": "src/leveldb/table/iterator_wrapper.h",
        "status": "added",
        "additions": 63,
        "deletions": 0,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/table/iterator_wrapper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/table/iterator_wrapper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/table/iterator_wrapper.h?ref=398e837e8da881e4d3f13da83590626ae76bb977",
        "patch": "@@ -0,0 +1,63 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#ifndef STORAGE_LEVELDB_TABLE_ITERATOR_WRAPPER_H_\n+#define STORAGE_LEVELDB_TABLE_ITERATOR_WRAPPER_H_\n+\n+namespace leveldb {\n+\n+// A internal wrapper class with an interface similar to Iterator that\n+// caches the valid() and key() results for an underlying iterator.\n+// This can help avoid virtual function calls and also gives better\n+// cache locality.\n+class IteratorWrapper {\n+ public:\n+  IteratorWrapper(): iter_(NULL), valid_(false) { }\n+  explicit IteratorWrapper(Iterator* iter): iter_(NULL) {\n+    Set(iter);\n+  }\n+  ~IteratorWrapper() { delete iter_; }\n+  Iterator* iter() const { return iter_; }\n+\n+  // Takes ownership of \"iter\" and will delete it when destroyed, or\n+  // when Set() is invoked again.\n+  void Set(Iterator* iter) {\n+    delete iter_;\n+    iter_ = iter;\n+    if (iter_ == NULL) {\n+      valid_ = false;\n+    } else {\n+      Update();\n+    }\n+  }\n+\n+\n+  // Iterator interface methods\n+  bool Valid() const        { return valid_; }\n+  Slice key() const         { assert(Valid()); return key_; }\n+  Slice value() const       { assert(Valid()); return iter_->value(); }\n+  // Methods below require iter() != NULL\n+  Status status() const     { assert(iter_); return iter_->status(); }\n+  void Next()               { assert(iter_); iter_->Next();        Update(); }\n+  void Prev()               { assert(iter_); iter_->Prev();        Update(); }\n+  void Seek(const Slice& k) { assert(iter_); iter_->Seek(k);       Update(); }\n+  void SeekToFirst()        { assert(iter_); iter_->SeekToFirst(); Update(); }\n+  void SeekToLast()         { assert(iter_); iter_->SeekToLast();  Update(); }\n+\n+ private:\n+  void Update() {\n+    valid_ = iter_->Valid();\n+    if (valid_) {\n+      key_ = iter_->key();\n+    }\n+  }\n+\n+  Iterator* iter_;\n+  bool valid_;\n+  Slice key_;\n+};\n+\n+}  // namespace leveldb\n+\n+#endif  // STORAGE_LEVELDB_TABLE_ITERATOR_WRAPPER_H_"
      },
      {
        "sha": "2dde4dc21fde9d86e98f5a3f3b493745d07a22f7",
        "filename": "src/leveldb/table/merger.cc",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/table/merger.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/table/merger.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/table/merger.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "91ddd80faa35bfcf7edb81ee2f22ed3f29b58f98",
        "filename": "src/leveldb/table/merger.h",
        "status": "added",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/table/merger.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/table/merger.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/table/merger.h?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "dbd6d3a1bf0867e285dd53207876605cca3bcf07",
        "filename": "src/leveldb/table/table.cc",
        "status": "added",
        "additions": 276,
        "deletions": 0,
        "changes": 276,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/table/table.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/table/table.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/table/table.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "62002c84f2b18f479fdb1cd3ab142c179e1f3a6f",
        "filename": "src/leveldb/table/table_builder.cc",
        "status": "added",
        "additions": 270,
        "deletions": 0,
        "changes": 270,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/table/table_builder.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/table/table_builder.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/table/table_builder.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "57cea25334e07501748b5fdac5a8872b89d31f1e",
        "filename": "src/leveldb/table/table_test.cc",
        "status": "added",
        "additions": 838,
        "deletions": 0,
        "changes": 838,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/table/table_test.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/table/table_test.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/table/table_test.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "7822ebab9c32ce579c42f9621545d7283e8332b9",
        "filename": "src/leveldb/table/two_level_iterator.cc",
        "status": "added",
        "additions": 182,
        "deletions": 0,
        "changes": 182,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/table/two_level_iterator.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/table/two_level_iterator.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/table/two_level_iterator.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "629ca34525414582e39df8ad7a48eff72e0e450f",
        "filename": "src/leveldb/table/two_level_iterator.h",
        "status": "added",
        "additions": 34,
        "deletions": 0,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/table/two_level_iterator.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/table/two_level_iterator.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/table/two_level_iterator.h?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "9551d6a3a27c8c2bd13cc7e48882aaecdb75ba20",
        "filename": "src/leveldb/util/arena.cc",
        "status": "added",
        "additions": 68,
        "deletions": 0,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/arena.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/arena.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/arena.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "8f7dde226c450745646f29986d0302630db6f1f5",
        "filename": "src/leveldb/util/arena.h",
        "status": "added",
        "additions": 68,
        "deletions": 0,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/arena.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/arena.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/arena.h?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "63d1778034550a7394029df41d6b24f9053f5663",
        "filename": "src/leveldb/util/arena_test.cc",
        "status": "added",
        "additions": 68,
        "deletions": 0,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/arena_test.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/arena_test.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/arena_test.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "d7941cd21fab64079cbef1f62060a48f0d86c74d",
        "filename": "src/leveldb/util/bloom.cc",
        "status": "added",
        "additions": 95,
        "deletions": 0,
        "changes": 95,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/bloom.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/bloom.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/bloom.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "4a6ea1b7c8e51d84cecad00b66662888e396ff38",
        "filename": "src/leveldb/util/bloom_test.cc",
        "status": "added",
        "additions": 159,
        "deletions": 0,
        "changes": 159,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/bloom_test.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/bloom_test.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/bloom_test.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "24f1f63f4f00289bed9ac700e5643e1ff626d099",
        "filename": "src/leveldb/util/cache.cc",
        "status": "added",
        "additions": 328,
        "deletions": 0,
        "changes": 328,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/cache.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/cache.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/cache.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "43716715a89f476700845c303e1651448ecef62c",
        "filename": "src/leveldb/util/cache_test.cc",
        "status": "added",
        "additions": 186,
        "deletions": 0,
        "changes": 186,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/cache_test.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/cache_test.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/cache_test.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "dbd7a6545c6b98ec21958b3fc56194d0d1531589",
        "filename": "src/leveldb/util/coding.cc",
        "status": "added",
        "additions": 194,
        "deletions": 0,
        "changes": 194,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/coding.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/coding.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/coding.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "3993c4a755dfa5a0f8b966f1a698a371fa08556d",
        "filename": "src/leveldb/util/coding.h",
        "status": "added",
        "additions": 104,
        "deletions": 0,
        "changes": 104,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/coding.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/coding.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/coding.h?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "2c52b17b602b8dc1cb36bd49d2bafeabd4a35af1",
        "filename": "src/leveldb/util/coding_test.cc",
        "status": "added",
        "additions": 196,
        "deletions": 0,
        "changes": 196,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/coding_test.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/coding_test.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/coding_test.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "4b7b5724ef3be5f6c7ed9f95dcb47a99f2ee2f9b",
        "filename": "src/leveldb/util/comparator.cc",
        "status": "added",
        "additions": 81,
        "deletions": 0,
        "changes": 81,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/comparator.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/comparator.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/comparator.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "6db9e770774d7ebc0b0c3bc4a230b5b8254cd1f4",
        "filename": "src/leveldb/util/crc32c.cc",
        "status": "added",
        "additions": 332,
        "deletions": 0,
        "changes": 332,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/crc32c.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/crc32c.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/crc32c.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "1d7e5c075d86d6cf2551cfcd0fd9ac5adce6fc38",
        "filename": "src/leveldb/util/crc32c.h",
        "status": "added",
        "additions": 45,
        "deletions": 0,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/crc32c.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/crc32c.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/crc32c.h?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "4b957ee120c8f805c0240d3d90eaf16a759437ba",
        "filename": "src/leveldb/util/crc32c_test.cc",
        "status": "added",
        "additions": 72,
        "deletions": 0,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/crc32c_test.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/crc32c_test.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/crc32c_test.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "c2600e964a260c87f22afc8c5a3e7788b4c7e350",
        "filename": "src/leveldb/util/env.cc",
        "status": "added",
        "additions": 96,
        "deletions": 0,
        "changes": 96,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/env.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/env.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/env.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "cb1f6fc05a1316d486f4c2dbd728afb32d6a1ab9",
        "filename": "src/leveldb/util/env_posix.cc",
        "status": "added",
        "additions": 609,
        "deletions": 0,
        "changes": 609,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/env_posix.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/env_posix.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/env_posix.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "b72cb4438425bca83d9a6ca0d207dbc8590efb2e",
        "filename": "src/leveldb/util/env_test.cc",
        "status": "added",
        "additions": 104,
        "deletions": 0,
        "changes": 104,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/env_test.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/env_test.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/env_test.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "7b045c8c91d6f6d600308e50966ccf56e53638bf",
        "filename": "src/leveldb/util/filter_policy.cc",
        "status": "added",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/filter_policy.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/filter_policy.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/filter_policy.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "ba1818082dff90aa6475bb272fa25ee0c22d6292",
        "filename": "src/leveldb/util/hash.cc",
        "status": "added",
        "additions": 45,
        "deletions": 0,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/hash.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/hash.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/hash.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "8889d56be80e2f6342a1a292c6a0075d2481de80",
        "filename": "src/leveldb/util/hash.h",
        "status": "added",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/hash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/hash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/hash.h?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "bb95f583eac6a6f916a83e409045f0a226bd9ae7",
        "filename": "src/leveldb/util/histogram.cc",
        "status": "added",
        "additions": 139,
        "deletions": 0,
        "changes": 139,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/histogram.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/histogram.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/histogram.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "1ef9f3c8abdfc50858be433110611086bb3c0da6",
        "filename": "src/leveldb/util/histogram.h",
        "status": "added",
        "additions": 42,
        "deletions": 0,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/histogram.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/histogram.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/histogram.h?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "22cf2785123c45ab77fa158256a45d8e700c1463",
        "filename": "src/leveldb/util/logging.cc",
        "status": "added",
        "additions": 81,
        "deletions": 0,
        "changes": 81,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/logging.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/logging.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/logging.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "b0c5da813e8658c9712b5529f4b219cb1a945508",
        "filename": "src/leveldb/util/logging.h",
        "status": "added",
        "additions": 47,
        "deletions": 0,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/logging.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/logging.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/logging.h?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "c3f3306d3e0f07853cd7426ade453448f6bea811",
        "filename": "src/leveldb/util/mutexlock.h",
        "status": "added",
        "additions": 39,
        "deletions": 0,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/mutexlock.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/mutexlock.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/mutexlock.h?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "76af5b9302d437d9847b2a93c87697232d027cac",
        "filename": "src/leveldb/util/options.cc",
        "status": "added",
        "additions": 29,
        "deletions": 0,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/options.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/options.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/options.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "9741b1afad930844f2ff047d244a4863e8c01613",
        "filename": "src/leveldb/util/posix_logger.h",
        "status": "added",
        "additions": 98,
        "deletions": 0,
        "changes": 98,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/posix_logger.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/posix_logger.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/posix_logger.h?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "07538242ea559ad31396b994a5172f13ecb3d775",
        "filename": "src/leveldb/util/random.h",
        "status": "added",
        "additions": 59,
        "deletions": 0,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/random.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/random.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/random.h?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "a44f35b3149fa8fe88d9ca32dbf92fbb9f6d534c",
        "filename": "src/leveldb/util/status.cc",
        "status": "added",
        "additions": 75,
        "deletions": 0,
        "changes": 75,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/status.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/status.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/status.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "eb1bdd554a3ea2f06cd45053ab3df8c71c9610a8",
        "filename": "src/leveldb/util/testharness.cc",
        "status": "added",
        "additions": 77,
        "deletions": 0,
        "changes": 77,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/testharness.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/testharness.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/testharness.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "da4fe68bb4e76ee69af136d76f9417d349fa9605",
        "filename": "src/leveldb/util/testharness.h",
        "status": "added",
        "additions": 138,
        "deletions": 0,
        "changes": 138,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/testharness.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/testharness.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/testharness.h?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "538d09516d217d614ac45cefe38bb1503d3b1d5c",
        "filename": "src/leveldb/util/testutil.cc",
        "status": "added",
        "additions": 51,
        "deletions": 0,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/testutil.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/testutil.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/testutil.cc?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      },
      {
        "sha": "824e655bd2c5d7955aa83887966ad0f54fb77192",
        "filename": "src/leveldb/util/testutil.h",
        "status": "added",
        "additions": 53,
        "deletions": 0,
        "changes": 53,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/testutil.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398e837e8da881e4d3f13da83590626ae76bb977/src/leveldb/util/testutil.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/testutil.h?ref=398e837e8da881e4d3f13da83590626ae76bb977"
      }
    ]
  },
  {
    "sha": "d7b9500eedc9d4556744a80dc274f78521adbe60",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkN2I5NTAwZWVkYzlkNDU1Njc0NGE4MGRjMjc0Zjc4NTIxYWRiZTYw",
    "commit": {
      "author": {
        "name": "justmoon",
        "email": "justmoon@members.fsf.org",
        "date": "2012-07-21T12:54:55Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-19T23:55:51Z"
      },
      "message": "Leveldb Windows port by Edouard Alligand, adapted for MingW by me.",
      "tree": {
        "sha": "cb1deb528516ff8f9957f5086e237aa3bf160841",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cb1deb528516ff8f9957f5086e237aa3bf160841"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d7b9500eedc9d4556744a80dc274f78521adbe60",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d7b9500eedc9d4556744a80dc274f78521adbe60",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d7b9500eedc9d4556744a80dc274f78521adbe60",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d7b9500eedc9d4556744a80dc274f78521adbe60/comments",
    "author": {
      "login": "justmoon",
      "id": 53233,
      "node_id": "MDQ6VXNlcjUzMjMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/53233?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/justmoon",
      "html_url": "https://github.com/justmoon",
      "followers_url": "https://api.github.com/users/justmoon/followers",
      "following_url": "https://api.github.com/users/justmoon/following{/other_user}",
      "gists_url": "https://api.github.com/users/justmoon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/justmoon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/justmoon/subscriptions",
      "organizations_url": "https://api.github.com/users/justmoon/orgs",
      "repos_url": "https://api.github.com/users/justmoon/repos",
      "events_url": "https://api.github.com/users/justmoon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/justmoon/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "398e837e8da881e4d3f13da83590626ae76bb977",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/398e837e8da881e4d3f13da83590626ae76bb977",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/398e837e8da881e4d3f13da83590626ae76bb977"
      }
    ],
    "stats": {
      "total": 1139,
      "additions": 1106,
      "deletions": 33
    },
    "files": [
      {
        "sha": "7f658cfdf9754abf5780a3894b605a2e4994c2cc",
        "filename": "src/leveldb/Makefile",
        "status": "modified",
        "additions": 23,
        "deletions": 23,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d7b9500eedc9d4556744a80dc274f78521adbe60/src/leveldb/Makefile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d7b9500eedc9d4556744a80dc274f78521adbe60/src/leveldb/Makefile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/Makefile?ref=d7b9500eedc9d4556744a80dc274f78521adbe60",
        "patch": "@@ -82,7 +82,7 @@ $(SHARED2): $(SHARED3)\n endif\n \n $(SHARED3):\n-\t$(CXX) $(LDFLAGS) $(PLATFORM_SHARED_LDFLAGS)$(SHARED2) $(CXXFLAGS) $(PLATFORM_SHARED_CFLAGS) $(SOURCES) -o $(SHARED3)\n+\t$(CXX) $(LDFLAGS) $(PLATFORM_SHARED_LDFLAGS)$(SHARED2) $(CXXFLAGS) $(PLATFORM_SHARED_CFLAGS) $(SOURCES) $(PLATFORM_EXTRALIBS) -o $(SHARED3)\n \n endif  # PLATFORM_SHARED_EXT\n \n@@ -100,74 +100,74 @@ $(LIBRARY): $(LIBOBJECTS)\n \t$(AR) -rs $@ $(LIBOBJECTS)\n \n db_bench: db/db_bench.o $(LIBOBJECTS) $(TESTUTIL)\n-\t$(CXX) db/db_bench.o $(LIBOBJECTS) $(TESTUTIL) -o $@  $(LDFLAGS)\n+\t$(CXX) db/db_bench.o $(LIBOBJECTS) $(TESTUTIL) -o $@  $(LDFLAGS) $(PLATFORM_EXTRALIBS)\n \n db_bench_sqlite3: doc/bench/db_bench_sqlite3.o $(LIBOBJECTS) $(TESTUTIL)\n-\t$(CXX) doc/bench/db_bench_sqlite3.o $(LIBOBJECTS) $(TESTUTIL) -o $@ $(LDFLAGS) -lsqlite3\n+\t$(CXX) doc/bench/db_bench_sqlite3.o $(LIBOBJECTS) $(TESTUTIL) -o $@ $(LDFLAGS) $(PLATFORM_EXTRALIBS) -lsqlite3\n \n db_bench_tree_db: doc/bench/db_bench_tree_db.o $(LIBOBJECTS) $(TESTUTIL)\n-\t$(CXX) doc/bench/db_bench_tree_db.o $(LIBOBJECTS) $(TESTUTIL) -o $@ $(LDFLAGS) -lkyotocabinet\n+\t$(CXX) doc/bench/db_bench_tree_db.o $(LIBOBJECTS) $(TESTUTIL) -o $@ $(LDFLAGS) $(PLATFORM_EXTRALIBS) -lkyotocabinet\n \n arena_test: util/arena_test.o $(LIBOBJECTS) $(TESTHARNESS)\n-\t$(CXX) util/arena_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\t$(CXX) util/arena_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS) $(PLATFORM_EXTRALIBS)\n \n bloom_test: util/bloom_test.o $(LIBOBJECTS) $(TESTHARNESS)\n-\t$(CXX) util/bloom_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\t$(CXX) util/bloom_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS) $(PLATFORM_EXTRALIBS)\n \n c_test: db/c_test.o $(LIBOBJECTS) $(TESTHARNESS)\n-\t$(CXX) db/c_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\t$(CXX) db/c_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS) $(PLATFORM_EXTRALIBS)\n \n cache_test: util/cache_test.o $(LIBOBJECTS) $(TESTHARNESS)\n-\t$(CXX) util/cache_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\t$(CXX) util/cache_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS) $(PLATFORM_EXTRALIBS)\n \n coding_test: util/coding_test.o $(LIBOBJECTS) $(TESTHARNESS)\n-\t$(CXX) util/coding_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\t$(CXX) util/coding_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS) $(PLATFORM_EXTRALIBS)\n \n corruption_test: db/corruption_test.o $(LIBOBJECTS) $(TESTHARNESS)\n-\t$(CXX) db/corruption_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\t$(CXX) db/corruption_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS) $(PLATFORM_EXTRALIBS)\n \n crc32c_test: util/crc32c_test.o $(LIBOBJECTS) $(TESTHARNESS)\n-\t$(CXX) util/crc32c_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\t$(CXX) util/crc32c_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS) $(PLATFORM_EXTRALIBS)\n \n db_test: db/db_test.o $(LIBOBJECTS) $(TESTHARNESS)\n-\t$(CXX) db/db_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\t$(CXX) db/db_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS) $(PLATFORM_EXTRALIBS)\n \n dbformat_test: db/dbformat_test.o $(LIBOBJECTS) $(TESTHARNESS)\n-\t$(CXX) db/dbformat_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\t$(CXX) db/dbformat_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS) $(PLATFORM_EXTRALIBS)\n \n env_test: util/env_test.o $(LIBOBJECTS) $(TESTHARNESS)\n-\t$(CXX) util/env_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\t$(CXX) util/env_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS) $(PLATFORM_EXTRALIBS)\n \n filename_test: db/filename_test.o $(LIBOBJECTS) $(TESTHARNESS)\n-\t$(CXX) db/filename_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\t$(CXX) db/filename_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS) $(PLATFORM_EXTRALIBS)\n \n filter_block_test: table/filter_block_test.o $(LIBOBJECTS) $(TESTHARNESS)\n-\t$(CXX) table/filter_block_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\t$(CXX) table/filter_block_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS) $(PLATFORM_EXTRALIBS)\n \n log_test: db/log_test.o $(LIBOBJECTS) $(TESTHARNESS)\n-\t$(CXX) db/log_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\t$(CXX) db/log_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS) $(PLATFORM_EXTRALIBS)\n \n table_test: table/table_test.o $(LIBOBJECTS) $(TESTHARNESS)\n-\t$(CXX) table/table_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\t$(CXX) table/table_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS) $(PLATFORM_EXTRALIBS)\n \n skiplist_test: db/skiplist_test.o $(LIBOBJECTS) $(TESTHARNESS)\n-\t$(CXX) db/skiplist_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\t$(CXX) db/skiplist_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS) $(PLATFORM_EXTRALIBS)\n \n version_edit_test: db/version_edit_test.o $(LIBOBJECTS) $(TESTHARNESS)\n-\t$(CXX) db/version_edit_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\t$(CXX) db/version_edit_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS) $(PLATFORM_EXTRALIBS)\n \n version_set_test: db/version_set_test.o $(LIBOBJECTS) $(TESTHARNESS)\n-\t$(CXX) db/version_set_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\t$(CXX) db/version_set_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS) $(PLATFORM_EXTRALIBS)\n \n write_batch_test: db/write_batch_test.o $(LIBOBJECTS) $(TESTHARNESS)\n-\t$(CXX) db/write_batch_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\t$(CXX) db/write_batch_test.o $(LIBOBJECTS) $(TESTHARNESS) -o $@ $(LDFLAGS) $(PLATFORM_EXTRALIBS)\n \n $(MEMENVLIBRARY) : $(MEMENVOBJECTS)\n \trm -f $@\n \t$(AR) -rs $@ $(MEMENVOBJECTS)\n \n memenv_test : helpers/memenv/memenv_test.o $(MEMENVLIBRARY) $(LIBRARY) $(TESTHARNESS)\n-\t$(CXX) helpers/memenv/memenv_test.o $(MEMENVLIBRARY) $(LIBRARY) $(TESTHARNESS) -o $@ $(LDFLAGS)\n+\t$(CXX) helpers/memenv/memenv_test.o $(MEMENVLIBRARY) $(LIBRARY) $(TESTHARNESS) -o $@ $(LDFLAGS) $(PLATFORM_EXTRALIBS)\n \n ifeq ($(PLATFORM), IOS)\n # For iOS, create universal object files to be used on both the simulator and"
      },
      {
        "sha": "5a8d723734e2d81ee80cb22f2f989b4bc1063815",
        "filename": "src/leveldb/build_detect_platform",
        "status": "modified",
        "additions": 23,
        "deletions": 10,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d7b9500eedc9d4556744a80dc274f78521adbe60/src/leveldb/build_detect_platform",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d7b9500eedc9d4556744a80dc274f78521adbe60/src/leveldb/build_detect_platform",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/build_detect_platform?ref=d7b9500eedc9d4556744a80dc274f78521adbe60",
        "patch": "@@ -50,6 +50,8 @@ CROSS_COMPILE=\n PLATFORM_CCFLAGS=\n PLATFORM_CXXFLAGS=\n PLATFORM_LDFLAGS=\n+PLATFORM_EXTRALIBS=\n+PLATFORM_SOURCES=\n PLATFORM_SHARED_EXT=\"so\"\n PLATFORM_SHARED_LDFLAGS=\"-shared -Wl,-soname -Wl,\"\n PLATFORM_SHARED_CFLAGS=\"-fPIC\"\n@@ -62,49 +64,59 @@ case \"$TARGET_OS\" in\n         COMMON_FLAGS=\"-fno-builtin-memcmp -DOS_MACOSX\"\n         PLATFORM_SHARED_EXT=dylib\n         PLATFORM_SHARED_LDFLAGS=\"-dynamiclib -install_name \"\n-        PORT_FILE=port/port_posix.cc\n+        PLATFORM_SOURCES=\"port/port_posix.cc util/env_posix.cc\"\n         ;;\n     Linux)\n         PLATFORM=OS_LINUX\n         COMMON_FLAGS=\"-fno-builtin-memcmp -pthread -DOS_LINUX\"\n         PLATFORM_LDFLAGS=\"-pthread\"\n-        PORT_FILE=port/port_posix.cc\n+        PLATFORM_SOURCES=\"port/port_posix.cc util/env_posix.cc\"\n         ;;\n     SunOS)\n         PLATFORM=OS_SOLARIS\n         COMMON_FLAGS=\"-fno-builtin-memcmp -D_REENTRANT -DOS_SOLARIS\"\n         PLATFORM_LDFLAGS=\"-lpthread -lrt\"\n-        PORT_FILE=port/port_posix.cc\n+        PLATFORM_SOURCES=\"port/port_posix.cc util/env_posix.cc\"\n         ;;\n     FreeBSD)\n         PLATFORM=OS_FREEBSD\n         COMMON_FLAGS=\"-fno-builtin-memcmp -D_REENTRANT -DOS_FREEBSD\"\n         PLATFORM_LDFLAGS=\"-lpthread\"\n-        PORT_FILE=port/port_posix.cc\n+        PLATFORM_SOURCES=\"port/port_posix.cc util/env_posix.cc\"\n         ;;\n     NetBSD)\n         PLATFORM=OS_NETBSD\n         COMMON_FLAGS=\"-fno-builtin-memcmp -D_REENTRANT -DOS_NETBSD\"\n         PLATFORM_LDFLAGS=\"-lpthread -lgcc_s\"\n-        PORT_FILE=port/port_posix.cc\n+        PLATFORM_SOURCES=\"port/port_posix.cc util/env_posix.cc\"\n         ;;\n     OpenBSD)\n         PLATFORM=OS_OPENBSD\n         COMMON_FLAGS=\"-fno-builtin-memcmp -D_REENTRANT -DOS_OPENBSD\"\n         PLATFORM_LDFLAGS=\"-pthread\"\n-        PORT_FILE=port/port_posix.cc\n+        PLATFORM_SOURCES=\"port/port_posix.cc util/env_posix.cc\"\n         ;;\n     DragonFly)\n         PLATFORM=OS_DRAGONFLYBSD\n         COMMON_FLAGS=\"-fno-builtin-memcmp -D_REENTRANT -DOS_DRAGONFLYBSD\"\n         PLATFORM_LDFLAGS=\"-lpthread\"\n-        PORT_FILE=port/port_posix.cc\n+        PLATFORM_SOURCES=\"port/port_posix.cc util/env_posix.cc\"\n         ;;\n     OS_ANDROID_CROSSCOMPILE)\n         PLATFORM=OS_ANDROID\n         COMMON_FLAGS=\"-fno-builtin-memcmp -D_REENTRANT -DOS_ANDROID -DLEVELDB_PLATFORM_POSIX\"\n         PLATFORM_LDFLAGS=\"\"  # All pthread features are in the Android C library\n-        PORT_FILE=port/port_posix.cc\n+        PLATFORM_SOURCES=\"port/port_posix.cc util/env_posix.cc\"\n+        CROSS_COMPILE=true\n+        ;;\n+    OS_WINDOWS_CROSSCOMPILE)\n+        PLATFORM=OS_WINDOWS\n+        COMMON_FLAGS=\"-fno-builtin-memcmp -D_REENTRANT -DOS_WINDOWS -DLEVELDB_PLATFORM_WINDOWS -DBOOST_THREAD_USE_LIB\"\n+        PLATFORM_CXXFLAGS=\"-std=c++0x\"\n+        PLATFORM_LDFLAGS=\"\"\n+        PLATFORM_SHARED_CFLAGS=\"\"\n+        PLATFORM_SOURCES=\"port/port_win.cc util/env_boost.cc util/win_logger.cc\"\n+        PLATFORM_EXTRALIBS=\"-lboost_system-mt-s -lboost_filesystem-mt-s -lboost_thread_win32-mt-s\"\n         CROSS_COMPILE=true\n         ;;\n     *)\n@@ -120,12 +132,12 @@ DIRS=\"util db table\"\n set -f # temporarily disable globbing so that our patterns aren't expanded\n PRUNE_TEST=\"-name *test*.cc -prune\"\n PRUNE_BENCH=\"-name *_bench.cc -prune\"\n-PORTABLE_FILES=`find $DIRS $PRUNE_TEST -o $PRUNE_BENCH -o -name '*.cc' -print | sort | tr \"\\n\" \" \"`\n+PORTABLE_FILES=`find $DIRS $PRUNE_TEST -o $PRUNE_BENCH -o -name '*.cc' -not -name 'env_*.cc' -not -name '*_logger.cc' -print | sort | tr \"\\n\" \" \"`\n set +f # re-enable globbing\n \n # The sources consist of the portable files, plus the platform-specific port\n # file.\n-echo \"SOURCES=$PORTABLE_FILES $PORT_FILE\" >> $OUTPUT\n+echo \"SOURCES=$PORTABLE_FILES $PLATFORM_SOURCES\" >> $OUTPUT\n echo \"MEMENV_SOURCES=helpers/memenv/memenv.cc\" >> $OUTPUT\n \n if [ \"$CROSS_COMPILE\" = \"true\" ]; then\n@@ -173,6 +185,7 @@ echo \"PLATFORM=$PLATFORM\" >> $OUTPUT\n echo \"PLATFORM_LDFLAGS=$PLATFORM_LDFLAGS\" >> $OUTPUT\n echo \"PLATFORM_CCFLAGS=$PLATFORM_CCFLAGS\" >> $OUTPUT\n echo \"PLATFORM_CXXFLAGS=$PLATFORM_CXXFLAGS\" >> $OUTPUT\n+echo \"PLATFORM_EXTRALIBS=$PLATFORM_EXTRALIBS\" >> $OUTPUT\n echo \"PLATFORM_SHARED_CFLAGS=$PLATFORM_SHARED_CFLAGS\" >> $OUTPUT\n echo \"PLATFORM_SHARED_EXT=$PLATFORM_SHARED_EXT\" >> $OUTPUT\n echo \"PLATFORM_SHARED_LDFLAGS=$PLATFORM_SHARED_LDFLAGS\" >> $OUTPUT"
      },
      {
        "sha": "4baafa8e22fd290cfd73ad4daf0b5245e0d109c1",
        "filename": "src/leveldb/port/port.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d7b9500eedc9d4556744a80dc274f78521adbe60/src/leveldb/port/port.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d7b9500eedc9d4556744a80dc274f78521adbe60/src/leveldb/port/port.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/port.h?ref=d7b9500eedc9d4556744a80dc274f78521adbe60",
        "patch": "@@ -14,6 +14,8 @@\n #  include \"port/port_posix.h\"\n #elif defined(LEVELDB_PLATFORM_CHROMIUM)\n #  include \"port/port_chromium.h\"\n+#elif defined(LEVELDB_PLATFORM_WINDOWS)\n+#  include \"port/port_win.h\"\n #endif\n \n #endif  // STORAGE_LEVELDB_PORT_PORT_H_"
      },
      {
        "sha": "4ca64acbef22d0f795e9c1385be364eea729ad9c",
        "filename": "src/leveldb/port/port_win.cc",
        "status": "added",
        "additions": 182,
        "deletions": 0,
        "changes": 182,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d7b9500eedc9d4556744a80dc274f78521adbe60/src/leveldb/port/port_win.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d7b9500eedc9d4556744a80dc274f78521adbe60/src/leveldb/port/port_win.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/port_win.cc?ref=d7b9500eedc9d4556744a80dc274f78521adbe60",
        "patch": "@@ -0,0 +1,182 @@\n+// LevelDB Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+//\n+// See port_example.h for documentation for the following types/functions.\n+\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are met:\n+// \n+//  * Redistributions of source code must retain the above copyright\n+//    notice, this list of conditions and the following disclaimer.\n+//  * Redistributions in binary form must reproduce the above copyright\n+//    notice, this list of conditions and the following disclaimer in the\n+//    documentation and/or other materials provided with the distribution.\n+//  * Neither the name of the University of California, Berkeley nor the\n+//    names of its contributors may be used to endorse or promote products\n+//    derived from this software without specific prior written permission.\n+// \n+// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY\n+// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+// DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY\n+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+//\n+\n+#include \"port/port_win.h\"\n+\n+#include <windows.h>\n+#include <cassert>\n+\n+namespace leveldb {\n+namespace port {\n+\n+Mutex::Mutex() :\n+    mutex_(::CreateMutex(NULL, FALSE, NULL)) {\n+  assert(mutex_);\n+}\n+\n+Mutex::~Mutex() {\n+  assert(mutex_);\n+  ::CloseHandle(mutex_);\n+}\n+\n+void Mutex::Lock() {\n+  assert(mutex_);\n+  ::WaitForSingleObject(mutex_, INFINITE);\n+}\n+\n+void Mutex::Unlock() {\n+  assert(mutex_);\n+  ::ReleaseMutex(mutex_);\n+}\n+\n+void Mutex::AssertHeld() {\n+  assert(mutex_);\n+  assert(1);\n+}\n+\n+CondVar::CondVar(Mutex* mu) :\n+    waiting_(0), \n+    mu_(mu), \n+    sema_(::CreateSemaphore(NULL, 0, 0x7fffffff, NULL)), \n+    event_(::CreateEvent(NULL, FALSE, FALSE, NULL)),\n+    broadcasted_(false){\n+  assert(mu_);\n+}\n+\n+CondVar::~CondVar() {\n+  ::CloseHandle(sema_);\n+  ::CloseHandle(event_);\n+}\n+\n+void CondVar::Wait() {\n+  wait_mtx_.Lock();\n+  ++waiting_;\n+  assert(waiting_ > 0);\n+  wait_mtx_.Unlock();\n+\n+  ::SignalObjectAndWait(mu_->mutex_, sema_, INFINITE, FALSE);\n+\n+  wait_mtx_.Lock();\n+  bool last = broadcasted_ && (--waiting_ == 0);\n+  assert(waiting_ >= 0);\n+  wait_mtx_.Unlock();\n+\n+  // we leave this function with the mutex held\n+  if (last)\n+  {\n+    ::SignalObjectAndWait(event_, mu_->mutex_, INFINITE, FALSE);\n+  }\n+  else\n+  {\n+    ::WaitForSingleObject(mu_->mutex_, INFINITE);\n+  }\n+}\n+\n+void CondVar::Signal() {\n+  wait_mtx_.Lock();\n+  bool waiters = waiting_ > 0;\n+  wait_mtx_.Unlock();\n+\n+  if (waiters)\n+  {\n+    ::ReleaseSemaphore(sema_, 1, 0);\n+  }\n+}\n+\n+void CondVar::SignalAll() {\n+  wait_mtx_.Lock();\n+\n+  broadcasted_ = (waiting_ > 0);\n+\n+  if (broadcasted_)\n+  {\n+      // release all\n+    ::ReleaseSemaphore(sema_, waiting_, 0);\n+    wait_mtx_.Unlock();\n+    ::WaitForSingleObject(event_, INFINITE);\n+    broadcasted_ = false;\n+  }\n+  else\n+  {\n+    wait_mtx_.Unlock();\n+  }\n+}\n+\n+AtomicPointer::AtomicPointer(void* v) {\n+  Release_Store(v);\n+}\n+\n+void* AtomicPointer::Acquire_Load() const {\n+  void * p = nullptr;\n+  InterlockedExchangePointer(&p, rep_);\n+  return p;\n+}\n+\n+void AtomicPointer::Release_Store(void* v) {\n+  InterlockedExchangePointer(&rep_, v);\n+}\n+\n+void* AtomicPointer::NoBarrier_Load() const {\n+  return rep_;\n+}\n+\n+void AtomicPointer::NoBarrier_Store(void* v) {\n+  rep_ = v;\n+}\n+\n+enum InitializationState\n+{\n+    Uninitialized = 0,\n+    Running = 1,\n+    Initialized = 2\n+};\n+\n+void InitOnce(OnceType* once, void (*initializer)()) {\n+\n+  static_assert(Uninitialized == LEVELDB_ONCE_INIT, \"Invalid uninitialized state value\");\n+\n+  InitializationState state = static_cast<InitializationState>(InterlockedCompareExchange(once, Running, Uninitialized));\n+\n+  if (state == Uninitialized) {\n+      initializer();\n+      *once = Initialized;\n+  }\n+\n+  if (state == Running) {\n+      while(*once != Initialized) {\n+          Sleep(0); // yield\n+      }\n+  }\n+\n+  assert(*once == Initialized);\n+}\n+\n+}\n+}"
      },
      {
        "sha": "b53d6ef70d078dd50ae4171180ae54b923129e0a",
        "filename": "src/leveldb/port/port_win.h",
        "status": "added",
        "additions": 161,
        "deletions": 0,
        "changes": 161,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d7b9500eedc9d4556744a80dc274f78521adbe60/src/leveldb/port/port_win.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d7b9500eedc9d4556744a80dc274f78521adbe60/src/leveldb/port/port_win.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/port_win.h?ref=d7b9500eedc9d4556744a80dc274f78521adbe60",
        "patch": "@@ -0,0 +1,161 @@\n+// LevelDB Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+//\n+// See port_example.h for documentation for the following types/functions.\n+\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are met:\n+// \n+//  * Redistributions of source code must retain the above copyright\n+//    notice, this list of conditions and the following disclaimer.\n+//  * Redistributions in binary form must reproduce the above copyright\n+//    notice, this list of conditions and the following disclaimer in the\n+//    documentation and/or other materials provided with the distribution.\n+//  * Neither the name of the University of California, Berkeley nor the\n+//    names of its contributors may be used to endorse or promote products\n+//    derived from this software without specific prior written permission.\n+// \n+// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY\n+// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+// DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY\n+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+//\n+\n+#ifndef STORAGE_LEVELDB_PORT_PORT_WIN_H_\n+#define STORAGE_LEVELDB_PORT_PORT_WIN_H_\n+\n+#ifdef _MSC_VER\n+#define snprintf _snprintf\n+#define close _close\n+#define fread_unlocked _fread_nolock\n+#endif\n+\n+\n+#ifdef SNAPPY\n+#include <snappy/snappy.h>\n+#endif\n+\n+#include <string>\n+\n+#include <stdint.h>\n+\n+namespace leveldb {\n+namespace port {\n+\n+// Windows is little endian (for now :p)\n+static const bool kLittleEndian = true;\n+\n+class CondVar;\n+\n+class Mutex {\n+ public:\n+  Mutex();\n+  ~Mutex();\n+\n+  void Lock();\n+  void Unlock();\n+  void AssertHeld();\n+\n+ private:\n+  friend class CondVar;\n+  // critical sections are more efficient than mutexes\n+  // but they are not recursive and can only be used to synchronize threads within the same process\n+  // additionnaly they cannot be used with SignalObjectAndWait that we use for CondVar\n+  // we use opaque void * to avoid including windows.h in port_win.h\n+  void * mutex_;\n+\n+  // No copying\n+  Mutex(const Mutex&);\n+  void operator=(const Mutex&);\n+};\n+\n+// the Win32 API offers a dependable condition variable mechanism, but only starting with\n+// Windows 2008 and Vista\n+// no matter what we will implement our own condition variable with a semaphore\n+// implementation as described in a paper written by Douglas C. Schmidt and Irfan Pyarali\n+class CondVar {\n+ public:\n+  explicit CondVar(Mutex* mu);\n+  ~CondVar();\n+  void Wait();\n+  void Signal();\n+  void SignalAll();\n+ private:\n+  Mutex* mu_;\n+  \n+  Mutex wait_mtx_;\n+  long waiting_;\n+  \n+  void * sema_;\n+  void * event_;\n+\n+  bool broadcasted_;  \n+};\n+\n+// Storage for a lock-free pointer\n+class AtomicPointer {\n+ private:\n+  void * rep_;\n+ public:\n+  AtomicPointer() : rep_(nullptr) { }\n+  explicit AtomicPointer(void* v); \n+  void* Acquire_Load() const;\n+\n+  void Release_Store(void* v);\n+\n+  void* NoBarrier_Load() const;\n+\n+  void NoBarrier_Store(void* v);\n+};\n+\n+typedef volatile long OnceType;\n+#define LEVELDB_ONCE_INIT (0)\n+\n+extern void InitOnce(OnceType* once, void (*initializer)());\n+\n+inline bool Snappy_Compress(const char* input, size_t length,\n+                            ::std::string* output) {\n+#ifdef SNAPPY\n+  output->resize(snappy::MaxCompressedLength(length));\n+  size_t outlen;\n+  snappy::RawCompress(input, length, &(*output)[0], &outlen);\n+  output->resize(outlen);\n+  return true;\n+#endif\n+\n+  return false;\n+}\n+\n+inline bool Snappy_GetUncompressedLength(const char* input, size_t length,\n+                                         size_t* result) {\n+#ifdef SNAPPY\n+  return snappy::GetUncompressedLength(input, length, result);\n+#else\n+  return false;\n+#endif\n+}\n+\n+inline bool Snappy_Uncompress(const char* input, size_t length,\n+                              char* output) {\n+#ifdef SNAPPY\n+  return snappy::RawUncompress(input, length, output);\n+#else\n+  return false;\n+#endif\n+}\n+\n+inline bool GetHeapProfile(void (*func)(void*, const char*, int), void* arg) {\n+  return false;\n+}\n+\n+}\n+}\n+\n+#endif  // STORAGE_LEVELDB_PORT_PORT_WIN_H_"
      },
      {
        "sha": "0190f9fb776c5ef274ba0208601d5f50992f8307",
        "filename": "src/leveldb/util/env_boost.cc",
        "status": "added",
        "additions": 591,
        "deletions": 0,
        "changes": 591,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d7b9500eedc9d4556744a80dc274f78521adbe60/src/leveldb/util/env_boost.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d7b9500eedc9d4556744a80dc274f78521adbe60/src/leveldb/util/env_boost.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/env_boost.cc?ref=d7b9500eedc9d4556744a80dc274f78521adbe60",
        "patch": "@@ -0,0 +1,591 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include <deque>\n+\n+#ifdef LEVELDB_PLATFORM_WINDOWS\n+#include <windows.h>\n+#include <errno.h>\n+#include <fcntl.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <sys/stat.h>\n+#include <sys/types.h>\n+#include <time.h>\n+#include <io.h>\n+#else\n+#include <dirent.h>\n+#include <errno.h>\n+#include <fcntl.h>\n+#include <pthread.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <sys/mman.h>\n+#include <sys/stat.h>\n+#include <sys/time.h>\n+#include <sys/types.h>\n+#include <sys/param.h>\n+#include <time.h>\n+#include <unistd.h>\n+#endif\n+#if defined(LEVELDB_PLATFORM_ANDROID)\n+#include <sys/stat.h>\n+#endif\n+#include \"leveldb/env.h\"\n+#include \"leveldb/slice.h\"\n+\n+#ifdef LEVELDB_PLATFORM_WINDOWS\n+#include \"util/win_logger.h\"\n+#else\n+#include \"util/posix_logger.h\"\n+#endif\n+#include \"port/port.h\"\n+#include \"util/logging.h\"\n+\n+#ifdef __linux\n+#include <sys/sysinfo.h>\n+#include <linux/unistd.h>\n+#endif\n+\n+#include <fstream>\n+\n+// Boost includes - see WINDOWS file to see which modules to install\n+#include <boost/date_time/gregorian/gregorian.hpp>\n+#include <boost/date_time/posix_time/posix_time.hpp>\n+#include <boost/filesystem/convenience.hpp>\n+#include <boost/thread/once.hpp>\n+#include <boost/thread/thread.hpp>\n+#include <boost/bind.hpp>\n+#include <boost/scoped_ptr.hpp>\n+#include <boost/interprocess/sync/file_lock.hpp>\n+#include <boost/thread/condition_variable.hpp>\n+\n+namespace leveldb {\n+namespace {\n+\n+// returns the ID of the current process\n+static boost::uint32_t current_process_id(void) {\n+#ifdef _WIN32\n+  return static_cast<boost::uint32_t>(::GetCurrentProcessId());\n+#else\n+  return static_cast<boost::uint32_t>(::getpid());\n+#endif\n+}\n+\n+// returns the ID of the current thread\n+static boost::uint32_t current_thread_id(void) {\n+#ifdef _WIN32\n+  return static_cast<boost::uint32_t>(::GetCurrentThreadId());\n+#else\n+#ifdef __linux\n+  return static_cast<boost::uint32_t>(::syscall(__NR_gettid));\n+#else\n+  // just return the pid\n+  return current_process_id();\n+#endif\n+#endif\n+}\n+\n+static char global_read_only_buf[0x8000];\n+\n+class PosixSequentialFile: public SequentialFile {\n+ private:\n+  std::string filename_;\n+  FILE* file_;\n+\n+ public:\n+  PosixSequentialFile(const std::string& fname, FILE* f)\n+    : filename_(fname), file_(f) { }\n+  virtual ~PosixSequentialFile() { fclose(file_); }\n+\n+  virtual Status Read(size_t n, Slice* result, char* scratch) {\n+  Status s;\n+#if defined(BSD) || defined(__MINGW32__)\n+  // fread_unlocked doesn't exist on FreeBSD or MingW\n+  size_t r = fread(scratch, 1, n, file_);\n+#else\n+  size_t r = fread_unlocked(scratch, 1, n, file_);\n+#endif\n+  *result = Slice(scratch, r);\n+  if (r < n) {\n+    if (feof(file_)) {\n+    // We leave status as ok if we hit the end of the file\n+    } else {\n+    // A partial read with an error: return a non-ok status\n+    s = Status::IOError(filename_, strerror(errno));\n+    }\n+  }\n+  return s;\n+  }\n+\n+  virtual Status Skip(uint64_t n) {\n+  if (fseek(file_, n, SEEK_CUR)) {\n+    return Status::IOError(filename_, strerror(errno));\n+  }\n+  return Status::OK();\n+  }\n+};\n+\n+class PosixRandomAccessFile: public RandomAccessFile {\n+ private:\n+  std::string filename_;\n+  int fd_;\n+  mutable boost::mutex mu_;\n+\n+ public:\n+  PosixRandomAccessFile(const std::string& fname, int fd)\n+    : filename_(fname), fd_(fd) { }\n+  virtual ~PosixRandomAccessFile() { close(fd_); }\n+\n+  virtual Status Read(uint64_t offset, size_t n, Slice* result,\n+            char* scratch) const {\n+    Status s;\n+#ifdef LEVELDB_PLATFORM_WINDOWS\n+    // no pread on Windows so we emulate it with a mutex\n+    boost::unique_lock<boost::mutex> lock(mu_);\n+\n+    if (::_lseeki64(fd_, offset, SEEK_SET) == -1L) {\n+      return Status::IOError(filename_, strerror(errno));\n+    }\n+\n+    int r = ::_read(fd_, scratch, n);\n+    *result = Slice(scratch, (r < 0) ? 0 : r);\n+    lock.unlock();\n+#else\n+    ssize_t r = pread(fd_, scratch, n, static_cast<off_t>(offset));\n+    *result = Slice(scratch, (r < 0) ? 0 : r);\n+#endif\n+    if (r < 0) {\n+      // An error: return a non-ok status\n+      s = Status::IOError(filename_, strerror(errno));\n+    }\n+    return s;\n+  }\n+};\n+\n+// We preallocate up to an extra megabyte and use memcpy to append new\n+// data to the file.  This is safe since we either properly close the\n+// file before reading from it, or for log files, the reading code\n+// knows enough to skip zero suffixes.\n+\n+class BoostFile : public WritableFile {\n+\n+public:\n+  explicit BoostFile(std::string path) : path_(path), written_(0) {\n+    Open();\n+  }\n+\n+  virtual ~BoostFile() {\n+    Close();\n+  }\n+\n+private:\n+  void Open() {\n+    // we truncate the file as implemented in env_posix\n+     file_.open(path_.generic_string().c_str(), \n+         std::ios_base::trunc | std::ios_base::out | std::ios_base::binary);\n+     written_ = 0;\n+  }\n+\n+public:\n+  virtual Status Append(const Slice& data) {\n+    Status result;\n+    file_.write(data.data(), data.size());\n+    if (!file_.good()) {\n+      result = Status::IOError(\n+          path_.generic_string() + \" Append\", \"cannot write\");\n+    }\n+    return result;\n+  }\n+\n+  virtual Status Close() {\n+    Status result;\n+\n+    try {\n+      if (file_.is_open()) {\n+        Sync();\n+        file_.close();\n+      }\n+    } catch (const std::exception & e) {\n+      result = Status::IOError(path_.generic_string() + \" close\", e.what());\n+    }\n+\n+    return result;\n+  }\n+\n+  virtual Status Flush() {\n+    file_.flush();\n+    return Status::OK();\n+  }\n+\n+  virtual Status Sync() {\n+    Status result;\n+    try {\n+      Flush();\n+    } catch (const std::exception & e) {\n+      result = Status::IOError(path_.string() + \" sync\", e.what());\n+    }\n+\n+    return result;\n+  }\n+\n+private:\n+  boost::filesystem::path path_;\n+  boost::uint64_t written_;\n+  std::ofstream file_;\n+};\n+\n+\n+\n+class BoostFileLock : public FileLock {\n+ public:\n+  boost::interprocess::file_lock fl_;\n+};\n+\n+class PosixEnv : public Env {\n+ public:\n+  PosixEnv();\n+  virtual ~PosixEnv() {\n+    fprintf(stderr, \"Destroying Env::Default()\\n\");\n+    exit(1);\n+  }\n+\n+  virtual Status NewSequentialFile(const std::string& fname,\n+                   SequentialFile** result) {\n+    FILE* f = fopen(fname.c_str(), \"rb\");\n+    if (f == NULL) {\n+      *result = NULL;\n+      return Status::IOError(fname, strerror(errno));\n+    } else {\n+      *result = new PosixSequentialFile(fname, f);\n+      return Status::OK();\n+    }\n+  }\n+\n+  virtual Status NewRandomAccessFile(const std::string& fname,\n+                   RandomAccessFile** result) {\n+#ifdef LEVELDB_PLATFORM_WINDOWS\n+    int fd = _open(fname.c_str(), _O_RDONLY | _O_RANDOM | _O_BINARY);\n+#else\n+    int fd = open(fname.c_str(), O_RDONLY);\n+#endif\n+    if (fd < 0) {\n+      *result = NULL;\n+      return Status::IOError(fname, strerror(errno));\n+    }\n+    *result = new PosixRandomAccessFile(fname, fd);\n+    return Status::OK();\n+  }\n+\n+  virtual Status NewWritableFile(const std::string& fname,\n+                 WritableFile** result) {\n+    Status s;\n+    try {\n+      // will create a new empty file to write to\n+      *result = new BoostFile(fname);\n+    }\n+    catch (const std::exception & e) {\n+      s = Status::IOError(fname, e.what());\n+    }\n+\n+    return s;\n+  }\n+\n+  virtual bool FileExists(const std::string& fname) {\n+    return boost::filesystem::exists(fname);\n+  }\n+\n+  virtual Status GetChildren(const std::string& dir,\n+               std::vector<std::string>* result) {\n+    result->clear();\n+\n+    boost::system::error_code ec;\n+    boost::filesystem::directory_iterator current(dir, ec);\n+    if (ec != 0) {\n+      return Status::IOError(dir, ec.message());\n+    }\n+\n+    boost::filesystem::directory_iterator end;\n+\n+    for(; current != end; ++current) {\n+      result->push_back(current->path().filename().generic_string());\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  virtual Status DeleteFile(const std::string& fname) {\n+    boost::system::error_code ec;\n+\n+    boost::filesystem::remove(fname, ec);\n+\n+    Status result;\n+\n+    if (ec != 0) {\n+      result = Status::IOError(fname, ec.message());\n+    }\n+\n+    return result;\n+  }\n+\n+  virtual Status CreateDir(const std::string& name) {\n+      Status result;\n+\n+      if (boost::filesystem::exists(name) &&\n+          boost::filesystem::is_directory(name)) {\n+        return result;\n+      }\n+\n+      boost::system::error_code ec;\n+\n+      if (!boost::filesystem::create_directories(name, ec)) {\n+        result = Status::IOError(name, ec.message());\n+      }\n+\n+      return result;\n+    };\n+\n+    virtual Status DeleteDir(const std::string& name) {\n+    Status result;\n+\n+    boost::system::error_code ec;\n+    if (!boost::filesystem::remove_all(name, ec)) {\n+      result = Status::IOError(name, ec.message());\n+    }\n+\n+    return result;\n+  };\n+\n+  virtual Status GetFileSize(const std::string& fname, uint64_t* size) {\n+    boost::system::error_code ec;\n+\n+    Status result;\n+\n+    *size = static_cast<uint64_t>(boost::filesystem::file_size(fname, ec));\n+    if (ec != 0) {\n+      *size = 0;\n+       result = Status::IOError(fname, ec.message());\n+    }\n+\n+    return result;\n+  }\n+\n+  virtual Status RenameFile(const std::string& src, const std::string& target) {\n+    boost::system::error_code ec;\n+\n+    boost::filesystem::rename(src, target, ec);\n+\n+    Status result;\n+\n+    if (ec != 0) {\n+      result = Status::IOError(src, ec.message());\n+    }\n+\n+    return result;\n+  }\n+\n+  virtual Status LockFile(const std::string& fname, FileLock** lock) {\n+    *lock = NULL;\n+\n+    Status result;\n+\n+    try {\n+      if (!boost::filesystem::exists(fname)) {\n+        std::ofstream of(fname.c_str(), std::ios_base::trunc | std::ios_base::out);\n+      }\n+\n+      assert(boost::filesystem::exists(fname));\n+\n+      boost::interprocess::file_lock fl(fname.c_str());\n+      BoostFileLock * my_lock = new BoostFileLock();\n+      my_lock->fl_ = std::move(fl);\n+      if (!my_lock->fl_.try_lock()) {\n+          return Status::IOError(\"database already in use: could not acquire exclusive lock\");\n+      }\n+      *lock = my_lock;\n+    } catch (const std::exception & e) {\n+      result = Status::IOError(\"lock \" + fname, e.what());\n+    }\n+\n+    return result;\n+  }\n+\n+  virtual Status UnlockFile(FileLock* lock) {\n+\n+    Status result;\n+\n+    try {\n+      BoostFileLock * my_lock = static_cast<BoostFileLock *>(lock);\n+      my_lock->fl_.unlock();\n+      delete my_lock;\n+    } catch (const std::exception & e) {\n+      result = Status::IOError(\"unlock\", e.what());\n+    }\n+\n+    return result;\n+  }\n+\n+  virtual void Schedule(void (*function)(void*), void* arg);\n+\n+  virtual void StartThread(void (*function)(void* arg), void* arg);\n+\n+  virtual Status GetTestDirectory(std::string* result) {\n+    boost::system::error_code ec;\n+    boost::filesystem::path temp_dir = \n+        boost::filesystem::temp_directory_path(ec);\n+    if (ec != 0) {\n+      temp_dir = \"tmp\";\n+    }\n+\n+    temp_dir /= \"leveldb_tests\";\n+    temp_dir /= boost::lexical_cast<std::string>(current_process_id());\n+\n+    // Directory may already exist\n+    CreateDir(temp_dir.generic_string());\n+\n+    *result = temp_dir.generic_string();\n+\n+    return Status::OK();\n+  }\n+\n+#ifndef LEVELDB_PLATFORM_WINDOWS\n+  static uint64_t gettid() {\n+    pthread_t tid = pthread_self();\n+    uint64_t thread_id = 0;\n+    memcpy(&thread_id, &tid, std::min(sizeof(thread_id), sizeof(tid)));\n+    return thread_id;\n+  }\n+#endif\n+\n+  virtual Status NewLogger(const std::string& fname, Logger** result) {\n+  FILE* f = fopen(fname.c_str(), \"wt\");\n+  if (f == NULL) {\n+    *result = NULL;\n+    return Status::IOError(fname, strerror(errno));\n+  } else {\n+#ifdef LEVELDB_PLATFORM_WINDOWS\n+    *result = new WinLogger(f);\n+#else\n+    *result = new PosixLogger(f, &PosixEnv::gettid);\n+#endif\n+    return Status::OK();\n+  }\n+  }\n+\n+  virtual uint64_t NowMicros() {\n+    return static_cast<uint64_t>(\n+        boost::posix_time::microsec_clock::universal_time()\n+        .time_of_day().total_microseconds());\n+  }\n+\n+  virtual void SleepForMicroseconds(int micros) {\n+  boost::this_thread::sleep(boost::posix_time::microseconds(micros));\n+  }\n+\n+ private:\n+  void PthreadCall(const char* label, int result) {\n+  if (result != 0) {\n+    fprintf(stderr, \"pthread %s: %s\\n\", label, strerror(result));\n+    exit(1);\n+  }\n+  }\n+\n+  // BGThread() is the body of the background thread\n+  void BGThread();\n+\n+  static void* BGThreadWrapper(void* arg) {\n+    reinterpret_cast<PosixEnv*>(arg)->BGThread();\n+    return NULL;\n+  }\n+\n+  boost::mutex mu_;\n+  boost::condition_variable bgsignal_;\n+  boost::scoped_ptr<boost::thread> bgthread_;\n+\n+  // Entry per Schedule() call\n+  struct BGItem { void* arg; void (*function)(void*); };\n+  typedef std::deque<BGItem> BGQueue;\n+  BGQueue queue_;\n+};\n+\n+PosixEnv::PosixEnv() { }\n+\n+void PosixEnv::Schedule(void (*function)(void*), void* arg) {\n+  boost::unique_lock<boost::mutex> lock(mu_);\n+\n+  // Start background thread if necessary\n+  if (!bgthread_) {\n+     bgthread_.reset(\n+         new boost::thread(boost::bind(&PosixEnv::BGThreadWrapper, this)));\n+  }\n+\n+  // Add to priority queue\n+  queue_.push_back(BGItem());\n+  queue_.back().function = function;\n+  queue_.back().arg = arg;\n+\n+  lock.unlock();\n+\n+  bgsignal_.notify_one();\n+\n+}\n+\n+void PosixEnv::BGThread() {\n+  while (true) {\n+  // Wait until there is an item that is ready to run\n+  boost::unique_lock<boost::mutex> lock(mu_);\n+\n+  while (queue_.empty()) {\n+    bgsignal_.wait(lock);\n+  }\n+\n+  void (*function)(void*) = queue_.front().function;\n+  void* arg = queue_.front().arg;\n+  queue_.pop_front();\n+\n+  lock.unlock();\n+  (*function)(arg);\n+  }\n+}\n+\n+namespace {\n+struct StartThreadState {\n+  void (*user_function)(void*);\n+  void* arg;\n+};\n+}\n+\n+static void* StartThreadWrapper(void* arg) {\n+  StartThreadState* state = reinterpret_cast<StartThreadState*>(arg);\n+  state->user_function(state->arg);\n+  delete state;\n+  return NULL;\n+}\n+\n+void PosixEnv::StartThread(void (*function)(void* arg), void* arg) {\n+  StartThreadState* state = new StartThreadState;\n+  state->user_function = function;\n+  state->arg = arg;\n+\n+  boost::thread t(boost::bind(&StartThreadWrapper, state));\n+}\n+\n+}\n+\n+static boost::once_flag once = BOOST_ONCE_INIT;\n+static Env* default_env;\n+static void InitDefaultEnv() { \n+  ::memset(global_read_only_buf, 0, sizeof(global_read_only_buf));\n+  default_env = new PosixEnv;\n+}\n+\n+Env* Env::Default() {\n+  boost::call_once(once, InitDefaultEnv);\n+\n+  return default_env;\n+}\n+\n+}"
      },
      {
        "sha": "834c98cc7669c9b03a0649b8ca75a877e89b0580",
        "filename": "src/leveldb/util/win_logger.cc",
        "status": "added",
        "additions": 96,
        "deletions": 0,
        "changes": 96,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d7b9500eedc9d4556744a80dc274f78521adbe60/src/leveldb/util/win_logger.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d7b9500eedc9d4556744a80dc274f78521adbe60/src/leveldb/util/win_logger.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/win_logger.cc?ref=d7b9500eedc9d4556744a80dc274f78521adbe60",
        "patch": "@@ -0,0 +1,96 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include \"util/win_logger.h\"\n+\n+#include <windows.h>\n+\n+namespace leveldb {\n+\n+void WinLogger::Logv(const char* format, va_list ap) {\n+  const uint64_t thread_id = static_cast<uint64_t>(::GetCurrentThreadId());\n+\n+  // We try twice: the first time with a fixed-size stack allocated buffer,\n+  // and the second time with a much larger dynamically allocated buffer.\n+  char buffer[500];\n+\n+  for (int iter = 0; iter < 2; iter++) {\n+    char* base;\n+    int bufsize;\n+    if (iter == 0) {\n+      bufsize = sizeof(buffer);\n+      base = buffer;\n+    } else {\n+      bufsize = 30000;\n+      base = new char[bufsize];\n+    }\n+\n+    char* p = base;\n+    char* limit = base + bufsize;\n+\n+    SYSTEMTIME st;\n+\n+    // GetSystemTime returns UTC time, we want local time!\n+    ::GetLocalTime(&st);\n+\n+#ifdef _MSC_VER\n+    p += _snprintf_s(p, limit - p, _TRUNCATE,\n+      \"%04d/%02d/%02d-%02d:%02d:%02d.%03d %llx \",\n+      st.wYear,\n+      st.wMonth,\n+      st.wDay,\n+      st.wHour,\n+      st.wMinute,\n+      st.wSecond,\n+      st.wMilliseconds,\n+      static_cast<long long unsigned int>(thread_id));\n+#else\n+#ifdef __MINGW32__\n+    p += snprintf(p, limit - p,\n+      \"%04d/%02d/%02d-%02d:%02d:%02d.%03d %llx \",\n+      st.wYear,\n+      st.wMonth,\n+      st.wDay,\n+      st.wHour,\n+      st.wMinute,\n+      st.wSecond,\n+      st.wMilliseconds,\n+      static_cast<long long unsigned int>(thread_id));\n+#else\n+#error Unable to detect Windows compiler (neither _MSC_VER nor __MINGW32__ are set)\n+#endif\n+#endif\n+\n+    // Print the message\n+    if (p < limit) {\n+      va_list backup_ap = ap;\n+      p += vsnprintf(p, limit - p, format, backup_ap);\n+      va_end(backup_ap);\n+    }\n+\n+    // Truncate to available space if necessary\n+    if (p >= limit) {\n+      if (iter == 0) {\n+        continue; // Try again with larger buffer\n+      } else {\n+        p = limit - 1;\n+      }\n+    }\n+\n+    // Add newline if necessary\n+    if (p == base || p[-1] != '\\n') {\n+      *p++ = '\\n';\n+    }\n+\n+    assert(p <= limit);\n+    fwrite(base, 1, p - base, file_);\n+    fflush(file_);\n+    if (base != buffer) {\n+      delete[] base;\n+    }\n+    break;\n+  }\n+}\n+\n+}\n\\ No newline at end of file"
      },
      {
        "sha": "b155d5c3190c44594bde894ca7c02ea4c81cf7fc",
        "filename": "src/leveldb/util/win_logger.h",
        "status": "added",
        "additions": 28,
        "deletions": 0,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d7b9500eedc9d4556744a80dc274f78521adbe60/src/leveldb/util/win_logger.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d7b9500eedc9d4556744a80dc274f78521adbe60/src/leveldb/util/win_logger.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/win_logger.h?ref=d7b9500eedc9d4556744a80dc274f78521adbe60",
        "patch": "@@ -0,0 +1,28 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+// Logger implementation for Windows\n+\n+#ifndef STORAGE_LEVELDB_UTIL_WIN_LOGGER_H_\n+#define STORAGE_LEVELDB_UTIL_WIN_LOGGER_H_\n+\n+#include <stdio.h>\n+#include \"leveldb/env.h\"\n+\n+namespace leveldb {\n+\n+class WinLogger : public Logger {\n+ private:\n+  FILE* file_;\n+ public:\n+  explicit WinLogger(FILE* f) : file_(f) { assert(file_); }\n+  virtual ~WinLogger() {\n+    fclose(file_);\n+  }\n+  virtual void Logv(const char* format, va_list ap);\n+\n+};\n+\n+}\n+#endif  // STORAGE_LEVELDB_UTIL_WIN_LOGGER_H_"
      }
    ]
  },
  {
    "sha": "70407bad80c877bac4039b78171663d01f6ee108",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3MDQwN2JhZDgwYzg3N2JhYzQwMzliNzgxNzE2NjNkMDFmNmVlMTA4",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-09-04T19:00:53Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-19T23:55:51Z"
      },
      "message": "Disable libsnappy detection in LevelDB",
      "tree": {
        "sha": "10d414108590cc2e2966189b62189520bff58061",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/10d414108590cc2e2966189b62189520bff58061"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/70407bad80c877bac4039b78171663d01f6ee108",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/70407bad80c877bac4039b78171663d01f6ee108",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/70407bad80c877bac4039b78171663d01f6ee108",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/70407bad80c877bac4039b78171663d01f6ee108/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d7b9500eedc9d4556744a80dc274f78521adbe60",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d7b9500eedc9d4556744a80dc274f78521adbe60",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d7b9500eedc9d4556744a80dc274f78521adbe60"
      }
    ],
    "stats": {
      "total": 11,
      "additions": 0,
      "deletions": 11
    },
    "files": [
      {
        "sha": "385b5effdcd7facbe9c61a54a24d0826d59f76ab",
        "filename": "src/leveldb/build_detect_platform",
        "status": "modified",
        "additions": 0,
        "deletions": 11,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/70407bad80c877bac4039b78171663d01f6ee108/src/leveldb/build_detect_platform",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/70407bad80c877bac4039b78171663d01f6ee108/src/leveldb/build_detect_platform",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/build_detect_platform?ref=70407bad80c877bac4039b78171663d01f6ee108",
        "patch": "@@ -156,17 +156,6 @@ EOF\n         COMMON_FLAGS=\"$COMMON_FLAGS -DLEVELDB_PLATFORM_POSIX\"\n     fi\n \n-    # Test whether Snappy library is installed\n-    # http://code.google.com/p/snappy/\n-    $CXX $CFLAGS -x c++ - -o /dev/null 2>/dev/null  <<EOF\n-      #include <snappy.h>\n-      int main() {}\n-EOF\n-    if [ \"$?\" = 0 ]; then\n-        COMMON_FLAGS=\"$COMMON_FLAGS -DSNAPPY\"\n-        PLATFORM_LDFLAGS=\"$PLATFORM_LDFLAGS -lsnappy\"\n-    fi\n-\n     # Test whether tcmalloc is available\n     $CXX $CFLAGS -x c++ - -o /dev/null -ltcmalloc 2>/dev/null  <<EOF\n       int main() {}"
      }
    ]
  },
  {
    "sha": "d6efe12b1add16c7c42b2993327c33c563da0d88",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkNmVmZTEyYjFhZGQxNmM3YzQyYjI5OTMzMjdjMzNjNTYzZGEwZDg4",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-09-04T21:01:03Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-19T23:55:51Z"
      },
      "message": "Backport Win32 LevelDB env from C++0x to C++\n\nSince the gitian mingw compiler doesn't support C++0x yet.",
      "tree": {
        "sha": "23b1e40a31e0177beb6ab65d06e4458d6feb04af",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/23b1e40a31e0177beb6ab65d06e4458d6feb04af"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d6efe12b1add16c7c42b2993327c33c563da0d88",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d6efe12b1add16c7c42b2993327c33c563da0d88",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d6efe12b1add16c7c42b2993327c33c563da0d88",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d6efe12b1add16c7c42b2993327c33c563da0d88/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "70407bad80c877bac4039b78171663d01f6ee108",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/70407bad80c877bac4039b78171663d01f6ee108",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/70407bad80c877bac4039b78171663d01f6ee108"
      }
    ],
    "stats": {
      "total": 10,
      "additions": 5,
      "deletions": 5
    },
    "files": [
      {
        "sha": "dd982236fdce20127e888410f9e85524cba4b833",
        "filename": "src/leveldb/build_detect_platform",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6efe12b1add16c7c42b2993327c33c563da0d88/src/leveldb/build_detect_platform",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6efe12b1add16c7c42b2993327c33c563da0d88/src/leveldb/build_detect_platform",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/build_detect_platform?ref=d6efe12b1add16c7c42b2993327c33c563da0d88",
        "patch": "@@ -112,7 +112,7 @@ case \"$TARGET_OS\" in\n     OS_WINDOWS_CROSSCOMPILE)\n         PLATFORM=OS_WINDOWS\n         COMMON_FLAGS=\"-fno-builtin-memcmp -D_REENTRANT -DOS_WINDOWS -DLEVELDB_PLATFORM_WINDOWS -DBOOST_THREAD_USE_LIB\"\n-        PLATFORM_CXXFLAGS=\"-std=c++0x\"\n+        PLATFORM_CXXFLAGS=\"\"\n         PLATFORM_LDFLAGS=\"\"\n         PLATFORM_SHARED_CFLAGS=\"\"\n         PLATFORM_SOURCES=\"port/port_win.cc util/env_boost.cc util/win_logger.cc\""
      },
      {
        "sha": "786cd6018a50e3882848f32d7d51794027eeb086",
        "filename": "src/leveldb/port/port_win.cc",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6efe12b1add16c7c42b2993327c33c563da0d88/src/leveldb/port/port_win.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6efe12b1add16c7c42b2993327c33c563da0d88/src/leveldb/port/port_win.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/port_win.cc?ref=d6efe12b1add16c7c42b2993327c33c563da0d88",
        "patch": "@@ -134,7 +134,7 @@ AtomicPointer::AtomicPointer(void* v) {\n }\n \n void* AtomicPointer::Acquire_Load() const {\n-  void * p = nullptr;\n+  void * p = NULL;\n   InterlockedExchangePointer(&p, rep_);\n   return p;\n }\n@@ -160,7 +160,7 @@ enum InitializationState\n \n void InitOnce(OnceType* once, void (*initializer)()) {\n \n-  static_assert(Uninitialized == LEVELDB_ONCE_INIT, \"Invalid uninitialized state value\");\n+  assert(Uninitialized == LEVELDB_ONCE_INIT);\n \n   InitializationState state = static_cast<InitializationState>(InterlockedCompareExchange(once, Running, Uninitialized));\n "
      },
      {
        "sha": "893919998ce71e7e830a43d63743ee8cc67e316b",
        "filename": "src/leveldb/port/port_win.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6efe12b1add16c7c42b2993327c33c563da0d88/src/leveldb/port/port_win.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6efe12b1add16c7c42b2993327c33c563da0d88/src/leveldb/port/port_win.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/port_win.h?ref=d6efe12b1add16c7c42b2993327c33c563da0d88",
        "patch": "@@ -104,7 +104,7 @@ class AtomicPointer {\n  private:\n   void * rep_;\n  public:\n-  AtomicPointer() : rep_(nullptr) { }\n+  AtomicPointer() : rep_(NULL) { }\n   explicit AtomicPointer(void* v); \n   void* Acquire_Load() const;\n "
      },
      {
        "sha": "055c65743841a83b00ff8045160193da2250866e",
        "filename": "src/leveldb/util/env_boost.cc",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6efe12b1add16c7c42b2993327c33c563da0d88/src/leveldb/util/env_boost.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6efe12b1add16c7c42b2993327c33c563da0d88/src/leveldb/util/env_boost.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/env_boost.cc?ref=d6efe12b1add16c7c42b2993327c33c563da0d88",
        "patch": "@@ -401,7 +401,7 @@ class PosixEnv : public Env {\n \n       boost::interprocess::file_lock fl(fname.c_str());\n       BoostFileLock * my_lock = new BoostFileLock();\n-      my_lock->fl_ = std::move(fl);\n+      fl.swap(my_lock->fl_);\n       if (!my_lock->fl_.try_lock()) {\n           return Status::IOError(\"database already in use: could not acquire exclusive lock\");\n       }"
      }
    ]
  },
  {
    "sha": "4031122ffc03292eb5ddf0083e649c2a9bcef55f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0MDMxMTIyZmZjMDMyOTJlYjVkZGYwMDgzZTY0OWMyYTliY2VmNTVm",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-08-30T19:13:50Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-19T23:55:51Z"
      },
      "message": "Makefile integration of LevelDB",
      "tree": {
        "sha": "970054f91c27d9a09f0858e6c42b2b059e859eca",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/970054f91c27d9a09f0858e6c42b2b059e859eca"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4031122ffc03292eb5ddf0083e649c2a9bcef55f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4031122ffc03292eb5ddf0083e649c2a9bcef55f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4031122ffc03292eb5ddf0083e649c2a9bcef55f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4031122ffc03292eb5ddf0083e649c2a9bcef55f/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d6efe12b1add16c7c42b2993327c33c563da0d88",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d6efe12b1add16c7c42b2993327c33c563da0d88",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d6efe12b1add16c7c42b2993327c33c563da0d88"
      }
    ],
    "stats": {
      "total": 72,
      "additions": 72,
      "deletions": 0
    },
    "files": [
      {
        "sha": "68add91122aa05178f2cb8c169e65ece1e8d7868",
        "filename": "bitcoin-qt.pro",
        "status": "modified",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4031122ffc03292eb5ddf0083e649c2a9bcef55f/bitcoin-qt.pro",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4031122ffc03292eb5ddf0083e649c2a9bcef55f/bitcoin-qt.pro",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/bitcoin-qt.pro?ref=4031122ffc03292eb5ddf0083e649c2a9bcef55f",
        "patch": "@@ -90,6 +90,29 @@ contains(BITCOIN_NEED_QT_PLUGINS, 1) {\n     QTPLUGIN += qcncodecs qjpcodecs qtwcodecs qkrcodecs qtaccessiblewidgets\n }\n \n+contains(USE_LEVELDB, -) {\n+    message(Building without LevelDB)\n+} else {\n+    message(Building with LevelDB)\n+    DEFINES += USE_LEVELDB\n+    INCLUDEPATH += src/leveldb/include src/leveldb/helpers\n+    LIBS += $$PWD/src/leveldb/libleveldb.a $$PWD/src/leveldb/libmemenv.a\n+    !windows {\n+        genleveldb.commands = cd $$PWD/src/leveldb ; $(MAKE) libleveldb.a libmemenv.a\n+    } else {\n+        # make an educated guess about what the ranlib command is called\n+        isEmpty(QMAKE_RANLIB) {\n+            QMAKE_RANLIB = $$replace(QMAKE_STRIP, strip, ranlib)\n+        }\n+        genleveldb.commands = cd $$PWD/src/leveldb ; CC=$$QMAKE_CC CXX=$$QMAKE_CXX TARGET_OS=OS_WINDOWS_CROSSCOMPILE CXXFLAGS=\"-I$$BOOST_INCLUDE_PATH\" LDFLAGS=\"-L$$BOOST_LIB_PATH\" $(MAKE) libleveldb.a libmemenv.a ; $$QMAKE_RANLIB $$PWD/src/leveldb/libleveldb.a ; $$QMAKE_RANLIB $$PWD/src/leveldb/libmemenv.a\n+    }\n+    genleveldb.target = $$PWD/src/leveldb/libleveldb.a\n+    genleveldb.depends = FORCE\n+    PRE_TARGETDEPS += $$PWD/src/leveldb/libleveldb.a\n+    QMAKE_EXTRA_TARGETS += genleveldb\n+    # Gross ugly hack that depends on qmake internals, unfortunately there's no other way to do it.\n+    QMAKE_CLEAN += $$PWD/src/leveldb/libleveldb.a; cd $$PWD/src/leveldb ; $(MAKE) clean\n+}\n \n # regenerate src/build.h\n !windows|contains(USE_BUILD_INFO, 1) {"
      },
      {
        "sha": "8f8279c9268178b3291f8a4db7cfa2fe2b074e99",
        "filename": "src/makefile.linux-mingw",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4031122ffc03292eb5ddf0083e649c2a9bcef55f/src/makefile.linux-mingw",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4031122ffc03292eb5ddf0083e649c2a9bcef55f/src/makefile.linux-mingw",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.linux-mingw?ref=4031122ffc03292eb5ddf0083e649c2a9bcef55f",
        "patch": "@@ -6,6 +6,7 @@ DEPSDIR:=/usr/i586-mingw32msvc\n \n USE_UPNP:=0\n USE_IPV6:=1\n+USE_LEVELDB:=1\n \n INCLUDEPATHS= \\\n  -I\"$(CURDIR)\" \\\n@@ -86,6 +87,15 @@ OBJS= \\\n \n all: bitcoind.exe\n \n+ifdef USE_LEVELDB\n+LIBS += $(CURDIR)/leveldb/libleveldb.lib $(CURDIR)/leveldb/libmemenv.a\n+DEFS += -I\"$(CURDIR)/leveldb/include\" -DUSE_LEVELDB\n+DEFS += -I\"$(CURDIR)/leveldb/helpers\"\n+leveldb/libleveldb.a:\n+\t@echo \"Building LevelDB ...\"; cd leveldb; TARGET_OS=OS_WINDOWS_CROSSCOMPILE CXXFLAGS=\"-I$(INCLUDEPATHS)\" LDFLAGS=\"-L$(LIBPATHS)\" make libleveldb.a libmemenv.a; cd ..\n+obj/db.o: leveldb/libleveldb.a\n+endif\n+\n obj/build.h: FORCE\n \t/bin/sh ../share/genbuild.sh obj/build.h\n version.cpp: obj/build.h"
      },
      {
        "sha": "e2560d9912c5a5c8d130ef1b91abf12d14ea1d2b",
        "filename": "src/makefile.mingw",
        "status": "modified",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4031122ffc03292eb5ddf0083e649c2a9bcef55f/src/makefile.mingw",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4031122ffc03292eb5ddf0083e649c2a9bcef55f/src/makefile.mingw",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.mingw?ref=4031122ffc03292eb5ddf0083e649c2a9bcef55f",
        "patch": "@@ -4,6 +4,7 @@\n \n USE_UPNP:=0\n USE_IPV6:=1\n+USE_LEVELDB:=1\n \n INCLUDEPATHS= \\\n  -I\"C:\\boost-1.50.0-mgw\" \\\n@@ -86,6 +87,18 @@ all: bitcoind.exe\n test check: test_bitcoin.exe FORCE\n \ttest_bitcoin.exe\n \n+#\n+# LevelDB support\n+#\n+ifdef USE_LEVELDB\n+LIBS += $(CURDIR)/leveldb/libleveldb.a $(CURDIR)/leveldb/libmemenv.a\n+DEFS += $(addprefix -I,$(CURDIR)/leveldb/include) -DUSE_LEVELDB\n+DEFS += $(addprefix -I,$(CURDIR)/leveldb/helpers)\n+leveldb/libleveldb.a:\n+    cd leveldb; make libleveldb.a libmemenv.a; cd ..\n+obj/db.o: leveldb/libleveldb.lib\n+endif\n+\n obj/%.o: %.cpp $(HEADERS)\n \tg++ -c $(CFLAGS) -o $@ $<\n "
      },
      {
        "sha": "bfda78841021e291457ffdb5fae6832316f9fee4",
        "filename": "src/makefile.osx",
        "status": "modified",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4031122ffc03292eb5ddf0083e649c2a9bcef55f/src/makefile.osx",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4031122ffc03292eb5ddf0083e649c2a9bcef55f/src/makefile.osx",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.osx?ref=4031122ffc03292eb5ddf0083e649c2a9bcef55f",
        "patch": "@@ -21,6 +21,7 @@ LIBPATHS= \\\n \n USE_UPNP:=1\n USE_IPV6:=1\n+USE_LEVELDB:=1\n \n LIBS= -dead_strip\n \n@@ -119,6 +120,18 @@ all: bitcoind\n test check: test_bitcoin FORCE\n \t./test_bitcoin\n \n+#\n+# LevelDB support\n+#\n+ifdef USE_LEVELDB\n+LIBS += $(CURDIR)/leveldb/libleveldb.a $(CURDIR)/leveldb/libmemenv.a\n+DEFS += $(addprefix -I,$(CURDIR)/leveldb/include) -DUSE_LEVELDB\n+DEFS += $(addprefix -I,$(CURDIR)/leveldb/helpers)\n+leveldb/libleveldb.a:\n+\t@echo \"Building LevelDB ...\"; cd leveldb; make libleveldb.a libmemenv.a; cd ..\n+obj/db.o: leveldb/libleveldb.a\n+endif\n+\n # auto-generated dependencies:\n -include obj/*.P\n -include obj-test/*.P"
      },
      {
        "sha": "01b637e9c6e52f5018abf06e143491bfd4231631",
        "filename": "src/makefile.unix",
        "status": "modified",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4031122ffc03292eb5ddf0083e649c2a9bcef55f/src/makefile.unix",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4031122ffc03292eb5ddf0083e649c2a9bcef55f/src/makefile.unix",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.unix?ref=4031122ffc03292eb5ddf0083e649c2a9bcef55f",
        "patch": "@@ -4,6 +4,7 @@\n \n USE_UPNP:=0\n USE_IPV6:=1\n+USE_LEVELDB:=1\n \n LINK:=$(CXX)\n \n@@ -135,6 +136,18 @@ all: bitcoind\n test check: test_bitcoin FORCE\n \t./test_bitcoin\n \n+#\n+# LevelDB support\n+#\n+ifdef USE_LEVELDB\n+LIBS += $(CURDIR)/leveldb/libleveldb.a $(CURDIR)/leveldb/libmemenv.a\n+DEFS += $(addprefix -I,$(CURDIR)/leveldb/include) -DUSE_LEVELDB\n+DEFS += $(addprefix -I,$(CURDIR)/leveldb/helpers)\n+leveldb/libleveldb.a:\n+\t@echo \"Building LevelDB ...\"; cd leveldb; make libleveldb.a libmemenv.a; cd ..;\n+obj/db.o: leveldb/libleveldb.a\n+endif\n+\n # auto-generated dependencies:\n -include obj/*.P\n -include obj-test/*.P"
      }
    ]
  },
  {
    "sha": "2b44e4b66b339875570b10805e9ffeec0840ad06",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyYjQ0ZTRiNjZiMzM5ODc1NTcwYjEwODA1ZTlmZmVlYzA4NDBhZDA2",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-09-03T17:05:30Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-19T23:55:51Z"
      },
      "message": "LevelDB glue\n\nDatabase-independent glue for supporting LevelDB databases.\n\nBased on code from earlier commits by Mike Hearn in his leveldb\nbranch.",
      "tree": {
        "sha": "a2f90a07dfd16e3a3ec1ae418e3f65a2f2177579",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a2f90a07dfd16e3a3ec1ae418e3f65a2f2177579"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2b44e4b66b339875570b10805e9ffeec0840ad06",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2b44e4b66b339875570b10805e9ffeec0840ad06",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2b44e4b66b339875570b10805e9ffeec0840ad06",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2b44e4b66b339875570b10805e9ffeec0840ad06/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4031122ffc03292eb5ddf0083e649c2a9bcef55f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4031122ffc03292eb5ddf0083e649c2a9bcef55f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4031122ffc03292eb5ddf0083e649c2a9bcef55f"
      }
    ],
    "stats": {
      "total": 217,
      "additions": 212,
      "deletions": 5
    },
    "files": [
      {
        "sha": "c92971661c445c7554ae195c1ac8e2aaa075470e",
        "filename": "bitcoin-qt.pro",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b44e4b66b339875570b10805e9ffeec0840ad06/bitcoin-qt.pro",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b44e4b66b339875570b10805e9ffeec0840ad06/bitcoin-qt.pro",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/bitcoin-qt.pro?ref=2b44e4b66b339875570b10805e9ffeec0840ad06",
        "patch": "@@ -97,6 +97,7 @@ contains(USE_LEVELDB, -) {\n     DEFINES += USE_LEVELDB\n     INCLUDEPATH += src/leveldb/include src/leveldb/helpers\n     LIBS += $$PWD/src/leveldb/libleveldb.a $$PWD/src/leveldb/libmemenv.a\n+    SOURCES += src/leveldb.cpp\n     !windows {\n         genleveldb.commands = cd $$PWD/src/leveldb ; $(MAKE) libleveldb.a libmemenv.a\n     } else {"
      },
      {
        "sha": "29e5e6a7fdee4521f05d8534c7c670b66774bd07",
        "filename": "src/leveldb.cpp",
        "status": "added",
        "additions": 58,
        "deletions": 0,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b44e4b66b339875570b10805e9ffeec0840ad06/src/leveldb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b44e4b66b339875570b10805e9ffeec0840ad06/src/leveldb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb.cpp?ref=2b44e4b66b339875570b10805e9ffeec0840ad06",
        "patch": "@@ -0,0 +1,58 @@\n+// Copyright (c) 2012 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"leveldb.h\"\n+#include \"util.h\"\n+\n+#include <leveldb/env.h>\n+#include <leveldb/cache.h>\n+#include <leveldb/filter_policy.h>\n+\n+#include <boost/filesystem.hpp>\n+\n+static leveldb::Options GetOptions() {\n+    leveldb::Options options;\n+    int nCacheSizeMB = GetArg(\"-dbcache\", 25);\n+    options.block_cache = leveldb::NewLRUCache(nCacheSizeMB * 1048576);\n+    options.filter_policy = leveldb::NewBloomFilterPolicy(10);\n+    options.compression = leveldb::kNoCompression;\n+    return options;\n+}\n+\n+CLevelDB::CLevelDB(const boost::filesystem::path &path) {\n+    penv = NULL;\n+    readoptions.verify_checksums = true;\n+    iteroptions.verify_checksums = true;\n+    iteroptions.fill_cache = false;\n+    syncoptions.sync = true;\n+    options = GetOptions();\n+    options.create_if_missing = true;\n+    boost::filesystem::create_directory(path);\n+    printf(\"Opening LevelDB in %s\\n\", path.string().c_str());\n+    leveldb::Status status = leveldb::DB::Open(options, path.string(), &pdb);\n+    if (!status.ok())\n+        throw std::runtime_error(strprintf(\"CLevelDB(): error opening database environment %s\", status.ToString().c_str()));\n+    printf(\"Opened LevelDB successfully\\n\");\n+}\n+\n+CLevelDB::~CLevelDB() {\n+    delete pdb;\n+    pdb = NULL;\n+    delete options.filter_policy;\n+    options.filter_policy = NULL;\n+    delete options.block_cache;\n+    options.block_cache = NULL;\n+    delete penv;\n+    options.env = NULL;\n+}\n+\n+bool CLevelDB::WriteBatch(CLevelDBBatch &batch, bool fSync) {\n+    leveldb::Status status = pdb->Write(fSync ? syncoptions : writeoptions, &batch.batch);\n+    if (!status.ok()) {\n+        printf(\"LevelDB write failure: %s\\n\", status.ToString().c_str());\n+        return false;\n+    }\n+    return true;\n+}\n+"
      },
      {
        "sha": "28484dac9d1c385d24ad5e494d8b86bd06115ac1",
        "filename": "src/leveldb.h",
        "status": "added",
        "additions": 144,
        "deletions": 0,
        "changes": 144,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b44e4b66b339875570b10805e9ffeec0840ad06/src/leveldb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b44e4b66b339875570b10805e9ffeec0840ad06/src/leveldb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb.h?ref=2b44e4b66b339875570b10805e9ffeec0840ad06",
        "patch": "@@ -0,0 +1,144 @@\n+// Copyright (c) 2012 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#ifndef BITCOIN_LEVELDB_H\n+#define BITCOIN_LEVELDB_H\n+\n+#include \"serialize.h\"\n+\n+#include <leveldb/db.h>\n+#include <leveldb/write_batch.h>\n+\n+#include <boost/filesystem/path.hpp>\n+\n+// Batch of changes queued to be written to a CLevelDB\n+class CLevelDBBatch\n+{\n+    friend class CLevelDB;\n+\n+private:\n+    leveldb::WriteBatch batch;\n+\n+public:\n+    template<typename K, typename V> void Write(const K& key, const V& value) {\n+        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+        ssKey.reserve(ssKey.GetSerializeSize(key));\n+        ssKey << key;\n+        leveldb::Slice slKey(&ssKey[0], ssKey.size());\n+\n+        CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n+        ssValue.reserve(ssValue.GetSerializeSize(value));\n+        ssValue << value;\n+        leveldb::Slice slValue(&ssValue[0], ssValue.size());\n+\n+        batch.Put(slKey, slValue);\n+    }\n+\n+    template<typename K> void Erase(const K& key) {\n+        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+        ssKey.reserve(ssKey.GetSerializeSize(key));\n+        ssKey << key;\n+        leveldb::Slice slKey(&ssKey[0], ssKey.size());\n+\n+        batch.Delete(slKey);\n+    }\n+};\n+\n+class CLevelDB\n+{\n+private:\n+    // custom environment this database is using (may be NULL in case of default environment)\n+    leveldb::Env *penv;\n+\n+    // database options used\n+    leveldb::Options options;\n+\n+    // options used when reading from the database\n+    leveldb::ReadOptions readoptions;\n+\n+    // options used when iterating over values of the database\n+    leveldb::ReadOptions iteroptions;\n+\n+    // options used when writing to the database\n+    leveldb::WriteOptions writeoptions;\n+\n+    // options used when sync writing to the database\n+    leveldb::WriteOptions syncoptions;\n+\n+    // the database itself\n+    leveldb::DB *pdb;\n+\n+public:\n+    CLevelDB(const boost::filesystem::path &path);\n+    ~CLevelDB();\n+\n+    template<typename K, typename V> bool Read(const K& key, V& value) {\n+        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+        ssKey.reserve(ssKey.GetSerializeSize(key));\n+        ssKey << key;\n+        leveldb::Slice slKey(&ssKey[0], ssKey.size());\n+\n+        std::string strValue;\n+        leveldb::Status status = pdb->Get(readoptions, slKey, &strValue);\n+        if (!status.ok()) {\n+            if (status.IsNotFound())\n+                return false;\n+            printf(\"LevelDB read failure: %s\\n\", status.ToString().c_str());\n+        }\n+        try {\n+            CDataStream ssValue(strValue.data(), strValue.data() + strValue.size(), SER_DISK, CLIENT_VERSION);\n+            ssValue >> value;\n+        } catch(std::exception &e) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    template<typename K, typename V> bool Write(const K& key, const V& value, bool fSync = false) {\n+        CLevelDBBatch batch;\n+        batch.Write(key, value);\n+        return WriteBatch(batch, fSync);\n+    }\n+\n+    template<typename K> bool Exists(const K& key) {\n+        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+        ssKey.reserve(ssKey.GetSerializeSize(key));\n+        ssKey << key;\n+        leveldb::Slice slKey(&ssKey[0], ssKey.size());\n+\n+        std::string strValue;\n+        leveldb::Status status = pdb->Get(readoptions, slKey, &strValue);\n+        if (!status.ok()) {\n+            if (status.IsNotFound())\n+                return false;\n+            printf(\"LevelDB read failure: %s\\n\", status.ToString().c_str());\n+        }\n+        return true;\n+    }\n+\n+    template<typename K> bool Erase(const K& key, bool fSync = false) {\n+        CLevelDBBatch batch;\n+        batch.Erase(key);\n+        return WriteBatch(batch, fSync);\n+    }\n+\n+    bool WriteBatch(CLevelDBBatch &batch, bool fSync = false);\n+\n+    // not available for LevelDB; provide for compatibility with BDB\n+    bool Flush() {\n+        return true;\n+    }\n+\n+    bool Sync() {\n+        CLevelDBBatch batch;\n+        return WriteBatch(batch, true);\n+    }\n+\n+    // not exactly clean encapsulation, but it's easiest for now\n+    leveldb::Iterator *NewIterator() {\n+        return pdb->NewIterator(iteroptions);\n+    }\n+};\n+\n+#endif // BITCOIN_LEVELDB_H\n+ \n\\ No newline at end of file"
      },
      {
        "sha": "9bad54cb61adeca74e78267dda77410ee8b5ba80",
        "filename": "src/makefile.linux-mingw",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b44e4b66b339875570b10805e9ffeec0840ad06/src/makefile.linux-mingw",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b44e4b66b339875570b10805e9ffeec0840ad06/src/makefile.linux-mingw",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.linux-mingw?ref=2b44e4b66b339875570b10805e9ffeec0840ad06",
        "patch": "@@ -88,12 +88,13 @@ OBJS= \\\n all: bitcoind.exe\n \n ifdef USE_LEVELDB\n-LIBS += $(CURDIR)/leveldb/libleveldb.lib $(CURDIR)/leveldb/libmemenv.a\n+LIBS += $(CURDIR)/leveldb/libleveldb.a $(CURDIR)/leveldb/libmemenv.a\n DEFS += -I\"$(CURDIR)/leveldb/include\" -DUSE_LEVELDB\n DEFS += -I\"$(CURDIR)/leveldb/helpers\"\n+OBJS += obj/leveldb.o\n leveldb/libleveldb.a:\n \t@echo \"Building LevelDB ...\"; cd leveldb; TARGET_OS=OS_WINDOWS_CROSSCOMPILE CXXFLAGS=\"-I$(INCLUDEPATHS)\" LDFLAGS=\"-L$(LIBPATHS)\" make libleveldb.a libmemenv.a; cd ..\n-obj/db.o: leveldb/libleveldb.a\n+obj/leveldb.o: leveldb/libleveldb.a\n endif\n \n obj/build.h: FORCE"
      },
      {
        "sha": "3953af3b0a1272c68b29e44bedd95a934090d0e8",
        "filename": "src/makefile.mingw",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b44e4b66b339875570b10805e9ffeec0840ad06/src/makefile.mingw",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b44e4b66b339875570b10805e9ffeec0840ad06/src/makefile.mingw",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.mingw?ref=2b44e4b66b339875570b10805e9ffeec0840ad06",
        "patch": "@@ -94,9 +94,10 @@ ifdef USE_LEVELDB\n LIBS += $(CURDIR)/leveldb/libleveldb.a $(CURDIR)/leveldb/libmemenv.a\n DEFS += $(addprefix -I,$(CURDIR)/leveldb/include) -DUSE_LEVELDB\n DEFS += $(addprefix -I,$(CURDIR)/leveldb/helpers)\n+OBJS += obj/leveldb.o\n leveldb/libleveldb.a:\n     cd leveldb; make libleveldb.a libmemenv.a; cd ..\n-obj/db.o: leveldb/libleveldb.lib\n+obj/leveldb.o: leveldb/libleveldb.lib\n endif\n \n obj/%.o: %.cpp $(HEADERS)"
      },
      {
        "sha": "618236521ac66339522926933fccf7e4e44571ba",
        "filename": "src/makefile.osx",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b44e4b66b339875570b10805e9ffeec0840ad06/src/makefile.osx",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b44e4b66b339875570b10805e9ffeec0840ad06/src/makefile.osx",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.osx?ref=2b44e4b66b339875570b10805e9ffeec0840ad06",
        "patch": "@@ -127,9 +127,10 @@ ifdef USE_LEVELDB\n LIBS += $(CURDIR)/leveldb/libleveldb.a $(CURDIR)/leveldb/libmemenv.a\n DEFS += $(addprefix -I,$(CURDIR)/leveldb/include) -DUSE_LEVELDB\n DEFS += $(addprefix -I,$(CURDIR)/leveldb/helpers)\n+OBJS += obj/leveldb.o\n leveldb/libleveldb.a:\n \t@echo \"Building LevelDB ...\"; cd leveldb; make libleveldb.a libmemenv.a; cd ..\n-obj/db.o: leveldb/libleveldb.a\n+obj/leveldb.o: leveldb/libleveldb.a\n endif\n \n # auto-generated dependencies:"
      },
      {
        "sha": "3fcefa1ea9225603c9a5a007650ad1292c2386a3",
        "filename": "src/makefile.unix",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b44e4b66b339875570b10805e9ffeec0840ad06/src/makefile.unix",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b44e4b66b339875570b10805e9ffeec0840ad06/src/makefile.unix",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.unix?ref=2b44e4b66b339875570b10805e9ffeec0840ad06",
        "patch": "@@ -143,9 +143,10 @@ ifdef USE_LEVELDB\n LIBS += $(CURDIR)/leveldb/libleveldb.a $(CURDIR)/leveldb/libmemenv.a\n DEFS += $(addprefix -I,$(CURDIR)/leveldb/include) -DUSE_LEVELDB\n DEFS += $(addprefix -I,$(CURDIR)/leveldb/helpers)\n+OBJS += obj/leveldb.o\n leveldb/libleveldb.a:\n \t@echo \"Building LevelDB ...\"; cd leveldb; make libleveldb.a libmemenv.a; cd ..;\n-obj/db.o: leveldb/libleveldb.a\n+obj/leveldb.o: leveldb/libleveldb.a\n endif\n \n # auto-generated dependencies:"
      }
    ]
  },
  {
    "sha": "396427bbd66447b9d31552a6ba62722ec33972c2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozOTY0MjdiYmQ2NjQ0N2I5ZDMxNTUyYTZiYTYyNzIyZWMzMzk3MmMy",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-06-15T12:19:11Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-19T23:55:51Z"
      },
      "message": "Compact serialization for variable-length integers\n\nVariable-length integers: bytes are a MSB base-128 encoding of the number.\nThe high bit in each byte signifies whether another digit follows. To make\nthe encoding is one-to-one, one is subtracted from all but the last digit.\nThus, the byte sequence a[] with length len, where all but the last byte\nhas bit 128 set, encodes the number:\n\n  (a[len-1] & 0x7F) + sum(i=1..len-1, 128^i*((a[len-i-1] & 0x7F)+1))\n\nProperties:\n* Very small (0-127: 1 byte, 128-16511: 2 bytes, 16512-2113663: 3 bytes)\n* Every integer has exactly one encoding\n* Encoding does not depend on size of original integer type",
      "tree": {
        "sha": "02f4f8d5cb22c9ca152e1cb55f9d62943ee5458e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/02f4f8d5cb22c9ca152e1cb55f9d62943ee5458e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/396427bbd66447b9d31552a6ba62722ec33972c2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/396427bbd66447b9d31552a6ba62722ec33972c2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/396427bbd66447b9d31552a6ba62722ec33972c2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/396427bbd66447b9d31552a6ba62722ec33972c2/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2b44e4b66b339875570b10805e9ffeec0840ad06",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2b44e4b66b339875570b10805e9ffeec0840ad06",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2b44e4b66b339875570b10805e9ffeec0840ad06"
      }
    ],
    "stats": {
      "total": 139,
      "additions": 138,
      "deletions": 1
    },
    "files": [
      {
        "sha": "549e46cbc3b89252a43c96fee479000bada9d571",
        "filename": "src/serialize.h",
        "status": "modified",
        "additions": 93,
        "deletions": 1,
        "changes": 94,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/396427bbd66447b9d31552a6ba62722ec33972c2/src/serialize.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/396427bbd66447b9d31552a6ba62722ec33972c2/src/serialize.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/serialize.h?ref=396427bbd66447b9d31552a6ba62722ec33972c2",
        "patch": "@@ -238,9 +238,75 @@ uint64 ReadCompactSize(Stream& is)\n     return nSizeRet;\n }\n \n+// Variable-length integers: bytes are a MSB base-128 encoding of the number.\n+// The high bit in each byte signifies whether another digit follows. To make\n+// the encoding is one-to-one, one is subtracted from all but the last digit.\n+// Thus, the byte sequence a[] with length len, where all but the last byte\n+// has bit 128 set, encodes the number:\n+//\n+//   (a[len-1] & 0x7F) + sum(i=1..len-1, 128^i*((a[len-i-1] & 0x7F)+1))\n+//\n+// Properties:\n+// * Very small (0-127: 1 byte, 128-16511: 2 bytes, 16512-2113663: 3 bytes)\n+// * Every integer has exactly one encoding\n+// * Encoding does not depend on size of original integer type\n+// * No redundancy: every (infinite) byte sequence corresponds to a list\n+//   of encoded integers.\n+//\n+// 0:         [0x00]  256:        [0x81 0x00]\n+// 1:         [0x01]  16383:      [0xFE 0x7F]\n+// 127:       [0x7F]  16384:      [0xFF 0x00]\n+// 128:  [0x80 0x00]  16511: [0x80 0xFF 0x7F]\n+// 255:  [0x80 0x7F]  65535: [0x82 0xFD 0x7F]\n+// 2^32:           [0x8E 0xFE 0xFE 0xFF 0x00]\n+\n+template<typename I>\n+inline unsigned int GetSizeOfVarInt(I n)\n+{\n+    int nRet = 0;\n+    while(true) {\n+        nRet++;\n+        if (n <= 0x7F)\n+            break;\n+        n = (n >> 7) - 1;\n+    }\n+    return nRet;\n+}\n+\n+template<typename Stream, typename I>\n+void WriteVarInt(Stream& os, I n)\n+{\n+    unsigned char tmp[(sizeof(n)*8+6)/7];\n+    int len=0;\n+    while(true) {\n+        tmp[len] = (n & 0x7F) | (len ? 0x80 : 0x00);\n+        if (n <= 0x7F)\n+            break;\n+        n = (n >> 7) - 1;\n+        len++;\n+    }\n+    do {\n+        WRITEDATA(os, tmp[len]);\n+    } while(len--);\n+}\n \n+template<typename Stream, typename I>\n+I ReadVarInt(Stream& is)\n+{\n+    I n = 0;\n+    while(true) {\n+        unsigned char chData;\n+        READDATA(is, chData);\n+        n = (n << 7) | (chData & 0x7F);\n+        if (chData & 0x80)\n+            n++;\n+        else\n+            return n;\n+    }\n+}\n \n-#define FLATDATA(obj)   REF(CFlatData((char*)&(obj), (char*)&(obj) + sizeof(obj)))\n+#define FLATDATA(obj)  REF(CFlatData((char*)&(obj), (char*)&(obj) + sizeof(obj)))\n+#define VARINT(obj)    REF(WrapVarInt(REF(obj)))\n \n /** Wrapper for serializing arrays and POD.\n  */\n@@ -274,6 +340,32 @@ class CFlatData\n     }\n };\n \n+template<typename I>\n+class CVarInt\n+{\n+protected:\n+    I &n;\n+public:\n+    CVarInt(I& nIn) : n(nIn) { }\n+\n+    unsigned int GetSerializeSize(int, int) const {\n+        return GetSizeOfVarInt<I>(n);\n+    }\n+\n+    template<typename Stream>\n+    void Serialize(Stream &s, int, int) const {\n+        WriteVarInt<Stream,I>(s, n);\n+    }\n+\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int, int) {\n+        n = ReadVarInt<Stream,I>(s);\n+    }\n+};\n+\n+template<typename I>\n+CVarInt<I> WrapVarInt(I& n) { return CVarInt<I>(n); }\n+\n //\n // Forward declarations\n //"
      },
      {
        "sha": "90ac89f8c5dba08f6062f377338c19591ef6ed2b",
        "filename": "src/test/serialize_tests.cpp",
        "status": "added",
        "additions": 45,
        "deletions": 0,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/396427bbd66447b9d31552a6ba62722ec33972c2/src/test/serialize_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/396427bbd66447b9d31552a6ba62722ec33972c2/src/test/serialize_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/serialize_tests.cpp?ref=396427bbd66447b9d31552a6ba62722ec33972c2",
        "patch": "@@ -0,0 +1,45 @@\n+#include <boost/test/unit_test.hpp>\n+\n+#include <string>\n+#include <vector>\n+\n+#include \"serialize.h\"\n+\n+using namespace std;\n+\n+BOOST_AUTO_TEST_SUITE(serialize_tests)\n+\n+BOOST_AUTO_TEST_CASE(varints)\n+{\n+    // encode\n+\n+    CDataStream ss(SER_DISK, 0);\n+    CDataStream::size_type size = 0;\n+    for (int i = 0; i < 100000; i++) {\n+        ss << VARINT(i);\n+        size += ::GetSerializeSize(VARINT(i), 0, 0);\n+        BOOST_CHECK(size == ss.size());\n+    }\n+\n+    for (uint64 i = 0;  i < 100000000000ULL; i += 999999937) {\n+        ss << VARINT(i);\n+        size += ::GetSerializeSize(VARINT(i), 0, 0);\n+        BOOST_CHECK(size == ss.size());\n+    }\n+\n+    // decode\n+    for (int i = 0; i < 100000; i++) {\n+        int j;\n+        ss >> VARINT(j);\n+        BOOST_CHECK_MESSAGE(i == j, \"decoded:\" << j << \" expected:\" << i);\n+    }\n+\n+    for (uint64 i = 0;  i < 100000000000ULL; i += 999999937) {\n+        uint64 j;\n+        ss >> VARINT(j);\n+        BOOST_CHECK_MESSAGE(i == j, \"decoded:\" << j << \" expected:\" << i);\n+    }\n+\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "df0001618619eacc745ef14189484720259644e7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkZjAwMDE2MTg2MTllYWNjNzQ1ZWYxNDE4OTQ4NDcyMDI1OTY0NGU3",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-06-15T16:52:19Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-19T23:55:51Z"
      },
      "message": "Compact serialization for scripts\n\nSpecial serializers for script which detect common cases and encode\nthem much more efficiently. 3 special cases are defined:\n* Pay to pubkey hash (encoded as 21 bytes)\n* Pay to script hash (encoded as 21 bytes)\n* Pay to pubkey starting with 0x02, 0x03 or 0x04 (encoded as 33 bytes)\n\nOther scripts up to 121 bytes require 1 byte + script length. Above\nthat, scripts up to 16505 bytes require 2 bytes + script length.",
      "tree": {
        "sha": "b800ff10cf08779f8e7e7e6f9aa0588452bb6885",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b800ff10cf08779f8e7e7e6f9aa0588452bb6885"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/df0001618619eacc745ef14189484720259644e7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/df0001618619eacc745ef14189484720259644e7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/df0001618619eacc745ef14189484720259644e7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/df0001618619eacc745ef14189484720259644e7/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "396427bbd66447b9d31552a6ba62722ec33972c2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/396427bbd66447b9d31552a6ba62722ec33972c2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/396427bbd66447b9d31552a6ba62722ec33972c2"
      }
    ],
    "stats": {
      "total": 217,
      "additions": 213,
      "deletions": 4
    },
    "files": [
      {
        "sha": "20114e6bb2feb3d7fefef3774294c127c56c172c",
        "filename": "src/key.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/df0001618619eacc745ef14189484720259644e7/src/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/df0001618619eacc745ef14189484720259644e7/src/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.cpp?ref=df0001618619eacc745ef14189484720259644e7",
        "patch": "@@ -120,9 +120,9 @@ int ECDSA_SIG_recover_key_GFp(EC_KEY *eckey, ECDSA_SIG *ecsig, const unsigned ch\n     return ret;\n }\n \n-void CKey::SetCompressedPubKey()\n+void CKey::SetCompressedPubKey(bool fCompressed)\n {\n-    EC_KEY_set_conv_form(pkey, POINT_CONVERSION_COMPRESSED);\n+    EC_KEY_set_conv_form(pkey, fCompressed ? POINT_CONVERSION_COMPRESSED : POINT_CONVERSION_UNCOMPRESSED);\n     fCompressedPubKey = true;\n }\n "
      },
      {
        "sha": "2a2723bbee79c92a5077ee58afe5fcc9801c1b77",
        "filename": "src/key.h",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/df0001618619eacc745ef14189484720259644e7/src/key.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/df0001618619eacc745ef14189484720259644e7/src/key.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.h?ref=df0001618619eacc745ef14189484720259644e7",
        "patch": "@@ -113,9 +113,8 @@ class CKey\n     bool fSet;\n     bool fCompressedPubKey;\n \n-    void SetCompressedPubKey();\n-\n public:\n+    void SetCompressedPubKey(bool fCompressed = true);\n \n     void Reset();\n "
      },
      {
        "sha": "1af781f45c70720ece1e37c8ea2a0cd942d2ad69",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/df0001618619eacc745ef14189484720259644e7/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/df0001618619eacc745ef14189484720259644e7/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=df0001618619eacc745ef14189484720259644e7",
        "patch": "@@ -647,6 +647,20 @@ class CTransaction\n     const CTxOut& GetOutputFor(const CTxIn& input, const MapPrevTx& inputs) const;\n };\n \n+/** wrapper for CTxOut that provides a more compact serialization */\n+class CTxOutCompressor\n+{\n+private:\n+    CTxOut &txout;\n+public:\n+    CTxOutCompressor(CTxOut &txoutIn) : txout(txoutIn) { }\n+\n+    IMPLEMENT_SERIALIZE(\n+        READWRITE(VARINT(txout.nValue));\n+        CScriptCompressor cscript(REF(txout.scriptPubKey));\n+        READWRITE(cscript);\n+    )\n+};\n \n \n "
      },
      {
        "sha": "a840bb1c0d49db67a2b16feb2d49b87e2efaa9b8",
        "filename": "src/script.cpp",
        "status": "modified",
        "additions": 125,
        "deletions": 0,
        "changes": 125,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/df0001618619eacc745ef14189484720259644e7/src/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/df0001618619eacc745ef14189484720259644e7/src/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.cpp?ref=df0001618619eacc745ef14189484720259644e7",
        "patch": "@@ -1951,3 +1951,128 @@ void CScript::SetMultisig(int nRequired, const std::vector<CKey>& keys)\n         *this << key.GetPubKey();\n     *this << EncodeOP_N(keys.size()) << OP_CHECKMULTISIG;\n }\n+\n+bool CScriptCompressor::IsToKeyID(CKeyID &hash) const\n+{\n+    if (script.size() == 25 && script[0] == OP_DUP && script[1] == OP_HASH160 \n+                            && script[2] == 20 && script[23] == OP_EQUALVERIFY\n+                            && script[24] == OP_CHECKSIG) {\n+        memcpy(&hash, &script[3], 20);\n+        return true;\n+    }\n+    return false;\n+}\n+\n+bool CScriptCompressor::IsToScriptID(CScriptID &hash) const\n+{\n+    if (script.size() == 23 && script[0] == OP_HASH160 && script[1] == 20\n+                            && script[22] == OP_EQUAL) {\n+        memcpy(&hash, &script[2], 20);\n+        return true;\n+    }\n+    return false;\n+}\n+\n+bool CScriptCompressor::IsToPubKey(std::vector<unsigned char> &pubkey) const\n+{\n+    if (script.size() == 35 && script[0] == 33 && script[34] == OP_CHECKSIG\n+                            && (script[1] == 0x02 || script[1] == 0x03)) {\n+        pubkey.resize(33);\n+        memcpy(&pubkey[0], &script[1], 33);\n+        return true;\n+    }\n+    if (script.size() == 67 && script[0] == 65 && script[66] == OP_CHECKSIG\n+                            && script[1] == 0x04) {\n+        pubkey.resize(65);\n+        memcpy(&pubkey[0], &script[1], 65);\n+        CKey key;\n+        return (key.SetPubKey(CPubKey(pubkey))); // SetPubKey fails if this is not a valid public key, a case that would not be compressible\n+    }\n+    return false;\n+}\n+\n+bool CScriptCompressor::Compress(std::vector<unsigned char> &out) const\n+{\n+    CKeyID keyID;\n+    if (IsToKeyID(keyID)) {\n+        out.resize(21);\n+        out[0] = 0x00;\n+        memcpy(&out[1], &keyID, 20);\n+        return true;\n+    }\n+    CScriptID scriptID;\n+    if (IsToScriptID(scriptID)) {\n+        out.resize(21);\n+        out[0] = 0x01;\n+        memcpy(&out[1], &scriptID, 20);\n+        return true;\n+    }\n+    std::vector<unsigned char> pubkey;\n+    if (IsToPubKey(pubkey)) {\n+        out.resize(33);\n+        memcpy(&out[1], &pubkey[1], 32);\n+        if (pubkey[0] == 0x02 || pubkey[0] == 0x03) {\n+            out[0] = pubkey[0];\n+            return true;\n+        } else if (pubkey[0] == 0x04) {\n+            out[0] = 0x04 | (pubkey[64] & 0x01);\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+unsigned int CScriptCompressor::GetSpecialSize(unsigned int nSize) const\n+{\n+    if (nSize == 0 || nSize == 1)\n+        return 20;\n+    if (nSize == 2 || nSize == 3 || nSize == 4 || nSize == 5)\n+        return 32;\n+    return 0;\n+}\n+\n+bool CScriptCompressor::Decompress(unsigned int nSize, const std::vector<unsigned char> &in)\n+{\n+    switch(nSize) {\n+    case 0x00:\n+        script.resize(25);\n+        script[0] = OP_DUP;\n+        script[1] = OP_HASH160;\n+        script[2] = 20;\n+        memcpy(&script[3], &in[0], 20);\n+        script[23] = OP_EQUALVERIFY;\n+        script[24] = OP_CHECKSIG;\n+        return true;\n+    case 0x01:\n+        script.resize(23);\n+        script[0] = OP_HASH160;\n+        script[1] = 20;\n+        memcpy(&script[2], &in[0], 20);\n+        script[22] = OP_EQUAL;\n+        return true;\n+    case 0x02:\n+    case 0x03:\n+        script.resize(35);\n+        script[0] = 33;\n+        script[1] = nSize;\n+        memcpy(&script[2], &in[0], 32);\n+        script[34] = OP_CHECKSIG;\n+        return true;\n+    case 0x04:\n+    case 0x05:\n+        std::vector<unsigned char> vch(33, 0x00);\n+        vch[0] = nSize - 2;\n+        memcpy(&vch[1], &in[0], 32);\n+        CKey key;\n+        if (!key.SetPubKey(CPubKey(vch)))\n+            return false;\n+        key.SetCompressedPubKey(false); // Decompress public key\n+        CPubKey pubkey = key.GetPubKey();\n+        script.resize(67);\n+        script[0] = 65;\n+        memcpy(&script[1], &pubkey.Raw()[0], 65);\n+        script[66] = OP_CHECKSIG;\n+        return true;\n+    }\n+    return false;\n+}"
      },
      {
        "sha": "e7b52d95e1ade786af746e60cec78e97dc51995e",
        "filename": "src/script.h",
        "status": "modified",
        "additions": 71,
        "deletions": 0,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/df0001618619eacc745ef14189484720259644e7/src/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/df0001618619eacc745ef14189484720259644e7/src/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.h?ref=df0001618619eacc745ef14189484720259644e7",
        "patch": "@@ -579,7 +579,78 @@ class CScript : public std::vector<unsigned char>\n     }\n };\n \n+/** Compact serializer for scripts.\n+ *\n+ *  It detects common cases and encodes them much more efficiently.\n+ *  3 special cases are defined:\n+ *  * Pay to pubkey hash (encoded as 21 bytes)\n+ *  * Pay to script hash (encoded as 21 bytes)\n+ *  * Pay to pubkey starting with 0x02, 0x03 or 0x04 (encoded as 33 bytes)\n+ *\n+ *  Other scripts up to 121 bytes require 1 byte + script length. Above\n+ *  that, scripts up to 16505 bytes require 2 bytes + script length.\n+ */\n+class CScriptCompressor\n+{\n+private:\n+    // make this static for now (there are only 6 special scripts defined)\n+    // this can potentially be extended together with a new nVersion for\n+    // transactions, in which case this value becomes dependent on nVersion\n+    // and nHeight of the enclosing transaction.\n+    static const unsigned int nSpecialScripts = 6;\n+\n+    CScript &script;\n+protected:\n+    // These check for scripts for which a special case with a shorter encoding is defined.\n+    // They are implemented separately from the CScript test, as these test for exact byte\n+    // sequence correspondences, and are more strict. For example, IsToPubKey also verifies\n+    // whether the public key is valid (as invalid ones cannot be represented in compressed\n+    // form).\n+    bool IsToKeyID(CKeyID &hash) const;\n+    bool IsToScriptID(CScriptID &hash) const;\n+    bool IsToPubKey(std::vector<unsigned char> &pubkey) const;\n+\n+    bool Compress(std::vector<unsigned char> &out) const;\n+    unsigned int GetSpecialSize(unsigned int nSize) const;\n+    bool Decompress(unsigned int nSize, const std::vector<unsigned char> &out);\n+public:\n+    CScriptCompressor(CScript &scriptIn) : script(scriptIn) { }\n+\n+    unsigned int GetSerializeSize(int nType, int nVersion) const {\n+        std::vector<unsigned char> compr;\n+        if (Compress(compr))\n+            return compr.size();\n+        unsigned int nSize = script.size() + nSpecialScripts;\n+        return script.size() + VARINT(nSize).GetSerializeSize(nType, nVersion);\n+    }\n \n+    template<typename Stream>\n+    void Serialize(Stream &s, int nType, int nVersion) const {\n+        std::vector<unsigned char> compr;\n+        if (Compress(compr)) {\n+            s << CFlatData(&compr[0], &compr[compr.size()]);\n+            return;\n+        }\n+        unsigned int nSize = script.size() + nSpecialScripts;\n+        s << VARINT(nSize);\n+        s << CFlatData(&script[0], &script[script.size()]);\n+    }\n+\n+    template<typename Stream>\n+    void Unserialize(Stream &s, int nType, int nVersion) {\n+        unsigned int nSize;\n+        s >> VARINT(nSize);\n+        if (nSize < nSpecialScripts) {\n+            std::vector<unsigned char> vch(GetSpecialSize(nSize), 0x00);\n+            s >> REF(CFlatData(&vch[0], &vch[vch.size()]));\n+            Decompress(nSize, vch);\n+            return;\n+        }\n+        nSize -= nSpecialScripts;\n+        script.resize(nSize);\n+        s >> REF(CFlatData(&script[0], &script[script.size()]));\n+    }\n+};\n \n bool IsCanonicalPubKey(const std::vector<unsigned char> &vchPubKey);\n bool IsCanonicalSignature(const std::vector<unsigned char> &vchSig);"
      }
    ]
  },
  {
    "sha": "ac9073c93ede6d77b62663fe1a0ff564fa44a24b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphYzkwNzNjOTNlZGU2ZDc3YjYyNjYzZmUxYTBmZjU2NGZhNDRhMjRi",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-06-16T11:36:00Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-19T23:55:51Z"
      },
      "message": "Compact serialization for amounts\n\nSpecial serializer/deserializer for amount values. It is optimized for\nvalues which have few non-zero digits in decimal representation. Most\namounts currently in the txout set take only 1 or 2 bytes to\nrepresent.",
      "tree": {
        "sha": "e7c296456e910c22bf09dceee3291f6a30fa3c50",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e7c296456e910c22bf09dceee3291f6a30fa3c50"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ac9073c93ede6d77b62663fe1a0ff564fa44a24b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ac9073c93ede6d77b62663fe1a0ff564fa44a24b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ac9073c93ede6d77b62663fe1a0ff564fa44a24b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ac9073c93ede6d77b62663fe1a0ff564fa44a24b/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "df0001618619eacc745ef14189484720259644e7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/df0001618619eacc745ef14189484720259644e7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/df0001618619eacc745ef14189484720259644e7"
      }
    ],
    "stats": {
      "total": 133,
      "additions": 130,
      "deletions": 3
    },
    "files": [
      {
        "sha": "ed677f31c8477f1f99ee645c9622b65f83dea2ce",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 54,
        "deletions": 0,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac9073c93ede6d77b62663fe1a0ff564fa44a24b/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac9073c93ede6d77b62663fe1a0ff564fa44a24b/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=ac9073c93ede6d77b62663fe1a0ff564fa44a24b",
        "patch": "@@ -4058,3 +4058,57 @@ void GenerateBitcoins(bool fGenerate, CWallet* pwallet)\n         }\n     }\n }\n+\n+// Amount compression:\n+// * If the amount is 0, output 0\n+// * first, divide the amount (in base units) by the largest power of 10 possible; call the exponent e (e is max 9)\n+// * if e<9, the last digit of the resulting number cannot be 0; store it as d, and drop it (divide by 10)\n+//   * call the result n\n+//   * output 1 + 10*(9*n + d - 1) + e\n+// * if e==9, we only know the resulting number is not zero, so output 1 + 10*(n - 1) + 9\n+// (this is decodable, as d is in [1-9] and e is in [0-9])\n+\n+uint64 CTxOutCompressor::CompressAmount(uint64 n)\n+{\n+    if (n == 0)\n+        return 0;\n+    int e = 0;\n+    while (((n % 10) == 0) && e < 9) {\n+        n /= 10;\n+        e++;\n+    }\n+    if (e < 9) {\n+        int d = (n % 10);\n+        assert(d >= 1 && d <= 9);\n+        n /= 10;\n+        return 1 + (n*9 + d - 1)*10 + e;\n+    } else {\n+        return 1 + (n - 1)*10 + 9;\n+    }\n+}\n+\n+uint64 CTxOutCompressor::DecompressAmount(uint64 x)\n+{\n+    // x = 0  OR  x = 1+10*(9*n + d - 1) + e  OR  x = 1+10*(n - 1) + 9\n+    if (x == 0)\n+        return 0;\n+    x--;\n+    // x = 10*(9*n + d - 1) + e\n+    int e = x % 10;\n+    x /= 10;\n+    uint64 n = 0;\n+    if (e < 9) {\n+        // x = 9*n + d - 1\n+        int d = (x % 9) + 1;\n+        x /= 9;\n+        // x = n\n+        n = x*10 + d;\n+    } else {\n+        n = x+1;\n+    }\n+    while (e) {\n+        n *= 10;\n+        e--;\n+    }\n+    return n;\n+}"
      },
      {
        "sha": "4286880c9f81a90181c8f3458e495f4284ca99f4",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 14,
        "deletions": 3,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac9073c93ede6d77b62663fe1a0ff564fa44a24b/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac9073c93ede6d77b62663fe1a0ff564fa44a24b/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=ac9073c93ede6d77b62663fe1a0ff564fa44a24b",
        "patch": "@@ -652,14 +652,25 @@ class CTxOutCompressor\n {\n private:\n     CTxOut &txout;\n+\n public:\n+    static uint64 CompressAmount(uint64 nAmount);\n+    static uint64 DecompressAmount(uint64 nAmount);\n+\n     CTxOutCompressor(CTxOut &txoutIn) : txout(txoutIn) { }\n \n-    IMPLEMENT_SERIALIZE(\n-        READWRITE(VARINT(txout.nValue));\n+    IMPLEMENT_SERIALIZE(({\n+        if (!fRead) {\n+            uint64 nVal = CompressAmount(txout.nValue);\n+            READWRITE(VARINT(nVal));\n+        } else {\n+            uint64 nVal = 0;\n+            READWRITE(VARINT(nVal));\n+            txout.nValue = DecompressAmount(nVal);\n+        }\n         CScriptCompressor cscript(REF(txout.scriptPubKey));\n         READWRITE(cscript);\n-    )\n+    });)\n };\n \n "
      },
      {
        "sha": "71b86bcb4121dfcf13f9d9703605ba7eb0865c4b",
        "filename": "src/test/compress_tests.cpp",
        "status": "added",
        "additions": 62,
        "deletions": 0,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ac9073c93ede6d77b62663fe1a0ff564fa44a24b/src/test/compress_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ac9073c93ede6d77b62663fe1a0ff564fa44a24b/src/test/compress_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/compress_tests.cpp?ref=ac9073c93ede6d77b62663fe1a0ff564fa44a24b",
        "patch": "@@ -0,0 +1,62 @@\n+#include <boost/test/unit_test.hpp>\n+\n+#include <string>\n+#include <vector>\n+\n+#include \"main.h\"\n+\n+// amounts 0.00000001 .. 0.00100000\n+#define NUM_MULTIPLES_UNIT 100000\n+\n+// amounts 0.01 .. 100.00\n+#define NUM_MULTIPLES_CENT 10000\n+\n+// amounts 1 .. 10000\n+#define NUM_MULTIPLES_1BTC 10000\n+\n+// amounts 50 .. 21000000\n+#define NUM_MULTIPLES_50BTC 420000\n+\n+using namespace std;\n+\n+BOOST_AUTO_TEST_SUITE(compress_tests)\n+\n+bool static TestEncode(uint64 in) {\n+    return in == CTxOutCompressor::DecompressAmount(CTxOutCompressor::CompressAmount(in));\n+}\n+\n+bool static TestDecode(uint64 in) {\n+    return in == CTxOutCompressor::CompressAmount(CTxOutCompressor::DecompressAmount(in));\n+}\n+\n+bool static TestPair(uint64 dec, uint64 enc) {\n+    return CTxOutCompressor::CompressAmount(dec) == enc &&\n+           CTxOutCompressor::DecompressAmount(enc) == dec;\n+}\n+\n+BOOST_AUTO_TEST_CASE(compress_amounts)\n+{\n+    BOOST_CHECK(TestPair(            0,       0x0));\n+    BOOST_CHECK(TestPair(            1,       0x1));\n+    BOOST_CHECK(TestPair(         CENT,       0x7));\n+    BOOST_CHECK(TestPair(         COIN,       0x9));\n+    BOOST_CHECK(TestPair(      50*COIN,      0x32));\n+    BOOST_CHECK(TestPair(21000000*COIN, 0x1406f40));\n+\n+    for (uint64 i = 1; i <= NUM_MULTIPLES_UNIT; i++)\n+        BOOST_CHECK(TestEncode(i));\n+\n+    for (uint64 i = 1; i <= NUM_MULTIPLES_CENT; i++)\n+        BOOST_CHECK(TestEncode(i * CENT));\n+\n+    for (uint64 i = 1; i <= NUM_MULTIPLES_1BTC; i++)\n+        BOOST_CHECK(TestEncode(i * COIN));\n+\n+    for (uint64 i = 1; i <= NUM_MULTIPLES_50BTC; i++)\n+        BOOST_CHECK(TestEncode(i * 50 * COIN));\n+\n+    for (uint64 i = 0; i < 100000; i++)\n+        BOOST_CHECK(TestDecode(i));\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "ca487b5d68aaec5ccbdc95fd0c5b5c6327fd3802",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjYTQ4N2I1ZDY4YWFlYzVjY2JkYzk1ZmQwYzViNWM2MzI3ZmQzODAy",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-06-15T13:27:09Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-20T13:39:07Z"
      },
      "message": "Add CCoins: pruned list of transaction outputs\n\nThe CCoins class represents a pruned set of transaction outputs from\na given transaction. It only retains information about its height in\nthe block chain, whether it was a coinbase transaction, and its\nunspent outputs (script + amount).\n\nIt has a custom serializer that has very low redundancy.",
      "tree": {
        "sha": "5564890a276d522b6f01295aaa6e360aefd3030d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5564890a276d522b6f01295aaa6e360aefd3030d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ca487b5d68aaec5ccbdc95fd0c5b5c6327fd3802",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ca487b5d68aaec5ccbdc95fd0c5b5c6327fd3802",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ca487b5d68aaec5ccbdc95fd0c5b5c6327fd3802",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ca487b5d68aaec5ccbdc95fd0c5b5c6327fd3802/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ac9073c93ede6d77b62663fe1a0ff564fa44a24b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ac9073c93ede6d77b62663fe1a0ff564fa44a24b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ac9073c93ede6d77b62663fe1a0ff564fa44a24b"
      }
    ],
    "stats": {
      "total": 234,
      "additions": 233,
      "deletions": 1
    },
    "files": [
      {
        "sha": "833fd492307e6d4473413256fb0d26b6fbce4f6f",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 233,
        "deletions": 1,
        "changes": 234,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca487b5d68aaec5ccbdc95fd0c5b5c6327fd3802/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca487b5d68aaec5ccbdc95fd0c5b5c6327fd3802/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=ca487b5d68aaec5ccbdc95fd0c5b5c6327fd3802",
        "patch": "@@ -337,7 +337,7 @@ class CTxOut\n         scriptPubKey.clear();\n     }\n \n-    bool IsNull()\n+    bool IsNull() const\n     {\n         return (nValue == -1);\n     }\n@@ -673,6 +673,238 @@ class CTxOutCompressor\n     });)\n };\n \n+/** pruned version of CTransaction: only retains metadata and unspent transaction outputs\n+ *\n+ * Serialized format:\n+ * - VARINT(nVersion)\n+ * - VARINT(nCode)\n+ * - unspentness bitvector, for vout[2] and further; least significant byte first\n+ * - the non-spent CTxOuts (via CTxOutCompressor)\n+ * - VARINT(nHeight)\n+ *\n+ * The nCode value consists of:\n+ * - bit 1: IsCoinBase()\n+ * - bit 2: vout[0] is not spent\n+ * - bit 4: vout[1] is not spent\n+ * - The higher bits encode N, the number of non-zero bytes in the following bitvector.\n+ *   - In case both bit 2 and bit 4 are unset, they encode N-1, as there must be at\n+ *     least one non-spent output).\n+ *\n+ * Example: 0104835800816115944e077fe7c803cfa57f29b36bf87c1d358bb85e\n+ *          <><><--------------------------------------------><---->\n+ *          |  \\                  |                             /\n+ *    version   code             vout[1]                  height\n+ *\n+ *    - version = 1\n+ *    - code = 4 (vout[1] is not spent, and 0 non-zero bytes of bitvector follow)\n+ *    - unspentness bitvector: as 0 non-zero bytes follow, it has length 0\n+ *    - vout[1]: 835800816115944e077fe7c803cfa57f29b36bf87c1d35\n+ *               * 8358: compact amount representation for 60000000000 (600 BTC)\n+ *               * 00: special txout type pay-to-pubkey-hash\n+ *               * 816115944e077fe7c803cfa57f29b36bf87c1d35: address uint160\n+ *    - height = 203998\n+ *\n+ *\n+ * Example: 0109044086ef97d5790061b01caab50f1b8e9c50a5057eb43c2d9563a4eebbd123008c988f1a4a4de2161e0f50aac7f17e7f9555caa486af3b\n+ *          <><><--><--------------------------------------------------><----------------------------------------------><---->\n+ *         /  \\   \\                     |                                                           |                     /\n+ *  version  code  unspentness       vout[4]                                                     vout[16]           height\n+ *\n+ *  - version = 1\n+ *  - code = 9 (coinbase, neither vout[0] or vout[1] are unspent,\n+ *                2 (1, +1 because both bit 2 and bit 4 are unset) non-zero bitvector bytes follow)\n+ *  - unspentness bitvector: bits 2 (0x04) and 14 (0x4000) are set, so vout[2+2] and vout[14+2] are unspent\n+ *  - vout[4]: 86ef97d5790061b01caab50f1b8e9c50a5057eb43c2d9563a4ee\n+ *             * 86ef97d579: compact amount representation for 234925952 (2.35 BTC)\n+ *             * 00: special txout type pay-to-pubkey-hash\n+ *             * 61b01caab50f1b8e9c50a5057eb43c2d9563a4ee: address uint160\n+ *  - vout[16]: bbd123008c988f1a4a4de2161e0f50aac7f17e7f9555caa4\n+ *              * bbd123: compact amount representation for 110397 (0.001 BTC)\n+ *              * 00: special txout type pay-to-pubkey-hash\n+ *              * 8c988f1a4a4de2161e0f50aac7f17e7f9555caa4: address uint160\n+ *  - height = 120891\n+ */\n+class CCoins\n+{\n+public:\n+    // whether transaction is a coinbase\n+    bool fCoinBase;\n+\n+    // unspent transaction outputs; spent outputs are .IsNull(); spent outputs at the end of the array are dropped\n+    std::vector<CTxOut> vout;\n+\n+    // at which height this transaction was included in the active blockchain\n+    int nHeight;\n+\n+    // version of the CTransaction; accesses to this value should probably check for nHeight as well,\n+    // as new tx version will probably only be introduced at certain heights\n+    int nVersion;\n+\n+    // construct a CCoins from a CTransaction, at a given height\n+    CCoins(const CTransaction &tx, int nHeightIn) : fCoinBase(tx.IsCoinBase()), vout(tx.vout), nHeight(nHeightIn), nVersion(tx.nVersion) { }\n+\n+    // empty constructor\n+    CCoins() : fCoinBase(false), vout(0), nHeight(0), nVersion(0) { }\n+\n+    // remove spent outputs at the end of vout\n+    void Cleanup() {\n+        while (vout.size() > 0 && vout.back().IsNull())\n+            vout.pop_back();\n+    }\n+\n+    // equality test\n+    friend bool operator==(const CCoins &a, const CCoins &b) {\n+         return a.fCoinBase == b.fCoinBase && \n+                a.nHeight == b.nHeight &&\n+                a.nVersion == b.nVersion &&\n+                a.vout == b.vout;\n+    }\n+    friend bool operator!=(const CCoins &a, const CCoins &b) {\n+        return !(a == b);\n+    }\n+\n+    // calculate number of bytes for the bitmask, and its number of non-zero bytes\n+    // each bit in the bitmask represents the availability of one output, but the\n+    // availabilities of the first two outputs are encoded separately\n+    void CalcMaskSize(unsigned int &nBytes, unsigned int &nNonzeroBytes) const {\n+        unsigned int nLastUsedByte = 0;\n+        for (unsigned int b = 0; 2+b*8 < vout.size(); b++) {\n+            bool fZero = true;\n+            for (unsigned int i = 0; i < 8 && 2+b*8+i < vout.size(); i++) {\n+                if (!vout[2+b*8+i].IsNull()) {\n+                    fZero = false;\n+                    continue;\n+                }\n+            }\n+            if (!fZero) {\n+                nLastUsedByte = b + 1;\n+                nNonzeroBytes++;\n+            }\n+        }\n+        nBytes += nLastUsedByte;\n+    }\n+\n+    bool IsCoinBase() const {\n+        return fCoinBase;\n+    }\n+\n+    unsigned int GetSerializeSize(int nType, int nVersion) const {\n+        unsigned int nSize = 0;\n+        unsigned int nMaskSize = 0, nMaskCode = 0;\n+        CalcMaskSize(nMaskSize, nMaskCode);\n+        bool fFirst = vout.size() > 0 && !vout[0].IsNull();\n+        bool fSecond = vout.size() > 1 && !vout[1].IsNull();\n+        assert(fFirst || fSecond || nMaskCode);\n+        unsigned int nCode = 8*(nMaskCode - (fFirst || fSecond ? 0 : 1)) + (fCoinBase ? 1 : 0) + (fFirst ? 2 : 0) + (fSecond ? 4 : 0);\n+        // version\n+        nSize += ::GetSerializeSize(VARINT(this->nVersion), nType, nVersion);\n+        // size of header code\n+        nSize += ::GetSerializeSize(VARINT(nCode), nType, nVersion);\n+        // spentness bitmask\n+        nSize += nMaskSize;\n+        // txouts themself\n+        for (unsigned int i = 0; i < vout.size(); i++)\n+            if (!vout[i].IsNull())\n+                nSize += ::GetSerializeSize(CTxOutCompressor(REF(vout[i])), nType, nVersion);\n+        // height\n+        nSize += ::GetSerializeSize(VARINT(nHeight), nType, nVersion);\n+        return nSize;\n+    }\n+\n+    template<typename Stream>\n+    void Serialize(Stream &s, int nType, int nVersion) const {\n+        unsigned int nMaskSize = 0, nMaskCode = 0;\n+        CalcMaskSize(nMaskSize, nMaskCode);\n+        bool fFirst = vout.size() > 0 && !vout[0].IsNull();\n+        bool fSecond = vout.size() > 1 && !vout[1].IsNull();\n+        assert(fFirst || fSecond || nMaskCode);\n+        unsigned int nCode = 8*(nMaskCode - (fFirst || fSecond ? 0 : 1)) + (fCoinBase ? 1 : 0) + (fFirst ? 2 : 0) + (fSecond ? 4 : 0);\n+        // version\n+        ::Serialize(s, VARINT(this->nVersion), nType, nVersion);\n+        // header code\n+        ::Serialize(s, VARINT(nCode), nType, nVersion);\n+        // spentness bitmask\n+        for (unsigned int b = 0; b<nMaskSize; b++) {\n+            unsigned char chAvail = 0;\n+            for (unsigned int i = 0; i < 8 && 2+b*8+i < vout.size(); i++)\n+                if (!vout[2+b*8+i].IsNull())\n+                    chAvail |= (1 << i);\n+            ::Serialize(s, chAvail, nType, nVersion);\n+        }\n+        // txouts themself\n+        for (unsigned int i = 0; i < vout.size(); i++) {\n+            if (!vout[i].IsNull())\n+                ::Serialize(s, CTxOutCompressor(REF(vout[i])), nType, nVersion);\n+        }\n+        // coinbase height\n+        ::Serialize(s, VARINT(nHeight), nType, nVersion);\n+    }\n+\n+    template<typename Stream>\n+    void Unserialize(Stream &s, int nType, int nVersion) {\n+        unsigned int nCode = 0;\n+        // version\n+        ::Unserialize(s, VARINT(this->nVersion), nType, nVersion);\n+        // header code\n+        ::Unserialize(s, VARINT(nCode), nType, nVersion);\n+        fCoinBase = nCode & 1;\n+        std::vector<bool> vAvail(2, false);\n+        vAvail[0] = nCode & 2;\n+        vAvail[1] = nCode & 4;\n+        unsigned int nMaskCode = (nCode / 8) + ((nCode & 6) != 0 ? 0 : 1);\n+        // spentness bitmask\n+        while (nMaskCode > 0) {\n+            unsigned char chAvail = 0;\n+            ::Unserialize(s, chAvail, nType, nVersion);\n+            for (unsigned int p = 0; p < 8; p++) {\n+                bool f = (chAvail & (1 << p)) != 0;\n+                vAvail.push_back(f);\n+            }\n+            if (chAvail != 0)\n+                nMaskCode--;\n+        }\n+        // txouts themself\n+        vout.assign(vAvail.size(), CTxOut());\n+        for (unsigned int i = 0; i < vAvail.size(); i++) {\n+            if (vAvail[i])\n+                ::Unserialize(s, REF(CTxOutCompressor(vout[i])), nType, nVersion);\n+        }\n+        // coinbase height\n+        ::Unserialize(s, VARINT(nHeight), nType, nVersion);\n+        Cleanup();\n+    }\n+\n+    // mark an outpoint spent\n+    bool Spend(const COutPoint &out) {\n+        if (out.n >= vout.size())\n+            return false;\n+        if (vout[out.n].IsNull())\n+            return false;\n+        vout[out.n].SetNull();\n+        Cleanup();\n+        return true;\n+    }\n+\n+    // mark a vout spent\n+    bool Spend(int nPos) {\n+        COutPoint out(0, nPos);\n+        return Spend(out);\n+    }\n+\n+    // check whether a particular output is still available\n+    bool IsAvailable(unsigned int nPos) const {\n+        return (nPos < vout.size() && !vout[nPos].IsNull());\n+    }\n+\n+    // check whether the entire CCoins is spent\n+    // note that only !IsPruned() CCoins can be serialized\n+    bool IsPruned() const {\n+        BOOST_FOREACH(const CTxOut &out, vout)\n+            if (!out.IsNull())\n+                return false;\n+        return true;\n+    }\n+};\n \n \n "
      }
    ]
  },
  {
    "sha": "39ddb97ca52ef80998b09b6d8984e1c248d514b3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozOWRkYjk3Y2E1MmVmODA5OThiMDliNmQ4OTg0ZTFjMjQ4ZDUxNGIz",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-06-18T14:55:29Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-20T13:39:11Z"
      },
      "message": "Add CTxUndo: transaction undo information\n\nThe CTxUndo class encapsulates data necessary to undo the effects of\na transaction on the txout set, namely the previous outputs consumed\nby it (script + amount), and potentially transaction meta-data when\nit is spent entirely.",
      "tree": {
        "sha": "967f11bc84981f0c24b9ae4eaee3fa5956582558",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/967f11bc84981f0c24b9ae4eaee3fa5956582558"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/39ddb97ca52ef80998b09b6d8984e1c248d514b3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/39ddb97ca52ef80998b09b6d8984e1c248d514b3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/39ddb97ca52ef80998b09b6d8984e1c248d514b3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/39ddb97ca52ef80998b09b6d8984e1c248d514b3/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ca487b5d68aaec5ccbdc95fd0c5b5c6327fd3802",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ca487b5d68aaec5ccbdc95fd0c5b5c6327fd3802",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ca487b5d68aaec5ccbdc95fd0c5b5c6327fd3802"
      }
    ],
    "stats": {
      "total": 67,
      "additions": 64,
      "deletions": 3
    },
    "files": [
      {
        "sha": "0c85286391f57e9dd9a11563b14462c391a10d00",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 64,
        "deletions": 3,
        "changes": 67,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39ddb97ca52ef80998b09b6d8984e1c248d514b3/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39ddb97ca52ef80998b09b6d8984e1c248d514b3/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=39ddb97ca52ef80998b09b6d8984e1c248d514b3",
        "patch": "@@ -673,6 +673,60 @@ class CTxOutCompressor\n     });)\n };\n \n+/** Undo information for a CTxIn\n+ *\n+ *  Contains the prevout's CTxOut being spent, and if this was the\n+ *  last output of the affected transaction, its metadata as well\n+ *  (coinbase or not, height, transaction version)\n+ */\n+class CTxInUndo\n+{\n+public:\n+    CTxOut txout;         // the txout data before being spent\n+    bool fCoinBase;       // if the outpoint was the last unspent: whether it belonged to a coinbase\n+    unsigned int nHeight; // if the outpoint was the last unspent: its height\n+    int nVersion;         // if the outpoint was the last unspent: its version\n+\n+    CTxInUndo() : txout(), fCoinBase(false), nHeight(0), nVersion(0) {}\n+    CTxInUndo(const CTxOut &txoutIn, bool fCoinBaseIn = false, unsigned int nHeightIn = 0, int nVersionIn = 0) : txout(txoutIn), fCoinBase(fCoinBaseIn), nHeight(nHeightIn), nVersion(nVersionIn) { }\n+\n+    unsigned int GetSerializeSize(int nType, int nVersion) const {\n+        return ::GetSerializeSize(VARINT(nHeight*2+(fCoinBase ? 1 : 0)), nType, nVersion) +\n+               (nHeight > 0 ? ::GetSerializeSize(VARINT(this->nVersion), nType, nVersion) : 0) +\n+               ::GetSerializeSize(CTxOutCompressor(REF(txout)), nType, nVersion);\n+    }\n+\n+    template<typename Stream>\n+    void Serialize(Stream &s, int nType, int nVersion) const {\n+        ::Serialize(s, VARINT(nHeight*2+(fCoinBase ? 1 : 0)), nType, nVersion);\n+        if (nHeight > 0)\n+            ::Serialize(s, VARINT(this->nVersion), nType, nVersion);\n+        ::Serialize(s, CTxOutCompressor(REF(txout)), nType, nVersion);\n+    }\n+\n+    template<typename Stream>\n+    void Unserialize(Stream &s, int nType, int nVersion) {\n+        unsigned int nCode = 0;\n+        ::Unserialize(s, VARINT(nCode), nType, nVersion);\n+        nHeight = nCode / 2;\n+        fCoinBase = nCode & 1;\n+        if (nHeight > 0)\n+            ::Unserialize(s, VARINT(this->nVersion), nType, nVersion);\n+        ::Unserialize(s, REF(CTxOutCompressor(REF(txout))), nType, nVersion);\n+    }\n+};\n+\n+/** Undo information for a CTransaction */\n+class CTxUndo\n+{\n+public:\n+    std::vector<CTxInUndo> vprevout;\n+\n+    IMPLEMENT_SERIALIZE(\n+        READWRITE(vprevout);\n+    )\n+};\n+\n /** pruned version of CTransaction: only retains metadata and unspent transaction outputs\n  *\n  * Serialized format:\n@@ -874,21 +928,28 @@ class CCoins\n         Cleanup();\n     }\n \n-    // mark an outpoint spent\n-    bool Spend(const COutPoint &out) {\n+    // mark an outpoint spent, and construct undo information\n+    bool Spend(const COutPoint &out, CTxInUndo &undo) {\n         if (out.n >= vout.size())\n             return false;\n         if (vout[out.n].IsNull())\n             return false;\n+        undo = CTxInUndo(vout[out.n]);\n         vout[out.n].SetNull();\n         Cleanup();\n+        if (vout.size() == 0) {\n+            undo.nHeight = nHeight;\n+            undo.fCoinBase = fCoinBase;\n+            undo.nVersion = this->nVersion;\n+        }\n         return true;\n     }\n \n     // mark a vout spent\n     bool Spend(int nPos) {\n+        CTxInUndo undo;\n         COutPoint out(0, nPos);\n-        return Spend(out);\n+        return Spend(out, undo);\n     }\n \n     // check whether a particular output is still available"
      }
    ]
  },
  {
    "sha": "d213076d14f587bf88a30bcb57707981ffa510b4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkMjEzMDc2ZDE0ZjU4N2JmODhhMzBiY2I1NzcwNzk4MWZmYTUxMGI0",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-06-18T23:36:43Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-20T13:39:11Z"
      },
      "message": "One file per block\n\nRefactor of the block storage code, which now stores one file per block.\nThis will allow easier pruning, as blocks can be removed individually.",
      "tree": {
        "sha": "6cb32ecd892a2d2f0368e57ea424f7efcd601b1a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6cb32ecd892a2d2f0368e57ea424f7efcd601b1a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d213076d14f587bf88a30bcb57707981ffa510b4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d213076d14f587bf88a30bcb57707981ffa510b4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d213076d14f587bf88a30bcb57707981ffa510b4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d213076d14f587bf88a30bcb57707981ffa510b4/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "39ddb97ca52ef80998b09b6d8984e1c248d514b3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/39ddb97ca52ef80998b09b6d8984e1c248d514b3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/39ddb97ca52ef80998b09b6d8984e1c248d514b3"
      }
    ],
    "stats": {
      "total": 279,
      "additions": 155,
      "deletions": 124
    },
    "files": [
      {
        "sha": "cef395c44420f668eb000f95f5a4615684e0b05e",
        "filename": "src/db.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 12,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d213076d14f587bf88a30bcb57707981ffa510b4/src/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d213076d14f587bf88a30bcb57707981ffa510b4/src/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.cpp?ref=d213076d14f587bf88a30bcb57707981ffa510b4",
        "patch": "@@ -637,12 +637,12 @@ bool CTxDB::LoadBlockIndex()\n         nCheckDepth = nBestHeight;\n     printf(\"Verifying last %i blocks at level %i\\n\", nCheckDepth, nCheckLevel);\n     CBlockIndex* pindexFork = NULL;\n-    map<pair<unsigned int, unsigned int>, CBlockIndex*> mapBlockPos;\n     for (CBlockIndex* pindex = pindexBest; pindex && pindex->pprev; pindex = pindex->pprev)\n     {\n         if (fRequestShutdown || pindex->nHeight < nBestHeight-nCheckDepth)\n             break;\n         CBlock block;\n+        CDiskBlockPos blockPos = pindex->GetBlockPos();\n         if (!block.ReadFromDisk(pindex))\n             return error(\"LoadBlockIndex() : block.ReadFromDisk failed\");\n         // check level 1: verify block validity\n@@ -654,16 +654,14 @@ bool CTxDB::LoadBlockIndex()\n         // check level 2: verify transaction index validity\n         if (nCheckLevel>1)\n         {\n-            pair<unsigned int, unsigned int> pos = make_pair(pindex->nFile, pindex->nBlockPos);\n-            mapBlockPos[pos] = pindex;\n             BOOST_FOREACH(const CTransaction &tx, block.vtx)\n             {\n                 uint256 hashTx = tx.GetHash();\n                 CTxIndex txindex;\n                 if (ReadTxIndex(hashTx, txindex))\n                 {\n                     // check level 3: checker transaction hashes\n-                    if (nCheckLevel>2 || pindex->nFile != txindex.pos.nFile || pindex->nBlockPos != txindex.pos.nBlockPos)\n+                    if (nCheckLevel>2 || blockPos != txindex.pos.blockPos)\n                     {\n                         // either an error or a duplicate transaction\n                         CTransaction txFound;\n@@ -687,12 +685,6 @@ bool CTxDB::LoadBlockIndex()\n                         {\n                             if (!txpos.IsNull())\n                             {\n-                                pair<unsigned int, unsigned int> posFind = make_pair(txpos.nFile, txpos.nBlockPos);\n-                                if (!mapBlockPos.count(posFind))\n-                                {\n-                                    printf(\"LoadBlockIndex(): *** found bad spend at %d, hashBlock=%s, hashTx=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str(), hashTx.ToString().c_str());\n-                                    pindexFork = pindex->pprev;\n-                                }\n                                 // check level 6: check whether spent txouts were spent by a valid transaction that consume them\n                                 if (nCheckLevel>5)\n                                 {\n@@ -795,9 +787,8 @@ bool CTxDB::LoadBlockIndexGuts()\n             CBlockIndex* pindexNew = InsertBlockIndex(diskindex.GetBlockHash());\n             pindexNew->pprev          = InsertBlockIndex(diskindex.hashPrev);\n             pindexNew->pnext          = InsertBlockIndex(diskindex.hashNext);\n-            pindexNew->nFile          = diskindex.nFile;\n-            pindexNew->nBlockPos      = diskindex.nBlockPos;\n             pindexNew->nHeight        = diskindex.nHeight;\n+            pindexNew->nAlternative   = diskindex.nAlternative;\n             pindexNew->nVersion       = diskindex.nVersion;\n             pindexNew->hashMerkleRoot = diskindex.hashMerkleRoot;\n             pindexNew->nTime          = diskindex.nTime;"
      },
      {
        "sha": "fa818bd05393359d021c0e1e7746ead5b851f577",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 34,
        "deletions": 69,
        "changes": 103,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d213076d14f587bf88a30bcb57707981ffa510b4/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d213076d14f587bf88a30bcb57707981ffa510b4/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=d213076d14f587bf88a30bcb57707981ffa510b4",
        "patch": "@@ -389,7 +389,7 @@ int CMerkleTx::SetMerkleBranch(const CBlock* pblock)\n             CTxIndex txindex;\n             if (!CTxDB(\"r\").ReadTxIndex(GetHash(), txindex))\n                 return 0;\n-            if (!blockTmp.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos))\n+            if (!blockTmp.ReadFromDisk(txindex.pos.blockPos))\n                 return 0;\n             pblock = &blockTmp;\n         }\n@@ -646,7 +646,7 @@ bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,\n \n         // Check against previous transactions\n         // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n-        if (!tx.ConnectInputs(mapInputs, mapUnused, CDiskTxPos(1,1,1), pindexBest, false, false))\n+        if (!tx.ConnectInputs(mapInputs, mapUnused, CDiskTxPos(true), pindexBest, false, false))\n         {\n             return error(\"CTxMemPool::accept() : ConnectInputs failed %s\", hash.ToString().substr(0,10).c_str());\n         }\n@@ -817,7 +817,7 @@ int CTxIndex::GetDepthInMainChain() const\n {\n     // Read block header\n     CBlock block;\n-    if (!block.ReadFromDisk(pos.nFile, pos.nBlockPos, false))\n+    if (!block.ReadFromDisk(pos.blockPos, false))\n         return 0;\n     // Find the block in the index\n     map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(block.GetHash());\n@@ -847,7 +847,7 @@ bool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock)\n         if (tx.ReadFromDisk(txdb, COutPoint(hash, 0), txindex))\n         {\n             CBlock block;\n-            if (block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n+            if (block.ReadFromDisk(txindex.pos.blockPos, false))\n                 hashBlock = block.GetHash();\n             return true;\n         }\n@@ -892,7 +892,7 @@ bool CBlock::ReadFromDisk(const CBlockIndex* pindex, bool fReadTransactions)\n         *this = pindex->GetBlockHeader();\n         return true;\n     }\n-    if (!ReadFromDisk(pindex->nFile, pindex->nBlockPos, fReadTransactions))\n+    if (!ReadFromDisk(pindex->GetBlockPos(), fReadTransactions))\n         return false;\n     if (GetHash() != pindex->GetBlockHash())\n         return error(\"CBlock::ReadFromDisk() : GetHash() doesn't match index\");\n@@ -1156,7 +1156,7 @@ bool CTransaction::FetchInputs(CTxDB& txdb, const map<uint256, CTxIndex>& mapTes\n \n         // Read txPrev\n         CTransaction& txPrev = inputsRet[prevout.hash].second;\n-        if (!fFound || txindex.pos == CDiskTxPos(1,1,1))\n+        if (!fFound || txindex.pos.IsMemPool())\n         {\n             // Get prev tx from single transactions in memory\n             {\n@@ -1262,7 +1262,7 @@ bool CTransaction::ConnectInputs(MapPrevTx inputs,\n             // If prev is coinbase, check that it's matured\n             if (txPrev.IsCoinBase())\n                 for (const CBlockIndex* pindex = pindexBlock; pindex && pindexBlock->nHeight - pindex->nHeight < COINBASE_MATURITY; pindex = pindex->pprev)\n-                    if (pindex->nBlockPos == txindex.pos.nBlockPos && pindex->nFile == txindex.pos.nFile)\n+                    if (pindex->GetBlockPos() == txindex.pos.blockPos)\n                         return error(\"ConnectInputs() : tried to spend coinbase at depth %d\", pindexBlock->nHeight - pindex->nHeight);\n \n             // Check for negative or overflow input values\n@@ -1427,11 +1427,10 @@ bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex, bool fJustCheck)\n     //// issue here: it doesn't know the version\n     unsigned int nTxPos;\n     if (fJustCheck)\n-        // FetchInputs treats CDiskTxPos(1,1,1) as a special \"refer to memorypool\" indicator\n         // Since we're just checking the block and not actually connecting it, it might not (and probably shouldn't) be on the disk to get the transaction from\n         nTxPos = 1;\n     else\n-        nTxPos = pindex->nBlockPos + ::GetSerializeSize(CBlock(), SER_DISK, CLIENT_VERSION) - 1 + GetSizeOfCompactSize(vtx.size());\n+        nTxPos = ::GetSerializeSize(CBlock(), SER_DISK, CLIENT_VERSION) - 1 + GetSizeOfCompactSize(vtx.size());\n \n     map<uint256, CTxIndex> mapQueuedChanges;\n     int64 nFees = 0;\n@@ -1453,9 +1452,11 @@ bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex, bool fJustCheck)\n         if (nSigOps > MAX_BLOCK_SIGOPS)\n             return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n \n-        CDiskTxPos posThisTx(pindex->nFile, pindex->nBlockPos, nTxPos);\n+        CDiskTxPos posThisTx(pindex->GetBlockPos(), nTxPos);\n         if (!fJustCheck)\n             nTxPos += ::GetSerializeSize(tx, SER_DISK, CLIENT_VERSION);\n+        else\n+            posThisTx = CDiskTxPos(true);\n \n         MapPrevTx mapInputs;\n         if (!tx.IsCoinBase())\n@@ -1750,15 +1751,15 @@ bool CBlock::SetBestChain(CTxDB& txdb, CBlockIndex* pindexNew)\n }\n \n \n-bool CBlock::AddToBlockIndex(unsigned int nFile, unsigned int nBlockPos)\n+bool CBlock::AddToBlockIndex(const CDiskBlockPos &pos)\n {\n     // Check for duplicate\n     uint256 hash = GetHash();\n     if (mapBlockIndex.count(hash))\n         return error(\"AddToBlockIndex() : %s already exists\", hash.ToString().substr(0,20).c_str());\n \n     // Construct new block index object\n-    CBlockIndex* pindexNew = new CBlockIndex(nFile, nBlockPos, *this);\n+    CBlockIndex* pindexNew = new CBlockIndex(*this);\n     if (!pindexNew)\n         return error(\"AddToBlockIndex() : new CBlockIndex failed\");\n     map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.insert(make_pair(hash, pindexNew)).first;\n@@ -1770,6 +1771,8 @@ bool CBlock::AddToBlockIndex(unsigned int nFile, unsigned int nBlockPos)\n         pindexNew->nHeight = pindexNew->pprev->nHeight + 1;\n     }\n     pindexNew->bnChainWork = (pindexNew->pprev ? pindexNew->pprev->bnChainWork : 0) + pindexNew->GetBlockWork();\n+    assert(pos.nHeight == pindexNew->nHeight);\n+    pindexNew->nAlternative = pos.nAlternative;\n \n     CTxDB txdb;\n     if (!txdb.TxnBegin())\n@@ -1908,13 +1911,12 @@ bool CBlock::AcceptBlock()\n     }\n \n     // Write block to history file\n+    CDiskBlockPos blockPos = CDiskBlockPos(nHeight);\n     if (!CheckDiskSpace(::GetSerializeSize(*this, SER_DISK, CLIENT_VERSION)))\n         return error(\"AcceptBlock() : out of disk space\");\n-    unsigned int nFile = -1;\n-    unsigned int nBlockPos = 0;\n-    if (!WriteToDisk(nFile, nBlockPos))\n+    if (!WriteToDisk(blockPos))\n         return error(\"AcceptBlock() : WriteToDisk failed\");\n-    if (!AddToBlockIndex(nFile, nBlockPos))\n+    if (!AddToBlockIndex(blockPos))\n         return error(\"AcceptBlock() : AddToBlockIndex failed\");\n \n     // Relay inventory, but don't relay old inventory during initial block download\n@@ -2048,53 +2050,18 @@ bool CheckDiskSpace(uint64 nAdditionalBytes)\n     return true;\n }\n \n-static filesystem::path BlockFilePath(unsigned int nFile)\n+FILE* OpenBlockFile(const CDiskBlockPos &pos, const char* pszMode)\n {\n-    string strBlockFn = strprintf(\"blk%04u.dat\", nFile);\n-    return GetDataDir() / strBlockFn;\n-}\n-\n-FILE* OpenBlockFile(unsigned int nFile, unsigned int nBlockPos, const char* pszMode)\n-{\n-    if ((nFile < 1) || (nFile == (unsigned int) -1))\n+    boost::filesystem::path path = pos.GetFileName(GetDataDir());\n+    boost::filesystem::create_directories(path.parent_path());\n+    if (pos.IsNull() || pos.IsMemPool())\n         return NULL;\n-    FILE* file = fopen(BlockFilePath(nFile).string().c_str(), pszMode);\n+    FILE* file = fopen(path.string().c_str(), pszMode);\n     if (!file)\n         return NULL;\n-    if (nBlockPos != 0 && !strchr(pszMode, 'a') && !strchr(pszMode, 'w'))\n-    {\n-        if (fseek(file, nBlockPos, SEEK_SET) != 0)\n-        {\n-            fclose(file);\n-            return NULL;\n-        }\n-    }\n     return file;\n }\n \n-static unsigned int nCurrentBlockFile = 1;\n-\n-FILE* AppendBlockFile(unsigned int& nFileRet)\n-{\n-    nFileRet = 0;\n-    loop\n-    {\n-        FILE* file = OpenBlockFile(nCurrentBlockFile, 0, \"ab\");\n-        if (!file)\n-            return NULL;\n-        if (fseek(file, 0, SEEK_END) != 0)\n-            return NULL;\n-        // FAT32 file size max 4GB, fseek and ftell max 2GB, so we must stay under 2GB\n-        if (ftell(file) < (long)(0x7F000000 - MAX_SIZE))\n-        {\n-            nFileRet = nCurrentBlockFile;\n-            return file;\n-        }\n-        fclose(file);\n-        nCurrentBlockFile++;\n-    }\n-}\n-\n bool LoadBlockIndex(bool fAllowNew)\n {\n     if (fTestNet)\n@@ -2153,19 +2120,19 @@ bool LoadBlockIndex(bool fAllowNew)\n         }\n \n         //// debug print\n-        printf(\"%s\\n\", block.GetHash().ToString().c_str());\n+        uint256 hash = block.GetHash();\n+        printf(\"%s\\n\", hash.ToString().c_str());\n         printf(\"%s\\n\", hashGenesisBlock.ToString().c_str());\n         printf(\"%s\\n\", block.hashMerkleRoot.ToString().c_str());\n         assert(block.hashMerkleRoot == uint256(\"0x4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b\"));\n         block.print();\n-        assert(block.GetHash() == hashGenesisBlock);\n+        assert(hash == hashGenesisBlock);\n \n         // Start new block file\n-        unsigned int nFile;\n-        unsigned int nBlockPos;\n-        if (!block.WriteToDisk(nFile, nBlockPos))\n+        CDiskBlockPos blockPos(0);\n+        if (!block.WriteToDisk(blockPos))\n             return error(\"LoadBlockIndex() : writing genesis block to disk failed\");\n-        if (!block.AddToBlockIndex(nFile, nBlockPos))\n+        if (!block.AddToBlockIndex(blockPos))\n             return error(\"LoadBlockIndex() : genesis block not accepted\");\n     }\n \n@@ -2219,11 +2186,9 @@ void PrintBlockTree()\n         // print item\n         CBlock block;\n         block.ReadFromDisk(pindex);\n-        printf(\"%d (%u,%u) %s  %s  tx %\"PRIszu\"\",\n+        printf(\"%d (%s)  %s  tx %\"PRIszu\"\",\n             pindex->nHeight,\n-            pindex->nFile,\n-            pindex->nBlockPos,\n-            block.GetHash().ToString().substr(0,20).c_str(),\n+            pindex->GetBlockPos().GetFileName(\"\").string().c_str(),\n             DateTimeStrFormat(\"%x %H:%M:%S\", block.GetBlockTime()).c_str(),\n             block.vtx.size());\n \n@@ -3693,9 +3658,9 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n             if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)\n                 continue;\n \n-            if (!tx.ConnectInputs(mapInputs, mapTestPoolTmp, CDiskTxPos(1,1,1), pindexPrev, false, true))\n+            if (!tx.ConnectInputs(mapInputs, mapTestPoolTmp, CDiskTxPos(true), pindexPrev, false, true))\n                 continue;\n-            mapTestPoolTmp[tx.GetHash()] = CTxIndex(CDiskTxPos(1,1,1), tx.vout.size());\n+            mapTestPoolTmp[tx.GetHash()] = CTxIndex(CDiskTxPos(true), tx.vout.size());\n             swap(mapTestPool, mapTestPoolTmp);\n \n             // Added\n@@ -3743,7 +3708,7 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n     pblock->nNonce         = 0;\n \n         pblock->vtx[0].vin[0].scriptSig = scriptDummy;\n-        CBlockIndex indexDummy(1, 1, *pblock);\n+        CBlockIndex indexDummy(*pblock);\n         indexDummy.pprev = pindexPrev;\n         indexDummy.nHeight = pindexPrev->nHeight + 1;\n         if (!pblock->ConnectBlock(txdb, &indexDummy, true))"
      },
      {
        "sha": "a1d6334746185af19d0f0fb1a84b42aa12e1d908",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 118,
        "deletions": 43,
        "changes": 161,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d213076d14f587bf88a30bcb57707981ffa510b4/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d213076d14f587bf88a30bcb57707981ffa510b4/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=d213076d14f587bf88a30bcb57707981ffa510b4",
        "patch": "@@ -80,14 +80,14 @@ static const uint64 nMinDiskSpace = 52428800;\n class CReserveKey;\n class CTxDB;\n class CTxIndex;\n+class CDiskBlockPos;\n \n void RegisterWallet(CWallet* pwalletIn);\n void UnregisterWallet(CWallet* pwalletIn);\n void SyncWithWallets(const CTransaction& tx, const CBlock* pblock = NULL, bool fUpdate = false);\n bool ProcessBlock(CNode* pfrom, CBlock* pblock);\n bool CheckDiskSpace(uint64 nAdditionalBytes=0);\n-FILE* OpenBlockFile(unsigned int nFile, unsigned int nBlockPos, const char* pszMode=\"rb\");\n-FILE* AppendBlockFile(unsigned int& nFileRet);\n+FILE* OpenBlockFile(const CDiskBlockPos &pos, const char* pszMode=\"rb\");\n bool LoadBlockIndex(bool fAllowNew=true);\n void PrintBlockTree();\n CBlockIndex* FindBlockByHeight(int nHeight);\n@@ -118,34 +118,115 @@ bool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock);\n \n bool GetWalletFile(CWallet* pwallet, std::string &strWalletFileOut);\n \n+class CDiskBlockPos\n+{\n+public:\n+    int nHeight;\n+    int nAlternative;\n+\n+    CDiskBlockPos() {\n+        SetNull();\n+    }\n+\n+    CDiskBlockPos(int nHeightIn, int nAlternativeIn = 0) {\n+        nHeight = nHeightIn;\n+        nAlternative = nAlternativeIn;\n+    }\n+\n+    std::string GetAlternative() const {\n+        char c[9]={0,0,0,0,0,0,0,0,0};\n+        char *cp = &c[8];\n+        unsigned int n = nAlternative;\n+        while (n > 0 && cp>c) {\n+            n--;\n+            *(--cp) = 'a' + (n % 26);\n+            n /= 26;\n+        }\n+        return std::string(cp);\n+    }\n+\n+    boost::filesystem::path GetDirectory(const boost::filesystem::path &base) const {\n+        assert(nHeight != -1);\n+        return base / strprintf(\"era%02u\", nHeight / 210000) / \n+                      strprintf(\"cycle%04u\", nHeight / 2016);\n+    }\n+\n+    boost::filesystem::path GetFileName(const boost::filesystem::path &base) const {\n+        return GetDirectory(base) / strprintf(\"%08u%s.blk\", nHeight, GetAlternative().c_str());\n+    }\n+\n+    // TODO: make thread-safe (lockfile, atomic file creation, ...?)\n+    void MakeUnique(const boost::filesystem::path &base) {\n+        while (boost::filesystem::exists(GetFileName(base)))\n+            nAlternative++;\n+    }\n+\n+    IMPLEMENT_SERIALIZE(({\n+        CDiskBlockPos *me = const_cast<CDiskBlockPos*>(this);\n+        if (!fRead) {\n+            unsigned int nCode = (nHeight + 1) * 2 + (nAlternative > 0);\n+            READWRITE(VARINT(nCode));\n+            if (nAlternative > 0) {\n+                unsigned int nAlt = nAlternative - 1;\n+                READWRITE(VARINT(nAlt));\n+            }\n+        } else {\n+            unsigned int nCode = 0;\n+            READWRITE(VARINT(nCode));\n+            me->nHeight = (nCode / 2) - 1;\n+            if (nCode & 1) {\n+                unsigned int nAlt = 0;\n+                READWRITE(VARINT(nAlt));\n+                me->nAlternative = 1 + nAlt;\n+            } else {\n+                me->nAlternative = 0;\n+            }\n+        }\n+    });)\n+\n+    friend bool operator==(const CDiskBlockPos &a, const CDiskBlockPos &b) {\n+        return ((a.nHeight == b.nHeight) && (a.nAlternative == b.nAlternative));\n+    }\n+\n+    friend bool operator!=(const CDiskBlockPos &a, const CDiskBlockPos &b) {\n+        return !(a == b);\n+    }\n+\n+    void SetNull() { nHeight = -1; nAlternative = 0; }\n+    bool IsNull() const { return ((nHeight == -1) && (nAlternative == 0)); }\n+\n+    void SetMemPool() { nHeight = -1; nAlternative = -1; }\n+    bool IsMemPool() const { return ((nHeight == -1) && (nAlternative == -1)); }\n+};\n+\n /** Position on disk for a particular transaction. */\n class CDiskTxPos\n {\n public:\n-    unsigned int nFile;\n-    unsigned int nBlockPos;\n+    CDiskBlockPos blockPos;\n     unsigned int nTxPos;\n \n-    CDiskTxPos()\n+    CDiskTxPos(bool fInMemPool = false)\n     {\n         SetNull();\n+        if (fInMemPool)\n+            blockPos.SetMemPool();\n     }\n \n-    CDiskTxPos(unsigned int nFileIn, unsigned int nBlockPosIn, unsigned int nTxPosIn)\n-    {\n-        nFile = nFileIn;\n-        nBlockPos = nBlockPosIn;\n-        nTxPos = nTxPosIn;\n-    }\n+    CDiskTxPos(const CDiskBlockPos &block, unsigned int nTxPosIn) : blockPos(block), nTxPos(nTxPosIn) { }\n \n-    IMPLEMENT_SERIALIZE( READWRITE(FLATDATA(*this)); )\n-    void SetNull() { nFile = (unsigned int) -1; nBlockPos = 0; nTxPos = 0; }\n-    bool IsNull() const { return (nFile == (unsigned int) -1); }\n+    IMPLEMENT_SERIALIZE( \n+        READWRITE(blockPos);\n+        READWRITE(VARINT(nTxPos));\n+    )\n+\n+    void SetNull() { blockPos.SetNull(); nTxPos = 0; }\n+    bool IsNull() const { return blockPos.IsNull(); }\n+    bool IsMemPool() const { return blockPos.IsMemPool(); }\n \n     friend bool operator==(const CDiskTxPos& a, const CDiskTxPos& b)\n     {\n-        return (a.nFile     == b.nFile &&\n-                a.nBlockPos == b.nBlockPos &&\n+        return (a.blockPos  == b.blockPos &&\n                 a.nTxPos    == b.nTxPos);\n     }\n \n@@ -158,8 +239,10 @@ class CDiskTxPos\n     {\n         if (IsNull())\n             return \"null\";\n+        else if (blockPos.IsMemPool())\n+            return \"mempool\";\n         else\n-            return strprintf(\"(nFile=%u, nBlockPos=%u, nTxPos=%u)\", nFile, nBlockPos, nTxPos);\n+            return strprintf(\"(%s, nTxPos=%u)\", blockPos.GetFileName(\"\").string().c_str(), nTxPos);\n     }\n \n     void print() const\n@@ -545,7 +628,7 @@ class CTransaction\n \n     bool ReadFromDisk(CDiskTxPos pos, FILE** pfileRet=NULL)\n     {\n-        CAutoFile filein = CAutoFile(OpenBlockFile(pos.nFile, 0, pfileRet ? \"rb+\" : \"rb\"), SER_DISK, CLIENT_VERSION);\n+        CAutoFile filein = CAutoFile(OpenBlockFile(pos.blockPos, pfileRet ? \"rb+\" : \"rb\"), SER_DISK, CLIENT_VERSION);\n         if (!filein)\n             return error(\"CTransaction::ReadFromDisk() : OpenBlockFile failed\");\n \n@@ -1215,22 +1298,15 @@ class CBlock\n     }\n \n \n-    bool WriteToDisk(unsigned int& nFileRet, unsigned int& nBlockPosRet)\n+    bool WriteToDisk(CDiskBlockPos &pos)\n     {\n         // Open history file to append\n-        CAutoFile fileout = CAutoFile(AppendBlockFile(nFileRet), SER_DISK, CLIENT_VERSION);\n+        pos.MakeUnique(GetDataDir());\n+        CAutoFile fileout = CAutoFile(OpenBlockFile(pos, \"ab\"), SER_DISK, CLIENT_VERSION);\n         if (!fileout)\n             return error(\"CBlock::WriteToDisk() : AppendBlockFile failed\");\n \n-        // Write index header\n-        unsigned int nSize = fileout.GetSerializeSize(*this);\n-        fileout << FLATDATA(pchMessageStart) << nSize;\n-\n         // Write block\n-        long fileOutPos = ftell(fileout);\n-        if (fileOutPos < 0)\n-            return error(\"CBlock::WriteToDisk() : ftell failed\");\n-        nBlockPosRet = fileOutPos;\n         fileout << *this;\n \n         // Flush stdio buffers and commit to disk before returning\n@@ -1241,12 +1317,12 @@ class CBlock\n         return true;\n     }\n \n-    bool ReadFromDisk(unsigned int nFile, unsigned int nBlockPos, bool fReadTransactions=true)\n+    bool ReadFromDisk(const CDiskBlockPos &pos, bool fReadTransactions = true)\n     {\n         SetNull();\n \n         // Open history file to read\n-        CAutoFile filein = CAutoFile(OpenBlockFile(nFile, nBlockPos, \"rb\"), SER_DISK, CLIENT_VERSION);\n+        CAutoFile filein = CAutoFile(OpenBlockFile(pos, \"rb\"), SER_DISK, CLIENT_VERSION);\n         if (!filein)\n             return error(\"CBlock::ReadFromDisk() : OpenBlockFile failed\");\n         if (!fReadTransactions)\n@@ -1294,7 +1370,7 @@ class CBlock\n     bool ConnectBlock(CTxDB& txdb, CBlockIndex* pindex, bool fJustCheck=false);\n     bool ReadFromDisk(const CBlockIndex* pindex, bool fReadTransactions=true);\n     bool SetBestChain(CTxDB& txdb, CBlockIndex* pindexNew);\n-    bool AddToBlockIndex(unsigned int nFile, unsigned int nBlockPos);\n+    bool AddToBlockIndex(const CDiskBlockPos &pos);\n     bool CheckBlock(bool fCheckPOW=true, bool fCheckMerkleRoot=true) const;\n     bool AcceptBlock();\n \n@@ -1320,9 +1396,8 @@ class CBlockIndex\n     const uint256* phashBlock;\n     CBlockIndex* pprev;\n     CBlockIndex* pnext;\n-    unsigned int nFile;\n-    unsigned int nBlockPos;\n     int nHeight;\n+    unsigned int nAlternative;\n     CBigNum bnChainWork;\n \n     // block header\n@@ -1338,10 +1413,9 @@ class CBlockIndex\n         phashBlock = NULL;\n         pprev = NULL;\n         pnext = NULL;\n-        nFile = 0;\n-        nBlockPos = 0;\n         nHeight = 0;\n         bnChainWork = 0;\n+        nAlternative = 0;\n \n         nVersion       = 0;\n         hashMerkleRoot = 0;\n@@ -1350,15 +1424,14 @@ class CBlockIndex\n         nNonce         = 0;\n     }\n \n-    CBlockIndex(unsigned int nFileIn, unsigned int nBlockPosIn, CBlock& block)\n+    CBlockIndex(CBlock& block)\n     {\n         phashBlock = NULL;\n         pprev = NULL;\n         pnext = NULL;\n-        nFile = nFileIn;\n-        nBlockPos = nBlockPosIn;\n         nHeight = 0;\n         bnChainWork = 0;\n+        nAlternative = 0;\n \n         nVersion       = block.nVersion;\n         hashMerkleRoot = block.hashMerkleRoot;\n@@ -1367,6 +1440,10 @@ class CBlockIndex\n         nNonce         = block.nNonce;\n     }\n \n+    CDiskBlockPos GetBlockPos() const {\n+        return CDiskBlockPos(nHeight, nAlternative);\n+    }\n+\n     CBlock GetBlockHeader() const\n     {\n         CBlock block;\n@@ -1444,11 +1521,10 @@ class CBlockIndex\n     static bool IsSuperMajority(int minVersion, const CBlockIndex* pstart,\n                                 unsigned int nRequired, unsigned int nToCheck);\n \n-\n     std::string ToString() const\n     {\n-        return strprintf(\"CBlockIndex(pprev=%p, pnext=%p, nFile=%u, nBlockPos=%-6u nHeight=%d, merkle=%s, hashBlock=%s)\",\n-            pprev, pnext, nFile, nBlockPos, nHeight,\n+        return strprintf(\"CBlockIndex(pprev=%p, pnext=%p, nHeight=%d, merkle=%s, hashBlock=%s)\",\n+            pprev, pnext, nHeight,\n             hashMerkleRoot.ToString().substr(0,10).c_str(),\n             GetBlockHash().ToString().substr(0,20).c_str());\n     }\n@@ -1486,9 +1562,8 @@ class CDiskBlockIndex : public CBlockIndex\n             READWRITE(nVersion);\n \n         READWRITE(hashNext);\n-        READWRITE(nFile);\n-        READWRITE(nBlockPos);\n         READWRITE(nHeight);\n+        READWRITE(nAlternative);\n \n         // block header\n         READWRITE(this->nVersion);"
      }
    ]
  },
  {
    "sha": "4415a7f1f55651b461281c2198e8fc23f135503b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0NDE1YTdmMWY1NTY1MWI0NjEyODFjMjE5OGU4ZmMyM2YxMzU1MDNi",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-06-23T12:17:13Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-20T13:39:11Z"
      },
      "message": "Preliminary undo file creation\n\nCreate files (one per block) with undo information for the transactions\nin it.",
      "tree": {
        "sha": "017ab9d78c3269430c82ca35f0e107f34ca98373",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/017ab9d78c3269430c82ca35f0e107f34ca98373"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4415a7f1f55651b461281c2198e8fc23f135503b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4415a7f1f55651b461281c2198e8fc23f135503b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4415a7f1f55651b461281c2198e8fc23f135503b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4415a7f1f55651b461281c2198e8fc23f135503b/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d213076d14f587bf88a30bcb57707981ffa510b4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d213076d14f587bf88a30bcb57707981ffa510b4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d213076d14f587bf88a30bcb57707981ffa510b4"
      }
    ],
    "stats": {
      "total": 32,
      "additions": 32,
      "deletions": 0
    },
    "files": [
      {
        "sha": "8b1532e48ca2a018b5625acf117f8160bd9b929b",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4415a7f1f55651b461281c2198e8fc23f135503b/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4415a7f1f55651b461281c2198e8fc23f135503b/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=4415a7f1f55651b461281c2198e8fc23f135503b",
        "patch": "@@ -1432,6 +1432,8 @@ bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex, bool fJustCheck)\n     else\n         nTxPos = ::GetSerializeSize(CBlock(), SER_DISK, CLIENT_VERSION) - 1 + GetSizeOfCompactSize(vtx.size());\n \n+    CBlockUndo blockundo;\n+\n     map<uint256, CTxIndex> mapQueuedChanges;\n     int64 nFees = 0;\n     unsigned int nSigOps = 0;\n@@ -1461,6 +1463,8 @@ bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex, bool fJustCheck)\n         MapPrevTx mapInputs;\n         if (!tx.IsCoinBase())\n         {\n+            CTxUndo undo;\n+\n             bool fInvalid;\n             if (!tx.FetchInputs(txdb, mapQueuedChanges, true, false, mapInputs, fInvalid))\n                 return false;\n@@ -1477,8 +1481,14 @@ bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex, bool fJustCheck)\n \n             nFees += tx.GetValueIn(mapInputs)-tx.GetValueOut();\n \n+            BOOST_FOREACH(const CTxIn &in, tx.vin) {\n+                undo.vprevout.push_back(CTxInUndo(mapInputs[in.prevout.hash].second.vout[in.prevout.n], pindex->nHeight));\n+            }\n+\n             if (!tx.ConnectInputs(mapInputs, mapQueuedChanges, posThisTx, pindex, true, false, fStrictPayToScriptHash))\n                 return false;\n+\n+            blockundo.vtxundo.push_back(undo);\n         }\n \n         mapQueuedChanges[hashTx] = CTxIndex(posThisTx, tx.vout.size());\n@@ -1507,6 +1517,13 @@ bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex, bool fJustCheck)\n             return error(\"ConnectBlock() : WriteBlockIndex failed\");\n     }\n \n+    // Write undo information to disk\n+    if (pindex->nHeight > Checkpoints::GetTotalBlocksEstimate())\n+    {\n+        CAutoFile fileUndo(fopen(pindex->GetBlockPos().GetUndoFile(GetDataDir()).string().c_str(), \"wb\"), SER_DISK, CLIENT_VERSION);\n+        fileUndo << blockundo;\n+    }\n+\n     // Watch for transactions paying to me\n     BOOST_FOREACH(CTransaction& tx, vtx)\n         SyncWithWallets(tx, this, true);"
      },
      {
        "sha": "9257b53f30c18fff96ffb9817fd3081b8cb795fa",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4415a7f1f55651b461281c2198e8fc23f135503b/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4415a7f1f55651b461281c2198e8fc23f135503b/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=4415a7f1f55651b461281c2198e8fc23f135503b",
        "patch": "@@ -155,6 +155,10 @@ class CDiskBlockPos\n         return GetDirectory(base) / strprintf(\"%08u%s.blk\", nHeight, GetAlternative().c_str());\n     }\n \n+    boost::filesystem::path GetUndoFile(const boost::filesystem::path &base) const {\n+        return GetDirectory(base) / strprintf(\"%08u%s.und\", nHeight, GetAlternative().c_str());\n+    }\n+\n     // TODO: make thread-safe (lockfile, atomic file creation, ...?)\n     void MakeUnique(const boost::filesystem::path &base) {\n         while (boost::filesystem::exists(GetFileName(base)))\n@@ -810,6 +814,17 @@ class CTxUndo\n     )\n };\n \n+/** Undo information for a CBlock */\n+class CBlockUndo\n+{\n+public:\n+    std::vector<CTxUndo> vtxundo;\n+\n+    IMPLEMENT_SERIALIZE(\n+        READWRITE(vtxundo);\n+    )\n+};\n+\n /** pruned version of CTransaction: only retains metadata and unspent transaction outputs\n  *\n  * Serialized format:"
      }
    ]
  },
  {
    "sha": "ab5a65f0c089f599831bfcb57215fcedf6f083f9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphYjVhNjVmMGMwODlmNTk5ODMxYmZjYjU3MjE1ZmNlZGY2ZjA4M2Y5",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-08-13T17:11:05Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-20T13:39:11Z"
      },
      "message": "Multiple blocks per file\n\nChange the block storage layer again, this time with multiple files\nper block, but tracked by txindex.dat database entries. The file\nformat is exactly the same as the earlier blk00001.dat, but with\nsmaller files (128 MiB for now).\n\nThe database entries track how many bytes each block file already\nuses, how many blocks are in it, which range of heights is present\nand which range of dates.",
      "tree": {
        "sha": "dd7c095fbff8be37313779464bc6867d17cf12d7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/dd7c095fbff8be37313779464bc6867d17cf12d7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ab5a65f0c089f599831bfcb57215fcedf6f083f9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ab5a65f0c089f599831bfcb57215fcedf6f083f9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ab5a65f0c089f599831bfcb57215fcedf6f083f9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ab5a65f0c089f599831bfcb57215fcedf6f083f9/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4415a7f1f55651b461281c2198e8fc23f135503b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4415a7f1f55651b461281c2198e8fc23f135503b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4415a7f1f55651b461281c2198e8fc23f135503b"
      }
    ],
    "stats": {
      "total": 367,
      "additions": 265,
      "deletions": 102
    },
    "files": [
      {
        "sha": "53be48cb0fa1beefe651e593418307e54eb591a8",
        "filename": "src/db.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 1,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ab5a65f0c089f599831bfcb57215fcedf6f083f9/src/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ab5a65f0c089f599831bfcb57215fcedf6f083f9/src/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.cpp?ref=ab5a65f0c089f599831bfcb57215fcedf6f083f9",
        "patch": "@@ -546,6 +546,22 @@ bool CTxDB::WriteBlockIndex(const CDiskBlockIndex& blockindex)\n     return Write(make_pair(string(\"blockindex\"), blockindex.GetBlockHash()), blockindex);\n }\n \n+bool CTxDB::WriteBlockFileInfo(int nFile, const CBlockFileInfo &info) {\n+    return Write(make_pair(string(\"blockfile\"), nFile), info);\n+}\n+\n+bool CTxDB::ReadBlockFileInfo(int nFile, CBlockFileInfo &info) {\n+    return Read(make_pair(string(\"blockfile\"), nFile), info);\n+}\n+\n+bool CTxDB::WriteLastBlockFile(int nFile) {\n+    return Write(string(\"lastblockfile\"), nFile);\n+}\n+\n+bool CTxDB::ReadLastBlockFile(int &nFile) {\n+    return Read(string(\"lastblockfile\"), nFile);\n+}\n+\n bool CTxDB::ReadHashBestChain(uint256& hashBestChain)\n {\n     return Read(string(\"hashBestChain\"), hashBestChain);\n@@ -609,6 +625,12 @@ bool CTxDB::LoadBlockIndex()\n         pindex->bnChainWork = (pindex->pprev ? pindex->pprev->bnChainWork : 0) + pindex->GetBlockWork();\n     }\n \n+    // Load block file info\n+    ReadLastBlockFile(nLastBlockFile);\n+    printf(\"LoadBlockIndex(): last block file = %i\\n\", nLastBlockFile);\n+    if (ReadBlockFileInfo(nLastBlockFile, infoLastBlockFile))\n+        printf(\"LoadBlockIndex(): last block file: %s\\n\", infoLastBlockFile.ToString().c_str());\n+ \n     // Load hashBestChain pointer to end of best chain\n     if (!ReadHashBestChain(hashBestChain))\n     {\n@@ -788,7 +810,8 @@ bool CTxDB::LoadBlockIndexGuts()\n             pindexNew->pprev          = InsertBlockIndex(diskindex.hashPrev);\n             pindexNew->pnext          = InsertBlockIndex(diskindex.hashNext);\n             pindexNew->nHeight        = diskindex.nHeight;\n-            pindexNew->nAlternative   = diskindex.nAlternative;\n+            pindexNew->pos            = diskindex.pos;\n+            pindexNew->nUndoPos       = diskindex.nUndoPos;\n             pindexNew->nVersion       = diskindex.nVersion;\n             pindexNew->hashMerkleRoot = diskindex.hashMerkleRoot;\n             pindexNew->nTime          = diskindex.nTime;"
      },
      {
        "sha": "61b59060a067b3ddb6e9149e3445365657f3ba6d",
        "filename": "src/db.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ab5a65f0c089f599831bfcb57215fcedf6f083f9/src/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ab5a65f0c089f599831bfcb57215fcedf6f083f9/src/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.h?ref=ab5a65f0c089f599831bfcb57215fcedf6f083f9",
        "patch": "@@ -339,6 +339,10 @@ class CTxDB : public CDB\n     bool WriteHashBestChain(uint256 hashBestChain);\n     bool ReadBestInvalidWork(CBigNum& bnBestInvalidWork);\n     bool WriteBestInvalidWork(CBigNum bnBestInvalidWork);\n+    bool ReadBlockFileInfo(int nFile, CBlockFileInfo &fileinfo);\n+    bool WriteBlockFileInfo(int nFile, const CBlockFileInfo &fileinfo);\n+    bool ReadLastBlockFile(int &nFile);\n+    bool WriteLastBlockFile(int nFile);\n     bool LoadBlockIndex();\n private:\n     bool LoadBlockIndexGuts();"
      },
      {
        "sha": "15a2331376332539c66ab2c05263ff200908303b",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 108,
        "deletions": 18,
        "changes": 126,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ab5a65f0c089f599831bfcb57215fcedf6f083f9/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ab5a65f0c089f599831bfcb57215fcedf6f083f9/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=ab5a65f0c089f599831bfcb57215fcedf6f083f9",
        "patch": "@@ -1399,6 +1399,8 @@ bool CBlock::DisconnectBlock(CTxDB& txdb, CBlockIndex* pindex)\n     return true;\n }\n \n+bool FindUndoPos(CTxDB &txdb, int nFile, CDiskBlockPos &pos, unsigned int nAddSize);\n+\n bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex, bool fJustCheck)\n {\n     // Check it again in case a previous version let a bad block in\n@@ -1430,7 +1432,7 @@ bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex, bool fJustCheck)\n         // Since we're just checking the block and not actually connecting it, it might not (and probably shouldn't) be on the disk to get the transaction from\n         nTxPos = 1;\n     else\n-        nTxPos = ::GetSerializeSize(CBlock(), SER_DISK, CLIENT_VERSION) - 1 + GetSizeOfCompactSize(vtx.size());\n+        nTxPos = pindex->pos.nPos + ::GetSerializeSize(CBlock(), SER_DISK, CLIENT_VERSION) - 1 + GetSizeOfCompactSize(vtx.size());\n \n     CBlockUndo blockundo;\n \n@@ -1507,6 +1509,17 @@ bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex, bool fJustCheck)\n             return error(\"ConnectBlock() : UpdateTxIndex failed\");\n     }\n \n+    // Write undo information to disk\n+    if (pindex->GetUndoPos().IsNull() && pindex->nHeight > Checkpoints::GetTotalBlocksEstimate())\n+    {\n+        CDiskBlockPos pos;\n+        if (!FindUndoPos(txdb, pindex->pos.nFile, pos, ::GetSerializeSize(blockundo, SER_DISK, CLIENT_VERSION) + 8))\n+            return error(\"ConnectBlock() : FindUndoPos failed\");\n+        if (!blockundo.WriteToDisk(pos))\n+            return error(\"ConnectBlock() : CBlockUndo::WriteToDisk failed\");\n+        pindex->nUndoPos = pos.nPos;\n+    }\n+\n     // Update block index on disk without changing it in memory.\n     // The memory index structure will be changed after the db commits.\n     if (pindex->pprev)\n@@ -1517,13 +1530,6 @@ bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex, bool fJustCheck)\n             return error(\"ConnectBlock() : WriteBlockIndex failed\");\n     }\n \n-    // Write undo information to disk\n-    if (pindex->nHeight > Checkpoints::GetTotalBlocksEstimate())\n-    {\n-        CAutoFile fileUndo(fopen(pindex->GetBlockPos().GetUndoFile(GetDataDir()).string().c_str(), \"wb\"), SER_DISK, CLIENT_VERSION);\n-        fileUndo << blockundo;\n-    }\n-\n     // Watch for transactions paying to me\n     BOOST_FOREACH(CTransaction& tx, vtx)\n         SyncWithWallets(tx, this, true);\n@@ -1788,8 +1794,8 @@ bool CBlock::AddToBlockIndex(const CDiskBlockPos &pos)\n         pindexNew->nHeight = pindexNew->pprev->nHeight + 1;\n     }\n     pindexNew->bnChainWork = (pindexNew->pprev ? pindexNew->pprev->bnChainWork : 0) + pindexNew->GetBlockWork();\n-    assert(pos.nHeight == pindexNew->nHeight);\n-    pindexNew->nAlternative = pos.nAlternative;\n+    pindexNew->pos = pos;\n+    pindexNew->nUndoPos = 0;\n \n     CTxDB txdb;\n     if (!txdb.TxnBegin())\n@@ -1819,6 +1825,57 @@ bool CBlock::AddToBlockIndex(const CDiskBlockPos &pos)\n \n \n \n+bool FindBlockPos(CTxDB &txdb, CDiskBlockPos &pos, unsigned int nAddSize, unsigned int nHeight, uint64 nTime)\n+{\n+    bool fUpdatedLast = false;\n+\n+    LOCK(cs_LastBlockFile);\n+\n+    while (infoLastBlockFile.nSize + nAddSize >= MAX_BLOCKFILE_SIZE) {\n+        printf(\"Leaving block file %i: %s\\n\", nLastBlockFile, infoLastBlockFile.ToString().c_str());\n+        nLastBlockFile++;\n+        infoLastBlockFile.SetNull();\n+        txdb.ReadBlockFileInfo(nLastBlockFile, infoLastBlockFile); // check whether data for the new file somehow already exist; can fail just fine\n+        fUpdatedLast = true;\n+    }\n+\n+    pos.nFile = nLastBlockFile;\n+    pos.nPos = infoLastBlockFile.nSize;\n+    infoLastBlockFile.nSize += nAddSize;\n+    infoLastBlockFile.AddBlock(nHeight, nTime);\n+\n+    if (!txdb.WriteBlockFileInfo(nLastBlockFile, infoLastBlockFile))\n+        return error(\"FindBlockPos() : cannot write updated block info\");\n+    if (fUpdatedLast)\n+        txdb.WriteLastBlockFile(nLastBlockFile);\n+\n+    return true;\n+}\n+\n+bool FindUndoPos(CTxDB &txdb, int nFile, CDiskBlockPos &pos, unsigned int nAddSize)\n+{\n+    pos.nFile = nFile;\n+\n+    LOCK(cs_LastBlockFile);\n+\n+    if (nFile == nLastBlockFile) {\n+        pos.nPos = infoLastBlockFile.nUndoSize;\n+        infoLastBlockFile.nUndoSize += nAddSize;\n+        if (!txdb.WriteBlockFileInfo(nLastBlockFile, infoLastBlockFile))\n+            return error(\"FindUndoPos() : cannot write updated block info\");\n+        return true;\n+    }\n+\n+    CBlockFileInfo info;\n+    if (!txdb.ReadBlockFileInfo(nFile, info))\n+        return error(\"FindUndoPos() : cannot read block info\");\n+    pos.nPos = info.nUndoSize;\n+    info.nUndoSize += nAddSize;\n+    if (!txdb.WriteBlockFileInfo(nFile, info))\n+        return error(\"FindUndoPos() : cannot write updated block info\");\n+    return true;\n+}\n+\n \n bool CBlock::CheckBlock(bool fCheckPOW, bool fCheckMerkleRoot) const\n {\n@@ -1928,9 +1985,15 @@ bool CBlock::AcceptBlock()\n     }\n \n     // Write block to history file\n-    CDiskBlockPos blockPos = CDiskBlockPos(nHeight);\n+    unsigned int nBlockSize = ::GetSerializeSize(*this, SER_DISK, CLIENT_VERSION);\n     if (!CheckDiskSpace(::GetSerializeSize(*this, SER_DISK, CLIENT_VERSION)))\n         return error(\"AcceptBlock() : out of disk space\");\n+    CDiskBlockPos blockPos;\n+    {\n+        CTxDB txdb;\n+        if (!FindBlockPos(txdb, blockPos, nBlockSize+8, nHeight, nTime))\n+            return error(\"AcceptBlock() : FindBlockPos failed\");\n+    }\n     if (!WriteToDisk(blockPos))\n         return error(\"AcceptBlock() : WriteToDisk failed\");\n     if (!AddToBlockIndex(blockPos))\n@@ -2067,18 +2130,39 @@ bool CheckDiskSpace(uint64 nAdditionalBytes)\n     return true;\n }\n \n-FILE* OpenBlockFile(const CDiskBlockPos &pos, const char* pszMode)\n+CCriticalSection cs_LastBlockFile;\n+CBlockFileInfo infoLastBlockFile;\n+int nLastBlockFile = 0;\n+\n+FILE* OpenDiskFile(const CDiskBlockPos &pos, const char *prefix, bool fReadOnly)\n {\n-    boost::filesystem::path path = pos.GetFileName(GetDataDir());\n-    boost::filesystem::create_directories(path.parent_path());\n     if (pos.IsNull() || pos.IsMemPool())\n         return NULL;\n-    FILE* file = fopen(path.string().c_str(), pszMode);\n+    boost::filesystem::path path = GetDataDir() / \"blocks\" / strprintf(\"%s%05u.dat\", prefix, pos.nFile);\n+    boost::filesystem::create_directories(path.parent_path());\n+    FILE* file = fopen(path.string().c_str(), \"rb+\");\n+    if (!file && !fReadOnly)\n+        file = fopen(path.string().c_str(), \"wb+\");\n     if (!file)\n         return NULL;\n+    if (pos.nPos) {\n+        if (fseek(file, pos.nPos, SEEK_SET)) {\n+            printf(\"Unable to seek to position %u of %s\\n\", pos.nPos, path.string().c_str());\n+            fclose(file);\n+            return NULL;\n+        }\n+    }\n     return file;\n }\n \n+FILE* OpenBlockFile(const CDiskBlockPos &pos, bool fReadOnly) {\n+    return OpenDiskFile(pos, \"blk\", fReadOnly);\n+}\n+\n+FILE *OpenUndoFile(const CDiskBlockPos &pos, bool fReadOnly) {\n+    return OpenDiskFile(pos, \"rev\", fReadOnly);\n+}\n+\n bool LoadBlockIndex(bool fAllowNew)\n {\n     if (fTestNet)\n@@ -2146,7 +2230,13 @@ bool LoadBlockIndex(bool fAllowNew)\n         assert(hash == hashGenesisBlock);\n \n         // Start new block file\n-        CDiskBlockPos blockPos(0);\n+        unsigned int nBlockSize = ::GetSerializeSize(block, SER_DISK, CLIENT_VERSION);\n+        CDiskBlockPos blockPos;\n+        {\n+            CTxDB txdb;\n+            if (!FindBlockPos(txdb, blockPos, nBlockSize+8, 0, block.nTime))\n+                return error(\"AcceptBlock() : FindBlockPos failed\");\n+        }\n         if (!block.WriteToDisk(blockPos))\n             return error(\"LoadBlockIndex() : writing genesis block to disk failed\");\n         if (!block.AddToBlockIndex(blockPos))\n@@ -2203,9 +2293,9 @@ void PrintBlockTree()\n         // print item\n         CBlock block;\n         block.ReadFromDisk(pindex);\n-        printf(\"%d (%s)  %s  tx %\"PRIszu\"\",\n+        printf(\"%d (blk%05u.dat:0x%lx)  %s  tx %\"PRIszu\"\",\n             pindex->nHeight,\n-            pindex->GetBlockPos().GetFileName(\"\").string().c_str(),\n+            pindex->GetBlockPos().nFile, pindex->GetBlockPos().nPos,\n             DateTimeStrFormat(\"%x %H:%M:%S\", block.GetBlockTime()).c_str(),\n             block.vtx.size());\n "
      },
      {
        "sha": "449cc47df8d3c8d1122d3b32204a93a8c6782540",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 129,
        "deletions": 83,
        "changes": 212,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ab5a65f0c089f599831bfcb57215fcedf6f083f9/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ab5a65f0c089f599831bfcb57215fcedf6f083f9/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=ab5a65f0c089f599831bfcb57215fcedf6f083f9",
        "patch": "@@ -28,6 +28,7 @@ static const unsigned int MAX_BLOCK_SIZE_GEN = MAX_BLOCK_SIZE/2;\n static const unsigned int MAX_BLOCK_SIGOPS = MAX_BLOCK_SIZE/50;\n static const unsigned int MAX_ORPHAN_TRANSACTIONS = MAX_BLOCK_SIZE/100;\n static const unsigned int MAX_INV_SZ = 50000;\n+static const unsigned int MAX_BLOCKFILE_SIZE = 0x8000000; // 128 MiB\n static const int64 MIN_TX_FEE = 50000;\n static const int64 MIN_RELAY_TX_FEE = 10000;\n static const int64 MAX_MONEY = 21000000 * COIN;\n@@ -87,7 +88,8 @@ void UnregisterWallet(CWallet* pwalletIn);\n void SyncWithWallets(const CTransaction& tx, const CBlock* pblock = NULL, bool fUpdate = false);\n bool ProcessBlock(CNode* pfrom, CBlock* pblock);\n bool CheckDiskSpace(uint64 nAdditionalBytes=0);\n-FILE* OpenBlockFile(const CDiskBlockPos &pos, const char* pszMode=\"rb\");\n+FILE* OpenBlockFile(const CDiskBlockPos &pos, bool fReadOnly = false);\n+FILE* OpenUndoFile(const CDiskBlockPos &pos, bool fReadOnly = false);\n bool LoadBlockIndex(bool fAllowNew=true);\n void PrintBlockTree();\n CBlockIndex* FindBlockByHeight(int nHeight);\n@@ -121,86 +123,27 @@ bool GetWalletFile(CWallet* pwallet, std::string &strWalletFileOut);\n class CDiskBlockPos\n {\n public:\n-    int nHeight;\n-    int nAlternative;\n-\n-    CDiskBlockPos() {\n-        SetNull();\n-    }\n-\n-    CDiskBlockPos(int nHeightIn, int nAlternativeIn = 0) {\n-        nHeight = nHeightIn;\n-        nAlternative = nAlternativeIn;\n-    }\n-\n-    std::string GetAlternative() const {\n-        char c[9]={0,0,0,0,0,0,0,0,0};\n-        char *cp = &c[8];\n-        unsigned int n = nAlternative;\n-        while (n > 0 && cp>c) {\n-            n--;\n-            *(--cp) = 'a' + (n % 26);\n-            n /= 26;\n-        }\n-        return std::string(cp);\n-    }\n-\n-    boost::filesystem::path GetDirectory(const boost::filesystem::path &base) const {\n-        assert(nHeight != -1);\n-        return base / strprintf(\"era%02u\", nHeight / 210000) / \n-                      strprintf(\"cycle%04u\", nHeight / 2016);\n-    }\n-\n-    boost::filesystem::path GetFileName(const boost::filesystem::path &base) const {\n-        return GetDirectory(base) / strprintf(\"%08u%s.blk\", nHeight, GetAlternative().c_str());\n-    }\n-\n-    boost::filesystem::path GetUndoFile(const boost::filesystem::path &base) const {\n-        return GetDirectory(base) / strprintf(\"%08u%s.und\", nHeight, GetAlternative().c_str());\n-    }\n-\n-    // TODO: make thread-safe (lockfile, atomic file creation, ...?)\n-    void MakeUnique(const boost::filesystem::path &base) {\n-        while (boost::filesystem::exists(GetFileName(base)))\n-            nAlternative++;\n-    }\n+    int nFile;\n+    unsigned int nPos;\n \n-    IMPLEMENT_SERIALIZE(({\n-        CDiskBlockPos *me = const_cast<CDiskBlockPos*>(this);\n-        if (!fRead) {\n-            unsigned int nCode = (nHeight + 1) * 2 + (nAlternative > 0);\n-            READWRITE(VARINT(nCode));\n-            if (nAlternative > 0) {\n-                unsigned int nAlt = nAlternative - 1;\n-                READWRITE(VARINT(nAlt));\n-            }\n-        } else {\n-            unsigned int nCode = 0;\n-            READWRITE(VARINT(nCode));\n-            me->nHeight = (nCode / 2) - 1;\n-            if (nCode & 1) {\n-                unsigned int nAlt = 0;\n-                READWRITE(VARINT(nAlt));\n-                me->nAlternative = 1 + nAlt;\n-            } else {\n-                me->nAlternative = 0;\n-            }\n-        }\n-    });)\n+    IMPLEMENT_SERIALIZE(\n+        READWRITE(VARINT(nFile));\n+        READWRITE(VARINT(nPos));\n+    )\n \n     friend bool operator==(const CDiskBlockPos &a, const CDiskBlockPos &b) {\n-        return ((a.nHeight == b.nHeight) && (a.nAlternative == b.nAlternative));\n+        return (a.nFile == b.nFile && a.nPos == b.nPos);\n     }\n \n     friend bool operator!=(const CDiskBlockPos &a, const CDiskBlockPos &b) {\n         return !(a == b);\n     }\n \n-    void SetNull() { nHeight = -1; nAlternative = 0; }\n-    bool IsNull() const { return ((nHeight == -1) && (nAlternative == 0)); }\n+    void SetNull() { nFile = -1; nPos = 0; }\n+    bool IsNull() const { return (nFile == -1); }\n \n-    void SetMemPool() { nHeight = -1; nAlternative = -1; }\n-    bool IsMemPool() const { return ((nHeight == -1) && (nAlternative == -1)); }\n+    void SetMemPool() { nFile = -2; nPos = 0; }\n+    bool IsMemPool() const { return (nFile == -2); }\n };\n \n /** Position on disk for a particular transaction. */\n@@ -225,7 +168,7 @@ class CDiskTxPos\n     )\n \n     void SetNull() { blockPos.SetNull(); nTxPos = 0; }\n-    bool IsNull() const { return blockPos.IsNull(); }\n+    bool IsNull() const { return (nTxPos == 0); }\n     bool IsMemPool() const { return blockPos.IsMemPool(); }\n \n     friend bool operator==(const CDiskTxPos& a, const CDiskTxPos& b)\n@@ -246,7 +189,7 @@ class CDiskTxPos\n         else if (blockPos.IsMemPool())\n             return \"mempool\";\n         else\n-            return strprintf(\"(%s, nTxPos=%u)\", blockPos.GetFileName(\"\").string().c_str(), nTxPos);\n+            return strprintf(\"\\\"blk%05i.dat:0x%x\\\"\", blockPos.nFile, nTxPos);\n     }\n \n     void print() const\n@@ -632,7 +575,7 @@ class CTransaction\n \n     bool ReadFromDisk(CDiskTxPos pos, FILE** pfileRet=NULL)\n     {\n-        CAutoFile filein = CAutoFile(OpenBlockFile(pos.blockPos, pfileRet ? \"rb+\" : \"rb\"), SER_DISK, CLIENT_VERSION);\n+        CAutoFile filein = CAutoFile(OpenBlockFile(pos.blockPos, pfileRet==NULL), SER_DISK, CLIENT_VERSION);\n         if (!filein)\n             return error(\"CTransaction::ReadFromDisk() : OpenBlockFile failed\");\n \n@@ -823,6 +766,33 @@ class CBlockUndo\n     IMPLEMENT_SERIALIZE(\n         READWRITE(vtxundo);\n     )\n+\n+    bool WriteToDisk(CDiskBlockPos &pos)\n+    {\n+        // Open history file to append\n+        CAutoFile fileout = CAutoFile(OpenUndoFile(pos), SER_DISK, CLIENT_VERSION);\n+        if (!fileout)\n+            return error(\"CBlockUndo::WriteToDisk() : OpenUndoFile failed\");\n+\n+        // Write index header\n+        unsigned int nSize = fileout.GetSerializeSize(*this);\n+        fileout << FLATDATA(pchMessageStart) << nSize;\n+\n+        // Write undo data\n+        long fileOutPos = ftell(fileout);\n+        if (fileOutPos < 0)\n+            return error(\"CBlock::WriteToDisk() : ftell failed\");\n+        pos.nPos = (unsigned int)fileOutPos;\n+        fileout << *this;\n+\n+        // Flush stdio buffers and commit to disk before returning\n+        fflush(fileout);\n+        if (!IsInitialBlockDownload() || (nBestHeight+1) % 500 == 0)\n+            FileCommit(fileout);\n+\n+        return true;\n+    }\n+\n };\n \n /** pruned version of CTransaction: only retains metadata and unspent transaction outputs\n@@ -1316,12 +1286,19 @@ class CBlock\n     bool WriteToDisk(CDiskBlockPos &pos)\n     {\n         // Open history file to append\n-        pos.MakeUnique(GetDataDir());\n-        CAutoFile fileout = CAutoFile(OpenBlockFile(pos, \"ab\"), SER_DISK, CLIENT_VERSION);\n+        CAutoFile fileout = CAutoFile(OpenBlockFile(pos), SER_DISK, CLIENT_VERSION);\n         if (!fileout)\n-            return error(\"CBlock::WriteToDisk() : AppendBlockFile failed\");\n+            return error(\"CBlock::WriteToDisk() : OpenBlockFile failed\");\n+\n+        // Write index header\n+        unsigned int nSize = fileout.GetSerializeSize(*this);\n+        fileout << FLATDATA(pchMessageStart) << nSize;\n \n         // Write block\n+        long fileOutPos = ftell(fileout);\n+        if (fileOutPos < 0)\n+            return error(\"CBlock::WriteToDisk() : ftell failed\");\n+        pos.nPos = (unsigned int)fileOutPos;\n         fileout << *this;\n \n         // Flush stdio buffers and commit to disk before returning\n@@ -1337,7 +1314,7 @@ class CBlock\n         SetNull();\n \n         // Open history file to read\n-        CAutoFile filein = CAutoFile(OpenBlockFile(pos, \"rb\"), SER_DISK, CLIENT_VERSION);\n+        CAutoFile filein = CAutoFile(OpenBlockFile(pos, true), SER_DISK, CLIENT_VERSION);\n         if (!filein)\n             return error(\"CBlock::ReadFromDisk() : OpenBlockFile failed\");\n         if (!fReadTransactions)\n@@ -1397,6 +1374,62 @@ class CBlock\n \n \n \n+class CBlockFileInfo\n+{\n+public:\n+    unsigned int nBlocks;      // number of blocks stored in file\n+    unsigned int nSize;        // number of used bytes of block file\n+    unsigned int nUndoSize;    // number of used bytes in the undo file\n+    unsigned int nHeightFirst; // lowest height of block in file\n+    unsigned int nHeightLast;  // highest height of block in file\n+    uint64 nTimeFirst;         // earliest time of block in file\n+    uint64 nTimeLast;          // latest time of block in file\n+\n+    IMPLEMENT_SERIALIZE(\n+        READWRITE(VARINT(nBlocks));\n+        READWRITE(VARINT(nSize));\n+        READWRITE(VARINT(nUndoSize));\n+        READWRITE(VARINT(nHeightFirst));\n+        READWRITE(VARINT(nHeightLast));\n+        READWRITE(VARINT(nTimeFirst));\n+        READWRITE(VARINT(nTimeLast));\n+     )\n+\n+     void SetNull() {\n+         nBlocks = 0;\n+         nSize = 0;\n+         nUndoSize = 0;\n+         nHeightFirst = 0;\n+         nHeightLast = 0;\n+         nTimeFirst = 0;\n+         nTimeLast = 0;\n+     }\n+\n+     CBlockFileInfo() {\n+         SetNull();\n+     }\n+\n+     std::string ToString() const {\n+         return strprintf(\"CBlockFileInfo(blocks=%u, size=%lu, heights=%u..%u, time=%s..%s)\", nBlocks, nSize, nHeightFirst, nHeightLast, DateTimeStrFormat(\"%Y-%m-%d\", nTimeFirst).c_str(), DateTimeStrFormat(\"%Y-%m-%d\", nTimeLast).c_str());\n+     }\n+\n+     // update statistics (does not update nSize)\n+     void AddBlock(unsigned int nHeightIn, uint64 nTimeIn) {\n+         if (nBlocks==0 || nHeightFirst > nHeightIn)\n+             nHeightFirst = nHeightIn;\n+         if (nBlocks==0 || nTimeFirst > nTimeIn)\n+             nTimeFirst = nTimeIn;\n+         nBlocks++;\n+         if (nHeightIn > nHeightFirst)\n+             nHeightLast = nHeightIn;\n+         if (nTimeIn > nTimeLast)\n+             nTimeLast = nTimeIn;\n+     }\n+};\n+\n+extern CCriticalSection cs_LastBlockFile;\n+extern CBlockFileInfo infoLastBlockFile;\n+extern int nLastBlockFile;\n \n /** The block chain is a tree shaped structure starting with the\n  * genesis block at the root, with each block potentially having multiple\n@@ -1412,7 +1445,8 @@ class CBlockIndex\n     CBlockIndex* pprev;\n     CBlockIndex* pnext;\n     int nHeight;\n-    unsigned int nAlternative;\n+    CDiskBlockPos pos;\n+    unsigned int nUndoPos;\n     CBigNum bnChainWork;\n \n     // block header\n@@ -1429,8 +1463,9 @@ class CBlockIndex\n         pprev = NULL;\n         pnext = NULL;\n         nHeight = 0;\n+        pos.SetNull();\n+        nUndoPos = (unsigned int)(-1);\n         bnChainWork = 0;\n-        nAlternative = 0;\n \n         nVersion       = 0;\n         hashMerkleRoot = 0;\n@@ -1445,8 +1480,9 @@ class CBlockIndex\n         pprev = NULL;\n         pnext = NULL;\n         nHeight = 0;\n+        pos.SetNull();\n+        nUndoPos = 0;\n         bnChainWork = 0;\n-        nAlternative = 0;\n \n         nVersion       = block.nVersion;\n         hashMerkleRoot = block.hashMerkleRoot;\n@@ -1456,7 +1492,16 @@ class CBlockIndex\n     }\n \n     CDiskBlockPos GetBlockPos() const {\n-        return CDiskBlockPos(nHeight, nAlternative);\n+        return pos;\n+    }\n+\n+    CDiskBlockPos GetUndoPos() const {\n+        CDiskBlockPos ret = pos;\n+        if (nUndoPos == (unsigned int)(-1))\n+            ret.SetNull();\n+        else\n+            ret.nPos = nUndoPos;\n+        return ret;\n     }\n \n     CBlock GetBlockHeader() const\n@@ -1578,7 +1623,8 @@ class CDiskBlockIndex : public CBlockIndex\n \n         READWRITE(hashNext);\n         READWRITE(nHeight);\n-        READWRITE(nAlternative);\n+        READWRITE(pos);\n+        READWRITE(nUndoPos);\n \n         // block header\n         READWRITE(this->nVersion);"
      }
    ]
  },
  {
    "sha": "2da73367141057a4073f9ea2229e5e93d6dc3c73",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyZGE3MzM2NzE0MTA1N2E0MDczZjllYTIyMjllNWU5M2Q2ZGMzYzcz",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-08-16T00:21:28Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-20T13:39:11Z"
      },
      "message": "Pre-allocate block and undo files in chunks\n\nIntroduce a AllocateFileRange() function in util, which wipes or\nat least allocates a given range of a file. It can be overriden\nby more efficient OS-dependent versions if necessary.\n\nBlock and undo files are now allocated in chunks of 16 and 1 MiB,\nrespectively.",
      "tree": {
        "sha": "f3b4fd8649021b52e19cfdf4620ffead5f30910e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f3b4fd8649021b52e19cfdf4620ffead5f30910e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2da73367141057a4073f9ea2229e5e93d6dc3c73",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2da73367141057a4073f9ea2229e5e93d6dc3c73",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2da73367141057a4073f9ea2229e5e93d6dc3c73",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2da73367141057a4073f9ea2229e5e93d6dc3c73/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ab5a65f0c089f599831bfcb57215fcedf6f083f9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ab5a65f0c089f599831bfcb57215fcedf6f083f9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ab5a65f0c089f599831bfcb57215fcedf6f083f9"
      }
    ],
    "stats": {
      "total": 58,
      "additions": 49,
      "deletions": 9
    },
    "files": [
      {
        "sha": "616845e92944b799c371dca6634dfdde9e68903c",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 9,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2da73367141057a4073f9ea2229e5e93d6dc3c73/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2da73367141057a4073f9ea2229e5e93d6dc3c73/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=2da73367141057a4073f9ea2229e5e93d6dc3c73",
        "patch": "@@ -1844,6 +1844,17 @@ bool FindBlockPos(CTxDB &txdb, CDiskBlockPos &pos, unsigned int nAddSize, unsign\n     infoLastBlockFile.nSize += nAddSize;\n     infoLastBlockFile.AddBlock(nHeight, nTime);\n \n+    unsigned int nOldChunks = (pos.nPos + BLOCKFILE_CHUNK_SIZE - 1) / BLOCKFILE_CHUNK_SIZE;\n+    unsigned int nNewChunks = (infoLastBlockFile.nSize + BLOCKFILE_CHUNK_SIZE - 1) / BLOCKFILE_CHUNK_SIZE;\n+    if (nNewChunks > nOldChunks) {\n+        FILE *file = OpenBlockFile(pos);\n+        if (file) {\n+            printf(\"Pre-allocating up to position 0x%x in blk%05u.dat\\n\", nNewChunks * BLOCKFILE_CHUNK_SIZE, pos.nFile);\n+            AllocateFileRange(file, pos.nPos, nNewChunks * BLOCKFILE_CHUNK_SIZE - pos.nPos);\n+        }\n+        fclose(file);\n+    }\n+\n     if (!txdb.WriteBlockFileInfo(nLastBlockFile, infoLastBlockFile))\n         return error(\"FindBlockPos() : cannot write updated block info\");\n     if (fUpdatedLast)\n@@ -1858,21 +1869,33 @@ bool FindUndoPos(CTxDB &txdb, int nFile, CDiskBlockPos &pos, unsigned int nAddSi\n \n     LOCK(cs_LastBlockFile);\n \n+    unsigned int nNewSize;\n     if (nFile == nLastBlockFile) {\n         pos.nPos = infoLastBlockFile.nUndoSize;\n-        infoLastBlockFile.nUndoSize += nAddSize;\n+        nNewSize = (infoLastBlockFile.nUndoSize += nAddSize);\n         if (!txdb.WriteBlockFileInfo(nLastBlockFile, infoLastBlockFile))\n             return error(\"FindUndoPos() : cannot write updated block info\");\n-        return true;\n+    } else {\n+        CBlockFileInfo info;\n+        if (!txdb.ReadBlockFileInfo(nFile, info))\n+            return error(\"FindUndoPos() : cannot read block info\");\n+        pos.nPos = info.nUndoSize;\n+        nNewSize = (info.nUndoSize += nAddSize);\n+        if (!txdb.WriteBlockFileInfo(nFile, info))\n+            return error(\"FindUndoPos() : cannot write updated block info\");\n+    }\n+\n+    unsigned int nOldChunks = (pos.nPos + UNDOFILE_CHUNK_SIZE - 1) / UNDOFILE_CHUNK_SIZE;\n+    unsigned int nNewChunks = (nNewSize + UNDOFILE_CHUNK_SIZE - 1) / UNDOFILE_CHUNK_SIZE;\n+    if (nNewChunks > nOldChunks) {\n+        FILE *file = OpenUndoFile(pos);\n+        if (file) {\n+            printf(\"Pre-allocating up to position 0x%x in rev%05u.dat\\n\", nNewChunks * UNDOFILE_CHUNK_SIZE, pos.nFile);\n+            AllocateFileRange(file, pos.nPos, nNewChunks * UNDOFILE_CHUNK_SIZE - pos.nPos);\n+        }\n+        fclose(file);\n     }\n \n-    CBlockFileInfo info;\n-    if (!txdb.ReadBlockFileInfo(nFile, info))\n-        return error(\"FindUndoPos() : cannot read block info\");\n-    pos.nPos = info.nUndoSize;\n-    info.nUndoSize += nAddSize;\n-    if (!txdb.WriteBlockFileInfo(nFile, info))\n-        return error(\"FindUndoPos() : cannot write updated block info\");\n     return true;\n }\n "
      },
      {
        "sha": "936a4e184de0888ef564ffaf6d4c4d4467aab236",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2da73367141057a4073f9ea2229e5e93d6dc3c73/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2da73367141057a4073f9ea2229e5e93d6dc3c73/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=2da73367141057a4073f9ea2229e5e93d6dc3c73",
        "patch": "@@ -29,6 +29,8 @@ static const unsigned int MAX_BLOCK_SIGOPS = MAX_BLOCK_SIZE/50;\n static const unsigned int MAX_ORPHAN_TRANSACTIONS = MAX_BLOCK_SIZE/100;\n static const unsigned int MAX_INV_SZ = 50000;\n static const unsigned int MAX_BLOCKFILE_SIZE = 0x8000000; // 128 MiB\n+static const unsigned int BLOCKFILE_CHUNK_SIZE = 0x1000000; // 16 MiB\n+static const unsigned int UNDOFILE_CHUNK_SIZE = 0x100000; // 1 MiB\n static const int64 MIN_TX_FEE = 50000;\n static const int64 MIN_RELAY_TX_FEE = 10000;\n static const int64 MAX_MONEY = 21000000 * COIN;"
      },
      {
        "sha": "91628864507d78cc098c67fc2566d3898d78c8b8",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2da73367141057a4073f9ea2229e5e93d6dc3c73/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2da73367141057a4073f9ea2229e5e93d6dc3c73/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=2da73367141057a4073f9ea2229e5e93d6dc3c73",
        "patch": "@@ -1137,6 +1137,20 @@ int GetFilesize(FILE* file)\n     return nFilesize;\n }\n \n+// this function tries to make a particular range of a file allocated (corresponding to disk space)\n+// it is advisory, and the range specified in the arguments will never contain live data\n+void AllocateFileRange(FILE *file, unsigned int offset, unsigned int length) {\n+    static const char buf[65536] = {};\n+    fseek(file, offset, SEEK_SET);\n+    while (length > 0) {\n+        unsigned int now = 65536;\n+        if (length < now)\n+            now = length;\n+        fwrite(buf, 1, now, file); // allowed to fail; this function is advisory anyway\n+        length -= now;\n+    }\n+}\n+\n void ShrinkDebugFile()\n {\n     // Scroll debug.log if it's getting too big"
      },
      {
        "sha": "b798f60aa739f66233556a140fad1068e1ad00c9",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2da73367141057a4073f9ea2229e5e93d6dc3c73/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2da73367141057a4073f9ea2229e5e93d6dc3c73/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=2da73367141057a4073f9ea2229e5e93d6dc3c73",
        "patch": "@@ -196,6 +196,7 @@ bool WildcardMatch(const char* psz, const char* mask);\n bool WildcardMatch(const std::string& str, const std::string& mask);\n void FileCommit(FILE *fileout);\n int GetFilesize(FILE* file);\n+void AllocateFileRange(FILE *file, unsigned int offset, unsigned int length);\n bool RenameOver(boost::filesystem::path src, boost::filesystem::path dest);\n boost::filesystem::path GetDefaultDataDir();\n const boost::filesystem::path &GetDataDir(bool fNetSpecific = true);"
      }
    ]
  },
  {
    "sha": "60dc5e886091e0e64678db4dd66ecd66434ca66c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2MGRjNWU4ODYwOTFlMGU2NDY3OGRiNGRkNjZlY2Q2NjQzNGNhNjZj",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-07-01T16:54:00Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-20T13:39:11Z"
      },
      "message": "Ultraprune\n\nThis switches bitcoin's transaction/block verification logic to use a\n\"coin database\", which contains all unredeemed transaction output scripts,\namounts and heights.\n\nThe name ultraprune comes from the fact that instead of a full transaction\nindex, we only (need to) keep an index with unspent outputs. For now, the\nblocks themselves are kept as usual, although they are only necessary for\nserving, rescanning and reorganizing.\n\nThe basic datastructures are CCoins (representing the coins of a single\ntransaction), and CCoinsView (representing a state of the coins database).\nThere are several implementations for CCoinsView. A dummy, one backed by\nthe coins database (coins.dat), one backed by the memory pool, and one\nthat adds a cache on top of it. FetchInputs, ConnectInputs, ConnectBlock,\nDisconnectBlock, ... now operate on a generic CCoinsView.\n\nThe block switching logic now builds a single cached CCoinsView with\nchanges to be committed to the database before any changes are made.\nThis means no uncommitted changes are ever read from the database, and\nshould ease the transition to another database layer which does not\nsupport transactions (but does support atomic writes), like LevelDB.\n\nFor the getrawtransaction() RPC call, access to a txid-to-disk index\nwould be preferable. As this index is not necessary or even useful\nfor any other part of the implementation, it is not provided. Instead,\ngetrawtransaction() uses the coin database to find the block height,\nand then scans that block to find the requested transaction. This is\nslow, but should suffice for debug purposes.",
      "tree": {
        "sha": "5c6fd4998dfcc81b5383ad490c1ffe53d372dec7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5c6fd4998dfcc81b5383ad490c1ffe53d372dec7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/60dc5e886091e0e64678db4dd66ecd66434ca66c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/60dc5e886091e0e64678db4dd66ecd66434ca66c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/60dc5e886091e0e64678db4dd66ecd66434ca66c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/60dc5e886091e0e64678db4dd66ecd66434ca66c/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2da73367141057a4073f9ea2229e5e93d6dc3c73",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2da73367141057a4073f9ea2229e5e93d6dc3c73",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2da73367141057a4073f9ea2229e5e93d6dc3c73"
      }
    ],
    "stats": {
      "total": 2011,
      "additions": 887,
      "deletions": 1124
    },
    "files": [
      {
        "sha": "0a6ba3fb392fba3a498cf3542b5e7658784b4d69",
        "filename": "src/db.cpp",
        "status": "modified",
        "additions": 61,
        "deletions": 184,
        "changes": 245,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/60dc5e886091e0e64678db4dd66ecd66434ca66c/src/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/60dc5e886091e0e64678db4dd66ecd66434ca66c/src/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.cpp?ref=60dc5e886091e0e64678db4dd66ecd66434ca66c",
        "patch": "@@ -244,7 +244,7 @@ CDB::CDB(const char *pszFile, const char* pszMode) :\n \n             ret = pdb->open(NULL,      // Txn pointer\n                             fMockDb ? NULL : pszFile,   // Filename\n-                            \"main\",    // Logical db name\n+                            fMockDb ? pszFile : \"main\", // Logical db name\n                             DB_BTREE,  // Database type\n                             nFlags,    // Flags\n                             0);\n@@ -273,7 +273,7 @@ CDB::CDB(const char *pszFile, const char* pszMode) :\n \n static bool IsChainFile(std::string strFile)\n {\n-    if (strFile == \"blkindex.dat\")\n+    if (strFile == \"coins.dat\" || strFile == \"chain.dat\")\n         return true;\n \n     return false;\n@@ -475,111 +475,66 @@ void CDBEnv::Flush(bool fShutdown)\n \n \n //\n-// CTxDB\n+// CChainDB and CCoinsDB\n //\n \n-bool CTxDB::ReadTxIndex(uint256 hash, CTxIndex& txindex)\n-{\n+bool CCoinsDB::HaveCoins(uint256 hash) {\n     assert(!fClient);\n-    txindex.SetNull();\n-    return Read(make_pair(string(\"tx\"), hash), txindex);\n+    return Exists(make_pair('c', hash));\n }\n \n-bool CTxDB::UpdateTxIndex(uint256 hash, const CTxIndex& txindex)\n-{\n+bool CCoinsDB::ReadCoins(uint256 hash, CCoins &coins) {\n     assert(!fClient);\n-    return Write(make_pair(string(\"tx\"), hash), txindex);\n-}\n-\n-bool CTxDB::AddTxIndex(const CTransaction& tx, const CDiskTxPos& pos, int nHeight)\n-{\n-    assert(!fClient);\n-\n-    // Add to tx index\n-    uint256 hash = tx.GetHash();\n-    CTxIndex txindex(pos, tx.vout.size());\n-    return Write(make_pair(string(\"tx\"), hash), txindex);\n+    return Read(make_pair('c', hash), coins);\n }\n \n-bool CTxDB::EraseTxIndex(const CTransaction& tx)\n-{\n-    assert(!fClient);\n-    uint256 hash = tx.GetHash();\n-\n-    return Erase(make_pair(string(\"tx\"), hash));\n-}\n-\n-bool CTxDB::ContainsTx(uint256 hash)\n-{\n+bool CCoinsDB::WriteCoins(uint256 hash, const CCoins &coins) {\n     assert(!fClient);\n-    return Exists(make_pair(string(\"tx\"), hash));\n+    if (coins.IsPruned())\n+        return Erase(make_pair('c', hash));\n+    else\n+        return Write(make_pair('c', hash), coins);\n }\n \n-bool CTxDB::ReadDiskTx(uint256 hash, CTransaction& tx, CTxIndex& txindex)\n+bool CChainDB::WriteBlockIndex(const CDiskBlockIndex& blockindex)\n {\n-    assert(!fClient);\n-    tx.SetNull();\n-    if (!ReadTxIndex(hash, txindex))\n-        return false;\n-    return (tx.ReadFromDisk(txindex.pos));\n+    return Write(make_pair('b', blockindex.GetBlockHash()), blockindex);\n }\n \n-bool CTxDB::ReadDiskTx(uint256 hash, CTransaction& tx)\n+bool CCoinsDB::ReadHashBestChain(uint256& hashBestChain)\n {\n-    CTxIndex txindex;\n-    return ReadDiskTx(hash, tx, txindex);\n+    return Read('B', hashBestChain);\n }\n \n-bool CTxDB::ReadDiskTx(COutPoint outpoint, CTransaction& tx, CTxIndex& txindex)\n+bool CCoinsDB::WriteHashBestChain(uint256 hashBestChain)\n {\n-    return ReadDiskTx(outpoint.hash, tx, txindex);\n+    return Write('B', hashBestChain);\n }\n \n-bool CTxDB::ReadDiskTx(COutPoint outpoint, CTransaction& tx)\n+bool CChainDB::ReadBestInvalidWork(CBigNum& bnBestInvalidWork)\n {\n-    CTxIndex txindex;\n-    return ReadDiskTx(outpoint.hash, tx, txindex);\n+    return Read('I', bnBestInvalidWork);\n }\n \n-bool CTxDB::WriteBlockIndex(const CDiskBlockIndex& blockindex)\n+bool CChainDB::WriteBestInvalidWork(CBigNum bnBestInvalidWork)\n {\n-    return Write(make_pair(string(\"blockindex\"), blockindex.GetBlockHash()), blockindex);\n+    return Write('I', bnBestInvalidWork);\n }\n \n-bool CTxDB::WriteBlockFileInfo(int nFile, const CBlockFileInfo &info) {\n-    return Write(make_pair(string(\"blockfile\"), nFile), info);\n+bool CChainDB::WriteBlockFileInfo(int nFile, const CBlockFileInfo &info) {\n+    return Write(make_pair('f', nFile), info);\n }\n \n-bool CTxDB::ReadBlockFileInfo(int nFile, CBlockFileInfo &info) {\n-    return Read(make_pair(string(\"blockfile\"), nFile), info);\n+bool CChainDB::ReadBlockFileInfo(int nFile, CBlockFileInfo &info) {\n+    return Read(make_pair('f', nFile), info);\n }\n \n-bool CTxDB::WriteLastBlockFile(int nFile) {\n-    return Write(string(\"lastblockfile\"), nFile);\n+bool CChainDB::WriteLastBlockFile(int nFile) {\n+    return Write('l', nFile);\n }\n \n-bool CTxDB::ReadLastBlockFile(int &nFile) {\n-    return Read(string(\"lastblockfile\"), nFile);\n-}\n-\n-bool CTxDB::ReadHashBestChain(uint256& hashBestChain)\n-{\n-    return Read(string(\"hashBestChain\"), hashBestChain);\n-}\n-\n-bool CTxDB::WriteHashBestChain(uint256 hashBestChain)\n-{\n-    return Write(string(\"hashBestChain\"), hashBestChain);\n-}\n-\n-bool CTxDB::ReadBestInvalidWork(CBigNum& bnBestInvalidWork)\n-{\n-    return Read(string(\"bnBestInvalidWork\"), bnBestInvalidWork);\n-}\n-\n-bool CTxDB::WriteBestInvalidWork(CBigNum bnBestInvalidWork)\n-{\n-    return Write(string(\"bnBestInvalidWork\"), bnBestInvalidWork);\n+bool CChainDB::ReadLastBlockFile(int &nFile) {\n+    return Read('l', nFile);\n }\n \n CBlockIndex static * InsertBlockIndex(uint256 hash)\n@@ -602,9 +557,9 @@ CBlockIndex static * InsertBlockIndex(uint256 hash)\n     return pindexNew;\n }\n \n-bool CTxDB::LoadBlockIndex()\n+bool LoadBlockIndex(CCoinsDB &coindb, CChainDB &chaindb)\n {\n-    if (!LoadBlockIndexGuts())\n+    if (!chaindb.LoadBlockIndexGuts())\n         return false;\n \n     if (fRequestShutdown)\n@@ -626,29 +581,39 @@ bool CTxDB::LoadBlockIndex()\n     }\n \n     // Load block file info\n-    ReadLastBlockFile(nLastBlockFile);\n+    chaindb.ReadLastBlockFile(nLastBlockFile);\n     printf(\"LoadBlockIndex(): last block file = %i\\n\", nLastBlockFile);\n-    if (ReadBlockFileInfo(nLastBlockFile, infoLastBlockFile))\n+    if (chaindb.ReadBlockFileInfo(nLastBlockFile, infoLastBlockFile))\n         printf(\"LoadBlockIndex(): last block file: %s\\n\", infoLastBlockFile.ToString().c_str());\n  \n     // Load hashBestChain pointer to end of best chain\n-    if (!ReadHashBestChain(hashBestChain))\n+    if (!coindb.ReadHashBestChain(hashBestChain))\n     {\n         if (pindexGenesisBlock == NULL)\n             return true;\n         return error(\"CTxDB::LoadBlockIndex() : hashBestChain not loaded\");\n     }\n-    if (!mapBlockIndex.count(hashBestChain))\n+    std::map<uint256, CBlockIndex*>::iterator it = mapBlockIndex.find(hashBestChain);\n+    if (it == mapBlockIndex.end()) {\n         return error(\"CTxDB::LoadBlockIndex() : hashBestChain not found in the block index\");\n-    pindexBest = mapBlockIndex[hashBestChain];\n-    nBestHeight = pindexBest->nHeight;\n-    bnBestChainWork = pindexBest->bnChainWork;\n-    printf(\"LoadBlockIndex(): hashBestChain=%s  height=%d  date=%s\\n\",\n-      hashBestChain.ToString().substr(0,20).c_str(), nBestHeight,\n-      DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n+    } else {\n+        // set 'next' pointers in best chain\n+        CBlockIndex *pindex = it->second;\n+        while(pindex != NULL && pindex->pprev != NULL) {\n+             CBlockIndex *pindexPrev = pindex->pprev;\n+             pindexPrev->pnext = pindex;\n+             pindex = pindexPrev;\n+        }\n+        pindexBest = it->second;\n+        nBestHeight = pindexBest->nHeight;\n+        bnBestChainWork = pindexBest->bnChainWork;\n+    }\n+    printf(\"LoadBlockIndex(): hashBestChain=%s  height=%d date=%s\\n\",\n+        hashBestChain.ToString().substr(0,20).c_str(), nBestHeight,\n+        DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n \n     // Load bnBestInvalidWork, OK if it doesn't exist\n-    ReadBestInvalidWork(bnBestInvalidWork);\n+    chaindb.ReadBestInvalidWork(bnBestInvalidWork);\n \n     // Verify blocks in the best chain\n     int nCheckLevel = GetArg(\"-checklevel\", 1);\n@@ -664,7 +629,6 @@ bool CTxDB::LoadBlockIndex()\n         if (fRequestShutdown || pindex->nHeight < nBestHeight-nCheckDepth)\n             break;\n         CBlock block;\n-        CDiskBlockPos blockPos = pindex->GetBlockPos();\n         if (!block.ReadFromDisk(pindex))\n             return error(\"LoadBlockIndex() : block.ReadFromDisk failed\");\n         // check level 1: verify block validity\n@@ -673,106 +637,20 @@ bool CTxDB::LoadBlockIndex()\n             printf(\"LoadBlockIndex() : *** found bad block at %d, hash=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n             pindexFork = pindex->pprev;\n         }\n-        // check level 2: verify transaction index validity\n-        if (nCheckLevel>1)\n-        {\n-            BOOST_FOREACH(const CTransaction &tx, block.vtx)\n-            {\n-                uint256 hashTx = tx.GetHash();\n-                CTxIndex txindex;\n-                if (ReadTxIndex(hashTx, txindex))\n-                {\n-                    // check level 3: checker transaction hashes\n-                    if (nCheckLevel>2 || blockPos != txindex.pos.blockPos)\n-                    {\n-                        // either an error or a duplicate transaction\n-                        CTransaction txFound;\n-                        if (!txFound.ReadFromDisk(txindex.pos))\n-                        {\n-                            printf(\"LoadBlockIndex() : *** cannot read mislocated transaction %s\\n\", hashTx.ToString().c_str());\n-                            pindexFork = pindex->pprev;\n-                        }\n-                        else\n-                            if (txFound.GetHash() != hashTx) // not a duplicate tx\n-                            {\n-                                printf(\"LoadBlockIndex(): *** invalid tx position for %s\\n\", hashTx.ToString().c_str());\n-                                pindexFork = pindex->pprev;\n-                            }\n-                    }\n-                    // check level 4: check whether spent txouts were spent within the main chain\n-                    unsigned int nOutput = 0;\n-                    if (nCheckLevel>3)\n-                    {\n-                        BOOST_FOREACH(const CDiskTxPos &txpos, txindex.vSpent)\n-                        {\n-                            if (!txpos.IsNull())\n-                            {\n-                                // check level 6: check whether spent txouts were spent by a valid transaction that consume them\n-                                if (nCheckLevel>5)\n-                                {\n-                                    CTransaction txSpend;\n-                                    if (!txSpend.ReadFromDisk(txpos))\n-                                    {\n-                                        printf(\"LoadBlockIndex(): *** cannot read spending transaction of %s:%i from disk\\n\", hashTx.ToString().c_str(), nOutput);\n-                                        pindexFork = pindex->pprev;\n-                                    }\n-                                    else if (!txSpend.CheckTransaction())\n-                                    {\n-                                        printf(\"LoadBlockIndex(): *** spending transaction of %s:%i is invalid\\n\", hashTx.ToString().c_str(), nOutput);\n-                                        pindexFork = pindex->pprev;\n-                                    }\n-                                    else\n-                                    {\n-                                        bool fFound = false;\n-                                        BOOST_FOREACH(const CTxIn &txin, txSpend.vin)\n-                                            if (txin.prevout.hash == hashTx && txin.prevout.n == nOutput)\n-                                                fFound = true;\n-                                        if (!fFound)\n-                                        {\n-                                            printf(\"LoadBlockIndex(): *** spending transaction of %s:%i does not spend it\\n\", hashTx.ToString().c_str(), nOutput);\n-                                            pindexFork = pindex->pprev;\n-                                        }\n-                                    }\n-                                }\n-                            }\n-                            nOutput++;\n-                        }\n-                    }\n-                }\n-                // check level 5: check whether all prevouts are marked spent\n-                if (nCheckLevel>4)\n-                {\n-                     BOOST_FOREACH(const CTxIn &txin, tx.vin)\n-                     {\n-                          CTxIndex txindex;\n-                          if (ReadTxIndex(txin.prevout.hash, txindex))\n-                              if (txindex.vSpent.size()-1 < txin.prevout.n || txindex.vSpent[txin.prevout.n].IsNull())\n-                              {\n-                                  printf(\"LoadBlockIndex(): *** found unspent prevout %s:%i in %s\\n\", txin.prevout.hash.ToString().c_str(), txin.prevout.n, hashTx.ToString().c_str());\n-                                  pindexFork = pindex->pprev;\n-                              }\n-                     }\n-                }\n-            }\n-        }\n+        // TODO: stronger verifications\n     }\n     if (pindexFork && !fRequestShutdown)\n     {\n-        // Reorg back to the fork\n-        printf(\"LoadBlockIndex() : *** moving best chain pointer back to block %d\\n\", pindexFork->nHeight);\n-        CBlock block;\n-        if (!block.ReadFromDisk(pindexFork))\n-            return error(\"LoadBlockIndex() : block.ReadFromDisk failed\");\n-        CTxDB txdb;\n-        block.SetBestChain(txdb, pindexFork);\n+        // TODO: reorg back\n+        return error(\"LoadBlockIndex(): chain database corrupted\");\n     }\n \n     return true;\n }\n \n \n \n-bool CTxDB::LoadBlockIndexGuts()\n+bool CChainDB::LoadBlockIndexGuts()\n {\n     // Get database cursor\n     Dbc* pcursor = GetCursor();\n@@ -786,7 +664,7 @@ bool CTxDB::LoadBlockIndexGuts()\n         // Read next record\n         CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n         if (fFlags == DB_SET_RANGE)\n-            ssKey << make_pair(string(\"blockindex\"), uint256(0));\n+            ssKey << make_pair('b', uint256(0));\n         CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n         int ret = ReadAtCursor(pcursor, ssKey, ssValue, fFlags);\n         fFlags = DB_NEXT;\n@@ -798,17 +676,16 @@ bool CTxDB::LoadBlockIndexGuts()\n         // Unserialize\n \n         try {\n-        string strType;\n-        ssKey >> strType;\n-        if (strType == \"blockindex\" && !fRequestShutdown)\n+        char chType;\n+        ssKey >> chType;\n+        if (chType == 'b' && !fRequestShutdown)\n         {\n             CDiskBlockIndex diskindex;\n             ssValue >> diskindex;\n \n             // Construct block index object\n             CBlockIndex* pindexNew = InsertBlockIndex(diskindex.GetBlockHash());\n             pindexNew->pprev          = InsertBlockIndex(diskindex.hashPrev);\n-            pindexNew->pnext          = InsertBlockIndex(diskindex.hashNext);\n             pindexNew->nHeight        = diskindex.nHeight;\n             pindexNew->pos            = diskindex.pos;\n             pindexNew->nUndoPos       = diskindex.nUndoPos;"
      },
      {
        "sha": "dd8993d56d658a947b19261bd7bc9c34369af205",
        "filename": "src/db.h",
        "status": "modified",
        "additions": 21,
        "deletions": 19,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/60dc5e886091e0e64678db4dd66ecd66434ca66c/src/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/60dc5e886091e0e64678db4dd66ecd66434ca66c/src/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.h?ref=60dc5e886091e0e64678db4dd66ecd66434ca66c",
        "patch": "@@ -17,10 +17,8 @@ class CAddress;\n class CAddrMan;\n class CBlockLocator;\n class CDiskBlockIndex;\n-class CDiskTxPos;\n class CMasterKey;\n class COutPoint;\n-class CTxIndex;\n class CWallet;\n class CWalletTx;\n \n@@ -316,39 +314,43 @@ class CDB\n \n \n \n-/** Access to the transaction database (blkindex.dat) */\n-class CTxDB : public CDB\n+/** Access to the transaction database (coins.dat) */\n+class CCoinsDB : public CDB\n {\n public:\n-    CTxDB(const char* pszMode=\"r+\") : CDB(\"blkindex.dat\", pszMode) { }\n+    CCoinsDB(const char* pszMode=\"r+\") : CDB(\"coins.dat\", pszMode) { }\n private:\n-    CTxDB(const CTxDB&);\n-    void operator=(const CTxDB&);\n+    CCoinsDB(const CCoinsDB&);\n+    void operator=(const CCoinsDB&);\n public:\n-    bool ReadTxIndex(uint256 hash, CTxIndex& txindex);\n-    bool UpdateTxIndex(uint256 hash, const CTxIndex& txindex);\n-    bool AddTxIndex(const CTransaction& tx, const CDiskTxPos& pos, int nHeight);\n-    bool EraseTxIndex(const CTransaction& tx);\n-    bool ContainsTx(uint256 hash);\n-    bool ReadDiskTx(uint256 hash, CTransaction& tx, CTxIndex& txindex);\n-    bool ReadDiskTx(uint256 hash, CTransaction& tx);\n-    bool ReadDiskTx(COutPoint outpoint, CTransaction& tx, CTxIndex& txindex);\n-    bool ReadDiskTx(COutPoint outpoint, CTransaction& tx);\n-    bool WriteBlockIndex(const CDiskBlockIndex& blockindex);\n+    bool ReadCoins(uint256 hash, CCoins &coins);\n+    bool WriteCoins(uint256 hash, const CCoins& coins);\n+    bool HaveCoins(uint256 hash);\n     bool ReadHashBestChain(uint256& hashBestChain);\n     bool WriteHashBestChain(uint256 hashBestChain);\n+};\n+\n+/** Access to the block database (chain.dat) */\n+class CChainDB : public CDB\n+{\n+public:\n+    CChainDB(const char* pszMode=\"r+\") : CDB(\"chain.dat\", pszMode) { }\n+private:\n+    CChainDB(const CChainDB&);\n+    void operator=(const CChainDB&);\n+public:\n+    bool WriteBlockIndex(const CDiskBlockIndex& blockindex);\n     bool ReadBestInvalidWork(CBigNum& bnBestInvalidWork);\n     bool WriteBestInvalidWork(CBigNum bnBestInvalidWork);\n     bool ReadBlockFileInfo(int nFile, CBlockFileInfo &fileinfo);\n     bool WriteBlockFileInfo(int nFile, const CBlockFileInfo &fileinfo);\n     bool ReadLastBlockFile(int &nFile);\n     bool WriteLastBlockFile(int nFile);\n-    bool LoadBlockIndex();\n-private:\n     bool LoadBlockIndexGuts();\n };\n \n \n+bool LoadBlockIndex(CCoinsDB &coinsdb, CChainDB &chaindb);\n \n \n /** Access to the (IP) address database (peers.dat) */"
      },
      {
        "sha": "56108cecee86fdad7ba927459a740728937d3ec1",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 8,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/60dc5e886091e0e64678db4dd66ecd66434ca66c/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/60dc5e886091e0e64678db4dd66ecd66434ca66c/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=60dc5e886091e0e64678db4dd66ecd66434ca66c",
        "patch": "@@ -638,14 +638,6 @@ bool AppInit2()\n         return InitError(msg);\n     }\n \n-    if (GetBoolArg(\"-loadblockindextest\"))\n-    {\n-        CTxDB txdb(\"r\");\n-        txdb.LoadBlockIndex();\n-        PrintBlockTree();\n-        return false;\n-    }\n-\n     uiInterface.InitMessage(_(\"Loading block index...\"));\n     printf(\"Loading block index...\\n\");\n     nStart = GetTimeMillis();"
      },
      {
        "sha": "ef5f627d94d2bbc2bd31efdbe81090ed2702f162",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 531,
        "deletions": 560,
        "changes": 1091,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/60dc5e886091e0e64678db4dd66ecd66434ca66c/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/60dc5e886091e0e64678db4dd66ecd66434ca66c/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=60dc5e886091e0e64678db4dd66ecd66434ca66c",
        "patch": "@@ -158,6 +158,99 @@ void static ResendWalletTransactions()\n \n \n \n+//////////////////////////////////////////////////////////////////////////////\n+//\n+// CCoinsView implementations\n+//\n+\n+bool CCoinsView::GetCoins(uint256 txid, CCoins &coins) { return false; }\n+bool CCoinsView::SetCoins(uint256 txid, const CCoins &coins) { return false; }\n+bool CCoinsView::HaveCoins(uint256 txid) { return false; }\n+CBlockIndex *CCoinsView::GetBestBlock() { return NULL; }\n+bool CCoinsView::SetBestBlock(CBlockIndex *pindex) { return false; }\n+\n+CCoinsViewBacked::CCoinsViewBacked(CCoinsView &viewIn) : base(&viewIn) { }\n+bool CCoinsViewBacked::GetCoins(uint256 txid, CCoins &coins) { return base->GetCoins(txid, coins); }\n+bool CCoinsViewBacked::SetCoins(uint256 txid, const CCoins &coins) { return base->SetCoins(txid, coins); }\n+bool CCoinsViewBacked::HaveCoins(uint256 txid) { return base->HaveCoins(txid); }\n+CBlockIndex *CCoinsViewBacked::GetBestBlock() { return base->GetBestBlock(); }\n+bool CCoinsViewBacked::SetBestBlock(CBlockIndex *pindex) { return base->SetBestBlock(pindex); }\n+void CCoinsViewBacked::SetBackend(CCoinsView &viewIn) { base = &viewIn; }\n+\n+CCoinsViewDB::CCoinsViewDB(CCoinsDB &dbIn) : db(dbIn) {}\n+bool CCoinsViewDB::GetCoins(uint256 txid, CCoins &coins) { return db.ReadCoins(txid, coins); }\n+bool CCoinsViewDB::SetCoins(uint256 txid, const CCoins &coins) { return db.WriteCoins(txid, coins); }\n+bool CCoinsViewDB::HaveCoins(uint256 txid) { return db.HaveCoins(txid); }\n+CBlockIndex *CCoinsViewDB::GetBestBlock() { return pindexBest; }\n+bool CCoinsViewDB::SetBestBlock(CBlockIndex *pindex) { return db.WriteHashBestChain(pindex->GetBlockHash()); }\n+\n+CCoinsViewCache::CCoinsViewCache(CCoinsView &baseIn, bool fDummy) : CCoinsViewBacked(baseIn), pindexTip(NULL) { }\n+\n+bool CCoinsViewCache::GetCoins(uint256 txid, CCoins &coins) {\n+    if (cacheCoins.count(txid)) {\n+        coins = cacheCoins[txid];\n+        return true;\n+    }\n+    if (base->GetCoins(txid, coins)) {\n+        cacheCoins[txid] = coins;\n+        return true;\n+    }\n+    return false;\n+}\n+\n+bool CCoinsViewCache::SetCoins(uint256 txid, const CCoins &coins) {\n+    cacheCoins[txid] = coins;\n+    return true;\n+}\n+\n+bool CCoinsViewCache::HaveCoins(uint256 txid) {\n+    return cacheCoins.count(txid) || base->HaveCoins(txid);\n+}\n+\n+CBlockIndex *CCoinsViewCache::GetBestBlock() {\n+    if (pindexTip == NULL)\n+        pindexTip = base->GetBestBlock();\n+    return pindexTip;\n+}\n+\n+bool CCoinsViewCache::SetBestBlock(CBlockIndex *pindex) {\n+    pindexTip = pindex;\n+    return true;\n+}\n+\n+bool CCoinsViewCache::Flush() {\n+    for (std::map<uint256,CCoins>::iterator it = cacheCoins.begin(); it != cacheCoins.end(); it++) {\n+        if (!base->SetCoins(it->first, it->second))\n+            return false;\n+    }\n+    if (!base->SetBestBlock(pindexTip))\n+        return false;\n+    cacheCoins.clear();\n+    pindexTip = NULL;\n+    return true;\n+}\n+\n+/** CCoinsView that brings transactions from a memorypool into view.\n+    It does not check for spendings by memory pool transactions. */\n+CCoinsViewMemPool::CCoinsViewMemPool(CCoinsView &baseIn, CTxMemPool &mempoolIn) : CCoinsViewBacked(baseIn), mempool(mempoolIn) { }\n+\n+bool CCoinsViewMemPool::GetCoins(uint256 txid, CCoins &coins) {\n+    if (base->GetCoins(txid, coins))\n+        return true;\n+    if (mempool.exists(txid)) {\n+        const CTransaction &tx = mempool.lookup(txid);\n+        coins = CCoins(tx, MEMPOOL_HEIGHT);\n+        return true;\n+    }\n+    return false;\n+}\n+\n+bool CCoinsViewMemPool::HaveCoins(uint256 txid) {\n+    return mempool.exists(txid) || base->HaveCoins(txid);\n+}\n+\n+\n+\n //////////////////////////////////////////////////////////////////////////////\n //\n // mapOrphanTransactions\n@@ -237,37 +330,9 @@ unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans)\n \n //////////////////////////////////////////////////////////////////////////////\n //\n-// CTransaction and CTxIndex\n+// CTransaction\n //\n \n-bool CTransaction::ReadFromDisk(CTxDB& txdb, COutPoint prevout, CTxIndex& txindexRet)\n-{\n-    SetNull();\n-    if (!txdb.ReadTxIndex(prevout.hash, txindexRet))\n-        return false;\n-    if (!ReadFromDisk(txindexRet.pos))\n-        return false;\n-    if (prevout.n >= vout.size())\n-    {\n-        SetNull();\n-        return false;\n-    }\n-    return true;\n-}\n-\n-bool CTransaction::ReadFromDisk(CTxDB& txdb, COutPoint prevout)\n-{\n-    CTxIndex txindex;\n-    return ReadFromDisk(txdb, prevout, txindex);\n-}\n-\n-bool CTransaction::ReadFromDisk(COutPoint prevout)\n-{\n-    CTxDB txdb(\"r\");\n-    CTxIndex txindex;\n-    return ReadFromDisk(txdb, prevout, txindex);\n-}\n-\n bool CTransaction::IsStandard() const\n {\n     if (nVersion > CTransaction::CURRENT_VERSION)\n@@ -303,7 +368,7 @@ bool CTransaction::IsStandard() const\n // expensive-to-check-upon-redemption script like:\n //   DUP CHECKSIG DROP ... repeated 100 times... OP_1\n //\n-bool CTransaction::AreInputsStandard(const MapPrevTx& mapInputs) const\n+bool CTransaction::AreInputsStandard(CCoinsView& mapInputs) const\n {\n     if (IsCoinBase())\n         return true; // Coinbases don't use vin normally\n@@ -383,17 +448,21 @@ int CMerkleTx::SetMerkleBranch(const CBlock* pblock)\n     else\n     {\n         CBlock blockTmp;\n-        if (pblock == NULL)\n-        {\n-            // Load the block this tx is in\n-            CTxIndex txindex;\n-            if (!CTxDB(\"r\").ReadTxIndex(GetHash(), txindex))\n-                return 0;\n-            if (!blockTmp.ReadFromDisk(txindex.pos.blockPos))\n-                return 0;\n-            pblock = &blockTmp;\n+\n+        if (pblock == NULL) {\n+            CCoinsDB coinsdb(\"r\");\n+            CCoins coins;\n+            if (coinsdb.ReadCoins(GetHash(), coins)) {\n+                CBlockIndex *pindex = FindBlockByHeight(coins.nHeight);\n+                if (pindex) {\n+                    if (!blockTmp.ReadFromDisk(pindex))\n+                        return 0;\n+                    pblock = &blockTmp;\n+                }\n+            }\n         }\n \n+        if (pblock) {\n         // Update the tx's hashBlock\n         hashBlock = pblock->GetHash();\n \n@@ -411,6 +480,7 @@ int CMerkleTx::SetMerkleBranch(const CBlock* pblock)\n \n         // Fill in merkle branch\n         vMerkleBranch = pblock->GetMerkleBranch(nIndex);\n+        }\n     }\n \n     // Is the tx in a block that's in the main chain\n@@ -526,8 +596,20 @@ int64 CTransaction::GetMinFee(unsigned int nBlockSize, bool fAllowFree,\n     return nMinFee;\n }\n \n+void CTxMemPool::pruneSpent(const uint256 &hashTx, CCoins &coins)\n+{\n+    LOCK(cs);\n+\n+    std::map<COutPoint, CInPoint>::iterator it = mapNextTx.lower_bound(COutPoint(hashTx, 0));\n \n-bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,\n+    // iterate over all COutPoints in mapNextTx whose hash equals the provided hashTx\n+    while (it != mapNextTx.end() && it->first.hash == hashTx) {\n+        coins.Spend(it->first.n); // and remove those outputs from coins\n+        it++;\n+    }\n+}\n+\n+bool CTxMemPool::accept(CCoinsDB& coinsdb, CTransaction &tx, bool fCheckInputs,\n                         bool* pfMissingInputs)\n {\n     if (pfMissingInputs)\n@@ -548,16 +630,13 @@ bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,\n     if (!fTestNet && !tx.IsStandard())\n         return error(\"CTxMemPool::accept() : nonstandard transaction type\");\n \n-    // Do we already have it?\n+    // is it already in the memory pool?\n     uint256 hash = tx.GetHash();\n     {\n         LOCK(cs);\n         if (mapTx.count(hash))\n             return false;\n     }\n-    if (fCheckInputs)\n-        if (txdb.ContainsTx(hash))\n-            return false;\n \n     // Check for conflicts with in-memory transactions\n     CTransaction* ptxOld = NULL;\n@@ -589,27 +668,32 @@ bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,\n \n     if (fCheckInputs)\n     {\n-        MapPrevTx mapInputs;\n-        map<uint256, CTxIndex> mapUnused;\n-        bool fInvalid = false;\n-        if (!tx.FetchInputs(txdb, mapUnused, false, false, mapInputs, fInvalid))\n-        {\n-            if (fInvalid)\n-                return error(\"CTxMemPool::accept() : FetchInputs found invalid tx %s\", hash.ToString().substr(0,10).c_str());\n-            if (pfMissingInputs)\n-                *pfMissingInputs = true;\n+        CCoinsViewDB viewDB(coinsdb);\n+        CCoinsViewMemPool viewMemPool(viewDB, mempool);\n+        CCoinsViewCache view(viewMemPool);\n+\n+        // do we already have it?\n+        if (view.HaveCoins(hash))\n             return false;\n+\n+        // do all inputs exist?\n+        BOOST_FOREACH(const CTxIn txin, tx.vin) {\n+            if (!view.HaveCoins(txin.prevout.hash)) {\n+                if (pfMissingInputs)\n+                    *pfMissingInputs = true;\n+                return false;\n+            }\n         }\n \n         // Check for non-standard pay-to-script-hash in inputs\n-        if (!tx.AreInputsStandard(mapInputs) && !fTestNet)\n+        if (!tx.AreInputsStandard(view) && !fTestNet)\n             return error(\"CTxMemPool::accept() : nonstandard transaction input\");\n \n         // Note: if you modify this code to accept non-standard transactions, then\n         // you should add code here to check that the transaction does a\n         // reasonable number of ECDSA signature verifications.\n \n-        int64 nFees = tx.GetValueIn(mapInputs)-tx.GetValueOut();\n+        int64 nFees = tx.GetValueIn(view)-tx.GetValueOut();\n         unsigned int nSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n \n         // Don't accept it if it can't get into a block\n@@ -646,7 +730,7 @@ bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,\n \n         // Check against previous transactions\n         // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n-        if (!tx.ConnectInputs(mapInputs, mapUnused, CDiskTxPos(true), pindexBest, false, false))\n+        if (!tx.CheckInputs(view, CS_ALWAYS, true, false))\n         {\n             return error(\"CTxMemPool::accept() : ConnectInputs failed %s\", hash.ToString().substr(0,10).c_str());\n         }\n@@ -674,9 +758,9 @@ bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,\n     return true;\n }\n \n-bool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMissingInputs)\n+bool CTransaction::AcceptToMemoryPool(CCoinsDB& coinsdb, bool fCheckInputs, bool* pfMissingInputs)\n {\n-    return mempool.accept(txdb, *this, fCheckInputs, pfMissingInputs);\n+    return mempool.accept(coinsdb, *this, fCheckInputs, pfMissingInputs);\n }\n \n bool CTxMemPool::addUnchecked(const uint256& hash, CTransaction &tx)\n@@ -765,29 +849,29 @@ int CMerkleTx::GetBlocksToMaturity() const\n }\n \n \n-bool CMerkleTx::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs)\n+bool CMerkleTx::AcceptToMemoryPool(CCoinsDB& coinsdb, bool fCheckInputs)\n {\n     if (fClient)\n     {\n-        if (!IsInMainChain() && !ClientConnectInputs())\n+        if (!IsInMainChain() && !ClientCheckInputs())\n             return false;\n-        return CTransaction::AcceptToMemoryPool(txdb, false);\n+        return CTransaction::AcceptToMemoryPool(coinsdb, false);\n     }\n     else\n     {\n-        return CTransaction::AcceptToMemoryPool(txdb, fCheckInputs);\n+        return CTransaction::AcceptToMemoryPool(coinsdb, fCheckInputs);\n     }\n }\n \n bool CMerkleTx::AcceptToMemoryPool()\n {\n-    CTxDB txdb(\"r\");\n-    return AcceptToMemoryPool(txdb);\n+    CCoinsDB coinsdb(\"r\");\n+    return AcceptToMemoryPool(coinsdb);\n }\n \n \n \n-bool CWalletTx::AcceptWalletTransaction(CTxDB& txdb, bool fCheckInputs)\n+bool CWalletTx::AcceptWalletTransaction(CCoinsDB& coinsdb, bool fCheckInputs)\n {\n \n     {\n@@ -798,64 +882,65 @@ bool CWalletTx::AcceptWalletTransaction(CTxDB& txdb, bool fCheckInputs)\n             if (!tx.IsCoinBase())\n             {\n                 uint256 hash = tx.GetHash();\n-                if (!mempool.exists(hash) && !txdb.ContainsTx(hash))\n-                    tx.AcceptToMemoryPool(txdb, fCheckInputs);\n+                if (!mempool.exists(hash) && !coinsdb.HaveCoins(hash))\n+                    tx.AcceptToMemoryPool(coinsdb, fCheckInputs);\n             }\n         }\n-        return AcceptToMemoryPool(txdb, fCheckInputs);\n+        return AcceptToMemoryPool(coinsdb, fCheckInputs);\n     }\n     return false;\n }\n \n bool CWalletTx::AcceptWalletTransaction()\n {\n-    CTxDB txdb(\"r\");\n-    return AcceptWalletTransaction(txdb);\n-}\n-\n-int CTxIndex::GetDepthInMainChain() const\n-{\n-    // Read block header\n-    CBlock block;\n-    if (!block.ReadFromDisk(pos.blockPos, false))\n-        return 0;\n-    // Find the block in the index\n-    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(block.GetHash());\n-    if (mi == mapBlockIndex.end())\n-        return 0;\n-    CBlockIndex* pindex = (*mi).second;\n-    if (!pindex || !pindex->IsInMainChain())\n-        return 0;\n-    return 1 + nBestHeight - pindex->nHeight;\n+    CCoinsDB coinsdb(\"r\");\n+    return AcceptWalletTransaction(coinsdb);\n }\n \n // Return transaction in tx, and if it was found inside a block, its hash is placed in hashBlock\n-bool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock)\n+bool GetTransaction(const uint256 &hash, CTransaction &txOut, uint256 &hashBlock, bool fAllowSlow)\n {\n+    CBlockIndex *pindexSlow = NULL;\n     {\n         LOCK(cs_main);\n         {\n             LOCK(mempool.cs);\n             if (mempool.exists(hash))\n             {\n-                tx = mempool.lookup(hash);\n+                txOut = mempool.lookup(hash);\n                 return true;\n             }\n         }\n-        CTxDB txdb(\"r\");\n-        CTxIndex txindex;\n-        if (tx.ReadFromDisk(txdb, COutPoint(hash, 0), txindex))\n-        {\n-            CBlock block;\n-            if (block.ReadFromDisk(txindex.pos.blockPos, false))\n-                hashBlock = block.GetHash();\n-            return true;\n+\n+        if (fAllowSlow) { // use coin database to locate block that contains transaction, and scan it\n+            int nHeight = -1;\n+            {\n+                CCoinsDB coindb(\"r\");\n+                CCoinsViewDB view(coindb);\n+                CCoins coins;\n+                if (view.GetCoins(hash, coins))\n+                    nHeight = coins.nHeight;\n+            }\n+            if (nHeight > 0)\n+                pindexSlow = FindBlockByHeight(nHeight);\n         }\n     }\n-    return false;\n-}\n \n+    if (pindexSlow) {\n+        CBlock block;\n+        if (block.ReadFromDisk(pindexSlow)) {\n+            BOOST_FOREACH(const CTransaction &tx, block.vtx) {\n+                if (tx.GetHash() == hash) {\n+                    txOut = tx;\n+                    hashBlock = pindexSlow->GetBlockHash();\n+                    return true;\n+                }\n+            }\n+        }\n+    }\n \n+    return false;\n+}\n \n \n \n@@ -1051,7 +1136,7 @@ void static InvalidChainFound(CBlockIndex* pindexNew)\n     if (pindexNew->bnChainWork > bnBestInvalidWork)\n     {\n         bnBestInvalidWork = pindexNew->bnChainWork;\n-        CTxDB().WriteBestInvalidWork(bnBestInvalidWork);\n+        CChainDB().WriteBestInvalidWork(bnBestInvalidWork);\n         uiInterface.NotifyBlocksChanged();\n     }\n     printf(\"InvalidChainFound: invalid block=%s  height=%d  work=%s  date=%s\\n\",\n@@ -1084,253 +1169,173 @@ void CBlock::UpdateTime(const CBlockIndex* pindexPrev)\n \n \n \n-bool CTransaction::DisconnectInputs(CTxDB& txdb)\n-{\n-    // Relinquish previous transactions' spent pointers\n-    if (!IsCoinBase())\n-    {\n-        BOOST_FOREACH(const CTxIn& txin, vin)\n-        {\n-            COutPoint prevout = txin.prevout;\n-\n-            // Get prev txindex from disk\n-            CTxIndex txindex;\n-            if (!txdb.ReadTxIndex(prevout.hash, txindex))\n-                return error(\"DisconnectInputs() : ReadTxIndex failed\");\n-\n-            if (prevout.n >= txindex.vSpent.size())\n-                return error(\"DisconnectInputs() : prevout.n out of range\");\n-\n-            // Mark outpoint as not spent\n-            txindex.vSpent[prevout.n].SetNull();\n-\n-            // Write back\n-            if (!txdb.UpdateTxIndex(prevout.hash, txindex))\n-                return error(\"DisconnectInputs() : UpdateTxIndex failed\");\n-        }\n-    }\n-\n-    // Remove transaction from index\n-    // This can fail if a duplicate of this transaction was in a chain that got\n-    // reorganized away. This is only possible if this transaction was completely\n-    // spent, so erasing it would be a no-op anyway.\n-    txdb.EraseTxIndex(*this);\n-\n-    return true;\n-}\n-\n-\n-bool CTransaction::FetchInputs(CTxDB& txdb, const map<uint256, CTxIndex>& mapTestPool,\n-                               bool fBlock, bool fMiner, MapPrevTx& inputsRet, bool& fInvalid)\n+CTxOut CTransaction::GetOutputFor(const CTxIn& input, CCoinsView& view)\n {\n-    // FetchInputs can return false either because we just haven't seen some inputs\n-    // (in which case the transaction should be stored as an orphan)\n-    // or because the transaction is malformed (in which case the transaction should\n-    // be dropped).  If tx is definitely invalid, fInvalid will be set to true.\n-    fInvalid = false;\n-\n-    if (IsCoinBase())\n-        return true; // Coinbase transactions have no inputs to fetch.\n-\n-    for (unsigned int i = 0; i < vin.size(); i++)\n-    {\n-        COutPoint prevout = vin[i].prevout;\n-        if (inputsRet.count(prevout.hash))\n-            continue; // Got it already\n-\n-        // Read txindex\n-        CTxIndex& txindex = inputsRet[prevout.hash].first;\n-        bool fFound = true;\n-        if ((fBlock || fMiner) && mapTestPool.count(prevout.hash))\n-        {\n-            // Get txindex from current proposed changes\n-            txindex = mapTestPool.find(prevout.hash)->second;\n-        }\n-        else\n-        {\n-            // Read txindex from txdb\n-            fFound = txdb.ReadTxIndex(prevout.hash, txindex);\n-        }\n-        if (!fFound && (fBlock || fMiner))\n-            return fMiner ? false : error(\"FetchInputs() : %s prev tx %s index entry not found\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n-\n-        // Read txPrev\n-        CTransaction& txPrev = inputsRet[prevout.hash].second;\n-        if (!fFound || txindex.pos.IsMemPool())\n-        {\n-            // Get prev tx from single transactions in memory\n-            {\n-                LOCK(mempool.cs);\n-                if (!mempool.exists(prevout.hash))\n-                    return error(\"FetchInputs() : %s mempool Tx prev not found %s\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n-                txPrev = mempool.lookup(prevout.hash);\n-            }\n-            if (!fFound)\n-                txindex.vSpent.resize(txPrev.vout.size());\n-        }\n-        else\n-        {\n-            // Get prev tx from disk\n-            if (!txPrev.ReadFromDisk(txindex.pos))\n-                return error(\"FetchInputs() : %s ReadFromDisk prev tx %s failed\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n-        }\n-    }\n-\n-    // Make sure all prevout.n indexes are valid:\n-    for (unsigned int i = 0; i < vin.size(); i++)\n-    {\n-        const COutPoint prevout = vin[i].prevout;\n-        assert(inputsRet.count(prevout.hash) != 0);\n-        const CTxIndex& txindex = inputsRet[prevout.hash].first;\n-        const CTransaction& txPrev = inputsRet[prevout.hash].second;\n-        if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())\n-        {\n-            // Revisit this if/when transaction replacement is implemented and allows\n-            // adding inputs:\n-            fInvalid = true;\n-            return DoS(100, error(\"FetchInputs() : %s prevout.n out of range %d %\"PRIszu\" %\"PRIszu\" prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n-        }\n-    }\n-\n-    return true;\n-}\n-\n-const CTxOut& CTransaction::GetOutputFor(const CTxIn& input, const MapPrevTx& inputs) const\n-{\n-    MapPrevTx::const_iterator mi = inputs.find(input.prevout.hash);\n-    if (mi == inputs.end())\n+    CCoins coins;\n+    if (!view.GetCoins(input.prevout.hash, coins))\n         throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.hash not found\");\n \n-    const CTransaction& txPrev = (mi->second).second;\n-    if (input.prevout.n >= txPrev.vout.size())\n-        throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.n out of range\");\n+    if (input.prevout.n >= coins.vout.size())\n+        throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.n out of range or already spent\");\n+\n+    const CTxOut &out = coins.vout[input.prevout.n];\n+    if (out.IsNull())\n+        throw std::runtime_error(\"CTransaction::GetOutputFor() : already spent\");\n \n-    return txPrev.vout[input.prevout.n];\n+    return out;\n }\n \n-int64 CTransaction::GetValueIn(const MapPrevTx& inputs) const\n+int64 CTransaction::GetValueIn(CCoinsView& inputs) const\n {\n     if (IsCoinBase())\n         return 0;\n \n     int64 nResult = 0;\n     for (unsigned int i = 0; i < vin.size(); i++)\n-    {\n         nResult += GetOutputFor(vin[i], inputs).nValue;\n-    }\n-    return nResult;\n \n+    return nResult;\n }\n \n-unsigned int CTransaction::GetP2SHSigOpCount(const MapPrevTx& inputs) const\n+unsigned int CTransaction::GetP2SHSigOpCount(CCoinsView& inputs) const\n {\n     if (IsCoinBase())\n         return 0;\n \n     unsigned int nSigOps = 0;\n     for (unsigned int i = 0; i < vin.size(); i++)\n     {\n-        const CTxOut& prevout = GetOutputFor(vin[i], inputs);\n+        CTxOut prevout = GetOutputFor(vin[i], inputs);\n         if (prevout.scriptPubKey.IsPayToScriptHash())\n             nSigOps += prevout.scriptPubKey.GetSigOpCount(vin[i].scriptSig);\n     }\n     return nSigOps;\n }\n \n-bool CTransaction::ConnectInputs(MapPrevTx inputs,\n-                                 map<uint256, CTxIndex>& mapTestPool, const CDiskTxPos& posThisTx,\n-                                 const CBlockIndex* pindexBlock, bool fBlock, bool fMiner, bool fStrictPayToScriptHash)\n+bool CTransaction::UpdateCoins(CCoinsView &inputs, CTxUndo &txundo, int nHeight) const\n+{\n+    uint256 hash = GetHash();\n+\n+    // mark inputs spent\n+    if (!IsCoinBase()) {\n+        BOOST_FOREACH(const CTxIn &txin, vin) {\n+            CCoins coins;\n+            if (!inputs.GetCoins(txin.prevout.hash, coins))\n+                return error(\"UpdateCoins() : cannot find prevtx\");\n+            CTxInUndo undo;\n+            if (!coins.Spend(txin.prevout, undo))\n+                return error(\"UpdateCoins() : cannot spend input\");\n+            txundo.vprevout.push_back(undo);\n+            if (!inputs.SetCoins(txin.prevout.hash, coins))\n+                return error(\"UpdateCoins() : cannot update input\");\n+        }\n+    }\n+\n+    // add outputs\n+    if (!inputs.SetCoins(hash, CCoins(*this, nHeight)))\n+        return error(\"UpdateCoins() : cannot update output\");\n+\n+    return true;\n+}\n+\n+bool CTransaction::HaveInputs(CCoinsView &inputs) const\n+{\n+    if (!IsCoinBase()) { \n+        // first check whether information about the prevout hash is available\n+        for (unsigned int i = 0; i < vin.size(); i++) {\n+            const COutPoint &prevout = vin[i].prevout;\n+            if (!inputs.HaveCoins(prevout.hash))\n+                return false;\n+        }\n+\n+        // then check whether the actual outputs are available\n+        for (unsigned int i = 0; i < vin.size(); i++) {\n+            const COutPoint &prevout = vin[i].prevout;\n+            CCoins coins;\n+            inputs.GetCoins(prevout.hash, coins);\n+            if (!coins.IsAvailable(prevout.n))\n+                return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool CTransaction::CheckInputs(CCoinsView &inputs, enum CheckSig_mode csmode, bool fStrictPayToScriptHash, bool fStrictEncodings) const\n {\n-    // Take over previous transactions' spent pointers\n-    // fBlock is true when this is called from AcceptBlock when a new best-block is added to the blockchain\n-    // fMiner is true when called from the internal bitcoin miner\n-    // ... both are false when called from CTransaction::AcceptToMemoryPool\n     if (!IsCoinBase())\n     {\n         int64 nValueIn = 0;\n         int64 nFees = 0;\n         for (unsigned int i = 0; i < vin.size(); i++)\n         {\n-            COutPoint prevout = vin[i].prevout;\n-            assert(inputs.count(prevout.hash) > 0);\n-            CTxIndex& txindex = inputs[prevout.hash].first;\n-            CTransaction& txPrev = inputs[prevout.hash].second;\n+            const COutPoint &prevout = vin[i].prevout;\n+            CCoins coins;\n+            if (!inputs.GetCoins(prevout.hash, coins))\n+                return error(\"CheckInputs() : cannot find prevout tx\");\n \n-            if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())\n-                return DoS(100, error(\"ConnectInputs() : %s prevout.n out of range %d %\"PRIszu\" %\"PRIszu\" prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n+            // Check for conflicts (double-spend)\n+            // This doesn't trigger the DoS code on purpose; if it did, it would make it easier\n+            // for an attacker to attempt to split the network.\n+            if (!coins.IsAvailable(prevout.n))\n+                return error(\"CheckInputs() : %s prev tx already used\", GetHash().ToString().substr(0,10).c_str());\n \n             // If prev is coinbase, check that it's matured\n-            if (txPrev.IsCoinBase())\n-                for (const CBlockIndex* pindex = pindexBlock; pindex && pindexBlock->nHeight - pindex->nHeight < COINBASE_MATURITY; pindex = pindex->pprev)\n-                    if (pindex->GetBlockPos() == txindex.pos.blockPos)\n-                        return error(\"ConnectInputs() : tried to spend coinbase at depth %d\", pindexBlock->nHeight - pindex->nHeight);\n+            if (coins.IsCoinBase()) {\n+                CBlockIndex *pindexBlock = inputs.GetBestBlock();\n+                if (pindexBlock->nHeight - coins.nHeight < COINBASE_MATURITY)\n+                    return error(\"CheckInputs() : tried to spend coinbase at depth %d\", pindexBlock->nHeight - coins.nHeight);\n+            }\n \n             // Check for negative or overflow input values\n-            nValueIn += txPrev.vout[prevout.n].nValue;\n-            if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n-                return DoS(100, error(\"ConnectInputs() : txin values out of range\"));\n+            nValueIn += coins.vout[prevout.n].nValue;\n+            if (!MoneyRange(coins.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n+                return DoS(100, error(\"CheckInputs() : txin values out of range\"));\n \n         }\n+\n+        if (nValueIn < GetValueOut())\n+            return DoS(100, error(\"ChecktInputs() : %s value in < value out\", GetHash().ToString().substr(0,10).c_str()));\n+\n+        // Tally transaction fees\n+        int64 nTxFee = nValueIn - GetValueOut();\n+        if (nTxFee < 0)\n+            return DoS(100, error(\"CheckInputs() : %s nTxFee < 0\", GetHash().ToString().substr(0,10).c_str()));\n+        nFees += nTxFee;\n+        if (!MoneyRange(nFees))\n+            return DoS(100, error(\"CheckInputs() : nFees out of range\"));\n+\n         // The first loop above does all the inexpensive checks.\n         // Only if ALL inputs pass do we perform expensive ECDSA signature checks.\n         // Helps prevent CPU exhaustion attacks.\n-        for (unsigned int i = 0; i < vin.size(); i++)\n-        {\n-            COutPoint prevout = vin[i].prevout;\n-            assert(inputs.count(prevout.hash) > 0);\n-            CTxIndex& txindex = inputs[prevout.hash].first;\n-            CTransaction& txPrev = inputs[prevout.hash].second;\n \n-            // Check for conflicts (double-spend)\n-            // This doesn't trigger the DoS code on purpose; if it did, it would make it easier\n-            // for an attacker to attempt to split the network.\n-            if (!txindex.vSpent[prevout.n].IsNull())\n-                return fMiner ? false : error(\"ConnectInputs() : %s prev tx already used at %s\", GetHash().ToString().substr(0,10).c_str(), txindex.vSpent[prevout.n].ToString().c_str());\n+        // Skip ECDSA signature verification when connecting blocks\n+        // before the last blockchain checkpoint. This is safe because block merkle hashes are\n+        // still computed and checked, and any change will be caught at the next checkpoint.\n+        if (csmode == CS_ALWAYS || \n+            (csmode == CS_AFTER_CHECKPOINT && inputs.GetBestBlock()->nHeight >= Checkpoints::GetTotalBlocksEstimate())) {\n+            for (unsigned int i = 0; i < vin.size(); i++) {\n+                const COutPoint &prevout = vin[i].prevout;\n+                CCoins coins;\n+                inputs.GetCoins(prevout.hash, coins);\n \n-            // Skip ECDSA signature verification when connecting blocks (fBlock=true)\n-            // before the last blockchain checkpoint. This is safe because block merkle hashes are\n-            // still computed and checked, and any change will be caught at the next checkpoint.\n-            if (!(fBlock && (nBestHeight < Checkpoints::GetTotalBlocksEstimate())))\n-            {\n                 // Verify signature\n-                if (!VerifySignature(txPrev, *this, i, fStrictPayToScriptHash, false, 0))\n-                {\n+                if (!VerifySignature(coins, *this, i, fStrictPayToScriptHash, fStrictEncodings, 0)) {\n                     // only during transition phase for P2SH: do not invoke anti-DoS code for\n                     // potentially old clients relaying bad P2SH transactions\n-                    if (fStrictPayToScriptHash && VerifySignature(txPrev, *this, i, false, false, 0))\n-                        return error(\"ConnectInputs() : %s P2SH VerifySignature failed\", GetHash().ToString().substr(0,10).c_str());\n+                    if (fStrictPayToScriptHash && VerifySignature(coins, *this, i, false, fStrictEncodings, 0))\n+                        return error(\"CheckInputs() : %s P2SH VerifySignature failed\", GetHash().ToString().substr(0,10).c_str());\n \n-                    return DoS(100,error(\"ConnectInputs() : %s VerifySignature failed\", GetHash().ToString().substr(0,10).c_str()));\n+                    return DoS(100,error(\"CheckInputs() : %s VerifySignature failed\", GetHash().ToString().substr(0,10).c_str()));\n                 }\n             }\n-\n-            // Mark outpoints as spent\n-            txindex.vSpent[prevout.n] = posThisTx;\n-\n-            // Write back\n-            if (fBlock || fMiner)\n-            {\n-                mapTestPool[prevout.hash] = txindex;\n-            }\n         }\n-\n-        if (nValueIn < GetValueOut())\n-            return DoS(100, error(\"ConnectInputs() : %s value in < value out\", GetHash().ToString().substr(0,10).c_str()));\n-\n-        // Tally transaction fees\n-        int64 nTxFee = nValueIn - GetValueOut();\n-        if (nTxFee < 0)\n-            return DoS(100, error(\"ConnectInputs() : %s nTxFee < 0\", GetHash().ToString().substr(0,10).c_str()));\n-        nFees += nTxFee;\n-        if (!MoneyRange(nFees))\n-            return DoS(100, error(\"ConnectInputs() : nFees out of range\"));\n     }\n \n     return true;\n }\n \n \n-bool CTransaction::ClientConnectInputs()\n+bool CTransaction::ClientCheckInputs() const\n {\n     if (IsCoinBase())\n         return false;\n@@ -1351,7 +1356,7 @@ bool CTransaction::ClientConnectInputs()\n                 return false;\n \n             // Verify signature\n-            if (!VerifySignature(txPrev, *this, i, true, false, 0))\n+            if (!VerifySignature(CCoins(txPrev, -1), *this, i, true, false, 0))\n                 return error(\"ConnectInputs() : VerifySignature failed\");\n \n             ///// this is redundant with the mempool.mapNextTx stuff,\n@@ -1379,34 +1384,89 @@ bool CTransaction::ClientConnectInputs()\n \n \n \n-bool CBlock::DisconnectBlock(CTxDB& txdb, CBlockIndex* pindex)\n+bool CBlock::DisconnectBlock(CBlockIndex *pindex, CCoinsView &view)\n {\n-    // Disconnect in reverse order\n-    for (int i = vtx.size()-1; i >= 0; i--)\n-        if (!vtx[i].DisconnectInputs(txdb))\n-            return false;\n+    assert(pindex == view.GetBestBlock());\n \n-    // Update block index on disk without changing it in memory.\n-    // The memory index structure will be changed after the db commits.\n-    if (pindex->pprev)\n+    CBlockUndo blockUndo;\n     {\n-        CDiskBlockIndex blockindexPrev(pindex->pprev);\n-        blockindexPrev.hashNext = 0;\n-        if (!txdb.WriteBlockIndex(blockindexPrev))\n-            return error(\"DisconnectBlock() : WriteBlockIndex failed\");\n+        CDiskBlockPos pos = pindex->GetUndoPos();\n+        if (pos.IsNull())\n+            return error(\"DisconnectBlock() : no undo data available\");\n+        FILE *file = OpenUndoFile(pos, true);\n+        if (file == NULL)\n+            return error(\"DisconnectBlock() : undo file not available\");\n+        CAutoFile fileUndo(file, SER_DISK, CLIENT_VERSION);\n+        fileUndo >> blockUndo;\n     }\n \n+    assert(blockUndo.vtxundo.size() + 1 == vtx.size());\n+\n+    // undo transactions in reverse order\n+    for (int i = vtx.size() - 1; i >= 0; i--) {\n+        const CTransaction &tx = vtx[i];\n+        uint256 hash = tx.GetHash();\n+\n+        // check that all outputs are available\n+        CCoins outs;\n+        if (!view.GetCoins(hash, outs))\n+            return error(\"DisconnectBlock() : outputs still spent? database corrupted\");\n+\n+        CCoins outsBlock = CCoins(tx, pindex->nHeight);\n+        if (outs != outsBlock)\n+            return error(\"DisconnectBlock() : added transaction mismatch? database corrupted\");\n+\n+        // remove outputs\n+        if (!view.SetCoins(hash, CCoins()))\n+            return error(\"DisconnectBlock() : cannot delete coin outputs\");\n+\n+        // restore inputs\n+        if (i > 0) { // not coinbases\n+            const CTxUndo &txundo = blockUndo.vtxundo[i-1];\n+            assert(txundo.vprevout.size() == tx.vin.size());\n+            for (unsigned int j = tx.vin.size(); j-- > 0;) {\n+                const COutPoint &out = tx.vin[j].prevout;\n+                const CTxInUndo &undo = txundo.vprevout[j];\n+                CCoins coins;\n+                view.GetCoins(out.hash, coins); // this can fail if the prevout was already entirely spent\n+                if (coins.IsPruned()) {\n+                    if (undo.nHeight == 0)\n+                        return error(\"DisconnectBlock() : undo data doesn't contain tx metadata? database corrupted\");\n+                    coins.fCoinBase = undo.fCoinBase;\n+                    coins.nHeight = undo.nHeight;\n+                    coins.nVersion = undo.nVersion;\n+                } else {\n+                    if (undo.nHeight != 0)\n+                        return error(\"DisconnectBlock() : undo data contains unneeded tx metadata? database corrupted\");\n+                }\n+                if (coins.IsAvailable(out.n))\n+                    return error(\"DisconnectBlock() : prevout output not spent? database corrupted\");\n+                if (coins.vout.size() < out.n+1)\n+                    coins.vout.resize(out.n+1);\n+                coins.vout[out.n] = undo.txout;\n+                if (!view.SetCoins(out.hash, coins))\n+                    return error(\"DisconnectBlock() : cannot restore coin inputs\");\n+            }\n+        }\n+    }\n+\n+    // move best block pointer to prevout block\n+    view.SetBestBlock(pindex->pprev);\n+\n     return true;\n }\n \n-bool FindUndoPos(CTxDB &txdb, int nFile, CDiskBlockPos &pos, unsigned int nAddSize);\n+bool FindUndoPos(CChainDB &chaindb, int nFile, CDiskBlockPos &pos, unsigned int nAddSize);\n \n-bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex, bool fJustCheck)\n+bool CBlock::ConnectBlock(CBlockIndex* pindex, CCoinsView &view, bool fJustCheck)\n {\n     // Check it again in case a previous version let a bad block in\n     if (!CheckBlock(!fJustCheck, !fJustCheck))\n         return false;\n \n+    // verify that the view's current state corresponds to the previous block\n+    assert(pindex->pprev == view.GetBestBlock());\n+\n     // Do not allow blocks that contain transactions which 'overwrite' older transactions,\n     // unless those are already completely spent.\n     // If such overwrites are allowed, coinbases and transactions depending upon those\n@@ -1421,163 +1481,152 @@ bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex, bool fJustCheck)\n     // initial block download.\n     bool fEnforceBIP30 = !((pindex->nHeight==91842 && pindex->GetBlockHash() == uint256(\"0x00000000000a4d0a398161ffc163c503763b1f4360639393e0e4c8e300e0caec\")) ||\n                            (pindex->nHeight==91880 && pindex->GetBlockHash() == uint256(\"0x00000000000743f190a18c5577a3c2d2a1f610ae9601ac046a38084ccb7cd721\")));\n+    if (fEnforceBIP30) {\n+        BOOST_FOREACH(CTransaction& tx, vtx) {\n+            uint256 hash = tx.GetHash();\n+            CCoins coins;\n+            if (view.GetCoins(hash, coins) && !coins.IsPruned())\n+                return error(\"ConnectBlock() : tried to overwrite transaction\");\n+        }\n+    }\n \n     // BIP16 didn't become active until Apr 1 2012\n     int64 nBIP16SwitchTime = 1333238400;\n     bool fStrictPayToScriptHash = (pindex->nTime >= nBIP16SwitchTime);\n \n-    //// issue here: it doesn't know the version\n-    unsigned int nTxPos;\n-    if (fJustCheck)\n-        // Since we're just checking the block and not actually connecting it, it might not (and probably shouldn't) be on the disk to get the transaction from\n-        nTxPos = 1;\n-    else\n-        nTxPos = pindex->pos.nPos + ::GetSerializeSize(CBlock(), SER_DISK, CLIENT_VERSION) - 1 + GetSizeOfCompactSize(vtx.size());\n-\n     CBlockUndo blockundo;\n \n-    map<uint256, CTxIndex> mapQueuedChanges;\n     int64 nFees = 0;\n     unsigned int nSigOps = 0;\n     BOOST_FOREACH(CTransaction& tx, vtx)\n     {\n-        uint256 hashTx = tx.GetHash();\n-\n-        if (fEnforceBIP30) {\n-            CTxIndex txindexOld;\n-            if (txdb.ReadTxIndex(hashTx, txindexOld)) {\n-                BOOST_FOREACH(CDiskTxPos &pos, txindexOld.vSpent)\n-                    if (pos.IsNull())\n-                        return false;\n-            }\n-        }\n-\n         nSigOps += tx.GetLegacySigOpCount();\n         if (nSigOps > MAX_BLOCK_SIGOPS)\n             return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n \n-        CDiskTxPos posThisTx(pindex->GetBlockPos(), nTxPos);\n-        if (!fJustCheck)\n-            nTxPos += ::GetSerializeSize(tx, SER_DISK, CLIENT_VERSION);\n-        else\n-            posThisTx = CDiskTxPos(true);\n-\n-        MapPrevTx mapInputs;\n         if (!tx.IsCoinBase())\n         {\n-            CTxUndo undo;\n-\n-            bool fInvalid;\n-            if (!tx.FetchInputs(txdb, mapQueuedChanges, true, false, mapInputs, fInvalid))\n-                return false;\n+            if (!tx.HaveInputs(view))\n+                return DoS(100, error(\"ConnectBlock() : inputs missing/spent\"));\n \n             if (fStrictPayToScriptHash)\n             {\n                 // Add in sigops done by pay-to-script-hash inputs;\n                 // this is to prevent a \"rogue miner\" from creating\n                 // an incredibly-expensive-to-validate block.\n-                nSigOps += tx.GetP2SHSigOpCount(mapInputs);\n+                nSigOps += tx.GetP2SHSigOpCount(view);\n                 if (nSigOps > MAX_BLOCK_SIGOPS)\n-                    return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n+                     return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n             }\n \n-            nFees += tx.GetValueIn(mapInputs)-tx.GetValueOut();\n+            nFees += tx.GetValueIn(view)-tx.GetValueOut();\n \n-            BOOST_FOREACH(const CTxIn &in, tx.vin) {\n-                undo.vprevout.push_back(CTxInUndo(mapInputs[in.prevout.hash].second.vout[in.prevout.n], pindex->nHeight));\n-            }\n-\n-            if (!tx.ConnectInputs(mapInputs, mapQueuedChanges, posThisTx, pindex, true, false, fStrictPayToScriptHash))\n+            if (!tx.CheckInputs(view, CS_AFTER_CHECKPOINT, fStrictPayToScriptHash, false))\n                 return false;\n-\n-            blockundo.vtxundo.push_back(undo);\n         }\n \n-        mapQueuedChanges[hashTx] = CTxIndex(posThisTx, tx.vout.size());\n+        CTxUndo txundo;\n+        if (!tx.UpdateCoins(view, txundo, pindex->nHeight))\n+            return error(\"ConnectBlock() : UpdateInputs failed\");\n+        if (!tx.IsCoinBase())\n+            blockundo.vtxundo.push_back(txundo);\n     }\n \n-    if (vtx[0].GetValueOut() > GetBlockValue(pindex->nHeight, nFees))\n-        return false;\n-\n     if (fJustCheck)\n         return true;\n \n-    // Write queued txindex changes\n-    for (map<uint256, CTxIndex>::iterator mi = mapQueuedChanges.begin(); mi != mapQueuedChanges.end(); ++mi)\n-    {\n-        if (!txdb.UpdateTxIndex((*mi).first, (*mi).second))\n-            return error(\"ConnectBlock() : UpdateTxIndex failed\");\n-    }\n-\n     // Write undo information to disk\n-    if (pindex->GetUndoPos().IsNull() && pindex->nHeight > Checkpoints::GetTotalBlocksEstimate())\n+    if (pindex->GetUndoPos().IsNull())\n     {\n+        CChainDB chaindb;\n         CDiskBlockPos pos;\n-        if (!FindUndoPos(txdb, pindex->pos.nFile, pos, ::GetSerializeSize(blockundo, SER_DISK, CLIENT_VERSION) + 8))\n+        if (!FindUndoPos(chaindb, pindex->pos.nFile, pos, ::GetSerializeSize(blockundo, SER_DISK, CLIENT_VERSION) + 8))\n             return error(\"ConnectBlock() : FindUndoPos failed\");\n         if (!blockundo.WriteToDisk(pos))\n             return error(\"ConnectBlock() : CBlockUndo::WriteToDisk failed\");\n-        pindex->nUndoPos = pos.nPos;\n-    }\n \n-    // Update block index on disk without changing it in memory.\n-    // The memory index structure will be changed after the db commits.\n-    if (pindex->pprev)\n-    {\n-        CDiskBlockIndex blockindexPrev(pindex->pprev);\n-        blockindexPrev.hashNext = pindex->GetBlockHash();\n-        if (!txdb.WriteBlockIndex(blockindexPrev))\n+        // update nUndoPos in block index\n+        pindex->nUndoPos = pos.nPos + 1;\n+        CDiskBlockIndex blockindex(pindex);\n+        if (!chaindb.WriteBlockIndex(blockindex))\n             return error(\"ConnectBlock() : WriteBlockIndex failed\");\n     }\n \n+    // add this block to the view's blockchain\n+    if (!view.SetBestBlock(pindex))\n+        return false;\n+\n     // Watch for transactions paying to me\n     BOOST_FOREACH(CTransaction& tx, vtx)\n         SyncWithWallets(tx, this, true);\n \n     return true;\n }\n \n-bool static Reorganize(CTxDB& txdb, CBlockIndex* pindexNew)\n+bool CBlock::SetBestChain(CBlockIndex* pindexNew)\n {\n-    printf(\"REORGANIZE\\n\");\n+    // if this functions exits prematurely, the transaction is aborted\n+    CCoinsDB coinsdb;\n+    if (!coinsdb.TxnBegin())\n+        return error(\"SetBestChain() : TxnBegin failed\");\n+\n+    // special case for attaching the genesis block\n+    // note that no ConnectBlock is called, so its coinbase output is non-spendable\n+    if (pindexGenesisBlock == NULL && pindexNew->GetBlockHash() == hashGenesisBlock)\n+    {\n+        coinsdb.WriteHashBestChain(pindexNew->GetBlockHash());\n+        if (!coinsdb.TxnCommit())\n+            return error(\"SetBestChain() : TxnCommit failed\");\n+        pindexGenesisBlock = pindexNew;\n+        pindexBest = pindexNew;\n+        hashBestChain = pindexNew->GetBlockHash();\n+        nBestHeight = pindexBest->nHeight;\n+        bnBestChainWork = pindexNew->bnChainWork;\n+        return true;\n+    }\n \n-    // Find the fork\n-    CBlockIndex* pfork = pindexBest;\n+    // create cached view to the coins database\n+    CCoinsViewDB viewDB(coinsdb);\n+    CCoinsViewCache view(viewDB);\n+\n+    // Find the fork (typically, there is none)\n+    CBlockIndex* pfork = view.GetBestBlock();\n     CBlockIndex* plonger = pindexNew;\n     while (pfork != plonger)\n     {\n         while (plonger->nHeight > pfork->nHeight)\n             if (!(plonger = plonger->pprev))\n-                return error(\"Reorganize() : plonger->pprev is null\");\n+                return error(\"SetBestChain() : plonger->pprev is null\");\n         if (pfork == plonger)\n             break;\n         if (!(pfork = pfork->pprev))\n-            return error(\"Reorganize() : pfork->pprev is null\");\n+            return error(\"SetBestChain() : pfork->pprev is null\");\n     }\n \n-    // List of what to disconnect\n+    // List of what to disconnect (typically nothing)\n     vector<CBlockIndex*> vDisconnect;\n-    for (CBlockIndex* pindex = pindexBest; pindex != pfork; pindex = pindex->pprev)\n+    for (CBlockIndex* pindex = view.GetBestBlock(); pindex != pfork; pindex = pindex->pprev)\n         vDisconnect.push_back(pindex);\n \n-    // List of what to connect\n+    // List of what to connect (typically only pindexNew)\n     vector<CBlockIndex*> vConnect;\n     for (CBlockIndex* pindex = pindexNew; pindex != pfork; pindex = pindex->pprev)\n         vConnect.push_back(pindex);\n     reverse(vConnect.begin(), vConnect.end());\n \n-    printf(\"REORGANIZE: Disconnect %\"PRIszu\" blocks; %s..%s\\n\", vDisconnect.size(), pfork->GetBlockHash().ToString().substr(0,20).c_str(), pindexBest->GetBlockHash().ToString().substr(0,20).c_str());\n-    printf(\"REORGANIZE: Connect %\"PRIszu\" blocks; %s..%s\\n\", vConnect.size(), pfork->GetBlockHash().ToString().substr(0,20).c_str(), pindexNew->GetBlockHash().ToString().substr(0,20).c_str());\n+    if (vDisconnect.size() > 0) {\n+        printf(\"REORGANIZE: Disconnect %\"PRIszu\" blocks; %s..%s\\n\", vDisconnect.size(), pfork->GetBlockHash().ToString().substr(0,20).c_str(), pindexBest->GetBlockHash().ToString().substr(0,20).c_str());\n+        printf(\"REORGANIZE: Connect %\"PRIszu\" blocks; %s..%s\\n\", vConnect.size(), pfork->GetBlockHash().ToString().substr(0,20).c_str(), pindexNew->GetBlockHash().ToString().substr(0,20).c_str());\n+    }\n \n     // Disconnect shorter branch\n     vector<CTransaction> vResurrect;\n-    BOOST_FOREACH(CBlockIndex* pindex, vDisconnect)\n-    {\n+    BOOST_FOREACH(CBlockIndex* pindex, vDisconnect) {\n         CBlock block;\n         if (!block.ReadFromDisk(pindex))\n-            return error(\"Reorganize() : ReadFromDisk for disconnect failed\");\n-        if (!block.DisconnectBlock(txdb, pindex))\n-            return error(\"Reorganize() : DisconnectBlock %s failed\", pindex->GetBlockHash().ToString().substr(0,20).c_str());\n+            return error(\"SetBestBlock() : ReadFromDisk for disconnect failed\");\n+        if (!block.DisconnectBlock(pindex, view))\n+            return error(\"SetBestBlock() : DisconnectBlock %s failed\", pindex->GetBlockHash().ToString().substr(0,20).c_str());\n \n         // Queue memory transactions to resurrect\n         BOOST_FOREACH(const CTransaction& tx, block.vtx)\n@@ -1587,28 +1636,35 @@ bool static Reorganize(CTxDB& txdb, CBlockIndex* pindexNew)\n \n     // Connect longer branch\n     vector<CTransaction> vDelete;\n-    for (unsigned int i = 0; i < vConnect.size(); i++)\n-    {\n-        CBlockIndex* pindex = vConnect[i];\n+    BOOST_FOREACH(CBlockIndex *pindex, vConnect) {\n         CBlock block;\n-        if (!block.ReadFromDisk(pindex))\n-            return error(\"Reorganize() : ReadFromDisk for connect failed\");\n-        if (!block.ConnectBlock(txdb, pindex))\n-        {\n-            // Invalid block\n-            return error(\"Reorganize() : ConnectBlock %s failed\", pindex->GetBlockHash().ToString().substr(0,20).c_str());\n+        CBlock *pblock;\n+        if (pindex == pindexNew) // connecting *this block\n+            pblock = this;\n+        else { // other block; read it from disk\n+            if (!block.ReadFromDisk(pindex))\n+                return error(\"SetBestBlock() : ReadFromDisk for connect failed\");\n+            pblock = &block;\n+        }\n+        if (!pblock->ConnectBlock(pindex, view)) {\n+            InvalidChainFound(pindexNew);\n+            return error(\"SetBestBlock() : ConnectBlock %s failed\", pindex->GetBlockHash().ToString().substr(0,20).c_str());\n         }\n \n         // Queue memory transactions to delete\n-        BOOST_FOREACH(const CTransaction& tx, block.vtx)\n+        BOOST_FOREACH(const CTransaction& tx, pblock->vtx)\n             vDelete.push_back(tx);\n     }\n-    if (!txdb.WriteHashBestChain(pindexNew->GetBlockHash()))\n-        return error(\"Reorganize() : WriteHashBestChain failed\");\n \n     // Make sure it's successfully written to disk before changing memory structure\n-    if (!txdb.TxnCommit())\n-        return error(\"Reorganize() : TxnCommit failed\");\n+    if (!view.Flush())\n+        return error(\"SetBestBlock() : failed to write coin changes\");\n+    if (!coinsdb.TxnCommit())\n+        return error(\"SetBestBlock() : TxnCommit failed\");\n+    coinsdb.Close();\n+\n+    // At this point, all changes have been done to the database.\n+    // Proceed by updating the memory structures.\n \n     // Disconnect shorter branch\n     BOOST_FOREACH(CBlockIndex* pindex, vDisconnect)\n@@ -1622,108 +1678,12 @@ bool static Reorganize(CTxDB& txdb, CBlockIndex* pindexNew)\n \n     // Resurrect memory transactions that were in the disconnected branch\n     BOOST_FOREACH(CTransaction& tx, vResurrect)\n-        tx.AcceptToMemoryPool(txdb, false);\n+        tx.AcceptToMemoryPool(coinsdb, false);\n \n     // Delete redundant memory transactions that are in the connected branch\n     BOOST_FOREACH(CTransaction& tx, vDelete)\n         mempool.remove(tx);\n \n-    printf(\"REORGANIZE: done\\n\");\n-\n-    return true;\n-}\n-\n-\n-// Called from inside SetBestChain: attaches a block to the new best chain being built\n-bool CBlock::SetBestChainInner(CTxDB& txdb, CBlockIndex *pindexNew)\n-{\n-    uint256 hash = GetHash();\n-\n-    // Adding to current best branch\n-    if (!ConnectBlock(txdb, pindexNew) || !txdb.WriteHashBestChain(hash))\n-    {\n-        txdb.TxnAbort();\n-        InvalidChainFound(pindexNew);\n-        return false;\n-    }\n-    if (!txdb.TxnCommit())\n-        return error(\"SetBestChain() : TxnCommit failed\");\n-\n-    // Add to current best branch\n-    pindexNew->pprev->pnext = pindexNew;\n-\n-    // Delete redundant memory transactions\n-    BOOST_FOREACH(CTransaction& tx, vtx)\n-        mempool.remove(tx);\n-\n-    return true;\n-}\n-\n-bool CBlock::SetBestChain(CTxDB& txdb, CBlockIndex* pindexNew)\n-{\n-    uint256 hash = GetHash();\n-\n-    if (!txdb.TxnBegin())\n-        return error(\"SetBestChain() : TxnBegin failed\");\n-\n-    if (pindexGenesisBlock == NULL && hash == hashGenesisBlock)\n-    {\n-        txdb.WriteHashBestChain(hash);\n-        if (!txdb.TxnCommit())\n-            return error(\"SetBestChain() : TxnCommit failed\");\n-        pindexGenesisBlock = pindexNew;\n-    }\n-    else if (hashPrevBlock == hashBestChain)\n-    {\n-        if (!SetBestChainInner(txdb, pindexNew))\n-            return error(\"SetBestChain() : SetBestChainInner failed\");\n-    }\n-    else\n-    {\n-        // the first block in the new chain that will cause it to become the new best chain\n-        CBlockIndex *pindexIntermediate = pindexNew;\n-\n-        // list of blocks that need to be connected afterwards\n-        std::vector<CBlockIndex*> vpindexSecondary;\n-\n-        // Reorganize is costly in terms of db load, as it works in a single db transaction.\n-        // Try to limit how much needs to be done inside\n-        while (pindexIntermediate->pprev && pindexIntermediate->pprev->bnChainWork > pindexBest->bnChainWork)\n-        {\n-            vpindexSecondary.push_back(pindexIntermediate);\n-            pindexIntermediate = pindexIntermediate->pprev;\n-        }\n-\n-        if (!vpindexSecondary.empty())\n-            printf(\"Postponing %\"PRIszu\" reconnects\\n\", vpindexSecondary.size());\n-\n-        // Switch to new best branch\n-        if (!Reorganize(txdb, pindexIntermediate))\n-        {\n-            txdb.TxnAbort();\n-            InvalidChainFound(pindexNew);\n-            return error(\"SetBestChain() : Reorganize failed\");\n-        }\n-\n-        // Connect further blocks\n-        BOOST_REVERSE_FOREACH(CBlockIndex *pindex, vpindexSecondary)\n-        {\n-            CBlock block;\n-            if (!block.ReadFromDisk(pindex))\n-            {\n-                printf(\"SetBestChain() : ReadFromDisk failed\\n\");\n-                break;\n-            }\n-            if (!txdb.TxnBegin()) {\n-                printf(\"SetBestChain() : TxnBegin 2 failed\\n\");\n-                break;\n-            }\n-            // errors now are not fatal, we still did a reorganisation to a new chain in a valid way\n-            if (!block.SetBestChainInner(txdb, pindex))\n-                break;\n-        }\n-    }\n-\n     // Update best block in wallet (so we can detect restored wallets)\n     bool fIsInitialDownload = IsInitialBlockDownload();\n     if (!fIsInitialDownload)\n@@ -1733,7 +1693,7 @@ bool CBlock::SetBestChain(CTxDB& txdb, CBlockIndex* pindexNew)\n     }\n \n     // New best block\n-    hashBestChain = hash;\n+    hashBestChain = pindexNew->GetBlockHash();\n     pindexBest = pindexNew;\n     pblockindexFBBHLast = NULL;\n     nBestHeight = pindexBest->nHeight;\n@@ -1797,19 +1757,19 @@ bool CBlock::AddToBlockIndex(const CDiskBlockPos &pos)\n     pindexNew->pos = pos;\n     pindexNew->nUndoPos = 0;\n \n-    CTxDB txdb;\n-    if (!txdb.TxnBegin())\n+    CChainDB chaindb;\n+    if (!chaindb.TxnBegin())\n         return false;\n-    txdb.WriteBlockIndex(CDiskBlockIndex(pindexNew));\n-    if (!txdb.TxnCommit())\n+    chaindb.WriteBlockIndex(CDiskBlockIndex(pindexNew));\n+    if (!chaindb.TxnCommit())\n         return false;\n \n     // New best\n-    if (pindexNew->bnChainWork > bnBestChainWork)\n-        if (!SetBestChain(txdb, pindexNew))\n-            return false;\n-\n-    txdb.Close();\n+    if (pindexNew->bnChainWork > bnBestChainWork) {\n+        if (!IsInitialBlockDownload() || (pindexNew->nHeight % 1) == 0)\n+            if (!SetBestChain(pindexNew))\n+                return false;\n+    }\n \n     if (pindexNew == pindexBest)\n     {\n@@ -1825,17 +1785,23 @@ bool CBlock::AddToBlockIndex(const CDiskBlockPos &pos)\n \n \n \n-bool FindBlockPos(CTxDB &txdb, CDiskBlockPos &pos, unsigned int nAddSize, unsigned int nHeight, uint64 nTime)\n+bool FindBlockPos(CChainDB &chaindb, CDiskBlockPos &pos, unsigned int nAddSize, unsigned int nHeight, uint64 nTime)\n {\n     bool fUpdatedLast = false;\n \n     LOCK(cs_LastBlockFile);\n \n     while (infoLastBlockFile.nSize + nAddSize >= MAX_BLOCKFILE_SIZE) {\n         printf(\"Leaving block file %i: %s\\n\", nLastBlockFile, infoLastBlockFile.ToString().c_str());\n+        FILE *file = OpenBlockFile(pos);\n+        FileCommit(file);\n+        fclose(file);\n+        file = OpenUndoFile(pos);\n+        FileCommit(file);\n+        fclose(file);\n         nLastBlockFile++;\n         infoLastBlockFile.SetNull();\n-        txdb.ReadBlockFileInfo(nLastBlockFile, infoLastBlockFile); // check whether data for the new file somehow already exist; can fail just fine\n+        chaindb.ReadBlockFileInfo(nLastBlockFile, infoLastBlockFile); // check whether data for the new file somehow already exist; can fail just fine\n         fUpdatedLast = true;\n     }\n \n@@ -1855,15 +1821,15 @@ bool FindBlockPos(CTxDB &txdb, CDiskBlockPos &pos, unsigned int nAddSize, unsign\n         fclose(file);\n     }\n \n-    if (!txdb.WriteBlockFileInfo(nLastBlockFile, infoLastBlockFile))\n+    if (!chaindb.WriteBlockFileInfo(nLastBlockFile, infoLastBlockFile))\n         return error(\"FindBlockPos() : cannot write updated block info\");\n     if (fUpdatedLast)\n-        txdb.WriteLastBlockFile(nLastBlockFile);\n+        chaindb.WriteLastBlockFile(nLastBlockFile);\n \n     return true;\n }\n \n-bool FindUndoPos(CTxDB &txdb, int nFile, CDiskBlockPos &pos, unsigned int nAddSize)\n+bool FindUndoPos(CChainDB &chaindb, int nFile, CDiskBlockPos &pos, unsigned int nAddSize)\n {\n     pos.nFile = nFile;\n \n@@ -1873,15 +1839,15 @@ bool FindUndoPos(CTxDB &txdb, int nFile, CDiskBlockPos &pos, unsigned int nAddSi\n     if (nFile == nLastBlockFile) {\n         pos.nPos = infoLastBlockFile.nUndoSize;\n         nNewSize = (infoLastBlockFile.nUndoSize += nAddSize);\n-        if (!txdb.WriteBlockFileInfo(nLastBlockFile, infoLastBlockFile))\n+        if (!chaindb.WriteBlockFileInfo(nLastBlockFile, infoLastBlockFile))\n             return error(\"FindUndoPos() : cannot write updated block info\");\n     } else {\n         CBlockFileInfo info;\n-        if (!txdb.ReadBlockFileInfo(nFile, info))\n+        if (!chaindb.ReadBlockFileInfo(nFile, info))\n             return error(\"FindUndoPos() : cannot read block info\");\n         pos.nPos = info.nUndoSize;\n         nNewSize = (info.nUndoSize += nAddSize);\n-        if (!txdb.WriteBlockFileInfo(nFile, info))\n+        if (!chaindb.WriteBlockFileInfo(nFile, info))\n             return error(\"FindUndoPos() : cannot write updated block info\");\n     }\n \n@@ -2013,8 +1979,8 @@ bool CBlock::AcceptBlock()\n         return error(\"AcceptBlock() : out of disk space\");\n     CDiskBlockPos blockPos;\n     {\n-        CTxDB txdb;\n-        if (!FindBlockPos(txdb, blockPos, nBlockSize+8, nHeight, nTime))\n+        CChainDB chaindb;\n+        if (!FindBlockPos(chaindb, blockPos, nBlockSize+8, nHeight, nTime))\n             return error(\"AcceptBlock() : FindBlockPos failed\");\n     }\n     if (!WriteToDisk(blockPos))\n@@ -2159,15 +2125,17 @@ int nLastBlockFile = 0;\n \n FILE* OpenDiskFile(const CDiskBlockPos &pos, const char *prefix, bool fReadOnly)\n {\n-    if (pos.IsNull() || pos.IsMemPool())\n+    if (pos.IsNull())\n         return NULL;\n     boost::filesystem::path path = GetDataDir() / \"blocks\" / strprintf(\"%s%05u.dat\", prefix, pos.nFile);\n     boost::filesystem::create_directories(path.parent_path());\n     FILE* file = fopen(path.string().c_str(), \"rb+\");\n     if (!file && !fReadOnly)\n         file = fopen(path.string().c_str(), \"wb+\");\n-    if (!file)\n+    if (!file) {\n+        printf(\"Unable to open file %s\\n\", path.string().c_str());\n         return NULL;\n+    }\n     if (pos.nPos) {\n         if (fseek(file, pos.nPos, SEEK_SET)) {\n             printf(\"Unable to seek to position %u of %s\\n\", pos.nPos, path.string().c_str());\n@@ -2200,10 +2168,12 @@ bool LoadBlockIndex(bool fAllowNew)\n     //\n     // Load block index\n     //\n-    CTxDB txdb(\"cr\");\n-    if (!txdb.LoadBlockIndex())\n+    CChainDB chaindb(\"cr\");\n+    CCoinsDB coinsdb(\"cr\");\n+    if (!LoadBlockIndex(coinsdb, chaindb))\n         return false;\n-    txdb.Close();\n+    chaindb.Close();\n+    coinsdb.Close();\n \n     //\n     // Init with genesis block\n@@ -2256,8 +2226,8 @@ bool LoadBlockIndex(bool fAllowNew)\n         unsigned int nBlockSize = ::GetSerializeSize(block, SER_DISK, CLIENT_VERSION);\n         CDiskBlockPos blockPos;\n         {\n-            CTxDB txdb;\n-            if (!FindBlockPos(txdb, blockPos, nBlockSize+8, 0, block.nTime))\n+            CChainDB chaindb;\n+            if (!FindBlockPos(chaindb, blockPos, nBlockSize+8, 0, block.nTime))\n                 return error(\"AcceptBlock() : FindBlockPos failed\");\n         }\n         if (!block.WriteToDisk(blockPos))\n@@ -2316,7 +2286,7 @@ void PrintBlockTree()\n         // print item\n         CBlock block;\n         block.ReadFromDisk(pindex);\n-        printf(\"%d (blk%05u.dat:0x%lx)  %s  tx %\"PRIszu\"\",\n+        printf(\"%d (blk%05u.dat:0x%x)  %s  tx %\"PRIszu\"\",\n             pindex->nHeight,\n             pindex->GetBlockPos().nFile, pindex->GetBlockPos().nPos,\n             DateTimeStrFormat(\"%x %H:%M:%S\", block.GetBlockTime()).c_str(),\n@@ -2522,22 +2492,20 @@ string GetWarnings(string strFor)\n //\n \n \n-bool static AlreadyHave(CTxDB& txdb, const CInv& inv)\n+bool static AlreadyHave(CCoinsDB &coinsdb, const CInv& inv)\n {\n     switch (inv.type)\n     {\n     case MSG_TX:\n         {\n-        bool txInMap = false;\n+            bool txInMap = false;\n             {\n-            LOCK(mempool.cs);\n-            txInMap = (mempool.exists(inv.hash));\n+                LOCK(mempool.cs);\n+                txInMap = mempool.exists(inv.hash);\n             }\n-        return txInMap ||\n-               mapOrphanTransactions.count(inv.hash) ||\n-               txdb.ContainsTx(inv.hash);\n+            return txInMap || mapOrphanTransactions.count(inv.hash) ||\n+                coinsdb.HaveCoins(inv.hash);\n         }\n-\n     case MSG_BLOCK:\n         return mapBlockIndex.count(inv.hash) ||\n                mapOrphanBlocks.count(inv.hash);\n@@ -2780,7 +2748,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n                 break;\n             }\n         }\n-        CTxDB txdb(\"r\");\n+        CCoinsDB coinsdb(\"r\");\n         for (unsigned int nInv = 0; nInv < vInv.size(); nInv++)\n         {\n             const CInv &inv = vInv[nInv];\n@@ -2789,7 +2757,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n                 return true;\n             pfrom->AddInventoryKnown(inv);\n \n-            bool fAlreadyHave = AlreadyHave(txdb, inv);\n+            bool fAlreadyHave = AlreadyHave(coinsdb, inv);\n             if (fDebug)\n                 printf(\"  got inventory: %s  %s\\n\", inv.ToString().c_str(), fAlreadyHave ? \"have\" : \"new\");\n \n@@ -2961,15 +2929,15 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         vector<uint256> vWorkQueue;\n         vector<uint256> vEraseQueue;\n         CDataStream vMsg(vRecv);\n-        CTxDB txdb(\"r\");\n+        CCoinsDB coinsdb(\"r\");\n         CTransaction tx;\n         vRecv >> tx;\n \n         CInv inv(MSG_TX, tx.GetHash());\n         pfrom->AddInventoryKnown(inv);\n \n         bool fMissingInputs = false;\n-        if (tx.AcceptToMemoryPool(txdb, true, &fMissingInputs))\n+        if (tx.AcceptToMemoryPool(coinsdb, true, &fMissingInputs))\n         {\n             SyncWithWallets(tx, NULL, true);\n             RelayMessage(inv, vMsg);\n@@ -2991,7 +2959,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n                     CInv inv(MSG_TX, tx.GetHash());\n                     bool fMissingInputs2 = false;\n \n-                    if (tx.AcceptToMemoryPool(txdb, true, &fMissingInputs2))\n+                    if (tx.AcceptToMemoryPool(coinsdb, true, &fMissingInputs2))\n                     {\n                         printf(\"   accepted orphan tx %s\\n\", inv.hash.ToString().substr(0,10).c_str());\n                         SyncWithWallets(tx, NULL, true);\n@@ -3439,11 +3407,11 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n         //\n         vector<CInv> vGetData;\n         int64 nNow = GetTime() * 1000000;\n-        CTxDB txdb(\"r\");\n+        CCoinsDB coinsdb(\"r\");\n         while (!pto->mapAskFor.empty() && (*pto->mapAskFor.begin()).first <= nNow)\n         {\n             const CInv& inv = (*pto->mapAskFor.begin()).second;\n-            if (!AlreadyHave(txdb, inv))\n+            if (!AlreadyHave(coinsdb, inv))\n             {\n                 if (fDebugNet)\n                     printf(\"sending getdata: %s\\n\", inv.ToString().c_str());\n@@ -3653,7 +3621,9 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n     int64 nFees = 0;\n     {\n         LOCK2(cs_main, mempool.cs);\n-        CTxDB txdb(\"r\");\n+        CCoinsDB coinsdb(\"r\");\n+        CCoinsViewDB viewdb(coinsdb);\n+        CCoinsViewCache view(viewdb);\n \n         // Priority order to process transactions\n         list<COrphan> vOrphan; // list memory doesn't move\n@@ -3675,9 +3645,8 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n             BOOST_FOREACH(const CTxIn& txin, tx.vin)\n             {\n                 // Read prev transaction\n-                CTransaction txPrev;\n-                CTxIndex txindex;\n-                if (!txPrev.ReadFromDisk(txdb, txin.prevout, txindex))\n+                CCoins coins;\n+                if (!view.GetCoins(txin.prevout.hash, coins))\n                 {\n                     // This should never happen; all transactions in the memory\n                     // pool should connect to either transactions in the chain\n@@ -3704,10 +3673,12 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n                     nTotalIn += mempool.mapTx[txin.prevout.hash].vout[txin.prevout.n].nValue;\n                     continue;\n                 }\n-                int64 nValueIn = txPrev.vout[txin.prevout.n].nValue;\n+\n+                int64 nValueIn = coins.vout[txin.prevout.n].nValue;\n                 nTotalIn += nValueIn;\n \n-                int nConf = txindex.GetDepthInMainChain();\n+                int nConf = pindexPrev->nHeight - coins.nHeight;\n+\n                 dPriority += (double)nValueIn * nConf;\n             }\n             if (fMissingInputs) continue;\n@@ -3731,7 +3702,6 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n         }\n \n         // Collect transactions into block\n-        map<uint256, CTxIndex> mapTestPool;\n         uint64 nBlockSize = 1000;\n         uint64 nBlockTx = 0;\n         int nBlockSigOps = 100;\n@@ -3750,6 +3720,9 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n             std::pop_heap(vecPriority.begin(), vecPriority.end(), comparer);\n             vecPriority.pop_back();\n \n+            // second layer cached modifications just for this transaction\n+            CCoinsViewCache viewTemp(view, true);\n+\n             // Size limits\n             unsigned int nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n             if (nBlockSize + nTxSize >= nBlockMaxSize)\n@@ -3774,24 +3747,21 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n                 std::make_heap(vecPriority.begin(), vecPriority.end(), comparer);\n             }\n \n-            // Connecting shouldn't fail due to dependency on other memory pool transactions\n-            // because we're already processing them in order of dependency\n-            map<uint256, CTxIndex> mapTestPoolTmp(mapTestPool);\n-            MapPrevTx mapInputs;\n-            bool fInvalid;\n-            if (!tx.FetchInputs(txdb, mapTestPoolTmp, false, true, mapInputs, fInvalid))\n+            if (!tx.CheckInputs(viewTemp, CS_ALWAYS, true, false))\n                 continue;\n \n-            int64 nTxFees = tx.GetValueIn(mapInputs)-tx.GetValueOut();\n+            int64 nTxFees = tx.GetValueIn(viewTemp)-tx.GetValueOut();\n \n-            nTxSigOps += tx.GetP2SHSigOpCount(mapInputs);\n+            nTxSigOps += tx.GetP2SHSigOpCount(viewTemp);\n             if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)\n                 continue;\n \n-            if (!tx.ConnectInputs(mapInputs, mapTestPoolTmp, CDiskTxPos(true), pindexPrev, false, true))\n+            CTxUndo txundo;\n+            if (!tx.UpdateCoins(viewTemp, txundo, pindexPrev->nHeight+1))\n                 continue;\n-            mapTestPoolTmp[tx.GetHash()] = CTxIndex(CDiskTxPos(true), tx.vout.size());\n-            swap(mapTestPool, mapTestPoolTmp);\n+\n+            // push changes from the second layer cache to the first one\n+            viewTemp.Flush();\n \n             // Added\n             pblock->vtx.push_back(tx);\n@@ -3829,19 +3799,20 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n         nLastBlockSize = nBlockSize;\n         printf(\"CreateNewBlock(): total size %\"PRI64u\"\\n\", nBlockSize);\n \n-    pblock->vtx[0].vout[0].nValue = GetBlockValue(pindexPrev->nHeight+1, nFees);\n-\n-    // Fill in header\n-    pblock->hashPrevBlock  = pindexPrev->GetBlockHash();\n-    pblock->UpdateTime(pindexPrev);\n-    pblock->nBits          = GetNextWorkRequired(pindexPrev, pblock.get());\n-    pblock->nNonce         = 0;\n+        pblock->vtx[0].vout[0].nValue = GetBlockValue(pindexPrev->nHeight+1, nFees);\n \n+        // Fill in header\n+        pblock->hashPrevBlock  = pindexPrev->GetBlockHash();\n+        pblock->UpdateTime(pindexPrev);\n+        pblock->nBits          = GetNextWorkRequired(pindexPrev, pblock.get());\n+        pblock->nNonce         = 0;\n         pblock->vtx[0].vin[0].scriptSig = scriptDummy;\n+\n         CBlockIndex indexDummy(*pblock);\n         indexDummy.pprev = pindexPrev;\n         indexDummy.nHeight = pindexPrev->nHeight + 1;\n-        if (!pblock->ConnectBlock(txdb, &indexDummy, true))\n+        CCoinsViewCache viewNew(viewdb);\n+        if (!pblock->ConnectBlock(&indexDummy, viewNew, true))\n             throw std::runtime_error(\"CreateNewBlock() : ConnectBlock failed\");\n     }\n "
      },
      {
        "sha": "a57fadac7879a71611bdc6c52032a3a33ad48c77",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 146,
        "deletions": 202,
        "changes": 348,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/60dc5e886091e0e64678db4dd66ecd66434ca66c/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/60dc5e886091e0e64678db4dd66ecd66434ca66c/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=60dc5e886091e0e64678db4dd66ecd66434ca66c",
        "patch": "@@ -31,6 +31,7 @@ static const unsigned int MAX_INV_SZ = 50000;\n static const unsigned int MAX_BLOCKFILE_SIZE = 0x8000000; // 128 MiB\n static const unsigned int BLOCKFILE_CHUNK_SIZE = 0x1000000; // 16 MiB\n static const unsigned int UNDOFILE_CHUNK_SIZE = 0x100000; // 1 MiB\n+static const unsigned int MEMPOOL_HEIGHT = 0x7FFFFFFF;\n static const int64 MIN_TX_FEE = 50000;\n static const int64 MIN_RELAY_TX_FEE = 10000;\n static const int64 MAX_MONEY = 21000000 * COIN;\n@@ -81,9 +82,12 @@ static const uint64 nMinDiskSpace = 52428800;\n \n \n class CReserveKey;\n-class CTxDB;\n-class CTxIndex;\n+class CCoinsDB;\n+class CChainDB;\n class CDiskBlockPos;\n+class CCoins;\n+class CTxUndo;\n+class CCoinsView;\n \n void RegisterWallet(CWallet* pwalletIn);\n void UnregisterWallet(CWallet* pwalletIn);\n@@ -108,8 +112,7 @@ unsigned int ComputeMinWork(unsigned int nBase, int64 nTime);\n int GetNumBlocksOfPeers();\n bool IsInitialBlockDownload();\n std::string GetWarnings(std::string strFor);\n-bool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock);\n-\n+bool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock, bool fAllowSlow = false);\n \n \n \n@@ -143,62 +146,8 @@ class CDiskBlockPos\n \n     void SetNull() { nFile = -1; nPos = 0; }\n     bool IsNull() const { return (nFile == -1); }\n-\n-    void SetMemPool() { nFile = -2; nPos = 0; }\n-    bool IsMemPool() const { return (nFile == -2); }\n };\n \n-/** Position on disk for a particular transaction. */\n-class CDiskTxPos\n-{\n-public:\n-    CDiskBlockPos blockPos;\n-    unsigned int nTxPos;\n-\n-    CDiskTxPos(bool fInMemPool = false)\n-    {\n-        SetNull();\n-        if (fInMemPool)\n-            blockPos.SetMemPool();\n-    }\n-\n-    CDiskTxPos(const CDiskBlockPos &block, unsigned int nTxPosIn) : blockPos(block), nTxPos(nTxPosIn) { }\n-\n-    IMPLEMENT_SERIALIZE( \n-        READWRITE(blockPos);\n-        READWRITE(VARINT(nTxPos));\n-    )\n-\n-    void SetNull() { blockPos.SetNull(); nTxPos = 0; }\n-    bool IsNull() const { return (nTxPos == 0); }\n-    bool IsMemPool() const { return blockPos.IsMemPool(); }\n-\n-    friend bool operator==(const CDiskTxPos& a, const CDiskTxPos& b)\n-    {\n-        return (a.blockPos  == b.blockPos &&\n-                a.nTxPos    == b.nTxPos);\n-    }\n-\n-    friend bool operator!=(const CDiskTxPos& a, const CDiskTxPos& b)\n-    {\n-        return !(a == b);\n-    }\n-\n-    std::string ToString() const\n-    {\n-        if (IsNull())\n-            return \"null\";\n-        else if (blockPos.IsMemPool())\n-            return \"mempool\";\n-        else\n-            return strprintf(\"\\\"blk%05i.dat:0x%x\\\"\", blockPos.nFile, nTxPos);\n-    }\n-\n-    void print() const\n-    {\n-        printf(\"%s\", ToString().c_str());\n-    }\n-};\n \n \n \n@@ -413,7 +362,13 @@ enum GetMinFee_mode\n     GMF_SEND,\n };\n \n-typedef std::map<uint256, std::pair<CTxIndex, CTransaction> > MapPrevTx;\n+// Modes for script/signature checking\n+enum CheckSig_mode\n+{\n+    CS_NEVER,             // never validate scripts\n+    CS_AFTER_CHECKPOINT,  // validate scripts after the last checkpoint\n+    CS_ALWAYS             // always validate scripts\n+};\n \n /** The basic transaction that is broadcasted on the network and contained in\n  * blocks.  A transaction can contain multiple inputs and outputs.\n@@ -525,7 +480,7 @@ class CTransaction\n         @return True if all inputs (scriptSigs) use only standard transaction forms\n         @see CTransaction::FetchInputs\n     */\n-    bool AreInputsStandard(const MapPrevTx& mapInputs) const;\n+    bool AreInputsStandard(CCoinsView& mapInputs) const;\n \n     /** Count ECDSA signature operations the old-fashioned (pre-0.6) way\n         @return number of sigops this transaction's outputs will produce when spent\n@@ -539,7 +494,7 @@ class CTransaction\n         @return maximum number of sigops required to validate this transaction's inputs\n         @see CTransaction::FetchInputs\n      */\n-    unsigned int GetP2SHSigOpCount(const MapPrevTx& mapInputs) const;\n+    unsigned int GetP2SHSigOpCount(CCoinsView& mapInputs) const;\n \n     /** Amount of bitcoins spent by this transaction.\n         @return sum of all outputs (note: does not include fees)\n@@ -564,7 +519,7 @@ class CTransaction\n         @return\tSum of value of all inputs (scriptSigs)\n         @see CTransaction::FetchInputs\n      */\n-    int64 GetValueIn(const MapPrevTx& mapInputs) const;\n+    int64 GetValueIn(CCoinsView& mapInputs) const;\n \n     static bool AllowFree(double dPriority)\n     {\n@@ -575,33 +530,6 @@ class CTransaction\n \n     int64 GetMinFee(unsigned int nBlockSize=1, bool fAllowFree=true, enum GetMinFee_mode mode=GMF_BLOCK) const;\n \n-    bool ReadFromDisk(CDiskTxPos pos, FILE** pfileRet=NULL)\n-    {\n-        CAutoFile filein = CAutoFile(OpenBlockFile(pos.blockPos, pfileRet==NULL), SER_DISK, CLIENT_VERSION);\n-        if (!filein)\n-            return error(\"CTransaction::ReadFromDisk() : OpenBlockFile failed\");\n-\n-        // Read transaction\n-        if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n-            return error(\"CTransaction::ReadFromDisk() : fseek failed\");\n-\n-        try {\n-            filein >> *this;\n-        }\n-        catch (std::exception &e) {\n-            return error(\"%s() : deserialize or I/O error\", __PRETTY_FUNCTION__);\n-        }\n-\n-        // Return file pointer\n-        if (pfileRet)\n-        {\n-            if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n-                return error(\"CTransaction::ReadFromDisk() : second fseek failed\");\n-            *pfileRet = filein.release();\n-        }\n-        return true;\n-    }\n-\n     friend bool operator==(const CTransaction& a, const CTransaction& b)\n     {\n         return (a.nVersion  == b.nVersion &&\n@@ -638,45 +566,27 @@ class CTransaction\n     }\n \n \n-    bool ReadFromDisk(CTxDB& txdb, COutPoint prevout, CTxIndex& txindexRet);\n-    bool ReadFromDisk(CTxDB& txdb, COutPoint prevout);\n-    bool ReadFromDisk(COutPoint prevout);\n-    bool DisconnectInputs(CTxDB& txdb);\n+    // Do all possible client-mode checks\n+    bool ClientCheckInputs() const;\n \n-    /** Fetch from memory and/or disk. inputsRet keys are transaction hashes.\n+    // Check whether all prevouts of this transaction are present in the UTXO set represented by view\n+    bool HaveInputs(CCoinsView &view) const;\n \n-     @param[in] txdb\tTransaction database\n-     @param[in] mapTestPool\tList of pending changes to the transaction index database\n-     @param[in] fBlock\tTrue if being called to add a new best-block to the chain\n-     @param[in] fMiner\tTrue if being called by CreateNewBlock\n-     @param[out] inputsRet\tPointers to this transaction's inputs\n-     @param[out] fInvalid\treturns true if transaction is invalid\n-     @return\tReturns true if all inputs are in txdb or mapTestPool\n-     */\n-    bool FetchInputs(CTxDB& txdb, const std::map<uint256, CTxIndex>& mapTestPool,\n-                     bool fBlock, bool fMiner, MapPrevTx& inputsRet, bool& fInvalid);\n-\n-    /** Sanity check previous transactions, then, if all checks succeed,\n-        mark them as spent by this transaction.\n-\n-        @param[in] inputs\tPrevious transactions (from FetchInputs)\n-        @param[out] mapTestPool\tKeeps track of inputs that need to be updated on disk\n-        @param[in] posThisTx\tPosition of this transaction on disk\n-        @param[in] pindexBlock\n-        @param[in] fBlock\ttrue if called from ConnectBlock\n-        @param[in] fMiner\ttrue if called from CreateNewBlock\n-        @param[in] fStrictPayToScriptHash\ttrue if fully validating p2sh transactions\n-        @return Returns true if all checks succeed\n-     */\n-    bool ConnectInputs(MapPrevTx inputs,\n-                       std::map<uint256, CTxIndex>& mapTestPool, const CDiskTxPos& posThisTx,\n-                       const CBlockIndex* pindexBlock, bool fBlock, bool fMiner, bool fStrictPayToScriptHash=true);\n-    bool ClientConnectInputs();\n+    // Check whether all inputs of this transaction are valid (no double spends, scripts & sigs, amounts)\n+    // This does not modify the UTXO set\n+    bool CheckInputs(CCoinsView &view, enum CheckSig_mode csmode, bool fStrictPayToScriptHash=true, bool fStrictEncodings=true) const;\n+\n+    // Apply the effects of this transaction on the UTXO set represented by view\n+    bool UpdateCoins(CCoinsView &view, CTxUndo &txundo, int nHeight) const;\n+\n+    // Context-independent validity checks\n     bool CheckTransaction() const;\n-    bool AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs=true, bool* pfMissingInputs=NULL);\n+\n+    // Try to accept this transaction into the memory pool\n+    bool AcceptToMemoryPool(CCoinsDB& coinsdb, bool fCheckInputs=true, bool* pfMissingInputs=NULL);\n \n protected:\n-    const CTxOut& GetOutputFor(const CTxIn& input, const MapPrevTx& inputs) const;\n+    static CTxOut GetOutputFor(const CTxIn& input, CCoinsView& mapInputs);\n };\n \n /** wrapper for CTxOut that provides a more compact serialization */\n@@ -752,6 +662,7 @@ class CTxInUndo\n class CTxUndo\n {\n public:\n+    // undo information for all txins\n     std::vector<CTxInUndo> vprevout;\n \n     IMPLEMENT_SERIALIZE(\n@@ -763,7 +674,7 @@ class CTxUndo\n class CBlockUndo\n {\n public:\n-    std::vector<CTxUndo> vtxundo;\n+    std::vector<CTxUndo> vtxundo; // for all but the coinbase\n \n     IMPLEMENT_SERIALIZE(\n         READWRITE(vtxundo);\n@@ -789,7 +700,7 @@ class CBlockUndo\n \n         // Flush stdio buffers and commit to disk before returning\n         fflush(fileout);\n-        if (!IsInitialBlockDownload() || (nBestHeight+1) % 500 == 0)\n+        if (!IsInitialBlockDownload())\n             FileCommit(fileout);\n \n         return true;\n@@ -1084,66 +995,16 @@ class CMerkleTx : public CTransaction\n     int GetDepthInMainChain() const { CBlockIndex *pindexRet; return GetDepthInMainChain(pindexRet); }\n     bool IsInMainChain() const { return GetDepthInMainChain() > 0; }\n     int GetBlocksToMaturity() const;\n-    bool AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs=true);\n+    bool AcceptToMemoryPool(CCoinsDB& coinsdb, bool fCheckInputs=true);\n     bool AcceptToMemoryPool();\n };\n \n \n \n \n-/**  A txdb record that contains the disk location of a transaction and the\n- * locations of transactions that spend its outputs.  vSpent is really only\n- * used as a flag, but having the location is very helpful for debugging.\n- */\n-class CTxIndex\n-{\n-public:\n-    CDiskTxPos pos;\n-    std::vector<CDiskTxPos> vSpent;\n \n-    CTxIndex()\n-    {\n-        SetNull();\n-    }\n \n-    CTxIndex(const CDiskTxPos& posIn, unsigned int nOutputs)\n-    {\n-        pos = posIn;\n-        vSpent.resize(nOutputs);\n-    }\n \n-    IMPLEMENT_SERIALIZE\n-    (\n-        if (!(nType & SER_GETHASH))\n-            READWRITE(nVersion);\n-        READWRITE(pos);\n-        READWRITE(vSpent);\n-    )\n-\n-    void SetNull()\n-    {\n-        pos.SetNull();\n-        vSpent.clear();\n-    }\n-\n-    bool IsNull()\n-    {\n-        return pos.IsNull();\n-    }\n-\n-    friend bool operator==(const CTxIndex& a, const CTxIndex& b)\n-    {\n-        return (a.pos    == b.pos &&\n-                a.vSpent == b.vSpent);\n-    }\n-\n-    friend bool operator!=(const CTxIndex& a, const CTxIndex& b)\n-    {\n-        return !(a == b);\n-    }\n-    int GetDepthInMainChain() const;\n-\n-};\n \n \n \n@@ -1155,9 +1016,6 @@ class CTxIndex\n  * to everyone and the block is added to the block chain.  The first transaction\n  * in the block is a special one that creates a new coin owned by the creator\n  * of the block.\n- *\n- * Blocks are appended to blk0001.dat files on disk.  Their location on disk\n- * is indexed by CBlockIndex objects in memory.\n  */\n class CBlock\n {\n@@ -1305,7 +1163,7 @@ class CBlock\n \n         // Flush stdio buffers and commit to disk before returning\n         fflush(fileout);\n-        if (!IsInitialBlockDownload() || (nBestHeight+1) % 500 == 0)\n+        if (!IsInitialBlockDownload())\n             FileCommit(fileout);\n \n         return true;\n@@ -1360,16 +1218,26 @@ class CBlock\n     }\n \n \n-    bool DisconnectBlock(CTxDB& txdb, CBlockIndex* pindex);\n-    bool ConnectBlock(CTxDB& txdb, CBlockIndex* pindex, bool fJustCheck=false);\n+    // Undo the effects of this block (with given index) on the UTXO set represented by coins\n+    bool DisconnectBlock(CBlockIndex *pindex, CCoinsView &coins);\n+\n+    // Apply the effects of this block (with given index) on the UTXO set represented by coins\n+    bool ConnectBlock(CBlockIndex *pindex, CCoinsView &coins, bool fJustCheck=false);\n+\n+    // Read a block from disk\n     bool ReadFromDisk(const CBlockIndex* pindex, bool fReadTransactions=true);\n-    bool SetBestChain(CTxDB& txdb, CBlockIndex* pindexNew);\n+\n+    // Make this block (with given index) the new tip of the active block chain\n+    bool SetBestChain(CBlockIndex* pindexNew);\n+\n+    // Add this block to the block index, and if necessary, switch the active block chain to this\n     bool AddToBlockIndex(const CDiskBlockPos &pos);\n+\n+    // Context-independent validity checks\n     bool CheckBlock(bool fCheckPOW=true, bool fCheckMerkleRoot=true) const;\n-    bool AcceptBlock();\n \n-private:\n-    bool SetBestChainInner(CTxDB& txdb, CBlockIndex *pindexNew);\n+    // Store block on disk\n+    bool AcceptBlock();\n };\n \n \n@@ -1412,7 +1280,7 @@ class CBlockFileInfo\n      }\n \n      std::string ToString() const {\n-         return strprintf(\"CBlockFileInfo(blocks=%u, size=%lu, heights=%u..%u, time=%s..%s)\", nBlocks, nSize, nHeightFirst, nHeightLast, DateTimeStrFormat(\"%Y-%m-%d\", nTimeFirst).c_str(), DateTimeStrFormat(\"%Y-%m-%d\", nTimeLast).c_str());\n+         return strprintf(\"CBlockFileInfo(blocks=%u, size=%u, heights=%u..%u, time=%s..%s)\", nBlocks, nSize, nHeightFirst, nHeightLast, DateTimeStrFormat(\"%Y-%m-%d\", nTimeFirst).c_str(), DateTimeStrFormat(\"%Y-%m-%d\", nTimeLast).c_str());\n      }\n \n      // update statistics (does not update nSize)\n@@ -1466,7 +1334,7 @@ class CBlockIndex\n         pnext = NULL;\n         nHeight = 0;\n         pos.SetNull();\n-        nUndoPos = (unsigned int)(-1);\n+        nUndoPos = 0;\n         bnChainWork = 0;\n \n         nVersion       = 0;\n@@ -1499,10 +1367,10 @@ class CBlockIndex\n \n     CDiskBlockPos GetUndoPos() const {\n         CDiskBlockPos ret = pos;\n-        if (nUndoPos == (unsigned int)(-1))\n+        if (nUndoPos == 0)\n             ret.SetNull();\n         else\n-            ret.nPos = nUndoPos;\n+            ret.nPos = nUndoPos - 1;\n         return ret;\n     }\n \n@@ -1604,26 +1472,20 @@ class CDiskBlockIndex : public CBlockIndex\n {\n public:\n     uint256 hashPrev;\n-    uint256 hashNext;\n \n-    CDiskBlockIndex()\n-    {\n+    CDiskBlockIndex() {\n         hashPrev = 0;\n-        hashNext = 0;\n     }\n \n-    explicit CDiskBlockIndex(CBlockIndex* pindex) : CBlockIndex(*pindex)\n-    {\n+    explicit CDiskBlockIndex(CBlockIndex* pindex) : CBlockIndex(*pindex) {\n         hashPrev = (pprev ? pprev->GetBlockHash() : 0);\n-        hashNext = (pnext ? pnext->GetBlockHash() : 0);\n     }\n \n     IMPLEMENT_SERIALIZE\n     (\n         if (!(nType & SER_GETHASH))\n             READWRITE(nVersion);\n \n-        READWRITE(hashNext);\n         READWRITE(nHeight);\n         READWRITE(pos);\n         READWRITE(nUndoPos);\n@@ -1654,10 +1516,9 @@ class CDiskBlockIndex : public CBlockIndex\n     {\n         std::string str = \"CDiskBlockIndex(\";\n         str += CBlockIndex::ToString();\n-        str += strprintf(\"\\n                hashBlock=%s, hashPrev=%s, hashNext=%s)\",\n+        str += strprintf(\"\\n                hashBlock=%s, hashPrev=%s)\",\n             GetBlockHash().ToString().c_str(),\n-            hashPrev.ToString().substr(0,20).c_str(),\n-            hashNext.ToString().substr(0,20).c_str());\n+            hashPrev.ToString().substr(0,20).c_str());\n         return str;\n     }\n \n@@ -1815,12 +1676,13 @@ class CTxMemPool\n     std::map<uint256, CTransaction> mapTx;\n     std::map<COutPoint, CInPoint> mapNextTx;\n \n-    bool accept(CTxDB& txdb, CTransaction &tx,\n+    bool accept(CCoinsDB& coinsdb, CTransaction &tx,\n                 bool fCheckInputs, bool* pfMissingInputs);\n     bool addUnchecked(const uint256& hash, CTransaction &tx);\n     bool remove(CTransaction &tx);\n     void clear();\n     void queryHashes(std::vector<uint256>& vtxid);\n+    void pruneSpent(const uint256& hash, CCoins &coins);\n \n     unsigned long size()\n     {\n@@ -1841,4 +1703,86 @@ class CTxMemPool\n \n extern CTxMemPool mempool;\n \n+/** Abstract view on the open txout dataset. */\n+class CCoinsView\n+{\n+public:\n+    // Retrieve the CCoins (unspent transaction outputs) for a given txid\n+    virtual bool GetCoins(uint256 txid, CCoins &coins);\n+\n+    // Modify the CCoins for a given txid\n+    virtual bool SetCoins(uint256 txid, const CCoins &coins);\n+\n+    // Just check whether we have data for a given txid.\n+    // This may (but cannot always) return true for fully spent transactions\n+    virtual bool HaveCoins(uint256 txid);\n+\n+    // Retrieve the block index whose state this CCoinsView currently represents\n+    virtual CBlockIndex *GetBestBlock();\n+\n+    // Modify the currently active block index\n+    virtual bool SetBestBlock(CBlockIndex *pindex);\n+};\n+\n+/** CCoinsView backed by another CCoinsView */\n+class CCoinsViewBacked : public CCoinsView\n+{\n+protected:\n+    CCoinsView *base;\n+\n+public:\n+    CCoinsViewBacked(CCoinsView &viewIn);\n+    bool GetCoins(uint256 txid, CCoins &coins);\n+    bool SetCoins(uint256 txid, const CCoins &coins);\n+    bool HaveCoins(uint256 txid);\n+    CBlockIndex *GetBestBlock();\n+    bool SetBestBlock(CBlockIndex *pindex);\n+    void SetBackend(CCoinsView &viewIn);\n+};\n+\n+\n+/** CCoinsView backed by a CCoinsDB */\n+class CCoinsViewDB : public CCoinsView\n+{\n+protected:\n+    CCoinsDB &db;\n+public:\n+    CCoinsViewDB(CCoinsDB &dbIn);\n+    bool GetCoins(uint256 txid, CCoins &coins);\n+    bool SetCoins(uint256 txid, const CCoins &coins);\n+    bool HaveCoins(uint256 txid);\n+    CBlockIndex *GetBestBlock();\n+    bool SetBestBlock(CBlockIndex *pindex);\n+};\n+\n+/** CCoinsView that adds a memory cache for transactions to another CCoinsView */\n+class CCoinsViewCache : public CCoinsViewBacked\n+{\n+protected:\n+    CBlockIndex *pindexTip;\n+    std::map<uint256,CCoins> cacheCoins;\n+\n+public:\n+    CCoinsViewCache(CCoinsView &baseIn, bool fDummy = false);\n+    bool GetCoins(uint256 txid, CCoins &coins);\n+    bool SetCoins(uint256 txid, const CCoins &coins);\n+    bool HaveCoins(uint256 txid);\n+    CBlockIndex *GetBestBlock();\n+    bool SetBestBlock(CBlockIndex *pindex);\n+    bool Flush();\n+};\n+\n+/** CCoinsView that brings transactions from a memorypool into view.\n+    It does not check for spendings by memory pool transactions. */\n+class CCoinsViewMemPool : public CCoinsViewBacked\n+{\n+protected:\n+    CTxMemPool &mempool;\n+\n+public:\n+    CCoinsViewMemPool(CCoinsView &baseIn, CTxMemPool &mempoolIn);\n+    bool GetCoins(uint256 txid, CCoins &coins);\n+    bool HaveCoins(uint256 txid);\n+};\n+\n #endif"
      },
      {
        "sha": "dc840b9f8d6c6d3bf9ebbb174641dfa734266caa",
        "filename": "src/qt/transactiondesc.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/60dc5e886091e0e64678db4dd66ecd66434ca66c/src/qt/transactiondesc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/60dc5e886091e0e64678db4dd66ecd66434ca66c/src/qt/transactiondesc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiondesc.cpp?ref=60dc5e886091e0e64678db4dd66ecd66434ca66c",
        "patch": "@@ -234,7 +234,8 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx)\n             strHTML += \"<br><b>\" + tr(\"Transaction\") + \":</b><br>\";\n             strHTML += GUIUtil::HtmlEscape(wtx.ToString(), true);\n \n-            CTxDB txdb(\"r\"); // To fetch source txouts\n+            CCoinsDB coindb(\"r\"); // To fetch source txouts\n+            CCoinsViewDB coins(coindb);\n \n             strHTML += \"<br><b>\" + tr(\"Inputs\") + \":</b>\";\n             strHTML += \"<ul>\";\n@@ -245,8 +246,8 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx)\n                 {\n                     COutPoint prevout = txin.prevout;\n \n-                    CTransaction prev;\n-                    if(txdb.ReadDiskTx(prevout.hash, prev))\n+                    CCoins prev;\n+                    if(coins.GetCoins(prevout.hash, prev))\n                     {\n                         if (prevout.n < prev.vout.size())\n                         {"
      },
      {
        "sha": "96518c6d8c23c652a9b3ad00b846b5113a920a34",
        "filename": "src/rpcmining.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 22,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/60dc5e886091e0e64678db4dd66ecd66434ca66c/src/rpcmining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/60dc5e886091e0e64678db4dd66ecd66434ca66c/src/rpcmining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcmining.cpp?ref=60dc5e886091e0e64678db4dd66ecd66434ca66c",
        "patch": "@@ -198,7 +198,7 @@ Value getwork(const Array& params, bool fHelp)\n \n Value getblocktemplate(const Array& params, bool fHelp)\n {\n-    if (fHelp || params.size() > 1)\n+    if (fHelp || params.size() != 1)\n         throw runtime_error(\n             \"getblocktemplate [params]\\n\"\n             \"Returns data needed to construct a block to work on:\\n\"\n@@ -281,7 +281,9 @@ Value getblocktemplate(const Array& params, bool fHelp)\n     Array transactions;\n     map<uint256, int64_t> setTxIndex;\n     int i = 0;\n-    CTxDB txdb(\"r\");\n+    CCoinsDB coindb(\"r\");\n+    CCoinsViewDB viewdb(coindb);\n+    CCoinsViewCache view(viewdb);\n     BOOST_FOREACH (CTransaction& tx, pblock->vtx)\n     {\n         uint256 txHash = tx.GetHash();\n@@ -298,25 +300,21 @@ Value getblocktemplate(const Array& params, bool fHelp)\n \n         entry.push_back(Pair(\"hash\", txHash.GetHex()));\n \n-        MapPrevTx mapInputs;\n-        map<uint256, CTxIndex> mapUnused;\n-        bool fInvalid = false;\n-        if (tx.FetchInputs(txdb, mapUnused, false, false, mapInputs, fInvalid))\n+        Array deps;\n+        BOOST_FOREACH (const CTxIn &in, tx.vin)\n         {\n-            entry.push_back(Pair(\"fee\", (int64_t)(tx.GetValueIn(mapInputs) - tx.GetValueOut())));\n-\n-            Array deps;\n-            BOOST_FOREACH (MapPrevTx::value_type& inp, mapInputs)\n-            {\n-                if (setTxIndex.count(inp.first))\n-                    deps.push_back(setTxIndex[inp.first]);\n-            }\n-            entry.push_back(Pair(\"depends\", deps));\n+            if (setTxIndex.count(in.prevout.hash))\n+                deps.push_back(setTxIndex[in.prevout.hash]);\n+        }\n+        entry.push_back(Pair(\"depends\", deps));\n \n-            int64_t nSigOps = tx.GetLegacySigOpCount();\n-            nSigOps += tx.GetP2SHSigOpCount(mapInputs);\n-            entry.push_back(Pair(\"sigops\", nSigOps));\n+        int64_t nSigOps = tx.GetLegacySigOpCount();\n+        if (tx.HaveInputs(view))\n+        {\n+            entry.push_back(Pair(\"fee\", (int64_t)(tx.GetValueIn(view) - tx.GetValueOut())));\n+            nSigOps += tx.GetP2SHSigOpCount(view);\n         }\n+        entry.push_back(Pair(\"sigops\", nSigOps));\n \n         transactions.push_back(entry);\n     }\n@@ -364,18 +362,17 @@ Value submitblock(const Array& params, bool fHelp)\n \n     vector<unsigned char> blockData(ParseHex(params[0].get_str()));\n     CDataStream ssBlock(blockData, SER_NETWORK, PROTOCOL_VERSION);\n-    CBlock block;\n+    CBlock pblock;\n     try {\n-        ssBlock >> block;\n+        ssBlock >> pblock;\n     }\n     catch (std::exception &e) {\n         throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Block decode failed\");\n     }\n \n-    bool fAccepted = ProcessBlock(NULL, &block);\n+    bool fAccepted = ProcessBlock(NULL, &pblock);\n     if (!fAccepted)\n         return \"rejected\";\n \n     return Value::null;\n }\n-"
      },
      {
        "sha": "c62898316c986ca890c8aa222d54662814886eb5",
        "filename": "src/rpcrawtransaction.cpp",
        "status": "modified",
        "additions": 43,
        "deletions": 44,
        "changes": 87,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/60dc5e886091e0e64678db4dd66ecd66434ca66c/src/rpcrawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/60dc5e886091e0e64678db4dd66ecd66434ca66c/src/rpcrawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcrawtransaction.cpp?ref=60dc5e886091e0e64678db4dd66ecd66434ca66c",
        "patch": "@@ -118,7 +118,7 @@ Value getrawtransaction(const Array& params, bool fHelp)\n \n     CTransaction tx;\n     uint256 hashBlock = 0;\n-    if (!GetTransaction(hash, tx, hashBlock))\n+    if (!GetTransaction(hash, tx, hashBlock, true))\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"No information available about transaction\");\n \n     CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n@@ -335,26 +335,22 @@ Value signrawtransaction(const Array& params, bool fHelp)\n     bool fComplete = true;\n \n     // Fetch previous transactions (inputs):\n-    map<COutPoint, CScript> mapPrevOut;\n-    for (unsigned int i = 0; i < mergedTx.vin.size(); i++)\n+    CCoinsView viewDummy;\n+    CCoinsViewCache view(viewDummy);\n     {\n-        CTransaction tempTx;\n-        MapPrevTx mapPrevTx;\n-        CTxDB txdb(\"r\");\n-        map<uint256, CTxIndex> unused;\n-        bool fInvalid;\n-\n-        // FetchInputs aborts on failure, so we go one at a time.\n-        tempTx.vin.push_back(mergedTx.vin[i]);\n-        tempTx.FetchInputs(txdb, unused, false, false, mapPrevTx, fInvalid);\n-\n-        // Copy results into mapPrevOut:\n-        BOOST_FOREACH(const CTxIn& txin, tempTx.vin)\n-        {\n+        LOCK(mempool.cs);\n+        CCoinsDB coinsdb(\"r\");\n+        CCoinsViewDB viewDB(coinsdb);\n+        CCoinsViewMemPool viewMempool(viewDB, mempool);\n+        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n+\n+        BOOST_FOREACH(const CTxIn& txin, mergedTx.vin) {\n             const uint256& prevHash = txin.prevout.hash;\n-            if (mapPrevTx.count(prevHash) && mapPrevTx[prevHash].second.vout.size()>txin.prevout.n)\n-                mapPrevOut[txin.prevout] = mapPrevTx[prevHash].second.vout[txin.prevout.n].scriptPubKey;\n+            CCoins coins;\n+            view.GetCoins(prevHash, coins); // this is certainly allowed to fail\n         }\n+\n+        view.SetBackend(viewDummy); // switch back to avoid locking db/mempool too long\n     }\n \n     // Add previous txouts given in the RPC call:\n@@ -386,20 +382,19 @@ Value signrawtransaction(const Array& params, bool fHelp)\n             vector<unsigned char> pkData(ParseHex(pkHex));\n             CScript scriptPubKey(pkData.begin(), pkData.end());\n \n-            COutPoint outpoint(txid, nOut);\n-            if (mapPrevOut.count(outpoint))\n-            {\n-                // Complain if scriptPubKey doesn't match\n-                if (mapPrevOut[outpoint] != scriptPubKey)\n-                {\n+            CCoins coins;\n+            if (view.GetCoins(txid, coins)) {\n+                if (coins.IsAvailable(nOut) && coins.vout[nOut].scriptPubKey != scriptPubKey) {\n                     string err(\"Previous output scriptPubKey mismatch:\\n\");\n-                    err = err + mapPrevOut[outpoint].ToString() + \"\\nvs:\\n\"+\n+                    err = err + coins.vout[nOut].scriptPubKey.ToString() + \"\\nvs:\\n\"+\n                         scriptPubKey.ToString();\n                     throw JSONRPCError(RPC_DESERIALIZATION_ERROR, err);\n                 }\n+                // what todo if txid is known, but the actual output isn't?\n             }\n-            else\n-                mapPrevOut[outpoint] = scriptPubKey;\n+            coins.vout[nOut].scriptPubKey = scriptPubKey;\n+            coins.vout[nOut].nValue = 0; // we don't know the actual output value\n+            view.SetCoins(txid, coins);\n         }\n     }\n \n@@ -452,12 +447,13 @@ Value signrawtransaction(const Array& params, bool fHelp)\n     for (unsigned int i = 0; i < mergedTx.vin.size(); i++)\n     {\n         CTxIn& txin = mergedTx.vin[i];\n-        if (mapPrevOut.count(txin.prevout) == 0)\n+        CCoins coins;\n+        if (!view.GetCoins(txin.prevout.hash, coins) || !coins.IsAvailable(txin.prevout.n))\n         {\n             fComplete = false;\n             continue;\n         }\n-        const CScript& prevPubKey = mapPrevOut[txin.prevout];\n+        const CScript& prevPubKey = coins.vout[txin.prevout.n].scriptPubKey;\n \n         txin.scriptSig.clear();\n         // Only sign SIGHASH_SINGLE if there's a corresponding output:\n@@ -505,24 +501,27 @@ Value sendrawtransaction(const Array& params, bool fHelp)\n     }\n     uint256 hashTx = tx.GetHash();\n \n-    // See if the transaction is already in a block\n-    // or in the memory pool:\n-    CTransaction existingTx;\n-    uint256 hashBlock = 0;\n-    if (GetTransaction(hashTx, existingTx, hashBlock))\n+    bool fHave = false;\n+    CCoins existingCoins;\n     {\n-        if (hashBlock != 0)\n-            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, string(\"transaction already in block \")+hashBlock.GetHex());\n+        CCoinsDB coinsdb(\"r\");\n+        {\n+            CCoinsViewDB coinsviewDB(coinsdb);\n+            CCoinsViewMemPool coinsview(coinsviewDB, mempool);\n+            fHave = coinsview.GetCoins(hashTx, existingCoins);\n+        }\n+        if (!fHave) {\n+            // push to local node\n+            if (!tx.AcceptToMemoryPool(coinsdb))\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX rejected\");\n+        }\n+    }\n+    if (fHave) {\n+        if (existingCoins.nHeight < 1000000000)\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"transaction already in block chain\");\n         // Not in block, but already in the memory pool; will drop\n         // through to re-relay it.\n-    }\n-    else\n-    {\n-        // push to local node\n-        CTxDB txdb(\"r\");\n-        if (!tx.AcceptToMemoryPool(txdb))\n-            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX rejected\");\n-\n+    } else {\n         SyncWithWallets(tx, NULL, true);\n     }\n     RelayMessage(CInv(MSG_TX, hashTx), tx);"
      },
      {
        "sha": "61112b17c0d21d486de847d78333a87652944e24",
        "filename": "src/script.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 4,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/60dc5e886091e0e64678db4dd66ecd66434ca66c/src/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/60dc5e886091e0e64678db4dd66ecd66434ca66c/src/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.cpp?ref=60dc5e886091e0e64678db4dd66ecd66434ca66c",
        "patch": "@@ -1719,17 +1719,14 @@ bool SignSignature(const CKeyStore &keystore, const CTransaction& txFrom, CTrans\n     return SignSignature(keystore, txout.scriptPubKey, txTo, nIn, nHashType);\n }\n \n-bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, bool fValidatePayToScriptHash, bool fStrictEncodings, int nHashType)\n+bool VerifySignature(const CCoins& txFrom, const CTransaction& txTo, unsigned int nIn, bool fValidatePayToScriptHash, bool fStrictEncodings, int nHashType)\n {\n     assert(nIn < txTo.vin.size());\n     const CTxIn& txin = txTo.vin[nIn];\n     if (txin.prevout.n >= txFrom.vout.size())\n         return false;\n     const CTxOut& txout = txFrom.vout[txin.prevout.n];\n \n-    if (txin.prevout.hash != txFrom.GetHash())\n-        return false;\n-\n     return VerifyScript(txin.scriptSig, txout.scriptPubKey, txTo, nIn, fValidatePayToScriptHash, fStrictEncodings, nHashType);\n }\n "
      },
      {
        "sha": "f9df587ca3f697e5a03f1469a46c2366c1b864fa",
        "filename": "src/script.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/60dc5e886091e0e64678db4dd66ecd66434ca66c/src/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/60dc5e886091e0e64678db4dd66ecd66434ca66c/src/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.h?ref=60dc5e886091e0e64678db4dd66ecd66434ca66c",
        "patch": "@@ -14,6 +14,7 @@\n #include \"keystore.h\"\n #include \"bignum.h\"\n \n+class CCoins;\n class CTransaction;\n \n /** Signature hash types/flags */\n@@ -667,7 +668,7 @@ bool SignSignature(const CKeyStore& keystore, const CScript& fromPubKey, CTransa\n bool SignSignature(const CKeyStore& keystore, const CTransaction& txFrom, CTransaction& txTo, unsigned int nIn, int nHashType=SIGHASH_ALL);\n bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n                   bool fValidatePayToScriptHash, bool fStrictEncodings, int nHashType);\n-bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, bool fValidatePayToScriptHash, bool fStrictEncodings, int nHashType);\n+bool VerifySignature(const CCoins& txFrom, const CTransaction& txTo, unsigned int nIn, bool fValidatePayToScriptHash, bool fStrictEncodings, int nHashType);\n \n // Given two sets of signatures for scriptPubKey, possibly with OP_0 placeholders,\n // combine them intelligently and return the result."
      },
      {
        "sha": "8235b0bda74b52df2c55af700893b50275e7d362",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/60dc5e886091e0e64678db4dd66ecd66434ca66c/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/60dc5e886091e0e64678db4dd66ecd66434ca66c/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=60dc5e886091e0e64678db4dd66ecd66434ca66c",
        "patch": "@@ -278,7 +278,7 @@ BOOST_AUTO_TEST_CASE(DoS_checkSig)\n     mst1 = boost::posix_time::microsec_clock::local_time();\n     for (unsigned int i = 0; i < 5; i++)\n         for (unsigned int j = 0; j < tx.vin.size(); j++)\n-            BOOST_CHECK(VerifySignature(orphans[j], tx, j, true, true, SIGHASH_ALL));\n+            BOOST_CHECK(VerifySignature(CCoins(orphans[j], MEMPOOL_HEIGHT), tx, j, true, true, SIGHASH_ALL));\n     mst2 = boost::posix_time::microsec_clock::local_time();\n     msdiff = mst2 - mst1;\n     long nManyValidate = msdiff.total_milliseconds();\n@@ -289,13 +289,13 @@ BOOST_AUTO_TEST_CASE(DoS_checkSig)\n     // Empty a signature, validation should fail:\n     CScript save = tx.vin[0].scriptSig;\n     tx.vin[0].scriptSig = CScript();\n-    BOOST_CHECK(!VerifySignature(orphans[0], tx, 0, true, true, SIGHASH_ALL));\n+    BOOST_CHECK(!VerifySignature(CCoins(orphans[0], MEMPOOL_HEIGHT), tx, 0, true, true, SIGHASH_ALL));\n     tx.vin[0].scriptSig = save;\n \n     // Swap signatures, validation should fail:\n     std::swap(tx.vin[0].scriptSig, tx.vin[1].scriptSig);\n-    BOOST_CHECK(!VerifySignature(orphans[0], tx, 0, true, true, SIGHASH_ALL));\n-    BOOST_CHECK(!VerifySignature(orphans[1], tx, 1, true, true, SIGHASH_ALL));\n+    BOOST_CHECK(!VerifySignature(CCoins(orphans[0], MEMPOOL_HEIGHT), tx, 0, true, true, SIGHASH_ALL));\n+    BOOST_CHECK(!VerifySignature(CCoins(orphans[1], MEMPOOL_HEIGHT), tx, 1, true, true, SIGHASH_ALL));\n     std::swap(tx.vin[0].scriptSig, tx.vin[1].scriptSig);\n \n     // Exercise -maxsigcachesize code:\n@@ -305,7 +305,7 @@ BOOST_AUTO_TEST_CASE(DoS_checkSig)\n     BOOST_CHECK(SignSignature(keystore, orphans[0], tx, 0));\n     BOOST_CHECK(tx.vin[0].scriptSig != oldSig);\n     for (unsigned int j = 0; j < tx.vin.size(); j++)\n-        BOOST_CHECK(VerifySignature(orphans[j], tx, j, true, true, SIGHASH_ALL));\n+        BOOST_CHECK(VerifySignature(CCoins(orphans[j], MEMPOOL_HEIGHT), tx, j, true, true, SIGHASH_ALL));\n     mapArgs.erase(\"-maxsigcachesize\");\n \n     LimitOrphanTxSize(0);"
      },
      {
        "sha": "35069a3fdded720bb209d1438f7d18e71b9c4847",
        "filename": "src/test/script_P2SH_tests.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 9,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/60dc5e886091e0e64678db4dd66ecd66434ca66c/src/test/script_P2SH_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/60dc5e886091e0e64678db4dd66ecd66434ca66c/src/test/script_P2SH_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_P2SH_tests.cpp?ref=60dc5e886091e0e64678db4dd66ecd66434ca66c",
        "patch": "@@ -105,7 +105,7 @@ BOOST_AUTO_TEST_CASE(sign)\n         {\n             CScript sigSave = txTo[i].vin[0].scriptSig;\n             txTo[i].vin[0].scriptSig = txTo[j].vin[0].scriptSig;\n-            bool sigOK = VerifySignature(txFrom, txTo[i], 0, true, true, 0);\n+            bool sigOK = VerifySignature(CCoins(txFrom, 0), txTo[i], 0, true, true, 0);\n             if (i == j)\n                 BOOST_CHECK_MESSAGE(sigOK, strprintf(\"VerifySignature %d %d\", i, j));\n             else\n@@ -243,7 +243,8 @@ BOOST_AUTO_TEST_CASE(switchover)\n \n BOOST_AUTO_TEST_CASE(AreInputsStandard)\n {\n-    std::map<uint256, std::pair<CTxIndex, CTransaction> > mapInputs;\n+    CCoinsView coinsDummy;\n+    CCoinsViewCache coins(coinsDummy);\n     CBasicKeyStore keystore;\n     CKey key[3];\n     vector<CKey> keys;\n@@ -264,23 +265,29 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n     CScript pay1of3; pay1of3.SetMultisig(1, keys);\n \n     txFrom.vout[0].scriptPubKey = payScriptHash1;\n+    txFrom.vout[0].nValue = 1000;\n     txFrom.vout[1].scriptPubKey = pay1;\n+    txFrom.vout[1].nValue = 2000;\n     txFrom.vout[2].scriptPubKey = pay1of3;\n+    txFrom.vout[2].nValue = 3000;\n \n     // Last three non-standard:\n     CScript empty;\n     keystore.AddCScript(empty);\n     txFrom.vout[3].scriptPubKey = empty;\n+    txFrom.vout[3].nValue = 4000;\n     // Can't use SetPayToScriptHash, it checks for the empty Script. So:\n     txFrom.vout[4].scriptPubKey << OP_HASH160 << Hash160(empty) << OP_EQUAL;\n+    txFrom.vout[4].nValue = 5000;\n     CScript oneOfEleven;\n     oneOfEleven << OP_1;\n     for (int i = 0; i < 11; i++)\n         oneOfEleven << key[0].GetPubKey();\n     oneOfEleven << OP_11 << OP_CHECKMULTISIG;\n     txFrom.vout[5].scriptPubKey.SetDestination(oneOfEleven.GetID());\n+    txFrom.vout[5].nValue = 6000;\n \n-    mapInputs[txFrom.GetHash()] = make_pair(CTxIndex(), txFrom);\n+    coins.SetCoins(txFrom.GetHash(), CCoins(txFrom, 0));\n \n     CTransaction txTo;\n     txTo.vout.resize(1);\n@@ -297,21 +304,22 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n     txTo.vin[2].prevout.hash = txFrom.GetHash();\n     BOOST_CHECK(SignSignature(keystore, txFrom, txTo, 2));\n \n-    BOOST_CHECK(txTo.AreInputsStandard(mapInputs));\n-    BOOST_CHECK_EQUAL(txTo.GetP2SHSigOpCount(mapInputs), 1);\n+    BOOST_CHECK(txTo.AreInputsStandard(coins));\n+    BOOST_CHECK_EQUAL(txTo.GetP2SHSigOpCount(coins), 1);\n \n     // Make sure adding crap to the scriptSigs makes them non-standard:\n     for (int i = 0; i < 3; i++)\n     {\n         CScript t = txTo.vin[i].scriptSig;\n         txTo.vin[i].scriptSig = (CScript() << 11) + t;\n-        BOOST_CHECK(!txTo.AreInputsStandard(mapInputs));\n+        BOOST_CHECK(!txTo.AreInputsStandard(coins));\n         txTo.vin[i].scriptSig = t;\n     }\n \n     CTransaction txToNonStd;\n     txToNonStd.vout.resize(1);\n     txToNonStd.vout[0].scriptPubKey.SetDestination(key[1].GetPubKey().GetID());\n+    txToNonStd.vout[0].nValue = 1000;\n     txToNonStd.vin.resize(2);\n     txToNonStd.vin[0].prevout.n = 4;\n     txToNonStd.vin[0].prevout.hash = txFrom.GetHash();\n@@ -320,11 +328,11 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n     txToNonStd.vin[1].prevout.hash = txFrom.GetHash();\n     txToNonStd.vin[1].scriptSig << OP_0 << Serialize(oneOfEleven);\n \n-    BOOST_CHECK(!txToNonStd.AreInputsStandard(mapInputs));\n-    BOOST_CHECK_EQUAL(txToNonStd.GetP2SHSigOpCount(mapInputs), 11);\n+    BOOST_CHECK(!txToNonStd.AreInputsStandard(coins));\n+    BOOST_CHECK_EQUAL(txToNonStd.GetP2SHSigOpCount(coins), 11);\n \n     txToNonStd.vin[0].scriptSig.clear();\n-    BOOST_CHECK(!txToNonStd.AreInputsStandard(mapInputs));\n+    BOOST_CHECK(!txToNonStd.AreInputsStandard(coins));\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "17b925c340d80c28f003193b6e46ebdbf8887b53",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 15,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/60dc5e886091e0e64678db4dd66ecd66434ca66c/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/60dc5e886091e0e64678db4dd66ecd66434ca66c/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=60dc5e886091e0e64678db4dd66ecd66434ca66c",
        "patch": "@@ -173,7 +173,7 @@ BOOST_AUTO_TEST_CASE(basic_transaction_tests)\n // paid to a TX_PUBKEYHASH.\n //\n static std::vector<CTransaction>\n-SetupDummyInputs(CBasicKeyStore& keystoreRet, MapPrevTx& inputsRet)\n+SetupDummyInputs(CBasicKeyStore& keystoreRet, CCoinsView & coinsRet)\n {\n     std::vector<CTransaction> dummyTransactions;\n     dummyTransactions.resize(2);\n@@ -192,23 +192,24 @@ SetupDummyInputs(CBasicKeyStore& keystoreRet, MapPrevTx& inputsRet)\n     dummyTransactions[0].vout[0].scriptPubKey << key[0].GetPubKey() << OP_CHECKSIG;\n     dummyTransactions[0].vout[1].nValue = 50*CENT;\n     dummyTransactions[0].vout[1].scriptPubKey << key[1].GetPubKey() << OP_CHECKSIG;\n-    inputsRet[dummyTransactions[0].GetHash()] = make_pair(CTxIndex(), dummyTransactions[0]);\n+    coinsRet.SetCoins(dummyTransactions[0].GetHash(), CCoins(dummyTransactions[0], 0));\n \n     dummyTransactions[1].vout.resize(2);\n     dummyTransactions[1].vout[0].nValue = 21*CENT;\n     dummyTransactions[1].vout[0].scriptPubKey.SetDestination(key[2].GetPubKey().GetID());\n     dummyTransactions[1].vout[1].nValue = 22*CENT;\n     dummyTransactions[1].vout[1].scriptPubKey.SetDestination(key[3].GetPubKey().GetID());\n-    inputsRet[dummyTransactions[1].GetHash()] = make_pair(CTxIndex(), dummyTransactions[1]);\n+    coinsRet.SetCoins(dummyTransactions[1].GetHash(), CCoins(dummyTransactions[1], 0));\n \n     return dummyTransactions;\n }\n \n BOOST_AUTO_TEST_CASE(test_Get)\n {\n     CBasicKeyStore keystore;\n-    MapPrevTx dummyInputs;\n-    std::vector<CTransaction> dummyTransactions = SetupDummyInputs(keystore, dummyInputs);\n+    CCoinsView coinsDummy;\n+    CCoinsViewCache coins(coinsDummy);\n+    std::vector<CTransaction> dummyTransactions = SetupDummyInputs(keystore, coins);\n \n     CTransaction t1;\n     t1.vin.resize(3);\n@@ -225,25 +226,24 @@ BOOST_AUTO_TEST_CASE(test_Get)\n     t1.vout[0].nValue = 90*CENT;\n     t1.vout[0].scriptPubKey << OP_1;\n \n-    BOOST_CHECK(t1.AreInputsStandard(dummyInputs));\n-    BOOST_CHECK_EQUAL(t1.GetValueIn(dummyInputs), (50+21+22)*CENT);\n+    BOOST_CHECK(t1.AreInputsStandard(coins));\n+    BOOST_CHECK_EQUAL(t1.GetValueIn(coins), (50+21+22)*CENT);\n \n     // Adding extra junk to the scriptSig should make it non-standard:\n     t1.vin[0].scriptSig << OP_11;\n-    BOOST_CHECK(!t1.AreInputsStandard(dummyInputs));\n+    BOOST_CHECK(!t1.AreInputsStandard(coins));\n \n     // ... as should not having enough:\n     t1.vin[0].scriptSig = CScript();\n-    BOOST_CHECK(!t1.AreInputsStandard(dummyInputs));\n+    BOOST_CHECK(!t1.AreInputsStandard(coins));\n }\n \n BOOST_AUTO_TEST_CASE(test_GetThrow)\n {\n     CBasicKeyStore keystore;\n-    MapPrevTx dummyInputs;\n-    std::vector<CTransaction> dummyTransactions = SetupDummyInputs(keystore, dummyInputs);\n-\n-    MapPrevTx missingInputs;\n+    CCoinsView coinsDummy;\n+    CCoinsViewCache coins(coinsDummy);\n+    std::vector<CTransaction> dummyTransactions = SetupDummyInputs(keystore, coins);\n \n     CTransaction t1;\n     t1.vin.resize(3);\n@@ -257,8 +257,8 @@ BOOST_AUTO_TEST_CASE(test_GetThrow)\n     t1.vout[0].nValue = 90*CENT;\n     t1.vout[0].scriptPubKey << OP_1;\n \n-    BOOST_CHECK_THROW(t1.AreInputsStandard(missingInputs), runtime_error);\n-    BOOST_CHECK_THROW(t1.GetValueIn(missingInputs), runtime_error);\n+    BOOST_CHECK_THROW(t1.AreInputsStandard(coinsDummy), runtime_error);\n+    BOOST_CHECK_THROW(t1.GetValueIn(coinsDummy), runtime_error);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "9b2960f64e4126a656c6493bfbb5a0a771bfb6ae",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 44,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/60dc5e886091e0e64678db4dd66ecd66434ca66c/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/60dc5e886091e0e64678db4dd66ecd66434ca66c/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=60dc5e886091e0e64678db4dd66ecd66434ca66c",
        "patch": "@@ -685,7 +685,7 @@ void CWalletTx::GetAccountAmounts(const string& strAccount, int64& nReceived,\n     }\n }\n \n-void CWalletTx::AddSupportingTransactions(CTxDB& txdb)\n+void CWalletTx::AddSupportingTransactions()\n {\n     vtxPrev.clear();\n \n@@ -696,7 +696,6 @@ void CWalletTx::AddSupportingTransactions(CTxDB& txdb)\n         BOOST_FOREACH(const CTxIn& txin, vin)\n             vWorkQueue.push_back(txin.prevout.hash);\n \n-        // This critsect is OK because txdb is already open\n         {\n             LOCK(pwallet->cs_wallet);\n             map<uint256, const CMerkleTx*> mapWalletPrev;\n@@ -720,15 +719,6 @@ void CWalletTx::AddSupportingTransactions(CTxDB& txdb)\n                 {\n                     tx = *mapWalletPrev[hash];\n                 }\n-                else if (!fClient && txdb.ReadDiskTx(hash, tx))\n-                {\n-                    ;\n-                }\n-                else\n-                {\n-                    printf(\"ERROR: AddSupportingTransactions() : unsupported transaction\\n\");\n-                    continue;\n-                }\n \n                 int nDepth = tx.SetMerkleBranch();\n                 vtxPrev.push_back(tx);\n@@ -775,49 +765,36 @@ int CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate)\n     return ret;\n }\n \n-int CWallet::ScanForWalletTransaction(const uint256& hashTx)\n-{\n-    CTransaction tx;\n-    tx.ReadFromDisk(COutPoint(hashTx, 0));\n-    if (AddToWalletIfInvolvingMe(tx, NULL, true, true))\n-        return 1;\n-    return 0;\n-}\n-\n void CWallet::ReacceptWalletTransactions()\n {\n-    CTxDB txdb(\"r\");\n+    CCoinsDB coinsdb(\"r\");\n     bool fRepeat = true;\n     while (fRepeat)\n     {\n         LOCK(cs_wallet);\n         fRepeat = false;\n-        vector<CDiskTxPos> vMissingTx;\n+        bool fMissing = false;\n         BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n         {\n             CWalletTx& wtx = item.second;\n             if (wtx.IsCoinBase() && wtx.IsSpent(0))\n                 continue;\n \n-            CTxIndex txindex;\n+            CCoins coins;\n             bool fUpdated = false;\n-            if (txdb.ReadTxIndex(wtx.GetHash(), txindex))\n+            bool fNotFound = coinsdb.ReadCoins(wtx.GetHash(), coins);\n+            if (!fNotFound || wtx.GetDepthInMainChain() > 0)\n             {\n                 // Update fSpent if a tx got spent somewhere else by a copy of wallet.dat\n-                if (txindex.vSpent.size() != wtx.vout.size())\n-                {\n-                    printf(\"ERROR: ReacceptWalletTransactions() : txindex.vSpent.size() %\"PRIszu\" != wtx.vout.size() %\"PRIszu\"\\n\", txindex.vSpent.size(), wtx.vout.size());\n-                    continue;\n-                }\n-                for (unsigned int i = 0; i < txindex.vSpent.size(); i++)\n+                for (unsigned int i = 0; i < wtx.vout.size(); i++)\n                 {\n                     if (wtx.IsSpent(i))\n                         continue;\n-                    if (!txindex.vSpent[i].IsNull() && IsMine(wtx.vout[i]))\n+                    if ((i >= coins.vout.size() || coins.vout[i].IsNull()) && IsMine(wtx.vout[i]))\n                     {\n                         wtx.MarkSpent(i);\n                         fUpdated = true;\n-                        vMissingTx.push_back(txindex.vSpent[i]);\n+                        fMissing = true;\n                     }\n                 }\n                 if (fUpdated)\n@@ -831,10 +808,10 @@ void CWallet::ReacceptWalletTransactions()\n             {\n                 // Re-accept any txes of ours that aren't already in a block\n                 if (!wtx.IsCoinBase())\n-                    wtx.AcceptWalletTransaction(txdb, false);\n+                    wtx.AcceptWalletTransaction(coinsdb, false);\n             }\n         }\n-        if (!vMissingTx.empty())\n+        if (fMissing)\n         {\n             // TODO: optimize this to scan just part of the block chain?\n             if (ScanForWalletTransactions(pindexGenesisBlock))\n@@ -843,21 +820,21 @@ void CWallet::ReacceptWalletTransactions()\n     }\n }\n \n-void CWalletTx::RelayWalletTransaction(CTxDB& txdb)\n+void CWalletTx::RelayWalletTransaction(CCoinsDB& coinsdb)\n {\n     BOOST_FOREACH(const CMerkleTx& tx, vtxPrev)\n     {\n         if (!tx.IsCoinBase())\n         {\n             uint256 hash = tx.GetHash();\n-            if (!txdb.ContainsTx(hash))\n+            if (!coinsdb.HaveCoins(hash))\n                 RelayMessage(CInv(MSG_TX, hash), (CTransaction)tx);\n         }\n     }\n     if (!IsCoinBase())\n     {\n         uint256 hash = GetHash();\n-        if (!txdb.ContainsTx(hash))\n+        if (!coinsdb.HaveCoins(hash))\n         {\n             printf(\"Relaying wtx %s\\n\", hash.ToString().substr(0,10).c_str());\n             RelayMessage(CInv(MSG_TX, hash), (CTransaction)*this);\n@@ -867,8 +844,8 @@ void CWalletTx::RelayWalletTransaction(CTxDB& txdb)\n \n void CWalletTx::RelayWalletTransaction()\n {\n-   CTxDB txdb(\"r\");\n-   RelayWalletTransaction(txdb);\n+   CCoinsDB coinsdb(\"r\");\n+   RelayWalletTransaction(coinsdb);\n }\n \n void CWallet::ResendWalletTransactions()\n@@ -891,7 +868,7 @@ void CWallet::ResendWalletTransactions()\n \n     // Rebroadcast any of our txes that aren't in a block yet\n     printf(\"ResendWalletTransactions()\\n\");\n-    CTxDB txdb(\"r\");\n+    CCoinsDB coinsdb(\"r\");\n     {\n         LOCK(cs_wallet);\n         // Sort them in chronological order\n@@ -907,7 +884,7 @@ void CWallet::ResendWalletTransactions()\n         BOOST_FOREACH(PAIRTYPE(const unsigned int, CWalletTx*)& item, mapSorted)\n         {\n             CWalletTx& wtx = *item.second;\n-            wtx.RelayWalletTransaction(txdb);\n+            wtx.RelayWalletTransaction(coinsdb);\n         }\n     }\n }\n@@ -1162,8 +1139,6 @@ bool CWallet::CreateTransaction(const vector<pair<CScript, int64> >& vecSend, CW\n \n     {\n         LOCK2(cs_main, cs_wallet);\n-        // txdb must be opened before the mapWallet lock\n-        CTxDB txdb(\"r\");\n         {\n             nFeeRet = nTransactionFee;\n             loop\n@@ -1253,7 +1228,7 @@ bool CWallet::CreateTransaction(const vector<pair<CScript, int64> >& vecSend, CW\n                 }\n \n                 // Fill vtxPrev by copying from previous transactions vtxPrev\n-                wtxNew.AddSupportingTransactions(txdb);\n+                wtxNew.AddSupportingTransactions();\n                 wtxNew.fTimeReceivedIsTxTime = true;\n \n                 break;"
      },
      {
        "sha": "e0aa07797250f15f31f9d546a84ce5901c0ac549",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/60dc5e886091e0e64678db4dd66ecd66434ca66c/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/60dc5e886091e0e64678db4dd66ecd66434ca66c/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=60dc5e886091e0e64678db4dd66ecd66434ca66c",
        "patch": "@@ -166,7 +166,6 @@ class CWallet : public CCryptoKeyStore\n     bool EraseFromWallet(uint256 hash);\n     void WalletUpdateSpent(const CTransaction& prevout);\n     int ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate = false);\n-    int ScanForWalletTransaction(const uint256& hashTx);\n     void ReacceptWalletTransactions();\n     void ResendWalletTransactions();\n     int64 GetBalance() const;\n@@ -659,12 +658,12 @@ class CWalletTx : public CMerkleTx\n     int64 GetTxTime() const;\n     int GetRequestCount() const;\n \n-    void AddSupportingTransactions(CTxDB& txdb);\n+    void AddSupportingTransactions();\n \n-    bool AcceptWalletTransaction(CTxDB& txdb, bool fCheckInputs=true);\n+    bool AcceptWalletTransaction(CCoinsDB& coinsdb, bool fCheckInputs=true);\n     bool AcceptWalletTransaction();\n \n-    void RelayWalletTransaction(CTxDB& txdb);\n+    void RelayWalletTransaction(CCoinsDB& coinsdb);\n     void RelayWalletTransaction();\n };\n "
      }
    ]
  },
  {
    "sha": "69a9db3639263eb38b2d2dcb7a394b26745dce72",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2OWE5ZGIzNjM5MjYzZWIzOGIyZDJkY2I3YTM5NGIyNjc0NWRjZTcy",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-07-06T14:33:34Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-20T13:39:12Z"
      },
      "message": "Batch block connection during IBD\n\nDuring the initial block download (or -loadblock), delay connection\nof new blocks a bit, and perform them in a single action. This reduces\nthe load on the database engine, as subsequent blocks often update an\nearlier block's transaction already.",
      "tree": {
        "sha": "848867135da5954b7155ebe98c09db66d09d5737",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/848867135da5954b7155ebe98c09db66d09d5737"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/69a9db3639263eb38b2d2dcb7a394b26745dce72",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/69a9db3639263eb38b2d2dcb7a394b26745dce72",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/69a9db3639263eb38b2d2dcb7a394b26745dce72",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/69a9db3639263eb38b2d2dcb7a394b26745dce72/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "60dc5e886091e0e64678db4dd66ecd66434ca66c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/60dc5e886091e0e64678db4dd66ecd66434ca66c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/60dc5e886091e0e64678db4dd66ecd66434ca66c"
      }
    ],
    "stats": {
      "total": 350,
      "additions": 181,
      "deletions": 169
    },
    "files": [
      {
        "sha": "06e5543b2e8b702cc5b49d01ff54adef9edd38f4",
        "filename": "src/db.cpp",
        "status": "modified",
        "additions": 65,
        "deletions": 24,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69a9db3639263eb38b2d2dcb7a394b26745dce72/src/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69a9db3639263eb38b2d2dcb7a394b26745dce72/src/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.cpp?ref=69a9db3639263eb38b2d2dcb7a394b26745dce72",
        "patch": "@@ -79,8 +79,8 @@ bool CDBEnv::Open(boost::filesystem::path pathEnv_)\n     dbenv.set_cachesize(nDbCache / 1024, (nDbCache % 1024)*1048576, 1);\n     dbenv.set_lg_bsize(1048576);\n     dbenv.set_lg_max(10485760);\n-    dbenv.set_lk_max_locks(10000);\n-    dbenv.set_lk_max_objects(10000);\n+    dbenv.set_lk_max_locks(40000);\n+    dbenv.set_lk_max_objects(40000);\n     dbenv.set_errfile(fopen(pathErrorFile.string().c_str(), \"a\")); /// debug\n     dbenv.set_flags(DB_AUTO_COMMIT, 1);\n     dbenv.set_flags(DB_TXN_WRITE_NOSYNC, 1);\n@@ -279,14 +279,10 @@ static bool IsChainFile(std::string strFile)\n     return false;\n }\n \n-void CDB::Close()\n+void CDB::Flush()\n {\n-    if (!pdb)\n-        return;\n     if (activeTxn)\n-        activeTxn->abort();\n-    activeTxn = NULL;\n-    pdb = NULL;\n+        return;\n \n     // Flush database activity from memory pool to disk log\n     unsigned int nMinutes = 0;\n@@ -298,6 +294,18 @@ void CDB::Close()\n         nMinutes = 5;\n \n     bitdb.dbenv.txn_checkpoint(nMinutes ? GetArg(\"-dblogsize\", 100)*1024 : 0, nMinutes, 0);\n+}\n+\n+void CDB::Close()\n+{\n+    if (!pdb)\n+        return;\n+    if (activeTxn)\n+        activeTxn->abort();\n+    activeTxn = NULL;\n+    pdb = NULL;\n+\n+    Flush();\n \n     {\n         LOCK(bitdb.cs_db);\n@@ -537,6 +545,42 @@ bool CChainDB::ReadLastBlockFile(int &nFile) {\n     return Read('l', nFile);\n }\n \n+CCoinsViewDB::CCoinsViewDB() : db(\"cr+\") {}\n+bool CCoinsViewDB::GetCoins(uint256 txid, CCoins &coins) { return db.ReadCoins(txid, coins); }\n+bool CCoinsViewDB::SetCoins(uint256 txid, const CCoins &coins) { return db.WriteCoins(txid, coins); }\n+bool CCoinsViewDB::HaveCoins(uint256 txid) { return db.HaveCoins(txid); }\n+CBlockIndex *CCoinsViewDB::GetBestBlock() {\n+    uint256 hashBestChain;\n+    if (!db.ReadHashBestChain(hashBestChain))\n+        return NULL;\n+    std::map<uint256, CBlockIndex*>::iterator it = mapBlockIndex.find(hashBestChain);\n+    if (it == mapBlockIndex.end())\n+        return NULL;\n+    return it->second;\n+}\n+bool CCoinsViewDB::SetBestBlock(CBlockIndex *pindex) { return db.WriteHashBestChain(pindex->GetBlockHash()); }\n+bool CCoinsViewDB::BatchWrite(const std::map<uint256, CCoins> &mapCoins, CBlockIndex *pindex) {\n+    printf(\"Committing %u changed transactions to coin database...\\n\", (unsigned int)mapCoins.size());\n+\n+    if (!db.TxnBegin())\n+        return false;\n+    bool fOk = true;\n+    for (std::map<uint256, CCoins>::const_iterator it = mapCoins.begin(); it != mapCoins.end(); it++) {\n+        fOk = db.WriteCoins(it->first, it->second);\n+        if (!fOk)\n+            break;\n+    }\n+    if (fOk)\n+        fOk = db.WriteHashBestChain(pindex->GetBlockHash());\n+\n+    if (!fOk)\n+        db.TxnAbort();\n+    else\n+        fOk = db.TxnCommit();\n+\n+    return fOk;\n+}\n+\n CBlockIndex static * InsertBlockIndex(uint256 hash)\n {\n     if (hash == 0)\n@@ -557,7 +601,7 @@ CBlockIndex static * InsertBlockIndex(uint256 hash)\n     return pindexNew;\n }\n \n-bool LoadBlockIndex(CCoinsDB &coindb, CChainDB &chaindb)\n+bool LoadBlockIndex(CChainDB &chaindb)\n {\n     if (!chaindb.LoadBlockIndexGuts())\n         return false;\n@@ -587,26 +631,23 @@ bool LoadBlockIndex(CCoinsDB &coindb, CChainDB &chaindb)\n         printf(\"LoadBlockIndex(): last block file: %s\\n\", infoLastBlockFile.ToString().c_str());\n  \n     // Load hashBestChain pointer to end of best chain\n-    if (!coindb.ReadHashBestChain(hashBestChain))\n+    pindexBest = pcoinsTip->GetBestBlock();\n+    if (pindexBest == NULL)\n     {\n         if (pindexGenesisBlock == NULL)\n             return true;\n         return error(\"CTxDB::LoadBlockIndex() : hashBestChain not loaded\");\n     }\n-    std::map<uint256, CBlockIndex*>::iterator it = mapBlockIndex.find(hashBestChain);\n-    if (it == mapBlockIndex.end()) {\n-        return error(\"CTxDB::LoadBlockIndex() : hashBestChain not found in the block index\");\n-    } else {\n-        // set 'next' pointers in best chain\n-        CBlockIndex *pindex = it->second;\n-        while(pindex != NULL && pindex->pprev != NULL) {\n-             CBlockIndex *pindexPrev = pindex->pprev;\n-             pindexPrev->pnext = pindex;\n-             pindex = pindexPrev;\n-        }\n-        pindexBest = it->second;\n-        nBestHeight = pindexBest->nHeight;\n-        bnBestChainWork = pindexBest->bnChainWork;\n+    hashBestChain = pindexBest->GetBlockHash();\n+    nBestHeight = pindexBest->nHeight;\n+    bnBestChainWork = pindexBest->bnChainWork;\n+\n+    // set 'next' pointers in best chain\n+    CBlockIndex *pindex = pindexBest;\n+    while(pindex != NULL && pindex->pprev != NULL) {\n+         CBlockIndex *pindexPrev = pindex->pprev;\n+         pindexPrev->pnext = pindex;\n+         pindex = pindexPrev;\n     }\n     printf(\"LoadBlockIndex(): hashBestChain=%s  height=%d date=%s\\n\",\n         hashBestChain.ToString().substr(0,20).c_str(), nBestHeight,"
      },
      {
        "sha": "bdab635468e65e0a5f3b1b24130b72959ecc4450",
        "filename": "src/db.h",
        "status": "modified",
        "additions": 19,
        "deletions": 1,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69a9db3639263eb38b2d2dcb7a394b26745dce72/src/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69a9db3639263eb38b2d2dcb7a394b26745dce72/src/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.h?ref=69a9db3639263eb38b2d2dcb7a394b26745dce72",
        "patch": "@@ -102,6 +102,7 @@ class CDB\n     explicit CDB(const char* pszFile, const char* pszMode=\"r+\");\n     ~CDB() { Close(); }\n public:\n+    void Flush();\n     void Close();\n private:\n     CDB(const CDB&);\n@@ -330,6 +331,23 @@ class CCoinsDB : public CDB\n     bool WriteHashBestChain(uint256 hashBestChain);\n };\n \n+\n+/** CCoinsView backed by a CCoinsDB */\n+class CCoinsViewDB : public CCoinsView\n+{\n+protected:\n+    CCoinsDB db;\n+public:\n+    CCoinsViewDB();\n+    bool GetCoins(uint256 txid, CCoins &coins);\n+    bool SetCoins(uint256 txid, const CCoins &coins);\n+    bool HaveCoins(uint256 txid);\n+    CBlockIndex *GetBestBlock();\n+    bool SetBestBlock(CBlockIndex *pindex);\n+    bool BatchWrite(const std::map<uint256, CCoins> &mapCoins, CBlockIndex *pindex);\n+};\n+\n+\n /** Access to the block database (chain.dat) */\n class CChainDB : public CDB\n {\n@@ -350,7 +368,7 @@ class CChainDB : public CDB\n };\n \n \n-bool LoadBlockIndex(CCoinsDB &coinsdb, CChainDB &chaindb);\n+bool LoadBlockIndex(CChainDB &chaindb);\n \n \n /** Access to the (IP) address database (peers.dat) */"
      },
      {
        "sha": "b05d57abfe6688e3159c1ee0025be955035d7951",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69a9db3639263eb38b2d2dcb7a394b26745dce72/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69a9db3639263eb38b2d2dcb7a394b26745dce72/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=69a9db3639263eb38b2d2dcb7a394b26745dce72",
        "patch": "@@ -50,6 +50,8 @@ void StartShutdown()\n #endif\n }\n \n+static CCoinsViewDB *pcoinsdbview;\n+\n void Shutdown(void* parg)\n {\n     static CCriticalSection cs_Shutdown;\n@@ -74,6 +76,12 @@ void Shutdown(void* parg)\n         nTransactionsUpdated++;\n         bitdb.Flush(false);\n         StopNode();\n+        {\n+            LOCK(cs_main);\n+            pcoinsTip->Flush();\n+            delete pcoinsTip;\n+            delete pcoinsdbview;\n+        }\n         bitdb.Flush(true);\n         boost::filesystem::remove(GetPidFile());\n         UnregisterWallet(pwalletMain);\n@@ -298,6 +306,7 @@ std::string HelpMessage()\n     return strUsage;\n }\n \n+\n /** Initialize bitcoin.\n  *  @pre Parameters should be parsed and config file should be read.\n  */\n@@ -641,6 +650,9 @@ bool AppInit2()\n     uiInterface.InitMessage(_(\"Loading block index...\"));\n     printf(\"Loading block index...\\n\");\n     nStart = GetTimeMillis();\n+    pcoinsdbview = new CCoinsViewDB();\n+    pcoinsTip = new CCoinsViewCache(*pcoinsdbview);\n+\n     if (!LoadBlockIndex())\n         return InitError(_(\"Error loading blkindex.dat\"));\n "
      },
      {
        "sha": "c23aae32067efcae84fd03ee4a027fd12cfb91d0",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 59,
        "deletions": 87,
        "changes": 146,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69a9db3639263eb38b2d2dcb7a394b26745dce72/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69a9db3639263eb38b2d2dcb7a394b26745dce72/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=69a9db3639263eb38b2d2dcb7a394b26745dce72",
        "patch": "@@ -168,6 +168,7 @@ bool CCoinsView::SetCoins(uint256 txid, const CCoins &coins) { return false; }\n bool CCoinsView::HaveCoins(uint256 txid) { return false; }\n CBlockIndex *CCoinsView::GetBestBlock() { return NULL; }\n bool CCoinsView::SetBestBlock(CBlockIndex *pindex) { return false; }\n+bool CCoinsView::BatchWrite(const std::map<uint256, CCoins> &mapCoins, CBlockIndex *pindex) { return false; }\n \n CCoinsViewBacked::CCoinsViewBacked(CCoinsView &viewIn) : base(&viewIn) { }\n bool CCoinsViewBacked::GetCoins(uint256 txid, CCoins &coins) { return base->GetCoins(txid, coins); }\n@@ -176,13 +177,7 @@ bool CCoinsViewBacked::HaveCoins(uint256 txid) { return base->HaveCoins(txid); }\n CBlockIndex *CCoinsViewBacked::GetBestBlock() { return base->GetBestBlock(); }\n bool CCoinsViewBacked::SetBestBlock(CBlockIndex *pindex) { return base->SetBestBlock(pindex); }\n void CCoinsViewBacked::SetBackend(CCoinsView &viewIn) { base = &viewIn; }\n-\n-CCoinsViewDB::CCoinsViewDB(CCoinsDB &dbIn) : db(dbIn) {}\n-bool CCoinsViewDB::GetCoins(uint256 txid, CCoins &coins) { return db.ReadCoins(txid, coins); }\n-bool CCoinsViewDB::SetCoins(uint256 txid, const CCoins &coins) { return db.WriteCoins(txid, coins); }\n-bool CCoinsViewDB::HaveCoins(uint256 txid) { return db.HaveCoins(txid); }\n-CBlockIndex *CCoinsViewDB::GetBestBlock() { return pindexBest; }\n-bool CCoinsViewDB::SetBestBlock(CBlockIndex *pindex) { return db.WriteHashBestChain(pindex->GetBlockHash()); }\n+bool CCoinsViewBacked::BatchWrite(const std::map<uint256, CCoins> &mapCoins, CBlockIndex *pindex) { return base->BatchWrite(mapCoins, pindex); }\n \n CCoinsViewCache::CCoinsViewCache(CCoinsView &baseIn, bool fDummy) : CCoinsViewBacked(baseIn), pindexTip(NULL) { }\n \n@@ -218,18 +213,24 @@ bool CCoinsViewCache::SetBestBlock(CBlockIndex *pindex) {\n     return true;\n }\n \n-bool CCoinsViewCache::Flush() {\n-    for (std::map<uint256,CCoins>::iterator it = cacheCoins.begin(); it != cacheCoins.end(); it++) {\n-        if (!base->SetCoins(it->first, it->second))\n-            return false;\n-    }\n-    if (!base->SetBestBlock(pindexTip))\n-        return false;\n-    cacheCoins.clear();\n-    pindexTip = NULL;\n+bool CCoinsViewCache::BatchWrite(const std::map<uint256, CCoins> &mapCoins, CBlockIndex *pindex) {\n+    for (std::map<uint256, CCoins>::const_iterator it = mapCoins.begin(); it != mapCoins.end(); it++)\n+        cacheCoins[it->first] = it->second;\n+    pindexTip = pindex;\n     return true;\n }\n \n+bool CCoinsViewCache::Flush() {\n+    bool fOk = base->BatchWrite(cacheCoins, pindexTip);\n+    if (fOk)\n+        cacheCoins.clear();\n+    return fOk;\n+}\n+\n+unsigned int CCoinsViewCache::GetCacheSize() {\n+    return cacheCoins.size();\n+}\n+\n /** CCoinsView that brings transactions from a memorypool into view.\n     It does not check for spendings by memory pool transactions. */\n CCoinsViewMemPool::CCoinsViewMemPool(CCoinsView &baseIn, CTxMemPool &mempoolIn) : CCoinsViewBacked(baseIn), mempool(mempoolIn) { }\n@@ -249,7 +250,7 @@ bool CCoinsViewMemPool::HaveCoins(uint256 txid) {\n     return mempool.exists(txid) || base->HaveCoins(txid);\n }\n \n-\n+CCoinsViewCache *pcoinsTip = NULL;\n \n //////////////////////////////////////////////////////////////////////////////\n //\n@@ -450,9 +451,8 @@ int CMerkleTx::SetMerkleBranch(const CBlock* pblock)\n         CBlock blockTmp;\n \n         if (pblock == NULL) {\n-            CCoinsDB coinsdb(\"r\");\n             CCoins coins;\n-            if (coinsdb.ReadCoins(GetHash(), coins)) {\n+            if (pcoinsTip->GetCoins(GetHash(), coins)) {\n                 CBlockIndex *pindex = FindBlockByHeight(coins.nHeight);\n                 if (pindex) {\n                     if (!blockTmp.ReadFromDisk(pindex))\n@@ -609,7 +609,7 @@ void CTxMemPool::pruneSpent(const uint256 &hashTx, CCoins &coins)\n     }\n }\n \n-bool CTxMemPool::accept(CCoinsDB& coinsdb, CTransaction &tx, bool fCheckInputs,\n+bool CTxMemPool::accept(CTransaction &tx, bool fCheckInputs,\n                         bool* pfMissingInputs)\n {\n     if (pfMissingInputs)\n@@ -668,9 +668,7 @@ bool CTxMemPool::accept(CCoinsDB& coinsdb, CTransaction &tx, bool fCheckInputs,\n \n     if (fCheckInputs)\n     {\n-        CCoinsViewDB viewDB(coinsdb);\n-        CCoinsViewMemPool viewMemPool(viewDB, mempool);\n-        CCoinsViewCache view(viewMemPool);\n+        CCoinsViewCache &view = *pcoinsTip;\n \n         // do we already have it?\n         if (view.HaveCoins(hash))\n@@ -758,9 +756,9 @@ bool CTxMemPool::accept(CCoinsDB& coinsdb, CTransaction &tx, bool fCheckInputs,\n     return true;\n }\n \n-bool CTransaction::AcceptToMemoryPool(CCoinsDB& coinsdb, bool fCheckInputs, bool* pfMissingInputs)\n+bool CTransaction::AcceptToMemoryPool(bool fCheckInputs, bool* pfMissingInputs)\n {\n-    return mempool.accept(coinsdb, *this, fCheckInputs, pfMissingInputs);\n+    return mempool.accept(*this, fCheckInputs, pfMissingInputs);\n }\n \n bool CTxMemPool::addUnchecked(const uint256& hash, CTransaction &tx)\n@@ -849,31 +847,24 @@ int CMerkleTx::GetBlocksToMaturity() const\n }\n \n \n-bool CMerkleTx::AcceptToMemoryPool(CCoinsDB& coinsdb, bool fCheckInputs)\n+bool CMerkleTx::AcceptToMemoryPool(bool fCheckInputs)\n {\n     if (fClient)\n     {\n         if (!IsInMainChain() && !ClientCheckInputs())\n             return false;\n-        return CTransaction::AcceptToMemoryPool(coinsdb, false);\n+        return CTransaction::AcceptToMemoryPool(false);\n     }\n     else\n     {\n-        return CTransaction::AcceptToMemoryPool(coinsdb, fCheckInputs);\n+        return CTransaction::AcceptToMemoryPool(fCheckInputs);\n     }\n }\n \n-bool CMerkleTx::AcceptToMemoryPool()\n-{\n-    CCoinsDB coinsdb(\"r\");\n-    return AcceptToMemoryPool(coinsdb);\n-}\n-\n \n \n-bool CWalletTx::AcceptWalletTransaction(CCoinsDB& coinsdb, bool fCheckInputs)\n+bool CWalletTx::AcceptWalletTransaction(bool fCheckInputs)\n {\n-\n     {\n         LOCK(mempool.cs);\n         // Add previous supporting transactions first\n@@ -882,20 +873,15 @@ bool CWalletTx::AcceptWalletTransaction(CCoinsDB& coinsdb, bool fCheckInputs)\n             if (!tx.IsCoinBase())\n             {\n                 uint256 hash = tx.GetHash();\n-                if (!mempool.exists(hash) && !coinsdb.HaveCoins(hash))\n-                    tx.AcceptToMemoryPool(coinsdb, fCheckInputs);\n+                if (!mempool.exists(hash) && pcoinsTip->HaveCoins(hash))\n+                    tx.AcceptToMemoryPool(fCheckInputs);\n             }\n         }\n-        return AcceptToMemoryPool(coinsdb, fCheckInputs);\n+        return AcceptToMemoryPool(fCheckInputs);\n     }\n     return false;\n }\n \n-bool CWalletTx::AcceptWalletTransaction()\n-{\n-    CCoinsDB coinsdb(\"r\");\n-    return AcceptWalletTransaction(coinsdb);\n-}\n \n // Return transaction in tx, and if it was found inside a block, its hash is placed in hashBlock\n bool GetTransaction(const uint256 &hash, CTransaction &txOut, uint256 &hashBlock, bool fAllowSlow)\n@@ -915,8 +901,7 @@ bool GetTransaction(const uint256 &hash, CTransaction &txOut, uint256 &hashBlock\n         if (fAllowSlow) { // use coin database to locate block that contains transaction, and scan it\n             int nHeight = -1;\n             {\n-                CCoinsDB coindb(\"r\");\n-                CCoinsViewDB view(coindb);\n+                CCoinsViewCache &view = *pcoinsTip;\n                 CCoins coins;\n                 if (view.GetCoins(hash, coins))\n                     nHeight = coins.nHeight;\n@@ -1565,18 +1550,15 @@ bool CBlock::ConnectBlock(CBlockIndex* pindex, CCoinsView &view, bool fJustCheck\n \n bool CBlock::SetBestChain(CBlockIndex* pindexNew)\n {\n-    // if this functions exits prematurely, the transaction is aborted\n-    CCoinsDB coinsdb;\n-    if (!coinsdb.TxnBegin())\n-        return error(\"SetBestChain() : TxnBegin failed\");\n+    CCoinsViewCache &view = *pcoinsTip;\n \n     // special case for attaching the genesis block\n     // note that no ConnectBlock is called, so its coinbase output is non-spendable\n     if (pindexGenesisBlock == NULL && pindexNew->GetBlockHash() == hashGenesisBlock)\n     {\n-        coinsdb.WriteHashBestChain(pindexNew->GetBlockHash());\n-        if (!coinsdb.TxnCommit())\n-            return error(\"SetBestChain() : TxnCommit failed\");\n+        view.SetBestBlock(pindexNew);\n+        if (!view.Flush())\n+            return false;\n         pindexGenesisBlock = pindexNew;\n         pindexBest = pindexNew;\n         hashBestChain = pindexNew->GetBlockHash();\n@@ -1585,10 +1567,6 @@ bool CBlock::SetBestChain(CBlockIndex* pindexNew)\n         return true;\n     }\n \n-    // create cached view to the coins database\n-    CCoinsViewDB viewDB(coinsdb);\n-    CCoinsViewCache view(viewDB);\n-\n     // Find the fork (typically, there is none)\n     CBlockIndex* pfork = view.GetBestBlock();\n     CBlockIndex* plonger = pindexNew;\n@@ -1625,8 +1603,11 @@ bool CBlock::SetBestChain(CBlockIndex* pindexNew)\n         CBlock block;\n         if (!block.ReadFromDisk(pindex))\n             return error(\"SetBestBlock() : ReadFromDisk for disconnect failed\");\n-        if (!block.DisconnectBlock(pindex, view))\n+        CCoinsViewCache viewTemp(view, true);\n+        if (!block.DisconnectBlock(pindex, viewTemp))\n             return error(\"SetBestBlock() : DisconnectBlock %s failed\", pindex->GetBlockHash().ToString().substr(0,20).c_str());\n+        if (!viewTemp.Flush())\n+            return error(\"SetBestBlock() : Cache flush failed after disconnect\");\n \n         // Queue memory transactions to resurrect\n         BOOST_FOREACH(const CTransaction& tx, block.vtx)\n@@ -1646,22 +1627,24 @@ bool CBlock::SetBestChain(CBlockIndex* pindexNew)\n                 return error(\"SetBestBlock() : ReadFromDisk for connect failed\");\n             pblock = &block;\n         }\n-        if (!pblock->ConnectBlock(pindex, view)) {\n+        CCoinsViewCache viewTemp(view, true);\n+        if (!pblock->ConnectBlock(pindex, viewTemp)) {\n             InvalidChainFound(pindexNew);\n             return error(\"SetBestBlock() : ConnectBlock %s failed\", pindex->GetBlockHash().ToString().substr(0,20).c_str());\n         }\n+        if (!viewTemp.Flush())\n+            return error(\"SetBestBlock() : Cache flush failed after connect\");\n \n         // Queue memory transactions to delete\n         BOOST_FOREACH(const CTransaction& tx, pblock->vtx)\n             vDelete.push_back(tx);\n     }\n \n     // Make sure it's successfully written to disk before changing memory structure\n-    if (!view.Flush())\n-        return error(\"SetBestBlock() : failed to write coin changes\");\n-    if (!coinsdb.TxnCommit())\n-        return error(\"SetBestBlock() : TxnCommit failed\");\n-    coinsdb.Close();\n+    bool fIsInitialDownload = IsInitialBlockDownload();\n+    if (!fIsInitialDownload || view.GetCacheSize()>5000)\n+        if (!view.Flush())\n+            return false;\n \n     // At this point, all changes have been done to the database.\n     // Proceed by updating the memory structures.\n@@ -1678,14 +1661,13 @@ bool CBlock::SetBestChain(CBlockIndex* pindexNew)\n \n     // Resurrect memory transactions that were in the disconnected branch\n     BOOST_FOREACH(CTransaction& tx, vResurrect)\n-        tx.AcceptToMemoryPool(coinsdb, false);\n+        tx.AcceptToMemoryPool(false);\n \n     // Delete redundant memory transactions that are in the connected branch\n     BOOST_FOREACH(CTransaction& tx, vDelete)\n         mempool.remove(tx);\n \n     // Update best block in wallet (so we can detect restored wallets)\n-    bool fIsInitialDownload = IsInitialBlockDownload();\n     if (!fIsInitialDownload)\n     {\n         const CBlockLocator locator(pindexNew);\n@@ -1765,11 +1747,8 @@ bool CBlock::AddToBlockIndex(const CDiskBlockPos &pos)\n         return false;\n \n     // New best\n-    if (pindexNew->bnChainWork > bnBestChainWork) {\n-        if (!IsInitialBlockDownload() || (pindexNew->nHeight % 1) == 0)\n-            if (!SetBestChain(pindexNew))\n-                return false;\n-    }\n+    if (!SetBestChain(pindexNew))\n+        return false;\n \n     if (pindexNew == pindexBest)\n     {\n@@ -2169,11 +2148,9 @@ bool LoadBlockIndex(bool fAllowNew)\n     // Load block index\n     //\n     CChainDB chaindb(\"cr\");\n-    CCoinsDB coinsdb(\"cr\");\n-    if (!LoadBlockIndex(coinsdb, chaindb))\n+    if (!LoadBlockIndex(chaindb))\n         return false;\n     chaindb.Close();\n-    coinsdb.Close();\n \n     //\n     // Init with genesis block\n@@ -2492,7 +2469,7 @@ string GetWarnings(string strFor)\n //\n \n \n-bool static AlreadyHave(CCoinsDB &coinsdb, const CInv& inv)\n+bool static AlreadyHave(const CInv& inv)\n {\n     switch (inv.type)\n     {\n@@ -2504,7 +2481,7 @@ bool static AlreadyHave(CCoinsDB &coinsdb, const CInv& inv)\n                 txInMap = mempool.exists(inv.hash);\n             }\n             return txInMap || mapOrphanTransactions.count(inv.hash) ||\n-                coinsdb.HaveCoins(inv.hash);\n+                pcoinsTip->HaveCoins(inv.hash);\n         }\n     case MSG_BLOCK:\n         return mapBlockIndex.count(inv.hash) ||\n@@ -2748,7 +2725,6 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n                 break;\n             }\n         }\n-        CCoinsDB coinsdb(\"r\");\n         for (unsigned int nInv = 0; nInv < vInv.size(); nInv++)\n         {\n             const CInv &inv = vInv[nInv];\n@@ -2757,7 +2733,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n                 return true;\n             pfrom->AddInventoryKnown(inv);\n \n-            bool fAlreadyHave = AlreadyHave(coinsdb, inv);\n+            bool fAlreadyHave = AlreadyHave(inv);\n             if (fDebug)\n                 printf(\"  got inventory: %s  %s\\n\", inv.ToString().c_str(), fAlreadyHave ? \"have\" : \"new\");\n \n@@ -2929,15 +2905,14 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         vector<uint256> vWorkQueue;\n         vector<uint256> vEraseQueue;\n         CDataStream vMsg(vRecv);\n-        CCoinsDB coinsdb(\"r\");\n         CTransaction tx;\n         vRecv >> tx;\n \n         CInv inv(MSG_TX, tx.GetHash());\n         pfrom->AddInventoryKnown(inv);\n \n         bool fMissingInputs = false;\n-        if (tx.AcceptToMemoryPool(coinsdb, true, &fMissingInputs))\n+        if (tx.AcceptToMemoryPool(true, &fMissingInputs))\n         {\n             SyncWithWallets(tx, NULL, true);\n             RelayMessage(inv, vMsg);\n@@ -2959,7 +2934,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n                     CInv inv(MSG_TX, tx.GetHash());\n                     bool fMissingInputs2 = false;\n \n-                    if (tx.AcceptToMemoryPool(coinsdb, true, &fMissingInputs2))\n+                    if (tx.AcceptToMemoryPool(true, &fMissingInputs2))\n                     {\n                         printf(\"   accepted orphan tx %s\\n\", inv.hash.ToString().substr(0,10).c_str());\n                         SyncWithWallets(tx, NULL, true);\n@@ -3407,11 +3382,10 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n         //\n         vector<CInv> vGetData;\n         int64 nNow = GetTime() * 1000000;\n-        CCoinsDB coinsdb(\"r\");\n         while (!pto->mapAskFor.empty() && (*pto->mapAskFor.begin()).first <= nNow)\n         {\n             const CInv& inv = (*pto->mapAskFor.begin()).second;\n-            if (!AlreadyHave(coinsdb, inv))\n+            if (!AlreadyHave(inv))\n             {\n                 if (fDebugNet)\n                     printf(\"sending getdata: %s\\n\", inv.ToString().c_str());\n@@ -3621,9 +3595,7 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n     int64 nFees = 0;\n     {\n         LOCK2(cs_main, mempool.cs);\n-        CCoinsDB coinsdb(\"r\");\n-        CCoinsViewDB viewdb(coinsdb);\n-        CCoinsViewCache view(viewdb);\n+        CCoinsViewCache view(*pcoinsTip, true);\n \n         // Priority order to process transactions\n         list<COrphan> vOrphan; // list memory doesn't move\n@@ -3811,7 +3783,7 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n         CBlockIndex indexDummy(*pblock);\n         indexDummy.pprev = pindexPrev;\n         indexDummy.nHeight = pindexPrev->nHeight + 1;\n-        CCoinsViewCache viewNew(viewdb);\n+        CCoinsViewCache viewNew(*pcoinsTip, true);\n         if (!pblock->ConnectBlock(&indexDummy, viewNew, true))\n             throw std::runtime_error(\"CreateNewBlock() : ConnectBlock failed\");\n     }"
      },
      {
        "sha": "0ec68b612ba514b651580da6407e82efbf76eca6",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 10,
        "deletions": 20,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69a9db3639263eb38b2d2dcb7a394b26745dce72/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69a9db3639263eb38b2d2dcb7a394b26745dce72/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=69a9db3639263eb38b2d2dcb7a394b26745dce72",
        "patch": "@@ -583,7 +583,7 @@ class CTransaction\n     bool CheckTransaction() const;\n \n     // Try to accept this transaction into the memory pool\n-    bool AcceptToMemoryPool(CCoinsDB& coinsdb, bool fCheckInputs=true, bool* pfMissingInputs=NULL);\n+    bool AcceptToMemoryPool(bool fCheckInputs=true, bool* pfMissingInputs=NULL);\n \n protected:\n     static CTxOut GetOutputFor(const CTxIn& input, CCoinsView& mapInputs);\n@@ -682,6 +682,7 @@ class CBlockUndo\n \n     bool WriteToDisk(CDiskBlockPos &pos)\n     {\n+\n         // Open history file to append\n         CAutoFile fileout = CAutoFile(OpenUndoFile(pos), SER_DISK, CLIENT_VERSION);\n         if (!fileout)\n@@ -995,8 +996,7 @@ class CMerkleTx : public CTransaction\n     int GetDepthInMainChain() const { CBlockIndex *pindexRet; return GetDepthInMainChain(pindexRet); }\n     bool IsInMainChain() const { return GetDepthInMainChain() > 0; }\n     int GetBlocksToMaturity() const;\n-    bool AcceptToMemoryPool(CCoinsDB& coinsdb, bool fCheckInputs=true);\n-    bool AcceptToMemoryPool();\n+    bool AcceptToMemoryPool(bool fCheckInputs=true);\n };\n \n \n@@ -1676,8 +1676,7 @@ class CTxMemPool\n     std::map<uint256, CTransaction> mapTx;\n     std::map<COutPoint, CInPoint> mapNextTx;\n \n-    bool accept(CCoinsDB& coinsdb, CTransaction &tx,\n-                bool fCheckInputs, bool* pfMissingInputs);\n+    bool accept(CTransaction &tx, bool fCheckInputs, bool* pfMissingInputs);\n     bool addUnchecked(const uint256& hash, CTransaction &tx);\n     bool remove(CTransaction &tx);\n     void clear();\n@@ -1722,6 +1721,7 @@ class CCoinsView\n \n     // Modify the currently active block index\n     virtual bool SetBestBlock(CBlockIndex *pindex);\n+    virtual bool BatchWrite(const std::map<uint256, CCoins> &mapCoins, CBlockIndex *pindex);\n };\n \n /** CCoinsView backed by another CCoinsView */\n@@ -1738,21 +1738,7 @@ class CCoinsViewBacked : public CCoinsView\n     CBlockIndex *GetBestBlock();\n     bool SetBestBlock(CBlockIndex *pindex);\n     void SetBackend(CCoinsView &viewIn);\n-};\n-\n-\n-/** CCoinsView backed by a CCoinsDB */\n-class CCoinsViewDB : public CCoinsView\n-{\n-protected:\n-    CCoinsDB &db;\n-public:\n-    CCoinsViewDB(CCoinsDB &dbIn);\n-    bool GetCoins(uint256 txid, CCoins &coins);\n-    bool SetCoins(uint256 txid, const CCoins &coins);\n-    bool HaveCoins(uint256 txid);\n-    CBlockIndex *GetBestBlock();\n-    bool SetBestBlock(CBlockIndex *pindex);\n+    bool BatchWrite(const std::map<uint256, CCoins> &mapCoins, CBlockIndex *pindex);\n };\n \n /** CCoinsView that adds a memory cache for transactions to another CCoinsView */\n@@ -1769,7 +1755,9 @@ class CCoinsViewCache : public CCoinsViewBacked\n     bool HaveCoins(uint256 txid);\n     CBlockIndex *GetBestBlock();\n     bool SetBestBlock(CBlockIndex *pindex);\n+    bool BatchWrite(const std::map<uint256, CCoins> &mapCoins, CBlockIndex *pindex);\n     bool Flush();\n+    unsigned int GetCacheSize();\n };\n \n /** CCoinsView that brings transactions from a memorypool into view.\n@@ -1785,4 +1773,6 @@ class CCoinsViewMemPool : public CCoinsViewBacked\n     bool HaveCoins(uint256 txid);\n };\n \n+extern CCoinsViewCache *pcoinsTip;\n+\n #endif"
      },
      {
        "sha": "e358c12e96f3d2a44e6a3ccc0624e57700a5eaa4",
        "filename": "src/qt/transactiondesc.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 4,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69a9db3639263eb38b2d2dcb7a394b26745dce72/src/qt/transactiondesc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69a9db3639263eb38b2d2dcb7a394b26745dce72/src/qt/transactiondesc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiondesc.cpp?ref=69a9db3639263eb38b2d2dcb7a394b26745dce72",
        "patch": "@@ -234,9 +234,6 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx)\n             strHTML += \"<br><b>\" + tr(\"Transaction\") + \":</b><br>\";\n             strHTML += GUIUtil::HtmlEscape(wtx.ToString(), true);\n \n-            CCoinsDB coindb(\"r\"); // To fetch source txouts\n-            CCoinsViewDB coins(coindb);\n-\n             strHTML += \"<br><b>\" + tr(\"Inputs\") + \":</b>\";\n             strHTML += \"<ul>\";\n \n@@ -247,7 +244,7 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx)\n                     COutPoint prevout = txin.prevout;\n \n                     CCoins prev;\n-                    if(coins.GetCoins(prevout.hash, prev))\n+                    if(pcoinsTip->GetCoins(prevout.hash, prev))\n                     {\n                         if (prevout.n < prev.vout.size())\n                         {"
      },
      {
        "sha": "0270b5f102566316d35323c97be097c5b8cd5bdd",
        "filename": "src/rpcmining.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69a9db3639263eb38b2d2dcb7a394b26745dce72/src/rpcmining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69a9db3639263eb38b2d2dcb7a394b26745dce72/src/rpcmining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcmining.cpp?ref=69a9db3639263eb38b2d2dcb7a394b26745dce72",
        "patch": "@@ -281,9 +281,7 @@ Value getblocktemplate(const Array& params, bool fHelp)\n     Array transactions;\n     map<uint256, int64_t> setTxIndex;\n     int i = 0;\n-    CCoinsDB coindb(\"r\");\n-    CCoinsViewDB viewdb(coindb);\n-    CCoinsViewCache view(viewdb);\n+    CCoinsViewCache &view = *pcoinsTip;\n     BOOST_FOREACH (CTransaction& tx, pblock->vtx)\n     {\n         uint256 txHash = tx.GetHash();"
      },
      {
        "sha": "647384f3334bc6b2f07891c6f129408b7c81d74e",
        "filename": "src/rpcrawtransaction.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 11,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69a9db3639263eb38b2d2dcb7a394b26745dce72/src/rpcrawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69a9db3639263eb38b2d2dcb7a394b26745dce72/src/rpcrawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcrawtransaction.cpp?ref=69a9db3639263eb38b2d2dcb7a394b26745dce72",
        "patch": "@@ -339,9 +339,8 @@ Value signrawtransaction(const Array& params, bool fHelp)\n     CCoinsViewCache view(viewDummy);\n     {\n         LOCK(mempool.cs);\n-        CCoinsDB coinsdb(\"r\");\n-        CCoinsViewDB viewDB(coinsdb);\n-        CCoinsViewMemPool viewMempool(viewDB, mempool);\n+        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewMemPool viewMempool(viewChain, mempool);\n         view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n \n         BOOST_FOREACH(const CTxIn& txin, mergedTx.vin) {\n@@ -350,7 +349,7 @@ Value signrawtransaction(const Array& params, bool fHelp)\n             view.GetCoins(prevHash, coins); // this is certainly allowed to fail\n         }\n \n-        view.SetBackend(viewDummy); // switch back to avoid locking db/mempool too long\n+        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n     }\n \n     // Add previous txouts given in the RPC call:\n@@ -502,17 +501,13 @@ Value sendrawtransaction(const Array& params, bool fHelp)\n     uint256 hashTx = tx.GetHash();\n \n     bool fHave = false;\n+    CCoinsViewCache &view = *pcoinsTip;\n     CCoins existingCoins;\n     {\n-        CCoinsDB coinsdb(\"r\");\n-        {\n-            CCoinsViewDB coinsviewDB(coinsdb);\n-            CCoinsViewMemPool coinsview(coinsviewDB, mempool);\n-            fHave = coinsview.GetCoins(hashTx, existingCoins);\n-        }\n+        fHave = view.GetCoins(hashTx, existingCoins);\n         if (!fHave) {\n             // push to local node\n-            if (!tx.AcceptToMemoryPool(coinsdb))\n+            if (!tx.AcceptToMemoryPool())\n                 throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX rejected\");\n         }\n     }"
      },
      {
        "sha": "5b32034696a14a59481adf35cf031373e1cf7e5a",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 14,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69a9db3639263eb38b2d2dcb7a394b26745dce72/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69a9db3639263eb38b2d2dcb7a394b26745dce72/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=69a9db3639263eb38b2d2dcb7a394b26745dce72",
        "patch": "@@ -767,7 +767,6 @@ int CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate)\n \n void CWallet::ReacceptWalletTransactions()\n {\n-    CCoinsDB coinsdb(\"r\");\n     bool fRepeat = true;\n     while (fRepeat)\n     {\n@@ -782,7 +781,7 @@ void CWallet::ReacceptWalletTransactions()\n \n             CCoins coins;\n             bool fUpdated = false;\n-            bool fNotFound = coinsdb.ReadCoins(wtx.GetHash(), coins);\n+            bool fNotFound = pcoinsTip->GetCoins(wtx.GetHash(), coins);\n             if (!fNotFound || wtx.GetDepthInMainChain() > 0)\n             {\n                 // Update fSpent if a tx got spent somewhere else by a copy of wallet.dat\n@@ -808,7 +807,7 @@ void CWallet::ReacceptWalletTransactions()\n             {\n                 // Re-accept any txes of ours that aren't already in a block\n                 if (!wtx.IsCoinBase())\n-                    wtx.AcceptWalletTransaction(coinsdb, false);\n+                    wtx.AcceptWalletTransaction(false);\n             }\n         }\n         if (fMissing)\n@@ -820,34 +819,29 @@ void CWallet::ReacceptWalletTransactions()\n     }\n }\n \n-void CWalletTx::RelayWalletTransaction(CCoinsDB& coinsdb)\n+void CWalletTx::RelayWalletTransaction()\n {\n+    CCoinsViewCache& coins = *pcoinsTip;\n     BOOST_FOREACH(const CMerkleTx& tx, vtxPrev)\n     {\n         if (!tx.IsCoinBase())\n         {\n             uint256 hash = tx.GetHash();\n-            if (!coinsdb.HaveCoins(hash))\n+            if (!coins.HaveCoins(hash))\n                 RelayMessage(CInv(MSG_TX, hash), (CTransaction)tx);\n         }\n     }\n     if (!IsCoinBase())\n     {\n         uint256 hash = GetHash();\n-        if (!coinsdb.HaveCoins(hash))\n+        if (!coins.HaveCoins(hash))\n         {\n             printf(\"Relaying wtx %s\\n\", hash.ToString().substr(0,10).c_str());\n             RelayMessage(CInv(MSG_TX, hash), (CTransaction)*this);\n         }\n     }\n }\n \n-void CWalletTx::RelayWalletTransaction()\n-{\n-   CCoinsDB coinsdb(\"r\");\n-   RelayWalletTransaction(coinsdb);\n-}\n-\n void CWallet::ResendWalletTransactions()\n {\n     // Do this infrequently and randomly to avoid giving away\n@@ -868,7 +862,6 @@ void CWallet::ResendWalletTransactions()\n \n     // Rebroadcast any of our txes that aren't in a block yet\n     printf(\"ResendWalletTransactions()\\n\");\n-    CCoinsDB coinsdb(\"r\");\n     {\n         LOCK(cs_wallet);\n         // Sort them in chronological order\n@@ -884,7 +877,7 @@ void CWallet::ResendWalletTransactions()\n         BOOST_FOREACH(PAIRTYPE(const unsigned int, CWalletTx*)& item, mapSorted)\n         {\n             CWalletTx& wtx = *item.second;\n-            wtx.RelayWalletTransaction(coinsdb);\n+            wtx.RelayWalletTransaction();\n         }\n     }\n }"
      },
      {
        "sha": "8c98f34a5afaaf87b00a2230fa5f0454b3fdb09c",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 1,
        "deletions": 5,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/69a9db3639263eb38b2d2dcb7a394b26745dce72/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/69a9db3639263eb38b2d2dcb7a394b26745dce72/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=69a9db3639263eb38b2d2dcb7a394b26745dce72",
        "patch": "@@ -659,11 +659,7 @@ class CWalletTx : public CMerkleTx\n     int GetRequestCount() const;\n \n     void AddSupportingTransactions();\n-\n-    bool AcceptWalletTransaction(CCoinsDB& coinsdb, bool fCheckInputs=true);\n-    bool AcceptWalletTransaction();\n-\n-    void RelayWalletTransaction(CCoinsDB& coinsdb);\n+    bool AcceptWalletTransaction(bool fCheckInputs=true);\n     void RelayWalletTransaction();\n };\n "
      }
    ]
  },
  {
    "sha": "e84145a0c6444cd0065105f3059493a4c7a1a742",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplODQxNDVhMGM2NDQ0Y2QwMDY1MTA1ZjMwNTk0OTNhNGM3YTFhNzQy",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-07-07T22:06:34Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-20T13:39:12Z"
      },
      "message": "Transaction hash caching\n\nUse CBlock's vMerkleTree to cache transaction hashes, and pass them\nalong as argument in more function calls. During initial block download,\nthis results in every transaction's hash to be only computed once.",
      "tree": {
        "sha": "40b287fafe4b309c0dd6e20cc44746e04d267f3c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/40b287fafe4b309c0dd6e20cc44746e04d267f3c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e84145a0c6444cd0065105f3059493a4c7a1a742",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e84145a0c6444cd0065105f3059493a4c7a1a742",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e84145a0c6444cd0065105f3059493a4c7a1a742",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e84145a0c6444cd0065105f3059493a4c7a1a742/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "69a9db3639263eb38b2d2dcb7a394b26745dce72",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/69a9db3639263eb38b2d2dcb7a394b26745dce72",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/69a9db3639263eb38b2d2dcb7a394b26745dce72"
      }
    ],
    "stats": {
      "total": 59,
      "additions": 32,
      "deletions": 27
    },
    "files": [
      {
        "sha": "a4f90dda71a29f2d4872e140f47e7778ad8af4e6",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 20,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e84145a0c6444cd0065105f3059493a4c7a1a742/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e84145a0c6444cd0065105f3059493a4c7a1a742/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=e84145a0c6444cd0065105f3059493a4c7a1a742",
        "patch": "@@ -111,10 +111,10 @@ void static EraseFromWallets(uint256 hash)\n }\n \n // make sure all wallets know about the given transaction, in the given block\n-void SyncWithWallets(const CTransaction& tx, const CBlock* pblock, bool fUpdate)\n+void SyncWithWallets(const uint256 &hash, const CTransaction& tx, const CBlock* pblock, bool fUpdate)\n {\n     BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n-        pwallet->AddToWalletIfInvolvingMe(tx, pblock, fUpdate);\n+        pwallet->AddToWalletIfInvolvingMe(hash, tx, pblock, fUpdate);\n }\n \n // notify wallets about a new best chain\n@@ -1197,10 +1197,8 @@ unsigned int CTransaction::GetP2SHSigOpCount(CCoinsView& inputs) const\n     return nSigOps;\n }\n \n-bool CTransaction::UpdateCoins(CCoinsView &inputs, CTxUndo &txundo, int nHeight) const\n+bool CTransaction::UpdateCoins(CCoinsView &inputs, CTxUndo &txundo, int nHeight, const uint256 &txhash) const\n {\n-    uint256 hash = GetHash();\n-\n     // mark inputs spent\n     if (!IsCoinBase()) {\n         BOOST_FOREACH(const CTxIn &txin, vin) {\n@@ -1217,7 +1215,7 @@ bool CTransaction::UpdateCoins(CCoinsView &inputs, CTxUndo &txundo, int nHeight)\n     }\n \n     // add outputs\n-    if (!inputs.SetCoins(hash, CCoins(*this, nHeight)))\n+    if (!inputs.SetCoins(txhash, CCoins(*this, nHeight)))\n         return error(\"UpdateCoins() : cannot update output\");\n \n     return true;\n@@ -1467,8 +1465,8 @@ bool CBlock::ConnectBlock(CBlockIndex* pindex, CCoinsView &view, bool fJustCheck\n     bool fEnforceBIP30 = !((pindex->nHeight==91842 && pindex->GetBlockHash() == uint256(\"0x00000000000a4d0a398161ffc163c503763b1f4360639393e0e4c8e300e0caec\")) ||\n                            (pindex->nHeight==91880 && pindex->GetBlockHash() == uint256(\"0x00000000000743f190a18c5577a3c2d2a1f610ae9601ac046a38084ccb7cd721\")));\n     if (fEnforceBIP30) {\n-        BOOST_FOREACH(CTransaction& tx, vtx) {\n-            uint256 hash = tx.GetHash();\n+        for (unsigned int i=0; i<vtx.size(); i++) {\n+            uint256 hash = GetTxHash(i);\n             CCoins coins;\n             if (view.GetCoins(hash, coins) && !coins.IsPruned())\n                 return error(\"ConnectBlock() : tried to overwrite transaction\");\n@@ -1483,8 +1481,10 @@ bool CBlock::ConnectBlock(CBlockIndex* pindex, CCoinsView &view, bool fJustCheck\n \n     int64 nFees = 0;\n     unsigned int nSigOps = 0;\n-    BOOST_FOREACH(CTransaction& tx, vtx)\n+    for (unsigned int i=0; i<vtx.size(); i++)\n     {\n+        const CTransaction &tx = vtx[i];\n+\n         nSigOps += tx.GetLegacySigOpCount();\n         if (nSigOps > MAX_BLOCK_SIGOPS)\n             return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n@@ -1511,7 +1511,7 @@ bool CBlock::ConnectBlock(CBlockIndex* pindex, CCoinsView &view, bool fJustCheck\n         }\n \n         CTxUndo txundo;\n-        if (!tx.UpdateCoins(view, txundo, pindex->nHeight))\n+        if (!tx.UpdateCoins(view, txundo, pindex->nHeight, GetTxHash(i)))\n             return error(\"ConnectBlock() : UpdateInputs failed\");\n         if (!tx.IsCoinBase())\n             blockundo.vtxundo.push_back(txundo);\n@@ -1542,8 +1542,8 @@ bool CBlock::ConnectBlock(CBlockIndex* pindex, CCoinsView &view, bool fJustCheck\n         return false;\n \n     // Watch for transactions paying to me\n-    BOOST_FOREACH(CTransaction& tx, vtx)\n-        SyncWithWallets(tx, this, true);\n+    for (unsigned int i=0; i<vtx.size(); i++)\n+        SyncWithWallets(GetTxHash(i), vtx[i], this, true);\n \n     return true;\n }\n@@ -1755,7 +1755,7 @@ bool CBlock::AddToBlockIndex(const CDiskBlockPos &pos)\n         // Notify UI to display prev block's coinbase if it was ours\n         static uint256 hashPrevBestCoinBase;\n         UpdatedTransaction(hashPrevBestCoinBase);\n-        hashPrevBestCoinBase = vtx[0].GetHash();\n+        hashPrevBestCoinBase = GetTxHash(0);\n     }\n \n     uiInterface.NotifyBlocksChanged();\n@@ -1876,10 +1876,10 @@ bool CBlock::CheckBlock(bool fCheckPOW, bool fCheckMerkleRoot) const\n \n     // Check for duplicate txids. This is caught by ConnectInputs(),\n     // but catching it earlier avoids a potential DoS attack:\n+    BuildMerkleTree();\n     set<uint256> uniqueTx;\n-    BOOST_FOREACH(const CTransaction& tx, vtx)\n-    {\n-        uniqueTx.insert(tx.GetHash());\n+    for (unsigned int i=0; i<vtx.size(); i++) {\n+        uniqueTx.insert(GetTxHash(i));\n     }\n     if (uniqueTx.size() != vtx.size())\n         return DoS(100, error(\"CheckBlock() : duplicate transaction\"));\n@@ -2914,7 +2914,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         bool fMissingInputs = false;\n         if (tx.AcceptToMemoryPool(true, &fMissingInputs))\n         {\n-            SyncWithWallets(tx, NULL, true);\n+            SyncWithWallets(inv.hash, tx, NULL, true);\n             RelayMessage(inv, vMsg);\n             mapAlreadyAskedFor.erase(inv);\n             vWorkQueue.push_back(inv.hash);\n@@ -2937,7 +2937,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n                     if (tx.AcceptToMemoryPool(true, &fMissingInputs2))\n                     {\n                         printf(\"   accepted orphan tx %s\\n\", inv.hash.ToString().substr(0,10).c_str());\n-                        SyncWithWallets(tx, NULL, true);\n+                        SyncWithWallets(inv.hash, tx, NULL, true);\n                         RelayMessage(inv, vMsg);\n                         mapAlreadyAskedFor.erase(inv);\n                         vWorkQueue.push_back(inv.hash);\n@@ -3729,7 +3729,8 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n                 continue;\n \n             CTxUndo txundo;\n-            if (!tx.UpdateCoins(viewTemp, txundo, pindexPrev->nHeight+1))\n+            uint256 hash = tx.GetHash();\n+            if (!tx.UpdateCoins(viewTemp, txundo, pindexPrev->nHeight+1, hash))\n                 continue;\n \n             // push changes from the second layer cache to the first one\n@@ -3749,7 +3750,6 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n             }\n \n             // Add transactions that depend on this one to the priority queue\n-            uint256 hash = tx.GetHash();\n             if (mapDependers.count(hash))\n             {\n                 BOOST_FOREACH(COrphan* porphan, mapDependers[hash])"
      },
      {
        "sha": "3ee0108f465cab7a34b4f8e2a908ae94ca59e6f0",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e84145a0c6444cd0065105f3059493a4c7a1a742/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e84145a0c6444cd0065105f3059493a4c7a1a742/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=e84145a0c6444cd0065105f3059493a4c7a1a742",
        "patch": "@@ -91,7 +91,7 @@ class CCoinsView;\n \n void RegisterWallet(CWallet* pwalletIn);\n void UnregisterWallet(CWallet* pwalletIn);\n-void SyncWithWallets(const CTransaction& tx, const CBlock* pblock = NULL, bool fUpdate = false);\n+void SyncWithWallets(const uint256 &hash, const CTransaction& tx, const CBlock* pblock = NULL, bool fUpdate = false);\n bool ProcessBlock(CNode* pfrom, CBlock* pblock);\n bool CheckDiskSpace(uint64 nAdditionalBytes=0);\n FILE* OpenBlockFile(const CDiskBlockPos &pos, bool fReadOnly = false);\n@@ -577,7 +577,7 @@ class CTransaction\n     bool CheckInputs(CCoinsView &view, enum CheckSig_mode csmode, bool fStrictPayToScriptHash=true, bool fStrictEncodings=true) const;\n \n     // Apply the effects of this transaction on the UTXO set represented by view\n-    bool UpdateCoins(CCoinsView &view, CTxUndo &txundo, int nHeight) const;\n+    bool UpdateCoins(CCoinsView &view, CTxUndo &txundo, int nHeight, const uint256 &txhash) const;\n \n     // Context-independent validity checks\n     bool CheckTransaction() const;\n@@ -1111,6 +1111,12 @@ class CBlock\n         return (vMerkleTree.empty() ? 0 : vMerkleTree.back());\n     }\n \n+    const uint256 &GetTxHash(unsigned int nIndex) const {\n+        assert(vMerkleTree.size() > 0); // BuildMerkleTree must have been called first\n+        assert(nIndex < vtx.size());\n+        return vMerkleTree[nIndex];\n+    }\n+\n     std::vector<uint256> GetMerkleBranch(int nIndex) const\n     {\n         if (vMerkleTree.empty())"
      },
      {
        "sha": "72a89c08c168656d3491def5592a72555d10cfa0",
        "filename": "src/rpcrawtransaction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e84145a0c6444cd0065105f3059493a4c7a1a742/src/rpcrawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e84145a0c6444cd0065105f3059493a4c7a1a742/src/rpcrawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcrawtransaction.cpp?ref=e84145a0c6444cd0065105f3059493a4c7a1a742",
        "patch": "@@ -517,7 +517,7 @@ Value sendrawtransaction(const Array& params, bool fHelp)\n         // Not in block, but already in the memory pool; will drop\n         // through to re-relay it.\n     } else {\n-        SyncWithWallets(tx, NULL, true);\n+        SyncWithWallets(hashTx, tx, NULL, true);\n     }\n     RelayMessage(CInv(MSG_TX, hashTx), tx);\n "
      },
      {
        "sha": "1498ff28b7e8beb65f1e4a9e48f4639c67c0b556",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e84145a0c6444cd0065105f3059493a4c7a1a742/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e84145a0c6444cd0065105f3059493a4c7a1a742/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=e84145a0c6444cd0065105f3059493a4c7a1a742",
        "patch": "@@ -479,9 +479,8 @@ bool CWallet::AddToWallet(const CWalletTx& wtxIn)\n // Add a transaction to the wallet, or update it.\n // pblock is optional, but should be provided if the transaction is known to be in a block.\n // If fUpdate is true, existing transactions will be updated.\n-bool CWallet::AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlock* pblock, bool fUpdate, bool fFindBlock)\n+bool CWallet::AddToWalletIfInvolvingMe(const uint256 &hash, const CTransaction& tx, const CBlock* pblock, bool fUpdate, bool fFindBlock)\n {\n-    uint256 hash = tx.GetHash();\n     {\n         LOCK(cs_wallet);\n         bool fExisted = mapWallet.count(hash);\n@@ -756,7 +755,7 @@ int CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate)\n             block.ReadFromDisk(pindex, true);\n             BOOST_FOREACH(CTransaction& tx, block.vtx)\n             {\n-                if (AddToWalletIfInvolvingMe(tx, &block, fUpdate))\n+                if (AddToWalletIfInvolvingMe(tx.GetHash(), tx, &block, fUpdate))\n                     ret++;\n             }\n             pindex = pindex->pnext;"
      },
      {
        "sha": "43b695c59748918b79fd1ac58dd99d34a7aab769",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e84145a0c6444cd0065105f3059493a4c7a1a742/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e84145a0c6444cd0065105f3059493a4c7a1a742/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=e84145a0c6444cd0065105f3059493a4c7a1a742",
        "patch": "@@ -162,7 +162,7 @@ class CWallet : public CCryptoKeyStore\n \n     void MarkDirty();\n     bool AddToWallet(const CWalletTx& wtxIn);\n-    bool AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlock* pblock, bool fUpdate = false, bool fFindBlock = false);\n+    bool AddToWalletIfInvolvingMe(const uint256 &hash, const CTransaction& tx, const CBlock* pblock, bool fUpdate = false, bool fFindBlock = false);\n     bool EraseFromWallet(uint256 hash);\n     void WalletUpdateSpent(const CTransaction& prevout);\n     int ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate = false);"
      }
    ]
  },
  {
    "sha": "b6ac21afb55294c4c54697e190ad647b13d9d5bc",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiNmFjMjFhZmI1NTI5NGM0YzU0Njk3ZTE5MGFkNjQ3YjEzZDlkNWJj",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-07-08T17:04:05Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-20T13:39:12Z"
      },
      "message": "Direct CCoins references\n\nTo prevent excessive copying of CCoins in and out of the CCoinsView\nimplementations, introduce a GetCoins() function in CCoinsViewCache\nwith returns a direct reference. The block validation and connection\nlogic is updated to require caching CCoinsViews, and exploits the\nGetCoins() function heavily.",
      "tree": {
        "sha": "5f19cdc9ff4d01f620239156a3d87cbce60dc091",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5f19cdc9ff4d01f620239156a3d87cbce60dc091"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b6ac21afb55294c4c54697e190ad647b13d9d5bc",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b6ac21afb55294c4c54697e190ad647b13d9d5bc",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b6ac21afb55294c4c54697e190ad647b13d9d5bc",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b6ac21afb55294c4c54697e190ad647b13d9d5bc/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e84145a0c6444cd0065105f3059493a4c7a1a742",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e84145a0c6444cd0065105f3059493a4c7a1a742",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e84145a0c6444cd0065105f3059493a4c7a1a742"
      }
    ],
    "stats": {
      "total": 128,
      "additions": 67,
      "deletions": 61
    },
    "files": [
      {
        "sha": "42f70c023c8fa11c207da1125a75b3e9125b94f5",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 53,
        "deletions": 49,
        "changes": 102,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b6ac21afb55294c4c54697e190ad647b13d9d5bc/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b6ac21afb55294c4c54697e190ad647b13d9d5bc/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=b6ac21afb55294c4c54697e190ad647b13d9d5bc",
        "patch": "@@ -170,6 +170,7 @@ CBlockIndex *CCoinsView::GetBestBlock() { return NULL; }\n bool CCoinsView::SetBestBlock(CBlockIndex *pindex) { return false; }\n bool CCoinsView::BatchWrite(const std::map<uint256, CCoins> &mapCoins, CBlockIndex *pindex) { return false; }\n \n+\n CCoinsViewBacked::CCoinsViewBacked(CCoinsView &viewIn) : base(&viewIn) { }\n bool CCoinsViewBacked::GetCoins(uint256 txid, CCoins &coins) { return base->GetCoins(txid, coins); }\n bool CCoinsViewBacked::SetCoins(uint256 txid, const CCoins &coins) { return base->SetCoins(txid, coins); }\n@@ -193,13 +194,30 @@ bool CCoinsViewCache::GetCoins(uint256 txid, CCoins &coins) {\n     return false;\n }\n \n+std::map<uint256,CCoins>::iterator CCoinsViewCache::FetchCoins(uint256 txid) {\n+    std::map<uint256,CCoins>::iterator it = cacheCoins.find(txid);\n+    if (it != cacheCoins.end())\n+        return it;\n+    CCoins tmp;\n+    if (!base->GetCoins(txid,tmp))\n+        return it;\n+    std::pair<std::map<uint256,CCoins>::iterator,bool> ret = cacheCoins.insert(std::make_pair(txid, tmp));\n+    return ret.first;\n+}\n+\n+CCoins &CCoinsViewCache::GetCoins(uint256 txid) {\n+    std::map<uint256,CCoins>::iterator it = FetchCoins(txid);\n+    assert(it != cacheCoins.end());\n+    return it->second;\n+}\n+\n bool CCoinsViewCache::SetCoins(uint256 txid, const CCoins &coins) {\n     cacheCoins[txid] = coins;\n     return true;\n }\n \n bool CCoinsViewCache::HaveCoins(uint256 txid) {\n-    return cacheCoins.count(txid) || base->HaveCoins(txid);\n+    return FetchCoins(txid) != cacheCoins.end();\n }\n \n CBlockIndex *CCoinsViewCache::GetBestBlock() {\n@@ -369,7 +387,7 @@ bool CTransaction::IsStandard() const\n // expensive-to-check-upon-redemption script like:\n //   DUP CHECKSIG DROP ... repeated 100 times... OP_1\n //\n-bool CTransaction::AreInputsStandard(CCoinsView& mapInputs) const\n+bool CTransaction::AreInputsStandard(CCoinsViewCache& mapInputs) const\n {\n     if (IsCoinBase())\n         return true; // Coinbases don't use vin normally\n@@ -683,6 +701,9 @@ bool CTxMemPool::accept(CTransaction &tx, bool fCheckInputs,\n             }\n         }\n \n+        if (!tx.HaveInputs(view))\n+            return error(\"CTxMemPool::accept() : inputs already spent\");\n+\n         // Check for non-standard pay-to-script-hash in inputs\n         if (!tx.AreInputsStandard(view) && !fTestNet)\n             return error(\"CTxMemPool::accept() : nonstandard transaction input\");\n@@ -1154,23 +1175,14 @@ void CBlock::UpdateTime(const CBlockIndex* pindexPrev)\n \n \n \n-CTxOut CTransaction::GetOutputFor(const CTxIn& input, CCoinsView& view)\n+const CTxOut &CTransaction::GetOutputFor(const CTxIn& input, CCoinsViewCache& view)\n {\n-    CCoins coins;\n-    if (!view.GetCoins(input.prevout.hash, coins))\n-        throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.hash not found\");\n-\n-    if (input.prevout.n >= coins.vout.size())\n-        throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.n out of range or already spent\");\n-\n-    const CTxOut &out = coins.vout[input.prevout.n];\n-    if (out.IsNull())\n-        throw std::runtime_error(\"CTransaction::GetOutputFor() : already spent\");\n-\n-    return out;\n+    const CCoins &coins = view.GetCoins(input.prevout.hash);\n+    assert(coins.IsAvailable(input.prevout.n));\n+    return coins.vout[input.prevout.n];\n }\n \n-int64 CTransaction::GetValueIn(CCoinsView& inputs) const\n+int64 CTransaction::GetValueIn(CCoinsViewCache& inputs) const\n {\n     if (IsCoinBase())\n         return 0;\n@@ -1182,35 +1194,31 @@ int64 CTransaction::GetValueIn(CCoinsView& inputs) const\n     return nResult;\n }\n \n-unsigned int CTransaction::GetP2SHSigOpCount(CCoinsView& inputs) const\n+unsigned int CTransaction::GetP2SHSigOpCount(CCoinsViewCache& inputs) const\n {\n     if (IsCoinBase())\n         return 0;\n \n     unsigned int nSigOps = 0;\n     for (unsigned int i = 0; i < vin.size(); i++)\n     {\n-        CTxOut prevout = GetOutputFor(vin[i], inputs);\n+        const CTxOut &prevout = GetOutputFor(vin[i], inputs);\n         if (prevout.scriptPubKey.IsPayToScriptHash())\n             nSigOps += prevout.scriptPubKey.GetSigOpCount(vin[i].scriptSig);\n     }\n     return nSigOps;\n }\n \n-bool CTransaction::UpdateCoins(CCoinsView &inputs, CTxUndo &txundo, int nHeight, const uint256 &txhash) const\n+bool CTransaction::UpdateCoins(CCoinsViewCache &inputs, CTxUndo &txundo, int nHeight, const uint256 &txhash) const\n {\n     // mark inputs spent\n     if (!IsCoinBase()) {\n         BOOST_FOREACH(const CTxIn &txin, vin) {\n-            CCoins coins;\n-            if (!inputs.GetCoins(txin.prevout.hash, coins))\n-                return error(\"UpdateCoins() : cannot find prevtx\");\n+            CCoins &coins = inputs.GetCoins(txin.prevout.hash);\n             CTxInUndo undo;\n             if (!coins.Spend(txin.prevout, undo))\n                 return error(\"UpdateCoins() : cannot spend input\");\n             txundo.vprevout.push_back(undo);\n-            if (!inputs.SetCoins(txin.prevout.hash, coins))\n-                return error(\"UpdateCoins() : cannot update input\");\n         }\n     }\n \n@@ -1221,7 +1229,7 @@ bool CTransaction::UpdateCoins(CCoinsView &inputs, CTxUndo &txundo, int nHeight,\n     return true;\n }\n \n-bool CTransaction::HaveInputs(CCoinsView &inputs) const\n+bool CTransaction::HaveInputs(CCoinsViewCache &inputs) const\n {\n     if (!IsCoinBase()) { \n         // first check whether information about the prevout hash is available\n@@ -1234,37 +1242,33 @@ bool CTransaction::HaveInputs(CCoinsView &inputs) const\n         // then check whether the actual outputs are available\n         for (unsigned int i = 0; i < vin.size(); i++) {\n             const COutPoint &prevout = vin[i].prevout;\n-            CCoins coins;\n-            inputs.GetCoins(prevout.hash, coins);\n+            const CCoins &coins = inputs.GetCoins(prevout.hash);\n             if (!coins.IsAvailable(prevout.n))\n                 return false;\n         }\n     }\n     return true;\n }\n \n-bool CTransaction::CheckInputs(CCoinsView &inputs, enum CheckSig_mode csmode, bool fStrictPayToScriptHash, bool fStrictEncodings) const\n+bool CTransaction::CheckInputs(CCoinsViewCache &inputs, enum CheckSig_mode csmode, bool fStrictPayToScriptHash, bool fStrictEncodings) const\n {\n     if (!IsCoinBase())\n     {\n+        // This doesn't trigger the DoS code on purpose; if it did, it would make it easier\n+        // for an attacker to attempt to split the network.\n+        if (!HaveInputs(inputs))\n+            return error(\"CheckInputs() : %s inputs unavailable\", GetHash().ToString().substr(0,10).c_str());\n+\n+        CBlockIndex *pindexBlock = inputs.GetBestBlock();\n         int64 nValueIn = 0;\n         int64 nFees = 0;\n         for (unsigned int i = 0; i < vin.size(); i++)\n         {\n             const COutPoint &prevout = vin[i].prevout;\n-            CCoins coins;\n-            if (!inputs.GetCoins(prevout.hash, coins))\n-                return error(\"CheckInputs() : cannot find prevout tx\");\n-\n-            // Check for conflicts (double-spend)\n-            // This doesn't trigger the DoS code on purpose; if it did, it would make it easier\n-            // for an attacker to attempt to split the network.\n-            if (!coins.IsAvailable(prevout.n))\n-                return error(\"CheckInputs() : %s prev tx already used\", GetHash().ToString().substr(0,10).c_str());\n+            const CCoins &coins = inputs.GetCoins(prevout.hash);\n \n             // If prev is coinbase, check that it's matured\n             if (coins.IsCoinBase()) {\n-                CBlockIndex *pindexBlock = inputs.GetBestBlock();\n                 if (pindexBlock->nHeight - coins.nHeight < COINBASE_MATURITY)\n                     return error(\"CheckInputs() : tried to spend coinbase at depth %d\", pindexBlock->nHeight - coins.nHeight);\n             }\n@@ -1298,8 +1302,7 @@ bool CTransaction::CheckInputs(CCoinsView &inputs, enum CheckSig_mode csmode, bo\n             (csmode == CS_AFTER_CHECKPOINT && inputs.GetBestBlock()->nHeight >= Checkpoints::GetTotalBlocksEstimate())) {\n             for (unsigned int i = 0; i < vin.size(); i++) {\n                 const COutPoint &prevout = vin[i].prevout;\n-                CCoins coins;\n-                inputs.GetCoins(prevout.hash, coins);\n+                const CCoins &coins = inputs.GetCoins(prevout.hash);\n \n                 // Verify signature\n                 if (!VerifySignature(coins, *this, i, fStrictPayToScriptHash, fStrictEncodings, 0)) {\n@@ -1367,7 +1370,7 @@ bool CTransaction::ClientCheckInputs() const\n \n \n \n-bool CBlock::DisconnectBlock(CBlockIndex *pindex, CCoinsView &view)\n+bool CBlock::DisconnectBlock(CBlockIndex *pindex, CCoinsViewCache &view)\n {\n     assert(pindex == view.GetBestBlock());\n \n@@ -1391,17 +1394,16 @@ bool CBlock::DisconnectBlock(CBlockIndex *pindex, CCoinsView &view)\n         uint256 hash = tx.GetHash();\n \n         // check that all outputs are available\n-        CCoins outs;\n-        if (!view.GetCoins(hash, outs))\n+        if (!view.HaveCoins(hash))\n             return error(\"DisconnectBlock() : outputs still spent? database corrupted\");\n+        CCoins &outs = view.GetCoins(hash);\n \n         CCoins outsBlock = CCoins(tx, pindex->nHeight);\n         if (outs != outsBlock)\n             return error(\"DisconnectBlock() : added transaction mismatch? database corrupted\");\n \n         // remove outputs\n-        if (!view.SetCoins(hash, CCoins()))\n-            return error(\"DisconnectBlock() : cannot delete coin outputs\");\n+        outs = CCoins();\n \n         // restore inputs\n         if (i > 0) { // not coinbases\n@@ -1441,7 +1443,7 @@ bool CBlock::DisconnectBlock(CBlockIndex *pindex, CCoinsView &view)\n \n bool FindUndoPos(CChainDB &chaindb, int nFile, CDiskBlockPos &pos, unsigned int nAddSize);\n \n-bool CBlock::ConnectBlock(CBlockIndex* pindex, CCoinsView &view, bool fJustCheck)\n+bool CBlock::ConnectBlock(CBlockIndex* pindex, CCoinsViewCache &view, bool fJustCheck)\n {\n     // Check it again in case a previous version let a bad block in\n     if (!CheckBlock(!fJustCheck, !fJustCheck))\n@@ -1467,8 +1469,7 @@ bool CBlock::ConnectBlock(CBlockIndex* pindex, CCoinsView &view, bool fJustCheck\n     if (fEnforceBIP30) {\n         for (unsigned int i=0; i<vtx.size(); i++) {\n             uint256 hash = GetTxHash(i);\n-            CCoins coins;\n-            if (view.GetCoins(hash, coins) && !coins.IsPruned())\n+            if (view.HaveCoins(hash) && !view.GetCoins(hash).IsPruned())\n                 return error(\"ConnectBlock() : tried to overwrite transaction\");\n         }\n     }\n@@ -3719,7 +3720,7 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n                 std::make_heap(vecPriority.begin(), vecPriority.end(), comparer);\n             }\n \n-            if (!tx.CheckInputs(viewTemp, CS_ALWAYS, true, false))\n+            if (!tx.HaveInputs(viewTemp))\n                 continue;\n \n             int64 nTxFees = tx.GetValueIn(viewTemp)-tx.GetValueOut();\n@@ -3728,6 +3729,9 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n             if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)\n                 continue;\n \n+            if (!tx.CheckInputs(viewTemp, CS_ALWAYS, true, false))\n+                continue;\n+\n             CTxUndo txundo;\n             uint256 hash = tx.GetHash();\n             if (!tx.UpdateCoins(viewTemp, txundo, pindexPrev->nHeight+1, hash))"
      },
      {
        "sha": "1150ca4c0251dc223c298711c2427f2f7e290ee4",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 14,
        "deletions": 9,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b6ac21afb55294c4c54697e190ad647b13d9d5bc/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b6ac21afb55294c4c54697e190ad647b13d9d5bc/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=b6ac21afb55294c4c54697e190ad647b13d9d5bc",
        "patch": "@@ -88,6 +88,7 @@ class CDiskBlockPos;\n class CCoins;\n class CTxUndo;\n class CCoinsView;\n+class CCoinsViewCache;\n \n void RegisterWallet(CWallet* pwalletIn);\n void UnregisterWallet(CWallet* pwalletIn);\n@@ -480,7 +481,7 @@ class CTransaction\n         @return True if all inputs (scriptSigs) use only standard transaction forms\n         @see CTransaction::FetchInputs\n     */\n-    bool AreInputsStandard(CCoinsView& mapInputs) const;\n+    bool AreInputsStandard(CCoinsViewCache& mapInputs) const;\n \n     /** Count ECDSA signature operations the old-fashioned (pre-0.6) way\n         @return number of sigops this transaction's outputs will produce when spent\n@@ -494,7 +495,7 @@ class CTransaction\n         @return maximum number of sigops required to validate this transaction's inputs\n         @see CTransaction::FetchInputs\n      */\n-    unsigned int GetP2SHSigOpCount(CCoinsView& mapInputs) const;\n+    unsigned int GetP2SHSigOpCount(CCoinsViewCache& mapInputs) const;\n \n     /** Amount of bitcoins spent by this transaction.\n         @return sum of all outputs (note: does not include fees)\n@@ -519,7 +520,7 @@ class CTransaction\n         @return\tSum of value of all inputs (scriptSigs)\n         @see CTransaction::FetchInputs\n      */\n-    int64 GetValueIn(CCoinsView& mapInputs) const;\n+    int64 GetValueIn(CCoinsViewCache& mapInputs) const;\n \n     static bool AllowFree(double dPriority)\n     {\n@@ -570,14 +571,14 @@ class CTransaction\n     bool ClientCheckInputs() const;\n \n     // Check whether all prevouts of this transaction are present in the UTXO set represented by view\n-    bool HaveInputs(CCoinsView &view) const;\n+    bool HaveInputs(CCoinsViewCache &view) const;\n \n     // Check whether all inputs of this transaction are valid (no double spends, scripts & sigs, amounts)\n     // This does not modify the UTXO set\n-    bool CheckInputs(CCoinsView &view, enum CheckSig_mode csmode, bool fStrictPayToScriptHash=true, bool fStrictEncodings=true) const;\n+    bool CheckInputs(CCoinsViewCache &view, enum CheckSig_mode csmode, bool fStrictPayToScriptHash=true, bool fStrictEncodings=true) const;\n \n     // Apply the effects of this transaction on the UTXO set represented by view\n-    bool UpdateCoins(CCoinsView &view, CTxUndo &txundo, int nHeight, const uint256 &txhash) const;\n+    bool UpdateCoins(CCoinsViewCache &view, CTxUndo &txundo, int nHeight, const uint256 &txhash) const;\n \n     // Context-independent validity checks\n     bool CheckTransaction() const;\n@@ -586,7 +587,7 @@ class CTransaction\n     bool AcceptToMemoryPool(bool fCheckInputs=true, bool* pfMissingInputs=NULL);\n \n protected:\n-    static CTxOut GetOutputFor(const CTxIn& input, CCoinsView& mapInputs);\n+    static const CTxOut &GetOutputFor(const CTxIn& input, CCoinsViewCache& mapInputs);\n };\n \n /** wrapper for CTxOut that provides a more compact serialization */\n@@ -1225,10 +1226,10 @@ class CBlock\n \n \n     // Undo the effects of this block (with given index) on the UTXO set represented by coins\n-    bool DisconnectBlock(CBlockIndex *pindex, CCoinsView &coins);\n+    bool DisconnectBlock(CBlockIndex *pindex, CCoinsViewCache &coins);\n \n     // Apply the effects of this block (with given index) on the UTXO set represented by coins\n-    bool ConnectBlock(CBlockIndex *pindex, CCoinsView &coins, bool fJustCheck=false);\n+    bool ConnectBlock(CBlockIndex *pindex, CCoinsViewCache &coins, bool fJustCheck=false);\n \n     // Read a block from disk\n     bool ReadFromDisk(const CBlockIndex* pindex, bool fReadTransactions=true);\n@@ -1759,11 +1760,15 @@ class CCoinsViewCache : public CCoinsViewBacked\n     bool GetCoins(uint256 txid, CCoins &coins);\n     bool SetCoins(uint256 txid, const CCoins &coins);\n     bool HaveCoins(uint256 txid);\n+    CCoins &GetCoins(uint256 txid);\n     CBlockIndex *GetBestBlock();\n     bool SetBestBlock(CBlockIndex *pindex);\n     bool BatchWrite(const std::map<uint256, CCoins> &mapCoins, CBlockIndex *pindex);\n     bool Flush();\n     unsigned int GetCacheSize();\n+\n+private:\n+    std::map<uint256,CCoins>::iterator FetchCoins(uint256 txid);\n };\n \n /** CCoinsView that brings transactions from a memorypool into view."
      },
      {
        "sha": "4385b9ba3727a4b47ec60fc4da9da8356fe6a2f7",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b6ac21afb55294c4c54697e190ad647b13d9d5bc/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b6ac21afb55294c4c54697e190ad647b13d9d5bc/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=b6ac21afb55294c4c54697e190ad647b13d9d5bc",
        "patch": "@@ -256,9 +256,6 @@ BOOST_AUTO_TEST_CASE(test_GetThrow)\n     t1.vout.resize(2);\n     t1.vout[0].nValue = 90*CENT;\n     t1.vout[0].scriptPubKey << OP_1;\n-\n-    BOOST_CHECK_THROW(t1.AreInputsStandard(coinsDummy), runtime_error);\n-    BOOST_CHECK_THROW(t1.GetValueIn(coinsDummy), runtime_error);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "d59389e76e53939f952da4fac06e69cb06e09fa8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkNTkzODllNzZlNTM5MzlmOTUyZGE0ZmFjMDZlNjljYjA2ZTA5ZmE4",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-08-10T13:13:57Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-20T13:39:12Z"
      },
      "message": "Automatically reorganize at startup to best known block\n\nGiven that the block tree database (chain.dat) and the active chain\ndatabase (coins.dat) are entirely separate now, it becomes legal to\nswap one with another instance without affecting the other.\n\nThis commit introduces a check in the startup code that detects the\npresence of a better chain in chain.dat that has not been activated\nyet, and does so efficiently (in batch, while reusing the blk???.dat\nfiles).",
      "tree": {
        "sha": "ef480d212b7da3b484bdb066453e874d2c5c6c84",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ef480d212b7da3b484bdb066453e874d2c5c6c84"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d59389e76e53939f952da4fac06e69cb06e09fa8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d59389e76e53939f952da4fac06e69cb06e09fa8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d59389e76e53939f952da4fac06e69cb06e09fa8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d59389e76e53939f952da4fac06e69cb06e09fa8/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b6ac21afb55294c4c54697e190ad647b13d9d5bc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b6ac21afb55294c4c54697e190ad647b13d9d5bc",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b6ac21afb55294c4c54697e190ad647b13d9d5bc"
      }
    ],
    "stats": {
      "total": 35,
      "additions": 34,
      "deletions": 1
    },
    "files": [
      {
        "sha": "5ca9ea2c34f6a07c053450d1589bf66cfe10aae3",
        "filename": "src/db.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d59389e76e53939f952da4fac06e69cb06e09fa8/src/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d59389e76e53939f952da4fac06e69cb06e09fa8/src/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.cpp?ref=d59389e76e53939f952da4fac06e69cb06e09fa8",
        "patch": "@@ -636,7 +636,6 @@ bool LoadBlockIndex(CChainDB &chaindb)\n     {\n         if (pindexGenesisBlock == NULL)\n             return true;\n-        return error(\"CTxDB::LoadBlockIndex() : hashBestChain not loaded\");\n     }\n     hashBestChain = pindexBest->GetBlockHash();\n     nBestHeight = pindexBest->nHeight;"
      },
      {
        "sha": "85aa4f6007d0f5a3c032122600c5df93f6dc1842",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 34,
        "deletions": 0,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d59389e76e53939f952da4fac06e69cb06e09fa8/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d59389e76e53939f952da4fac06e69cb06e09fa8/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=d59389e76e53939f952da4fac06e69cb06e09fa8",
        "patch": "@@ -780,6 +780,40 @@ bool AppInit2()\n \n     // ********************************************************* Step 9: import blocks\n \n+    // scan for better chains in the block chain database, that are not yet connected in the active best chain\n+    CBlockIndex *pindexFoundBest = pindexBest;\n+    for (std::map<uint256,CBlockIndex*>::iterator it = mapBlockIndex.begin(); it != mapBlockIndex.end(); it++) {\n+        CBlockIndex *pindex = it->second;\n+        if (pindexFoundBest==NULL || pindex->bnChainWork > pindexFoundBest->bnChainWork)\n+            pindexFoundBest = pindex;\n+    }\n+    if (pindexFoundBest != pindexBest) {\n+        uiInterface.InitMessage(_(\"Importing blocks from block database...\"));\n+        uint64 nTxs = 0;\n+        uint64 nBlocks = 0;\n+        std::vector<CBlockIndex*> vAttach;\n+        vAttach.reserve(pindexFoundBest->nHeight - (pindexBest==NULL ? 0 : pindexBest->nHeight));\n+        while (pindexFoundBest && pindexFoundBest->bnChainWork > (pindexBest==NULL ? 0 : pindexBest->bnChainWork)) {\n+            vAttach.push_back(pindexFoundBest);\n+            pindexFoundBest = pindexFoundBest->pprev;\n+        }\n+        for (std::vector<CBlockIndex*>::reverse_iterator it = vAttach.rbegin(); it != vAttach.rend(); it++) {\n+            CBlockIndex *pindex = *it;\n+            CBlock block;\n+            if (!block.ReadFromDisk(pindex))\n+                break;\n+            nTxs += block.vtx.size();\n+            nBlocks++;\n+            if (pindex->nHeight == 0 || nTxs + nBlocks*3 > 500) {\n+                nTxs=0;\n+                nBlocks=0;\n+                block.SetBestChain(pindex);\n+            }\n+            if (fRequestShutdown)\n+                break;\n+        }\n+    }\n+\n     std::vector<boost::filesystem::path> *vPath = new std::vector<boost::filesystem::path>();\n     if (mapArgs.count(\"-loadblock\"))\n     {"
      }
    ]
  },
  {
    "sha": "e961d7dac92b8fbb7ae9ace1ac0fe5a6b539712a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplOTYxZDdkYWM5MmI4ZmJiN2FlOWFjZTFhYzBmZTVhNmI1Mzk3MTJh",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-08-18T22:33:01Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-20T13:39:12Z"
      },
      "message": "Prepare database format for multi-stage block processing\n\nThis commit adds a status field and a transaction counter to the block\nindexes.",
      "tree": {
        "sha": "e404a80e1070d495b18fe81c70378cf2a5ee60c7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e404a80e1070d495b18fe81c70378cf2a5ee60c7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e961d7dac92b8fbb7ae9ace1ac0fe5a6b539712a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e961d7dac92b8fbb7ae9ace1ac0fe5a6b539712a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e961d7dac92b8fbb7ae9ace1ac0fe5a6b539712a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e961d7dac92b8fbb7ae9ace1ac0fe5a6b539712a/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d59389e76e53939f952da4fac06e69cb06e09fa8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d59389e76e53939f952da4fac06e69cb06e09fa8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d59389e76e53939f952da4fac06e69cb06e09fa8"
      }
    ],
    "stats": {
      "total": 272,
      "additions": 197,
      "deletions": 75
    },
    "files": [
      {
        "sha": "e77ddd77e1351549a50b0be9b9acd0ecba9d47a8",
        "filename": "src/db.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e961d7dac92b8fbb7ae9ace1ac0fe5a6b539712a/src/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e961d7dac92b8fbb7ae9ace1ac0fe5a6b539712a/src/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.cpp?ref=e961d7dac92b8fbb7ae9ace1ac0fe5a6b539712a",
        "patch": "@@ -622,6 +622,9 @@ bool LoadBlockIndex(CChainDB &chaindb)\n     {\n         CBlockIndex* pindex = item.second;\n         pindex->bnChainWork = (pindex->pprev ? pindex->pprev->bnChainWork : 0) + pindex->GetBlockWork();\n+        pindex->nChainTx = (pindex->pprev ? pindex->pprev->nChainTx : 0) + pindex->nTx;\n+        if ((pindex->nStatus & BLOCK_VALID_MASK) >= BLOCK_VALID_TRANSACTIONS && !(pindex->nStatus & BLOCK_FAILED_MASK))\n+            setBlockIndexValid.insert(pindex);\n     }\n \n     // Load block file info\n@@ -727,20 +730,23 @@ bool CChainDB::LoadBlockIndexGuts()\n             CBlockIndex* pindexNew = InsertBlockIndex(diskindex.GetBlockHash());\n             pindexNew->pprev          = InsertBlockIndex(diskindex.hashPrev);\n             pindexNew->nHeight        = diskindex.nHeight;\n-            pindexNew->pos            = diskindex.pos;\n+            pindexNew->nFile          = diskindex.nFile;\n+            pindexNew->nDataPos       = diskindex.nDataPos;\n             pindexNew->nUndoPos       = diskindex.nUndoPos;\n             pindexNew->nVersion       = diskindex.nVersion;\n             pindexNew->hashMerkleRoot = diskindex.hashMerkleRoot;\n             pindexNew->nTime          = diskindex.nTime;\n             pindexNew->nBits          = diskindex.nBits;\n             pindexNew->nNonce         = diskindex.nNonce;\n+            pindexNew->nStatus        = diskindex.nStatus;\n+            pindexNew->nTx            = diskindex.nTx;\n \n             // Watch for genesis block\n             if (pindexGenesisBlock == NULL && diskindex.GetBlockHash() == hashGenesisBlock)\n                 pindexGenesisBlock = pindexNew;\n \n             if (!pindexNew->CheckIndex())\n-                return error(\"LoadBlockIndex() : CheckIndex failed at %d\", pindexNew->nHeight);\n+                return error(\"LoadBlockIndex() : CheckIndex failed: %s\", pindexNew->ToString().c_str());\n         }\n         else\n         {"
      },
      {
        "sha": "99e2bba37663249627ffe132ec0e1f26e66d53fe",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 32,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e961d7dac92b8fbb7ae9ace1ac0fe5a6b539712a/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e961d7dac92b8fbb7ae9ace1ac0fe5a6b539712a/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=e961d7dac92b8fbb7ae9ace1ac0fe5a6b539712a",
        "patch": "@@ -781,38 +781,9 @@ bool AppInit2()\n     // ********************************************************* Step 9: import blocks\n \n     // scan for better chains in the block chain database, that are not yet connected in the active best chain\n-    CBlockIndex *pindexFoundBest = pindexBest;\n-    for (std::map<uint256,CBlockIndex*>::iterator it = mapBlockIndex.begin(); it != mapBlockIndex.end(); it++) {\n-        CBlockIndex *pindex = it->second;\n-        if (pindexFoundBest==NULL || pindex->bnChainWork > pindexFoundBest->bnChainWork)\n-            pindexFoundBest = pindex;\n-    }\n-    if (pindexFoundBest != pindexBest) {\n-        uiInterface.InitMessage(_(\"Importing blocks from block database...\"));\n-        uint64 nTxs = 0;\n-        uint64 nBlocks = 0;\n-        std::vector<CBlockIndex*> vAttach;\n-        vAttach.reserve(pindexFoundBest->nHeight - (pindexBest==NULL ? 0 : pindexBest->nHeight));\n-        while (pindexFoundBest && pindexFoundBest->bnChainWork > (pindexBest==NULL ? 0 : pindexBest->bnChainWork)) {\n-            vAttach.push_back(pindexFoundBest);\n-            pindexFoundBest = pindexFoundBest->pprev;\n-        }\n-        for (std::vector<CBlockIndex*>::reverse_iterator it = vAttach.rbegin(); it != vAttach.rend(); it++) {\n-            CBlockIndex *pindex = *it;\n-            CBlock block;\n-            if (!block.ReadFromDisk(pindex))\n-                break;\n-            nTxs += block.vtx.size();\n-            nBlocks++;\n-            if (pindex->nHeight == 0 || nTxs + nBlocks*3 > 500) {\n-                nTxs=0;\n-                nBlocks=0;\n-                block.SetBestChain(pindex);\n-            }\n-            if (fRequestShutdown)\n-                break;\n-        }\n-    }\n+    uiInterface.InitMessage(_(\"Importing blocks from block database...\"));\n+    if (!ConnectBestBlock())\n+        strErrors << \"Failed to connect best block\";\n \n     std::vector<boost::filesystem::path> *vPath = new std::vector<boost::filesystem::path>();\n     if (mapArgs.count(\"-loadblock\"))"
      },
      {
        "sha": "b077eb9d6e9e758ad4deed545d721c4d56e9b0b0",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 89,
        "deletions": 25,
        "changes": 114,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e961d7dac92b8fbb7ae9ace1ac0fe5a6b539712a/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e961d7dac92b8fbb7ae9ace1ac0fe5a6b539712a/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=e961d7dac92b8fbb7ae9ace1ac0fe5a6b539712a",
        "patch": "@@ -37,6 +37,7 @@ CBigNum bnBestChainWork = 0;\n CBigNum bnBestInvalidWork = 0;\n uint256 hashBestChain = 0;\n CBlockIndex* pindexBest = NULL;\n+set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexValid; // may contain all CBlockIndex*'s that have validness >=BLOCK_VALID_TRANSACTIONS, and must contain those who aren't failed\n int64 nTimeBestReceived = 0;\n bool fImporting = false;\n \n@@ -1156,6 +1157,62 @@ void static InvalidChainFound(CBlockIndex* pindexNew)\n         printf(\"InvalidChainFound: Warning: Displayed transactions may not be correct! You may need to upgrade, or other nodes may need to upgrade.\\n\");\n }\n \n+void static InvalidBlockFound(CBlockIndex *pindex) {\n+    pindex->nStatus |= BLOCK_FAILED_VALID;\n+    CChainDB().WriteBlockIndex(CDiskBlockIndex(pindex));\n+    setBlockIndexValid.erase(pindex);\n+    InvalidChainFound(pindex);\n+    if (pindex->pnext)\n+        ConnectBestBlock(); // reorganise away from the failed block\n+}\n+\n+bool ConnectBestBlock() {\n+    do {\n+        CBlockIndex *pindexNewBest;\n+\n+        {\n+            std::set<CBlockIndex*,CBlockIndexWorkComparator>::reverse_iterator it = setBlockIndexValid.rbegin();\n+            if (it == setBlockIndexValid.rend())\n+                return true;\n+            pindexNewBest = *it;\n+        }\n+\n+        if (pindexNewBest == pindexBest)\n+            return true; // nothing to do\n+\n+        // check ancestry\n+        CBlockIndex *pindexTest = pindexNewBest;\n+        std::vector<CBlockIndex*> vAttach;\n+        do {\n+            if (pindexTest->nStatus & BLOCK_FAILED_MASK) {\n+                // mark descendants failed\n+                CChainDB chaindb;\n+                CBlockIndex *pindexFailed = pindexNewBest;\n+                while (pindexTest != pindexFailed) {\n+                    pindexFailed->nStatus |= BLOCK_FAILED_CHILD;\n+                    setBlockIndexValid.erase(pindexFailed);\n+                    chaindb.WriteBlockIndex(CDiskBlockIndex(pindexFailed));\n+                    pindexFailed = pindexFailed->pprev;\n+                }\n+                InvalidChainFound(pindexNewBest);\n+                break;\n+            }\n+\n+            if (pindexBest == NULL || pindexTest->bnChainWork > pindexBest->bnChainWork)\n+                vAttach.push_back(pindexTest);\n+\n+            if (pindexTest->pprev == NULL || pindexTest->pnext != NULL) {\n+                reverse(vAttach.begin(), vAttach.end());\n+                BOOST_FOREACH(CBlockIndex *pindexSwitch, vAttach)\n+                    if (!SetBestChain(pindexSwitch))\n+                        return false;\n+                return true;\n+            }\n+            pindexTest = pindexTest->pprev;\n+        } while(true);\n+    } while(true);\n+}\n+\n void CBlock::UpdateTime(const CBlockIndex* pindexPrev)\n {\n     nTime = max(pindexPrev->GetMedianTimePast()+1, GetAdjustedTime());\n@@ -1522,17 +1579,24 @@ bool CBlock::ConnectBlock(CBlockIndex* pindex, CCoinsViewCache &view, bool fJust\n         return true;\n \n     // Write undo information to disk\n-    if (pindex->GetUndoPos().IsNull())\n+    if (pindex->GetUndoPos().IsNull() || (pindex->nStatus & BLOCK_VALID_MASK) < BLOCK_VALID_SCRIPTS)\n     {\n         CChainDB chaindb;\n-        CDiskBlockPos pos;\n-        if (!FindUndoPos(chaindb, pindex->pos.nFile, pos, ::GetSerializeSize(blockundo, SER_DISK, CLIENT_VERSION) + 8))\n-            return error(\"ConnectBlock() : FindUndoPos failed\");\n-        if (!blockundo.WriteToDisk(pos))\n-            return error(\"ConnectBlock() : CBlockUndo::WriteToDisk failed\");\n-\n-        // update nUndoPos in block index\n-        pindex->nUndoPos = pos.nPos + 1;\n+\n+        if (pindex->GetUndoPos().IsNull()) {\n+            CDiskBlockPos pos;\n+            if (!FindUndoPos(chaindb, pindex->nFile, pos, ::GetSerializeSize(blockundo, SER_DISK, CLIENT_VERSION) + 8))\n+                return error(\"ConnectBlock() : FindUndoPos failed\");\n+            if (!blockundo.WriteToDisk(pos))\n+                return error(\"ConnectBlock() : CBlockUndo::WriteToDisk failed\");\n+\n+            // update nUndoPos in block index\n+            pindex->nUndoPos = pos.nPos;\n+            pindex->nStatus |= BLOCK_HAVE_UNDO;\n+        }\n+\n+        pindex->nStatus = (pindex->nStatus & ~BLOCK_VALID_MASK) | BLOCK_VALID_SCRIPTS;\n+\n         CDiskBlockIndex blockindex(pindex);\n         if (!chaindb.WriteBlockIndex(blockindex))\n             return error(\"ConnectBlock() : WriteBlockIndex failed\");\n@@ -1549,7 +1613,7 @@ bool CBlock::ConnectBlock(CBlockIndex* pindex, CCoinsViewCache &view, bool fJust\n     return true;\n }\n \n-bool CBlock::SetBestChain(CBlockIndex* pindexNew)\n+bool SetBestChain(CBlockIndex* pindexNew)\n {\n     CCoinsViewCache &view = *pcoinsTip;\n \n@@ -1620,24 +1684,19 @@ bool CBlock::SetBestChain(CBlockIndex* pindexNew)\n     vector<CTransaction> vDelete;\n     BOOST_FOREACH(CBlockIndex *pindex, vConnect) {\n         CBlock block;\n-        CBlock *pblock;\n-        if (pindex == pindexNew) // connecting *this block\n-            pblock = this;\n-        else { // other block; read it from disk\n-            if (!block.ReadFromDisk(pindex))\n-                return error(\"SetBestBlock() : ReadFromDisk for connect failed\");\n-            pblock = &block;\n-        }\n+        if (!block.ReadFromDisk(pindex))\n+            return error(\"SetBestBlock() : ReadFromDisk for connect failed\");\n         CCoinsViewCache viewTemp(view, true);\n-        if (!pblock->ConnectBlock(pindex, viewTemp)) {\n+        if (!block.ConnectBlock(pindex, viewTemp)) {\n             InvalidChainFound(pindexNew);\n+            InvalidBlockFound(pindex);\n             return error(\"SetBestBlock() : ConnectBlock %s failed\", pindex->GetBlockHash().ToString().substr(0,20).c_str());\n         }\n         if (!viewTemp.Flush())\n             return error(\"SetBestBlock() : Cache flush failed after connect\");\n \n         // Queue memory transactions to delete\n-        BOOST_FOREACH(const CTransaction& tx, pblock->vtx)\n+        BOOST_FOREACH(const CTransaction& tx, block.vtx)\n             vDelete.push_back(tx);\n     }\n \n@@ -1683,8 +1742,8 @@ bool CBlock::SetBestChain(CBlockIndex* pindexNew)\n     bnBestChainWork = pindexNew->bnChainWork;\n     nTimeBestReceived = GetTime();\n     nTransactionsUpdated++;\n-    printf(\"SetBestChain: new best=%s  height=%d  work=%s  date=%s\\n\",\n-      hashBestChain.ToString().substr(0,20).c_str(), nBestHeight, bnBestChainWork.ToString().c_str(),\n+    printf(\"SetBestChain: new best=%s  height=%d  work=%s  tx=%lu  date=%s\\n\",\n+      hashBestChain.ToString().substr(0,20).c_str(), nBestHeight, bnBestChainWork.ToString().c_str(), (unsigned long)pindexNew->nChainTx,\n       DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n \n     // Check the version of the last 100 blocks to see if we need to upgrade:\n@@ -1736,9 +1795,14 @@ bool CBlock::AddToBlockIndex(const CDiskBlockPos &pos)\n         pindexNew->pprev = (*miPrev).second;\n         pindexNew->nHeight = pindexNew->pprev->nHeight + 1;\n     }\n+    pindexNew->nTx = vtx.size();\n     pindexNew->bnChainWork = (pindexNew->pprev ? pindexNew->pprev->bnChainWork : 0) + pindexNew->GetBlockWork();\n-    pindexNew->pos = pos;\n+    pindexNew->nChainTx = (pindexNew->pprev ? pindexNew->pprev->nChainTx : 0) + pindexNew->nTx;\n+    pindexNew->nFile = pos.nFile;\n+    pindexNew->nDataPos = pos.nPos;\n     pindexNew->nUndoPos = 0;\n+    pindexNew->nStatus = BLOCK_VALID_TRANSACTIONS | BLOCK_HAVE_DATA;\n+    setBlockIndexValid.insert(pindexNew);\n \n     CChainDB chaindb;\n     if (!chaindb.TxnBegin())\n@@ -1747,8 +1811,8 @@ bool CBlock::AddToBlockIndex(const CDiskBlockPos &pos)\n     if (!chaindb.TxnCommit())\n         return false;\n \n-    // New best\n-    if (!SetBestChain(pindexNew))\n+    // New best?\n+    if (!ConnectBestBlock())\n         return false;\n \n     if (pindexNew == pindexBest)"
      },
      {
        "sha": "687171ef7c24510359b07f16708397e1491a23af",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 97,
        "deletions": 16,
        "changes": 113,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e961d7dac92b8fbb7ae9ace1ac0fe5a6b539712a/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e961d7dac92b8fbb7ae9ace1ac0fe5a6b539712a/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=e961d7dac92b8fbb7ae9ace1ac0fe5a6b539712a",
        "patch": "@@ -23,6 +23,8 @@ class CInv;\n class CRequestTracker;\n class CNode;\n \n+class CBlockIndexWorkComparator;\n+\n static const unsigned int MAX_BLOCK_SIZE = 1000000;\n static const unsigned int MAX_BLOCK_SIZE_GEN = MAX_BLOCK_SIZE/2;\n static const unsigned int MAX_BLOCK_SIGOPS = MAX_BLOCK_SIZE/50;\n@@ -55,6 +57,7 @@ extern CScript COINBASE_FLAGS;\n \n extern CCriticalSection cs_main;\n extern std::map<uint256, CBlockIndex*> mapBlockIndex;\n+extern std::set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexValid;\n extern uint256 hashGenesisBlock;\n extern CBlockIndex* pindexGenesisBlock;\n extern int nBestHeight;\n@@ -114,6 +117,9 @@ int GetNumBlocksOfPeers();\n bool IsInitialBlockDownload();\n std::string GetWarnings(std::string strFor);\n bool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock, bool fAllowSlow = false);\n+bool SetBestChain(CBlockIndex* pindexNew);\n+bool ConnectBestBlock();\n+\n \n \n \n@@ -1234,9 +1240,6 @@ class CBlock\n     // Read a block from disk\n     bool ReadFromDisk(const CBlockIndex* pindex, bool fReadTransactions=true);\n \n-    // Make this block (with given index) the new tip of the active block chain\n-    bool SetBestChain(CBlockIndex* pindexNew);\n-\n     // Add this block to the block index, and if necessary, switch the active block chain to this\n     bool AddToBlockIndex(const CDiskBlockPos &pos);\n \n@@ -1308,6 +1311,24 @@ extern CCriticalSection cs_LastBlockFile;\n extern CBlockFileInfo infoLastBlockFile;\n extern int nLastBlockFile;\n \n+enum BlockStatus {\n+    BLOCK_VALID_UNKNOWN      =    0,\n+    BLOCK_VALID_HEADER       =    1, // parsed, version ok, hash satisfies claimed PoW, 1 <= vtx count <= max, timestamp not in future\n+    BLOCK_VALID_TREE         =    2, // parent found, difficulty matches, timestamp >= median previous, checkpoint\n+    BLOCK_VALID_TRANSACTIONS =    3, // only first tx is coinbase, 2 <= coinbase input script length <= 100, transactions valid, no duplicate txids, sigops, size, merkle root\n+    BLOCK_VALID_CHAIN        =    4, // outputs do not overspend inputs, no double spends, coinbase output ok, immature coinbase spends, BIP30\n+    BLOCK_VALID_SCRIPTS      =    5, // scripts/signatures ok\n+    BLOCK_VALID_MASK         =    7,\n+\n+    BLOCK_HAVE_DATA          =    8, // full block available in blk*.dat\n+    BLOCK_HAVE_UNDO          =   16, // undo data available in rev*.dat\n+    BLOCK_HAVE_MASK          =   24,\n+\n+    BLOCK_FAILED_VALID       =   32, // stage after last reached validness failed\n+    BLOCK_FAILED_CHILD       =   64, // descends from failed block\n+    BLOCK_FAILED_MASK        =   96\n+};\n+\n /** The block chain is a tree shaped structure starting with the\n  * genesis block at the root, with each block potentially having multiple\n  * candidates to be the next block.  pprev and pnext link a path through the\n@@ -1318,14 +1339,40 @@ extern int nLastBlockFile;\n class CBlockIndex\n {\n public:\n+    // pointer to the hash of the block, if any. memory is owned by this CBlockIndex\n     const uint256* phashBlock;\n+\n+    // pointer to the index of the predecessor of this block\n     CBlockIndex* pprev;\n+\n+    // (memory only) pointer to the index of the *active* successor of this block\n     CBlockIndex* pnext;\n+\n+    // height of the entry in the chain. The genesis block has height 0\n     int nHeight;\n-    CDiskBlockPos pos;\n+\n+    // Which # file this block is stored in (blk?????.dat)\n+    int nFile;\n+\n+    // Byte offset within blk?????.dat where this block's data is stored\n+    unsigned int nDataPos;\n+\n+    // Byte offset within rev?????.dat where this block's undo data is stored\n     unsigned int nUndoPos;\n+\n+    // (memory only) Total amount of work (expected number of hashes) in the chain up to and including this block\n     CBigNum bnChainWork;\n \n+    // Number of transactions in this block.\n+    // Note: in a potential headers-first mode, this number cannot be relied upon\n+    unsigned int nTx;\n+\n+    // (memory only) Number of transactions in the chain up to and including this block\n+    unsigned int nChainTx; // change to 64-bit type when necessary; won't happen before 2030\n+\n+    // Verification status of this block. See enum BlockStatus\n+    unsigned int nStatus;\n+\n     // block header\n     int nVersion;\n     uint256 hashMerkleRoot;\n@@ -1340,9 +1387,13 @@ class CBlockIndex\n         pprev = NULL;\n         pnext = NULL;\n         nHeight = 0;\n-        pos.SetNull();\n+        nFile = 0;\n+        nDataPos = 0;\n         nUndoPos = 0;\n         bnChainWork = 0;\n+        nTx = 0;\n+        nChainTx = 0;\n+        nStatus = 0;\n \n         nVersion       = 0;\n         hashMerkleRoot = 0;\n@@ -1357,9 +1408,13 @@ class CBlockIndex\n         pprev = NULL;\n         pnext = NULL;\n         nHeight = 0;\n-        pos.SetNull();\n+        nFile = 0;\n+        nDataPos = 0;\n         nUndoPos = 0;\n         bnChainWork = 0;\n+        nTx = 0;\n+        nChainTx = 0;\n+        nStatus = 0;\n \n         nVersion       = block.nVersion;\n         hashMerkleRoot = block.hashMerkleRoot;\n@@ -1369,15 +1424,22 @@ class CBlockIndex\n     }\n \n     CDiskBlockPos GetBlockPos() const {\n-        return pos;\n+        CDiskBlockPos ret;\n+        if (nStatus & BLOCK_HAVE_DATA) {\n+            ret.nFile = nFile;\n+            ret.nPos  = nDataPos;\n+        } else\n+            ret.SetNull();\n+        return ret;\n     }\n \n     CDiskBlockPos GetUndoPos() const {\n-        CDiskBlockPos ret = pos;\n-        if (nUndoPos == 0)\n+        CDiskBlockPos ret;\n+        if (nStatus & BLOCK_HAVE_UNDO) {\n+            ret.nFile = nFile;\n+            ret.nPos  = nUndoPos;\n+        } else\n             ret.SetNull();\n-        else\n-            ret.nPos = nUndoPos - 1;\n         return ret;\n     }\n \n@@ -1472,6 +1534,19 @@ class CBlockIndex\n     }\n };\n \n+struct CBlockIndexWorkComparator\n+{\n+    bool operator()(CBlockIndex *pa, CBlockIndex *pb) {\n+        if (pa->bnChainWork > pb->bnChainWork) return false;\n+        if (pa->bnChainWork < pb->bnChainWork) return true;\n+\n+        if (pa->GetBlockHash() < pb->GetBlockHash()) return false;\n+        if (pa->GetBlockHash() > pb->GetBlockHash()) return true;\n+\n+        return false; // identical blocks\n+    }\n+};\n+\n \n \n /** Used to marshal pointers into hashes for db storage. */\n@@ -1491,11 +1566,17 @@ class CDiskBlockIndex : public CBlockIndex\n     IMPLEMENT_SERIALIZE\n     (\n         if (!(nType & SER_GETHASH))\n-            READWRITE(nVersion);\n-\n-        READWRITE(nHeight);\n-        READWRITE(pos);\n-        READWRITE(nUndoPos);\n+            READWRITE(VARINT(nVersion));\n+\n+        READWRITE(VARINT(nHeight));\n+        READWRITE(VARINT(nStatus));\n+        READWRITE(VARINT(nTx));\n+        if (nStatus & (BLOCK_HAVE_DATA | BLOCK_HAVE_UNDO))\n+            READWRITE(VARINT(nFile));\n+        if (nStatus & BLOCK_HAVE_DATA)\n+            READWRITE(VARINT(nDataPos));\n+        if (nStatus & BLOCK_HAVE_UNDO)\n+            READWRITE(VARINT(nUndoPos));\n \n         // block header\n         READWRITE(this->nVersion);"
      }
    ]
  },
  {
    "sha": "b73ff755b9a800670f0675a8f88d3001fd001943",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiNzNmZjc1NWI5YTgwMDY3MGYwNjc1YThmODhkMzAwMWZkMDAxOTQz",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-09-03T13:26:57Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-20T13:39:12Z"
      },
      "message": "Use singleton block tree database instance",
      "tree": {
        "sha": "6ed14b062fb97de3c1b9646161297649825b62e4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6ed14b062fb97de3c1b9646161297649825b62e4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b73ff755b9a800670f0675a8f88d3001fd001943",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b73ff755b9a800670f0675a8f88d3001fd001943",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b73ff755b9a800670f0675a8f88d3001fd001943",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b73ff755b9a800670f0675a8f88d3001fd001943/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e961d7dac92b8fbb7ae9ace1ac0fe5a6b539712a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e961d7dac92b8fbb7ae9ace1ac0fe5a6b539712a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e961d7dac92b8fbb7ae9ace1ac0fe5a6b539712a"
      }
    ],
    "stats": {
      "total": 120,
      "additions": 61,
      "deletions": 59
    },
    "files": [
      {
        "sha": "5fe7e0585f34f5f3e46f9dd95d637b4a6a6f3918",
        "filename": "src/db.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 15,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b73ff755b9a800670f0675a8f88d3001fd001943/src/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b73ff755b9a800670f0675a8f88d3001fd001943/src/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.cpp?ref=b73ff755b9a800670f0675a8f88d3001fd001943",
        "patch": "@@ -273,7 +273,7 @@ CDB::CDB(const char *pszFile, const char* pszMode) :\n \n static bool IsChainFile(std::string strFile)\n {\n-    if (strFile == \"coins.dat\" || strFile == \"chain.dat\")\n+    if (strFile == \"coins.dat\" || strFile == \"blktree.dat\")\n         return true;\n \n     return false;\n@@ -483,7 +483,7 @@ void CDBEnv::Flush(bool fShutdown)\n \n \n //\n-// CChainDB and CCoinsDB\n+// CBlockTreeDB and CCoinsDB\n //\n \n bool CCoinsDB::HaveCoins(uint256 hash) {\n@@ -504,7 +504,7 @@ bool CCoinsDB::WriteCoins(uint256 hash, const CCoins &coins) {\n         return Write(make_pair('c', hash), coins);\n }\n \n-bool CChainDB::WriteBlockIndex(const CDiskBlockIndex& blockindex)\n+bool CBlockTreeDB::WriteBlockIndex(const CDiskBlockIndex& blockindex)\n {\n     return Write(make_pair('b', blockindex.GetBlockHash()), blockindex);\n }\n@@ -519,29 +519,29 @@ bool CCoinsDB::WriteHashBestChain(uint256 hashBestChain)\n     return Write('B', hashBestChain);\n }\n \n-bool CChainDB::ReadBestInvalidWork(CBigNum& bnBestInvalidWork)\n+bool CBlockTreeDB::ReadBestInvalidWork(CBigNum& bnBestInvalidWork)\n {\n     return Read('I', bnBestInvalidWork);\n }\n \n-bool CChainDB::WriteBestInvalidWork(CBigNum bnBestInvalidWork)\n+bool CBlockTreeDB::WriteBestInvalidWork(CBigNum bnBestInvalidWork)\n {\n     return Write('I', bnBestInvalidWork);\n }\n \n-bool CChainDB::WriteBlockFileInfo(int nFile, const CBlockFileInfo &info) {\n+bool CBlockTreeDB::WriteBlockFileInfo(int nFile, const CBlockFileInfo &info) {\n     return Write(make_pair('f', nFile), info);\n }\n \n-bool CChainDB::ReadBlockFileInfo(int nFile, CBlockFileInfo &info) {\n+bool CBlockTreeDB::ReadBlockFileInfo(int nFile, CBlockFileInfo &info) {\n     return Read(make_pair('f', nFile), info);\n }\n \n-bool CChainDB::WriteLastBlockFile(int nFile) {\n+bool CBlockTreeDB::WriteLastBlockFile(int nFile) {\n     return Write('l', nFile);\n }\n \n-bool CChainDB::ReadLastBlockFile(int &nFile) {\n+bool CBlockTreeDB::ReadLastBlockFile(int &nFile) {\n     return Read('l', nFile);\n }\n \n@@ -601,9 +601,9 @@ CBlockIndex static * InsertBlockIndex(uint256 hash)\n     return pindexNew;\n }\n \n-bool LoadBlockIndex(CChainDB &chaindb)\n+bool LoadBlockIndexDB()\n {\n-    if (!chaindb.LoadBlockIndexGuts())\n+    if (!pblocktree->LoadBlockIndexGuts())\n         return false;\n \n     if (fRequestShutdown)\n@@ -628,9 +628,9 @@ bool LoadBlockIndex(CChainDB &chaindb)\n     }\n \n     // Load block file info\n-    chaindb.ReadLastBlockFile(nLastBlockFile);\n+    pblocktree->ReadLastBlockFile(nLastBlockFile);\n     printf(\"LoadBlockIndex(): last block file = %i\\n\", nLastBlockFile);\n-    if (chaindb.ReadBlockFileInfo(nLastBlockFile, infoLastBlockFile))\n+    if (pblocktree->ReadBlockFileInfo(nLastBlockFile, infoLastBlockFile))\n         printf(\"LoadBlockIndex(): last block file: %s\\n\", infoLastBlockFile.ToString().c_str());\n  \n     // Load hashBestChain pointer to end of best chain\n@@ -656,7 +656,7 @@ bool LoadBlockIndex(CChainDB &chaindb)\n         DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n \n     // Load bnBestInvalidWork, OK if it doesn't exist\n-    chaindb.ReadBestInvalidWork(bnBestInvalidWork);\n+    pblocktree->ReadBestInvalidWork(bnBestInvalidWork);\n \n     // Verify blocks in the best chain\n     int nCheckLevel = GetArg(\"-checklevel\", 1);\n@@ -693,7 +693,7 @@ bool LoadBlockIndex(CChainDB &chaindb)\n \n \n \n-bool CChainDB::LoadBlockIndexGuts()\n+bool CBlockTreeDB::LoadBlockIndexGuts()\n {\n     // Get database cursor\n     Dbc* pcursor = GetCursor();"
      },
      {
        "sha": "d0696f3d8ceb76f7da59ef7fd491b10c433d3846",
        "filename": "src/db.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b73ff755b9a800670f0675a8f88d3001fd001943/src/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b73ff755b9a800670f0675a8f88d3001fd001943/src/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.h?ref=b73ff755b9a800670f0675a8f88d3001fd001943",
        "patch": "@@ -348,14 +348,14 @@ class CCoinsViewDB : public CCoinsView\n };\n \n \n-/** Access to the block database (chain.dat) */\n-class CChainDB : public CDB\n+/** Access to the block database (blktree.dat) */\n+class CBlockTreeDB : public CDB\n {\n public:\n-    CChainDB(const char* pszMode=\"r+\") : CDB(\"chain.dat\", pszMode) { }\n+    CBlockTreeDB(const char* pszMode=\"r+\") : CDB(\"blktree.dat\", pszMode) { }\n private:\n-    CChainDB(const CChainDB&);\n-    void operator=(const CChainDB&);\n+    CBlockTreeDB(const CBlockTreeDB&);\n+    void operator=(const CBlockTreeDB&);\n public:\n     bool WriteBlockIndex(const CDiskBlockIndex& blockindex);\n     bool ReadBestInvalidWork(CBigNum& bnBestInvalidWork);\n@@ -368,7 +368,7 @@ class CChainDB : public CDB\n };\n \n \n-bool LoadBlockIndex(CChainDB &chaindb);\n+bool LoadBlockIndexDB();\n \n \n /** Access to the (IP) address database (peers.dat) */"
      },
      {
        "sha": "07e5d13d6ee8e226cb3c8db61f34b00b15a50c67",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b73ff755b9a800670f0675a8f88d3001fd001943/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b73ff755b9a800670f0675a8f88d3001fd001943/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=b73ff755b9a800670f0675a8f88d3001fd001943",
        "patch": "@@ -79,8 +79,10 @@ void Shutdown(void* parg)\n         {\n             LOCK(cs_main);\n             pcoinsTip->Flush();\n+            pblocktree->Flush();\n             delete pcoinsTip;\n             delete pcoinsdbview;\n+            delete pblocktree;\n         }\n         bitdb.Flush(true);\n         boost::filesystem::remove(GetPidFile());\n@@ -650,6 +652,7 @@ bool AppInit2()\n     uiInterface.InitMessage(_(\"Loading block index...\"));\n     printf(\"Loading block index...\\n\");\n     nStart = GetTimeMillis();\n+    pblocktree = new CBlockTreeDB(\"cr+\");\n     pcoinsdbview = new CCoinsViewDB();\n     pcoinsTip = new CCoinsViewCache(*pcoinsdbview);\n "
      },
      {
        "sha": "6395a2541540ad56dc39b54f65a3f3da0c6bbfb0",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 37,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b73ff755b9a800670f0675a8f88d3001fd001943/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b73ff755b9a800670f0675a8f88d3001fd001943/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=b73ff755b9a800670f0675a8f88d3001fd001943",
        "patch": "@@ -270,6 +270,7 @@ bool CCoinsViewMemPool::HaveCoins(uint256 txid) {\n }\n \n CCoinsViewCache *pcoinsTip = NULL;\n+CBlockTreeDB *pblocktree = NULL;\n \n //////////////////////////////////////////////////////////////////////////////\n //\n@@ -1143,7 +1144,7 @@ void static InvalidChainFound(CBlockIndex* pindexNew)\n     if (pindexNew->bnChainWork > bnBestInvalidWork)\n     {\n         bnBestInvalidWork = pindexNew->bnChainWork;\n-        CChainDB().WriteBestInvalidWork(bnBestInvalidWork);\n+        pblocktree->WriteBestInvalidWork(bnBestInvalidWork);\n         uiInterface.NotifyBlocksChanged();\n     }\n     printf(\"InvalidChainFound: invalid block=%s  height=%d  work=%s  date=%s\\n\",\n@@ -1159,7 +1160,7 @@ void static InvalidChainFound(CBlockIndex* pindexNew)\n \n void static InvalidBlockFound(CBlockIndex *pindex) {\n     pindex->nStatus |= BLOCK_FAILED_VALID;\n-    CChainDB().WriteBlockIndex(CDiskBlockIndex(pindex));\n+    pblocktree->WriteBlockIndex(CDiskBlockIndex(pindex));\n     setBlockIndexValid.erase(pindex);\n     InvalidChainFound(pindex);\n     if (pindex->pnext)\n@@ -1186,12 +1187,11 @@ bool ConnectBestBlock() {\n         do {\n             if (pindexTest->nStatus & BLOCK_FAILED_MASK) {\n                 // mark descendants failed\n-                CChainDB chaindb;\n                 CBlockIndex *pindexFailed = pindexNewBest;\n                 while (pindexTest != pindexFailed) {\n                     pindexFailed->nStatus |= BLOCK_FAILED_CHILD;\n                     setBlockIndexValid.erase(pindexFailed);\n-                    chaindb.WriteBlockIndex(CDiskBlockIndex(pindexFailed));\n+                    pblocktree->WriteBlockIndex(CDiskBlockIndex(pindexFailed));\n                     pindexFailed = pindexFailed->pprev;\n                 }\n                 InvalidChainFound(pindexNewBest);\n@@ -1498,7 +1498,7 @@ bool CBlock::DisconnectBlock(CBlockIndex *pindex, CCoinsViewCache &view)\n     return true;\n }\n \n-bool FindUndoPos(CChainDB &chaindb, int nFile, CDiskBlockPos &pos, unsigned int nAddSize);\n+bool FindUndoPos(int nFile, CDiskBlockPos &pos, unsigned int nAddSize);\n \n bool CBlock::ConnectBlock(CBlockIndex* pindex, CCoinsViewCache &view, bool fJustCheck)\n {\n@@ -1581,11 +1581,9 @@ bool CBlock::ConnectBlock(CBlockIndex* pindex, CCoinsViewCache &view, bool fJust\n     // Write undo information to disk\n     if (pindex->GetUndoPos().IsNull() || (pindex->nStatus & BLOCK_VALID_MASK) < BLOCK_VALID_SCRIPTS)\n     {\n-        CChainDB chaindb;\n-\n         if (pindex->GetUndoPos().IsNull()) {\n             CDiskBlockPos pos;\n-            if (!FindUndoPos(chaindb, pindex->nFile, pos, ::GetSerializeSize(blockundo, SER_DISK, CLIENT_VERSION) + 8))\n+            if (!FindUndoPos(pindex->nFile, pos, ::GetSerializeSize(blockundo, SER_DISK, CLIENT_VERSION) + 8))\n                 return error(\"ConnectBlock() : FindUndoPos failed\");\n             if (!blockundo.WriteToDisk(pos))\n                 return error(\"ConnectBlock() : CBlockUndo::WriteToDisk failed\");\n@@ -1598,7 +1596,7 @@ bool CBlock::ConnectBlock(CBlockIndex* pindex, CCoinsViewCache &view, bool fJust\n         pindex->nStatus = (pindex->nStatus & ~BLOCK_VALID_MASK) | BLOCK_VALID_SCRIPTS;\n \n         CDiskBlockIndex blockindex(pindex);\n-        if (!chaindb.WriteBlockIndex(blockindex))\n+        if (!pblocktree->WriteBlockIndex(blockindex))\n             return error(\"ConnectBlock() : WriteBlockIndex failed\");\n     }\n \n@@ -1804,12 +1802,7 @@ bool CBlock::AddToBlockIndex(const CDiskBlockPos &pos)\n     pindexNew->nStatus = BLOCK_VALID_TRANSACTIONS | BLOCK_HAVE_DATA;\n     setBlockIndexValid.insert(pindexNew);\n \n-    CChainDB chaindb;\n-    if (!chaindb.TxnBegin())\n-        return false;\n-    chaindb.WriteBlockIndex(CDiskBlockIndex(pindexNew));\n-    if (!chaindb.TxnCommit())\n-        return false;\n+    pblocktree->WriteBlockIndex(CDiskBlockIndex(pindexNew));\n \n     // New best?\n     if (!ConnectBestBlock())\n@@ -1823,13 +1816,15 @@ bool CBlock::AddToBlockIndex(const CDiskBlockPos &pos)\n         hashPrevBestCoinBase = GetTxHash(0);\n     }\n \n+    pblocktree->Flush();\n+\n     uiInterface.NotifyBlocksChanged();\n     return true;\n }\n \n \n \n-bool FindBlockPos(CChainDB &chaindb, CDiskBlockPos &pos, unsigned int nAddSize, unsigned int nHeight, uint64 nTime)\n+bool FindBlockPos(CDiskBlockPos &pos, unsigned int nAddSize, unsigned int nHeight, uint64 nTime)\n {\n     bool fUpdatedLast = false;\n \n@@ -1845,7 +1840,7 @@ bool FindBlockPos(CChainDB &chaindb, CDiskBlockPos &pos, unsigned int nAddSize,\n         fclose(file);\n         nLastBlockFile++;\n         infoLastBlockFile.SetNull();\n-        chaindb.ReadBlockFileInfo(nLastBlockFile, infoLastBlockFile); // check whether data for the new file somehow already exist; can fail just fine\n+        pblocktree->ReadBlockFileInfo(nLastBlockFile, infoLastBlockFile); // check whether data for the new file somehow already exist; can fail just fine\n         fUpdatedLast = true;\n     }\n \n@@ -1865,15 +1860,15 @@ bool FindBlockPos(CChainDB &chaindb, CDiskBlockPos &pos, unsigned int nAddSize,\n         fclose(file);\n     }\n \n-    if (!chaindb.WriteBlockFileInfo(nLastBlockFile, infoLastBlockFile))\n+    if (!pblocktree->WriteBlockFileInfo(nLastBlockFile, infoLastBlockFile))\n         return error(\"FindBlockPos() : cannot write updated block info\");\n     if (fUpdatedLast)\n-        chaindb.WriteLastBlockFile(nLastBlockFile);\n+        pblocktree->WriteLastBlockFile(nLastBlockFile);\n \n     return true;\n }\n \n-bool FindUndoPos(CChainDB &chaindb, int nFile, CDiskBlockPos &pos, unsigned int nAddSize)\n+bool FindUndoPos(int nFile, CDiskBlockPos &pos, unsigned int nAddSize)\n {\n     pos.nFile = nFile;\n \n@@ -1883,15 +1878,15 @@ bool FindUndoPos(CChainDB &chaindb, int nFile, CDiskBlockPos &pos, unsigned int\n     if (nFile == nLastBlockFile) {\n         pos.nPos = infoLastBlockFile.nUndoSize;\n         nNewSize = (infoLastBlockFile.nUndoSize += nAddSize);\n-        if (!chaindb.WriteBlockFileInfo(nLastBlockFile, infoLastBlockFile))\n+        if (!pblocktree->WriteBlockFileInfo(nLastBlockFile, infoLastBlockFile))\n             return error(\"FindUndoPos() : cannot write updated block info\");\n     } else {\n         CBlockFileInfo info;\n-        if (!chaindb.ReadBlockFileInfo(nFile, info))\n+        if (!pblocktree->ReadBlockFileInfo(nFile, info))\n             return error(\"FindUndoPos() : cannot read block info\");\n         pos.nPos = info.nUndoSize;\n         nNewSize = (info.nUndoSize += nAddSize);\n-        if (!chaindb.WriteBlockFileInfo(nFile, info))\n+        if (!pblocktree->WriteBlockFileInfo(nFile, info))\n             return error(\"FindUndoPos() : cannot write updated block info\");\n     }\n \n@@ -2022,11 +2017,8 @@ bool CBlock::AcceptBlock()\n     if (!CheckDiskSpace(::GetSerializeSize(*this, SER_DISK, CLIENT_VERSION)))\n         return error(\"AcceptBlock() : out of disk space\");\n     CDiskBlockPos blockPos;\n-    {\n-        CChainDB chaindb;\n-        if (!FindBlockPos(chaindb, blockPos, nBlockSize+8, nHeight, nTime))\n-            return error(\"AcceptBlock() : FindBlockPos failed\");\n-    }\n+    if (!FindBlockPos(blockPos, nBlockSize+8, nHeight, nTime))\n+        return error(\"AcceptBlock() : FindBlockPos failed\");\n     if (!WriteToDisk(blockPos))\n         return error(\"AcceptBlock() : WriteToDisk failed\");\n     if (!AddToBlockIndex(blockPos))\n@@ -2210,12 +2202,10 @@ bool LoadBlockIndex(bool fAllowNew)\n     }\n \n     //\n-    // Load block index\n+    // Load block index from databases\n     //\n-    CChainDB chaindb(\"cr\");\n-    if (!LoadBlockIndex(chaindb))\n+    if (!LoadBlockIndexDB())\n         return false;\n-    chaindb.Close();\n \n     //\n     // Init with genesis block\n@@ -2267,11 +2257,8 @@ bool LoadBlockIndex(bool fAllowNew)\n         // Start new block file\n         unsigned int nBlockSize = ::GetSerializeSize(block, SER_DISK, CLIENT_VERSION);\n         CDiskBlockPos blockPos;\n-        {\n-            CChainDB chaindb;\n-            if (!FindBlockPos(chaindb, blockPos, nBlockSize+8, 0, block.nTime))\n-                return error(\"AcceptBlock() : FindBlockPos failed\");\n-        }\n+        if (!FindBlockPos(blockPos, nBlockSize+8, 0, block.nTime))\n+            return error(\"AcceptBlock() : FindBlockPos failed\");\n         if (!block.WriteToDisk(blockPos))\n             return error(\"LoadBlockIndex() : writing genesis block to disk failed\");\n         if (!block.AddToBlockIndex(blockPos))"
      },
      {
        "sha": "2cab48c91218d0b4b5243e8049c38bfe475f31fe",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b73ff755b9a800670f0675a8f88d3001fd001943/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b73ff755b9a800670f0675a8f88d3001fd001943/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=b73ff755b9a800670f0675a8f88d3001fd001943",
        "patch": "@@ -86,7 +86,7 @@ static const uint64 nMinDiskSpace = 52428800;\n \n class CReserveKey;\n class CCoinsDB;\n-class CChainDB;\n+class CBlockTreeDB;\n class CDiskBlockPos;\n class CCoins;\n class CTxUndo;\n@@ -1865,6 +1865,10 @@ class CCoinsViewMemPool : public CCoinsViewBacked\n     bool HaveCoins(uint256 txid);\n };\n \n+/** Global variable that points to the active CCoinsView (protected by cs_main) */\n extern CCoinsViewCache *pcoinsTip;\n \n+/** Global variable that points to the active block tree (protected by cs_main) */\n+extern CBlockTreeDB *pblocktree;\n+\n #endif"
      },
      {
        "sha": "4580877cd80393e79220b745ac9bbd8797ede3be",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b73ff755b9a800670f0675a8f88d3001fd001943/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b73ff755b9a800670f0675a8f88d3001fd001943/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=b73ff755b9a800670f0675a8f88d3001fd001943",
        "patch": "@@ -12,10 +12,15 @@ extern bool fPrintToConsole;\n extern void noui_connect();\n \n struct TestingSetup {\n+    CCoinsViewDB *pcoinsdbview;\n+\n     TestingSetup() {\n         fPrintToDebugger = true; // don't want to write to debug.log file\n         noui_connect();\n         bitdb.MakeMock();\n+        pblocktree = new CBlockTreeDB(\"cr+\");\n+        pcoinsdbview = new CCoinsViewDB();\n+        pcoinsTip = new CCoinsViewCache(*pcoinsdbview);\n         LoadBlockIndex(true);\n         bool fFirstRun;\n         pwalletMain = new CWallet(\"wallet.dat\");\n@@ -26,6 +31,9 @@ struct TestingSetup {\n     {\n         delete pwalletMain;\n         pwalletMain = NULL;\n+        delete pcoinsTip;\n+        delete pcoinsdbview;\n+        delete pblocktree;\n         bitdb.Flush(true);\n     }\n };"
      }
    ]
  },
  {
    "sha": "afdf33b64d8bdaff8951a3673902b44edcd3189d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphZmRmMzNiNjRkOGJkYWZmODk1MWEzNjczOTAyYjQ0ZWRjZDMxODlk",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-09-06T01:21:18Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-20T13:39:12Z"
      },
      "message": "Flush and sync block data",
      "tree": {
        "sha": "94e27888554f534d352d9b90ca955464516411c8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/94e27888554f534d352d9b90ca955464516411c8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/afdf33b64d8bdaff8951a3673902b44edcd3189d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/afdf33b64d8bdaff8951a3673902b44edcd3189d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/afdf33b64d8bdaff8951a3673902b44edcd3189d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/afdf33b64d8bdaff8951a3673902b44edcd3189d/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b73ff755b9a800670f0675a8f88d3001fd001943",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b73ff755b9a800670f0675a8f88d3001fd001943",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b73ff755b9a800670f0675a8f88d3001fd001943"
      }
    ],
    "stats": {
      "total": 29,
      "additions": 21,
      "deletions": 8
    },
    "files": [
      {
        "sha": "44e690b959ea34dec21aae025cb631f21e9183be",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 21,
        "deletions": 8,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/afdf33b64d8bdaff8951a3673902b44edcd3189d/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/afdf33b64d8bdaff8951a3673902b44edcd3189d/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=afdf33b64d8bdaff8951a3673902b44edcd3189d",
        "patch": "@@ -1498,6 +1498,23 @@ bool CBlock::DisconnectBlock(CBlockIndex *pindex, CCoinsViewCache &view)\n     return true;\n }\n \n+void static FlushBlockFile()\n+{\n+    LOCK(cs_LastBlockFile);\n+\n+    CDiskBlockPos posOld;\n+    posOld.nFile = nLastBlockFile;\n+    posOld.nPos = 0;\n+\n+    FILE *fileOld = OpenBlockFile(posOld);\n+    FileCommit(fileOld);\n+    fclose(fileOld);\n+\n+    fileOld = OpenUndoFile(posOld);\n+    FileCommit(fileOld);\n+    fclose(fileOld);\n+}\n+\n bool FindUndoPos(int nFile, CDiskBlockPos &pos, unsigned int nAddSize);\n \n bool CBlock::ConnectBlock(CBlockIndex* pindex, CCoinsViewCache &view, bool fJustCheck)\n@@ -1700,9 +1717,11 @@ bool SetBestChain(CBlockIndex* pindexNew)\n \n     // Make sure it's successfully written to disk before changing memory structure\n     bool fIsInitialDownload = IsInitialBlockDownload();\n-    if (!fIsInitialDownload || view.GetCacheSize()>5000)\n+    if (!fIsInitialDownload || view.GetCacheSize()>5000) {\n+        FlushBlockFile();\n         if (!view.Flush())\n             return false;\n+    }\n \n     // At this point, all changes have been done to the database.\n     // Proceed by updating the memory structures.\n@@ -1823,7 +1842,6 @@ bool CBlock::AddToBlockIndex(const CDiskBlockPos &pos)\n }\n \n \n-\n bool FindBlockPos(CDiskBlockPos &pos, unsigned int nAddSize, unsigned int nHeight, uint64 nTime)\n {\n     bool fUpdatedLast = false;\n@@ -1832,12 +1850,7 @@ bool FindBlockPos(CDiskBlockPos &pos, unsigned int nAddSize, unsigned int nHeigh\n \n     while (infoLastBlockFile.nSize + nAddSize >= MAX_BLOCKFILE_SIZE) {\n         printf(\"Leaving block file %i: %s\\n\", nLastBlockFile, infoLastBlockFile.ToString().c_str());\n-        FILE *file = OpenBlockFile(pos);\n-        FileCommit(file);\n-        fclose(file);\n-        file = OpenUndoFile(pos);\n-        FileCommit(file);\n-        fclose(file);\n+        FlushBlockFile();\n         nLastBlockFile++;\n         infoLastBlockFile.SetNull();\n         pblocktree->ReadBlockFileInfo(nLastBlockFile, infoLastBlockFile); // check whether data for the new file somehow already exist; can fail just fine"
      }
    ]
  },
  {
    "sha": "6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2ODcxYTIwZWE1ZTJlNWM2N2Q2OWVkN2NiZmU4YzU3YWUyN2Q3NTBk",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-09-03T19:14:03Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-20T13:39:12Z"
      },
      "message": "LevelDB block and coin databases\n\nSplit off CBlockTreeDB and CCoinsViewDB into txdb-*.{cpp,h} files,\nimplemented by either LevelDB or BDB.\n\nBased on code from earlier commits by Mike Hearn in his leveldb\nbranch.",
      "tree": {
        "sha": "351935f27dcd037d68d514c3a79ff5d2d24da367",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/351935f27dcd037d68d514c3a79ff5d2d24da367"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "afdf33b64d8bdaff8951a3673902b44edcd3189d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/afdf33b64d8bdaff8951a3673902b44edcd3189d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/afdf33b64d8bdaff8951a3673902b44edcd3189d"
      }
    ],
    "stats": {
      "total": 914,
      "additions": 574,
      "deletions": 340
    },
    "files": [
      {
        "sha": "d0f535347ebfa845d9968c9fce9be98ee0eb5e86",
        "filename": "bitcoin-qt.pro",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d/bitcoin-qt.pro",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d/bitcoin-qt.pro",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/bitcoin-qt.pro?ref=6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d",
        "patch": "@@ -92,12 +92,15 @@ contains(BITCOIN_NEED_QT_PLUGINS, 1) {\n \n contains(USE_LEVELDB, -) {\n     message(Building without LevelDB)\n+    SOURCES += src/txdb-bdb.cpp\n+    HEADERS += src/txdb-bdb.h\n } else {\n     message(Building with LevelDB)\n     DEFINES += USE_LEVELDB\n     INCLUDEPATH += src/leveldb/include src/leveldb/helpers\n     LIBS += $$PWD/src/leveldb/libleveldb.a $$PWD/src/leveldb/libmemenv.a\n-    SOURCES += src/leveldb.cpp\n+    SOURCES += src/leveldb.cpp src/txdb-leveldb.cpp\n+    HEADERS += src/leveldb.h src/txdb-leveldb.h\n     !windows {\n         genleveldb.commands = cd $$PWD/src/leveldb ; $(MAKE) libleveldb.a libmemenv.a\n     } else {\n@@ -153,6 +156,7 @@ HEADERS += src/qt/bitcoingui.h \\\n     src/net.h \\\n     src/key.h \\\n     src/db.h \\\n+    src/txdb.h \\\n     src/walletdb.h \\\n     src/script.h \\\n     src/init.h \\"
      },
      {
        "sha": "8738a0af8ef9b02cae3d49958ba89bfd4d2e42d7",
        "filename": "src/db.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 279,
        "changes": 279,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d/src/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d/src/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.cpp?ref=6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d",
        "patch": "@@ -482,285 +482,6 @@ void CDBEnv::Flush(bool fShutdown)\n \n \n \n-//\n-// CBlockTreeDB and CCoinsDB\n-//\n-\n-bool CCoinsDB::HaveCoins(uint256 hash) {\n-    assert(!fClient);\n-    return Exists(make_pair('c', hash));\n-}\n-\n-bool CCoinsDB::ReadCoins(uint256 hash, CCoins &coins) {\n-    assert(!fClient);\n-    return Read(make_pair('c', hash), coins);\n-}\n-\n-bool CCoinsDB::WriteCoins(uint256 hash, const CCoins &coins) {\n-    assert(!fClient);\n-    if (coins.IsPruned())\n-        return Erase(make_pair('c', hash));\n-    else\n-        return Write(make_pair('c', hash), coins);\n-}\n-\n-bool CBlockTreeDB::WriteBlockIndex(const CDiskBlockIndex& blockindex)\n-{\n-    return Write(make_pair('b', blockindex.GetBlockHash()), blockindex);\n-}\n-\n-bool CCoinsDB::ReadHashBestChain(uint256& hashBestChain)\n-{\n-    return Read('B', hashBestChain);\n-}\n-\n-bool CCoinsDB::WriteHashBestChain(uint256 hashBestChain)\n-{\n-    return Write('B', hashBestChain);\n-}\n-\n-bool CBlockTreeDB::ReadBestInvalidWork(CBigNum& bnBestInvalidWork)\n-{\n-    return Read('I', bnBestInvalidWork);\n-}\n-\n-bool CBlockTreeDB::WriteBestInvalidWork(CBigNum bnBestInvalidWork)\n-{\n-    return Write('I', bnBestInvalidWork);\n-}\n-\n-bool CBlockTreeDB::WriteBlockFileInfo(int nFile, const CBlockFileInfo &info) {\n-    return Write(make_pair('f', nFile), info);\n-}\n-\n-bool CBlockTreeDB::ReadBlockFileInfo(int nFile, CBlockFileInfo &info) {\n-    return Read(make_pair('f', nFile), info);\n-}\n-\n-bool CBlockTreeDB::WriteLastBlockFile(int nFile) {\n-    return Write('l', nFile);\n-}\n-\n-bool CBlockTreeDB::ReadLastBlockFile(int &nFile) {\n-    return Read('l', nFile);\n-}\n-\n-CCoinsViewDB::CCoinsViewDB() : db(\"cr+\") {}\n-bool CCoinsViewDB::GetCoins(uint256 txid, CCoins &coins) { return db.ReadCoins(txid, coins); }\n-bool CCoinsViewDB::SetCoins(uint256 txid, const CCoins &coins) { return db.WriteCoins(txid, coins); }\n-bool CCoinsViewDB::HaveCoins(uint256 txid) { return db.HaveCoins(txid); }\n-CBlockIndex *CCoinsViewDB::GetBestBlock() {\n-    uint256 hashBestChain;\n-    if (!db.ReadHashBestChain(hashBestChain))\n-        return NULL;\n-    std::map<uint256, CBlockIndex*>::iterator it = mapBlockIndex.find(hashBestChain);\n-    if (it == mapBlockIndex.end())\n-        return NULL;\n-    return it->second;\n-}\n-bool CCoinsViewDB::SetBestBlock(CBlockIndex *pindex) { return db.WriteHashBestChain(pindex->GetBlockHash()); }\n-bool CCoinsViewDB::BatchWrite(const std::map<uint256, CCoins> &mapCoins, CBlockIndex *pindex) {\n-    printf(\"Committing %u changed transactions to coin database...\\n\", (unsigned int)mapCoins.size());\n-\n-    if (!db.TxnBegin())\n-        return false;\n-    bool fOk = true;\n-    for (std::map<uint256, CCoins>::const_iterator it = mapCoins.begin(); it != mapCoins.end(); it++) {\n-        fOk = db.WriteCoins(it->first, it->second);\n-        if (!fOk)\n-            break;\n-    }\n-    if (fOk)\n-        fOk = db.WriteHashBestChain(pindex->GetBlockHash());\n-\n-    if (!fOk)\n-        db.TxnAbort();\n-    else\n-        fOk = db.TxnCommit();\n-\n-    return fOk;\n-}\n-\n-CBlockIndex static * InsertBlockIndex(uint256 hash)\n-{\n-    if (hash == 0)\n-        return NULL;\n-\n-    // Return existing\n-    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n-    if (mi != mapBlockIndex.end())\n-        return (*mi).second;\n-\n-    // Create new\n-    CBlockIndex* pindexNew = new CBlockIndex();\n-    if (!pindexNew)\n-        throw runtime_error(\"LoadBlockIndex() : new CBlockIndex failed\");\n-    mi = mapBlockIndex.insert(make_pair(hash, pindexNew)).first;\n-    pindexNew->phashBlock = &((*mi).first);\n-\n-    return pindexNew;\n-}\n-\n-bool LoadBlockIndexDB()\n-{\n-    if (!pblocktree->LoadBlockIndexGuts())\n-        return false;\n-\n-    if (fRequestShutdown)\n-        return true;\n-\n-    // Calculate bnChainWork\n-    vector<pair<int, CBlockIndex*> > vSortedByHeight;\n-    vSortedByHeight.reserve(mapBlockIndex.size());\n-    BOOST_FOREACH(const PAIRTYPE(uint256, CBlockIndex*)& item, mapBlockIndex)\n-    {\n-        CBlockIndex* pindex = item.second;\n-        vSortedByHeight.push_back(make_pair(pindex->nHeight, pindex));\n-    }\n-    sort(vSortedByHeight.begin(), vSortedByHeight.end());\n-    BOOST_FOREACH(const PAIRTYPE(int, CBlockIndex*)& item, vSortedByHeight)\n-    {\n-        CBlockIndex* pindex = item.second;\n-        pindex->bnChainWork = (pindex->pprev ? pindex->pprev->bnChainWork : 0) + pindex->GetBlockWork();\n-        pindex->nChainTx = (pindex->pprev ? pindex->pprev->nChainTx : 0) + pindex->nTx;\n-        if ((pindex->nStatus & BLOCK_VALID_MASK) >= BLOCK_VALID_TRANSACTIONS && !(pindex->nStatus & BLOCK_FAILED_MASK))\n-            setBlockIndexValid.insert(pindex);\n-    }\n-\n-    // Load block file info\n-    pblocktree->ReadLastBlockFile(nLastBlockFile);\n-    printf(\"LoadBlockIndex(): last block file = %i\\n\", nLastBlockFile);\n-    if (pblocktree->ReadBlockFileInfo(nLastBlockFile, infoLastBlockFile))\n-        printf(\"LoadBlockIndex(): last block file: %s\\n\", infoLastBlockFile.ToString().c_str());\n- \n-    // Load hashBestChain pointer to end of best chain\n-    pindexBest = pcoinsTip->GetBestBlock();\n-    if (pindexBest == NULL)\n-    {\n-        if (pindexGenesisBlock == NULL)\n-            return true;\n-    }\n-    hashBestChain = pindexBest->GetBlockHash();\n-    nBestHeight = pindexBest->nHeight;\n-    bnBestChainWork = pindexBest->bnChainWork;\n-\n-    // set 'next' pointers in best chain\n-    CBlockIndex *pindex = pindexBest;\n-    while(pindex != NULL && pindex->pprev != NULL) {\n-         CBlockIndex *pindexPrev = pindex->pprev;\n-         pindexPrev->pnext = pindex;\n-         pindex = pindexPrev;\n-    }\n-    printf(\"LoadBlockIndex(): hashBestChain=%s  height=%d date=%s\\n\",\n-        hashBestChain.ToString().substr(0,20).c_str(), nBestHeight,\n-        DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n-\n-    // Load bnBestInvalidWork, OK if it doesn't exist\n-    pblocktree->ReadBestInvalidWork(bnBestInvalidWork);\n-\n-    // Verify blocks in the best chain\n-    int nCheckLevel = GetArg(\"-checklevel\", 1);\n-    int nCheckDepth = GetArg( \"-checkblocks\", 2500);\n-    if (nCheckDepth == 0)\n-        nCheckDepth = 1000000000; // suffices until the year 19000\n-    if (nCheckDepth > nBestHeight)\n-        nCheckDepth = nBestHeight;\n-    printf(\"Verifying last %i blocks at level %i\\n\", nCheckDepth, nCheckLevel);\n-    CBlockIndex* pindexFork = NULL;\n-    for (CBlockIndex* pindex = pindexBest; pindex && pindex->pprev; pindex = pindex->pprev)\n-    {\n-        if (fRequestShutdown || pindex->nHeight < nBestHeight-nCheckDepth)\n-            break;\n-        CBlock block;\n-        if (!block.ReadFromDisk(pindex))\n-            return error(\"LoadBlockIndex() : block.ReadFromDisk failed\");\n-        // check level 1: verify block validity\n-        if (nCheckLevel>0 && !block.CheckBlock())\n-        {\n-            printf(\"LoadBlockIndex() : *** found bad block at %d, hash=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n-            pindexFork = pindex->pprev;\n-        }\n-        // TODO: stronger verifications\n-    }\n-    if (pindexFork && !fRequestShutdown)\n-    {\n-        // TODO: reorg back\n-        return error(\"LoadBlockIndex(): chain database corrupted\");\n-    }\n-\n-    return true;\n-}\n-\n-\n-\n-bool CBlockTreeDB::LoadBlockIndexGuts()\n-{\n-    // Get database cursor\n-    Dbc* pcursor = GetCursor();\n-    if (!pcursor)\n-        return false;\n-\n-    // Load mapBlockIndex\n-    unsigned int fFlags = DB_SET_RANGE;\n-    loop\n-    {\n-        // Read next record\n-        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n-        if (fFlags == DB_SET_RANGE)\n-            ssKey << make_pair('b', uint256(0));\n-        CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n-        int ret = ReadAtCursor(pcursor, ssKey, ssValue, fFlags);\n-        fFlags = DB_NEXT;\n-        if (ret == DB_NOTFOUND)\n-            break;\n-        else if (ret != 0)\n-            return false;\n-\n-        // Unserialize\n-\n-        try {\n-        char chType;\n-        ssKey >> chType;\n-        if (chType == 'b' && !fRequestShutdown)\n-        {\n-            CDiskBlockIndex diskindex;\n-            ssValue >> diskindex;\n-\n-            // Construct block index object\n-            CBlockIndex* pindexNew = InsertBlockIndex(diskindex.GetBlockHash());\n-            pindexNew->pprev          = InsertBlockIndex(diskindex.hashPrev);\n-            pindexNew->nHeight        = diskindex.nHeight;\n-            pindexNew->nFile          = diskindex.nFile;\n-            pindexNew->nDataPos       = diskindex.nDataPos;\n-            pindexNew->nUndoPos       = diskindex.nUndoPos;\n-            pindexNew->nVersion       = diskindex.nVersion;\n-            pindexNew->hashMerkleRoot = diskindex.hashMerkleRoot;\n-            pindexNew->nTime          = diskindex.nTime;\n-            pindexNew->nBits          = diskindex.nBits;\n-            pindexNew->nNonce         = diskindex.nNonce;\n-            pindexNew->nStatus        = diskindex.nStatus;\n-            pindexNew->nTx            = diskindex.nTx;\n-\n-            // Watch for genesis block\n-            if (pindexGenesisBlock == NULL && diskindex.GetBlockHash() == hashGenesisBlock)\n-                pindexGenesisBlock = pindexNew;\n-\n-            if (!pindexNew->CheckIndex())\n-                return error(\"LoadBlockIndex() : CheckIndex failed: %s\", pindexNew->ToString().c_str());\n-        }\n-        else\n-        {\n-            break; // if shutdown requested or finished loading block index\n-        }\n-        }    // try\n-        catch (std::exception &e) {\n-            return error(\"%s() : deserialize error\", __PRETTY_FUNCTION__);\n-        }\n-    }\n-    pcursor->close();\n-\n-    return true;\n-}\n \n \n "
      },
      {
        "sha": "9a5f1ca9e4604a4bce9a43fcf10457b0d07756bc",
        "filename": "src/db.h",
        "status": "modified",
        "additions": 0,
        "deletions": 55,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d/src/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d/src/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.h?ref=6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d",
        "patch": "@@ -315,61 +315,6 @@ class CDB\n \n \n \n-/** Access to the transaction database (coins.dat) */\n-class CCoinsDB : public CDB\n-{\n-public:\n-    CCoinsDB(const char* pszMode=\"r+\") : CDB(\"coins.dat\", pszMode) { }\n-private:\n-    CCoinsDB(const CCoinsDB&);\n-    void operator=(const CCoinsDB&);\n-public:\n-    bool ReadCoins(uint256 hash, CCoins &coins);\n-    bool WriteCoins(uint256 hash, const CCoins& coins);\n-    bool HaveCoins(uint256 hash);\n-    bool ReadHashBestChain(uint256& hashBestChain);\n-    bool WriteHashBestChain(uint256 hashBestChain);\n-};\n-\n-\n-/** CCoinsView backed by a CCoinsDB */\n-class CCoinsViewDB : public CCoinsView\n-{\n-protected:\n-    CCoinsDB db;\n-public:\n-    CCoinsViewDB();\n-    bool GetCoins(uint256 txid, CCoins &coins);\n-    bool SetCoins(uint256 txid, const CCoins &coins);\n-    bool HaveCoins(uint256 txid);\n-    CBlockIndex *GetBestBlock();\n-    bool SetBestBlock(CBlockIndex *pindex);\n-    bool BatchWrite(const std::map<uint256, CCoins> &mapCoins, CBlockIndex *pindex);\n-};\n-\n-\n-/** Access to the block database (blktree.dat) */\n-class CBlockTreeDB : public CDB\n-{\n-public:\n-    CBlockTreeDB(const char* pszMode=\"r+\") : CDB(\"blktree.dat\", pszMode) { }\n-private:\n-    CBlockTreeDB(const CBlockTreeDB&);\n-    void operator=(const CBlockTreeDB&);\n-public:\n-    bool WriteBlockIndex(const CDiskBlockIndex& blockindex);\n-    bool ReadBestInvalidWork(CBigNum& bnBestInvalidWork);\n-    bool WriteBestInvalidWork(CBigNum bnBestInvalidWork);\n-    bool ReadBlockFileInfo(int nFile, CBlockFileInfo &fileinfo);\n-    bool WriteBlockFileInfo(int nFile, const CBlockFileInfo &fileinfo);\n-    bool ReadLastBlockFile(int &nFile);\n-    bool WriteLastBlockFile(int nFile);\n-    bool LoadBlockIndexGuts();\n-};\n-\n-\n-bool LoadBlockIndexDB();\n-\n \n /** Access to the (IP) address database (peers.dat) */\n class CAddrDB"
      },
      {
        "sha": "30f0d0049ea4b542c71393fffe21cceedc0c53cf",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d",
        "patch": "@@ -2,7 +2,7 @@\n // Copyright (c) 2009-2012 The Bitcoin developers\n // Distributed under the MIT/X11 software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-#include \"db.h\"\n+#include \"txdb.h\"\n #include \"walletdb.h\"\n #include \"bitcoinrpc.h\"\n #include \"net.h\""
      },
      {
        "sha": "94f1a931514ef616b24e3394a2e8f58e16ed9a25",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 112,
        "deletions": 0,
        "changes": 112,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d",
        "patch": "@@ -6,6 +6,7 @@\n #include \"alert.h\"\n #include \"checkpoints.h\"\n #include \"db.h\"\n+#include \"txdb.h\"\n #include \"net.h\"\n #include \"init.h\"\n #include \"ui_interface.h\"\n@@ -1719,6 +1720,7 @@ bool SetBestChain(CBlockIndex* pindexNew)\n     bool fIsInitialDownload = IsInitialBlockDownload();\n     if (!fIsInitialDownload || view.GetCacheSize()>5000) {\n         FlushBlockFile();\n+        pblocktree->Sync();\n         if (!view.Flush())\n             return false;\n     }\n@@ -2203,6 +2205,116 @@ FILE *OpenUndoFile(const CDiskBlockPos &pos, bool fReadOnly) {\n     return OpenDiskFile(pos, \"rev\", fReadOnly);\n }\n \n+CBlockIndex * InsertBlockIndex(uint256 hash)\n+{\n+    if (hash == 0)\n+        return NULL;\n+\n+    // Return existing\n+    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n+    if (mi != mapBlockIndex.end())\n+        return (*mi).second;\n+\n+    // Create new\n+    CBlockIndex* pindexNew = new CBlockIndex();\n+    if (!pindexNew)\n+        throw runtime_error(\"LoadBlockIndex() : new CBlockIndex failed\");\n+    mi = mapBlockIndex.insert(make_pair(hash, pindexNew)).first;\n+    pindexNew->phashBlock = &((*mi).first);\n+\n+    return pindexNew;\n+}\n+\n+bool static LoadBlockIndexDB()\n+{\n+    if (!pblocktree->LoadBlockIndexGuts())\n+        return false;\n+\n+    if (fRequestShutdown)\n+        return true;\n+\n+    // Calculate bnChainWork\n+    vector<pair<int, CBlockIndex*> > vSortedByHeight;\n+    vSortedByHeight.reserve(mapBlockIndex.size());\n+    BOOST_FOREACH(const PAIRTYPE(uint256, CBlockIndex*)& item, mapBlockIndex)\n+    {\n+        CBlockIndex* pindex = item.second;\n+        vSortedByHeight.push_back(make_pair(pindex->nHeight, pindex));\n+    }\n+    sort(vSortedByHeight.begin(), vSortedByHeight.end());\n+    BOOST_FOREACH(const PAIRTYPE(int, CBlockIndex*)& item, vSortedByHeight)\n+    {\n+        CBlockIndex* pindex = item.second;\n+        pindex->bnChainWork = (pindex->pprev ? pindex->pprev->bnChainWork : 0) + pindex->GetBlockWork();\n+        pindex->nChainTx = (pindex->pprev ? pindex->pprev->nChainTx : 0) + pindex->nTx;\n+        if ((pindex->nStatus & BLOCK_VALID_MASK) >= BLOCK_VALID_TRANSACTIONS && !(pindex->nStatus & BLOCK_FAILED_MASK))\n+            setBlockIndexValid.insert(pindex);\n+    }\n+\n+    // Load block file info\n+    pblocktree->ReadLastBlockFile(nLastBlockFile);\n+    printf(\"LoadBlockIndex(): last block file = %i\\n\", nLastBlockFile);\n+    if (pblocktree->ReadBlockFileInfo(nLastBlockFile, infoLastBlockFile))\n+        printf(\"LoadBlockIndex(): last block file: %s\\n\", infoLastBlockFile.ToString().c_str());\n+ \n+    // Load hashBestChain pointer to end of best chain\n+    pindexBest = pcoinsTip->GetBestBlock();\n+    if (pindexBest == NULL)\n+    {\n+        if (pindexGenesisBlock == NULL)\n+            return true;\n+    }\n+    hashBestChain = pindexBest->GetBlockHash();\n+    nBestHeight = pindexBest->nHeight;\n+    bnBestChainWork = pindexBest->bnChainWork;\n+\n+    // set 'next' pointers in best chain\n+    CBlockIndex *pindex = pindexBest;\n+    while(pindex != NULL && pindex->pprev != NULL) {\n+         CBlockIndex *pindexPrev = pindex->pprev;\n+         pindexPrev->pnext = pindex;\n+         pindex = pindexPrev;\n+    }\n+    printf(\"LoadBlockIndex(): hashBestChain=%s  height=%d date=%s\\n\",\n+        hashBestChain.ToString().substr(0,20).c_str(), nBestHeight,\n+        DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n+\n+    // Load bnBestInvalidWork, OK if it doesn't exist\n+    pblocktree->ReadBestInvalidWork(bnBestInvalidWork);\n+\n+    // Verify blocks in the best chain\n+    int nCheckLevel = GetArg(\"-checklevel\", 1);\n+    int nCheckDepth = GetArg( \"-checkblocks\", 2500);\n+    if (nCheckDepth == 0)\n+        nCheckDepth = 1000000000; // suffices until the year 19000\n+    if (nCheckDepth > nBestHeight)\n+        nCheckDepth = nBestHeight;\n+    printf(\"Verifying last %i blocks at level %i\\n\", nCheckDepth, nCheckLevel);\n+    CBlockIndex* pindexFork = NULL;\n+    for (CBlockIndex* pindex = pindexBest; pindex && pindex->pprev; pindex = pindex->pprev)\n+    {\n+        if (fRequestShutdown || pindex->nHeight < nBestHeight-nCheckDepth)\n+            break;\n+        CBlock block;\n+        if (!block.ReadFromDisk(pindex))\n+            return error(\"LoadBlockIndex() : block.ReadFromDisk failed\");\n+        // check level 1: verify block validity\n+        if (nCheckLevel>0 && !block.CheckBlock())\n+        {\n+            printf(\"LoadBlockIndex() : *** found bad block at %d, hash=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n+            pindexFork = pindex->pprev;\n+        }\n+        // TODO: stronger verifications\n+    }\n+    if (pindexFork && !fRequestShutdown)\n+    {\n+        // TODO: reorg back\n+        return error(\"LoadBlockIndex(): chain database corrupted\");\n+    }\n+\n+    return true;\n+}\n+\n bool LoadBlockIndex(bool fAllowNew)\n {\n     if (fTestNet)"
      },
      {
        "sha": "1126feb09bbe1a07fa4e9e7999e3ec443c073605",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d",
        "patch": "@@ -119,6 +119,7 @@ std::string GetWarnings(std::string strFor);\n bool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock, bool fAllowSlow = false);\n bool SetBestChain(CBlockIndex* pindexNew);\n bool ConnectBestBlock();\n+CBlockIndex * InsertBlockIndex(uint256 hash);\n \n \n "
      },
      {
        "sha": "eee325d624b7172ce4b219a2086fb133bce100ff",
        "filename": "src/makefile.linux-mingw",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d/src/makefile.linux-mingw",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d/src/makefile.linux-mingw",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.linux-mingw?ref=6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d",
        "patch": "@@ -91,10 +91,12 @@ ifdef USE_LEVELDB\n LIBS += $(CURDIR)/leveldb/libleveldb.a $(CURDIR)/leveldb/libmemenv.a\n DEFS += -I\"$(CURDIR)/leveldb/include\" -DUSE_LEVELDB\n DEFS += -I\"$(CURDIR)/leveldb/helpers\"\n-OBJS += obj/leveldb.o\n+OBJS += obj/leveldb.o obj/txdb-leveldb.o\n leveldb/libleveldb.a:\n \t@echo \"Building LevelDB ...\"; cd leveldb; TARGET_OS=OS_WINDOWS_CROSSCOMPILE CXXFLAGS=\"-I$(INCLUDEPATHS)\" LDFLAGS=\"-L$(LIBPATHS)\" make libleveldb.a libmemenv.a; cd ..\n obj/leveldb.o: leveldb/libleveldb.a\n+else\n+OBJS += obj/txdb-bdb.o\n endif\n \n obj/build.h: FORCE"
      },
      {
        "sha": "4d95d1c0389b7be5ff5a8b8ba0ca01ca7026e6d8",
        "filename": "src/makefile.mingw",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d/src/makefile.mingw",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d/src/makefile.mingw",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.mingw?ref=6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d",
        "patch": "@@ -94,10 +94,12 @@ ifdef USE_LEVELDB\n LIBS += $(CURDIR)/leveldb/libleveldb.a $(CURDIR)/leveldb/libmemenv.a\n DEFS += $(addprefix -I,$(CURDIR)/leveldb/include) -DUSE_LEVELDB\n DEFS += $(addprefix -I,$(CURDIR)/leveldb/helpers)\n-OBJS += obj/leveldb.o\n+OBJS += obj/leveldb.o obj/txdb-leveldb.o\n leveldb/libleveldb.a:\n     cd leveldb; make libleveldb.a libmemenv.a; cd ..\n obj/leveldb.o: leveldb/libleveldb.lib\n+else\n+OBJS += obj/txdb-bdb.o\n endif\n \n obj/%.o: %.cpp $(HEADERS)"
      },
      {
        "sha": "9a9296f41217e02d8987948931f4753e1e6e5cae",
        "filename": "src/makefile.osx",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d/src/makefile.osx",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d/src/makefile.osx",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.osx?ref=6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d",
        "patch": "@@ -127,10 +127,12 @@ ifdef USE_LEVELDB\n LIBS += $(CURDIR)/leveldb/libleveldb.a $(CURDIR)/leveldb/libmemenv.a\n DEFS += $(addprefix -I,$(CURDIR)/leveldb/include) -DUSE_LEVELDB\n DEFS += $(addprefix -I,$(CURDIR)/leveldb/helpers)\n-OBJS += obj/leveldb.o\n+OBJS += obj/leveldb.o obj/txdb-leveldb.o\n leveldb/libleveldb.a:\n \t@echo \"Building LevelDB ...\"; cd leveldb; make libleveldb.a libmemenv.a; cd ..\n obj/leveldb.o: leveldb/libleveldb.a\n+else\n+OBJS += obj/txdb-bdb.o\n endif\n \n # auto-generated dependencies:"
      },
      {
        "sha": "95234bae2a92db381122eafc3ace1ded716fa105",
        "filename": "src/makefile.unix",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d/src/makefile.unix",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d/src/makefile.unix",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.unix?ref=6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d",
        "patch": "@@ -143,10 +143,12 @@ ifdef USE_LEVELDB\n LIBS += $(CURDIR)/leveldb/libleveldb.a $(CURDIR)/leveldb/libmemenv.a\n DEFS += $(addprefix -I,$(CURDIR)/leveldb/include) -DUSE_LEVELDB\n DEFS += $(addprefix -I,$(CURDIR)/leveldb/helpers)\n-OBJS += obj/leveldb.o\n+OBJS += obj/leveldb.o obj/txdb-leveldb.o\n leveldb/libleveldb.a:\n \t@echo \"Building LevelDB ...\"; cd leveldb; make libleveldb.a libmemenv.a; cd ..;\n obj/leveldb.o: leveldb/libleveldb.a\n+else\n+OBJS += obj/txdb-bdb.o\n endif\n \n # auto-generated dependencies:"
      },
      {
        "sha": "5e46096646c6e77f9e640d0d86ed715d432232ab",
        "filename": "src/txdb-bdb.cpp",
        "status": "added",
        "additions": 171,
        "deletions": 0,
        "changes": 171,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d/src/txdb-bdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d/src/txdb-bdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb-bdb.cpp?ref=6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d",
        "patch": "@@ -0,0 +1,171 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2012 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"txdb-bdb.h\"\n+\n+bool CCoinsDB::HaveCoins(uint256 hash) {\n+    assert(!fClient);\n+    return Exists(make_pair('c', hash));\n+}\n+\n+bool CCoinsDB::ReadCoins(uint256 hash, CCoins &coins) {\n+    assert(!fClient);\n+    return Read(make_pair('c', hash), coins);\n+}\n+\n+bool CCoinsDB::WriteCoins(uint256 hash, const CCoins &coins) {\n+    assert(!fClient);\n+    if (coins.IsPruned())\n+        return Erase(make_pair('c', hash));\n+    else\n+        return Write(make_pair('c', hash), coins);\n+}\n+\n+bool CCoinsDB::ReadHashBestChain(uint256& hashBestChain)\n+{\n+    return Read('B', hashBestChain);\n+}\n+\n+bool CCoinsDB::WriteHashBestChain(uint256 hashBestChain)\n+{\n+    return Write('B', hashBestChain);\n+}\n+\n+bool CBlockTreeDB::WriteBlockIndex(const CDiskBlockIndex& blockindex)\n+{\n+    return Write(make_pair('b', blockindex.GetBlockHash()), blockindex);\n+}\n+\n+bool CBlockTreeDB::ReadBestInvalidWork(CBigNum& bnBestInvalidWork)\n+{\n+    return Read('I', bnBestInvalidWork);\n+}\n+\n+bool CBlockTreeDB::WriteBestInvalidWork(CBigNum bnBestInvalidWork)\n+{\n+    return Write('I', bnBestInvalidWork);\n+}\n+\n+bool CBlockTreeDB::WriteBlockFileInfo(int nFile, const CBlockFileInfo &info) {\n+    return Write(make_pair('f', nFile), info);\n+}\n+\n+bool CBlockTreeDB::ReadBlockFileInfo(int nFile, CBlockFileInfo &info) {\n+    return Read(make_pair('f', nFile), info);\n+}\n+\n+bool CBlockTreeDB::WriteLastBlockFile(int nFile) {\n+    return Write('l', nFile);\n+}\n+\n+bool CBlockTreeDB::ReadLastBlockFile(int &nFile) {\n+    return Read('l', nFile);\n+}\n+\n+CCoinsViewDB::CCoinsViewDB() : db(\"cr+\") {}\n+bool CCoinsViewDB::GetCoins(uint256 txid, CCoins &coins) { return db.ReadCoins(txid, coins); }\n+bool CCoinsViewDB::SetCoins(uint256 txid, const CCoins &coins) { return db.WriteCoins(txid, coins); }\n+bool CCoinsViewDB::HaveCoins(uint256 txid) { return db.HaveCoins(txid); }\n+CBlockIndex *CCoinsViewDB::GetBestBlock() {\n+    uint256 hashBestChain;\n+    if (!db.ReadHashBestChain(hashBestChain))\n+        return NULL;\n+    std::map<uint256, CBlockIndex*>::iterator it = mapBlockIndex.find(hashBestChain);\n+    if (it == mapBlockIndex.end())\n+        return NULL;\n+    return it->second;\n+}\n+bool CCoinsViewDB::SetBestBlock(CBlockIndex *pindex) { return db.WriteHashBestChain(pindex->GetBlockHash()); }\n+bool CCoinsViewDB::BatchWrite(const std::map<uint256, CCoins> &mapCoins, CBlockIndex *pindex) {\n+    printf(\"Committing %u changed transactions to coin database...\\n\", (unsigned int)mapCoins.size());\n+\n+    if (!db.TxnBegin())\n+        return false;\n+    bool fOk = true;\n+    for (std::map<uint256, CCoins>::const_iterator it = mapCoins.begin(); it != mapCoins.end(); it++) {\n+        fOk = db.WriteCoins(it->first, it->second);\n+        if (!fOk)\n+            break;\n+    }\n+    if (fOk)\n+        fOk = db.WriteHashBestChain(pindex->GetBlockHash());\n+\n+    if (!fOk)\n+        db.TxnAbort();\n+    else\n+        fOk = db.TxnCommit();\n+\n+    return fOk;\n+}\n+\n+\n+bool CBlockTreeDB::LoadBlockIndexGuts()\n+{\n+    // Get database cursor\n+    Dbc* pcursor = GetCursor();\n+    if (!pcursor)\n+        return false;\n+\n+    // Load mapBlockIndex\n+    unsigned int fFlags = DB_SET_RANGE;\n+    loop\n+    {\n+        // Read next record\n+        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n+        if (fFlags == DB_SET_RANGE)\n+            ssKey << make_pair('b', uint256(0));\n+        CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n+        int ret = ReadAtCursor(pcursor, ssKey, ssValue, fFlags);\n+        fFlags = DB_NEXT;\n+        if (ret == DB_NOTFOUND)\n+            break;\n+        else if (ret != 0)\n+            return false;\n+\n+        // Unserialize\n+\n+        try {\n+        char chType;\n+        ssKey >> chType;\n+        if (chType == 'b' && !fRequestShutdown)\n+        {\n+            CDiskBlockIndex diskindex;\n+            ssValue >> diskindex;\n+\n+            // Construct block index object\n+            CBlockIndex* pindexNew = InsertBlockIndex(diskindex.GetBlockHash());\n+            pindexNew->pprev          = InsertBlockIndex(diskindex.hashPrev);\n+            pindexNew->nHeight        = diskindex.nHeight;\n+            pindexNew->nFile          = diskindex.nFile;\n+            pindexNew->nDataPos       = diskindex.nDataPos;\n+            pindexNew->nUndoPos       = diskindex.nUndoPos;\n+            pindexNew->nVersion       = diskindex.nVersion;\n+            pindexNew->hashMerkleRoot = diskindex.hashMerkleRoot;\n+            pindexNew->nTime          = diskindex.nTime;\n+            pindexNew->nBits          = diskindex.nBits;\n+            pindexNew->nNonce         = diskindex.nNonce;\n+            pindexNew->nStatus        = diskindex.nStatus;\n+            pindexNew->nTx            = diskindex.nTx;\n+\n+            // Watch for genesis block\n+            if (pindexGenesisBlock == NULL && diskindex.GetBlockHash() == hashGenesisBlock)\n+                pindexGenesisBlock = pindexNew;\n+\n+            if (!pindexNew->CheckIndex())\n+                return error(\"LoadBlockIndex() : CheckIndex failed: %s\", pindexNew->ToString().c_str());\n+        }\n+        else\n+        {\n+            break; // if shutdown requested or finished loading block index\n+        }\n+        }    // try\n+        catch (std::exception &e) {\n+            return error(\"%s() : deserialize error\", __PRETTY_FUNCTION__);\n+        }\n+    }\n+    pcursor->close();\n+\n+    return true;\n+}"
      },
      {
        "sha": "d61e95bac2ca3f6ed16f12ebeefabb413187b81b",
        "filename": "src/txdb-bdb.h",
        "status": "added",
        "additions": 61,
        "deletions": 0,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d/src/txdb-bdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d/src/txdb-bdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb-bdb.h?ref=6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d",
        "patch": "@@ -0,0 +1,61 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2012 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#ifndef BITCOIN_TXDB_BDB_H\n+#define BITCOIN_TXDB_BDB_H\n+\n+#include \"db.h\"\n+\n+/** Access to the transaction database (coins.dat) */\n+class CCoinsDB : public CDB\n+{\n+public:\n+    CCoinsDB(const char* pszMode=\"r+\") : CDB(\"coins.dat\", pszMode) { }\n+private:\n+    CCoinsDB(const CCoinsDB&);\n+    void operator=(const CCoinsDB&);\n+public:\n+    bool ReadCoins(uint256 hash, CCoins &coins);\n+    bool WriteCoins(uint256 hash, const CCoins& coins);\n+    bool HaveCoins(uint256 hash);\n+    bool ReadHashBestChain(uint256& hashBestChain);\n+    bool WriteHashBestChain(uint256 hashBestChain);\n+};\n+\n+/** CCoinsView backed by a CCoinsDB */\n+class CCoinsViewDB : public CCoinsView\n+{\n+protected:\n+    CCoinsDB db;\n+public:\n+    CCoinsViewDB();\n+\n+    bool GetCoins(uint256 txid, CCoins &coins);\n+    bool SetCoins(uint256 txid, const CCoins &coins);\n+    bool HaveCoins(uint256 txid);\n+    CBlockIndex *GetBestBlock();\n+    bool SetBestBlock(CBlockIndex *pindex);\n+    bool BatchWrite(const std::map<uint256, CCoins> &mapCoins, CBlockIndex *pindex);\n+};\n+\n+/** Access to the block database (blktree.dat) */\n+class CBlockTreeDB : public CDB\n+{\n+public:\n+    CBlockTreeDB(const char* pszMode=\"r+\") : CDB(\"blktree.dat\", pszMode) { }\n+private:\n+    CBlockTreeDB(const CBlockTreeDB&);\n+    void operator=(const CBlockTreeDB&);\n+public:\n+    bool WriteBlockIndex(const CDiskBlockIndex& blockindex);\n+    bool ReadBestInvalidWork(CBigNum& bnBestInvalidWork);\n+    bool WriteBestInvalidWork(CBigNum bnBestInvalidWork);\n+    bool ReadBlockFileInfo(int nFile, CBlockFileInfo &fileinfo);\n+    bool WriteBlockFileInfo(int nFile, const CBlockFileInfo &fileinfo);\n+    bool ReadLastBlockFile(int &nFile);\n+    bool WriteLastBlockFile(int nFile);\n+    bool LoadBlockIndexGuts();\n+};\n+\n+#endif // BITCOIN_TXDB_BDB_H"
      },
      {
        "sha": "83a71c97d2e6d1fe75a3cbddfc5fb9fe1bcf4a45",
        "filename": "src/txdb-leveldb.cpp",
        "status": "added",
        "additions": 151,
        "deletions": 0,
        "changes": 151,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d/src/txdb-leveldb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d/src/txdb-leveldb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb-leveldb.cpp?ref=6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d",
        "patch": "@@ -0,0 +1,151 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2012 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"txdb-leveldb.h\"\n+#include \"main.h\"\n+\n+using namespace std;\n+\n+void static BatchWriteCoins(CLevelDBBatch &batch, const uint256 &hash, const CCoins &coins) {\n+    if (coins.IsPruned())\n+        batch.Erase(make_pair('c', hash));\n+    else\n+        batch.Write(make_pair('c', hash), coins);\n+}\n+\n+void static BatchWriteHashBestChain(CLevelDBBatch &batch, const uint256 &hash) {\n+    batch.Write('B', hash);\n+}\n+\n+CCoinsViewDB::CCoinsViewDB() : db(GetDataDir() / \"coins\") {\n+}\n+\n+bool CCoinsViewDB::GetCoins(uint256 txid, CCoins &coins) { \n+    return db.Read(make_pair('c', txid), coins); \n+}\n+\n+bool CCoinsViewDB::SetCoins(uint256 txid, const CCoins &coins) {\n+    CLevelDBBatch batch;\n+    BatchWriteCoins(batch, txid, coins);\n+    return db.WriteBatch(batch);\n+}\n+\n+bool CCoinsViewDB::HaveCoins(uint256 txid) {\n+    return db.Exists(make_pair('c', txid)); \n+}\n+\n+CBlockIndex *CCoinsViewDB::GetBestBlock() {\n+    uint256 hashBestChain;\n+    if (!db.Read('B', hashBestChain))\n+        return NULL;\n+    std::map<uint256, CBlockIndex*>::iterator it = mapBlockIndex.find(hashBestChain);\n+    if (it == mapBlockIndex.end())\n+        return NULL;\n+    return it->second;\n+}\n+\n+bool CCoinsViewDB::SetBestBlock(CBlockIndex *pindex) {\n+    CLevelDBBatch batch;\n+    BatchWriteHashBestChain(batch, pindex->GetBlockHash()); \n+    return db.WriteBatch(batch);\n+}\n+\n+bool CCoinsViewDB::BatchWrite(const std::map<uint256, CCoins> &mapCoins, CBlockIndex *pindex) {\n+    printf(\"Committing %u changed transactions to coin database...\\n\", (unsigned int)mapCoins.size());\n+\n+    CLevelDBBatch batch;\n+    for (std::map<uint256, CCoins>::const_iterator it = mapCoins.begin(); it != mapCoins.end(); it++)\n+        BatchWriteCoins(batch, it->first, it->second);\n+    BatchWriteHashBestChain(batch, pindex->GetBlockHash());\n+\n+    return db.WriteBatch(batch);\n+}\n+\n+bool CBlockTreeDB::WriteBlockIndex(const CDiskBlockIndex& blockindex)\n+{\n+    return Write(make_pair('b', blockindex.GetBlockHash()), blockindex);\n+}\n+\n+bool CBlockTreeDB::ReadBestInvalidWork(CBigNum& bnBestInvalidWork)\n+{\n+    return Read('I', bnBestInvalidWork);\n+}\n+\n+bool CBlockTreeDB::WriteBestInvalidWork(const CBigNum& bnBestInvalidWork)\n+{\n+    return Write('I', bnBestInvalidWork);\n+}\n+\n+bool CBlockTreeDB::WriteBlockFileInfo(int nFile, const CBlockFileInfo &info) {\n+    return Write(make_pair('f', nFile), info);\n+}\n+\n+bool CBlockTreeDB::ReadBlockFileInfo(int nFile, CBlockFileInfo &info) {\n+    return Read(make_pair('f', nFile), info);\n+}\n+\n+bool CBlockTreeDB::WriteLastBlockFile(int nFile) {\n+    return Write('l', nFile);\n+}\n+\n+bool CBlockTreeDB::ReadLastBlockFile(int &nFile) {\n+    return Read('l', nFile);\n+}\n+\n+bool CBlockTreeDB::LoadBlockIndexGuts()\n+{\n+    leveldb::Iterator *pcursor = NewIterator();\n+\n+    CDataStream ssKeySet(SER_DISK, CLIENT_VERSION);\n+    ssKeySet << make_pair('b', uint256(0));\n+    pcursor->Seek(ssKeySet.str());\n+\n+    // Load mapBlockIndex\n+    while (pcursor->Valid()) {\n+        try {\n+            leveldb::Slice slKey = pcursor->key();\n+            CDataStream ssKey(slKey.data(), slKey.data()+slKey.size(), SER_DISK, CLIENT_VERSION);\n+            char chType;\n+            ssKey >> chType;\n+            if (chType == 'b' && !fRequestShutdown) {\n+                leveldb::Slice slValue = pcursor->value();\n+                CDataStream ssValue(slValue.data(), slValue.data()+slValue.size(), SER_DISK, CLIENT_VERSION);\n+                CDiskBlockIndex diskindex;\n+                ssValue >> diskindex;\n+\n+                // Construct block index object\n+                CBlockIndex* pindexNew = InsertBlockIndex(diskindex.GetBlockHash());\n+                pindexNew->pprev          = InsertBlockIndex(diskindex.hashPrev);\n+                pindexNew->nHeight        = diskindex.nHeight;\n+                pindexNew->nFile          = diskindex.nFile;\n+                pindexNew->nDataPos       = diskindex.nDataPos;\n+                pindexNew->nUndoPos       = diskindex.nUndoPos;\n+                pindexNew->nVersion       = diskindex.nVersion;\n+                pindexNew->hashMerkleRoot = diskindex.hashMerkleRoot;\n+                pindexNew->nTime          = diskindex.nTime;\n+                pindexNew->nBits          = diskindex.nBits;\n+                pindexNew->nNonce         = diskindex.nNonce;\n+                pindexNew->nStatus        = diskindex.nStatus;\n+                pindexNew->nTx            = diskindex.nTx;\n+\n+                // Watch for genesis block\n+                if (pindexGenesisBlock == NULL && diskindex.GetBlockHash() == hashGenesisBlock)\n+                    pindexGenesisBlock = pindexNew;\n+\n+                if (!pindexNew->CheckIndex())\n+                    return error(\"LoadBlockIndex() : CheckIndex failed: %s\", pindexNew->ToString().c_str());\n+\n+                pcursor->Next();\n+            } else {\n+                break; // if shutdown requested or finished loading block index\n+            }\n+        } catch (std::exception &e) {\n+            return error(\"%s() : deserialize error\", __PRETTY_FUNCTION__);\n+        }\n+    }\n+    delete pcursor;\n+\n+    return true;\n+}"
      },
      {
        "sha": "e66ba8f8a0f7e292cd1b4df8070ebebddb2ce24e",
        "filename": "src/txdb-leveldb.h",
        "status": "added",
        "additions": 46,
        "deletions": 0,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d/src/txdb-leveldb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d/src/txdb-leveldb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb-leveldb.h?ref=6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d",
        "patch": "@@ -0,0 +1,46 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2012 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#ifndef BITCOIN_TXDB_LEVELDB_H\n+#define BITCOIN_TXDB_LEVELDB_H\n+\n+#include \"main.h\"\n+#include \"leveldb.h\"\n+\n+/** CCoinsView backed by the LevelDB coin database (coins/) */\n+class CCoinsViewDB : public CCoinsView\n+{\n+protected:\n+    CLevelDB db;\n+public:\n+    CCoinsViewDB();\n+\n+    bool GetCoins(uint256 txid, CCoins &coins);\n+    bool SetCoins(uint256 txid, const CCoins &coins);\n+    bool HaveCoins(uint256 txid);\n+    CBlockIndex *GetBestBlock();\n+    bool SetBestBlock(CBlockIndex *pindex);\n+    bool BatchWrite(const std::map<uint256, CCoins> &mapCoins, CBlockIndex *pindex);\n+};\n+\n+/** Access to the block database (blktree/) */\n+class CBlockTreeDB : public CLevelDB\n+{\n+public:\n+    CBlockTreeDB(const char* pszMode=\"r+\") : CLevelDB(GetDataDir() / \"blktree\") { }\n+private:\n+    CBlockTreeDB(const CBlockTreeDB&);\n+    void operator=(const CBlockTreeDB&);\n+public:\n+    bool WriteBlockIndex(const CDiskBlockIndex& blockindex);\n+    bool ReadBestInvalidWork(CBigNum& bnBestInvalidWork);\n+    bool WriteBestInvalidWork(const CBigNum& bnBestInvalidWork);\n+    bool ReadBlockFileInfo(int nFile, CBlockFileInfo &fileinfo);\n+    bool WriteBlockFileInfo(int nFile, const CBlockFileInfo &fileinfo);\n+    bool ReadLastBlockFile(int &nFile);\n+    bool WriteLastBlockFile(int nFile);\n+    bool LoadBlockIndexGuts();\n+};\n+\n+#endif // BITCOIN_TXDB_LEVELDB_H"
      },
      {
        "sha": "e21a1e6774af84e0f4cd3e278300cfe2c8b1a756",
        "filename": "src/txdb.h",
        "status": "added",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d",
        "patch": "@@ -0,0 +1,14 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2012 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#ifndef BITCOIN_TXDB_H\n+#define BITCOIN_TXDB_H\n+\n+#ifdef USE_LEVELDB\n+#include \"txdb-leveldb.h\"\n+#else\n+#include \"txdb-bdb.h\"\n+#endif\n+\n+#endif // BITCOIN_TXDB_H"
      }
    ]
  },
  {
    "sha": "3569b3a474938a7f0e734878f38acdfb65a7ff67",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozNTY5YjNhNDc0OTM4YTdmMGU3MzQ4NzhmMzhhY2RmYjY1YTdmZjY3",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-09-04T16:12:00Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-20T13:39:12Z"
      },
      "message": "Add LevelDB MemEnv support\n\nSupport LevelDB memory-backed environments, and use them in unit tests.",
      "tree": {
        "sha": "c96ed4dca6cbca2791096fe95e2e866c06016a6a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c96ed4dca6cbca2791096fe95e2e866c06016a6a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3569b3a474938a7f0e734878f38acdfb65a7ff67",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3569b3a474938a7f0e734878f38acdfb65a7ff67",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3569b3a474938a7f0e734878f38acdfb65a7ff67",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3569b3a474938a7f0e734878f38acdfb65a7ff67/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6871a20ea5e2e5c67d69ed7cbfe8c57ae27d750d"
      }
    ],
    "stats": {
      "total": 39,
      "additions": 27,
      "deletions": 12
    },
    "files": [
      {
        "sha": "4d5720306dcc56524b9591ee2fad55308f45725e",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3569b3a474938a7f0e734878f38acdfb65a7ff67/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3569b3a474938a7f0e734878f38acdfb65a7ff67/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=3569b3a474938a7f0e734878f38acdfb65a7ff67",
        "patch": "@@ -652,7 +652,7 @@ bool AppInit2()\n     uiInterface.InitMessage(_(\"Loading block index...\"));\n     printf(\"Loading block index...\\n\");\n     nStart = GetTimeMillis();\n-    pblocktree = new CBlockTreeDB(\"cr+\");\n+    pblocktree = new CBlockTreeDB();\n     pcoinsdbview = new CCoinsViewDB();\n     pcoinsTip = new CCoinsViewCache(*pcoinsdbview);\n "
      },
      {
        "sha": "e8a0fbe87469710f5f25985ce91b25dfcfbd20c4",
        "filename": "src/leveldb.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 3,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3569b3a474938a7f0e734878f38acdfb65a7ff67/src/leveldb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3569b3a474938a7f0e734878f38acdfb65a7ff67/src/leveldb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb.cpp?ref=3569b3a474938a7f0e734878f38acdfb65a7ff67",
        "patch": "@@ -8,6 +8,7 @@\n #include <leveldb/env.h>\n #include <leveldb/cache.h>\n #include <leveldb/filter_policy.h>\n+#include <memenv/memenv.h>\n \n #include <boost/filesystem.hpp>\n \n@@ -20,16 +21,21 @@ static leveldb::Options GetOptions() {\n     return options;\n }\n \n-CLevelDB::CLevelDB(const boost::filesystem::path &path) {\n+CLevelDB::CLevelDB(const boost::filesystem::path &path, bool fMemory) {\n     penv = NULL;\n     readoptions.verify_checksums = true;\n     iteroptions.verify_checksums = true;\n     iteroptions.fill_cache = false;\n     syncoptions.sync = true;\n     options = GetOptions();\n     options.create_if_missing = true;\n-    boost::filesystem::create_directory(path);\n-    printf(\"Opening LevelDB in %s\\n\", path.string().c_str());\n+    if (fMemory) {\n+        penv = leveldb::NewMemEnv(leveldb::Env::Default());\n+        options.env = penv;\n+    } else {\n+        boost::filesystem::create_directory(path);\n+        printf(\"Opening LevelDB in %s\\n\", path.string().c_str());\n+    }\n     leveldb::Status status = leveldb::DB::Open(options, path.string(), &pdb);\n     if (!status.ok())\n         throw std::runtime_error(strprintf(\"CLevelDB(): error opening database environment %s\", status.ToString().c_str()));"
      },
      {
        "sha": "ee9079c3c3725b27a797032258697d011612b0b1",
        "filename": "src/leveldb.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3569b3a474938a7f0e734878f38acdfb65a7ff67/src/leveldb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3569b3a474938a7f0e734878f38acdfb65a7ff67/src/leveldb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb.h?ref=3569b3a474938a7f0e734878f38acdfb65a7ff67",
        "patch": "@@ -69,7 +69,7 @@ class CLevelDB\n     leveldb::DB *pdb;\n \n public:\n-    CLevelDB(const boost::filesystem::path &path);\n+    CLevelDB(const boost::filesystem::path &path, bool fMemory = false);\n     ~CLevelDB();\n \n     template<typename K, typename V> bool Read(const K& key, V& value) {"
      },
      {
        "sha": "0173c0064b4f41368546d81bfa70cfe0386e4141",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3569b3a474938a7f0e734878f38acdfb65a7ff67/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3569b3a474938a7f0e734878f38acdfb65a7ff67/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=3569b3a474938a7f0e734878f38acdfb65a7ff67",
        "patch": "@@ -2,6 +2,7 @@\n #include <boost/test/unit_test.hpp>\n \n #include \"db.h\"\n+#include \"txdb.h\"\n #include \"main.h\"\n #include \"wallet.h\"\n \n@@ -18,8 +19,13 @@ struct TestingSetup {\n         fPrintToDebugger = true; // don't want to write to debug.log file\n         noui_connect();\n         bitdb.MakeMock();\n-        pblocktree = new CBlockTreeDB(\"cr+\");\n+#ifdef USE_LEVELDB\n+        pblocktree = new CBlockTreeDB(true);\n+        pcoinsdbview = new CCoinsViewDB(true);\n+#else\n+        pblocktree = new CBlockTreeDB();\n         pcoinsdbview = new CCoinsViewDB();\n+#endif\n         pcoinsTip = new CCoinsViewCache(*pcoinsdbview);\n         LoadBlockIndex(true);\n         bool fFirstRun;"
      },
      {
        "sha": "8954b8b30a544fdebac4073cc8ae35f602e92fc1",
        "filename": "src/txdb-bdb.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3569b3a474938a7f0e734878f38acdfb65a7ff67/src/txdb-bdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3569b3a474938a7f0e734878f38acdfb65a7ff67/src/txdb-bdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb-bdb.cpp?ref=3569b3a474938a7f0e734878f38acdfb65a7ff67",
        "patch": "@@ -64,7 +64,7 @@ bool CBlockTreeDB::ReadLastBlockFile(int &nFile) {\n     return Read('l', nFile);\n }\n \n-CCoinsViewDB::CCoinsViewDB() : db(\"cr+\") {}\n+CCoinsViewDB::CCoinsViewDB() : db() {}\n bool CCoinsViewDB::GetCoins(uint256 txid, CCoins &coins) { return db.ReadCoins(txid, coins); }\n bool CCoinsViewDB::SetCoins(uint256 txid, const CCoins &coins) { return db.WriteCoins(txid, coins); }\n bool CCoinsViewDB::HaveCoins(uint256 txid) { return db.HaveCoins(txid); }"
      },
      {
        "sha": "3e8d40c274866d362b24e8987be3ea2811f89955",
        "filename": "src/txdb-bdb.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3569b3a474938a7f0e734878f38acdfb65a7ff67/src/txdb-bdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3569b3a474938a7f0e734878f38acdfb65a7ff67/src/txdb-bdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb-bdb.h?ref=3569b3a474938a7f0e734878f38acdfb65a7ff67",
        "patch": "@@ -11,7 +11,7 @@\n class CCoinsDB : public CDB\n {\n public:\n-    CCoinsDB(const char* pszMode=\"r+\") : CDB(\"coins.dat\", pszMode) { }\n+    CCoinsDB() : CDB(\"coins.dat\", \"cr+\") { }\n private:\n     CCoinsDB(const CCoinsDB&);\n     void operator=(const CCoinsDB&);\n@@ -43,7 +43,7 @@ class CCoinsViewDB : public CCoinsView\n class CBlockTreeDB : public CDB\n {\n public:\n-    CBlockTreeDB(const char* pszMode=\"r+\") : CDB(\"blktree.dat\", pszMode) { }\n+    CBlockTreeDB() : CDB(\"blktree.dat\", \"cr+\") { }\n private:\n     CBlockTreeDB(const CBlockTreeDB&);\n     void operator=(const CBlockTreeDB&);"
      },
      {
        "sha": "4e2abe63d7c60e7cf2360bc6bf949552c71970b7",
        "filename": "src/txdb-leveldb.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3569b3a474938a7f0e734878f38acdfb65a7ff67/src/txdb-leveldb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3569b3a474938a7f0e734878f38acdfb65a7ff67/src/txdb-leveldb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb-leveldb.cpp?ref=3569b3a474938a7f0e734878f38acdfb65a7ff67",
        "patch": "@@ -19,7 +19,7 @@ void static BatchWriteHashBestChain(CLevelDBBatch &batch, const uint256 &hash) {\n     batch.Write('B', hash);\n }\n \n-CCoinsViewDB::CCoinsViewDB() : db(GetDataDir() / \"coins\") {\n+CCoinsViewDB::CCoinsViewDB(bool fMemory) : db(GetDataDir() / \"coins\", fMemory) {\n }\n \n bool CCoinsViewDB::GetCoins(uint256 txid, CCoins &coins) { \n@@ -63,6 +63,9 @@ bool CCoinsViewDB::BatchWrite(const std::map<uint256, CCoins> &mapCoins, CBlockI\n     return db.WriteBatch(batch);\n }\n \n+CBlockTreeDB::CBlockTreeDB(bool fMemory) : CLevelDB(GetDataDir() / \"blktree\", fMemory) {\n+}\n+\n bool CBlockTreeDB::WriteBlockIndex(const CDiskBlockIndex& blockindex)\n {\n     return Write(make_pair('b', blockindex.GetBlockHash()), blockindex);"
      },
      {
        "sha": "1254422cf03522a25e2704a671a0f651140a56cb",
        "filename": "src/txdb-leveldb.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3569b3a474938a7f0e734878f38acdfb65a7ff67/src/txdb-leveldb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3569b3a474938a7f0e734878f38acdfb65a7ff67/src/txdb-leveldb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb-leveldb.h?ref=3569b3a474938a7f0e734878f38acdfb65a7ff67",
        "patch": "@@ -14,7 +14,7 @@ class CCoinsViewDB : public CCoinsView\n protected:\n     CLevelDB db;\n public:\n-    CCoinsViewDB();\n+    CCoinsViewDB(bool fMemory = false);\n \n     bool GetCoins(uint256 txid, CCoins &coins);\n     bool SetCoins(uint256 txid, const CCoins &coins);\n@@ -28,7 +28,7 @@ class CCoinsViewDB : public CCoinsView\n class CBlockTreeDB : public CLevelDB\n {\n public:\n-    CBlockTreeDB(const char* pszMode=\"r+\") : CLevelDB(GetDataDir() / \"blktree\") { }\n+    CBlockTreeDB(bool fMemory = false);\n private:\n     CBlockTreeDB(const CBlockTreeDB&);\n     void operator=(const CBlockTreeDB&);"
      }
    ]
  },
  {
    "sha": "4a8ca807be96fc59fb94a0b29b28df9502415141",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0YThjYTgwN2JlOTZmYzU5ZmI5NGEwYjI5YjI4ZGY5NTAyNDE1MTQx",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-09-25T21:04:54Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-20T13:39:12Z"
      },
      "message": "Add gettxout and gettxoutsetinfo RPCs",
      "tree": {
        "sha": "adf8ec903008407b95da0467a0ea8fcbf4909938",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/adf8ec903008407b95da0467a0ea8fcbf4909938"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4a8ca807be96fc59fb94a0b29b28df9502415141",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4a8ca807be96fc59fb94a0b29b28df9502415141",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4a8ca807be96fc59fb94a0b29b28df9502415141",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4a8ca807be96fc59fb94a0b29b28df9502415141/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3569b3a474938a7f0e734878f38acdfb65a7ff67",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3569b3a474938a7f0e734878f38acdfb65a7ff67",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3569b3a474938a7f0e734878f38acdfb65a7ff67"
      }
    ],
    "stats": {
      "total": 118,
      "additions": 118,
      "deletions": 0
    },
    "files": [
      {
        "sha": "725037addc16180116f909c266810823a16ac8dd",
        "filename": "src/bitcoinrpc.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a8ca807be96fc59fb94a0b29b28df9502415141/src/bitcoinrpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a8ca807be96fc59fb94a0b29b28df9502415141/src/bitcoinrpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoinrpc.cpp?ref=4a8ca807be96fc59fb94a0b29b28df9502415141",
        "patch": "@@ -256,6 +256,8 @@ static const CRPCCommand vRPCCommands[] =\n     { \"decoderawtransaction\",   &decoderawtransaction,   false,  false },\n     { \"signrawtransaction\",     &signrawtransaction,     false,  false },\n     { \"sendrawtransaction\",     &sendrawtransaction,     false,  false },\n+    { \"gettxoutsetinfo\",        &gettxoutsetinfo,        true,   false },\n+    { \"gettxout\",               &gettxout,               true,   false },\n };\n \n CRPCTable::CRPCTable()\n@@ -1166,6 +1168,8 @@ Array RPCConvertValues(const std::string &strMethod, const std::vector<std::stri\n     if (strMethod == \"createrawtransaction\"   && n > 1) ConvertTo<Object>(params[1]);\n     if (strMethod == \"signrawtransaction\"     && n > 1) ConvertTo<Array>(params[1], true);\n     if (strMethod == \"signrawtransaction\"     && n > 2) ConvertTo<Array>(params[2], true);\n+    if (strMethod == \"gettxout\"               && n > 1) ConvertTo<boost::int64_t>(params[1]);\n+    if (strMethod == \"gettxout\"               && n > 2) ConvertTo<bool>(params[2]);\n \n     return params;\n }"
      },
      {
        "sha": "92906976642712598e51df2d649e2631e0b452ee",
        "filename": "src/bitcoinrpc.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a8ca807be96fc59fb94a0b29b28df9502415141/src/bitcoinrpc.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a8ca807be96fc59fb94a0b29b28df9502415141/src/bitcoinrpc.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoinrpc.h?ref=4a8ca807be96fc59fb94a0b29b28df9502415141",
        "patch": "@@ -187,5 +187,7 @@ extern json_spirit::Value settxfee(const json_spirit::Array& params, bool fHelp)\n extern json_spirit::Value getrawmempool(const json_spirit::Array& params, bool fHelp);\n extern json_spirit::Value getblockhash(const json_spirit::Array& params, bool fHelp);\n extern json_spirit::Value getblock(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value gettxoutsetinfo(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value gettxout(const json_spirit::Array& params, bool fHelp);\n \n #endif"
      },
      {
        "sha": "064ac7e10dfbcc0adf970bb49e03bf26704c8b43",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a8ca807be96fc59fb94a0b29b28df9502415141/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a8ca807be96fc59fb94a0b29b28df9502415141/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=4a8ca807be96fc59fb94a0b29b28df9502415141",
        "patch": "@@ -171,6 +171,7 @@ bool CCoinsView::HaveCoins(uint256 txid) { return false; }\n CBlockIndex *CCoinsView::GetBestBlock() { return NULL; }\n bool CCoinsView::SetBestBlock(CBlockIndex *pindex) { return false; }\n bool CCoinsView::BatchWrite(const std::map<uint256, CCoins> &mapCoins, CBlockIndex *pindex) { return false; }\n+bool CCoinsView::GetStats(CCoinsStats &stats) { return false; }\n \n \n CCoinsViewBacked::CCoinsViewBacked(CCoinsView &viewIn) : base(&viewIn) { }\n@@ -181,6 +182,7 @@ CBlockIndex *CCoinsViewBacked::GetBestBlock() { return base->GetBestBlock(); }\n bool CCoinsViewBacked::SetBestBlock(CBlockIndex *pindex) { return base->SetBestBlock(pindex); }\n void CCoinsViewBacked::SetBackend(CCoinsView &viewIn) { base = &viewIn; }\n bool CCoinsViewBacked::BatchWrite(const std::map<uint256, CCoins> &mapCoins, CBlockIndex *pindex) { return base->BatchWrite(mapCoins, pindex); }\n+bool CCoinsViewBacked::GetStats(CCoinsStats &stats) { return base->GetStats(stats); }\n \n CCoinsViewCache::CCoinsViewCache(CCoinsView &baseIn, bool fDummy) : CCoinsViewBacked(baseIn), pindexTip(NULL) { }\n "
      },
      {
        "sha": "75ee7a9be51f0b8ff1b1b0f5c7232d0996b20db5",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a8ca807be96fc59fb94a0b29b28df9502415141/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a8ca807be96fc59fb94a0b29b28df9502415141/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=4a8ca807be96fc59fb94a0b29b28df9502415141",
        "patch": "@@ -1791,6 +1791,16 @@ class CTxMemPool\n \n extern CTxMemPool mempool;\n \n+struct CCoinsStats\n+{\n+    int nHeight;\n+    uint64 nTransactions;\n+    uint64 nTransactionOutputs;\n+    uint64 nSerializedSize;\n+\n+    CCoinsStats() : nHeight(0), nTransactions(0), nTransactionOutputs(0), nSerializedSize(0) {}\n+};\n+\n /** Abstract view on the open txout dataset. */\n class CCoinsView\n {\n@@ -1811,6 +1821,7 @@ class CCoinsView\n     // Modify the currently active block index\n     virtual bool SetBestBlock(CBlockIndex *pindex);\n     virtual bool BatchWrite(const std::map<uint256, CCoins> &mapCoins, CBlockIndex *pindex);\n+    virtual bool GetStats(CCoinsStats &stats);\n };\n \n /** CCoinsView backed by another CCoinsView */\n@@ -1828,6 +1839,7 @@ class CCoinsViewBacked : public CCoinsView\n     bool SetBestBlock(CBlockIndex *pindex);\n     void SetBackend(CCoinsView &viewIn);\n     bool BatchWrite(const std::map<uint256, CCoins> &mapCoins, CBlockIndex *pindex);\n+    bool GetStats(CCoinsStats &stats);\n };\n \n /** CCoinsView that adds a memory cache for transactions to another CCoinsView */"
      },
      {
        "sha": "3fde463cd37b0ca97f3a20dad069ecd103c8af46",
        "filename": "src/rpcblockchain.cpp",
        "status": "modified",
        "additions": 62,
        "deletions": 0,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a8ca807be96fc59fb94a0b29b28df9502415141/src/rpcblockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a8ca807be96fc59fb94a0b29b28df9502415141/src/rpcblockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcblockchain.cpp?ref=4a8ca807be96fc59fb94a0b29b28df9502415141",
        "patch": "@@ -159,7 +159,69 @@ Value getblock(const Array& params, bool fHelp)\n     return blockToJSON(block, pblockindex);\n }\n \n+Value gettxoutsetinfo(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 0)\n+        throw runtime_error(\n+            \"gettxoutsetinfo\\n\"\n+            \"Returns statistics about the unspent transaction output set.\");\n+\n+    Object ret;\n+\n+    CCoinsStats stats;\n+    if (pcoinsTip->GetStats(stats)) {\n+        ret.push_back(Pair(\"bestblock\", pcoinsTip->GetBestBlock()->GetBlockHash().GetHex()));\n+        ret.push_back(Pair(\"transactions\", (boost::int64_t)stats.nTransactions));\n+        ret.push_back(Pair(\"txouts\", (boost::int64_t)stats.nTransactionOutputs));\n+        ret.push_back(Pair(\"bytes_serialized\", (boost::int64_t)stats.nSerializedSize));\n+    }\n+    return ret;\n+}\n \n+Value gettxout(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+            \"gettxout <txid> <n> [includemempool=true]\\n\"\n+            \"Returns details about an unspent transaction output.\");\n \n+    Object ret;\n+\n+    std::string strHash = params[0].get_str();\n+    uint256 hash(strHash);\n+    int n = params[1].get_int();\n+    bool fMempool = true;\n+    if (params.size() > 2)\n+        fMempool = params[2].get_bool();\n+\n+    CCoins coins;\n+    if (fMempool) {\n+        LOCK(mempool.cs);\n+        CCoinsViewMemPool view(*pcoinsTip, mempool);\n+        if (!view.GetCoins(hash, coins))\n+            return Value::null;\n+        mempool.pruneSpent(hash, coins); // TODO: this should be done by the CCoinsViewMemPool\n+    } else {\n+        if (!pcoinsTip->GetCoins(hash, coins))\n+            return Value::null;\n+    }\n+    if (n<0 || (unsigned int)n>=coins.vout.size() || coins.vout[n].IsNull())\n+        return Value::null;\n+\n+    ret.push_back(Pair(\"bestblock\", pcoinsTip->GetBestBlock()->GetBlockHash().GetHex()));\n+    if ((unsigned int)coins.nHeight == MEMPOOL_HEIGHT)\n+        ret.push_back(Pair(\"confirmations\", 0));\n+    else\n+        ret.push_back(Pair(\"confirmations\", pcoinsTip->GetBestBlock()->nHeight - coins.nHeight + 1));\n+    ret.push_back(Pair(\"amount\", (boost::int64_t)coins.vout[n].nValue));\n+    Object o;\n+    o.push_back(Pair(\"asm\", coins.vout[n].scriptPubKey.ToString()));\n+    o.push_back(Pair(\"hex\", HexStr(coins.vout[n].scriptPubKey.begin(), coins.vout[n].scriptPubKey.end())));\n+    ret.push_back(Pair(\"scriptPubKey\", o));\n+    ret.push_back(Pair(\"version\", coins.nVersion));\n+    ret.push_back(Pair(\"coinbase\", coins.fCoinBase));\n+\n+    return ret;\n+}\n \n "
      },
      {
        "sha": "7c72ccac02f196dbc011caf22919068a6a74bd4d",
        "filename": "src/txdb-leveldb.cpp",
        "status": "modified",
        "additions": 35,
        "deletions": 0,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a8ca807be96fc59fb94a0b29b28df9502415141/src/txdb-leveldb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a8ca807be96fc59fb94a0b29b28df9502415141/src/txdb-leveldb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb-leveldb.cpp?ref=4a8ca807be96fc59fb94a0b29b28df9502415141",
        "patch": "@@ -97,6 +97,41 @@ bool CBlockTreeDB::ReadLastBlockFile(int &nFile) {\n     return Read('l', nFile);\n }\n \n+bool CCoinsViewDB::GetStats(CCoinsStats &stats) {\n+    leveldb::Iterator *pcursor = db.NewIterator();\n+    pcursor->SeekToFirst();\n+\n+    while (pcursor->Valid()) {\n+        try {\n+            leveldb::Slice slKey = pcursor->key();\n+            CDataStream ssKey(slKey.data(), slKey.data()+slKey.size(), SER_DISK, CLIENT_VERSION);\n+            char chType;\n+            ssKey >> chType;\n+            if (chType == 'c' && !fRequestShutdown) {\n+                leveldb::Slice slValue = pcursor->value();\n+                CDataStream ssValue(slValue.data(), slValue.data()+slValue.size(), SER_DISK, CLIENT_VERSION);\n+                CCoins coins;\n+                ssValue >> coins;\n+                uint256 txhash;\n+                ssKey >> txhash;\n+\n+                stats.nTransactions++;\n+                BOOST_FOREACH(const CTxOut &out, coins.vout) {\n+                    if (!out.IsNull())\n+                        stats.nTransactionOutputs++;\n+                }\n+                stats.nSerializedSize += 32 + slValue.size();\n+            }\n+            pcursor->Next();\n+        } catch (std::exception &e) {\n+            return error(\"%s() : deserialize error\", __PRETTY_FUNCTION__);\n+        }\n+    }\n+    delete pcursor;\n+    stats.nHeight = GetBestBlock()->nHeight;\n+    return true;\n+}\n+\n bool CBlockTreeDB::LoadBlockIndexGuts()\n {\n     leveldb::Iterator *pcursor = NewIterator();"
      },
      {
        "sha": "123ec00d239a161e156f6abb627cb1134b19a548",
        "filename": "src/txdb-leveldb.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a8ca807be96fc59fb94a0b29b28df9502415141/src/txdb-leveldb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a8ca807be96fc59fb94a0b29b28df9502415141/src/txdb-leveldb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb-leveldb.h?ref=4a8ca807be96fc59fb94a0b29b28df9502415141",
        "patch": "@@ -22,6 +22,7 @@ class CCoinsViewDB : public CCoinsView\n     CBlockIndex *GetBestBlock();\n     bool SetBestBlock(CBlockIndex *pindex);\n     bool BatchWrite(const std::map<uint256, CCoins> &mapCoins, CBlockIndex *pindex);\n+    bool GetStats(CCoinsStats &stats);\n };\n \n /** Access to the block database (blktree/) */"
      }
    ]
  },
  {
    "sha": "b343492bfa5db9c9f9da40f33889d3e2b89846f0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMzQzNDkyYmZhNWRiOWM5ZjlkYTQwZjMzODg5ZDNlMmI4OTg0NmYw",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-16T20:23:39Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-20T13:39:12Z"
      },
      "message": "Remove BDB block database support",
      "tree": {
        "sha": "7c0df7313bf492b67bd629a01d28074f22af4104",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7c0df7313bf492b67bd629a01d28074f22af4104"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b343492bfa5db9c9f9da40f33889d3e2b89846f0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b343492bfa5db9c9f9da40f33889d3e2b89846f0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b343492bfa5db9c9f9da40f33889d3e2b89846f0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b343492bfa5db9c9f9da40f33889d3e2b89846f0/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4a8ca807be96fc59fb94a0b29b28df9502415141",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4a8ca807be96fc59fb94a0b29b28df9502415141",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4a8ca807be96fc59fb94a0b29b28df9502415141"
      }
    ],
    "stats": {
      "total": 429,
      "additions": 78,
      "deletions": 351
    },
    "files": [
      {
        "sha": "1808fcc3dceffb919d3f817fdf57e5f7a558af52",
        "filename": "bitcoin-qt.pro",
        "status": "modified",
        "additions": 20,
        "deletions": 26,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b343492bfa5db9c9f9da40f33889d3e2b89846f0/bitcoin-qt.pro",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b343492bfa5db9c9f9da40f33889d3e2b89846f0/bitcoin-qt.pro",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/bitcoin-qt.pro?ref=b343492bfa5db9c9f9da40f33889d3e2b89846f0",
        "patch": "@@ -90,33 +90,23 @@ contains(BITCOIN_NEED_QT_PLUGINS, 1) {\n     QTPLUGIN += qcncodecs qjpcodecs qtwcodecs qkrcodecs qtaccessiblewidgets\n }\n \n-contains(USE_LEVELDB, -) {\n-    message(Building without LevelDB)\n-    SOURCES += src/txdb-bdb.cpp\n-    HEADERS += src/txdb-bdb.h\n+INCLUDEPATH += src/leveldb/include src/leveldb/helpers\n+LIBS += $$PWD/src/leveldb/libleveldb.a $$PWD/src/leveldb/libmemenv.a\n+!windows {\n+    genleveldb.commands = cd $$PWD/src/leveldb ; $(MAKE) libleveldb.a libmemenv.a\n } else {\n-    message(Building with LevelDB)\n-    DEFINES += USE_LEVELDB\n-    INCLUDEPATH += src/leveldb/include src/leveldb/helpers\n-    LIBS += $$PWD/src/leveldb/libleveldb.a $$PWD/src/leveldb/libmemenv.a\n-    SOURCES += src/leveldb.cpp src/txdb-leveldb.cpp\n-    HEADERS += src/leveldb.h src/txdb-leveldb.h\n-    !windows {\n-        genleveldb.commands = cd $$PWD/src/leveldb ; $(MAKE) libleveldb.a libmemenv.a\n-    } else {\n-        # make an educated guess about what the ranlib command is called\n-        isEmpty(QMAKE_RANLIB) {\n-            QMAKE_RANLIB = $$replace(QMAKE_STRIP, strip, ranlib)\n-        }\n-        genleveldb.commands = cd $$PWD/src/leveldb ; CC=$$QMAKE_CC CXX=$$QMAKE_CXX TARGET_OS=OS_WINDOWS_CROSSCOMPILE CXXFLAGS=\"-I$$BOOST_INCLUDE_PATH\" LDFLAGS=\"-L$$BOOST_LIB_PATH\" $(MAKE) libleveldb.a libmemenv.a ; $$QMAKE_RANLIB $$PWD/src/leveldb/libleveldb.a ; $$QMAKE_RANLIB $$PWD/src/leveldb/libmemenv.a\n+    # make an educated guess about what the ranlib command is called\n+    isEmpty(QMAKE_RANLIB) {\n+        QMAKE_RANLIB = $$replace(QMAKE_STRIP, strip, ranlib)\n     }\n-    genleveldb.target = $$PWD/src/leveldb/libleveldb.a\n-    genleveldb.depends = FORCE\n-    PRE_TARGETDEPS += $$PWD/src/leveldb/libleveldb.a\n-    QMAKE_EXTRA_TARGETS += genleveldb\n-    # Gross ugly hack that depends on qmake internals, unfortunately there's no other way to do it.\n-    QMAKE_CLEAN += $$PWD/src/leveldb/libleveldb.a; cd $$PWD/src/leveldb ; $(MAKE) clean\n+    genleveldb.commands = cd $$PWD/src/leveldb ; CC=$$QMAKE_CC CXX=$$QMAKE_CXX TARGET_OS=OS_WINDOWS_CROSSCOMPILE CXXFLAGS=\"-I$$BOOST_INCLUDE_PATH\" LDFLAGS=\"-L$$BOOST_LIB_PATH\" $(MAKE) libleveldb.a libmemenv.a ; $$QMAKE_RANLIB $$PWD/src/leveldb/libleveldb.a ; $$QMAKE_RANLIB $$PWD/src/leveldb/libmemenv.a\n }\n+genleveldb.target = $$PWD/src/leveldb/libleveldb.a\n+genleveldb.depends = FORCE\n+PRE_TARGETDEPS += $$PWD/src/leveldb/libleveldb.a\n+QMAKE_EXTRA_TARGETS += genleveldb\n+# Gross ugly hack that depends on qmake internals, unfortunately there's no other way to do it.\n+QMAKE_CLEAN += $$PWD/src/leveldb/libleveldb.a; cd $$PWD/src/leveldb ; $(MAKE) clean\n \n # regenerate src/build.h\n !windows|contains(USE_BUILD_INFO, 1) {\n@@ -202,7 +192,9 @@ HEADERS += src/qt/bitcoingui.h \\\n     src/qt/rpcconsole.h \\\n     src/version.h \\\n     src/netbase.h \\\n-    src/clientversion.h\n+    src/clientversion.h \\\n+    src/txdb.h \\\n+    src/leveldb.h\n \n SOURCES += src/qt/bitcoin.cpp src/qt/bitcoingui.cpp \\\n     src/qt/transactiontablemodel.cpp \\\n@@ -262,7 +254,9 @@ SOURCES += src/qt/bitcoin.cpp src/qt/bitcoingui.cpp \\\n     src/qt/notificator.cpp \\\n     src/qt/qtipcserver.cpp \\\n     src/qt/rpcconsole.cpp \\\n-    src/noui.cpp\n+    src/noui.cpp \\\n+    src/leveldb.cpp \\\n+    src/txdb.cpp\n \n RESOURCES += \\\n     src/qt/bitcoin.qrc"
      },
      {
        "sha": "f4adbb2bff858160d9be7930af277377720a38fc",
        "filename": "src/makefile.linux-mingw",
        "status": "modified",
        "additions": 4,
        "deletions": 8,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b343492bfa5db9c9f9da40f33889d3e2b89846f0/src/makefile.linux-mingw",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b343492bfa5db9c9f9da40f33889d3e2b89846f0/src/makefile.linux-mingw",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.linux-mingw?ref=b343492bfa5db9c9f9da40f33889d3e2b89846f0",
        "patch": "@@ -6,7 +6,6 @@ DEPSDIR:=/usr/i586-mingw32msvc\n \n USE_UPNP:=0\n USE_IPV6:=1\n-USE_LEVELDB:=1\n \n INCLUDEPATHS= \\\n  -I\"$(CURDIR)\" \\\n@@ -83,21 +82,18 @@ OBJS= \\\n     obj/util.o \\\n     obj/wallet.o \\\n     obj/walletdb.o \\\n-    obj/noui.o\n+    obj/noui.o \\\n+    obj/leveldb.o \\\n+    obj/txdb.o\n \n all: bitcoind.exe\n \n-ifdef USE_LEVELDB\n LIBS += $(CURDIR)/leveldb/libleveldb.a $(CURDIR)/leveldb/libmemenv.a\n-DEFS += -I\"$(CURDIR)/leveldb/include\" -DUSE_LEVELDB\n+DEFS += -I\"$(CURDIR)/leveldb/include\"\n DEFS += -I\"$(CURDIR)/leveldb/helpers\"\n-OBJS += obj/leveldb.o obj/txdb-leveldb.o\n leveldb/libleveldb.a:\n \t@echo \"Building LevelDB ...\"; cd leveldb; TARGET_OS=OS_WINDOWS_CROSSCOMPILE CXXFLAGS=\"-I$(INCLUDEPATHS)\" LDFLAGS=\"-L$(LIBPATHS)\" make libleveldb.a libmemenv.a; cd ..\n obj/leveldb.o: leveldb/libleveldb.a\n-else\n-OBJS += obj/txdb-bdb.o\n-endif\n \n obj/build.h: FORCE\n \t/bin/sh ../share/genbuild.sh obj/build.h"
      },
      {
        "sha": "89a4f372c5f5e80e2cc8448460b2ad4f9ee1e333",
        "filename": "src/makefile.mingw",
        "status": "modified",
        "additions": 4,
        "deletions": 8,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b343492bfa5db9c9f9da40f33889d3e2b89846f0/src/makefile.mingw",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b343492bfa5db9c9f9da40f33889d3e2b89846f0/src/makefile.mingw",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.mingw?ref=b343492bfa5db9c9f9da40f33889d3e2b89846f0",
        "patch": "@@ -4,7 +4,6 @@\n \n USE_UPNP:=0\n USE_IPV6:=1\n-USE_LEVELDB:=1\n \n INCLUDEPATHS= \\\n  -I\"C:\\boost-1.50.0-mgw\" \\\n@@ -79,7 +78,9 @@ OBJS= \\\n     obj/util.o \\\n     obj/wallet.o \\\n     obj/walletdb.o \\\n-    obj/noui.o\n+    obj/noui.o \\\n+    obj/leveldb.o \\\n+    obj/txdb.o\n \n \n all: bitcoind.exe\n@@ -90,17 +91,12 @@ test check: test_bitcoin.exe FORCE\n #\n # LevelDB support\n #\n-ifdef USE_LEVELDB\n LIBS += $(CURDIR)/leveldb/libleveldb.a $(CURDIR)/leveldb/libmemenv.a\n-DEFS += $(addprefix -I,$(CURDIR)/leveldb/include) -DUSE_LEVELDB\n+DEFS += $(addprefix -I,$(CURDIR)/leveldb/include)\n DEFS += $(addprefix -I,$(CURDIR)/leveldb/helpers)\n-OBJS += obj/leveldb.o obj/txdb-leveldb.o\n leveldb/libleveldb.a:\n     cd leveldb; make libleveldb.a libmemenv.a; cd ..\n obj/leveldb.o: leveldb/libleveldb.lib\n-else\n-OBJS += obj/txdb-bdb.o\n-endif\n \n obj/%.o: %.cpp $(HEADERS)\n \tg++ -c $(CFLAGS) -o $@ $<"
      },
      {
        "sha": "f3e17d0d131417d1661724999eaba6446b7967e7",
        "filename": "src/makefile.osx",
        "status": "modified",
        "additions": 4,
        "deletions": 8,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b343492bfa5db9c9f9da40f33889d3e2b89846f0/src/makefile.osx",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b343492bfa5db9c9f9da40f33889d3e2b89846f0/src/makefile.osx",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.osx?ref=b343492bfa5db9c9f9da40f33889d3e2b89846f0",
        "patch": "@@ -21,7 +21,6 @@ LIBPATHS= \\\n \n USE_UPNP:=1\n USE_IPV6:=1\n-USE_LEVELDB:=1\n \n LIBS= -dead_strip\n \n@@ -97,7 +96,9 @@ OBJS= \\\n     obj/util.o \\\n     obj/wallet.o \\\n     obj/walletdb.o \\\n-    obj/noui.o\n+    obj/noui.o \\\n+    obj/leveldb.o \\\n+    obj/txdb.o\n \n ifndef USE_UPNP\n \toverride USE_UPNP = -\n@@ -123,17 +124,12 @@ test check: test_bitcoin FORCE\n #\n # LevelDB support\n #\n-ifdef USE_LEVELDB\n LIBS += $(CURDIR)/leveldb/libleveldb.a $(CURDIR)/leveldb/libmemenv.a\n-DEFS += $(addprefix -I,$(CURDIR)/leveldb/include) -DUSE_LEVELDB\n+DEFS += $(addprefix -I,$(CURDIR)/leveldb/include)\n DEFS += $(addprefix -I,$(CURDIR)/leveldb/helpers)\n-OBJS += obj/leveldb.o obj/txdb-leveldb.o\n leveldb/libleveldb.a:\n \t@echo \"Building LevelDB ...\"; cd leveldb; make libleveldb.a libmemenv.a; cd ..\n obj/leveldb.o: leveldb/libleveldb.a\n-else\n-OBJS += obj/txdb-bdb.o\n-endif\n \n # auto-generated dependencies:\n -include obj/*.P"
      },
      {
        "sha": "df05f7990af7774f5784ddd9db7b107a17686f28",
        "filename": "src/makefile.unix",
        "status": "modified",
        "additions": 4,
        "deletions": 8,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b343492bfa5db9c9f9da40f33889d3e2b89846f0/src/makefile.unix",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b343492bfa5db9c9f9da40f33889d3e2b89846f0/src/makefile.unix",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.unix?ref=b343492bfa5db9c9f9da40f33889d3e2b89846f0",
        "patch": "@@ -4,7 +4,6 @@\n \n USE_UPNP:=0\n USE_IPV6:=1\n-USE_LEVELDB:=1\n \n LINK:=$(CXX)\n \n@@ -128,7 +127,9 @@ OBJS= \\\n     obj/util.o \\\n     obj/wallet.o \\\n     obj/walletdb.o \\\n-    obj/noui.o\n+    obj/noui.o \\\n+    obj/leveldb.o \\\n+    obj/txdb.o\n \n \n all: bitcoind\n@@ -139,17 +140,12 @@ test check: test_bitcoin FORCE\n #\n # LevelDB support\n #\n-ifdef USE_LEVELDB\n LIBS += $(CURDIR)/leveldb/libleveldb.a $(CURDIR)/leveldb/libmemenv.a\n-DEFS += $(addprefix -I,$(CURDIR)/leveldb/include) -DUSE_LEVELDB\n+DEFS += $(addprefix -I,$(CURDIR)/leveldb/include)\n DEFS += $(addprefix -I,$(CURDIR)/leveldb/helpers)\n-OBJS += obj/leveldb.o obj/txdb-leveldb.o\n leveldb/libleveldb.a:\n \t@echo \"Building LevelDB ...\"; cd leveldb; make libleveldb.a libmemenv.a; cd ..;\n obj/leveldb.o: leveldb/libleveldb.a\n-else\n-OBJS += obj/txdb-bdb.o\n-endif\n \n # auto-generated dependencies:\n -include obj/*.P"
      },
      {
        "sha": "c1f47f786b17f3a9a5e34b5eaec5cfeecd8f8156",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b343492bfa5db9c9f9da40f33889d3e2b89846f0/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b343492bfa5db9c9f9da40f33889d3e2b89846f0/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=b343492bfa5db9c9f9da40f33889d3e2b89846f0",
        "patch": "@@ -19,13 +19,8 @@ struct TestingSetup {\n         fPrintToDebugger = true; // don't want to write to debug.log file\n         noui_connect();\n         bitdb.MakeMock();\n-#ifdef USE_LEVELDB\n         pblocktree = new CBlockTreeDB(true);\n         pcoinsdbview = new CCoinsViewDB(true);\n-#else\n-        pblocktree = new CBlockTreeDB();\n-        pcoinsdbview = new CCoinsViewDB();\n-#endif\n         pcoinsTip = new CCoinsViewCache(*pcoinsdbview);\n         LoadBlockIndex(true);\n         bool fFirstRun;"
      },
      {
        "sha": "8954b8b30a544fdebac4073cc8ae35f602e92fc1",
        "filename": "src/txdb-bdb.cpp",
        "status": "removed",
        "additions": 0,
        "deletions": 171,
        "changes": 171,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a8ca807be96fc59fb94a0b29b28df9502415141/src/txdb-bdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a8ca807be96fc59fb94a0b29b28df9502415141/src/txdb-bdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb-bdb.cpp?ref=4a8ca807be96fc59fb94a0b29b28df9502415141",
        "patch": "@@ -1,171 +0,0 @@\n-// Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2012 The Bitcoin developers\n-// Distributed under the MIT/X11 software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include \"txdb-bdb.h\"\n-\n-bool CCoinsDB::HaveCoins(uint256 hash) {\n-    assert(!fClient);\n-    return Exists(make_pair('c', hash));\n-}\n-\n-bool CCoinsDB::ReadCoins(uint256 hash, CCoins &coins) {\n-    assert(!fClient);\n-    return Read(make_pair('c', hash), coins);\n-}\n-\n-bool CCoinsDB::WriteCoins(uint256 hash, const CCoins &coins) {\n-    assert(!fClient);\n-    if (coins.IsPruned())\n-        return Erase(make_pair('c', hash));\n-    else\n-        return Write(make_pair('c', hash), coins);\n-}\n-\n-bool CCoinsDB::ReadHashBestChain(uint256& hashBestChain)\n-{\n-    return Read('B', hashBestChain);\n-}\n-\n-bool CCoinsDB::WriteHashBestChain(uint256 hashBestChain)\n-{\n-    return Write('B', hashBestChain);\n-}\n-\n-bool CBlockTreeDB::WriteBlockIndex(const CDiskBlockIndex& blockindex)\n-{\n-    return Write(make_pair('b', blockindex.GetBlockHash()), blockindex);\n-}\n-\n-bool CBlockTreeDB::ReadBestInvalidWork(CBigNum& bnBestInvalidWork)\n-{\n-    return Read('I', bnBestInvalidWork);\n-}\n-\n-bool CBlockTreeDB::WriteBestInvalidWork(CBigNum bnBestInvalidWork)\n-{\n-    return Write('I', bnBestInvalidWork);\n-}\n-\n-bool CBlockTreeDB::WriteBlockFileInfo(int nFile, const CBlockFileInfo &info) {\n-    return Write(make_pair('f', nFile), info);\n-}\n-\n-bool CBlockTreeDB::ReadBlockFileInfo(int nFile, CBlockFileInfo &info) {\n-    return Read(make_pair('f', nFile), info);\n-}\n-\n-bool CBlockTreeDB::WriteLastBlockFile(int nFile) {\n-    return Write('l', nFile);\n-}\n-\n-bool CBlockTreeDB::ReadLastBlockFile(int &nFile) {\n-    return Read('l', nFile);\n-}\n-\n-CCoinsViewDB::CCoinsViewDB() : db() {}\n-bool CCoinsViewDB::GetCoins(uint256 txid, CCoins &coins) { return db.ReadCoins(txid, coins); }\n-bool CCoinsViewDB::SetCoins(uint256 txid, const CCoins &coins) { return db.WriteCoins(txid, coins); }\n-bool CCoinsViewDB::HaveCoins(uint256 txid) { return db.HaveCoins(txid); }\n-CBlockIndex *CCoinsViewDB::GetBestBlock() {\n-    uint256 hashBestChain;\n-    if (!db.ReadHashBestChain(hashBestChain))\n-        return NULL;\n-    std::map<uint256, CBlockIndex*>::iterator it = mapBlockIndex.find(hashBestChain);\n-    if (it == mapBlockIndex.end())\n-        return NULL;\n-    return it->second;\n-}\n-bool CCoinsViewDB::SetBestBlock(CBlockIndex *pindex) { return db.WriteHashBestChain(pindex->GetBlockHash()); }\n-bool CCoinsViewDB::BatchWrite(const std::map<uint256, CCoins> &mapCoins, CBlockIndex *pindex) {\n-    printf(\"Committing %u changed transactions to coin database...\\n\", (unsigned int)mapCoins.size());\n-\n-    if (!db.TxnBegin())\n-        return false;\n-    bool fOk = true;\n-    for (std::map<uint256, CCoins>::const_iterator it = mapCoins.begin(); it != mapCoins.end(); it++) {\n-        fOk = db.WriteCoins(it->first, it->second);\n-        if (!fOk)\n-            break;\n-    }\n-    if (fOk)\n-        fOk = db.WriteHashBestChain(pindex->GetBlockHash());\n-\n-    if (!fOk)\n-        db.TxnAbort();\n-    else\n-        fOk = db.TxnCommit();\n-\n-    return fOk;\n-}\n-\n-\n-bool CBlockTreeDB::LoadBlockIndexGuts()\n-{\n-    // Get database cursor\n-    Dbc* pcursor = GetCursor();\n-    if (!pcursor)\n-        return false;\n-\n-    // Load mapBlockIndex\n-    unsigned int fFlags = DB_SET_RANGE;\n-    loop\n-    {\n-        // Read next record\n-        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n-        if (fFlags == DB_SET_RANGE)\n-            ssKey << make_pair('b', uint256(0));\n-        CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n-        int ret = ReadAtCursor(pcursor, ssKey, ssValue, fFlags);\n-        fFlags = DB_NEXT;\n-        if (ret == DB_NOTFOUND)\n-            break;\n-        else if (ret != 0)\n-            return false;\n-\n-        // Unserialize\n-\n-        try {\n-        char chType;\n-        ssKey >> chType;\n-        if (chType == 'b' && !fRequestShutdown)\n-        {\n-            CDiskBlockIndex diskindex;\n-            ssValue >> diskindex;\n-\n-            // Construct block index object\n-            CBlockIndex* pindexNew = InsertBlockIndex(diskindex.GetBlockHash());\n-            pindexNew->pprev          = InsertBlockIndex(diskindex.hashPrev);\n-            pindexNew->nHeight        = diskindex.nHeight;\n-            pindexNew->nFile          = diskindex.nFile;\n-            pindexNew->nDataPos       = diskindex.nDataPos;\n-            pindexNew->nUndoPos       = diskindex.nUndoPos;\n-            pindexNew->nVersion       = diskindex.nVersion;\n-            pindexNew->hashMerkleRoot = diskindex.hashMerkleRoot;\n-            pindexNew->nTime          = diskindex.nTime;\n-            pindexNew->nBits          = diskindex.nBits;\n-            pindexNew->nNonce         = diskindex.nNonce;\n-            pindexNew->nStatus        = diskindex.nStatus;\n-            pindexNew->nTx            = diskindex.nTx;\n-\n-            // Watch for genesis block\n-            if (pindexGenesisBlock == NULL && diskindex.GetBlockHash() == hashGenesisBlock)\n-                pindexGenesisBlock = pindexNew;\n-\n-            if (!pindexNew->CheckIndex())\n-                return error(\"LoadBlockIndex() : CheckIndex failed: %s\", pindexNew->ToString().c_str());\n-        }\n-        else\n-        {\n-            break; // if shutdown requested or finished loading block index\n-        }\n-        }    // try\n-        catch (std::exception &e) {\n-            return error(\"%s() : deserialize error\", __PRETTY_FUNCTION__);\n-        }\n-    }\n-    pcursor->close();\n-\n-    return true;\n-}"
      },
      {
        "sha": "3e8d40c274866d362b24e8987be3ea2811f89955",
        "filename": "src/txdb-bdb.h",
        "status": "removed",
        "additions": 0,
        "deletions": 61,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a8ca807be96fc59fb94a0b29b28df9502415141/src/txdb-bdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a8ca807be96fc59fb94a0b29b28df9502415141/src/txdb-bdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb-bdb.h?ref=4a8ca807be96fc59fb94a0b29b28df9502415141",
        "patch": "@@ -1,61 +0,0 @@\n-// Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2012 The Bitcoin developers\n-// Distributed under the MIT/X11 software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-#ifndef BITCOIN_TXDB_BDB_H\n-#define BITCOIN_TXDB_BDB_H\n-\n-#include \"db.h\"\n-\n-/** Access to the transaction database (coins.dat) */\n-class CCoinsDB : public CDB\n-{\n-public:\n-    CCoinsDB() : CDB(\"coins.dat\", \"cr+\") { }\n-private:\n-    CCoinsDB(const CCoinsDB&);\n-    void operator=(const CCoinsDB&);\n-public:\n-    bool ReadCoins(uint256 hash, CCoins &coins);\n-    bool WriteCoins(uint256 hash, const CCoins& coins);\n-    bool HaveCoins(uint256 hash);\n-    bool ReadHashBestChain(uint256& hashBestChain);\n-    bool WriteHashBestChain(uint256 hashBestChain);\n-};\n-\n-/** CCoinsView backed by a CCoinsDB */\n-class CCoinsViewDB : public CCoinsView\n-{\n-protected:\n-    CCoinsDB db;\n-public:\n-    CCoinsViewDB();\n-\n-    bool GetCoins(uint256 txid, CCoins &coins);\n-    bool SetCoins(uint256 txid, const CCoins &coins);\n-    bool HaveCoins(uint256 txid);\n-    CBlockIndex *GetBestBlock();\n-    bool SetBestBlock(CBlockIndex *pindex);\n-    bool BatchWrite(const std::map<uint256, CCoins> &mapCoins, CBlockIndex *pindex);\n-};\n-\n-/** Access to the block database (blktree.dat) */\n-class CBlockTreeDB : public CDB\n-{\n-public:\n-    CBlockTreeDB() : CDB(\"blktree.dat\", \"cr+\") { }\n-private:\n-    CBlockTreeDB(const CBlockTreeDB&);\n-    void operator=(const CBlockTreeDB&);\n-public:\n-    bool WriteBlockIndex(const CDiskBlockIndex& blockindex);\n-    bool ReadBestInvalidWork(CBigNum& bnBestInvalidWork);\n-    bool WriteBestInvalidWork(CBigNum bnBestInvalidWork);\n-    bool ReadBlockFileInfo(int nFile, CBlockFileInfo &fileinfo);\n-    bool WriteBlockFileInfo(int nFile, const CBlockFileInfo &fileinfo);\n-    bool ReadLastBlockFile(int &nFile);\n-    bool WriteLastBlockFile(int nFile);\n-    bool LoadBlockIndexGuts();\n-};\n-\n-#endif // BITCOIN_TXDB_BDB_H"
      },
      {
        "sha": "123ec00d239a161e156f6abb627cb1134b19a548",
        "filename": "src/txdb-leveldb.h",
        "status": "removed",
        "additions": 0,
        "deletions": 47,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4a8ca807be96fc59fb94a0b29b28df9502415141/src/txdb-leveldb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4a8ca807be96fc59fb94a0b29b28df9502415141/src/txdb-leveldb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb-leveldb.h?ref=4a8ca807be96fc59fb94a0b29b28df9502415141",
        "patch": "@@ -1,47 +0,0 @@\n-// Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2012 The Bitcoin developers\n-// Distributed under the MIT/X11 software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-#ifndef BITCOIN_TXDB_LEVELDB_H\n-#define BITCOIN_TXDB_LEVELDB_H\n-\n-#include \"main.h\"\n-#include \"leveldb.h\"\n-\n-/** CCoinsView backed by the LevelDB coin database (coins/) */\n-class CCoinsViewDB : public CCoinsView\n-{\n-protected:\n-    CLevelDB db;\n-public:\n-    CCoinsViewDB(bool fMemory = false);\n-\n-    bool GetCoins(uint256 txid, CCoins &coins);\n-    bool SetCoins(uint256 txid, const CCoins &coins);\n-    bool HaveCoins(uint256 txid);\n-    CBlockIndex *GetBestBlock();\n-    bool SetBestBlock(CBlockIndex *pindex);\n-    bool BatchWrite(const std::map<uint256, CCoins> &mapCoins, CBlockIndex *pindex);\n-    bool GetStats(CCoinsStats &stats);\n-};\n-\n-/** Access to the block database (blktree/) */\n-class CBlockTreeDB : public CLevelDB\n-{\n-public:\n-    CBlockTreeDB(bool fMemory = false);\n-private:\n-    CBlockTreeDB(const CBlockTreeDB&);\n-    void operator=(const CBlockTreeDB&);\n-public:\n-    bool WriteBlockIndex(const CDiskBlockIndex& blockindex);\n-    bool ReadBestInvalidWork(CBigNum& bnBestInvalidWork);\n-    bool WriteBestInvalidWork(const CBigNum& bnBestInvalidWork);\n-    bool ReadBlockFileInfo(int nFile, CBlockFileInfo &fileinfo);\n-    bool WriteBlockFileInfo(int nFile, const CBlockFileInfo &fileinfo);\n-    bool ReadLastBlockFile(int &nFile);\n-    bool WriteLastBlockFile(int nFile);\n-    bool LoadBlockIndexGuts();\n-};\n-\n-#endif // BITCOIN_TXDB_LEVELDB_H"
      },
      {
        "sha": "67d15cb58fd2fa7c38dd137a7a00b4eeac700919",
        "filename": "src/txdb.cpp",
        "status": "renamed",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b343492bfa5db9c9f9da40f33889d3e2b89846f0/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b343492bfa5db9c9f9da40f33889d3e2b89846f0/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=b343492bfa5db9c9f9da40f33889d3e2b89846f0",
        "patch": "@@ -3,7 +3,7 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include \"txdb-leveldb.h\"\n+#include \"txdb.h\"\n #include \"main.h\"\n \n using namespace std;",
        "previous_filename": "src/txdb-leveldb.cpp"
      },
      {
        "sha": "123ec00d239a161e156f6abb627cb1134b19a548",
        "filename": "src/txdb.h",
        "status": "modified",
        "additions": 41,
        "deletions": 8,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b343492bfa5db9c9f9da40f33889d3e2b89846f0/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b343492bfa5db9c9f9da40f33889d3e2b89846f0/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=b343492bfa5db9c9f9da40f33889d3e2b89846f0",
        "patch": "@@ -2,13 +2,46 @@\n // Copyright (c) 2009-2012 The Bitcoin developers\n // Distributed under the MIT/X11 software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-#ifndef BITCOIN_TXDB_H\n-#define BITCOIN_TXDB_H\n+#ifndef BITCOIN_TXDB_LEVELDB_H\n+#define BITCOIN_TXDB_LEVELDB_H\n \n-#ifdef USE_LEVELDB\n-#include \"txdb-leveldb.h\"\n-#else\n-#include \"txdb-bdb.h\"\n-#endif\n+#include \"main.h\"\n+#include \"leveldb.h\"\n \n-#endif // BITCOIN_TXDB_H\n+/** CCoinsView backed by the LevelDB coin database (coins/) */\n+class CCoinsViewDB : public CCoinsView\n+{\n+protected:\n+    CLevelDB db;\n+public:\n+    CCoinsViewDB(bool fMemory = false);\n+\n+    bool GetCoins(uint256 txid, CCoins &coins);\n+    bool SetCoins(uint256 txid, const CCoins &coins);\n+    bool HaveCoins(uint256 txid);\n+    CBlockIndex *GetBestBlock();\n+    bool SetBestBlock(CBlockIndex *pindex);\n+    bool BatchWrite(const std::map<uint256, CCoins> &mapCoins, CBlockIndex *pindex);\n+    bool GetStats(CCoinsStats &stats);\n+};\n+\n+/** Access to the block database (blktree/) */\n+class CBlockTreeDB : public CLevelDB\n+{\n+public:\n+    CBlockTreeDB(bool fMemory = false);\n+private:\n+    CBlockTreeDB(const CBlockTreeDB&);\n+    void operator=(const CBlockTreeDB&);\n+public:\n+    bool WriteBlockIndex(const CDiskBlockIndex& blockindex);\n+    bool ReadBestInvalidWork(CBigNum& bnBestInvalidWork);\n+    bool WriteBestInvalidWork(const CBigNum& bnBestInvalidWork);\n+    bool ReadBlockFileInfo(int nFile, CBlockFileInfo &fileinfo);\n+    bool WriteBlockFileInfo(int nFile, const CBlockFileInfo &fileinfo);\n+    bool ReadLastBlockFile(int &nFile);\n+    bool WriteLastBlockFile(int nFile);\n+    bool LoadBlockIndexGuts();\n+};\n+\n+#endif // BITCOIN_TXDB_LEVELDB_H"
      }
    ]
  },
  {
    "sha": "1b93546674e9a5993a0858f7bc8b12564f12d05e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxYjkzNTQ2Njc0ZTlhNTk5M2EwODU4ZjdiYzhiMTI1NjRmMTJkMDVl",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-13T13:32:50Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-20T14:12:46Z"
      },
      "message": "SetHash framework",
      "tree": {
        "sha": "fb795072ea53375bcb72cb757c0e6c9b6f0b09ea",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fb795072ea53375bcb72cb757c0e6c9b6f0b09ea"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1b93546674e9a5993a0858f7bc8b12564f12d05e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1b93546674e9a5993a0858f7bc8b12564f12d05e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1b93546674e9a5993a0858f7bc8b12564f12d05e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1b93546674e9a5993a0858f7bc8b12564f12d05e/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b343492bfa5db9c9f9da40f33889d3e2b89846f0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b343492bfa5db9c9f9da40f33889d3e2b89846f0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b343492bfa5db9c9f9da40f33889d3e2b89846f0"
      }
    ],
    "stats": {
      "total": 67,
      "additions": 67,
      "deletions": 0
    },
    "files": [
      {
        "sha": "6af93d515bf8f25eb6b85b73f372c6549d96c161",
        "filename": "bitcoin-qt.pro",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1b93546674e9a5993a0858f7bc8b12564f12d05e/bitcoin-qt.pro",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1b93546674e9a5993a0858f7bc8b12564f12d05e/bitcoin-qt.pro",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/bitcoin-qt.pro?ref=1b93546674e9a5993a0858f7bc8b12564f12d05e",
        "patch": "@@ -194,6 +194,7 @@ HEADERS += src/qt/bitcoingui.h \\\n     src/netbase.h \\\n     src/clientversion.h \\\n     src/txdb.h \\\n+    src/sethash.h \\\n     src/leveldb.h\n \n SOURCES += src/qt/bitcoin.cpp src/qt/bitcoingui.cpp \\\n@@ -256,6 +257,7 @@ SOURCES += src/qt/bitcoin.cpp src/qt/bitcoingui.cpp \\\n     src/qt/rpcconsole.cpp \\\n     src/noui.cpp \\\n     src/leveldb.cpp \\\n+    src/sethash.cpp \\\n     src/txdb.cpp\n \n RESOURCES += \\"
      },
      {
        "sha": "779e00127a8b9243bdc6141a5c47d11ce3b7aa59",
        "filename": "src/makefile.linux-mingw",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1b93546674e9a5993a0858f7bc8b12564f12d05e/src/makefile.linux-mingw",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1b93546674e9a5993a0858f7bc8b12564f12d05e/src/makefile.linux-mingw",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.linux-mingw?ref=1b93546674e9a5993a0858f7bc8b12564f12d05e",
        "patch": "@@ -84,6 +84,7 @@ OBJS= \\\n     obj/walletdb.o \\\n     obj/noui.o \\\n     obj/leveldb.o \\\n+    obj/sethash.o \\\n     obj/txdb.o\n \n all: bitcoind.exe"
      },
      {
        "sha": "b54901afa5db96d2cd2097cebeec98d5fe3f9bc5",
        "filename": "src/makefile.mingw",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1b93546674e9a5993a0858f7bc8b12564f12d05e/src/makefile.mingw",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1b93546674e9a5993a0858f7bc8b12564f12d05e/src/makefile.mingw",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.mingw?ref=1b93546674e9a5993a0858f7bc8b12564f12d05e",
        "patch": "@@ -80,6 +80,7 @@ OBJS= \\\n     obj/walletdb.o \\\n     obj/noui.o \\\n     obj/leveldb.o \\\n+    obj/sethash.o \\\n     obj/txdb.o\n \n "
      },
      {
        "sha": "e9596a4827670dd76eed143f4c5d4872c0fbc438",
        "filename": "src/makefile.osx",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1b93546674e9a5993a0858f7bc8b12564f12d05e/src/makefile.osx",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1b93546674e9a5993a0858f7bc8b12564f12d05e/src/makefile.osx",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.osx?ref=1b93546674e9a5993a0858f7bc8b12564f12d05e",
        "patch": "@@ -98,6 +98,7 @@ OBJS= \\\n     obj/walletdb.o \\\n     obj/noui.o \\\n     obj/leveldb.o \\\n+    obj/sethash.o \\\n     obj/txdb.o\n \n ifndef USE_UPNP"
      },
      {
        "sha": "93d8c87e47bcbf956a3e5175878f8281080bc55a",
        "filename": "src/makefile.unix",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1b93546674e9a5993a0858f7bc8b12564f12d05e/src/makefile.unix",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1b93546674e9a5993a0858f7bc8b12564f12d05e/src/makefile.unix",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.unix?ref=1b93546674e9a5993a0858f7bc8b12564f12d05e",
        "patch": "@@ -129,6 +129,7 @@ OBJS= \\\n     obj/walletdb.o \\\n     obj/noui.o \\\n     obj/leveldb.o \\\n+    obj/sethash.o \\\n     obj/txdb.o\n \n "
      },
      {
        "sha": "b63364fe5799bbb2dda46d9582cb0e8e8e6b012f",
        "filename": "src/sethash.cpp",
        "status": "added",
        "additions": 25,
        "deletions": 0,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1b93546674e9a5993a0858f7bc8b12564f12d05e/src/sethash.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1b93546674e9a5993a0858f7bc8b12564f12d05e/src/sethash.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sethash.cpp?ref=1b93546674e9a5993a0858f7bc8b12564f12d05e",
        "patch": "@@ -0,0 +1,25 @@\n+#include <sethash.h>\n+\n+#include <openssl/sha.h>\n+\n+void CSetHash::addRaw(const unsigned char *pch, size_t size) {\n+    uint64 buf[8];\n+    SHA512(pch, size, (unsigned char*)buf);\n+    for (int i=0; i<8; i++) {\n+        state[i] += buf[i];\n+    }\n+}\n+\n+void CSetHash::removeRaw(const unsigned char *pch, size_t size) {\n+    uint64 buf[8];\n+    SHA512(pch, size, (unsigned char*)buf);\n+    for (int i=0; i<8; i++) {\n+        state[i] -= buf[i];\n+    }\n+}\n+\n+uint256 CSetHash::GetHash() const {\n+    uint256 ret = 0;\n+    SHA256((unsigned char*)state, 64, (unsigned char*)&ret);\n+    return ret;\n+}"
      },
      {
        "sha": "22ae67f109c9368ba6579c5debdbfe88007a8bad",
        "filename": "src/sethash.h",
        "status": "added",
        "additions": 36,
        "deletions": 0,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1b93546674e9a5993a0858f7bc8b12564f12d05e/src/sethash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1b93546674e9a5993a0858f7bc8b12564f12d05e/src/sethash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sethash.h?ref=1b93546674e9a5993a0858f7bc8b12564f12d05e",
        "patch": "@@ -0,0 +1,36 @@\n+#ifndef _SETHASH_H_\n+#define _SETHASH_H_ 1\n+\n+#include \"serialize.h\"\n+#include \"uint256.h\"\n+#include \"version.h\"\n+\n+class CSetHash\n+{\n+private:\n+    uint64 state[8];\n+\n+protected:\n+    void addRaw(const unsigned char *pch, size_t size);\n+    void removeRaw(const unsigned char *pch, size_t size);\n+\n+public:\n+    CSetHash() {\n+        memset(state, 0, 64);\n+    }\n+\n+    template<typename D> void add(const D& input) {\n+        CDataStream ss(SER_DISK, CLIENT_VERSION);\n+        ss << input;\n+        addRaw((const unsigned char*)&ss[0], ss.size());\n+    }\n+    template<typename D> void remove(const D& input) {\n+        CDataStream ss(SER_DISK, CLIENT_VERSION);\n+        ss << input;\n+        removeRaw((const unsigned char*)&ss[0], ss.size());\n+    }\n+\n+    uint256 GetHash() const;\n+};\n+\n+#endif"
      }
    ]
  },
  {
    "sha": "f625f941c18992d2744ae10986afed54d17a07ef",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmNjI1Zjk0MWMxODk5MmQyNzQ0YWUxMDk4NmFmZWQ1NGQxN2EwN2Vm",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-13T21:03:22Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-10-20T14:12:46Z"
      },
      "message": "Add gettxoutsethash RPC",
      "tree": {
        "sha": "3cc180d50a3721049b10d90a6d488b4e11aa04d0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3cc180d50a3721049b10d90a6d488b4e11aa04d0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f625f941c18992d2744ae10986afed54d17a07ef",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f625f941c18992d2744ae10986afed54d17a07ef",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f625f941c18992d2744ae10986afed54d17a07ef",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f625f941c18992d2744ae10986afed54d17a07ef/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1b93546674e9a5993a0858f7bc8b12564f12d05e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1b93546674e9a5993a0858f7bc8b12564f12d05e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1b93546674e9a5993a0858f7bc8b12564f12d05e"
      }
    ],
    "stats": {
      "total": 54,
      "additions": 53,
      "deletions": 1
    },
    "files": [
      {
        "sha": "e8f90c0f627c212b4df0def49e025fecf3c2924f",
        "filename": "src/bitcoinrpc.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f625f941c18992d2744ae10986afed54d17a07ef/src/bitcoinrpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f625f941c18992d2744ae10986afed54d17a07ef/src/bitcoinrpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoinrpc.cpp?ref=f625f941c18992d2744ae10986afed54d17a07ef",
        "patch": "@@ -257,6 +257,7 @@ static const CRPCCommand vRPCCommands[] =\n     { \"signrawtransaction\",     &signrawtransaction,     false,  false },\n     { \"sendrawtransaction\",     &sendrawtransaction,     false,  false },\n     { \"gettxoutsetinfo\",        &gettxoutsetinfo,        true,   false },\n+    { \"gettxoutsethash\",        &gettxoutsethash,        true,   false },\n     { \"gettxout\",               &gettxout,               true,   false },\n };\n "
      },
      {
        "sha": "c9b6804d802d2705e1ba168fa00e08b579d0d40b",
        "filename": "src/bitcoinrpc.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f625f941c18992d2744ae10986afed54d17a07ef/src/bitcoinrpc.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f625f941c18992d2744ae10986afed54d17a07ef/src/bitcoinrpc.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoinrpc.h?ref=f625f941c18992d2744ae10986afed54d17a07ef",
        "patch": "@@ -188,6 +188,7 @@ extern json_spirit::Value getrawmempool(const json_spirit::Array& params, bool f\n extern json_spirit::Value getblockhash(const json_spirit::Array& params, bool fHelp);\n extern json_spirit::Value getblock(const json_spirit::Array& params, bool fHelp);\n extern json_spirit::Value gettxoutsetinfo(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value gettxoutsethash(const json_spirit::Array& params, bool fHelp);\n extern json_spirit::Value gettxout(const json_spirit::Array& params, bool fHelp);\n \n #endif"
      },
      {
        "sha": "2ca0eec87186f2cde6b3e5be40d7644cc013891a",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f625f941c18992d2744ae10986afed54d17a07ef/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f625f941c18992d2744ae10986afed54d17a07ef/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=f625f941c18992d2744ae10986afed54d17a07ef",
        "patch": "@@ -1797,8 +1797,9 @@ struct CCoinsStats\n     uint64 nTransactions;\n     uint64 nTransactionOutputs;\n     uint64 nSerializedSize;\n+    uint256 nHash;\n \n-    CCoinsStats() : nHeight(0), nTransactions(0), nTransactionOutputs(0), nSerializedSize(0) {}\n+    CCoinsStats() : nHeight(0), nTransactions(0), nTransactionOutputs(0), nSerializedSize(0), nHash(0) {}\n };\n \n /** Abstract view on the open txout dataset. */"
      },
      {
        "sha": "05ae86855cc2cdd24e9b668dc50d749f68d83c2a",
        "filename": "src/rpcblockchain.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f625f941c18992d2744ae10986afed54d17a07ef/src/rpcblockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f625f941c18992d2744ae10986afed54d17a07ef/src/rpcblockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcblockchain.cpp?ref=f625f941c18992d2744ae10986afed54d17a07ef",
        "patch": "@@ -178,6 +178,23 @@ Value gettxoutsetinfo(const Array& params, bool fHelp)\n     return ret;\n }\n \n+Value gettxoutsethash(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 0)\n+        throw runtime_error(\n+            \"gettxoutsethash\\n\"\n+            \"Returns hash of the current unspent transaction output set.\");\n+\n+    Object ret;\n+\n+    CCoinsStats stats;\n+    if (pcoinsTip->GetStats(stats)) {\n+        ret.push_back(Pair(\"bestblock\", pcoinsTip->GetBestBlock()->GetBlockHash().GetHex()));\n+        ret.push_back(Pair(\"txoutsethash\", stats.nHash.GetHex()));\n+    }\n+    return ret;\n+}\n+\n Value gettxout(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() < 2 || params.size() > 3)"
      },
      {
        "sha": "95828c3ca0ff59d11ef0d8c388b0c64cba77e288",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 0,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f625f941c18992d2744ae10986afed54d17a07ef/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f625f941c18992d2744ae10986afed54d17a07ef/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=f625f941c18992d2744ae10986afed54d17a07ef",
        "patch": "@@ -5,6 +5,7 @@\n \n #include \"txdb.h\"\n #include \"main.h\"\n+#include \"sethash.h\"\n \n using namespace std;\n \n@@ -97,10 +98,30 @@ bool CBlockTreeDB::ReadLastBlockFile(int &nFile) {\n     return Read('l', nFile);\n }\n \n+class CPrunedOutputs\n+{\n+public:\n+    uint256 nHash;\n+    int nVersion;\n+    int nHeight;\n+    bool fCoinBase;\n+    std::vector<CTxOut> vout;\n+\n+    IMPLEMENT_SERIALIZE(\n+        READWRITE(nHash);\n+        READWRITE(nVersion);\n+        READWRITE(nHeight);\n+        READWRITE(fCoinBase);\n+        READWRITE(vout);\n+    )\n+};\n+\n bool CCoinsViewDB::GetStats(CCoinsStats &stats) {\n     leveldb::Iterator *pcursor = db.NewIterator();\n     pcursor->SeekToFirst();\n \n+    CSetHash sethash;\n+\n     while (pcursor->Valid()) {\n         try {\n             leveldb::Slice slKey = pcursor->key();\n@@ -121,6 +142,16 @@ bool CCoinsViewDB::GetStats(CCoinsStats &stats) {\n                         stats.nTransactionOutputs++;\n                 }\n                 stats.nSerializedSize += 32 + slValue.size();\n+\n+                CPrunedOutputs outs;\n+                outs.nHash = txhash;\n+                outs.nVersion = coins.nVersion;\n+                outs.nHeight = coins.nHeight;\n+                outs.fCoinBase = coins.fCoinBase;\n+                outs.vout = coins.vout;\n+                while (outs.vout.size() > 0 && outs.vout.back().IsNull())\n+                    outs.vout.pop_back();\n+                sethash.add(outs);\n             }\n             pcursor->Next();\n         } catch (std::exception &e) {\n@@ -129,6 +160,7 @@ bool CCoinsViewDB::GetStats(CCoinsStats &stats) {\n     }\n     delete pcursor;\n     stats.nHeight = GetBestBlock()->nHeight;\n+    stats.nHash = sethash.GetHash();\n     return true;\n }\n "
      }
    ]
  }
]