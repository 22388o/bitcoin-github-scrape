[
  {
    "sha": "26a93bce29fd813e1402b013f402869c25b656d1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNmE5M2JjZTI5ZmQ4MTNlMTQwMmIwMTNmNDAyODY5YzI1YjY1NmQx",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-03-08T18:30:45Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-08-14T17:40:49Z"
      },
      "message": "Remove unused variable",
      "tree": {
        "sha": "582d350a38fada01d4519f75c4311cd7c277a5ca",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/582d350a38fada01d4519f75c4311cd7c277a5ca"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/26a93bce29fd813e1402b013f402869c25b656d1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/26a93bce29fd813e1402b013f402869c25b656d1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/26a93bce29fd813e1402b013f402869c25b656d1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/26a93bce29fd813e1402b013f402869c25b656d1/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "67be6d7a177cb14ca8a68b9c6361dfaae9e64f2b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/67be6d7a177cb14ca8a68b9c6361dfaae9e64f2b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/67be6d7a177cb14ca8a68b9c6361dfaae9e64f2b"
      }
    ],
    "stats": {
      "total": 1,
      "additions": 0,
      "deletions": 1
    },
    "files": [
      {
        "sha": "4e8a96497cf7846a88cd849c79e27553a6aaeba7",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26a93bce29fd813e1402b013f402869c25b656d1/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26a93bce29fd813e1402b013f402869c25b656d1/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=26a93bce29fd813e1402b013f402869c25b656d1",
        "patch": "@@ -703,7 +703,6 @@ class CNode\n     std::vector<CAddress> vAddrToSend;\n     CRollingBloomFilter addrKnown;\n     bool fGetAddr{false};\n-    std::set<uint256> setKnown;\n     int64_t nNextAddrSend GUARDED_BY(cs_sendProcessing){0};\n     int64_t nNextLocalAddrSend GUARDED_BY(cs_sendProcessing){0};\n "
      }
    ]
  },
  {
    "sha": "4de0dbac9b286c42a9b10132b7c2d76712f1a319",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ZGUwZGJhYzliMjg2YzQyYTliMTAxMzJiN2MyZDc2NzEyZjFhMzE5",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-03-08T19:26:36Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-08-28T17:41:58Z"
      },
      "message": "[refactor] Move tx relay state to separate structure",
      "tree": {
        "sha": "028412f5e563bf5ab01a689a1ba78057b015198f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/028412f5e563bf5ab01a689a1ba78057b015198f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4de0dbac9b286c42a9b10132b7c2d76712f1a319",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4de0dbac9b286c42a9b10132b7c2d76712f1a319",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4de0dbac9b286c42a9b10132b7c2d76712f1a319",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4de0dbac9b286c42a9b10132b7c2d76712f1a319/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "26a93bce29fd813e1402b013f402869c25b656d1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/26a93bce29fd813e1402b013f402869c25b656d1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/26a93bce29fd813e1402b013f402869c25b656d1"
      }
    ],
    "stats": {
      "total": 184,
      "additions": 95,
      "deletions": 89
    },
    "files": [
      {
        "sha": "527c001308260c42d3f278e891c408310ecb2505",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 9,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4de0dbac9b286c42a9b10132b7c2d76712f1a319/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4de0dbac9b286c42a9b10132b7c2d76712f1a319/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=4de0dbac9b286c42a9b10132b7c2d76712f1a319",
        "patch": "@@ -500,8 +500,8 @@ void CNode::copyStats(CNodeStats &stats)\n     X(addr);\n     X(addrBind);\n     {\n-        LOCK(cs_filter);\n-        X(fRelayTxes);\n+        LOCK(m_tx_relay.cs_filter);\n+        stats.fRelayTxes = m_tx_relay.fRelayTxes;\n     }\n     X(nLastSend);\n     X(nLastRecv);\n@@ -529,8 +529,8 @@ void CNode::copyStats(CNodeStats &stats)\n     X(m_legacyWhitelisted);\n     X(m_permissionFlags);\n     {\n-        LOCK(cs_feeFilter);\n-        X(minFeeFilter);\n+        LOCK(m_tx_relay.cs_feeFilter);\n+        stats.minFeeFilter = m_tx_relay.minFeeFilter;\n     }\n \n     // It is common for nodes with good ping times to suddenly become lagged,\n@@ -818,11 +818,11 @@ bool CConnman::AttemptToEvictConnection()\n                 continue;\n             if (node->fDisconnect)\n                 continue;\n-            LOCK(node->cs_filter);\n+            LOCK(node->m_tx_relay.cs_filter);\n             NodeEvictionCandidate candidate = {node->GetId(), node->nTimeConnected, node->nMinPingUsecTime,\n                                                node->nLastBlockTime, node->nLastTXTime,\n                                                HasAllDesirableServiceFlags(node->nServices),\n-                                               node->fRelayTxes, node->pfilter != nullptr, node->addr, node->nKeyedNetGroup,\n+                                               node->m_tx_relay.fRelayTxes, node->m_tx_relay.pfilter != nullptr, node->addr, node->nKeyedNetGroup,\n                                                node->m_prefer_evict};\n             vEvictionCandidates.push_back(candidate);\n         }\n@@ -2625,7 +2625,6 @@ CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn\n     fInbound(fInboundIn),\n     nKeyedNetGroup(nKeyedNetGroupIn),\n     addrKnown(5000, 0.001),\n-    filterInventoryKnown(50000, 0.000001),\n     id(idIn),\n     nLocalHostNonce(nLocalHostNonceIn),\n     nLocalServices(nLocalServicesIn),\n@@ -2634,8 +2633,6 @@ CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn\n     hSocket = hSocketIn;\n     addrName = addrNameIn == \"\" ? addr.ToStringIPPort() : addrNameIn;\n     hashContinue = uint256();\n-    filterInventoryKnown.reset();\n-    pfilter = MakeUnique<CBloomFilter>();\n \n     for (const std::string &msg : getAllNetMessageTypes())\n         mapRecvBytesPerMsgCmd[msg] = 0;"
      },
      {
        "sha": "bd46d995ec7b1946a04d6f505d333111bab1a148",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 36,
        "deletions": 28,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4de0dbac9b286c42a9b10132b7c2d76712f1a319/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4de0dbac9b286c42a9b10132b7c2d76712f1a319/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=4de0dbac9b286c42a9b10132b7c2d76712f1a319",
        "patch": "@@ -676,15 +676,8 @@ class CNode\n     // Setting fDisconnect to true will cause the node to be disconnected the\n     // next time DisconnectNodes() runs\n     std::atomic_bool fDisconnect{false};\n-    // We use fRelayTxes for two purposes -\n-    // a) it allows us to not relay tx invs before receiving the peer's version message\n-    // b) the peer may tell us in its version message that we should not relay tx invs\n-    //    unless it loads a bloom filter.\n-    bool fRelayTxes GUARDED_BY(cs_filter){false};\n     bool fSentAddr{false};\n     CSemaphoreGrant grantOutbound;\n-    mutable CCriticalSection cs_filter;\n-    std::unique_ptr<CBloomFilter> pfilter PT_GUARDED_BY(cs_filter);\n     std::atomic<int> nRefCount{0};\n \n     const uint64_t nKeyedNetGroup;\n@@ -706,24 +699,43 @@ class CNode\n     int64_t nNextAddrSend GUARDED_BY(cs_sendProcessing){0};\n     int64_t nNextLocalAddrSend GUARDED_BY(cs_sendProcessing){0};\n \n-    // inventory based relay\n-    CRollingBloomFilter filterInventoryKnown GUARDED_BY(cs_inventory);\n-    // Set of transaction ids we still have to announce.\n-    // They are sorted by the mempool before relay, so the order is not important.\n-    std::set<uint256> setInventoryTxToSend;\n     // List of block ids we still have announce.\n     // There is no final sorting before sending, as they are always sent immediately\n     // and in the order requested.\n     std::vector<uint256> vInventoryBlockToSend GUARDED_BY(cs_inventory);\n     CCriticalSection cs_inventory;\n-    int64_t nNextInvSend{0};\n+\n+    struct TxRelay {\n+        TxRelay() { pfilter = MakeUnique<CBloomFilter>(); }\n+        mutable CCriticalSection cs_filter;\n+        // We use fRelayTxes for two purposes -\n+        // a) it allows us to not relay tx invs before receiving the peer's version message\n+        // b) the peer may tell us in its version message that we should not relay tx invs\n+        //    unless it loads a bloom filter.\n+        bool fRelayTxes GUARDED_BY(cs_filter){false};\n+        std::unique_ptr<CBloomFilter> pfilter PT_GUARDED_BY(cs_filter) GUARDED_BY(cs_filter);\n+\n+        mutable CCriticalSection cs_tx_inventory;\n+        CRollingBloomFilter filterInventoryKnown GUARDED_BY(cs_tx_inventory){50000, 0.000001};\n+        // Set of transaction ids we still have to announce.\n+        // They are sorted by the mempool before relay, so the order is not important.\n+        std::set<uint256> setInventoryTxToSend;\n+        // Used for BIP35 mempool sending\n+        bool fSendMempool GUARDED_BY(cs_tx_inventory){false};\n+        // Last time a \"MEMPOOL\" request was serviced.\n+        std::atomic<int64_t> timeLastMempoolReq{0};\n+        int64_t nNextInvSend{0};\n+\n+        CCriticalSection cs_feeFilter;\n+        // Minimum fee rate with which to filter inv's to this node\n+        CAmount minFeeFilter GUARDED_BY(cs_feeFilter){0};\n+        CAmount lastSentFeeFilter{0};\n+        int64_t nextSendTimeFeeFilter{0};\n+    };\n+\n+    TxRelay m_tx_relay;\n     // Used for headers announcements - unfiltered blocks to relay\n     std::vector<uint256> vBlockHashesToAnnounce GUARDED_BY(cs_inventory);\n-    // Used for BIP35 mempool sending\n-    bool fSendMempool GUARDED_BY(cs_inventory){false};\n-\n-    // Last time a \"MEMPOOL\" request was serviced.\n-    std::atomic<int64_t> timeLastMempoolReq{0};\n \n     // Block and TXN accept times\n     std::atomic<int64_t> nLastBlockTime{0};\n@@ -740,11 +752,6 @@ class CNode\n     std::atomic<int64_t> nMinPingUsecTime{std::numeric_limits<int64_t>::max()};\n     // Whether a ping is requested.\n     std::atomic<bool> fPingQueued{false};\n-    // Minimum fee rate with which to filter inv's to this node\n-    CAmount minFeeFilter GUARDED_BY(cs_feeFilter){0};\n-    CCriticalSection cs_feeFilter;\n-    CAmount lastSentFeeFilter{0};\n-    int64_t nextSendTimeFeeFilter{0};\n \n     std::set<uint256> orphan_work_set;\n \n@@ -842,19 +849,20 @@ class CNode\n     void AddInventoryKnown(const CInv& inv)\n     {\n         {\n-            LOCK(cs_inventory);\n-            filterInventoryKnown.insert(inv.hash);\n+            LOCK(m_tx_relay.cs_tx_inventory);\n+            m_tx_relay.filterInventoryKnown.insert(inv.hash);\n         }\n     }\n \n     void PushInventory(const CInv& inv)\n     {\n-        LOCK(cs_inventory);\n         if (inv.type == MSG_TX) {\n-            if (!filterInventoryKnown.contains(inv.hash)) {\n-                setInventoryTxToSend.insert(inv.hash);\n+            LOCK(m_tx_relay.cs_tx_inventory);\n+            if (!m_tx_relay.filterInventoryKnown.contains(inv.hash)) {\n+                m_tx_relay.setInventoryTxToSend.insert(inv.hash);\n             }\n         } else if (inv.type == MSG_BLOCK) {\n+            LOCK(cs_inventory);\n             vInventoryBlockToSend.push_back(inv.hash);\n         }\n     }"
      },
      {
        "sha": "c88d17b6ee5e4929fd90bd06001e5a88da3c4f6a",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 53,
        "deletions": 52,
        "changes": 105,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4de0dbac9b286c42a9b10132b7c2d76712f1a319/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4de0dbac9b286c42a9b10132b7c2d76712f1a319/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=4de0dbac9b286c42a9b10132b7c2d76712f1a319",
        "patch": "@@ -1449,10 +1449,10 @@ void static ProcessGetBlockData(CNode* pfrom, const CChainParams& chainparams, c\n                 bool sendMerkleBlock = false;\n                 CMerkleBlock merkleBlock;\n                 {\n-                    LOCK(pfrom->cs_filter);\n-                    if (pfrom->pfilter) {\n+                    LOCK(pfrom->m_tx_relay.cs_filter);\n+                    if (pfrom->m_tx_relay.pfilter) {\n                         sendMerkleBlock = true;\n-                        merkleBlock = CMerkleBlock(*pblock, *pfrom->pfilter);\n+                        merkleBlock = CMerkleBlock(*pblock, *pfrom->m_tx_relay.pfilter);\n                     }\n                 }\n                 if (sendMerkleBlock) {\n@@ -1532,11 +1532,11 @@ void static ProcessGetData(CNode* pfrom, const CChainParams& chainparams, CConnm\n             if (mi != mapRelay.end()) {\n                 connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::TX, *mi->second));\n                 push = true;\n-            } else if (pfrom->timeLastMempoolReq) {\n+            } else if (pfrom->m_tx_relay.timeLastMempoolReq) {\n                 auto txinfo = mempool.info(inv.hash);\n                 // To protect privacy, do not answer getdata using the mempool when\n                 // that TX couldn't have been INVed in reply to a MEMPOOL request.\n-                if (txinfo.tx && txinfo.nTime <= pfrom->timeLastMempoolReq) {\n+                if (txinfo.tx && txinfo.nTime <= pfrom->m_tx_relay.timeLastMempoolReq) {\n                     connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::TX, *txinfo.tx));\n                     push = true;\n                 }\n@@ -1996,8 +1996,8 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         pfrom->m_limited_node = (!(nServices & NODE_NETWORK) && (nServices & NODE_NETWORK_LIMITED));\n \n         {\n-            LOCK(pfrom->cs_filter);\n-            pfrom->fRelayTxes = fRelay; // set to true after we get the first filter* message\n+            LOCK(pfrom->m_tx_relay.cs_filter);\n+            pfrom->m_tx_relay.fRelayTxes = fRelay; // set to true after we get the first filter* message\n         }\n \n         // Change version\n@@ -3030,8 +3030,8 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             return true;\n         }\n \n-        LOCK(pfrom->cs_inventory);\n-        pfrom->fSendMempool = true;\n+        LOCK(pfrom->m_tx_relay.cs_tx_inventory);\n+        pfrom->m_tx_relay.fSendMempool = true;\n         return true;\n     }\n \n@@ -3124,10 +3124,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         }\n         else\n         {\n-            LOCK(pfrom->cs_filter);\n-            pfrom->pfilter.reset(new CBloomFilter(filter));\n-            pfrom->pfilter->UpdateEmptyFull();\n-            pfrom->fRelayTxes = true;\n+            LOCK(pfrom->m_tx_relay.cs_filter);\n+            pfrom->m_tx_relay.pfilter.reset(new CBloomFilter(filter));\n+            pfrom->m_tx_relay.pfilter->UpdateEmptyFull();\n+            pfrom->m_tx_relay.fRelayTxes = true;\n         }\n         return true;\n     }\n@@ -3142,9 +3142,9 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (vData.size() > MAX_SCRIPT_ELEMENT_SIZE) {\n             bad = true;\n         } else {\n-            LOCK(pfrom->cs_filter);\n-            if (pfrom->pfilter) {\n-                pfrom->pfilter->insert(vData);\n+            LOCK(pfrom->m_tx_relay.cs_filter);\n+            if (pfrom->m_tx_relay.pfilter) {\n+                pfrom->m_tx_relay.pfilter->insert(vData);\n             } else {\n                 bad = true;\n             }\n@@ -3157,11 +3157,11 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n     }\n \n     if (strCommand == NetMsgType::FILTERCLEAR) {\n-        LOCK(pfrom->cs_filter);\n+        LOCK(pfrom->m_tx_relay.cs_filter);\n         if (pfrom->GetLocalServices() & NODE_BLOOM) {\n-            pfrom->pfilter.reset(new CBloomFilter());\n+            pfrom->m_tx_relay.pfilter.reset(new CBloomFilter());\n         }\n-        pfrom->fRelayTxes = true;\n+        pfrom->m_tx_relay.fRelayTxes = true;\n         return true;\n     }\n \n@@ -3170,8 +3170,8 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         vRecv >> newFeeFilter;\n         if (MoneyRange(newFeeFilter)) {\n             {\n-                LOCK(pfrom->cs_feeFilter);\n-                pfrom->minFeeFilter = newFeeFilter;\n+                LOCK(pfrom->m_tx_relay.cs_feeFilter);\n+                pfrom->m_tx_relay.minFeeFilter = newFeeFilter;\n             }\n             LogPrint(BCLog::NET, \"received: feefilter of %s from peer=%d\\n\", CFeeRate(newFeeFilter).ToString(), pfrom->GetId());\n         }\n@@ -3791,69 +3791,70 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n             }\n             pto->vInventoryBlockToSend.clear();\n \n+            LOCK(pto->m_tx_relay.cs_tx_inventory);\n             // Check whether periodic sends should happen\n             bool fSendTrickle = pto->HasPermission(PF_NOBAN);\n-            if (pto->nNextInvSend < nNow) {\n+            if (pto->m_tx_relay.nNextInvSend < nNow) {\n                 fSendTrickle = true;\n                 if (pto->fInbound) {\n-                    pto->nNextInvSend = connman->PoissonNextSendInbound(nNow, INVENTORY_BROADCAST_INTERVAL);\n+                    pto->m_tx_relay.nNextInvSend = connman->PoissonNextSendInbound(nNow, INVENTORY_BROADCAST_INTERVAL);\n                 } else {\n                     // Use half the delay for outbound peers, as there is less privacy concern for them.\n-                    pto->nNextInvSend = PoissonNextSend(nNow, INVENTORY_BROADCAST_INTERVAL >> 1);\n+                    pto->m_tx_relay.nNextInvSend = PoissonNextSend(nNow, INVENTORY_BROADCAST_INTERVAL >> 1);\n                 }\n             }\n \n             // Time to send but the peer has requested we not relay transactions.\n             if (fSendTrickle) {\n-                LOCK(pto->cs_filter);\n-                if (!pto->fRelayTxes) pto->setInventoryTxToSend.clear();\n+                LOCK(pto->m_tx_relay.cs_filter);\n+                if (!pto->m_tx_relay.fRelayTxes) pto->m_tx_relay.setInventoryTxToSend.clear();\n             }\n \n             // Respond to BIP35 mempool requests\n-            if (fSendTrickle && pto->fSendMempool) {\n+            if (fSendTrickle && pto->m_tx_relay.fSendMempool) {\n                 auto vtxinfo = mempool.infoAll();\n-                pto->fSendMempool = false;\n+                pto->m_tx_relay.fSendMempool = false;\n                 CAmount filterrate = 0;\n                 {\n-                    LOCK(pto->cs_feeFilter);\n-                    filterrate = pto->minFeeFilter;\n+                    LOCK(pto->m_tx_relay.cs_feeFilter);\n+                    filterrate = pto->m_tx_relay.minFeeFilter;\n                 }\n \n-                LOCK(pto->cs_filter);\n+                LOCK(pto->m_tx_relay.cs_filter);\n \n                 for (const auto& txinfo : vtxinfo) {\n                     const uint256& hash = txinfo.tx->GetHash();\n                     CInv inv(MSG_TX, hash);\n-                    pto->setInventoryTxToSend.erase(hash);\n+                    pto->m_tx_relay.setInventoryTxToSend.erase(hash);\n                     if (filterrate) {\n                         if (txinfo.feeRate.GetFeePerK() < filterrate)\n                             continue;\n                     }\n-                    if (pto->pfilter) {\n-                        if (!pto->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n+                    if (pto->m_tx_relay.pfilter) {\n+                        if (!pto->m_tx_relay.pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                     }\n-                    pto->filterInventoryKnown.insert(hash);\n+                    pto->m_tx_relay.filterInventoryKnown.insert(hash);\n                     vInv.push_back(inv);\n                     if (vInv.size() == MAX_INV_SZ) {\n                         connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n                         vInv.clear();\n                     }\n                 }\n-                pto->timeLastMempoolReq = GetTime();\n+                pto->m_tx_relay.timeLastMempoolReq = GetTime();\n             }\n \n             // Determine transactions to relay\n             if (fSendTrickle) {\n                 // Produce a vector with all candidates for sending\n                 std::vector<std::set<uint256>::iterator> vInvTx;\n-                vInvTx.reserve(pto->setInventoryTxToSend.size());\n-                for (std::set<uint256>::iterator it = pto->setInventoryTxToSend.begin(); it != pto->setInventoryTxToSend.end(); it++) {\n+                vInvTx.reserve(pto->m_tx_relay.setInventoryTxToSend.size());\n+                for (std::set<uint256>::iterator it = pto->m_tx_relay.setInventoryTxToSend.begin(); it != pto->m_tx_relay.setInventoryTxToSend.end(); it++) {\n                     vInvTx.push_back(it);\n                 }\n                 CAmount filterrate = 0;\n                 {\n-                    LOCK(pto->cs_feeFilter);\n-                    filterrate = pto->minFeeFilter;\n+                    LOCK(pto->m_tx_relay.cs_feeFilter);\n+                    filterrate = pto->m_tx_relay.minFeeFilter;\n                 }\n                 // Topologically and fee-rate sort the inventory we send for privacy and priority reasons.\n                 // A heap is used so that not all items need sorting if only a few are being sent.\n@@ -3862,17 +3863,17 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                 // No reason to drain out at many times the network's capacity,\n                 // especially since we have many peers and some will draw much shorter delays.\n                 unsigned int nRelayedTransactions = 0;\n-                LOCK(pto->cs_filter);\n+                LOCK(pto->m_tx_relay.cs_filter);\n                 while (!vInvTx.empty() && nRelayedTransactions < INVENTORY_BROADCAST_MAX) {\n                     // Fetch the top element from the heap\n                     std::pop_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\n                     std::set<uint256>::iterator it = vInvTx.back();\n                     vInvTx.pop_back();\n                     uint256 hash = *it;\n                     // Remove it from the to-be-sent set\n-                    pto->setInventoryTxToSend.erase(it);\n+                    pto->m_tx_relay.setInventoryTxToSend.erase(it);\n                     // Check if not in the filter already\n-                    if (pto->filterInventoryKnown.contains(hash)) {\n+                    if (pto->m_tx_relay.filterInventoryKnown.contains(hash)) {\n                         continue;\n                     }\n                     // Not in the mempool anymore? don't bother sending it.\n@@ -3883,7 +3884,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                     if (filterrate && txinfo.feeRate.GetFeePerK() < filterrate) {\n                         continue;\n                     }\n-                    if (pto->pfilter && !pto->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n+                    if (pto->m_tx_relay.pfilter && !pto->m_tx_relay.pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                     // Send\n                     vInv.push_back(CInv(MSG_TX, hash));\n                     nRelayedTransactions++;\n@@ -3904,7 +3905,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                         connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n                         vInv.clear();\n                     }\n-                    pto->filterInventoryKnown.insert(hash);\n+                    pto->m_tx_relay.filterInventoryKnown.insert(hash);\n                 }\n             }\n         }\n@@ -4069,23 +4070,23 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n             !pto->HasPermission(PF_FORCERELAY)) {\n             CAmount currentFilter = mempool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFeePerK();\n             int64_t timeNow = GetTimeMicros();\n-            if (timeNow > pto->nextSendTimeFeeFilter) {\n+            if (timeNow > pto->m_tx_relay.nextSendTimeFeeFilter) {\n                 static CFeeRate default_feerate(DEFAULT_MIN_RELAY_TX_FEE);\n                 static FeeFilterRounder filterRounder(default_feerate);\n                 CAmount filterToSend = filterRounder.round(currentFilter);\n                 // We always have a fee filter of at least minRelayTxFee\n                 filterToSend = std::max(filterToSend, ::minRelayTxFee.GetFeePerK());\n-                if (filterToSend != pto->lastSentFeeFilter) {\n+                if (filterToSend != pto->m_tx_relay.lastSentFeeFilter) {\n                     connman->PushMessage(pto, msgMaker.Make(NetMsgType::FEEFILTER, filterToSend));\n-                    pto->lastSentFeeFilter = filterToSend;\n+                    pto->m_tx_relay.lastSentFeeFilter = filterToSend;\n                 }\n-                pto->nextSendTimeFeeFilter = PoissonNextSend(timeNow, AVG_FEEFILTER_BROADCAST_INTERVAL);\n+                pto->m_tx_relay.nextSendTimeFeeFilter = PoissonNextSend(timeNow, AVG_FEEFILTER_BROADCAST_INTERVAL);\n             }\n             // If the fee filter has changed substantially and it's still more than MAX_FEEFILTER_CHANGE_DELAY\n             // until scheduled broadcast, then move the broadcast to within MAX_FEEFILTER_CHANGE_DELAY.\n-            else if (timeNow + MAX_FEEFILTER_CHANGE_DELAY * 1000000 < pto->nextSendTimeFeeFilter &&\n-                     (currentFilter < 3 * pto->lastSentFeeFilter / 4 || currentFilter > 4 * pto->lastSentFeeFilter / 3)) {\n-                pto->nextSendTimeFeeFilter = timeNow + GetRandInt(MAX_FEEFILTER_CHANGE_DELAY) * 1000000;\n+            else if (timeNow + MAX_FEEFILTER_CHANGE_DELAY * 1000000 < pto->m_tx_relay.nextSendTimeFeeFilter &&\n+                     (currentFilter < 3 * pto->m_tx_relay.lastSentFeeFilter / 4 || currentFilter > 4 * pto->m_tx_relay.lastSentFeeFilter / 3)) {\n+                pto->m_tx_relay.nextSendTimeFeeFilter = timeNow + GetRandInt(MAX_FEEFILTER_CHANGE_DELAY) * 1000000;\n             }\n         }\n     }"
      }
    ]
  },
  {
    "sha": "c4aa2ba82211ea5988ed7fe21e1b08bc3367e6d4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjNGFhMmJhODIyMTFlYTU5ODhlZDdmZTIxZTFiMDhiYzMzNjdlNmQ0",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-03-08T20:30:36Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-08-28T17:41:58Z"
      },
      "message": "[refactor] Change tx_relay structure to be unique_ptr",
      "tree": {
        "sha": "f0666a205ae658352be324c48aac5507110c7ab6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f0666a205ae658352be324c48aac5507110c7ab6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c4aa2ba82211ea5988ed7fe21e1b08bc3367e6d4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c4aa2ba82211ea5988ed7fe21e1b08bc3367e6d4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c4aa2ba82211ea5988ed7fe21e1b08bc3367e6d4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c4aa2ba82211ea5988ed7fe21e1b08bc3367e6d4/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4de0dbac9b286c42a9b10132b7c2d76712f1a319",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4de0dbac9b286c42a9b10132b7c2d76712f1a319",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4de0dbac9b286c42a9b10132b7c2d76712f1a319"
      }
    ],
    "stats": {
      "total": 131,
      "additions": 66,
      "deletions": 65
    },
    "files": [
      {
        "sha": "78b33954d66c022f55683a790dfeebccc771862a",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 6,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c4aa2ba82211ea5988ed7fe21e1b08bc3367e6d4/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c4aa2ba82211ea5988ed7fe21e1b08bc3367e6d4/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=c4aa2ba82211ea5988ed7fe21e1b08bc3367e6d4",
        "patch": "@@ -500,8 +500,8 @@ void CNode::copyStats(CNodeStats &stats)\n     X(addr);\n     X(addrBind);\n     {\n-        LOCK(m_tx_relay.cs_filter);\n-        stats.fRelayTxes = m_tx_relay.fRelayTxes;\n+        LOCK(m_tx_relay->cs_filter);\n+        stats.fRelayTxes = m_tx_relay->fRelayTxes;\n     }\n     X(nLastSend);\n     X(nLastRecv);\n@@ -529,8 +529,8 @@ void CNode::copyStats(CNodeStats &stats)\n     X(m_legacyWhitelisted);\n     X(m_permissionFlags);\n     {\n-        LOCK(m_tx_relay.cs_feeFilter);\n-        stats.minFeeFilter = m_tx_relay.minFeeFilter;\n+        LOCK(m_tx_relay->cs_feeFilter);\n+        stats.minFeeFilter = m_tx_relay->minFeeFilter;\n     }\n \n     // It is common for nodes with good ping times to suddenly become lagged,\n@@ -818,11 +818,11 @@ bool CConnman::AttemptToEvictConnection()\n                 continue;\n             if (node->fDisconnect)\n                 continue;\n-            LOCK(node->m_tx_relay.cs_filter);\n+            LOCK(node->m_tx_relay->cs_filter);\n             NodeEvictionCandidate candidate = {node->GetId(), node->nTimeConnected, node->nMinPingUsecTime,\n                                                node->nLastBlockTime, node->nLastTXTime,\n                                                HasAllDesirableServiceFlags(node->nServices),\n-                                               node->m_tx_relay.fRelayTxes, node->m_tx_relay.pfilter != nullptr, node->addr, node->nKeyedNetGroup,\n+                                               node->m_tx_relay->fRelayTxes, node->m_tx_relay->pfilter != nullptr, node->addr, node->nKeyedNetGroup,\n                                                node->m_prefer_evict};\n             vEvictionCandidates.push_back(candidate);\n         }\n@@ -2633,6 +2633,7 @@ CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn\n     hSocket = hSocketIn;\n     addrName = addrNameIn == \"\" ? addr.ToStringIPPort() : addrNameIn;\n     hashContinue = uint256();\n+    m_tx_relay = MakeUnique<TxRelay>();\n \n     for (const std::string &msg : getAllNetMessageTypes())\n         mapRecvBytesPerMsgCmd[msg] = 0;"
      },
      {
        "sha": "d12fc3ae9a892c02f152cdabda4803fb6e82ed38",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c4aa2ba82211ea5988ed7fe21e1b08bc3367e6d4/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c4aa2ba82211ea5988ed7fe21e1b08bc3367e6d4/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=c4aa2ba82211ea5988ed7fe21e1b08bc3367e6d4",
        "patch": "@@ -733,7 +733,7 @@ class CNode\n         int64_t nextSendTimeFeeFilter{0};\n     };\n \n-    TxRelay m_tx_relay;\n+    std::unique_ptr<TxRelay> m_tx_relay;\n     // Used for headers announcements - unfiltered blocks to relay\n     std::vector<uint256> vBlockHashesToAnnounce GUARDED_BY(cs_inventory);\n \n@@ -849,17 +849,17 @@ class CNode\n     void AddInventoryKnown(const CInv& inv)\n     {\n         {\n-            LOCK(m_tx_relay.cs_tx_inventory);\n-            m_tx_relay.filterInventoryKnown.insert(inv.hash);\n+            LOCK(m_tx_relay->cs_tx_inventory);\n+            m_tx_relay->filterInventoryKnown.insert(inv.hash);\n         }\n     }\n \n     void PushInventory(const CInv& inv)\n     {\n         if (inv.type == MSG_TX) {\n-            LOCK(m_tx_relay.cs_tx_inventory);\n-            if (!m_tx_relay.filterInventoryKnown.contains(inv.hash)) {\n-                m_tx_relay.setInventoryTxToSend.insert(inv.hash);\n+            LOCK(m_tx_relay->cs_tx_inventory);\n+            if (!m_tx_relay->filterInventoryKnown.contains(inv.hash)) {\n+                m_tx_relay->setInventoryTxToSend.insert(inv.hash);\n             }\n         } else if (inv.type == MSG_BLOCK) {\n             LOCK(cs_inventory);"
      },
      {
        "sha": "303a060a99b864757ac5710f8c8f1f226c4d55f1",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 53,
        "deletions": 53,
        "changes": 106,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c4aa2ba82211ea5988ed7fe21e1b08bc3367e6d4/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c4aa2ba82211ea5988ed7fe21e1b08bc3367e6d4/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=c4aa2ba82211ea5988ed7fe21e1b08bc3367e6d4",
        "patch": "@@ -1449,10 +1449,10 @@ void static ProcessGetBlockData(CNode* pfrom, const CChainParams& chainparams, c\n                 bool sendMerkleBlock = false;\n                 CMerkleBlock merkleBlock;\n                 {\n-                    LOCK(pfrom->m_tx_relay.cs_filter);\n-                    if (pfrom->m_tx_relay.pfilter) {\n+                    LOCK(pfrom->m_tx_relay->cs_filter);\n+                    if (pfrom->m_tx_relay->pfilter) {\n                         sendMerkleBlock = true;\n-                        merkleBlock = CMerkleBlock(*pblock, *pfrom->m_tx_relay.pfilter);\n+                        merkleBlock = CMerkleBlock(*pblock, *pfrom->m_tx_relay->pfilter);\n                     }\n                 }\n                 if (sendMerkleBlock) {\n@@ -1532,11 +1532,11 @@ void static ProcessGetData(CNode* pfrom, const CChainParams& chainparams, CConnm\n             if (mi != mapRelay.end()) {\n                 connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::TX, *mi->second));\n                 push = true;\n-            } else if (pfrom->m_tx_relay.timeLastMempoolReq) {\n+            } else if (pfrom->m_tx_relay->timeLastMempoolReq) {\n                 auto txinfo = mempool.info(inv.hash);\n                 // To protect privacy, do not answer getdata using the mempool when\n                 // that TX couldn't have been INVed in reply to a MEMPOOL request.\n-                if (txinfo.tx && txinfo.nTime <= pfrom->m_tx_relay.timeLastMempoolReq) {\n+                if (txinfo.tx && txinfo.nTime <= pfrom->m_tx_relay->timeLastMempoolReq) {\n                     connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::TX, *txinfo.tx));\n                     push = true;\n                 }\n@@ -1996,8 +1996,8 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         pfrom->m_limited_node = (!(nServices & NODE_NETWORK) && (nServices & NODE_NETWORK_LIMITED));\n \n         {\n-            LOCK(pfrom->m_tx_relay.cs_filter);\n-            pfrom->m_tx_relay.fRelayTxes = fRelay; // set to true after we get the first filter* message\n+            LOCK(pfrom->m_tx_relay->cs_filter);\n+            pfrom->m_tx_relay->fRelayTxes = fRelay; // set to true after we get the first filter* message\n         }\n \n         // Change version\n@@ -3030,8 +3030,8 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             return true;\n         }\n \n-        LOCK(pfrom->m_tx_relay.cs_tx_inventory);\n-        pfrom->m_tx_relay.fSendMempool = true;\n+        LOCK(pfrom->m_tx_relay->cs_tx_inventory);\n+        pfrom->m_tx_relay->fSendMempool = true;\n         return true;\n     }\n \n@@ -3124,10 +3124,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         }\n         else\n         {\n-            LOCK(pfrom->m_tx_relay.cs_filter);\n-            pfrom->m_tx_relay.pfilter.reset(new CBloomFilter(filter));\n-            pfrom->m_tx_relay.pfilter->UpdateEmptyFull();\n-            pfrom->m_tx_relay.fRelayTxes = true;\n+            LOCK(pfrom->m_tx_relay->cs_filter);\n+            pfrom->m_tx_relay->pfilter.reset(new CBloomFilter(filter));\n+            pfrom->m_tx_relay->pfilter->UpdateEmptyFull();\n+            pfrom->m_tx_relay->fRelayTxes = true;\n         }\n         return true;\n     }\n@@ -3142,9 +3142,9 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (vData.size() > MAX_SCRIPT_ELEMENT_SIZE) {\n             bad = true;\n         } else {\n-            LOCK(pfrom->m_tx_relay.cs_filter);\n-            if (pfrom->m_tx_relay.pfilter) {\n-                pfrom->m_tx_relay.pfilter->insert(vData);\n+            LOCK(pfrom->m_tx_relay->cs_filter);\n+            if (pfrom->m_tx_relay->pfilter) {\n+                pfrom->m_tx_relay->pfilter->insert(vData);\n             } else {\n                 bad = true;\n             }\n@@ -3157,11 +3157,11 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n     }\n \n     if (strCommand == NetMsgType::FILTERCLEAR) {\n-        LOCK(pfrom->m_tx_relay.cs_filter);\n+        LOCK(pfrom->m_tx_relay->cs_filter);\n         if (pfrom->GetLocalServices() & NODE_BLOOM) {\n-            pfrom->m_tx_relay.pfilter.reset(new CBloomFilter());\n+            pfrom->m_tx_relay->pfilter.reset(new CBloomFilter());\n         }\n-        pfrom->m_tx_relay.fRelayTxes = true;\n+        pfrom->m_tx_relay->fRelayTxes = true;\n         return true;\n     }\n \n@@ -3170,8 +3170,8 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         vRecv >> newFeeFilter;\n         if (MoneyRange(newFeeFilter)) {\n             {\n-                LOCK(pfrom->m_tx_relay.cs_feeFilter);\n-                pfrom->m_tx_relay.minFeeFilter = newFeeFilter;\n+                LOCK(pfrom->m_tx_relay->cs_feeFilter);\n+                pfrom->m_tx_relay->minFeeFilter = newFeeFilter;\n             }\n             LogPrint(BCLog::NET, \"received: feefilter of %s from peer=%d\\n\", CFeeRate(newFeeFilter).ToString(), pfrom->GetId());\n         }\n@@ -3791,70 +3791,70 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n             }\n             pto->vInventoryBlockToSend.clear();\n \n-            LOCK(pto->m_tx_relay.cs_tx_inventory);\n+            LOCK(pto->m_tx_relay->cs_tx_inventory);\n             // Check whether periodic sends should happen\n             bool fSendTrickle = pto->HasPermission(PF_NOBAN);\n-            if (pto->m_tx_relay.nNextInvSend < nNow) {\n+            if (pto->m_tx_relay->nNextInvSend < nNow) {\n                 fSendTrickle = true;\n                 if (pto->fInbound) {\n-                    pto->m_tx_relay.nNextInvSend = connman->PoissonNextSendInbound(nNow, INVENTORY_BROADCAST_INTERVAL);\n+                    pto->m_tx_relay->nNextInvSend = connman->PoissonNextSendInbound(nNow, INVENTORY_BROADCAST_INTERVAL);\n                 } else {\n                     // Use half the delay for outbound peers, as there is less privacy concern for them.\n-                    pto->m_tx_relay.nNextInvSend = PoissonNextSend(nNow, INVENTORY_BROADCAST_INTERVAL >> 1);\n+                    pto->m_tx_relay->nNextInvSend = PoissonNextSend(nNow, INVENTORY_BROADCAST_INTERVAL >> 1);\n                 }\n             }\n \n             // Time to send but the peer has requested we not relay transactions.\n             if (fSendTrickle) {\n-                LOCK(pto->m_tx_relay.cs_filter);\n-                if (!pto->m_tx_relay.fRelayTxes) pto->m_tx_relay.setInventoryTxToSend.clear();\n+                LOCK(pto->m_tx_relay->cs_filter);\n+                if (!pto->m_tx_relay->fRelayTxes) pto->m_tx_relay->setInventoryTxToSend.clear();\n             }\n \n             // Respond to BIP35 mempool requests\n-            if (fSendTrickle && pto->m_tx_relay.fSendMempool) {\n+            if (fSendTrickle && pto->m_tx_relay->fSendMempool) {\n                 auto vtxinfo = mempool.infoAll();\n-                pto->m_tx_relay.fSendMempool = false;\n+                pto->m_tx_relay->fSendMempool = false;\n                 CAmount filterrate = 0;\n                 {\n-                    LOCK(pto->m_tx_relay.cs_feeFilter);\n-                    filterrate = pto->m_tx_relay.minFeeFilter;\n+                    LOCK(pto->m_tx_relay->cs_feeFilter);\n+                    filterrate = pto->m_tx_relay->minFeeFilter;\n                 }\n \n-                LOCK(pto->m_tx_relay.cs_filter);\n+                LOCK(pto->m_tx_relay->cs_filter);\n \n                 for (const auto& txinfo : vtxinfo) {\n                     const uint256& hash = txinfo.tx->GetHash();\n                     CInv inv(MSG_TX, hash);\n-                    pto->m_tx_relay.setInventoryTxToSend.erase(hash);\n+                    pto->m_tx_relay->setInventoryTxToSend.erase(hash);\n                     if (filterrate) {\n                         if (txinfo.feeRate.GetFeePerK() < filterrate)\n                             continue;\n                     }\n-                    if (pto->m_tx_relay.pfilter) {\n-                        if (!pto->m_tx_relay.pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n+                    if (pto->m_tx_relay->pfilter) {\n+                        if (!pto->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                     }\n-                    pto->m_tx_relay.filterInventoryKnown.insert(hash);\n+                    pto->m_tx_relay->filterInventoryKnown.insert(hash);\n                     vInv.push_back(inv);\n                     if (vInv.size() == MAX_INV_SZ) {\n                         connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n                         vInv.clear();\n                     }\n                 }\n-                pto->m_tx_relay.timeLastMempoolReq = GetTime();\n+                pto->m_tx_relay->timeLastMempoolReq = GetTime();\n             }\n \n             // Determine transactions to relay\n             if (fSendTrickle) {\n                 // Produce a vector with all candidates for sending\n                 std::vector<std::set<uint256>::iterator> vInvTx;\n-                vInvTx.reserve(pto->m_tx_relay.setInventoryTxToSend.size());\n-                for (std::set<uint256>::iterator it = pto->m_tx_relay.setInventoryTxToSend.begin(); it != pto->m_tx_relay.setInventoryTxToSend.end(); it++) {\n+                vInvTx.reserve(pto->m_tx_relay->setInventoryTxToSend.size());\n+                for (std::set<uint256>::iterator it = pto->m_tx_relay->setInventoryTxToSend.begin(); it != pto->m_tx_relay->setInventoryTxToSend.end(); it++) {\n                     vInvTx.push_back(it);\n                 }\n                 CAmount filterrate = 0;\n                 {\n-                    LOCK(pto->m_tx_relay.cs_feeFilter);\n-                    filterrate = pto->m_tx_relay.minFeeFilter;\n+                    LOCK(pto->m_tx_relay->cs_feeFilter);\n+                    filterrate = pto->m_tx_relay->minFeeFilter;\n                 }\n                 // Topologically and fee-rate sort the inventory we send for privacy and priority reasons.\n                 // A heap is used so that not all items need sorting if only a few are being sent.\n@@ -3863,17 +3863,17 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                 // No reason to drain out at many times the network's capacity,\n                 // especially since we have many peers and some will draw much shorter delays.\n                 unsigned int nRelayedTransactions = 0;\n-                LOCK(pto->m_tx_relay.cs_filter);\n+                LOCK(pto->m_tx_relay->cs_filter);\n                 while (!vInvTx.empty() && nRelayedTransactions < INVENTORY_BROADCAST_MAX) {\n                     // Fetch the top element from the heap\n                     std::pop_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\n                     std::set<uint256>::iterator it = vInvTx.back();\n                     vInvTx.pop_back();\n                     uint256 hash = *it;\n                     // Remove it from the to-be-sent set\n-                    pto->m_tx_relay.setInventoryTxToSend.erase(it);\n+                    pto->m_tx_relay->setInventoryTxToSend.erase(it);\n                     // Check if not in the filter already\n-                    if (pto->m_tx_relay.filterInventoryKnown.contains(hash)) {\n+                    if (pto->m_tx_relay->filterInventoryKnown.contains(hash)) {\n                         continue;\n                     }\n                     // Not in the mempool anymore? don't bother sending it.\n@@ -3884,7 +3884,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                     if (filterrate && txinfo.feeRate.GetFeePerK() < filterrate) {\n                         continue;\n                     }\n-                    if (pto->m_tx_relay.pfilter && !pto->m_tx_relay.pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n+                    if (pto->m_tx_relay->pfilter && !pto->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                     // Send\n                     vInv.push_back(CInv(MSG_TX, hash));\n                     nRelayedTransactions++;\n@@ -3905,7 +3905,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                         connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n                         vInv.clear();\n                     }\n-                    pto->m_tx_relay.filterInventoryKnown.insert(hash);\n+                    pto->m_tx_relay->filterInventoryKnown.insert(hash);\n                 }\n             }\n         }\n@@ -4070,23 +4070,23 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n             !pto->HasPermission(PF_FORCERELAY)) {\n             CAmount currentFilter = mempool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFeePerK();\n             int64_t timeNow = GetTimeMicros();\n-            if (timeNow > pto->m_tx_relay.nextSendTimeFeeFilter) {\n+            if (timeNow > pto->m_tx_relay->nextSendTimeFeeFilter) {\n                 static CFeeRate default_feerate(DEFAULT_MIN_RELAY_TX_FEE);\n                 static FeeFilterRounder filterRounder(default_feerate);\n                 CAmount filterToSend = filterRounder.round(currentFilter);\n                 // We always have a fee filter of at least minRelayTxFee\n                 filterToSend = std::max(filterToSend, ::minRelayTxFee.GetFeePerK());\n-                if (filterToSend != pto->m_tx_relay.lastSentFeeFilter) {\n+                if (filterToSend != pto->m_tx_relay->lastSentFeeFilter) {\n                     connman->PushMessage(pto, msgMaker.Make(NetMsgType::FEEFILTER, filterToSend));\n-                    pto->m_tx_relay.lastSentFeeFilter = filterToSend;\n+                    pto->m_tx_relay->lastSentFeeFilter = filterToSend;\n                 }\n-                pto->m_tx_relay.nextSendTimeFeeFilter = PoissonNextSend(timeNow, AVG_FEEFILTER_BROADCAST_INTERVAL);\n+                pto->m_tx_relay->nextSendTimeFeeFilter = PoissonNextSend(timeNow, AVG_FEEFILTER_BROADCAST_INTERVAL);\n             }\n             // If the fee filter has changed substantially and it's still more than MAX_FEEFILTER_CHANGE_DELAY\n             // until scheduled broadcast, then move the broadcast to within MAX_FEEFILTER_CHANGE_DELAY.\n-            else if (timeNow + MAX_FEEFILTER_CHANGE_DELAY * 1000000 < pto->m_tx_relay.nextSendTimeFeeFilter &&\n-                     (currentFilter < 3 * pto->m_tx_relay.lastSentFeeFilter / 4 || currentFilter > 4 * pto->m_tx_relay.lastSentFeeFilter / 3)) {\n-                pto->m_tx_relay.nextSendTimeFeeFilter = timeNow + GetRandInt(MAX_FEEFILTER_CHANGE_DELAY) * 1000000;\n+            else if (timeNow + MAX_FEEFILTER_CHANGE_DELAY * 1000000 < pto->m_tx_relay->nextSendTimeFeeFilter &&\n+                     (currentFilter < 3 * pto->m_tx_relay->lastSentFeeFilter / 4 || currentFilter > 4 * pto->m_tx_relay->lastSentFeeFilter / 3)) {\n+                pto->m_tx_relay->nextSendTimeFeeFilter = timeNow + GetRandInt(MAX_FEEFILTER_CHANGE_DELAY) * 1000000;\n             }\n         }\n     }"
      }
    ]
  },
  {
    "sha": "e75c39cd425f8c4e5b6bbb2beecb9c80034fefe1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNzVjMzljZDQyNWY4YzRlNWI2YmJiMmJlZWNiOWM4MDAzNGZlZmUx",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-03-08T20:48:41Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-09-04T18:58:34Z"
      },
      "message": "Check that tx_relay is initialized before access",
      "tree": {
        "sha": "697bd41fb179ec55aaea1ef76f015ade8ac33169",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/697bd41fb179ec55aaea1ef76f015ade8ac33169"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e75c39cd425f8c4e5b6bbb2beecb9c80034fefe1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e75c39cd425f8c4e5b6bbb2beecb9c80034fefe1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e75c39cd425f8c4e5b6bbb2beecb9c80034fefe1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e75c39cd425f8c4e5b6bbb2beecb9c80034fefe1/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c4aa2ba82211ea5988ed7fe21e1b08bc3367e6d4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c4aa2ba82211ea5988ed7fe21e1b08bc3367e6d4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c4aa2ba82211ea5988ed7fe21e1b08bc3367e6d4"
      }
    ],
    "stats": {
      "total": 249,
      "additions": 133,
      "deletions": 116
    },
    "files": [
      {
        "sha": "9514da8809e106ae54c591bb92ef478b2f415f3e",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 4,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e75c39cd425f8c4e5b6bbb2beecb9c80034fefe1/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e75c39cd425f8c4e5b6bbb2beecb9c80034fefe1/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=e75c39cd425f8c4e5b6bbb2beecb9c80034fefe1",
        "patch": "@@ -499,9 +499,11 @@ void CNode::copyStats(CNodeStats &stats)\n     X(nServices);\n     X(addr);\n     X(addrBind);\n-    {\n+    if (m_tx_relay != nullptr) {\n         LOCK(m_tx_relay->cs_filter);\n         stats.fRelayTxes = m_tx_relay->fRelayTxes;\n+    } else {\n+        stats.fRelayTxes = false;\n     }\n     X(nLastSend);\n     X(nLastRecv);\n@@ -528,9 +530,11 @@ void CNode::copyStats(CNodeStats &stats)\n     }\n     X(m_legacyWhitelisted);\n     X(m_permissionFlags);\n-    {\n+    if (m_tx_relay != nullptr) {\n         LOCK(m_tx_relay->cs_feeFilter);\n         stats.minFeeFilter = m_tx_relay->minFeeFilter;\n+    } else {\n+        stats.minFeeFilter = 0;\n     }\n \n     // It is common for nodes with good ping times to suddenly become lagged,\n@@ -818,11 +822,17 @@ bool CConnman::AttemptToEvictConnection()\n                 continue;\n             if (node->fDisconnect)\n                 continue;\n-            LOCK(node->m_tx_relay->cs_filter);\n+            bool peer_relay_txes = false;\n+            bool peer_filter_not_null = false;\n+            if (node->m_tx_relay != nullptr) {\n+                LOCK(node->m_tx_relay->cs_filter);\n+                peer_relay_txes = node->m_tx_relay->fRelayTxes;\n+                peer_filter_not_null = node->m_tx_relay->pfilter != nullptr;\n+            }\n             NodeEvictionCandidate candidate = {node->GetId(), node->nTimeConnected, node->nMinPingUsecTime,\n                                                node->nLastBlockTime, node->nLastTXTime,\n                                                HasAllDesirableServiceFlags(node->nServices),\n-                                               node->m_tx_relay->fRelayTxes, node->m_tx_relay->pfilter != nullptr, node->addr, node->nKeyedNetGroup,\n+                                               peer_relay_txes, peer_filter_not_null, node->addr, node->nKeyedNetGroup,\n                                                node->m_prefer_evict};\n             vEvictionCandidates.push_back(candidate);\n         }"
      },
      {
        "sha": "218dd67ba6639f296ea5b48bf3b3701bf036ee7d",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e75c39cd425f8c4e5b6bbb2beecb9c80034fefe1/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e75c39cd425f8c4e5b6bbb2beecb9c80034fefe1/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=e75c39cd425f8c4e5b6bbb2beecb9c80034fefe1",
        "patch": "@@ -848,15 +848,15 @@ class CNode\n \n     void AddInventoryKnown(const CInv& inv)\n     {\n-        {\n+        if (m_tx_relay != nullptr) {\n             LOCK(m_tx_relay->cs_tx_inventory);\n             m_tx_relay->filterInventoryKnown.insert(inv.hash);\n         }\n     }\n \n     void PushInventory(const CInv& inv)\n     {\n-        if (inv.type == MSG_TX) {\n+        if (inv.type == MSG_TX && m_tx_relay != nullptr) {\n             LOCK(m_tx_relay->cs_tx_inventory);\n             if (!m_tx_relay->filterInventoryKnown.contains(inv.hash)) {\n                 m_tx_relay->setInventoryTxToSend.insert(inv.hash);"
      },
      {
        "sha": "0802cf424d17f18633f88250b24afb7352c70115",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 117,
        "deletions": 110,
        "changes": 227,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e75c39cd425f8c4e5b6bbb2beecb9c80034fefe1/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e75c39cd425f8c4e5b6bbb2beecb9c80034fefe1/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=e75c39cd425f8c4e5b6bbb2beecb9c80034fefe1",
        "patch": "@@ -1448,7 +1448,7 @@ void static ProcessGetBlockData(CNode* pfrom, const CChainParams& chainparams, c\n             {\n                 bool sendMerkleBlock = false;\n                 CMerkleBlock merkleBlock;\n-                {\n+                if (pfrom->m_tx_relay != nullptr) {\n                     LOCK(pfrom->m_tx_relay->cs_filter);\n                     if (pfrom->m_tx_relay->pfilter) {\n                         sendMerkleBlock = true;\n@@ -1512,7 +1512,7 @@ void static ProcessGetData(CNode* pfrom, const CChainParams& chainparams, CConnm\n     std::deque<CInv>::iterator it = pfrom->vRecvGetData.begin();\n     std::vector<CInv> vNotFound;\n     const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n-    {\n+    if (pfrom->m_tx_relay != nullptr) {\n         LOCK(cs_main);\n \n         while (it != pfrom->vRecvGetData.end() && (it->type == MSG_TX || it->type == MSG_WITNESS_TX)) {\n@@ -1995,7 +1995,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // set nodes not capable of serving the complete blockchain history as \"limited nodes\"\n         pfrom->m_limited_node = (!(nServices & NODE_NETWORK) && (nServices & NODE_NETWORK_LIMITED));\n \n-        {\n+        if (pfrom->m_tx_relay != nullptr) {\n             LOCK(pfrom->m_tx_relay->cs_filter);\n             pfrom->m_tx_relay->fRelayTxes = fRelay; // set to true after we get the first filter* message\n         }\n@@ -3030,8 +3030,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             return true;\n         }\n \n-        LOCK(pfrom->m_tx_relay->cs_tx_inventory);\n-        pfrom->m_tx_relay->fSendMempool = true;\n+        if (pfrom->m_tx_relay != nullptr) {\n+            LOCK(pfrom->m_tx_relay->cs_tx_inventory);\n+            pfrom->m_tx_relay->fSendMempool = true;\n+        }\n         return true;\n     }\n \n@@ -3122,7 +3124,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 100);\n         }\n-        else\n+        else if (pfrom->m_tx_relay != nullptr)\n         {\n             LOCK(pfrom->m_tx_relay->cs_filter);\n             pfrom->m_tx_relay->pfilter.reset(new CBloomFilter(filter));\n@@ -3141,7 +3143,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         bool bad = false;\n         if (vData.size() > MAX_SCRIPT_ELEMENT_SIZE) {\n             bad = true;\n-        } else {\n+        } else if (pfrom->m_tx_relay != nullptr) {\n             LOCK(pfrom->m_tx_relay->cs_filter);\n             if (pfrom->m_tx_relay->pfilter) {\n                 pfrom->m_tx_relay->pfilter->insert(vData);\n@@ -3157,6 +3159,9 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n     }\n \n     if (strCommand == NetMsgType::FILTERCLEAR) {\n+        if (pfrom->m_tx_relay == nullptr) {\n+            return true;\n+        }\n         LOCK(pfrom->m_tx_relay->cs_filter);\n         if (pfrom->GetLocalServices() & NODE_BLOOM) {\n             pfrom->m_tx_relay->pfilter.reset(new CBloomFilter());\n@@ -3169,7 +3174,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         CAmount newFeeFilter = 0;\n         vRecv >> newFeeFilter;\n         if (MoneyRange(newFeeFilter)) {\n-            {\n+            if (pfrom->m_tx_relay != nullptr) {\n                 LOCK(pfrom->m_tx_relay->cs_feeFilter);\n                 pfrom->m_tx_relay->minFeeFilter = newFeeFilter;\n             }\n@@ -3791,121 +3796,123 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n             }\n             pto->vInventoryBlockToSend.clear();\n \n-            LOCK(pto->m_tx_relay->cs_tx_inventory);\n-            // Check whether periodic sends should happen\n-            bool fSendTrickle = pto->HasPermission(PF_NOBAN);\n-            if (pto->m_tx_relay->nNextInvSend < nNow) {\n-                fSendTrickle = true;\n-                if (pto->fInbound) {\n-                    pto->m_tx_relay->nNextInvSend = connman->PoissonNextSendInbound(nNow, INVENTORY_BROADCAST_INTERVAL);\n-                } else {\n-                    // Use half the delay for outbound peers, as there is less privacy concern for them.\n-                    pto->m_tx_relay->nNextInvSend = PoissonNextSend(nNow, INVENTORY_BROADCAST_INTERVAL >> 1);\n+            if (pto->m_tx_relay != nullptr) {\n+                LOCK(pto->m_tx_relay->cs_tx_inventory);\n+                // Check whether periodic sends should happen\n+                bool fSendTrickle = pto->HasPermission(PF_NOBAN);\n+                if (pto->m_tx_relay->nNextInvSend < nNow) {\n+                    fSendTrickle = true;\n+                    if (pto->fInbound) {\n+                        pto->m_tx_relay->nNextInvSend = connman->PoissonNextSendInbound(nNow, INVENTORY_BROADCAST_INTERVAL);\n+                    } else {\n+                        // Use half the delay for outbound peers, as there is less privacy concern for them.\n+                        pto->m_tx_relay->nNextInvSend = PoissonNextSend(nNow, INVENTORY_BROADCAST_INTERVAL >> 1);\n+                    }\n                 }\n-            }\n-\n-            // Time to send but the peer has requested we not relay transactions.\n-            if (fSendTrickle) {\n-                LOCK(pto->m_tx_relay->cs_filter);\n-                if (!pto->m_tx_relay->fRelayTxes) pto->m_tx_relay->setInventoryTxToSend.clear();\n-            }\n \n-            // Respond to BIP35 mempool requests\n-            if (fSendTrickle && pto->m_tx_relay->fSendMempool) {\n-                auto vtxinfo = mempool.infoAll();\n-                pto->m_tx_relay->fSendMempool = false;\n-                CAmount filterrate = 0;\n-                {\n-                    LOCK(pto->m_tx_relay->cs_feeFilter);\n-                    filterrate = pto->m_tx_relay->minFeeFilter;\n+                // Time to send but the peer has requested we not relay transactions.\n+                if (fSendTrickle) {\n+                    LOCK(pto->m_tx_relay->cs_filter);\n+                    if (!pto->m_tx_relay->fRelayTxes) pto->m_tx_relay->setInventoryTxToSend.clear();\n                 }\n \n-                LOCK(pto->m_tx_relay->cs_filter);\n-\n-                for (const auto& txinfo : vtxinfo) {\n-                    const uint256& hash = txinfo.tx->GetHash();\n-                    CInv inv(MSG_TX, hash);\n-                    pto->m_tx_relay->setInventoryTxToSend.erase(hash);\n-                    if (filterrate) {\n-                        if (txinfo.feeRate.GetFeePerK() < filterrate)\n-                            continue;\n-                    }\n-                    if (pto->m_tx_relay->pfilter) {\n-                        if (!pto->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n+                // Respond to BIP35 mempool requests\n+                if (fSendTrickle && pto->m_tx_relay->fSendMempool) {\n+                    auto vtxinfo = mempool.infoAll();\n+                    pto->m_tx_relay->fSendMempool = false;\n+                    CAmount filterrate = 0;\n+                    {\n+                        LOCK(pto->m_tx_relay->cs_feeFilter);\n+                        filterrate = pto->m_tx_relay->minFeeFilter;\n                     }\n-                    pto->m_tx_relay->filterInventoryKnown.insert(hash);\n-                    vInv.push_back(inv);\n-                    if (vInv.size() == MAX_INV_SZ) {\n-                        connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n-                        vInv.clear();\n+\n+                    LOCK(pto->m_tx_relay->cs_filter);\n+\n+                    for (const auto& txinfo : vtxinfo) {\n+                        const uint256& hash = txinfo.tx->GetHash();\n+                        CInv inv(MSG_TX, hash);\n+                        pto->m_tx_relay->setInventoryTxToSend.erase(hash);\n+                        if (filterrate) {\n+                            if (txinfo.feeRate.GetFeePerK() < filterrate)\n+                                continue;\n+                        }\n+                        if (pto->m_tx_relay->pfilter) {\n+                            if (!pto->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n+                        }\n+                        pto->m_tx_relay->filterInventoryKnown.insert(hash);\n+                        vInv.push_back(inv);\n+                        if (vInv.size() == MAX_INV_SZ) {\n+                            connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n+                            vInv.clear();\n+                        }\n                     }\n+                    pto->m_tx_relay->timeLastMempoolReq = GetTime();\n                 }\n-                pto->m_tx_relay->timeLastMempoolReq = GetTime();\n-            }\n \n-            // Determine transactions to relay\n-            if (fSendTrickle) {\n-                // Produce a vector with all candidates for sending\n-                std::vector<std::set<uint256>::iterator> vInvTx;\n-                vInvTx.reserve(pto->m_tx_relay->setInventoryTxToSend.size());\n-                for (std::set<uint256>::iterator it = pto->m_tx_relay->setInventoryTxToSend.begin(); it != pto->m_tx_relay->setInventoryTxToSend.end(); it++) {\n-                    vInvTx.push_back(it);\n-                }\n-                CAmount filterrate = 0;\n-                {\n-                    LOCK(pto->m_tx_relay->cs_feeFilter);\n-                    filterrate = pto->m_tx_relay->minFeeFilter;\n-                }\n-                // Topologically and fee-rate sort the inventory we send for privacy and priority reasons.\n-                // A heap is used so that not all items need sorting if only a few are being sent.\n-                CompareInvMempoolOrder compareInvMempoolOrder(&mempool);\n-                std::make_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\n-                // No reason to drain out at many times the network's capacity,\n-                // especially since we have many peers and some will draw much shorter delays.\n-                unsigned int nRelayedTransactions = 0;\n-                LOCK(pto->m_tx_relay->cs_filter);\n-                while (!vInvTx.empty() && nRelayedTransactions < INVENTORY_BROADCAST_MAX) {\n-                    // Fetch the top element from the heap\n-                    std::pop_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\n-                    std::set<uint256>::iterator it = vInvTx.back();\n-                    vInvTx.pop_back();\n-                    uint256 hash = *it;\n-                    // Remove it from the to-be-sent set\n-                    pto->m_tx_relay->setInventoryTxToSend.erase(it);\n-                    // Check if not in the filter already\n-                    if (pto->m_tx_relay->filterInventoryKnown.contains(hash)) {\n-                        continue;\n-                    }\n-                    // Not in the mempool anymore? don't bother sending it.\n-                    auto txinfo = mempool.info(hash);\n-                    if (!txinfo.tx) {\n-                        continue;\n+                // Determine transactions to relay\n+                if (fSendTrickle) {\n+                    // Produce a vector with all candidates for sending\n+                    std::vector<std::set<uint256>::iterator> vInvTx;\n+                    vInvTx.reserve(pto->m_tx_relay->setInventoryTxToSend.size());\n+                    for (std::set<uint256>::iterator it = pto->m_tx_relay->setInventoryTxToSend.begin(); it != pto->m_tx_relay->setInventoryTxToSend.end(); it++) {\n+                        vInvTx.push_back(it);\n                     }\n-                    if (filterrate && txinfo.feeRate.GetFeePerK() < filterrate) {\n-                        continue;\n-                    }\n-                    if (pto->m_tx_relay->pfilter && !pto->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n-                    // Send\n-                    vInv.push_back(CInv(MSG_TX, hash));\n-                    nRelayedTransactions++;\n+                    CAmount filterrate = 0;\n                     {\n-                        // Expire old relay messages\n-                        while (!vRelayExpiration.empty() && vRelayExpiration.front().first < nNow)\n-                        {\n-                            mapRelay.erase(vRelayExpiration.front().second);\n-                            vRelayExpiration.pop_front();\n+                        LOCK(pto->m_tx_relay->cs_feeFilter);\n+                        filterrate = pto->m_tx_relay->minFeeFilter;\n+                    }\n+                    // Topologically and fee-rate sort the inventory we send for privacy and priority reasons.\n+                    // A heap is used so that not all items need sorting if only a few are being sent.\n+                    CompareInvMempoolOrder compareInvMempoolOrder(&mempool);\n+                    std::make_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\n+                    // No reason to drain out at many times the network's capacity,\n+                    // especially since we have many peers and some will draw much shorter delays.\n+                    unsigned int nRelayedTransactions = 0;\n+                    LOCK(pto->m_tx_relay->cs_filter);\n+                    while (!vInvTx.empty() && nRelayedTransactions < INVENTORY_BROADCAST_MAX) {\n+                        // Fetch the top element from the heap\n+                        std::pop_heap(vInvTx.begin(), vInvTx.end(), compareInvMempoolOrder);\n+                        std::set<uint256>::iterator it = vInvTx.back();\n+                        vInvTx.pop_back();\n+                        uint256 hash = *it;\n+                        // Remove it from the to-be-sent set\n+                        pto->m_tx_relay->setInventoryTxToSend.erase(it);\n+                        // Check if not in the filter already\n+                        if (pto->m_tx_relay->filterInventoryKnown.contains(hash)) {\n+                            continue;\n+                        }\n+                        // Not in the mempool anymore? don't bother sending it.\n+                        auto txinfo = mempool.info(hash);\n+                        if (!txinfo.tx) {\n+                            continue;\n+                        }\n+                        if (filterrate && txinfo.feeRate.GetFeePerK() < filterrate) {\n+                            continue;\n                         }\n+                        if (pto->m_tx_relay->pfilter && !pto->m_tx_relay->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n+                        // Send\n+                        vInv.push_back(CInv(MSG_TX, hash));\n+                        nRelayedTransactions++;\n+                        {\n+                            // Expire old relay messages\n+                            while (!vRelayExpiration.empty() && vRelayExpiration.front().first < nNow)\n+                            {\n+                                mapRelay.erase(vRelayExpiration.front().second);\n+                                vRelayExpiration.pop_front();\n+                            }\n \n-                        auto ret = mapRelay.insert(std::make_pair(hash, std::move(txinfo.tx)));\n-                        if (ret.second) {\n-                            vRelayExpiration.push_back(std::make_pair(nNow + 15 * 60 * 1000000, ret.first));\n+                            auto ret = mapRelay.insert(std::make_pair(hash, std::move(txinfo.tx)));\n+                            if (ret.second) {\n+                                vRelayExpiration.push_back(std::make_pair(nNow + 15 * 60 * 1000000, ret.first));\n+                            }\n                         }\n+                        if (vInv.size() == MAX_INV_SZ) {\n+                            connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n+                            vInv.clear();\n+                        }\n+                        pto->m_tx_relay->filterInventoryKnown.insert(hash);\n                     }\n-                    if (vInv.size() == MAX_INV_SZ) {\n-                        connman->PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n-                        vInv.clear();\n-                    }\n-                    pto->m_tx_relay->filterInventoryKnown.insert(hash);\n                 }\n             }\n         }\n@@ -4066,7 +4073,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n         // Message: feefilter\n         //\n         // We don't want white listed peers to filter txs to us if we have -whitelistforcerelay\n-        if (pto->nVersion >= FEEFILTER_VERSION && gArgs.GetBoolArg(\"-feefilter\", DEFAULT_FEEFILTER) &&\n+        if (pto->m_tx_relay != nullptr && pto->nVersion >= FEEFILTER_VERSION && gArgs.GetBoolArg(\"-feefilter\", DEFAULT_FEEFILTER) &&\n             !pto->HasPermission(PF_FORCERELAY)) {\n             CAmount currentFilter = mempool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFeePerK();\n             int64_t timeNow = GetTimeMicros();"
      }
    ]
  },
  {
    "sha": "b83f51a4bbe29bf130a2b0c0e85e5bffea107f75",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiODNmNTFhNGJiZTI5YmYxMzBhMmIwYzBlODVlNWJmZmVhMTA3Zjc1",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-03-08T21:04:55Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-09-04T18:58:36Z"
      },
      "message": "Add comment explaining intended use of m_tx_relay",
      "tree": {
        "sha": "fe6f9338cd7afb463284f554452b73a1bb7a8208",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fe6f9338cd7afb463284f554452b73a1bb7a8208"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b83f51a4bbe29bf130a2b0c0e85e5bffea107f75",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b83f51a4bbe29bf130a2b0c0e85e5bffea107f75",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b83f51a4bbe29bf130a2b0c0e85e5bffea107f75",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b83f51a4bbe29bf130a2b0c0e85e5bffea107f75/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e75c39cd425f8c4e5b6bbb2beecb9c80034fefe1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e75c39cd425f8c4e5b6bbb2beecb9c80034fefe1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e75c39cd425f8c4e5b6bbb2beecb9c80034fefe1"
      }
    ],
    "stats": {
      "total": 1,
      "additions": 1,
      "deletions": 0
    },
    "files": [
      {
        "sha": "31f446cde974ac869c178f5013616ea271b509b7",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b83f51a4bbe29bf130a2b0c0e85e5bffea107f75/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b83f51a4bbe29bf130a2b0c0e85e5bffea107f75/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=b83f51a4bbe29bf130a2b0c0e85e5bffea107f75",
        "patch": "@@ -733,6 +733,7 @@ class CNode\n         int64_t nextSendTimeFeeFilter{0};\n     };\n \n+    // m_tx_relay == nullptr if we're not relaying transactions with this peer\n     std::unique_ptr<TxRelay> m_tx_relay;\n     // Used for headers announcements - unfiltered blocks to relay\n     std::vector<uint256> vBlockHashesToAnnounce GUARDED_BY(cs_inventory);"
      }
    ]
  },
  {
    "sha": "3a5e885306ea954d7eccdc11502e91a51dab8ec6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozYTVlODg1MzA2ZWE5NTRkN2VjY2RjMTE1MDJlOTFhNTFkYWI4ZWM2",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-03-09T17:55:06Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-09-04T18:58:36Z"
      },
      "message": "Add 2 outbound block-relay-only connections\n\nTransaction relay is primarily optimized for balancing redundancy/robustness\nwith bandwidth minimization -- as a result transaction relay leaks information\nthat adversaries can use to infer the network topology.\n\nNetwork topology is better kept private for (at least) two reasons:\n\n(a) Knowledge of the network graph can make it easier to find the source IP of\na given transaction.\n\n(b) Knowledge of the network graph could be used to split a target node or\nnodes from the honest network (eg by knowing which peers to attack in order to\nachieve a network split).\n\nWe can eliminate the risks of (b) by separating block relay from transaction\nrelay; inferring network connectivity from the relay of blocks/block headers is\nmuch more expensive for an adversary.\n\nAfter this commit, bitcoind will make 2 additional outbound connections that\nare only used for block relay. (In the future, we might consider rotating our\ntransaction-relay peers to help limit the effects of (a).)",
      "tree": {
        "sha": "d0fa4fd1f947425ca84bf0c4b6f93a033c58c75d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d0fa4fd1f947425ca84bf0c4b6f93a033c58c75d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3a5e885306ea954d7eccdc11502e91a51dab8ec6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3a5e885306ea954d7eccdc11502e91a51dab8ec6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3a5e885306ea954d7eccdc11502e91a51dab8ec6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3a5e885306ea954d7eccdc11502e91a51dab8ec6/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b83f51a4bbe29bf130a2b0c0e85e5bffea107f75",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b83f51a4bbe29bf130a2b0c0e85e5bffea107f75",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b83f51a4bbe29bf130a2b0c0e85e5bffea107f75"
      }
    ],
    "stats": {
      "total": 115,
      "additions": 75,
      "deletions": 40
    },
    "files": [
      {
        "sha": "1bc5eb3f7bd05fc6eb875f1f667be1275c8696e8",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a5e885306ea954d7eccdc11502e91a51dab8ec6/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a5e885306ea954d7eccdc11502e91a51dab8ec6/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=3a5e885306ea954d7eccdc11502e91a51dab8ec6",
        "patch": "@@ -1753,7 +1753,8 @@ bool AppInitMain(InitInterfaces& interfaces)\n     CConnman::Options connOptions;\n     connOptions.nLocalServices = nLocalServices;\n     connOptions.nMaxConnections = nMaxConnections;\n-    connOptions.nMaxOutbound = std::min(MAX_OUTBOUND_CONNECTIONS, connOptions.nMaxConnections);\n+    connOptions.m_max_outbound_full_relay = std::min(MAX_OUTBOUND_FULL_RELAY_CONNECTIONS, connOptions.nMaxConnections);\n+    connOptions.m_max_outbound_block_relay = std::min(MAX_BLOCKS_ONLY_CONNECTIONS, connOptions.nMaxConnections-connOptions.m_max_outbound_full_relay);\n     connOptions.nMaxAddnode = MAX_ADDNODE_CONNECTIONS;\n     connOptions.nMaxFeeler = 1;\n     connOptions.nBestHeight = chain_active_height;"
      },
      {
        "sha": "e589b940ade01717583636c865819904377f61b1",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 14,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a5e885306ea954d7eccdc11502e91a51dab8ec6/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a5e885306ea954d7eccdc11502e91a51dab8ec6/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=3a5e885306ea954d7eccdc11502e91a51dab8ec6",
        "patch": "@@ -352,7 +352,7 @@ static CAddress GetBindAddress(SOCKET sock)\n     return addr_bind;\n }\n \n-CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure, bool manual_connection)\n+CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure, bool manual_connection, bool block_relay_only)\n {\n     if (pszDest == nullptr) {\n         if (IsLocal(addrConnect))\n@@ -442,7 +442,7 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\n     NodeId id = GetNewNodeId();\n     uint64_t nonce = GetDeterministicRandomizer(RANDOMIZER_ID_LOCALHOSTNONCE).Write(id).Finalize();\n     CAddress addr_bind = GetBindAddress(hSocket);\n-    CNode* pnode = new CNode(id, nLocalServices, GetBestHeight(), hSocket, addrConnect, CalculateKeyedNetGroup(addrConnect), nonce, addr_bind, pszDest ? pszDest : \"\", false);\n+    CNode* pnode = new CNode(id, nLocalServices, GetBestHeight(), hSocket, addrConnect, CalculateKeyedNetGroup(addrConnect), nonce, addr_bind, pszDest ? pszDest : \"\", false, block_relay_only);\n     pnode->AddRef();\n \n     return pnode;\n@@ -905,7 +905,7 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     SOCKET hSocket = accept(hListenSocket.socket, (struct sockaddr*)&sockaddr, &len);\n     CAddress addr;\n     int nInbound = 0;\n-    int nMaxInbound = nMaxConnections - (nMaxOutbound + nMaxFeeler);\n+    int nMaxInbound = nMaxConnections - m_max_outbound;\n \n     if (hSocket != INVALID_SOCKET) {\n         if (!addr.SetSockAddr((const struct sockaddr*)&sockaddr)) {\n@@ -1666,7 +1666,7 @@ int CConnman::GetExtraOutboundCount()\n             }\n         }\n     }\n-    return std::max(nOutbound - nMaxOutbound, 0);\n+    return std::max(nOutbound - m_max_outbound_full_relay - m_max_outbound_block_relay, 0);\n }\n \n void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n@@ -1726,7 +1726,8 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n         CAddress addrConnect;\n \n         // Only connect out to one peer per network group (/16 for IPv4).\n-        int nOutbound = 0;\n+        int nOutboundFullRelay = 0;\n+        int nOutboundBlockRelay = 0;\n         std::set<std::vector<unsigned char> > setConnected;\n         {\n             LOCK(cs_vNodes);\n@@ -1738,7 +1739,11 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n                     // also have the added issue that they're attacker controlled and could be used\n                     // to prevent us from connecting to particular hosts if we used them here.\n                     setConnected.insert(pnode->addr.GetGroup());\n-                    nOutbound++;\n+                    if (pnode->m_tx_relay == nullptr) {\n+                        nOutboundBlockRelay++;\n+                    } else if (!pnode->fFeeler) {\n+                        nOutboundFullRelay++;\n+                    }\n                 }\n             }\n         }\n@@ -1757,7 +1762,7 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n         //\n         bool fFeeler = false;\n \n-        if (nOutbound >= nMaxOutbound && !GetTryNewOutboundPeer()) {\n+        if (nOutboundFullRelay >= m_max_outbound_full_relay && nOutboundBlockRelay >= m_max_outbound_block_relay && !GetTryNewOutboundPeer()) {\n             int64_t nTime = GetTimeMicros(); // The current time right now (in microseconds).\n             if (nTime > nNextFeeler) {\n                 nNextFeeler = PoissonNextSend(nTime, FEELER_INTERVAL);\n@@ -1831,7 +1836,14 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n                 LogPrint(BCLog::NET, \"Making feeler connection to %s\\n\", addrConnect.ToString());\n             }\n \n-            OpenNetworkConnection(addrConnect, (int)setConnected.size() >= std::min(nMaxConnections - 1, 2), &grant, nullptr, false, fFeeler);\n+            // Open this connection as block-relay-only if we're already at our\n+            // full-relay capacity, but not yet at our block-relay peer limit.\n+            // (It should not be possible for fFeeler to be set if we're not\n+            // also at our block-relay peer limit, but check against that as\n+            // well for sanity.)\n+            bool block_relay_only = nOutboundBlockRelay < m_max_outbound_block_relay && !fFeeler && nOutboundFullRelay >= m_max_outbound_full_relay;\n+\n+            OpenNetworkConnection(addrConnect, (int)setConnected.size() >= std::min(nMaxConnections - 1, 2), &grant, nullptr, false, fFeeler, false, block_relay_only);\n         }\n     }\n }\n@@ -1918,7 +1930,7 @@ void CConnman::ThreadOpenAddedConnections()\n }\n \n // if successful, this moves the passed grant to the constructed node\n-void CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound, const char *pszDest, bool fOneShot, bool fFeeler, bool manual_connection)\n+void CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound, const char *pszDest, bool fOneShot, bool fFeeler, bool manual_connection, bool block_relay_only)\n {\n     //\n     // Initiate outbound network connection\n@@ -1937,7 +1949,7 @@ void CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFai\n     } else if (FindNode(std::string(pszDest)))\n         return;\n \n-    CNode* pnode = ConnectNode(addrConnect, pszDest, fCountFailure, manual_connection);\n+    CNode* pnode = ConnectNode(addrConnect, pszDest, fCountFailure, manual_connection, block_relay_only);\n \n     if (!pnode)\n         return;\n@@ -2240,7 +2252,7 @@ bool CConnman::Start(CScheduler& scheduler, const Options& connOptions)\n \n     if (semOutbound == nullptr) {\n         // initialize semaphore\n-        semOutbound = MakeUnique<CSemaphore>(std::min((nMaxOutbound + nMaxFeeler), nMaxConnections));\n+        semOutbound = MakeUnique<CSemaphore>(std::min(m_max_outbound, nMaxConnections));\n     }\n     if (semAddnode == nullptr) {\n         // initialize semaphore\n@@ -2318,7 +2330,7 @@ void CConnman::Interrupt()\n     InterruptSocks5(true);\n \n     if (semOutbound) {\n-        for (int i=0; i<(nMaxOutbound + nMaxFeeler); i++) {\n+        for (int i=0; i<m_max_outbound; i++) {\n             semOutbound->post();\n         }\n     }\n@@ -2628,7 +2640,7 @@ int CConnman::GetBestHeight() const\n \n unsigned int CConnman::GetReceiveFloodSize() const { return nReceiveFloodSize; }\n \n-CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn, SOCKET hSocketIn, const CAddress& addrIn, uint64_t nKeyedNetGroupIn, uint64_t nLocalHostNonceIn, const CAddress& addrBindIn, const std::string& addrNameIn, bool fInboundIn)\n+CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn, SOCKET hSocketIn, const CAddress& addrIn, uint64_t nKeyedNetGroupIn, uint64_t nLocalHostNonceIn, const CAddress& addrBindIn, const std::string& addrNameIn, bool fInboundIn, bool block_relay_only)\n     : nTimeConnected(GetSystemTimeInSeconds()),\n     addr(addrIn),\n     addrBind(addrBindIn),\n@@ -2643,7 +2655,9 @@ CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn\n     hSocket = hSocketIn;\n     addrName = addrNameIn == \"\" ? addr.ToStringIPPort() : addrNameIn;\n     hashContinue = uint256();\n-    m_tx_relay = MakeUnique<TxRelay>();\n+    if (!block_relay_only) {\n+        m_tx_relay = MakeUnique<TxRelay>();\n+    }\n \n     for (const std::string &msg : getAllNetMessageTypes())\n         mapRecvBytesPerMsgCmd[msg] = 0;"
      },
      {
        "sha": "20b7932037ac4bdc09588cab68a400500435a007",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 23,
        "deletions": 10,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a5e885306ea954d7eccdc11502e91a51dab8ec6/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a5e885306ea954d7eccdc11502e91a51dab8ec6/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=3a5e885306ea954d7eccdc11502e91a51dab8ec6",
        "patch": "@@ -56,10 +56,12 @@ static const unsigned int MAX_ADDR_TO_SEND = 1000;\n static const unsigned int MAX_PROTOCOL_MESSAGE_LENGTH = 4 * 1000 * 1000;\n /** Maximum length of the user agent string in `version` message */\n static const unsigned int MAX_SUBVERSION_LENGTH = 256;\n-/** Maximum number of automatic outgoing nodes */\n-static const int MAX_OUTBOUND_CONNECTIONS = 8;\n+/** Maximum number of automatic outgoing nodes over which we'll relay everything (blocks, tx, addrs, etc) */\n+static const int MAX_OUTBOUND_FULL_RELAY_CONNECTIONS = 8;\n /** Maximum number of addnode outgoing nodes */\n static const int MAX_ADDNODE_CONNECTIONS = 8;\n+/** Maximum number of block-relay-only outgoing connections */\n+static const int MAX_BLOCKS_ONLY_CONNECTIONS = 2;\n /** -listen default */\n static const bool DEFAULT_LISTEN = true;\n /** -upnp default */\n@@ -126,7 +128,8 @@ class CConnman\n     {\n         ServiceFlags nLocalServices = NODE_NONE;\n         int nMaxConnections = 0;\n-        int nMaxOutbound = 0;\n+        int m_max_outbound_full_relay = 0;\n+        int m_max_outbound_block_relay = 0;\n         int nMaxAddnode = 0;\n         int nMaxFeeler = 0;\n         int nBestHeight = 0;\n@@ -150,10 +153,12 @@ class CConnman\n     void Init(const Options& connOptions) {\n         nLocalServices = connOptions.nLocalServices;\n         nMaxConnections = connOptions.nMaxConnections;\n-        nMaxOutbound = std::min(connOptions.nMaxOutbound, connOptions.nMaxConnections);\n+        m_max_outbound_full_relay = std::min(connOptions.m_max_outbound_full_relay, connOptions.nMaxConnections);\n+        m_max_outbound_block_relay = connOptions.m_max_outbound_block_relay;\n         m_use_addrman_outgoing = connOptions.m_use_addrman_outgoing;\n         nMaxAddnode = connOptions.nMaxAddnode;\n         nMaxFeeler = connOptions.nMaxFeeler;\n+        m_max_outbound = m_max_outbound_full_relay + m_max_outbound_block_relay + nMaxFeeler;\n         nBestHeight = connOptions.nBestHeight;\n         clientInterface = connOptions.uiInterface;\n         m_banman = connOptions.m_banman;\n@@ -192,7 +197,7 @@ class CConnman\n     bool GetNetworkActive() const { return fNetworkActive; };\n     bool GetUseAddrmanOutgoing() const { return m_use_addrman_outgoing; };\n     void SetNetworkActive(bool active);\n-    void OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound = nullptr, const char *strDest = nullptr, bool fOneShot = false, bool fFeeler = false, bool manual_connection = false);\n+    void OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound = nullptr, const char *strDest = nullptr, bool fOneShot = false, bool fFeeler = false, bool manual_connection = false, bool block_relay_only = false);\n     bool CheckIncomingNonce(uint64_t nonce);\n \n     bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func);\n@@ -248,7 +253,7 @@ class CConnman\n     void AddNewAddresses(const std::vector<CAddress>& vAddr, const CAddress& addrFrom, int64_t nTimePenalty = 0);\n     std::vector<CAddress> GetAddresses();\n \n-    // This allows temporarily exceeding nMaxOutbound, with the goal of finding\n+    // This allows temporarily exceeding m_max_outbound_full_relay, with the goal of finding\n     // a peer that is better than all our current peers.\n     void SetTryNewOutboundPeer(bool flag);\n     bool GetTryNewOutboundPeer();\n@@ -350,7 +355,7 @@ class CConnman\n     CNode* FindNode(const CService& addr);\n \n     bool AttemptToEvictConnection();\n-    CNode* ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure, bool manual_connection);\n+    CNode* ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure, bool manual_connection, bool block_relay_only);\n     void AddWhitelistPermissionFlags(NetPermissionFlags& flags, const CNetAddr &addr) const;\n \n     void DeleteNode(CNode* pnode);\n@@ -409,9 +414,17 @@ class CConnman\n     std::unique_ptr<CSemaphore> semOutbound;\n     std::unique_ptr<CSemaphore> semAddnode;\n     int nMaxConnections;\n-    int nMaxOutbound;\n+\n+    // How many full-relay (tx, block, addr) outbound peers we want\n+    int m_max_outbound_full_relay;\n+\n+    // How many block-relay only outbound peers we want\n+    // We do not relay tx or addr messages with these peers\n+    int m_max_outbound_block_relay;\n+\n     int nMaxAddnode;\n     int nMaxFeeler;\n+    int m_max_outbound;\n     bool m_use_addrman_outgoing;\n     std::atomic<int> nBestHeight;\n     CClientUIInterface* clientInterface;\n@@ -437,7 +450,7 @@ class CConnman\n     std::thread threadMessageHandler;\n \n     /** flag for deciding to connect to an extra outbound peer,\n-     *  in excess of nMaxOutbound\n+     *  in excess of m_max_outbound_full_relay\n      *  This takes the place of a feeler connection */\n     std::atomic_bool m_try_another_outbound_peer;\n \n@@ -756,7 +769,7 @@ class CNode\n \n     std::set<uint256> orphan_work_set;\n \n-    CNode(NodeId id, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn, SOCKET hSocketIn, const CAddress &addrIn, uint64_t nKeyedNetGroupIn, uint64_t nLocalHostNonceIn, const CAddress &addrBindIn, const std::string &addrNameIn = \"\", bool fInboundIn = false);\n+    CNode(NodeId id, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn, SOCKET hSocketIn, const CAddress &addrIn, uint64_t nKeyedNetGroupIn, uint64_t nLocalHostNonceIn, const CAddress &addrBindIn, const std::string &addrNameIn = \"\", bool fInboundIn = false, bool block_relay_only = false);\n     ~CNode();\n     CNode(const CNode&) = delete;\n     CNode& operator=(const CNode&) = delete;"
      },
      {
        "sha": "48a7b91dcb546006d6bf8b3110199fddc2d17da0",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 9,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a5e885306ea954d7eccdc11502e91a51dab8ec6/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a5e885306ea954d7eccdc11502e91a51dab8ec6/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=3a5e885306ea954d7eccdc11502e91a51dab8ec6",
        "patch": "@@ -262,7 +262,7 @@ struct CNodeState {\n     bool fSupportsDesiredCmpctVersion;\n \n     /** State used to enforce CHAIN_SYNC_TIMEOUT\n-      * Only in effect for outbound, non-manual connections, with\n+      * Only in effect for outbound, non-manual, full-relay connections, with\n       * m_protect == false\n       * Algorithm: if a peer's best known block has less work than our tip,\n       * set a timeout CHAIN_SYNC_TIMEOUT seconds in the future:\n@@ -425,7 +425,7 @@ static void PushNodeVersion(CNode *pnode, CConnman* connman, int64_t nTime)\n     CAddress addrMe = CAddress(CService(), nLocalNodeServices);\n \n     connman->PushMessage(pnode, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERSION, PROTOCOL_VERSION, (uint64_t)nLocalNodeServices, nTime, addrYou, addrMe,\n-            nonce, strSubVersion, nNodeStartingHeight, ::g_relay_txes));\n+            nonce, strSubVersion, nNodeStartingHeight, ::g_relay_txes && pnode->m_tx_relay != nullptr));\n \n     if (fLogIPs) {\n         LogPrint(BCLog::NET, \"send version message: version %d, blocks=%d, us=%s, them=%s, peer=%d\\n\", PROTOCOL_VERSION, nNodeStartingHeight, addrMe.ToString(), addrYou.ToString(), nodeid);\n@@ -757,7 +757,7 @@ void UpdateLastBlockAnnounceTime(NodeId node, int64_t time_in_seconds)\n }\n \n // Returns true for outbound peers, excluding manual connections, feelers, and\n-// one-shots\n+// one-shots.\n static bool IsOutboundDisconnectionCandidate(const CNode *node)\n {\n     return !(node->fInbound || node->m_manual_connection || node->fFeeler || node->fOneShot);\n@@ -1772,9 +1772,11 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n             }\n         }\n \n-        if (!pfrom->fDisconnect && IsOutboundDisconnectionCandidate(pfrom) && nodestate->pindexBestKnownBlock != nullptr) {\n-            // If this is an outbound peer, check to see if we should protect\n+        if (!pfrom->fDisconnect && IsOutboundDisconnectionCandidate(pfrom) && nodestate->pindexBestKnownBlock != nullptr && pfrom->m_tx_relay != nullptr) {\n+            // If this is an outbound full-relay peer, check to see if we should protect\n             // it from the bad/lagging chain logic.\n+            // Note that block-relay-only peers are already implicitly protected, so we\n+            // only consider setting m_protect for the full-relay peers.\n             if (g_outbound_peers_with_protect_from_disconnect < MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT && nodestate->pindexBestKnownBlock->nChainWork >= ::ChainActive().Tip()->nChainWork && !nodestate->m_chain_sync.m_protect) {\n                 LogPrint(BCLog::NET, \"Protecting outbound peer=%d from eviction\\n\", pfrom->GetId());\n                 nodestate->m_chain_sync.m_protect = true;\n@@ -2088,9 +2090,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // Mark this node as currently connected, so we update its timestamp later.\n             LOCK(cs_main);\n             State(pfrom->GetId())->fCurrentlyConnected = true;\n-            LogPrintf(\"New outbound peer connected: version: %d, blocks=%d, peer=%d%s\\n\",\n-                      pfrom->nVersion.load(), pfrom->nStartingHeight, pfrom->GetId(),\n-                      (fLogIPs ? strprintf(\", peeraddr=%s\", pfrom->addr.ToString()) : \"\"));\n+            LogPrintf(\"New outbound peer connected: version: %d, blocks=%d, peer=%d%s (%s)\\n\",\n+                      pfrom->nVersion.load(), pfrom->nStartingHeight,\n+                      pfrom->GetId(), (fLogIPs ? strprintf(\", peeraddr=%s\", pfrom->addr.ToString()) : \"\"),\n+                      pfrom->m_tx_relay == nullptr ? \"block-relay\" : \"full-relay\");\n         }\n \n         if (pfrom->nVersion >= SENDHEADERS_VERSION) {\n@@ -2214,7 +2217,9 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             return false;\n         }\n \n-        bool fBlocksOnly = !g_relay_txes;\n+        // We won't accept tx inv's if we're in blocks-only mode, or this is a\n+        // block-relay-only peer\n+        bool fBlocksOnly = !g_relay_txes || (pfrom->m_tx_relay == nullptr);\n \n         // Allow whitelisted peers to send data other than blocks in blocks only mode if whitelistrelay is true\n         if (pfrom->HasPermission(PF_RELAY))\n@@ -3453,6 +3458,8 @@ void PeerLogicValidation::EvictExtraOutboundPeers(int64_t time_in_seconds)\n             if (state == nullptr) return; // shouldn't be possible, but just in case\n             // Don't evict our protected peers\n             if (state->m_chain_sync.m_protect) return;\n+            // Don't evict our block-relay-only peers.\n+            if (pnode->m_tx_relay == nullptr) return;\n             if (state->m_last_block_announcement < oldest_block_announcement || (state->m_last_block_announcement == oldest_block_announcement && pnode->GetId() > worst_peer)) {\n                 worst_peer = pnode->GetId();\n                 oldest_block_announcement = state->m_last_block_announcement;"
      },
      {
        "sha": "b0a613372ff146a7b42cac3c0ac961ccb21ada1e",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a5e885306ea954d7eccdc11502e91a51dab8ec6/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a5e885306ea954d7eccdc11502e91a51dab8ec6/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=3a5e885306ea954d7eccdc11502e91a51dab8ec6",
        "patch": "@@ -151,17 +151,17 @@ BOOST_AUTO_TEST_CASE(stale_tip_peer_management)\n     auto peerLogic = MakeUnique<PeerLogicValidation>(connman.get(), nullptr, scheduler, false);\n \n     const Consensus::Params& consensusParams = Params().GetConsensus();\n-    constexpr int nMaxOutbound = 8;\n+    constexpr int max_outbound_full_relay = 8;\n     CConnman::Options options;\n     options.nMaxConnections = 125;\n-    options.nMaxOutbound = nMaxOutbound;\n+    options.m_max_outbound_full_relay = max_outbound_full_relay;\n     options.nMaxFeeler = 1;\n \n     connman->Init(options);\n     std::vector<CNode *> vNodes;\n \n     // Mock some outbound peers\n-    for (int i=0; i<nMaxOutbound; ++i) {\n+    for (int i=0; i<max_outbound_full_relay; ++i) {\n         AddRandomOutboundPeer(vNodes, *peerLogic, connman.get());\n     }\n \n@@ -190,7 +190,7 @@ BOOST_AUTO_TEST_CASE(stale_tip_peer_management)\n     AddRandomOutboundPeer(vNodes, *peerLogic, connman.get());\n \n     peerLogic->CheckForStaleTipAndEvictPeers(consensusParams);\n-    for (int i=0; i<nMaxOutbound; ++i) {\n+    for (int i=0; i<max_outbound_full_relay; ++i) {\n         BOOST_CHECK(vNodes[i]->fDisconnect == false);\n     }\n     // Last added node should get marked for eviction\n@@ -203,10 +203,10 @@ BOOST_AUTO_TEST_CASE(stale_tip_peer_management)\n     UpdateLastBlockAnnounceTime(vNodes.back()->GetId(), GetTime());\n \n     peerLogic->CheckForStaleTipAndEvictPeers(consensusParams);\n-    for (int i=0; i<nMaxOutbound-1; ++i) {\n+    for (int i=0; i<max_outbound_full_relay-1; ++i) {\n         BOOST_CHECK(vNodes[i]->fDisconnect == false);\n     }\n-    BOOST_CHECK(vNodes[nMaxOutbound-1]->fDisconnect == true);\n+    BOOST_CHECK(vNodes[max_outbound_full_relay-1]->fDisconnect == true);\n     BOOST_CHECK(vNodes.back()->fDisconnect == false);\n \n     bool dummy;"
      }
    ]
  },
  {
    "sha": "430f489027f15c1e4948ea4378954df24e3fee88",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0MzBmNDg5MDI3ZjE1YzFlNDk0OGVhNDM3ODk1NGRmMjRlM2ZlZTg4",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-04-05T17:35:15Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-09-04T18:58:36Z"
      },
      "message": "Don't relay addr messages to block-relay-only peers\n\nWe don't want relay of addr messages to leak information about\nthese network links.",
      "tree": {
        "sha": "e0e8a8e4c9c1fc30957473e8072042b5e92c9160",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e0e8a8e4c9c1fc30957473e8072042b5e92c9160"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/430f489027f15c1e4948ea4378954df24e3fee88",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/430f489027f15c1e4948ea4378954df24e3fee88",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/430f489027f15c1e4948ea4378954df24e3fee88",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/430f489027f15c1e4948ea4378954df24e3fee88/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3a5e885306ea954d7eccdc11502e91a51dab8ec6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3a5e885306ea954d7eccdc11502e91a51dab8ec6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3a5e885306ea954d7eccdc11502e91a51dab8ec6"
      }
    ],
    "stats": {
      "total": 23,
      "additions": 19,
      "deletions": 4
    },
    "files": [
      {
        "sha": "b44048cbcecf6b00b9fc06b28d91efaef7c908a7",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/430f489027f15c1e4948ea4378954df24e3fee88/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/430f489027f15c1e4948ea4378954df24e3fee88/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=430f489027f15c1e4948ea4378954df24e3fee88",
        "patch": "@@ -2647,6 +2647,10 @@ CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn\n     fInbound(fInboundIn),\n     nKeyedNetGroup(nKeyedNetGroupIn),\n     addrKnown(5000, 0.001),\n+    // Don't relay addr messages to peers that we connect to as block-relay-only\n+    // peers (to prevent adversaries from inferring these links from addr\n+    // traffic).\n+    m_addr_relay_peer(!block_relay_only),\n     id(idIn),\n     nLocalHostNonce(nLocalHostNonceIn),\n     nLocalServices(nLocalServicesIn),"
      },
      {
        "sha": "605d7a8252b3baf7eb8f8962241fa89b78eb2d21",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/430f489027f15c1e4948ea4378954df24e3fee88/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/430f489027f15c1e4948ea4378954df24e3fee88/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=430f489027f15c1e4948ea4378954df24e3fee88",
        "patch": "@@ -712,6 +712,9 @@ class CNode\n     int64_t nNextAddrSend GUARDED_BY(cs_sendProcessing){0};\n     int64_t nNextLocalAddrSend GUARDED_BY(cs_sendProcessing){0};\n \n+    const bool m_addr_relay_peer;\n+    bool IsAddrRelayPeer() const { return m_addr_relay_peer; }\n+\n     // List of block ids we still have announce.\n     // There is no final sorting before sending, as they are always sent immediately\n     // and in the order requested.\n@@ -748,6 +751,7 @@ class CNode\n \n     // m_tx_relay == nullptr if we're not relaying transactions with this peer\n     std::unique_ptr<TxRelay> m_tx_relay;\n+\n     // Used for headers announcements - unfiltered blocks to relay\n     std::vector<uint256> vBlockHashesToAnnounce GUARDED_BY(cs_inventory);\n "
      },
      {
        "sha": "657109ba52a90f0b88e307494f4397502b3f3957",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 4,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/430f489027f15c1e4948ea4378954df24e3fee88/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/430f489027f15c1e4948ea4378954df24e3fee88/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=430f489027f15c1e4948ea4378954df24e3fee88",
        "patch": "@@ -1329,7 +1329,7 @@ static void RelayAddress(const CAddress& addr, bool fReachable, CConnman* connma\n     assert(nRelayNodes <= best.size());\n \n     auto sortfunc = [&best, &hasher, nRelayNodes](CNode* pnode) {\n-        if (pnode->nVersion >= CADDR_TIME_VERSION) {\n+        if (pnode->nVersion >= CADDR_TIME_VERSION && pnode->IsAddrRelayPeer()) {\n             uint64_t hashKey = CSipHasher(hasher).Write(pnode->GetId()).Finalize();\n             for (unsigned int i = 0; i < nRelayNodes; i++) {\n                  if (hashKey > best[i].first) {\n@@ -2018,7 +2018,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         UpdatePreferredDownload(pfrom, State(pfrom->GetId()));\n         }\n \n-        if (!pfrom->fInbound)\n+        if (!pfrom->fInbound && pfrom->IsAddrRelayPeer())\n         {\n             // Advertise our address\n             if (fListen && !::ChainstateActive().IsInitialBlockDownload())\n@@ -2134,6 +2134,9 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // Don't want addr from older versions unless seeding\n         if (pfrom->nVersion < CADDR_TIME_VERSION && connman->GetAddressCount() > 1000)\n             return true;\n+        if (!pfrom->IsAddrRelayPeer()) {\n+            return true;\n+        }\n         if (vAddr.size() > 1000)\n         {\n             LOCK(cs_main);\n@@ -2994,6 +2997,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             LogPrint(BCLog::NET, \"Ignoring \\\"getaddr\\\" from outbound connection. peer=%d\\n\", pfrom->GetId());\n             return true;\n         }\n+        if (!pfrom->IsAddrRelayPeer()) {\n+            LogPrint(BCLog::NET, \"Ignoring \\\"getaddr\\\" from block-relay-only connection. peer=%d\\n\", pfrom->GetId());\n+            return true;\n+        }\n \n         // Only send one GetAddr response per connection to reduce resource waste\n         //  and discourage addr stamping of INV announcements.\n@@ -3587,15 +3594,15 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n \n         // Address refresh broadcast\n         int64_t nNow = GetTimeMicros();\n-        if (!::ChainstateActive().IsInitialBlockDownload() && pto->nNextLocalAddrSend < nNow) {\n+        if (pto->IsAddrRelayPeer() && !::ChainstateActive().IsInitialBlockDownload() && pto->nNextLocalAddrSend < nNow) {\n             AdvertiseLocal(pto);\n             pto->nNextLocalAddrSend = PoissonNextSend(nNow, AVG_LOCAL_ADDRESS_BROADCAST_INTERVAL);\n         }\n \n         //\n         // Message: addr\n         //\n-        if (pto->nNextAddrSend < nNow) {\n+        if (pto->IsAddrRelayPeer() && pto->nNextAddrSend < nNow) {\n             pto->nNextAddrSend = PoissonNextSend(nNow, AVG_ADDRESS_BROADCAST_INTERVAL);\n             std::vector<CAddress> vAddr;\n             vAddr.reserve(pto->vAddrToSend.size());"
      }
    ]
  },
  {
    "sha": "937eba91e1550bc3038dc541c236ac83e0a0e6d5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5MzdlYmE5MWUxNTUwYmMzMDM4ZGM1NDFjMjM2YWM4M2UwYTBlNmQ1",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-08-13T14:08:48Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-09-04T18:58:36Z"
      },
      "message": "doc: improve comments relating to block-relay-only peers",
      "tree": {
        "sha": "69559c38688339b98deac13ff565b7d4df573c19",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/69559c38688339b98deac13ff565b7d4df573c19"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/937eba91e1550bc3038dc541c236ac83e0a0e6d5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/937eba91e1550bc3038dc541c236ac83e0a0e6d5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/937eba91e1550bc3038dc541c236ac83e0a0e6d5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/937eba91e1550bc3038dc541c236ac83e0a0e6d5/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "430f489027f15c1e4948ea4378954df24e3fee88",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/430f489027f15c1e4948ea4378954df24e3fee88",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/430f489027f15c1e4948ea4378954df24e3fee88"
      }
    ],
    "stats": {
      "total": 5,
      "additions": 5,
      "deletions": 0
    },
    "files": [
      {
        "sha": "baf3bc7448b8304b54914e10ddae6ca77931d817",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/937eba91e1550bc3038dc541c236ac83e0a0e6d5/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/937eba91e1550bc3038dc541c236ac83e0a0e6d5/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=937eba91e1550bc3038dc541c236ac83e0a0e6d5",
        "patch": "@@ -1512,6 +1512,11 @@ void static ProcessGetData(CNode* pfrom, const CChainParams& chainparams, CConnm\n     std::deque<CInv>::iterator it = pfrom->vRecvGetData.begin();\n     std::vector<CInv> vNotFound;\n     const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n+\n+    // Note that if we receive a getdata for a MSG_TX or MSG_WITNESS_TX from a\n+    // block-relay-only outbound peer, we will stop processing further getdata\n+    // messages from this peer (likely resulting in our peer eventually\n+    // disconnecting us).\n     if (pfrom->m_tx_relay != nullptr) {\n         LOCK(cs_main);\n "
      }
    ]
  },
  {
    "sha": "0ba08020c9791f7caf5986ad6490c16a2b66cd83",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowYmEwODAyMGM5NzkxZjdjYWY1OTg2YWQ2NDkwYzE2YTJiNjZjZDgz",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-08-28T21:23:45Z"
      },
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2019-09-04T18:58:36Z"
      },
      "message": "Disconnect peers violating blocks-only mode\n\nIf we set fRelay=false in our VERSION message, and a peer sends an INV or TX\nmessage anyway, disconnect. Since we use fRelay=false to minimize bandwidth,\nwe should not tolerate remaining connected to a peer violating the protocol.",
      "tree": {
        "sha": "ec7abf1dd0f430fc2cfa653dd520f86b85024b58",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ec7abf1dd0f430fc2cfa653dd520f86b85024b58"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0ba08020c9791f7caf5986ad6490c16a2b66cd83",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0ba08020c9791f7caf5986ad6490c16a2b66cd83",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0ba08020c9791f7caf5986ad6490c16a2b66cd83",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0ba08020c9791f7caf5986ad6490c16a2b66cd83/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "937eba91e1550bc3038dc541c236ac83e0a0e6d5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/937eba91e1550bc3038dc541c236ac83e0a0e6d5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/937eba91e1550bc3038dc541c236ac83e0a0e6d5"
      }
    ],
    "stats": {
      "total": 18,
      "additions": 13,
      "deletions": 5
    },
    "files": [
      {
        "sha": "4418174f95aba52772daeb253ce02209cb178aac",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 2,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0ba08020c9791f7caf5986ad6490c16a2b66cd83/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0ba08020c9791f7caf5986ad6490c16a2b66cd83/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=0ba08020c9791f7caf5986ad6490c16a2b66cd83",
        "patch": "@@ -2266,7 +2266,9 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             {\n                 pfrom->AddInventoryKnown(inv);\n                 if (fBlocksOnly) {\n-                    LogPrint(BCLog::NET, \"transaction (%s) inv sent in violation of protocol peer=%d\\n\", inv.hash.ToString(), pfrom->GetId());\n+                    LogPrint(BCLog::NET, \"transaction (%s) inv sent in violation of protocol, disconnecting peer=%d\\n\", inv.hash.ToString(), pfrom->GetId());\n+                    pfrom->fDisconnect = true;\n+                    return true;\n                 } else if (!fAlreadyHave && !fImporting && !fReindex && !::ChainstateActive().IsInitialBlockDownload()) {\n                     RequestTx(State(pfrom->GetId()), inv.hash, current_time);\n                 }\n@@ -2483,9 +2485,11 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n     if (strCommand == NetMsgType::TX) {\n         // Stop processing the transaction early if\n         // We are in blocks only mode and peer is either not whitelisted or whitelistrelay is off\n-        if (!g_relay_txes && !pfrom->HasPermission(PF_RELAY))\n+        // or if this peer is supposed to be a block-relay-only peer\n+        if ((!g_relay_txes && !pfrom->HasPermission(PF_RELAY)) || (pfrom->m_tx_relay == nullptr))\n         {\n             LogPrint(BCLog::NET, \"transaction sent in violation of protocol peer=%d\\n\", pfrom->GetId());\n+            pfrom->fDisconnect = true;\n             return true;\n         }\n "
      },
      {
        "sha": "3258a38e3cba70cf6831320f7e5a21246d1fa927",
        "filename": "test/functional/p2p_blocksonly.py",
        "status": "modified",
        "additions": 7,
        "deletions": 3,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0ba08020c9791f7caf5986ad6490c16a2b66cd83/test/functional/p2p_blocksonly.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0ba08020c9791f7caf5986ad6490c16a2b66cd83/test/functional/p2p_blocksonly.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_blocksonly.py?ref=0ba08020c9791f7caf5986ad6490c16a2b66cd83",
        "patch": "@@ -19,7 +19,7 @@ def set_test_params(self):\n     def run_test(self):\n         self.nodes[0].add_p2p_connection(P2PInterface())\n \n-        self.log.info('Check that txs from p2p are rejected')\n+        self.log.info('Check that txs from p2p are rejected and result in disconnect')\n         prevtx = self.nodes[0].getblock(self.nodes[0].getblockhash(1), 2)['tx'][0]\n         rawtx = self.nodes[0].createrawtransaction(\n             inputs=[{\n@@ -42,13 +42,17 @@ def run_test(self):\n         assert_equal(self.nodes[0].getnetworkinfo()['localrelay'], False)\n         with self.nodes[0].assert_debug_log(['transaction sent in violation of protocol peer=0']):\n             self.nodes[0].p2p.send_message(msg_tx(FromHex(CTransaction(), sigtx)))\n-            self.nodes[0].p2p.sync_with_ping()\n+            self.nodes[0].p2p.wait_for_disconnect()\n             assert_equal(self.nodes[0].getmempoolinfo()['size'], 0)\n \n+        # Remove the disconnected peer and add a new one.\n+        del self.nodes[0].p2ps[0]\n+        self.nodes[0].add_p2p_connection(P2PInterface())\n+\n         self.log.info('Check that txs from rpc are not rejected and relayed to other peers')\n         assert_equal(self.nodes[0].getpeerinfo()[0]['relaytxes'], True)\n         txid = self.nodes[0].testmempoolaccept([sigtx])[0]['txid']\n-        with self.nodes[0].assert_debug_log(['received getdata for: tx {} peer=0'.format(txid)]):\n+        with self.nodes[0].assert_debug_log(['received getdata for: tx {} peer=1'.format(txid)]):\n             self.nodes[0].sendrawtransaction(sigtx)\n             self.nodes[0].p2p.wait_for_tx(txid)\n             assert_equal(self.nodes[0].getmempoolinfo()['size'], 1)"
      }
    ]
  }
]