[
  {
    "sha": "e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplMzliMjZjMGU4MzlkYzViMmU4NDM2ZGEyYjI1ODE2Y2NiMTkzOGQ5",
    "commit": {
      "author": {
        "name": "Brandon Dahler",
        "email": "brandon.dahler@gmail.com",
        "date": "2013-11-17T01:44:09Z"
      },
      "committer": {
        "name": "Brandon Dahler",
        "email": "brandon.dahler@gmail.com",
        "date": "2013-12-06T02:58:31Z"
      },
      "message": "Use C++ streams instead of C-style printf functions\n\nConvert aoti[64] to fromstr, itostr[64] to tostr.\nAdd Log class (log.{cpp,h}), replaces LogPrintf function.\nRemove error(...) function.\nFix functions relying on the false return from error function.\nUse fstream where possible (when no fsync is required).\nUse boost::format for localized string token replacement.\nAdd ability to request the translation as a string.\nMove time functions from util.{h,cpp} to bitcointime.{h,cpp} (can not use time.h).\nUse boost::format instead of ostringstream when possible.",
      "tree": {
        "sha": "61f3fb99d881a851dfbfad2af857754ed903ec00",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/61f3fb99d881a851dfbfad2af857754ed903ec00"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/comments",
    "author": {
      "login": "brandondahler",
      "id": 1155895,
      "node_id": "MDQ6VXNlcjExNTU4OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1155895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brandondahler",
      "html_url": "https://github.com/brandondahler",
      "followers_url": "https://api.github.com/users/brandondahler/followers",
      "following_url": "https://api.github.com/users/brandondahler/following{/other_user}",
      "gists_url": "https://api.github.com/users/brandondahler/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brandondahler/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brandondahler/subscriptions",
      "organizations_url": "https://api.github.com/users/brandondahler/orgs",
      "repos_url": "https://api.github.com/users/brandondahler/repos",
      "events_url": "https://api.github.com/users/brandondahler/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brandondahler/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "brandondahler",
      "id": 1155895,
      "node_id": "MDQ6VXNlcjExNTU4OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1155895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brandondahler",
      "html_url": "https://github.com/brandondahler",
      "followers_url": "https://api.github.com/users/brandondahler/followers",
      "following_url": "https://api.github.com/users/brandondahler/following{/other_user}",
      "gists_url": "https://api.github.com/users/brandondahler/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brandondahler/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brandondahler/subscriptions",
      "organizations_url": "https://api.github.com/users/brandondahler/orgs",
      "repos_url": "https://api.github.com/users/brandondahler/repos",
      "events_url": "https://api.github.com/users/brandondahler/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brandondahler/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d6d12f932db873a1eb490820206de1cca7d287d3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d6d12f932db873a1eb490820206de1cca7d287d3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d6d12f932db873a1eb490820206de1cca7d287d3"
      }
    ],
    "stats": {
      "total": 4139,
      "additions": 2408,
      "deletions": 1731
    },
    "files": [
      {
        "sha": "ab587491c168c0428b7a69365e4627d962f352a8",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -176,7 +176,7 @@ PKG_PROG_PKG_CONFIG\n ##       compatibility with the legacy buildsystem.\n ##\n CXXFLAGS=\"$CXXFLAGS -Wall -Wextra -Wformat -Wformat-security -Wno-unused-parameter\"\n-CPPFLAGS=\"$CPPFLAGS -DBOOST_SPIRIT_THREADSAFE -DHAVE_BUILD_INFO -D__STDC_FORMAT_MACROS\"\n+CPPFLAGS=\"$CPPFLAGS -DBOOST_SPIRIT_THREADSAFE -DHAVE_BUILD_INFO\"\n \n AC_LANG_PUSH([C++])\n \n@@ -221,7 +221,7 @@ case $host in\n        AC_MSG_ERROR(\"windres not found\")\n      fi\n \n-     CPPFLAGS=\"$CPPFLAGS -D_MT -DWIN32 -D_WINDOWS -DBOOST_THREAD_USE_LIB -D__USE_MINGW_ANSI_STDIO\"\n+     CPPFLAGS=\"$CPPFLAGS -D_MT -DWIN32 -D_WINDOWS -DBOOST_THREAD_USE_LIB\"\n      LEVELDB_TARGET_FLAGS=\"TARGET_OS=OS_WINDOWS_CROSSCOMPILE\"\n      CXXFLAGS=\"$CXXFLAGS -w\"\n      ;;"
      },
      {
        "sha": "395b219f015d0bea3a486ff4b26bbf9c40e13904",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -15,10 +15,10 @@ BITCOIN_CORE_H = addrman.h alert.h allocators.h base58.h bignum.h \\\n   rpcclient.h \\\n   rpcprotocol.h \\\n   rpcserver.h \\\n-  bloom.h chainparams.h checkpoints.h checkqueue.h \\\n+  bitcointime.h bloom.h chainparams.h checkpoints.h checkqueue.h \\\n   clientversion.h coincontrol.h compat.h core.h coins.h crypter.h db.h hash.h init.h \\\n-  key.h keystore.h leveldbwrapper.h limitedmap.h main.h miner.h mruset.h \\\n-  netbase.h net.h noui.h protocol.h script.h serialize.h sync.h threadsafety.h \\\n+  key.h keystore.h leveldbwrapper.h limitedmap.h log.h main.h miner.h mruset.h \\\n+  netbase.h net.h noui.h protocol.h script.h serialize.h sync.h threadsafety.h  \\\n   txdb.h txmempool.h ui_interface.h uint256.h util.h version.h walletdb.h wallet.h\n \n JSON_H = json/json_spirit.h json/json_spirit_error_position.h \\\n@@ -45,10 +45,12 @@ libbitcoin_server_a_SOURCES = addrman.cpp alert.cpp \\\n \n libbitcoin_common_a_SOURCES = \\\n   allocators.cpp \\\n+  bitcointime.cpp \\\n   chainparams.cpp \\\n   core.cpp \\\n   hash.cpp \\\n   key.cpp \\\n+  log.cpp \\\n   netbase.cpp \\\n   protocol.cpp \\\n   rpcprotocol.cpp \\"
      },
      {
        "sha": "25fb9308e24362f9879ab5d30808a615a6e90054",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -304,7 +304,7 @@ void CAddrMan::Good_(const CService &addr, int64_t nTime)\n     // TODO: maybe re-add the node, but for now, just bail out\n     if (nUBucket == -1) return;\n \n-    LogPrint(\"addrman\", \"Moving %s to tried\\n\", addr.ToString().c_str());\n+    Log(\"addrman\") << \"Moving \" << addr.ToString() << \" to tried\\n\";\n \n     // move nId to the tried tables\n     MakeTried(info, nId, nUBucket);\n@@ -322,7 +322,7 @@ bool CAddrMan::Add_(const CAddress &addr, const CNetAddr& source, int64_t nTimeP\n     if (pinfo)\n     {\n         // periodically update nTime\n-        bool fCurrentlyOnline = (GetAdjustedTime() - addr.nTime < 24 * 60 * 60);\n+        bool fCurrentlyOnline = (BitcoinTime::GetAdjustedTime() - addr.nTime < 24 * 60 * 60);\n         int64_t nUpdateInterval = (fCurrentlyOnline ? 60 * 60 : 24 * 60 * 60);\n         if (addr.nTime && (!pinfo->nTime || pinfo->nTime < addr.nTime - nUpdateInterval - nTimePenalty))\n             pinfo->nTime = max((int64_t)0, addr.nTime - nTimePenalty);"
      },
      {
        "sha": "4ebc8700a4ca8af47354108f08556ef9f6a58468",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 10,
        "deletions": 8,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -5,6 +5,8 @@\n #ifndef _BITCOIN_ADDRMAN\n #define _BITCOIN_ADDRMAN 1\n \n+#include \"bitcointime.h\"\n+#include \"log.h\"\n #include \"netbase.h\"\n #include \"protocol.h\"\n #include \"sync.h\"\n@@ -87,10 +89,10 @@ class CAddrInfo : public CAddress\n     }\n \n     // Determine whether the statistics about this entry are bad enough so that it can just be deleted\n-    bool IsTerrible(int64_t nNow = GetAdjustedTime()) const;\n+    bool IsTerrible(int64_t nNow = BitcoinTime::GetAdjustedTime()) const;\n \n     // Calculate the relative chance this entry should be given when selecting nodes to connect to\n-    double GetChance(int64_t nNow = GetAdjustedTime()) const;\n+    double GetChance(int64_t nNow = BitcoinTime::GetAdjustedTime()) const;\n \n };\n \n@@ -404,7 +406,7 @@ class CAddrMan\n             LOCK(cs);\n             int err;\n             if ((err=Check_()))\n-                LogPrintf(\"ADDRMAN CONSISTENCY CHECK FAILED!!! err=%i\\n\", err);\n+                Log() << \"ADDRMAN CONSISTENCY CHECK FAILED!!! err=\" << err << \"\\n\";\n         }\n #endif\n     }\n@@ -420,7 +422,7 @@ class CAddrMan\n             Check();\n         }\n         if (fRet)\n-            LogPrint(\"addrman\", \"Added %s from %s: %i tried, %i new\\n\", addr.ToStringIPPort().c_str(), source.ToString().c_str(), nTried, nNew);\n+            Log(\"addrman\") << \"Added \" << addr.ToStringIPPort() << \" from \" << source.ToString() << \": \" << nTried << \" tried, \" << nNew << \" new\\n\";\n         return fRet;\n     }\n \n@@ -436,12 +438,12 @@ class CAddrMan\n             Check();\n         }\n         if (nAdd)\n-            LogPrint(\"addrman\", \"Added %i addresses from %s: %i tried, %i new\\n\", nAdd, source.ToString().c_str(), nTried, nNew);\n+            Log(\"addrman\") << \"Added \" << nAdd << \" addresses from \" << source.ToString() << \": \" << nTried << \" tried, \" << nNew << \" new\\n\";\n         return nAdd > 0;\n     }\n \n     // Mark an entry as accessible.\n-    void Good(const CService &addr, int64_t nTime = GetAdjustedTime())\n+    void Good(const CService &addr, int64_t nTime = BitcoinTime::GetAdjustedTime())\n     {\n         {\n             LOCK(cs);\n@@ -452,7 +454,7 @@ class CAddrMan\n     }\n \n     // Mark an entry as connection attempted to.\n-    void Attempt(const CService &addr, int64_t nTime = GetAdjustedTime())\n+    void Attempt(const CService &addr, int64_t nTime = BitcoinTime::GetAdjustedTime())\n     {\n         {\n             LOCK(cs);\n@@ -490,7 +492,7 @@ class CAddrMan\n     }\n \n     // Mark an entry as currently-connected-to.\n-    void Connected(const CService &addr, int64_t nTime = GetAdjustedTime())\n+    void Connected(const CService &addr, int64_t nTime = BitcoinTime::GetAdjustedTime())\n     {\n         {\n             LOCK(cs);"
      },
      {
        "sha": "60b273dfedfcb176edee63c7807fb1c6d36e8c5c",
        "filename": "src/alert.cpp",
        "status": "modified",
        "additions": 40,
        "deletions": 40,
        "changes": 80,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/alert.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/alert.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/alert.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -5,18 +5,21 @@\n \n #include \"alert.h\"\n \n+#include \"bitcointime.h\"\n #include \"key.h\"\n+#include \"log.h\"\n #include \"net.h\"\n #include \"ui_interface.h\"\n #include \"util.h\"\n \n #include <algorithm>\n-#include <inttypes.h>\n #include <map>\n+#include <sstream>\n \n #include <boost/algorithm/string/classification.hpp>\n #include <boost/algorithm/string/replace.hpp>\n #include <boost/foreach.hpp>\n+#include <boost/format.hpp>\n \n using namespace std;\n \n@@ -43,44 +46,38 @@ void CUnsignedAlert::SetNull()\n \n std::string CUnsignedAlert::ToString() const\n {\n-    std::string strSetCancel;\n+    std::ostringstream oss;\n+    oss << \"CAlert(\\n\"\n+        << \"    nVersion     = \" << nVersion << \"\\n\"\n+        << \"    nRelayUntil  = \" << nRelayUntil << \"\\n\"\n+        << \"    nExpiration  = \" << nExpiration << \"\\n\"\n+        << \"    nID          = \" << nID << \"\\n\"\n+        << \"    nCancel      = \" << nCancel << \"\\n\"\n+        << \"    setCancel    =\";\n+    \n     BOOST_FOREACH(int n, setCancel)\n-        strSetCancel += strprintf(\"%d \", n);\n-    std::string strSetSubVer;\n+        oss << \" \" << n;\n+    oss << \"\\n\";\n+\n+    oss << \"    nMinVer      = \" << nMinVer << \"\\n\"\n+        << \"    nMaxVer      = \" << nMaxVer << \"\\n\"\n+        << \"    setSubVer    =\";\n+    \n     BOOST_FOREACH(std::string str, setSubVer)\n-        strSetSubVer += \"\\\"\" + str + \"\\\" \";\n-    return strprintf(\n-        \"CAlert(\\n\"\n-        \"    nVersion     = %d\\n\"\n-        \"    nRelayUntil  = %\"PRId64\"\\n\"\n-        \"    nExpiration  = %\"PRId64\"\\n\"\n-        \"    nID          = %d\\n\"\n-        \"    nCancel      = %d\\n\"\n-        \"    setCancel    = %s\\n\"\n-        \"    nMinVer      = %d\\n\"\n-        \"    nMaxVer      = %d\\n\"\n-        \"    setSubVer    = %s\\n\"\n-        \"    nPriority    = %d\\n\"\n-        \"    strComment   = \\\"%s\\\"\\n\"\n-        \"    strStatusBar = \\\"%s\\\"\\n\"\n-        \")\\n\",\n-        nVersion,\n-        nRelayUntil,\n-        nExpiration,\n-        nID,\n-        nCancel,\n-        strSetCancel.c_str(),\n-        nMinVer,\n-        nMaxVer,\n-        strSetSubVer.c_str(),\n-        nPriority,\n-        strComment.c_str(),\n-        strStatusBar.c_str());\n+        oss << \" \\\"\" << str << \"\\\"\";\n+    oss << \"\\n\";\n+\n+    oss << \"    nPriority    = \" << nPriority << \"\\n\"\n+        << \"    strComment   = \\\"\" << strComment << \"\\\"\\n\"\n+        << \"    strStatusBar = \\\"\" << strStatusBar << \"\\\"\\n\"\n+        << \")\\n\";\n+\n+    return oss.str();\n }\n \n void CUnsignedAlert::print() const\n {\n-    LogPrintf(\"%s\", ToString().c_str());\n+    Log() << ToString();\n }\n \n void CAlert::SetNull()\n@@ -102,7 +99,7 @@ uint256 CAlert::GetHash() const\n \n bool CAlert::IsInEffect() const\n {\n-    return (GetAdjustedTime() < nExpiration);\n+    return (BitcoinTime::GetAdjustedTime() < nExpiration);\n }\n \n bool CAlert::Cancels(const CAlert& alert) const\n@@ -134,7 +131,7 @@ bool CAlert::RelayTo(CNode* pnode) const\n     {\n         if (AppliesTo(pnode->nVersion, pnode->strSubVer) ||\n             AppliesToMe() ||\n-            GetAdjustedTime() < nRelayUntil)\n+            BitcoinTime::GetAdjustedTime() < nRelayUntil)\n         {\n             pnode->PushMessage(\"alert\", *this);\n             return true;\n@@ -147,7 +144,10 @@ bool CAlert::CheckSignature() const\n {\n     CPubKey key(Params().AlertKey());\n     if (!key.Verify(Hash(vchMsg.begin(), vchMsg.end()), vchSig))\n-        return error(\"CAlert::CheckSignature() : verify signature failed\");\n+    {\n+        Log() << \"ERROR: CAlert::CheckSignature() : verify signature failed\\n\";\n+        return false;\n+    }\n \n     // Now unserialize the data\n     CDataStream sMsg(vchMsg, SER_NETWORK, PROTOCOL_VERSION);\n@@ -204,13 +204,13 @@ bool CAlert::ProcessAlert(bool fThread)\n             const CAlert& alert = (*mi).second;\n             if (Cancels(alert))\n             {\n-                LogPrint(\"alert\", \"cancelling alert %d\\n\", alert.nID);\n+                Log(\"alert\") << \"cancelling alert \" << alert.nID << \"\\n\";\n                 uiInterface.NotifyAlertChanged((*mi).first, CT_DELETED);\n                 mapAlerts.erase(mi++);\n             }\n             else if (!alert.IsInEffect())\n             {\n-                LogPrint(\"alert\", \"expiring alert %d\\n\", alert.nID);\n+                Log(\"alert\") << \"expiring alert \" << alert.nID << \"\\n\";\n                 uiInterface.NotifyAlertChanged((*mi).first, CT_DELETED);\n                 mapAlerts.erase(mi++);\n             }\n@@ -224,7 +224,7 @@ bool CAlert::ProcessAlert(bool fThread)\n             const CAlert& alert = item.second;\n             if (alert.Cancels(*this))\n             {\n-                LogPrint(\"alert\", \"alert already cancelled by %d\\n\", alert.nID);\n+                Log(\"alert\") << \"alert already cancelled by \" << alert.nID << \"\\n\";\n                 return false;\n             }\n         }\n@@ -254,6 +254,6 @@ bool CAlert::ProcessAlert(bool fThread)\n         }\n     }\n \n-    LogPrint(\"alert\", \"accepted alert %d, AppliesToMe()=%d\\n\", nID, AppliesToMe());\n+    Log(\"alert\") << \"accepted alert \" << nID << \", AppliesToMe()=\" << AppliesToMe() << \"\\n\";\n     return true;\n }"
      },
      {
        "sha": "0930f332328aaa25621e0906ca3425703230f00a",
        "filename": "src/bitcoin-cli.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 9,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/bitcoin-cli.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/bitcoin-cli.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-cli.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -9,6 +9,9 @@\n #include \"ui_interface.h\" /* for _(...) */\n #include \"chainparams.h\"\n \n+#include <iostream>\n+#include <string>\n+\n #include <boost/filesystem/operations.hpp>\n \n //////////////////////////////////////////////////////////////////////////////\n@@ -23,7 +26,7 @@ static bool AppInitRPC(int argc, char* argv[])\n     ParseParameters(argc, argv);\n     if (!boost::filesystem::is_directory(GetDataDir(false)))\n     {\n-        fprintf(stderr, \"Error: Specified data directory \\\"%s\\\" does not exist.\\n\", mapArgs[\"-datadir\"].c_str());\n+        std::cerr << \"Error: Specified data directory \\\"\" << mapArgs[\"-datadir\"] << \"\\\" does not exist.\\n\";\n         return false;\n     }\n     ReadConfigFile(mapArgs, mapMultiArgs);\n@@ -36,15 +39,15 @@ static bool AppInitRPC(int argc, char* argv[])\n     if (argc<2 || mapArgs.count(\"-?\") || mapArgs.count(\"--help\"))\n     {\n         // First part of help message is specific to RPC client\n-        std::string strUsage = _(\"Bitcoin RPC client version\") + \" \" + FormatFullVersion() + \"\\n\\n\" +\n-            _(\"Usage:\") + \"\\n\" +\n-              \"  bitcoin-cli [options] <command> [params]  \" + _(\"Send command to Bitcoin server\") + \"\\n\" +\n-              \"  bitcoin-cli [options] help                \" + _(\"List commands\") + \"\\n\" +\n-              \"  bitcoin-cli [options] help <command>      \" + _(\"Get help for a command\") + \"\\n\";\n-\n-        strUsage += \"\\n\" + HelpMessageCli(true);\n+        std::cout << _<std::string>(\"Bitcoin RPC client version\") << \" \" << FormatFullVersion() << \"\\n\" \n+                  << \"\\n\"\n+                  << _<std::string>(\"Usage:\") << \"\\n\"\n+                  << \"  bitcoin-cli [options] <command> [params]  \" << _<std::string>(\"Send command to Bitcoin server\") << \"\\n\"\n+                  << \"  bitcoin-cli [options] help                \" << _<std::string>(\"List commands\") << \"\\n\"\n+                  << \"  bitcoin-cli [options] help <command>      \" << _<std::string>(\"Get help for a command\") << \"\\n\"\n+                  << \"\\n\" \n+                  << HelpMessageCli(true);\n \n-        fprintf(stdout, \"%s\", strUsage.c_str());\n         return false;\n     }\n     return true;"
      },
      {
        "sha": "4e04da1fcd083d8a2b090fb8c43ac183a2ef4ef7",
        "filename": "src/bitcoind.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 12,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/bitcoind.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/bitcoind.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoind.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -11,6 +11,9 @@\n #include \"ui_interface.h\"\n #include \"util.h\"\n \n+#include <iostream>\n+#include <string>\n+\n #include <boost/algorithm/string/predicate.hpp>\n #include <boost/filesystem.hpp>\n \n@@ -65,31 +68,31 @@ bool AppInit(int argc, char* argv[])\n         ParseParameters(argc, argv);\n         if (!boost::filesystem::is_directory(GetDataDir(false)))\n         {\n-            fprintf(stderr, \"Error: Specified data directory \\\"%s\\\" does not exist.\\n\", mapArgs[\"-datadir\"].c_str());\n+            std::cerr << \"Error: Specified data directory \\\"\" << mapArgs[\"-datadir\"] << \"\\\" does not exist.\\n\";\n             return false;\n         }\n         ReadConfigFile(mapArgs, mapMultiArgs);\n         // Check for -testnet or -regtest parameter (TestNet() calls are only valid after this clause)\n         if (!SelectParamsFromCommandLine()) {\n-            fprintf(stderr, \"Error: Invalid combination of -regtest and -testnet.\\n\");\n+            std::cerr << \"Error: Invalid combination of -regtest and -testnet.\\n\";\n             return false;\n         }\n \n         if (mapArgs.count(\"-?\") || mapArgs.count(\"--help\"))\n         {\n             // First part of help message is specific to bitcoind / RPC client\n-            std::string strUsage = _(\"Bitcoin version\") + \" \" + FormatFullVersion() + \"\\n\\n\" +\n-                _(\"Usage:\") + \"\\n\" +\n-                  \"  bitcoind [options]                     \" + _(\"Start Bitcoin server\") + \"\\n\" +\n-                _(\"Usage (deprecated, use bitcoin-cli):\") + \"\\n\" +\n-                  \"  bitcoind [options] <command> [params]  \" + _(\"Send command to Bitcoin server\") + \"\\n\" +\n-                  \"  bitcoind [options] help                \" + _(\"List commands\") + \"\\n\" +\n-                  \"  bitcoind [options] help <command>      \" + _(\"Get help for a command\") + \"\\n\";\n+            std::string strUsage = _<std::string>(\"Bitcoin version\") + \" \" + FormatFullVersion() + \"\\n\\n\" +\n+                _<std::string>(\"Usage:\") + \"\\n\" +\n+                  \"  bitcoind [options]                     \" + _<std::string>(\"Start Bitcoin server\") + \"\\n\" +\n+                _<std::string>(\"Usage (deprecated, use bitcoin-cli):\") + \"\\n\" +\n+                  \"  bitcoind [options] <command> [params]  \" + _<std::string>(\"Send command to Bitcoin server\") + \"\\n\" +\n+                  \"  bitcoind [options] help                \" + _<std::string>(\"List commands\") + \"\\n\" +\n+                  \"  bitcoind [options] help <command>      \" + _<std::string>(\"Get help for a command\") + \"\\n\";\n \n             strUsage += \"\\n\" + HelpMessage(HMM_BITCOIND);\n             strUsage += \"\\n\" + HelpMessageCli(false);\n \n-            fprintf(stdout, \"%s\", strUsage.c_str());\n+            std::cout << strUsage;\n             return false;\n         }\n \n@@ -112,7 +115,7 @@ bool AppInit(int argc, char* argv[])\n             pid_t pid = fork();\n             if (pid < 0)\n             {\n-                fprintf(stderr, \"Error: fork() returned %d errno %d\\n\", pid, errno);\n+                std::cerr << \"Error: fork() returned \" << pid << \" errno \" << errno << \"\\n\";\n                 return false;\n             }\n             if (pid > 0) // Parent process, pid is child process id\n@@ -124,7 +127,7 @@ bool AppInit(int argc, char* argv[])\n \n             pid_t sid = setsid();\n             if (sid < 0)\n-                fprintf(stderr, \"Error: setsid() returned %d errno %d\\n\", sid, errno);\n+                std::cerr << \"Error: setsid() returned \" << sid << \" errno \" << errno << \"\\n\";\n         }\n #endif\n "
      },
      {
        "sha": "7d46c5016b58b6f880e6a3d8457e54b653f90e41",
        "filename": "src/bitcointime.cpp",
        "status": "added",
        "additions": 85,
        "deletions": 0,
        "changes": 85,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/bitcointime.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/bitcointime.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcointime.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -0,0 +1,85 @@\n+// Copyright (c) 2013 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"bitcointime.h\"\n+\n+#include \"log.h\"\n+#include \"sync.h\"\n+\n+#ifndef WIN32\n+#include <sys/time.h>\n+#endif\n+\n+#include <boost/date_time/posix_time/posix_time.hpp>\n+#include <boost/foreach.hpp>\n+\n+using namespace std;\n+\n+namespace BitcoinTime\n+{\n+    int64_t GetTimeMillis()\n+    {\n+        return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n+                boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n+    }\n+\n+    int64_t GetTimeMicros()\n+    {\n+        return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n+                boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_microseconds();\n+    }\n+\n+    string DateTimeStrFormat(const char* pszFormat, int64_t nTime)\n+    {\n+        time_t n = nTime;\n+        struct tm* ptmTime = gmtime(&n);\n+        char pszTime[200];\n+        strftime(pszTime, sizeof(pszTime), pszFormat, ptmTime);\n+        return pszTime;\n+    }\n+\n+\n+\n+    //\n+    // \"Never go to sea with two chronometers; take one or three.\"\n+    // Our three time sources are:\n+    //  - System clock\n+    //  - Median of other nodes clocks\n+    //  - The user (asking the user to fix the system clock if the first two disagree)\n+    //\n+    static int64_t nMockTime = 0;  // For unit testing\n+\n+    int64_t GetTime()\n+    {\n+        if (nMockTime) return nMockTime;\n+\n+        return time(NULL);\n+    }\n+\n+    void SetMockTime(int64_t nMockTimeIn)\n+    {\n+        nMockTime = nMockTimeIn;\n+    }\n+\n+    int64_t GetAdjustedTime()\n+    {\n+        return GetTime() + GetTimeOffset();\n+    }\n+\n+    static CCriticalSection cs_nTimeOffset;\n+    static int64_t nTimeOffset = 0;\n+    \n+    int64_t GetTimeOffset()\n+    {\n+        LOCK(cs_nTimeOffset);\n+        return nTimeOffset;\n+    }\n+\n+    void SetTimeOffset(int64_t n)\n+    {\n+        LOCK(cs_nTimeOffset);\n+        nTimeOffset = n;\n+    }\n+\n+}"
      },
      {
        "sha": "0a7e300e0dece723d3beb25080e143c3adec8709",
        "filename": "src/bitcointime.h",
        "status": "added",
        "additions": 24,
        "deletions": 0,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/bitcointime.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/bitcointime.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcointime.h?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -0,0 +1,24 @@\n+// Copyright (c) 2013 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_BITCOINTIME_H\n+#define BITCOIN_BITCOINTIME_H\n+\n+#include <stdint.h>\n+#include <string>\n+\n+namespace BitcoinTime\n+{\n+    int64_t GetTimeMillis();\n+    int64_t GetTimeMicros();\n+    std::string DateTimeStrFormat(const char* pszFormat, int64_t nTime);\n+\n+    int64_t GetTime();\n+    void SetMockTime(int64_t nMockTimeIn);\n+    int64_t GetAdjustedTime();\n+    int64_t GetTimeOffset();\n+    void SetTimeOffset(int64_t n);\n+}\n+\n+#endif"
      },
      {
        "sha": "25e9ea2907fe97638c3f929a9688147bac7fd42c",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -6,6 +6,7 @@\n #include \"chainparams.h\"\n \n #include \"assert.h\"\n+#include \"bitcointime.h\"\n #include \"core.h\"\n #include \"protocol.h\"\n #include \"util.h\"\n@@ -162,7 +163,7 @@ class CMainParams : public CChainParams {\n             struct in_addr ip;\n             memcpy(&ip, &pnSeed[i], sizeof(ip));\n             CAddress addr(CService(ip, GetDefaultPort()));\n-            addr.nTime = GetTime() - GetRand(nOneWeek) - nOneWeek;\n+            addr.nTime = BitcoinTime::GetTime() - GetRand(nOneWeek) - nOneWeek;\n             vFixedSeeds.push_back(addr);\n         }\n     }"
      },
      {
        "sha": "06ac4df9c52626cff834330c120f329ffc3a9fcb",
        "filename": "src/core.cpp",
        "status": "modified",
        "additions": 39,
        "deletions": 35,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/core.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/core.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -5,16 +5,23 @@\n \n #include \"core.h\"\n \n+#include \"log.h\"\n #include \"util.h\"\n \n+#include <iomanip>\n+#include <sstream>\n+#include <stdint.h>\n+\n+#include <boost/format.hpp>\n+\n std::string COutPoint::ToString() const\n {\n-    return strprintf(\"COutPoint(%s, %u)\", hash.ToString().substr(0,10).c_str(), n);\n+    return boost::str(boost::format(\"COutPoint(%s, %u)\") % hash.ToString().substr(0,10) % n);\n }\n \n void COutPoint::print() const\n {\n-    LogPrintf(\"%s\\n\", ToString().c_str());\n+    Log() << ToString() << \"\\n\";\n }\n \n CTxIn::CTxIn(COutPoint prevoutIn, CScript scriptSigIn, unsigned int nSequenceIn)\n@@ -33,22 +40,21 @@ CTxIn::CTxIn(uint256 hashPrevTx, unsigned int nOut, CScript scriptSigIn, unsigne\n \n std::string CTxIn::ToString() const\n {\n-    std::string str;\n-    str += \"CTxIn(\";\n-    str += prevout.ToString();\n+    std::ostringstream oss;\n+    oss << \"CTxIn(\" <<  prevout.ToString();\n     if (prevout.IsNull())\n-        str += strprintf(\", coinbase %s\", HexStr(scriptSig).c_str());\n+        oss << \", coinbase \" << HexStr(scriptSig);\n     else\n-        str += strprintf(\", scriptSig=%s\", scriptSig.ToString().substr(0,24).c_str());\n+        oss << \", scriptSig=\" << scriptSig.ToString().substr(0,24);\n     if (nSequence != std::numeric_limits<unsigned int>::max())\n-        str += strprintf(\", nSequence=%u\", nSequence);\n-    str += \")\";\n-    return str;\n+        oss << \", nSequence=\" << nSequence;\n+    oss << \")\";\n+    return oss.str();\n }\n \n void CTxIn::print() const\n {\n-    LogPrintf(\"%s\\n\", ToString().c_str());\n+    Log() << ToString() << \"\\n\";\n }\n \n CTxOut::CTxOut(int64_t nValueIn, CScript scriptPubKeyIn)\n@@ -64,12 +70,12 @@ uint256 CTxOut::GetHash() const\n \n std::string CTxOut::ToString() const\n {\n-    return strprintf(\"CTxOut(nValue=%\"PRId64\".%08\"PRId64\", scriptPubKey=%s)\", nValue / COIN, nValue % COIN, scriptPubKey.ToString().substr(0,30).c_str());\n+    return boost::str(boost::format(\"CTxOut(nValue=%d.%08d, scriptPubKey=%s)\") % (nValue / COIN) % (nValue % COIN) % scriptPubKey.ToString().substr(0,30));\n }\n \n void CTxOut::print() const\n {\n-    LogPrintf(\"%s\\n\", ToString().c_str());\n+    Log() << ToString() << \"\\n\";\n }\n \n uint256 CTransaction::GetHash() const\n@@ -139,23 +145,18 @@ double CTransaction::ComputePriority(double dPriorityInputs, unsigned int nTxSiz\n \n std::string CTransaction::ToString() const\n {\n-    std::string str;\n-    str += strprintf(\"CTransaction(hash=%s, ver=%d, vin.size=%\"PRIszu\", vout.size=%\"PRIszu\", nLockTime=%u)\\n\",\n-        GetHash().ToString().substr(0,10).c_str(),\n-        nVersion,\n-        vin.size(),\n-        vout.size(),\n-        nLockTime);\n+    std::ostringstream oss;\n+    oss << boost::format(\"CTransaction(hash=%s, ver=%d, vin.size=%u, vout.size=%u, nLockTime=%u)\\n\") % GetHash().ToString().substr(0,10) % nVersion % vin.size() % vout.size() % nLockTime;\n     for (unsigned int i = 0; i < vin.size(); i++)\n-        str += \"    \" + vin[i].ToString() + \"\\n\";\n+        oss << \"    \" << vin[i].ToString() << \"\\n\";\n     for (unsigned int i = 0; i < vout.size(); i++)\n-        str += \"    \" + vout[i].ToString() + \"\\n\";\n-    return str;\n+        oss << \"    \" << vout[i].ToString() << \"\\n\";\n+    return oss.str();\n }\n \n void CTransaction::print() const\n {\n-    LogPrintf(\"%s\", ToString().c_str());\n+    Log() << ToString();\n }\n \n // Amount compression:\n@@ -269,20 +270,23 @@ uint256 CBlock::CheckMerkleBranch(uint256 hash, const std::vector<uint256>& vMer\n \n void CBlock::print() const\n {\n-    LogPrintf(\"CBlock(hash=%s, ver=%d, hashPrevBlock=%s, hashMerkleRoot=%s, nTime=%u, nBits=%08x, nNonce=%u, vtx=%\"PRIszu\")\\n\",\n-        GetHash().ToString().c_str(),\n-        nVersion,\n-        hashPrevBlock.ToString().c_str(),\n-        hashMerkleRoot.ToString().c_str(),\n-        nTime, nBits, nNonce,\n-        vtx.size());\n+    Log() << \"CBlock(hash=\" << GetHash().ToString() \n+          << \", ver=\" << nVersion \n+          << \", hashPrevBlock=\" << hashPrevBlock.ToString()\n+          << \", hashMerkleRoot=\" << hashMerkleRoot.ToString() \n+          << \", nTime=\" << nTime \n+          << \", nBits=\" << boost::format(\"%08x\") % nBits\n+          << \", nNonce=\" << nNonce \n+          << \", vtx=\" << vtx.size() \n+          << \")\\n\";\n+    \n     for (unsigned int i = 0; i < vtx.size(); i++)\n     {\n-        LogPrintf(\"  \");\n+        Log() << \"  \";\n         vtx[i].print();\n     }\n-    LogPrintf(\"  vMerkleTree: \");\n+    Log() << \"  vMerkleTree: \";\n     for (unsigned int i = 0; i < vMerkleTree.size(); i++)\n-        LogPrintf(\"%s \", vMerkleTree[i].ToString().c_str());\n-    LogPrintf(\"\\n\");\n+        Log() << vMerkleTree[i].ToString() << \" \";\n+    Log() << \"\\n\";\n }"
      },
      {
        "sha": "a50fc6ac1743ba5f25de1840a22facd37ed271cc",
        "filename": "src/core.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/core.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/core.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core.h?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -11,6 +11,7 @@\n #include \"uint256.h\"\n \n #include <stdint.h>\n+#include <string>\n \n class CTransaction;\n "
      },
      {
        "sha": "8a3de31744932bf963c5cbb81c83eb63958b0c65",
        "filename": "src/db.cpp",
        "status": "modified",
        "additions": 56,
        "deletions": 30,
        "changes": 86,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -6,18 +6,21 @@\n #include \"db.h\"\n \n #include \"addrman.h\"\n+#include \"bitcointime.h\"\n #include \"hash.h\"\n+#include \"log.h\"\n #include \"protocol.h\"\n #include \"util.h\"\n \n-#include <inttypes.h>\n+#include <iomanip>\n #include <stdint.h>\n \n #ifndef WIN32\n #include <sys/stat.h>\n #endif\n \n #include <boost/filesystem.hpp>\n+#include <boost/format.hpp>\n #include <boost/version.hpp>\n #include <openssl/rand.h>\n \n@@ -43,7 +46,7 @@ void CDBEnv::EnvShutdown()\n     fDbEnvInit = false;\n     int ret = dbenv.close(0);\n     if (ret != 0)\n-        LogPrintf(\"EnvShutdown exception: %s (%d)\\n\", DbEnv::strerror(ret), ret);\n+        Log() << \"EnvShutdown exception: \" << DbEnv::strerror(ret) << \" (\" << ret << \")\\n\";\n     if (!fMockDb)\n         DbEnv(0).remove(path.string().c_str(), 0);\n }\n@@ -75,7 +78,7 @@ bool CDBEnv::Open(const boost::filesystem::path& pathIn)\n     filesystem::path pathLogDir = path / \"database\";\n     filesystem::create_directory(pathLogDir);\n     filesystem::path pathErrorFile = path / \"db.log\";\n-    LogPrintf(\"dbenv.open LogDir=%s ErrorFile=%s\\n\", pathLogDir.string().c_str(), pathErrorFile.string().c_str());\n+    Log() << \"dbenv.open LogDir=\" << pathLogDir.string() << \" ErrorFile=\" << pathErrorFile.string() << \"\\n\";\n \n     unsigned int nEnvFlags = 0;\n     if (GetBoolArg(\"-privdb\", true))\n@@ -102,7 +105,10 @@ bool CDBEnv::Open(const boost::filesystem::path& pathIn)\n                      nEnvFlags,\n                      S_IRUSR | S_IWUSR);\n     if (ret != 0)\n-        return error(\"CDB() : error %s (%d) opening database environment\", DbEnv::strerror(ret), ret);\n+    {\n+        Log() << \"ERROR: CDB() : error \" << DbEnv::strerror(ret) << \" (\" << ret << \") opening database environment\\n\";\n+        return false;\n+    }\n \n     fDbEnvInit = true;\n     fMockDb = false;\n@@ -116,7 +122,7 @@ void CDBEnv::MakeMock()\n \n     boost::this_thread::interruption_point();\n \n-    LogPrint(\"db\", \"CDBEnv::MakeMock()\\n\");\n+    Log(\"db\") << \"CDBEnv::MakeMock()\\n\";\n \n     dbenv.set_cachesize(1, 0, 1);\n     dbenv.set_lg_bsize(10485760*4);\n@@ -135,7 +141,7 @@ void CDBEnv::MakeMock()\n                      DB_PRIVATE,\n                      S_IRUSR | S_IWUSR);\n     if (ret > 0)\n-        throw runtime_error(strprintf(\"CDBEnv::MakeMock(): error %d opening database environment\", ret));\n+        throw runtime_error(boost::str(boost::format(\"CDBEnv::MakeMock(): error %d opening database environment\") % ret));\n \n     fDbEnvInit = true;\n     fMockDb = true;\n@@ -173,16 +179,16 @@ bool CDBEnv::Salvage(std::string strFile, bool fAggressive,\n     int result = db.verify(strFile.c_str(), NULL, &strDump, flags);\n     if (result == DB_VERIFY_BAD)\n     {\n-        LogPrintf(\"Error: Salvage found errors, all data may not be recoverable.\\n\");\n+        Log() << \"Error: Salvage found errors, all data may not be recoverable.\\n\";\n         if (!fAggressive)\n         {\n-            LogPrintf(\"Error: Rerun with aggressive mode to ignore errors and continue.\\n\");\n+            Log() << \"Error: Rerun with aggressive mode to ignore errors and continue.\\n\";\n             return false;\n         }\n     }\n     if (result != 0 && result != DB_VERIFY_BAD)\n     {\n-        LogPrintf(\"ERROR: db salvage failed: %d\\n\",result);\n+        Log() << \"ERROR: db salvage failed: \" << result << \"\\n\";\n         return false;\n     }\n \n@@ -253,7 +259,7 @@ CDB::CDB(const char *pszFile, const char* pszMode) :\n                 DbMpoolFile*mpf = pdb->get_mpf();\n                 ret = mpf->set_flags(DB_MPOOL_NOFILE, 1);\n                 if (ret != 0)\n-                    throw runtime_error(strprintf(\"CDB() : failed to configure for no temp file backing for database %s\", pszFile));\n+                    throw runtime_error(string(\"CDB() : failed to configure for no temp file backing for database \") + pszFile);\n             }\n \n             ret = pdb->open(NULL,      // Txn pointer\n@@ -269,7 +275,8 @@ CDB::CDB(const char *pszFile, const char* pszMode) :\n                 pdb = NULL;\n                 --bitdb.mapFileUseCount[strFile];\n                 strFile = \"\";\n-                throw runtime_error(strprintf(\"CDB() : can't open database file %s, error %d\", pszFile, ret));\n+\n+                throw runtime_error(boost::str(boost::format(\"CDB() : can't open database file %s, error %d\") % pszFile % ret));\n             }\n \n             if (fCreate && !Exists(string(\"version\")))\n@@ -353,7 +360,7 @@ bool CDB::Rewrite(const string& strFile, const char* pszSkip)\n                 bitdb.mapFileUseCount.erase(strFile);\n \n                 bool fSuccess = true;\n-                LogPrintf(\"Rewriting %s...\\n\", strFile.c_str());\n+                Log() << \"Rewriting \" << strFile << \"...\\n\";\n                 string strFileRes = strFile + \".rewrite\";\n                 { // surround usage of db with extra {}\n                     CDB db(strFile.c_str(), \"r\");\n@@ -367,7 +374,7 @@ bool CDB::Rewrite(const string& strFile, const char* pszSkip)\n                                             0);\n                     if (ret > 0)\n                     {\n-                        LogPrintf(\"Cannot create database file %s\\n\", strFileRes.c_str());\n+                        Log() << \"Cannot create database file \" << strFileRes << \"\\n\";\n                         fSuccess = false;\n                     }\n \n@@ -423,7 +430,7 @@ bool CDB::Rewrite(const string& strFile, const char* pszSkip)\n                         fSuccess = false;\n                 }\n                 if (!fSuccess)\n-                    LogPrintf(\"Rewriting of %s FAILED!\\n\", strFileRes.c_str());\n+                    Log() << \"Rewriting of \" << strFileRes << \" FAILED!\\n\";\n                 return fSuccess;\n             }\n         }\n@@ -435,10 +442,10 @@ bool CDB::Rewrite(const string& strFile, const char* pszSkip)\n \n void CDBEnv::Flush(bool fShutdown)\n {\n-    int64_t nStart = GetTimeMillis();\n+    int64_t nStart = BitcoinTime::GetTimeMillis();\n     // Flush log data to the actual data file\n     //  on all files that are not in use\n-    LogPrint(\"db\", \"Flush(%s)%s\\n\", fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" db not started\");\n+    Log(\"db\") << \"Flush(\" << (fShutdown ? \"true\" : \"false\") << \")\" << (fDbEnvInit ? \"\" : \" db not started\") << \"\\n\";\n     if (!fDbEnvInit)\n         return;\n     {\n@@ -448,23 +455,23 @@ void CDBEnv::Flush(bool fShutdown)\n         {\n             string strFile = (*mi).first;\n             int nRefCount = (*mi).second;\n-            LogPrint(\"db\", \"%s refcount=%d\\n\", strFile.c_str(), nRefCount);\n+            Log(\"db\") << strFile << \" refcount=\" << nRefCount << \"\\n\";\n             if (nRefCount == 0)\n             {\n                 // Move log data to the dat file\n                 CloseDb(strFile);\n-                LogPrint(\"db\", \"%s checkpoint\\n\", strFile.c_str());\n+                Log(\"db\") << strFile << \" checkpoint\\n\";\n                 dbenv.txn_checkpoint(0, 0, 0);\n-                LogPrint(\"db\", \"%s detach\\n\", strFile.c_str());\n+                Log(\"db\") << strFile << \" detach\\n\";\n                 if (!fMockDb)\n                     dbenv.lsn_reset(strFile.c_str(), 0);\n-                LogPrint(\"db\", \"%s closed\\n\", strFile.c_str());\n+                Log(\"db\") << strFile << \" closed\\n\";\n                 mapFileUseCount.erase(mi++);\n             }\n             else\n                 mi++;\n         }\n-        LogPrint(\"db\", \"DBFlush(%s)%s ended %15\"PRId64\"ms\\n\", fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" db not started\", GetTimeMillis() - nStart);\n+        Log(\"db\") << \"DBFlush(\" << (fShutdown ? \"true\" : \"false\") << \")\" << (fDbEnvInit ? \"\" : \" db not started\") << \" ended \" << std::setw(15) << (BitcoinTime::GetTimeMillis() - nStart) << \"ms\\n\";\n         if (fShutdown)\n         {\n             char** listp;\n@@ -503,7 +510,8 @@ bool CAddrDB::Write(const CAddrMan& addr)\n     // Generate random temporary filename\n     unsigned short randv = 0;\n     RAND_bytes((unsigned char *)&randv, sizeof(randv));\n-    std::string tmpfn = strprintf(\"peers.dat.%04x\", randv);\n+\n+    std::string tmpfn = boost::str(boost::format(\"peers.dat.%04x\") % randv);\n \n     // serialize addresses, checksum data up to that point, then append csum\n     CDataStream ssPeers(SER_DISK, CLIENT_VERSION);\n@@ -517,21 +525,28 @@ bool CAddrDB::Write(const CAddrMan& addr)\n     FILE *file = fopen(pathTmp.string().c_str(), \"wb\");\n     CAutoFile fileout = CAutoFile(file, SER_DISK, CLIENT_VERSION);\n     if (!fileout)\n-        return error(\"CAddrman::Write() : open failed\");\n+    {\n+        Log() << \"ERROR: CAddrman::Write() : open failed\\n\";\n+        return false;\n+    }\n \n     // Write and commit header, data\n     try {\n         fileout << ssPeers;\n     }\n     catch (std::exception &e) {\n-        return error(\"CAddrman::Write() : I/O error\");\n+        Log() << \"ERROR: CAddrman::Write() : I/O error\\n\";\n+        return false;\n     }\n     FileCommit(fileout);\n     fileout.fclose();\n \n     // replace existing peers.dat, if any, with new peers.dat.XXXX\n     if (!RenameOver(pathTmp, pathAddr))\n-        return error(\"CAddrman::Write() : Rename-into-place failed\");\n+    {\n+        Log() << \"ERROR: CAddrman::Write() : Rename-into-place failed\\n\";\n+        return false;\n+    }\n \n     return true;\n }\n@@ -542,7 +557,10 @@ bool CAddrDB::Read(CAddrMan& addr)\n     FILE *file = fopen(pathAddr.string().c_str(), \"rb\");\n     CAutoFile filein = CAutoFile(file, SER_DISK, CLIENT_VERSION);\n     if (!filein)\n-        return error(\"CAddrman::Read() : open failed\");\n+    {\n+        Log() << \"ERROR: CAddrman::Read() : open failed\\n\";\n+        return false;\n+    }\n \n     // use file size to size memory buffer\n     int fileSize = GetFilesize(filein);\n@@ -559,7 +577,8 @@ bool CAddrDB::Read(CAddrMan& addr)\n         filein >> hashIn;\n     }\n     catch (std::exception &e) {\n-        return error(\"CAddrman::Read() 2 : I/O error or stream data corrupted\");\n+        Log() << \"ERROR: CAddrman::Read() 2 : I/O error or stream data corrupted\\n\";\n+        return false;\n     }\n     filein.fclose();\n \n@@ -568,7 +587,10 @@ bool CAddrDB::Read(CAddrMan& addr)\n     // verify stored checksum matches input data\n     uint256 hashTmp = Hash(ssPeers.begin(), ssPeers.end());\n     if (hashIn != hashTmp)\n-        return error(\"CAddrman::Read() : checksum mismatch; data corrupted\");\n+    {\n+        Log() << \"ERROR: CAddrman::Read() : checksum mismatch; data corrupted\\n\";\n+        return false;\n+    }\n \n     unsigned char pchMsgTmp[4];\n     try {\n@@ -577,13 +599,17 @@ bool CAddrDB::Read(CAddrMan& addr)\n \n         // ... verify the network matches ours\n         if (memcmp(pchMsgTmp, Params().MessageStart(), sizeof(pchMsgTmp)))\n-            return error(\"CAddrman::Read() : invalid network magic number\");\n+        {\n+            Log() << \"ERROR: CAddrman::Read() : invalid network magic number\\n\";\n+            return false;\n+        }\n \n         // de-serialize address data into one CAddrMan object\n         ssPeers >> addr;\n     }\n     catch (std::exception &e) {\n-        return error(\"CAddrman::Read() : I/O error or stream data corrupted\");\n+        Log() << \"ERROR: CAddrman::Read() : I/O error or stream data corrupted\\n\";\n+        return false;\n     }\n \n     return true;"
      },
      {
        "sha": "db5e3e0a25ced4c4e95f27c80a33f383eef892b8",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 198,
        "deletions": 195,
        "changes": 393,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -10,17 +10,21 @@\n #include \"init.h\"\n \n #include \"addrman.h\"\n-#include \"rpcserver.h\"\n+#include \"bitcointime.h\"\n #include \"checkpoints.h\"\n+#include \"log.h\"\n #include \"miner.h\"\n #include \"net.h\"\n+#include \"rpcserver.h\"\n #include \"txdb.h\"\n #include \"ui_interface.h\"\n #include \"util.h\"\n #include \"wallet.h\"\n #include \"walletdb.h\"\n \n-#include <inttypes.h>\n+#include <iomanip>\n+#include <iostream>\n+#include <sstream>\n #include <stdint.h>\n \n #ifndef WIN32\n@@ -35,7 +39,7 @@\n using namespace std;\n using namespace boost;\n \n-std::string strWalletFile;\n+string strWalletFile;\n CWallet* pwalletMain;\n \n #ifdef WIN32\n@@ -100,7 +104,7 @@ static CCoinsViewDB *pcoinsdbview;\n \n void Shutdown()\n {\n-    LogPrintf(\"Shutdown : In progress...\\n\");\n+    Log() << \"Shutdown : In progress...\\n\";\n     static CCriticalSection cs_Shutdown;\n     TRY_LOCK(cs_Shutdown, lockShutdown);\n     if (!lockShutdown) return;\n@@ -131,7 +135,7 @@ void Shutdown()\n     UnregisterAllWallets();\n     if (pwalletMain)\n         delete pwalletMain;\n-    LogPrintf(\"Shutdown : done\\n\");\n+    Log() << \"Shutdown : done\\n\";\n }\n \n //\n@@ -144,16 +148,16 @@ void HandleSIGTERM(int)\n \n void HandleSIGHUP(int)\n {\n-    fReopenDebugLog = true;\n+    Log::fReopenDebugLog = true;\n }\n \n-bool static InitError(const std::string &str)\n+bool static InitError(const string &str)\n {\n     uiInterface.ThreadSafeMessageBox(str, \"\", CClientUIInterface::MSG_ERROR);\n     return false;\n }\n \n-bool static InitWarning(const std::string &str)\n+bool static InitWarning(const string &str)\n {\n     uiInterface.ThreadSafeMessageBox(str, \"\", CClientUIInterface::MSG_WARNING);\n     return true;\n@@ -162,7 +166,7 @@ bool static InitWarning(const std::string &str)\n bool static Bind(const CService &addr, unsigned int flags) {\n     if (!(flags & BF_EXPLICIT) && IsLimited(addr))\n         return false;\n-    std::string strError;\n+    string strError;\n     if (!BindListenPort(addr, strError)) {\n         if (flags & BF_REPORT_ERROR)\n             return InitError(strError);\n@@ -172,112 +176,113 @@ bool static Bind(const CService &addr, unsigned int flags) {\n }\n \n // Core-specific options shared between UI, daemon and RPC client\n-std::string HelpMessage(HelpMessageMode hmm)\n+string HelpMessage(HelpMessageMode hmm)\n {\n-    string strUsage = _(\"Options:\") + \"\\n\";\n-    strUsage += \"  -?                     \" + _(\"This help message\") + \"\\n\";\n-    strUsage += \"  -conf=<file>           \" + _(\"Specify configuration file (default: bitcoin.conf)\") + \"\\n\";\n-    strUsage += \"  -datadir=<dir>         \" + _(\"Specify data directory\") + \"\\n\";\n-    strUsage += \"  -testnet               \" + _(\"Use the test network\") + \"\\n\";\n-\n-    strUsage += \"  -pid=<file>            \" + _(\"Specify pid file (default: bitcoind.pid)\") + \"\\n\";\n-    strUsage += \"  -gen                   \" + _(\"Generate coins (default: 0)\") + \"\\n\";\n-    strUsage += \"  -wallet=<file>         \" + _(\"Specify wallet file (within data directory)\") + \"\\n\";\n-    strUsage += \"  -dbcache=<n>           \" + _(\"Set database cache size in megabytes (default: 25)\") + \"\\n\";\n-    strUsage += \"  -timeout=<n>           \" + _(\"Specify connection timeout in milliseconds (default: 5000)\") + \"\\n\";\n-    strUsage += \"  -proxy=<ip:port>       \" + _(\"Connect through socks proxy\") + \"\\n\";\n-    strUsage += \"  -socks=<n>             \" + _(\"Select the version of socks proxy to use (4-5, default: 5)\") + \"\\n\";\n-    strUsage += \"  -onion=<ip:port>         \" + _(\"Use proxy to reach tor hidden services (default: same as -proxy)\") + \"\\n\";\n-    strUsage += \"  -dns                   \" + _(\"Allow DNS lookups for -addnode, -seednode and -connect\") + \"\\n\";\n-    strUsage += \"  -port=<port>           \" + _(\"Listen for connections on <port> (default: 8333 or testnet: 18333)\") + \"\\n\";\n-    strUsage += \"  -maxconnections=<n>    \" + _(\"Maintain at most <n> connections to peers (default: 125)\") + \"\\n\";\n-    strUsage += \"  -addnode=<ip>          \" + _(\"Add a node to connect to and attempt to keep the connection open\") + \"\\n\";\n-    strUsage += \"  -connect=<ip>          \" + _(\"Connect only to the specified node(s)\") + \"\\n\";\n-    strUsage += \"  -seednode=<ip>         \" + _(\"Connect to a node to retrieve peer addresses, and disconnect\") + \"\\n\";\n-    strUsage += \"  -externalip=<ip>       \" + _(\"Specify your own public address\") + \"\\n\";\n-    strUsage += \"  -onlynet=<net>         \" + _(\"Only connect to nodes in network <net> (IPv4, IPv6 or Tor)\") + \"\\n\";\n-    strUsage += \"  -discover              \" + _(\"Discover own IP address (default: 1 when listening and no -externalip)\") + \"\\n\";\n-    strUsage += \"  -checkpoints           \" + _(\"Only accept block chain matching built-in checkpoints (default: 1)\") + \"\\n\";\n-    strUsage += \"  -listen                \" + _(\"Accept connections from outside (default: 1 if no -proxy or -connect)\") + \"\\n\";\n-    strUsage += \"  -bind=<addr>           \" + _(\"Bind to given address and always listen on it. Use [host]:port notation for IPv6\") + \"\\n\";\n-    strUsage += \"  -dnsseed               \" + _(\"Find peers using DNS lookup (default: 1 unless -connect)\") + \"\\n\";\n-    strUsage += \"  -banscore=<n>          \" + _(\"Threshold for disconnecting misbehaving peers (default: 100)\") + \"\\n\";\n-    strUsage += \"  -bantime=<n>           \" + _(\"Number of seconds to keep misbehaving peers from reconnecting (default: 86400)\") + \"\\n\";\n-    strUsage += \"  -maxreceivebuffer=<n>  \" + _(\"Maximum per-connection receive buffer, <n>*1000 bytes (default: 5000)\") + \"\\n\";\n-    strUsage += \"  -maxsendbuffer=<n>     \" + _(\"Maximum per-connection send buffer, <n>*1000 bytes (default: 1000)\") + \"\\n\";\n+    ostringstream ossUsage;\n+    ossUsage <<  _<string>(\"Options:\") << \"\\n\"\n+             << \"  -?                     \" << _<string>(\"This help message\") << \"\\n\"\n+             << \"  -conf=<file>           \" << _<string>(\"Specify configuration file (default: bitcoin.conf)\") << \"\\n\"\n+             << \"  -datadir=<dir>         \" << _<string>(\"Specify data directory\") << \"\\n\"\n+             << \"  -testnet               \" << _<string>(\"Use the test network\") << \"\\n\"\n+             << \"  -pid=<file>            \" << _<string>(\"Specify pid file (default: bitcoind.pid)\") << \"\\n\"\n+             << \"  -gen                   \" << _<string>(\"Generate coins (default: 0)\") << \"\\n\"\n+             << \"  -wallet=<file>         \" << _<string>(\"Specify wallet file (within data directory)\") << \"\\n\"\n+             << \"  -dbcache=<n>           \" << _<string>(\"Set database cache size in megabytes (default: 25)\") << \"\\n\"\n+             << \"  -timeout=<n>           \" << _<string>(\"Specify connection timeout in milliseconds (default: 5000)\") << \"\\n\"\n+             << \"  -proxy=<ip:port>       \" << _<string>(\"Connect through socks proxy\") << \"\\n\"\n+             << \"  -socks=<n>             \" << _<string>(\"Select the version of socks proxy to use (4-5, default: 5)\") << \"\\n\"\n+             << \"  -onion=<ip:port>       \" << _<string>(\"Use proxy to reach tor hidden services (default: same as -proxy)\") << \"\\n\"\n+             << \"  -dns                   \" << _<string>(\"Allow DNS lookups for -addnode, -seednode and -connect\") << \"\\n\"\n+             << \"  -port=<port>           \" << _<string>(\"Listen for connections on <port> (default: 8333 or testnet: 18333)\") << \"\\n\"\n+             << \"  -maxconnections=<n>    \" << _<string>(\"Maintain at most <n> connections to peers (default: 125)\") << \"\\n\"\n+             << \"  -addnode=<ip>          \" << _<string>(\"Add a node to connect to and attempt to keep the connection open\") << \"\\n\"\n+             << \"  -connect=<ip>          \" << _<string>(\"Connect only to the specified node(s)\") << \"\\n\"\n+             << \"  -seednode=<ip>         \" << _<string>(\"Connect to a node to retrieve peer addresses, and disconnect\") << \"\\n\"\n+             << \"  -externalip=<ip>       \" << _<string>(\"Specify your own public address\") << \"\\n\"\n+             << \"  -onlynet=<net>         \" << _<string>(\"Only connect to nodes in network <net> (IPv4, IPv6 or Tor)\") << \"\\n\"\n+             << \"  -discover              \" << _<string>(\"Discover own IP address (default: 1 when listening and no -externalip)\") << \"\\n\"\n+             << \"  -checkpoints           \" << _<string>(\"Only accept block chain matching built-in checkpoints (default: 1)\") << \"\\n\"\n+             << \"  -listen                \" << _<string>(\"Accept connections from outside (default: 1 if no -proxy or -connect)\") << \"\\n\"\n+             << \"  -bind=<addr>           \" << _<string>(\"Bind to given address and always listen on it. Use [host]:port notation for IPv6\") << \"\\n\"\n+             << \"  -dnsseed               \" << _<string>(\"Find peers using DNS lookup (default: 1 unless -connect)\") << \"\\n\"\n+             << \"  -banscore=<n>          \" << _<string>(\"Threshold for disconnecting misbehaving peers (default: 100)\") << \"\\n\"\n+             << \"  -bantime=<n>           \" << _<string>(\"Number of seconds to keep misbehaving peers from reconnecting (default: 86400)\") << \"\\n\"\n+             << \"  -maxreceivebuffer=<n>  \" << _<string>(\"Maximum per-connection receive buffer, <n>*1000 bytes (default: 5000)\") << \"\\n\"\n+             << \"  -maxsendbuffer=<n>     \" << _<string>(\"Maximum per-connection send buffer, <n>*1000 bytes (default: 1000)\") << \"\\n\";\n #ifdef USE_UPNP\n #if USE_UPNP\n-    strUsage += \"  -upnp                  \" + _(\"Use UPnP to map the listening port (default: 1 when listening)\") + \"\\n\";\n+    ossUsage << \"  -upnp                  \" << _<string>(\"Use UPnP to map the listening port (default: 1 when listening)\") << \"\\n\";\n #else\n-    strUsage += \"  -upnp                  \" + _(\"Use UPnP to map the listening port (default: 0)\") + \"\\n\";\n+    ossUsage << \"  -upnp                  \" << _<string>(\"Use UPnP to map the listening port (default: 0)\") << \"\\n\";\n #endif\n #endif\n-    strUsage += \"  -paytxfee=<amt>        \" + _(\"Fee per KB to add to transactions you send\") + \"\\n\";\n-    strUsage += \"  -debug=<category>      \" + _(\"Output debugging information (default: 0, supplying <category> is optional)\") + \"\\n\";\n-    strUsage +=                               _(\"If <category> is not supplied, output all debugging information.\") + \"\\n\";\n-    strUsage +=                               _(\"<category> can be:\");\n-    strUsage +=                                 \" addrman, alert, coindb, db, lock, rand, rpc, selectcoins, mempool, net\"; // Don't translate these and qt below\n+    ossUsage << \"  -paytxfee=<amt>        \" << _<string>(\"Fee per KB to add to transactions you send\") << \"\\n\"\n+             << \"  -debug=<category>      \" << _<string>(\"Output debugging information (default: 0, supplying <category> is optional)\") << \"\\n\"\n+             <<                                _<string>(\"If <category> is not supplied, output all debugging information.\") << \"\\n\"\n+             <<                                _<string>(\"<category> can be:\")\n+             <<                                          \" addrman, alert, coindb, db, lock, rand, rpc, selectcoins, mempool, net\"; // Don't translate these and qt below\n     if (hmm == HMM_BITCOIN_QT)\n     {\n-        strUsage += \", qt.\\n\";\n+        ossUsage << \", qt.\\n\";\n     }\n     else\n     {\n-        strUsage += \".\\n\";\n+        ossUsage << \".\\n\";\n     }\n-    strUsage += \"  -logtimestamps         \" + _(\"Prepend debug output with timestamp (default: 1)\") + \"\\n\";\n-    strUsage += \"  -shrinkdebugfile       \" + _(\"Shrink debug.log file on client startup (default: 1 when no -debug)\") + \"\\n\";\n-    strUsage += \"  -printtoconsole        \" + _(\"Send trace/debug info to console instead of debug.log file\") + \"\\n\";\n-    strUsage += \"  -regtest               \" + _(\"Enter regression test mode, which uses a special chain in which blocks can be \"\n-                                            \"solved instantly. This is intended for regression testing tools and app development.\") + \"\\n\";\n+    ossUsage << \"  -logtimestamps         \" << _<string>(\"Prepend debug output with timestamp (default: 1)\") << \"\\n\"\n+             << \"  -shrinkdebugfile       \" << _<string>(\"Shrink debug.log file on client startup (default: 1 when no -debug)\") << \"\\n\"\n+             << \"  -printtoconsole        \" << _<string>(\"Send trace/debug info to console instead of debug.log file\") << \"\\n\"\n+             << \"  -regtest               \" << _<string>(\"Enter regression test mode, which uses a special chain in which blocks can be \"\n+                                                         \"solved instantly. This is intended for regression testing tools and app development.\") << \"\\n\";\n #ifdef WIN32\n-    strUsage += \"  -printtodebugger       \" + _(\"Send trace/debug info to debugger\") + \"\\n\";\n+    ossUsage << \"  -printtodebugger       \" << _<string>(\"Send trace/debug info to debugger\") << \"\\n\";\n #endif\n \n     if (hmm == HMM_BITCOIN_QT)\n     {\n-        strUsage += \"  -server                \" + _(\"Accept command line and JSON-RPC commands\") + \"\\n\";\n+        ossUsage << \"  -server                \" << _<string>(\"Accept command line and JSON-RPC commands\") << \"\\n\";\n     }\n \n     if (hmm == HMM_BITCOIND)\n     {\n #if !defined(WIN32)\n-        strUsage += \"  -daemon                \" + _(\"Run in the background as a daemon and accept commands\") + \"\\n\";\n+        ossUsage << \"  -daemon                \" << _<string>(\"Run in the background as a daemon and accept commands\") << \"\\n\";\n #endif\n     }\n \n-    strUsage += \"  -rpcuser=<user>        \" + _(\"Username for JSON-RPC connections\") + \"\\n\";\n-    strUsage += \"  -rpcpassword=<pw>      \" + _(\"Password for JSON-RPC connections\") + \"\\n\";\n-    strUsage += \"  -rpcport=<port>        \" + _(\"Listen for JSON-RPC connections on <port> (default: 8332 or testnet: 18332)\") + \"\\n\";\n-\n-    strUsage += \"  -rpcallowip=<ip>       \" + _(\"Allow JSON-RPC connections from specified IP address\") + \"\\n\";\n-    strUsage += \"  -rpcthreads=<n>        \" + _(\"Set the number of threads to service RPC calls (default: 4)\") + \"\\n\";\n-    strUsage += \"  -blocknotify=<cmd>     \" + _(\"Execute command when the best block changes (%s in cmd is replaced by block hash)\") + \"\\n\";\n-    strUsage += \"  -walletnotify=<cmd>    \" + _(\"Execute command when a wallet transaction changes (%s in cmd is replaced by TxID)\") + \"\\n\";\n-    strUsage += \"  -alertnotify=<cmd>     \" + _(\"Execute command when a relevant alert is received or we see a really long fork (%s in cmd is replaced by message)\") + \"\\n\";\n-    strUsage += \"  -upgradewallet         \" + _(\"Upgrade wallet to latest format\") + \"\\n\";\n-    strUsage += \"  -keypool=<n>           \" + _(\"Set key pool size to <n> (default: 100)\") + \"\\n\";\n-    strUsage += \"  -rescan                \" + _(\"Rescan the block chain for missing wallet transactions\") + \"\\n\";\n-    strUsage += \"  -salvagewallet         \" + _(\"Attempt to recover private keys from a corrupt wallet.dat\") + \"\\n\";\n-    strUsage += \"  -checkblocks=<n>       \" + _(\"How many blocks to check at startup (default: 288, 0 = all)\") + \"\\n\";\n-    strUsage += \"  -checklevel=<n>        \" + _(\"How thorough the block verification is (0-4, default: 3)\") + \"\\n\";\n-    strUsage += \"  -txindex               \" + _(\"Maintain a full transaction index (default: 0)\") + \"\\n\";\n-    strUsage += \"  -loadblock=<file>      \" + _(\"Imports blocks from external blk000??.dat file\") + \"\\n\";\n-    strUsage += \"  -reindex               \" + _(\"Rebuild block chain index from current blk000??.dat files\") + \"\\n\";\n-    strUsage += \"  -par=<n>               \" + _(\"Set the number of script verification threads (up to 16, 0 = auto, <0 = leave that many cores free, default: 0)\") + \"\\n\";\n-\n-    strUsage += \"\\n\" + _(\"Block creation options:\") + \"\\n\";\n-    strUsage += \"  -blockminsize=<n>      \"   + _(\"Set minimum block size in bytes (default: 0)\") + \"\\n\";\n-    strUsage += \"  -blockmaxsize=<n>      \"   + _(\"Set maximum block size in bytes (default: 250000)\") + \"\\n\";\n-    strUsage += \"  -blockprioritysize=<n> \"   + _(\"Set maximum size of high-priority/low-fee transactions in bytes (default: 27000)\") + \"\\n\";\n-\n-    strUsage += \"\\n\" + _(\"SSL options: (see the Bitcoin Wiki for SSL setup instructions)\") + \"\\n\";\n-    strUsage += \"  -rpcssl                                  \" + _(\"Use OpenSSL (https) for JSON-RPC connections\") + \"\\n\";\n-    strUsage += \"  -rpcsslcertificatechainfile=<file.cert>  \" + _(\"Server certificate file (default: server.cert)\") + \"\\n\";\n-    strUsage += \"  -rpcsslprivatekeyfile=<file.pem>         \" + _(\"Server private key (default: server.pem)\") + \"\\n\";\n-    strUsage += \"  -rpcsslciphers=<ciphers>                 \" + _(\"Acceptable ciphers (default: TLSv1.2+HIGH:TLSv1+HIGH:!SSLv2:!aNULL:!eNULL:!3DES:@STRENGTH)\") + \"\\n\";\n-\n-    return strUsage;\n+    ossUsage << \"  -rpcuser=<user>        \" << _<string>(\"Username for JSON-RPC connections\") << \"\\n\"\n+             << \"  -rpcpassword=<pw>      \" << _<string>(\"Password for JSON-RPC connections\") << \"\\n\"\n+             << \"  -rpcport=<port>        \" << _<string>(\"Listen for JSON-RPC connections on <port> (default: 8332 or testnet: 18332)\") << \"\\n\"\n+             << \"  -rpcallowip=<ip>       \" << _<string>(\"Allow JSON-RPC connections from specified IP address\") << \"\\n\"\n+             << \"  -rpcthreads=<n>        \" << _<string>(\"Set the number of threads to service RPC calls (default: 4)\") << \"\\n\"\n+             << \"  -blocknotify=<cmd>     \" << _<string>(\"Execute command when the best block changes (%s in cmd is replaced by block hash)\") << \"\\n\"\n+             << \"  -walletnotify=<cmd>    \" << _<string>(\"Execute command when a wallet transaction changes (%s in cmd is replaced by TxID)\") << \"\\n\"\n+             << \"  -alertnotify=<cmd>     \" << _<string>(\"Execute command when a relevant alert is received or we see a really long fork (%s in cmd is replaced by message)\") << \"\\n\"\n+             << \"  -upgradewallet         \" << _<string>(\"Upgrade wallet to latest format\") << \"\\n\"\n+             << \"  -keypool=<n>           \" << _<string>(\"Set key pool size to <n> (default: 100)\") << \"\\n\"\n+             << \"  -rescan                \" << _<string>(\"Rescan the block chain for missing wallet transactions\") << \"\\n\"\n+             << \"  -salvagewallet         \" << _<string>(\"Attempt to recover private keys from a corrupt wallet.dat\") << \"\\n\"\n+             << \"  -checkblocks=<n>       \" << _<string>(\"How many blocks to check at startup (default: 288, 0 = all)\") << \"\\n\"\n+             << \"  -checklevel=<n>        \" << _<string>(\"How thorough the block verification is (0-4, default: 3)\") << \"\\n\"\n+             << \"  -txindex               \" << _<string>(\"Maintain a full transaction index (default: 0)\") << \"\\n\"\n+             << \"  -loadblock=<file>      \" << _<string>(\"Imports blocks from external blk000??.dat file\") << \"\\n\"\n+             << \"  -reindex               \" << _<string>(\"Rebuild block chain index from current blk000??.dat files\") << \"\\n\"\n+             << \"  -par=<n>               \" << _<string>(\"Set the number of script verification threads (up to 16, 0 = auto, <0 = leave that many cores free, default: 0)\") << \"\\n\"\n+             << \"\\n\";\n+\n+    ossUsage << _<string>(\"Block creation options:\") << \"\\n\"\n+             << \"  -blockminsize=<n>      \"   << _<string>(\"Set minimum block size in bytes (default: 0)\") << \"\\n\"\n+             << \"  -blockmaxsize=<n>      \"   << _<string>(\"Set maximum block size in bytes (default: 250000)\") << \"\\n\"\n+             << \"  -blockprioritysize=<n> \"   << _<string>(\"Set maximum size of high-priority/low-fee transactions in bytes (default: 27000)\") << \"\\n\"\n+             << \"\\n\";\n+\n+    ossUsage << _<string>(\"SSL options: (see the Bitcoin Wiki for SSL setup instructions)\") << \"\\n\"\n+             << \"  -rpcssl                                  \" << _<string>(\"Use OpenSSL (https) for JSON-RPC connections\") << \"\\n\"\n+             << \"  -rpcsslcertificatechainfile=<file.cert>  \" << _<string>(\"Server certificate file (default: server.cert)\") << \"\\n\"\n+             << \"  -rpcsslprivatekeyfile=<file.pem>         \" << _<string>(\"Server private key (default: server.pem)\") << \"\\n\"\n+             << \"  -rpcsslciphers=<ciphers>                 \" << _<string>(\"Acceptable ciphers (default: TLSv1.2+HIGH:TLSv1+HIGH:!SSLv2:!aNULL:!eNULL:!3DES:@STRENGTH)\") << \"\\n\";\n+\n+    return ossUsage.str();\n }\n \n struct CImportingNow\n@@ -306,13 +311,13 @@ void ThreadImport(std::vector<boost::filesystem::path> vImportFiles)\n             FILE *file = OpenBlockFile(pos, true);\n             if (!file)\n                 break;\n-            LogPrintf(\"Reindexing block file blk%05u.dat...\\n\", (unsigned int)nFile);\n+            Log() << \"Reindexing block file blk\" << setfill('0') << setw(5) << (unsigned int) nFile << setfill(' ') << \".dat...\\n\";\n             LoadExternalBlockFile(file, &pos);\n             nFile++;\n         }\n         pblocktree->WriteReindexing(false);\n         fReindex = false;\n-        LogPrintf(\"Reindexing finished\\n\");\n+        Log() << \"Reindexing finished\\n\";\n         // To avoid ending up in a situation without genesis block, re-try initializing (no-op if reindexing worked):\n         InitBlockIndex();\n     }\n@@ -324,7 +329,7 @@ void ThreadImport(std::vector<boost::filesystem::path> vImportFiles)\n         if (file) {\n             CImportingNow imp;\n             filesystem::path pathBootstrapOld = GetDataDir() / \"bootstrap.dat.old\";\n-            LogPrintf(\"Importing bootstrap.dat...\\n\");\n+            Log() << \"Importing bootstrap.dat...\\n\";\n             LoadExternalBlockFile(file);\n             RenameOver(pathBootstrap, pathBootstrapOld);\n         }\n@@ -335,7 +340,7 @@ void ThreadImport(std::vector<boost::filesystem::path> vImportFiles)\n         FILE *file = fopen(path.string().c_str(), \"rb\");\n         if (file) {\n             CImportingNow imp;\n-            LogPrintf(\"Importing %s...\\n\", path.string().c_str());\n+            Log() << \"Importing \" << path.string() << \"...\\n\";\n             LoadExternalBlockFile(file);\n         }\n     }\n@@ -373,9 +378,7 @@ bool AppInit2(boost::thread_group& threadGroup, bool fForceServer)\n     WSADATA wsadata;\n     int ret = WSAStartup(MAKEWORD(2,2), &wsadata);\n     if (ret != NO_ERROR || LOBYTE(wsadata.wVersion ) != 2 || HIBYTE(wsadata.wVersion) != 2)\n-    {\n-        return InitError(strprintf(\"Error: Winsock library failed to start (WSAStartup returned error %d)\", ret));\n-    }\n+        return InitError(boost::str(boost::format(\"Error: Winsock library failed to start (WSAStartup returned error %d)\") % ret));\n #endif\n #ifndef WIN32\n     umask(077);\n@@ -442,21 +445,21 @@ bool AppInit2(boost::thread_group& threadGroup, bool fForceServer)\n     nMaxConnections = std::max(std::min(nMaxConnections, (int)(FD_SETSIZE - nBind - MIN_CORE_FILEDESCRIPTORS)), 0);\n     int nFD = RaiseFileDescriptorLimit(nMaxConnections + MIN_CORE_FILEDESCRIPTORS);\n     if (nFD < MIN_CORE_FILEDESCRIPTORS)\n-        return InitError(_(\"Not enough file descriptors available.\"));\n+        return InitError(_<string>(\"Not enough file descriptors available.\"));\n     if (nFD - MIN_CORE_FILEDESCRIPTORS < nMaxConnections)\n         nMaxConnections = nFD - MIN_CORE_FILEDESCRIPTORS;\n \n     // ********************************************************* Step 3: parameter-to-internal-flags\n \n-    fDebug = !mapMultiArgs[\"-debug\"].empty();\n+    Log::fDebug = !mapMultiArgs[\"-debug\"].empty();\n     // Special-case: if -debug=0/-nodebug is set, turn off debugging messages\n     const vector<string>& categories = mapMultiArgs[\"-debug\"];\n     if (GetBoolArg(\"-nodebug\", false) || find(categories.begin(), categories.end(), string(\"0\")) != categories.end())\n-        fDebug = false;\n+        Log::fDebug = false;\n \n     // Check for -debugnet (deprecated)\n     if (GetBoolArg(\"-debugnet\", false))\n-        InitWarning(_(\"Warning: Deprecated argument -debugnet ignored, use -debug=net\"));\n+        InitWarning(_<string>(\"Warning: Deprecated argument -debugnet ignored, use -debug=net\"));\n \n     fBenchmark = GetBoolArg(\"-benchmark\", false);\n     mempool.setSanityCheck(GetBoolArg(\"-checkmempool\", RegTest()));\n@@ -476,9 +479,9 @@ bool AppInit2(boost::thread_group& threadGroup, bool fForceServer)\n     else\n         fServer = GetBoolArg(\"-server\", false);\n \n-    fPrintToConsole = GetBoolArg(\"-printtoconsole\", false);\n-    fPrintToDebugger = GetBoolArg(\"-printtodebugger\", false);\n-    fLogTimestamps = GetBoolArg(\"-logtimestamps\", true);\n+    Log::fPrintToConsole = GetBoolArg(\"-printtoconsole\", false);\n+    Log::fPrintToDebugger = GetBoolArg(\"-printtodebugger\", false);\n+    Log::fLogTimestamps = GetBoolArg(\"-logtimestamps\", true);\n     bool fDisableWallet = GetBoolArg(\"-disablewallet\", false);\n \n     if (mapArgs.count(\"-timeout\"))\n@@ -506,60 +509,60 @@ bool AppInit2(boost::thread_group& threadGroup, bool fForceServer)\n         if (ParseMoney(mapArgs[\"-mintxfee\"], n) && n > 0)\n             CTransaction::nMinTxFee = n;\n         else\n-            return InitError(strprintf(_(\"Invalid amount for -mintxfee=<amount>: '%s'\"), mapArgs[\"-mintxfee\"].c_str()));\n+            return InitError(str(_(\"Invalid amount for -mintxfee=<amount>: '%s'\") % mapArgs[\"-mintxfee\"]));\n     }\n     if (mapArgs.count(\"-minrelaytxfee\"))\n     {\n         int64_t n = 0;\n         if (ParseMoney(mapArgs[\"-minrelaytxfee\"], n) && n > 0)\n             CTransaction::nMinRelayTxFee = n;\n         else\n-            return InitError(strprintf(_(\"Invalid amount for -minrelaytxfee=<amount>: '%s'\"), mapArgs[\"-minrelaytxfee\"].c_str()));\n+            return InitError(str(_(\"Invalid amount for -minrelaytxfee=<amount>: '%s'\") % mapArgs[\"-minrelaytxfee\"]));\n     }\n \n     if (mapArgs.count(\"-paytxfee\"))\n     {\n         if (!ParseMoney(mapArgs[\"-paytxfee\"], nTransactionFee))\n-            return InitError(strprintf(_(\"Invalid amount for -paytxfee=<amount>: '%s'\"), mapArgs[\"-paytxfee\"].c_str()));\n+            return InitError(str(_(\"Invalid amount for -paytxfee=<amount>: '%s'\") % mapArgs[\"-paytxfee\"]));\n         if (nTransactionFee > 0.25 * COIN)\n-            InitWarning(_(\"Warning: -paytxfee is set very high! This is the transaction fee you will pay if you send a transaction.\"));\n+            InitWarning(_<string>(\"Warning: -paytxfee is set very high! This is the transaction fee you will pay if you send a transaction.\"));\n     }\n \n     strWalletFile = GetArg(\"-wallet\", \"wallet.dat\");\n \n     // ********************************************************* Step 4: application initialization: dir lock, daemonize, pidfile, debug log\n \n-    std::string strDataDir = GetDataDir().string();\n+    string strDataDir = GetDataDir().string();\n \n     // Wallet file must be a plain filename without a directory\n     if (strWalletFile != boost::filesystem::basename(strWalletFile) + boost::filesystem::extension(strWalletFile))\n-        return InitError(strprintf(_(\"Wallet %s resides outside data directory %s\"), strWalletFile.c_str(), strDataDir.c_str()));\n+        return InitError(str(_(\"Wallet %s resides outside data directory %s\") % strWalletFile % strDataDir));\n \n     // Make sure only a single Bitcoin process is using the data directory.\n     boost::filesystem::path pathLockFile = GetDataDir() / \".lock\";\n     FILE* file = fopen(pathLockFile.string().c_str(), \"a\"); // empty lock file; created if it doesn't exist.\n     if (file) fclose(file);\n     static boost::interprocess::file_lock lock(pathLockFile.string().c_str());\n     if (!lock.try_lock())\n-        return InitError(strprintf(_(\"Cannot obtain a lock on data directory %s. Bitcoin is probably already running.\"), strDataDir.c_str()));\n+        return InitError(str(_(\"Cannot obtain a lock on data directory %s. Bitcoin is probably already running.\") % strDataDir));\n \n-    if (GetBoolArg(\"-shrinkdebugfile\", !fDebug))\n+    if (GetBoolArg(\"-shrinkdebugfile\", !Log::fDebug))\n         ShrinkDebugFile();\n-    LogPrintf(\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\");\n-    LogPrintf(\"Bitcoin version %s (%s)\\n\", FormatFullVersion().c_str(), CLIENT_DATE.c_str());\n-    LogPrintf(\"Using OpenSSL version %s\\n\", SSLeay_version(SSLEAY_VERSION));\n-    if (!fLogTimestamps)\n-        LogPrintf(\"Startup time: %s\\n\", DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", GetTime()).c_str());\n-    LogPrintf(\"Default data directory %s\\n\", GetDefaultDataDir().string().c_str());\n-    LogPrintf(\"Using data directory %s\\n\", strDataDir.c_str());\n-    LogPrintf(\"Using at most %i connections (%i file descriptors available)\\n\", nMaxConnections, nFD);\n-    std::ostringstream strErrors;\n+    Log() << \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\";\n+    Log() << \"Bitcoin version \" << FormatFullVersion() << \" (\" << CLIENT_DATE << \")\\n\";\n+    Log() << \"Using OpenSSL version \" << SSLeay_version(SSLEAY_VERSION) << \"\\n\";\n+    if (!Log::fLogTimestamps)\n+        Log() << \"Startup time: \" << BitcoinTime::DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", BitcoinTime::GetTime()) << \"\\n\";\n+    Log() << \"Default data directory \" << GetDefaultDataDir().string() << \"\\n\";\n+    Log() << \"Using data directory \" << strDataDir << \"\\n\";\n+    Log() << \"Using at most \" << nMaxConnections << \" connections (\" << nFD << \" file descriptors available)\\n\";\n+    std::ostringstream ossErrors;\n \n     if (fDaemon)\n-        fprintf(stdout, \"Bitcoin server starting\\n\");\n+        cout << \"Bitcoin server starting\\n\";\n \n     if (nScriptCheckThreads) {\n-        LogPrintf(\"Using %u threads for script verification\\n\", nScriptCheckThreads);\n+        Log() << \"Using \" << nScriptCheckThreads << \" threads for script verification\\n\";\n         for (int i=0; i<nScriptCheckThreads-1; i++)\n             threadGroup.create_thread(&ThreadScriptCheck);\n     }\n@@ -569,24 +572,24 @@ bool AppInit2(boost::thread_group& threadGroup, bool fForceServer)\n     // ********************************************************* Step 5: verify wallet database integrity\n \n     if (!fDisableWallet) {\n-        uiInterface.InitMessage(_(\"Verifying wallet...\"));\n+        uiInterface.InitMessage(_<string>(\"Verifying wallet...\"));\n \n         if (!bitdb.Open(GetDataDir()))\n         {\n             // try moving the database env out of the way\n             boost::filesystem::path pathDatabase = GetDataDir() / \"database\";\n-            boost::filesystem::path pathDatabaseBak = GetDataDir() / strprintf(\"database.%\"PRId64\".bak\", GetTime());\n+            boost::filesystem::path pathDatabaseBak = GetDataDir() / boost::str(boost::format(\"database.%d.bak\") % BitcoinTime::GetTime()); \n             try {\n                 boost::filesystem::rename(pathDatabase, pathDatabaseBak);\n-                LogPrintf(\"Moved old %s to %s. Retrying.\\n\", pathDatabase.string().c_str(), pathDatabaseBak.string().c_str());\n+                Log() << \"Moved old \" << pathDatabase.string() << \" to \" << pathDatabaseBak.string() << \". Retrying.\\n\";\n             } catch(boost::filesystem::filesystem_error &error) {\n                  // failure is ok (well, not really, but it's not worse than what we started with)\n             }\n \n             // try again\n             if (!bitdb.Open(GetDataDir())) {\n                 // if it still fails, it probably means we can't even create the database env\n-                string msg = strprintf(_(\"Error initializing wallet database environment %s!\"), strDataDir.c_str());\n+                string msg = str(_(\"Error initializing wallet database environment %s!\") % strDataDir);\n                 return InitError(msg);\n             }\n         }\n@@ -603,14 +606,14 @@ bool AppInit2(boost::thread_group& threadGroup, bool fForceServer)\n             CDBEnv::VerifyResult r = bitdb.Verify(strWalletFile, CWalletDB::Recover);\n             if (r == CDBEnv::RECOVER_OK)\n             {\n-                string msg = strprintf(_(\"Warning: wallet.dat corrupt, data salvaged!\"\n+                string msg = str(_(\"Warning: wallet.dat corrupt, data salvaged!\"\n                                          \" Original wallet.dat saved as wallet.{timestamp}.bak in %s; if\"\n                                          \" your balance or transactions are incorrect you should\"\n-                                         \" restore from a backup.\"), strDataDir.c_str());\n+                                         \" restore from a backup.\") % strDataDir);\n                 InitWarning(msg);\n             }\n             if (r == CDBEnv::RECOVER_FAIL)\n-                return InitError(_(\"wallet.dat corrupt, salvage failed\"));\n+                return InitError(_<string>(\"wallet.dat corrupt, salvage failed\"));\n         }\n     } // (!fDisableWallet)\n \n@@ -620,14 +623,14 @@ bool AppInit2(boost::thread_group& threadGroup, bool fForceServer)\n \n     int nSocksVersion = GetArg(\"-socks\", 5);\n     if (nSocksVersion != 4 && nSocksVersion != 5)\n-        return InitError(strprintf(_(\"Unknown -socks proxy version requested: %i\"), nSocksVersion));\n+        return InitError(str(_(\"Unknown -socks proxy version requested: %i\") % nSocksVersion));\n \n     if (mapArgs.count(\"-onlynet\")) {\n         std::set<enum Network> nets;\n-        BOOST_FOREACH(std::string snet, mapMultiArgs[\"-onlynet\"]) {\n+        BOOST_FOREACH(string snet, mapMultiArgs[\"-onlynet\"]) {\n             enum Network net = ParseNetwork(snet);\n             if (net == NET_UNROUTABLE)\n-                return InitError(strprintf(_(\"Unknown network specified in -onlynet: '%s'\"), snet.c_str()));\n+                return InitError(str(_(\"Unknown network specified in -onlynet: '%s'\") % snet));\n             nets.insert(net);\n         }\n         for (int n = 0; n < NET_MAX; n++) {\n@@ -648,7 +651,7 @@ bool AppInit2(boost::thread_group& threadGroup, bool fForceServer)\n     if (mapArgs.count(\"-proxy\")) {\n         addrProxy = CService(mapArgs[\"-proxy\"], 9050);\n         if (!addrProxy.IsValid())\n-            return InitError(strprintf(_(\"Invalid -proxy address: '%s'\"), mapArgs[\"-proxy\"].c_str()));\n+            return InitError(str(_(\"Invalid -proxy address: '%s'\") % mapArgs[\"-proxy\"]));\n \n         if (!IsLimited(NET_IPV4))\n             SetProxy(NET_IPV4, addrProxy, nSocksVersion);\n@@ -665,7 +668,7 @@ bool AppInit2(boost::thread_group& threadGroup, bool fForceServer)\n     // -onion can override normal proxy, -noonion disables tor entirely\n     // -tor here is a temporary backwards compatibility measure\n     if (mapArgs.count(\"-tor\"))\n-        printf(\"Notice: option -tor has been replaced with -onion and will be removed in a later version.\\n\");\n+        cout << \"Notice: option -tor has been replaced with -onion and will be removed in a later version.\\n\";\n     if (!(mapArgs.count(\"-onion\") && mapArgs[\"-onion\"] == \"0\") &&\n         !(mapArgs.count(\"-tor\") && mapArgs[\"-tor\"] == \"0\") &&\n          (fProxy || mapArgs.count(\"-onion\") || mapArgs.count(\"-tor\"))) {\n@@ -675,7 +678,7 @@ bool AppInit2(boost::thread_group& threadGroup, bool fForceServer)\n         else\n             addrOnion = mapArgs.count(\"-onion\")?CService(mapArgs[\"-onion\"], 9050):CService(mapArgs[\"-tor\"], 9050);\n         if (!addrOnion.IsValid())\n-            return InitError(strprintf(_(\"Invalid -onion address: '%s'\"), mapArgs.count(\"-onion\")?mapArgs[\"-onion\"].c_str():mapArgs[\"-tor\"].c_str()));\n+            return InitError(str(_(\"Invalid -onion address: '%s'\") % (mapArgs.count(\"-onion\") ? mapArgs[\"-onion\"] : mapArgs[\"-tor\"])));\n         SetProxy(NET_TOR, addrOnion, 5);\n         SetReachable(NET_TOR);\n     }\n@@ -688,10 +691,10 @@ bool AppInit2(boost::thread_group& threadGroup, bool fForceServer)\n     bool fBound = false;\n     if (!fNoListen) {\n         if (mapArgs.count(\"-bind\")) {\n-            BOOST_FOREACH(std::string strBind, mapMultiArgs[\"-bind\"]) {\n+            BOOST_FOREACH(string strBind, mapMultiArgs[\"-bind\"]) {\n                 CService addrBind;\n                 if (!Lookup(strBind.c_str(), addrBind, GetListenPort(), false))\n-                    return InitError(strprintf(_(\"Cannot resolve -bind address: '%s'\"), strBind.c_str()));\n+                    return InitError(str(_(\"Cannot resolve -bind address: '%s'\") % strBind));\n                 fBound |= Bind(addrBind, (BF_EXPLICIT | BF_REPORT_ERROR));\n             }\n         }\n@@ -704,14 +707,14 @@ bool AppInit2(boost::thread_group& threadGroup, bool fForceServer)\n             fBound |= Bind(CService(inaddr_any, GetListenPort()), !fBound ? BF_REPORT_ERROR : BF_NONE);\n         }\n         if (!fBound)\n-            return InitError(_(\"Failed to listen on any port. Use -listen=0 if you want this.\"));\n+            return InitError(_<string>(\"Failed to listen on any port. Use -listen=0 if you want this.\"));\n     }\n \n     if (mapArgs.count(\"-externalip\")) {\n         BOOST_FOREACH(string strAddr, mapMultiArgs[\"-externalip\"]) {\n             CService addrLocal(strAddr, GetListenPort(), fNameLookup);\n             if (!addrLocal.IsValid())\n-                return InitError(strprintf(_(\"Cannot resolve -externalip address: '%s'\"), strAddr.c_str()));\n+                return InitError(str(_(\"Cannot resolve -externalip address: '%s'\") % strAddr));\n             AddLocal(CService(strAddr, GetListenPort(), fNameLookup), LOCAL_MANUAL);\n         }\n     }\n@@ -730,17 +733,18 @@ bool AppInit2(boost::thread_group& threadGroup, bool fForceServer)\n         filesystem::create_directories(blocksDir);\n         bool linked = false;\n         for (unsigned int i = 1; i < 10000; i++) {\n-            filesystem::path source = GetDataDir() / strprintf(\"blk%04u.dat\", i);\n+            filesystem::path source = GetDataDir() / boost::str(boost::format(\"blk%04d.dat\") % i);\n             if (!filesystem::exists(source)) break;\n-            filesystem::path dest = blocksDir / strprintf(\"blk%05u.dat\", i-1);\n+\n+            filesystem::path dest = blocksDir / boost::str(boost::format(\"blk%05d.dat\") % (i - 1));\n             try {\n                 filesystem::create_hard_link(source, dest);\n-                LogPrintf(\"Hardlinked %s -> %s\\n\", source.string().c_str(), dest.string().c_str());\n+                Log() << \"Hardlinked \" << source.string() << \" -> \" << dest.string() << \"\\n\";\n                 linked = true;\n             } catch (filesystem::filesystem_error & e) {\n                 // Note: hardlink creation failing is not a disaster, it just means\n                 // blocks will get re-downloaded from peers.\n-                LogPrintf(\"Error hardlinking blk%04u.dat : %s\\n\", i, e.what());\n+                Log() << \"Error hardlinking blk\" << setfill('0') << setw(4) << i << setfill(' ') << \".dat : \" << e.what() << \"\\n\";\n                 break;\n             }\n         }\n@@ -765,11 +769,11 @@ bool AppInit2(boost::thread_group& threadGroup, bool fForceServer)\n     bool fLoaded = false;\n     while (!fLoaded) {\n         bool fReset = fReindex;\n-        std::string strLoadError;\n+        string strLoadError;\n \n-        uiInterface.InitMessage(_(\"Loading block index...\"));\n+        uiInterface.InitMessage(_<string>(\"Loading block index...\"));\n \n-        nStart = GetTimeMillis();\n+        nStart = BitcoinTime::GetTimeMillis();\n         do {\n             try {\n                 UnloadBlockIndex();\n@@ -785,36 +789,36 @@ bool AppInit2(boost::thread_group& threadGroup, bool fForceServer)\n                     pblocktree->WriteReindexing(true);\n \n                 if (!LoadBlockIndex()) {\n-                    strLoadError = _(\"Error loading block database\");\n+                    strLoadError = _<string>(\"Error loading block database\");\n                     break;\n                 }\n \n                 // If the loaded chain has a wrong genesis, bail out immediately\n                 // (we're likely using a testnet datadir, or the other way around).\n                 if (!mapBlockIndex.empty() && chainActive.Genesis() == NULL)\n-                    return InitError(_(\"Incorrect or no genesis block found. Wrong datadir for network?\"));\n+                    return InitError(_<string>(\"Incorrect or no genesis block found. Wrong datadir for network?\"));\n \n                 // Initialize the block index (no-op if non-empty database was already loaded)\n                 if (!InitBlockIndex()) {\n-                    strLoadError = _(\"Error initializing block database\");\n+                    strLoadError = _<string>(\"Error initializing block database\");\n                     break;\n                 }\n \n                 // Check for changed -txindex state\n                 if (fTxIndex != GetBoolArg(\"-txindex\", false)) {\n-                    strLoadError = _(\"You need to rebuild the database using -reindex to change -txindex\");\n+                    strLoadError = _<string>(\"You need to rebuild the database using -reindex to change -txindex\");\n                     break;\n                 }\n \n-                uiInterface.InitMessage(_(\"Verifying blocks...\"));\n+                uiInterface.InitMessage(_<string>(\"Verifying blocks...\"));\n                 if (!VerifyDB(GetArg(\"-checklevel\", 3),\n                               GetArg(\"-checkblocks\", 288))) {\n-                    strLoadError = _(\"Corrupted block database detected\");\n+                    strLoadError = _<string>(\"Corrupted block database detected\");\n                     break;\n                 }\n             } catch(std::exception &e) {\n-                if (fDebug) LogPrintf(\"%s\\n\", e.what());\n-                strLoadError = _(\"Error opening block database\");\n+                if (Log::fDebug) Log() << e.what() << \"\\n\";\n+                strLoadError = _<string>(\"Error opening block database\");\n                 break;\n             }\n \n@@ -825,13 +829,13 @@ bool AppInit2(boost::thread_group& threadGroup, bool fForceServer)\n             // first suggest a reindex\n             if (!fReset) {\n                 bool fRet = uiInterface.ThreadSafeMessageBox(\n-                    strLoadError + \".\\n\\n\" + _(\"Do you want to rebuild the block database now?\"),\n+                    strLoadError + \".\\n\\n\" + _<string>(\"Do you want to rebuild the block database now?\"),\n                     \"\", CClientUIInterface::MSG_ERROR | CClientUIInterface::BTN_ABORT);\n                 if (fRet) {\n                     fReindex = true;\n                     fRequestShutdown = false;\n                 } else {\n-                    LogPrintf(\"Aborted block database rebuild. Exiting.\\n\");\n+                    Log() << \"Aborted block database rebuild. Exiting.\\n\";\n                     return false;\n                 }\n             } else {\n@@ -845,10 +849,10 @@ bool AppInit2(boost::thread_group& threadGroup, bool fForceServer)\n     // As the program has not fully started yet, Shutdown() is possibly overkill.\n     if (fRequestShutdown)\n     {\n-        LogPrintf(\"Shutdown requested. Exiting.\\n\");\n+        Log() << \"Shutdown requested. Exiting.\\n\";\n         return false;\n     }\n-    LogPrintf(\" block index %15\"PRId64\"ms\\n\", GetTimeMillis() - nStart);\n+    Log() << \" block index \" << setw(15) << (BitcoinTime::GetTimeMillis() - nStart) << \"ms\\n\";\n \n     if (GetBoolArg(\"-printblockindex\", false) || GetBoolArg(\"-printblocktree\", false))\n     {\n@@ -870,62 +874,62 @@ bool AppInit2(boost::thread_group& threadGroup, bool fForceServer)\n                 ReadBlockFromDisk(block, pindex);\n                 block.BuildMerkleTree();\n                 block.print();\n-                LogPrintf(\"\\n\");\n+                Log() << \"\\n\";\n                 nFound++;\n             }\n         }\n         if (nFound == 0)\n-            LogPrintf(\"No blocks matching %s were found\\n\", strMatch.c_str());\n+            Log() << \"No blocks matching \" << strMatch << \" were found\\n\";\n         return false;\n     }\n \n     // ********************************************************* Step 8: load wallet\n \n     if (fDisableWallet) {\n         pwalletMain = NULL;\n-        LogPrintf(\"Wallet disabled!\\n\");\n+        Log() << \"Wallet disabled!\\n\";\n     } else {\n-        uiInterface.InitMessage(_(\"Loading wallet...\"));\n+        uiInterface.InitMessage(_<string>(\"Loading wallet...\"));\n \n-        nStart = GetTimeMillis();\n+        nStart = BitcoinTime::GetTimeMillis();\n         bool fFirstRun = true;\n         pwalletMain = new CWallet(strWalletFile);\n         DBErrors nLoadWalletRet = pwalletMain->LoadWallet(fFirstRun);\n         if (nLoadWalletRet != DB_LOAD_OK)\n         {\n             if (nLoadWalletRet == DB_CORRUPT)\n-                strErrors << _(\"Error loading wallet.dat: Wallet corrupted\") << \"\\n\";\n+                ossErrors << _<string>(\"Error loading wallet.dat: Wallet corrupted\") << \"\\n\";\n             else if (nLoadWalletRet == DB_NONCRITICAL_ERROR)\n             {\n-                string msg(_(\"Warning: error reading wallet.dat! All keys read correctly, but transaction data\"\n+                string msg(_<string>(\"Warning: error reading wallet.dat! All keys read correctly, but transaction data\"\n                              \" or address book entries might be missing or incorrect.\"));\n                 InitWarning(msg);\n             }\n             else if (nLoadWalletRet == DB_TOO_NEW)\n-                strErrors << _(\"Error loading wallet.dat: Wallet requires newer version of Bitcoin\") << \"\\n\";\n+                ossErrors << _<string>(\"Error loading wallet.dat: Wallet requires newer version of Bitcoin\") << \"\\n\";\n             else if (nLoadWalletRet == DB_NEED_REWRITE)\n             {\n-                strErrors << _(\"Wallet needed to be rewritten: restart Bitcoin to complete\") << \"\\n\";\n-                LogPrintf(\"%s\", strErrors.str().c_str());\n-                return InitError(strErrors.str());\n+                ossErrors << _<string>(\"Wallet needed to be rewritten: restart Bitcoin to complete\") << \"\\n\";\n+                Log() << ossErrors.str();\n+                return InitError(ossErrors.str());\n             }\n             else\n-                strErrors << _(\"Error loading wallet.dat\") << \"\\n\";\n+                ossErrors << _<string>(\"Error loading wallet.dat\") << \"\\n\";\n         }\n \n         if (GetBoolArg(\"-upgradewallet\", fFirstRun))\n         {\n             int nMaxVersion = GetArg(\"-upgradewallet\", 0);\n             if (nMaxVersion == 0) // the -upgradewallet without argument case\n             {\n-                LogPrintf(\"Performing wallet upgrade to %i\\n\", FEATURE_LATEST);\n+                Log() << \"Performing wallet upgrade to \" << FEATURE_LATEST << \"\\n\";\n                 nMaxVersion = CLIENT_VERSION;\n                 pwalletMain->SetMinVersion(FEATURE_LATEST); // permanently upgrade the wallet immediately\n             }\n             else\n-                LogPrintf(\"Allowing wallet upgrade up to %i\\n\", nMaxVersion);\n+                Log() << \"Allowing wallet upgrade up to \" << nMaxVersion << \"\\n\";\n             if (nMaxVersion < pwalletMain->GetVersion())\n-                strErrors << _(\"Cannot downgrade wallet\") << \"\\n\";\n+                ossErrors << _<string>(\"Cannot downgrade wallet\") << \"\\n\";\n             pwalletMain->SetMaxVersion(nMaxVersion);\n         }\n \n@@ -938,14 +942,14 @@ bool AppInit2(boost::thread_group& threadGroup, bool fForceServer)\n             if (pwalletMain->GetKeyFromPool(newDefaultKey)) {\n                 pwalletMain->SetDefaultKey(newDefaultKey);\n                 if (!pwalletMain->SetAddressBook(pwalletMain->vchDefaultKey.GetID(), \"\", \"receive\"))\n-                    strErrors << _(\"Cannot write default address\") << \"\\n\";\n+                    ossErrors << _<string>(\"Cannot write default address\") << \"\\n\";\n             }\n \n             pwalletMain->SetBestChain(chainActive.GetLocator());\n         }\n \n-        LogPrintf(\"%s\", strErrors.str().c_str());\n-        LogPrintf(\" wallet      %15\"PRId64\"ms\\n\", GetTimeMillis() - nStart);\n+        Log() << ossErrors.str();\n+        Log() << \" wallet      \" << setw(15) << (BitcoinTime::GetTimeMillis() - nStart) << \"ms\\n\";\n \n         RegisterWallet(pwalletMain);\n \n@@ -963,11 +967,11 @@ bool AppInit2(boost::thread_group& threadGroup, bool fForceServer)\n         }\n         if (chainActive.Tip() && chainActive.Tip() != pindexRescan)\n         {\n-            uiInterface.InitMessage(_(\"Rescanning...\"));\n-            LogPrintf(\"Rescanning last %i blocks (from block %i)...\\n\", chainActive.Height() - pindexRescan->nHeight, pindexRescan->nHeight);\n-            nStart = GetTimeMillis();\n+            uiInterface.InitMessage(_<string>(\"Rescanning...\"));\n+            Log() << \"Rescanning last \" << (chainActive.Height() - pindexRescan->nHeight) << \" blocks (from block \" << pindexRescan->nHeight << \")...\\n\";\n+            nStart = BitcoinTime::GetTimeMillis();\n             pwalletMain->ScanForWalletTransactions(pindexRescan, true);\n-            LogPrintf(\" rescan      %15\"PRId64\"ms\\n\", GetTimeMillis() - nStart);\n+            Log() << \" rescan      \" << setw(15) << (BitcoinTime::GetTimeMillis() - nStart) << \"ms\\n\";\n             pwalletMain->SetBestChain(chainActive.GetLocator());\n             nWalletDBUpdated++;\n         }\n@@ -978,7 +982,7 @@ bool AppInit2(boost::thread_group& threadGroup, bool fForceServer)\n     // scan for better chains in the block chain database, that are not yet connected in the active best chain\n     CValidationState state;\n     if (!ConnectBestBlock(state))\n-        strErrors << \"Failed to connect best block\";\n+        ossErrors << \"Failed to connect best block\";\n \n     std::vector<boost::filesystem::path> vImportFiles;\n     if (mapArgs.count(\"-loadblock\"))\n@@ -990,35 +994,34 @@ bool AppInit2(boost::thread_group& threadGroup, bool fForceServer)\n \n     // ********************************************************* Step 10: load peers\n \n-    uiInterface.InitMessage(_(\"Loading addresses...\"));\n+    uiInterface.InitMessage(_<string>(\"Loading addresses...\"));\n \n-    nStart = GetTimeMillis();\n+    nStart = BitcoinTime::GetTimeMillis();\n \n     {\n         CAddrDB adb;\n         if (!adb.Read(addrman))\n-            LogPrintf(\"Invalid or missing peers.dat; recreating\\n\");\n+            Log() << \"Invalid or missing peers.dat; recreating\\n\";\n     }\n \n-    LogPrintf(\"Loaded %i addresses from peers.dat  %\"PRId64\"ms\\n\",\n-           addrman.size(), GetTimeMillis() - nStart);\n+    Log() << \"Loaded \" << addrman.size() << \" addresses from peers.dat  \" << (BitcoinTime::GetTimeMillis() - nStart) << \"ms\\n\";\n \n     // ********************************************************* Step 11: start node\n \n     if (!CheckDiskSpace())\n         return false;\n \n-    if (!strErrors.str().empty())\n-        return InitError(strErrors.str());\n+    if (!ossErrors.str().empty())\n+        return InitError(ossErrors.str());\n \n     RandAddSeedPerfmon();\n \n     //// debug print\n-    LogPrintf(\"mapBlockIndex.size() = %\"PRIszu\"\\n\",   mapBlockIndex.size());\n-    LogPrintf(\"nBestHeight = %d\\n\",                   chainActive.Height());\n-    LogPrintf(\"setKeyPool.size() = %\"PRIszu\"\\n\",      pwalletMain ? pwalletMain->setKeyPool.size() : 0);\n-    LogPrintf(\"mapWallet.size() = %\"PRIszu\"\\n\",       pwalletMain ? pwalletMain->mapWallet.size() : 0);\n-    LogPrintf(\"mapAddressBook.size() = %\"PRIszu\"\\n\",  pwalletMain ? pwalletMain->mapAddressBook.size() : 0);\n+    Log() << \"mapBlockIndex.size() = \" << mapBlockIndex.size() << \"\\n\";\n+    Log() << \"nBestHeight = \" << chainActive.Height() << \"\\n\";\n+    Log() << \"setKeyPool.size() = \" << (pwalletMain ? pwalletMain->setKeyPool.size() : 0) << \"\\n\";\n+    Log() << \"mapWallet.size() = \" << (pwalletMain ? pwalletMain->mapWallet.size() : 0) << \"\\n\";\n+    Log() << \"mapAddressBook.size() = \" << (pwalletMain ? pwalletMain->mapAddressBook.size() : 0) << \"\\n\";\n \n     StartNode(threadGroup);\n \n@@ -1033,7 +1036,7 @@ bool AppInit2(boost::thread_group& threadGroup, bool fForceServer)\n \n     // ********************************************************* Step 12: finished\n \n-    uiInterface.InitMessage(_(\"Done loading\"));\n+    uiInterface.InitMessage(_<string>(\"Done loading\"));\n \n     if (pwalletMain) {\n         // Add wallet transactions that aren't already in a block to mapTransactions"
      },
      {
        "sha": "ac1d9cb7e55d589f36edc9c637cb5ef0198ab18e",
        "filename": "src/leveldbwrapper.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/leveldbwrapper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/leveldbwrapper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldbwrapper.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -15,7 +15,7 @@\n void HandleError(const leveldb::Status &status) throw(leveldb_error) {\n     if (status.ok())\n         return;\n-    LogPrintf(\"%s\\n\", status.ToString().c_str());\n+    Log() << status.ToString() << \"\\n\";\n     if (status.IsCorruption())\n         throw leveldb_error(\"Database corrupted\");\n     if (status.IsIOError())\n@@ -48,15 +48,15 @@ CLevelDBWrapper::CLevelDBWrapper(const boost::filesystem::path &path, size_t nCa\n         options.env = penv;\n     } else {\n         if (fWipe) {\n-            LogPrintf(\"Wiping LevelDB in %s\\n\", path.string().c_str());\n+            Log() << \"Wiping LevelDB in \" << path.string() << \"\\n\";\n             leveldb::DestroyDB(path.string(), options);\n         }\n         boost::filesystem::create_directory(path);\n-        LogPrintf(\"Opening LevelDB in %s\\n\", path.string().c_str());\n+        Log() << \"Opening LevelDB in \" << path.string() << \"\\n\";\n     }\n     leveldb::Status status = leveldb::DB::Open(options, path.string(), &pdb);\n     HandleError(status);\n-    LogPrintf(\"Opened LevelDB successfully\\n\");\n+    Log() << \"Opened LevelDB successfully\\n\";\n }\n \n CLevelDBWrapper::~CLevelDBWrapper() {"
      },
      {
        "sha": "985ef1600bd9a66e9372a7a91e0391ccdbfbdf4c",
        "filename": "src/leveldbwrapper.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/leveldbwrapper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/leveldbwrapper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldbwrapper.h?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -5,6 +5,7 @@\n #ifndef BITCOIN_LEVELDBWRAPPER_H\n #define BITCOIN_LEVELDBWRAPPER_H\n \n+#include \"log.h\"\n #include \"serialize.h\"\n #include \"util.h\"\n #include \"version.h\"\n@@ -93,7 +94,7 @@ class CLevelDBWrapper\n         if (!status.ok()) {\n             if (status.IsNotFound())\n                 return false;\n-            LogPrintf(\"LevelDB read failure: %s\\n\", status.ToString().c_str());\n+            Log() << \"LevelDB read failure: \" << status.ToString() << \"\\n\";\n             HandleError(status);\n         }\n         try {\n@@ -122,7 +123,7 @@ class CLevelDBWrapper\n         if (!status.ok()) {\n             if (status.IsNotFound())\n                 return false;\n-            LogPrintf(\"LevelDB read failure: %s\\n\", status.ToString().c_str());\n+            Log() << \"LevelDB read failure: \" << status.ToString() << \"\\n\";\n             HandleError(status);\n         }\n         return true;"
      },
      {
        "sha": "057cc3b32bd1899c60e228999bca071972437d27",
        "filename": "src/log.cpp",
        "status": "added",
        "additions": 156,
        "deletions": 0,
        "changes": 156,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/log.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/log.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/log.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -0,0 +1,156 @@\n+// Copyright (c) 2013 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"log.h\"\n+\n+#include \"bitcointime.h\"\n+#include \"util.h\"\n+\n+#include <iostream>\n+\n+#ifdef WIN32\n+#define WIN32_LEAN_AND_MEAN 1\n+#include <windows.h>\n+#endif\n+\n+#include <boost/filesystem/path.hpp>\n+\n+using namespace std;\n+\n+bool Log::fDebug = false;\n+bool Log::fPrintToConsole = false;\n+bool Log::fPrintToDebugger = false;\n+bool Log::fLogTimestamps = false;\n+volatile bool Log::fReopenDebugLog = false;\n+bool Log::fStartedNewLine = true;\n+\n+boost::once_flag Log::initStaticLogMembersFlag = BOOST_ONCE_INIT;\n+boost::once_flag Log::initFileoutFlag = BOOST_ONCE_INIT;\n+\n+StaticLogMembers* Log::slm = NULL;\n+\n+\n+Log::Log(const string& category)\n+{\n+    boost::call_once(&Log::StaticLogMembersInit, initStaticLogMembersFlag);\n+    boost::mutex::scoped_lock scoped_lock(slm->mutexDebugLog);\n+\n+    if (category != \"\")\n+    {\n+        if (!fDebug)\n+            return;\n+\n+        const vector<string>& categories = mapMultiArgs[\"-debug\"];\n+        bool allCategories = count(categories.begin(), categories.end(), string(\"\"));\n+\n+        // Only look for categories, if not -debug/-debug=1 was passed,\n+        // as that implies every category should be logged.\n+        if (!allCategories)\n+        {\n+            // Category was not found (not supplied via -debug=<category>)\n+            if (find(categories.begin(), categories.end(), category) == categories.end())\n+                return;\n+        }\n+    }\n+\n+    if (fPrintToConsole)\n+    {\n+        // print to console\n+        vLogStreams.push_back(&cout);\n+    }\n+    else if (!fPrintToDebugger)\n+    {\n+        boost::call_once(&Log::FileoutInit, initFileoutFlag);\n+\n+        if (!slm->fileout.is_open())\n+            return;\n+\n+        vLogStreams.push_back(&slm->fileout);\n+\n+        // reopen the log file, if requested\n+        if (fReopenDebugLog) {\n+            fReopenDebugLog = false;\n+            boost::filesystem::path pathDebug = GetDataDir() / \"debug.log\";\n+            slm->fileout.close();\n+            slm->fileout.open(pathDebug.string().c_str(), ofstream::out | ofstream::app);\n+            if (slm->fileout.is_open())\n+                slm->fileout.rdbuf()->pubsetbuf(NULL, 0); // unbuffered\n+        }\n+\n+    }\n+\n+#ifdef WIN32\n+    if (fPrintToDebugger)\n+        vLogStreams.push_back(&slm->windowsDebugLog);\n+#endif\n+}\n+\n+Log& Log::insert(const string& message)\n+{\n+    boost::mutex::scoped_lock scoped_lock(slm->mutexDebugLog);\n+\n+    for (vector<ostream*>::iterator it = vLogStreams.begin(); it != vLogStreams.end(); ++it)\n+    {\n+        if (*it == &slm->fileout)\n+        {\n+            // Debug print useful for profiling\n+            if (fLogTimestamps && fStartedNewLine)\n+                **it << BitcoinTime::DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", BitcoinTime::GetTime()) << \" \";\n+            \n+            if (message[message.length() - 1] == '\\n')\n+                fStartedNewLine = true;\n+            else\n+                fStartedNewLine = false;\n+\n+            **it << message;\n+#ifdef WIN32            \n+        } else if (*it == &slm->windowsDebugLog) {\n+                // Accumulate in windowsDebugLog and output a line at a time\n+                int line_start = 0, line_end;\n+                while((line_end = message.find('\\n', line_start)) != -1)\n+                {\n+                    string strLine = message.substr(line_start, line_end - line_start);\n+\n+                    // Include buffered data if this is the first line, clear buffer after prepending\n+                    if (line_start == 0)\n+                    {\n+                        strLine = slm->windowsDebugLog.str() + strLine;\n+                        slm->windowsDebugLog.str(\"\");\n+                    }\n+                    \n+                    OutputDebugStringA(strLine.c_str());\n+                    line_start = line_end + 1;\n+                }\n+\n+                // Add un-printed message contents\n+                **it << message.substr(line_start);\n+#endif\n+        } else {\n+            **it << message;\n+        }\n+\n+        **it << flush;\n+\n+    }\n+\n+    return *this;\n+}\n+\n+void Log::StaticLogMembersInit()\n+{\n+    assert(!slm);\n+\n+    slm = new StaticLogMembers();\n+}\n+\n+void Log::FileoutInit()\n+{\n+    assert(!slm->fileout.is_open());\n+\n+    boost::filesystem::path pathDebug = GetDataDir() / \"debug.log\";\n+    slm->fileout.open(pathDebug.string().c_str(), ofstream::out | ofstream::app);\n+    if (slm->fileout.is_open()) slm->fileout.rdbuf()->pubsetbuf(NULL, 0); // unbuffered\n+\n+}\n+"
      },
      {
        "sha": "67e22d268b719ec14d8953b5c5d7f8ec93c4c920",
        "filename": "src/log.h",
        "status": "added",
        "additions": 128,
        "deletions": 0,
        "changes": 128,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/log.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/log.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/log.h?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -0,0 +1,128 @@\n+// Copyright (c) 2013 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_LOG_H\n+#define BITCOIN_LOG_H\n+\n+#include \"bitcointime.h\"\n+\n+#include <fstream>\n+#include <ostream>\n+#include <sstream>\n+#include <string>\n+#include <vector>\n+\n+#include <boost/thread/once.hpp>\n+#include <boost/thread/mutex.hpp>\n+\n+class StaticLogMembers;\n+\n+\n+class Log\n+{\n+    public:\n+        Log(const std::string& category = \"\");\n+\n+        // Must log strings specially since they can contain new lines\n+        Log& operator<<(const char* message) { return operator<<(std::string(message)); }\n+\n+        // Value types\n+        Log& operator<<(bool   n) { return insert(n); }\n+        Log& operator<<(float  n) { return insert(n); }\n+        Log& operator<<(double n) { return insert(n); }\n+        Log& operator<<(void*  n) { return insert(n); }\n+\n+        Log& operator<<(char      n) { return insert(n); }\n+        Log& operator<<(short     n) { return insert(n); }\n+        Log& operator<<(int       n) { return insert(n); }\n+        Log& operator<<(long      n) { return insert(n); }\n+        Log& operator<<(long long n) { return insert(n); }\n+\n+        Log& operator<<(unsigned char      n) { return insert(n); }\n+        Log& operator<<(unsigned short     n) { return insert(n); }\n+        Log& operator<<(unsigned int       n) { return insert(n); }\n+        Log& operator<<(unsigned long      n) { return insert(n); }\n+        Log& operator<<(unsigned long long n) { return insert(n); }\n+\n+        // catch-all\n+        template <typename T> Log& operator<<(const T& message) { return insert(message); }\n+\n+        static bool fDebug;\n+        static bool fPrintToConsole;\n+        static bool fPrintToDebugger;\n+        static bool fLogTimestamps;\n+        static volatile bool fReopenDebugLog;\n+        static bool fStartedNewLine;\n+\n+    private:\n+        \n+        // String implementation\n+        Log& insert(const std::string& message);\n+\n+        // Non-string implementation\n+        template <typename T> Log& insert(const T& message);\n+\n+        static void StaticLogMembersInit();\n+        static void FileoutInit();\n+\n+        std::vector<std::ostream*> vLogStreams;\n+\n+        // We use boost::call_once() to make sure these are initialized in a\n+        //   thread-safe manner, the first time their respective members are used:\n+        static boost::once_flag initStaticLogMembersFlag;\n+        static boost::once_flag initFileoutFlag;\n+\n+        // Static variables that require class construction MUST be contained\n+        //   within the StaticLogMembers singleton class.\n+        //\n+        // Since the destruction order of static variables is undefined and\n+        //   some static classes call Log functions upon their own destruction, \n+        //   we must define our static class members in a way that they are\n+        //   never destructed.\n+        static StaticLogMembers* slm;\n+};\n+\n+\n+// Singleton class to be constructed just in time for the Log class, \n+//   and only for the Log class\n+class StaticLogMembers\n+{\n+    friend class Log;\n+\n+    private:\n+        StaticLogMembers() { }\n+\n+        std::ofstream fileout;\n+        \n+        boost::mutex mutexDebugLog;\n+\n+#ifdef WIN32\n+        std::ostringstream windowsDebugLog;\n+#endif\n+};\n+\n+\n+// Just insert data into stream for non-strings\n+template <typename T> \n+Log& Log::insert(const T& message)\n+{\n+    boost::mutex::scoped_lock scoped_lock(slm->mutexDebugLog);\n+\n+    for (std::vector<std::ostream*>::iterator it = vLogStreams.begin(); it != vLogStreams.end(); ++it)\n+    {\n+        if (*it == &slm->fileout)\n+        {\n+            // Debug print useful for profiling\n+            if (fLogTimestamps && fStartedNewLine)\n+                **it << BitcoinTime::DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", BitcoinTime::GetTime()) << \" \";\n+            \n+            fStartedNewLine = false;\n+        }\n+        **it << message << std::flush;\n+    }\n+\n+    return *this;\n+}\n+\n+#endif"
      },
      {
        "sha": "6637482a94ddccdc6dc576ed1d4521bcdcd82292",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 512,
        "deletions": 308,
        "changes": 820,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -7,22 +7,26 @@\n \n #include \"addrman.h\"\n #include \"alert.h\"\n+#include \"bitcointime.h\"\n #include \"chainparams.h\"\n #include \"checkpoints.h\"\n #include \"checkqueue.h\"\n+#include \"core.h\"\n #include \"init.h\"\n #include \"net.h\"\n #include \"txdb.h\"\n #include \"txmempool.h\"\n #include \"ui_interface.h\"\n #include \"util.h\"\n \n-#include <inttypes.h>\n+#include <iomanip>\n+#include <ios>\n #include <sstream>\n \n #include <boost/algorithm/string/replace.hpp>\n #include <boost/filesystem.hpp>\n #include <boost/filesystem/fstream.hpp>\n+#include <boost/format.hpp>\n \n using namespace std;\n using namespace boost;\n@@ -256,16 +260,15 @@ bool AddOrphanTx(const CTransaction& tx)\n     unsigned int sz = tx.GetSerializeSize(SER_NETWORK, CTransaction::CURRENT_VERSION);\n     if (sz > 5000)\n     {\n-        LogPrint(\"mempool\", \"ignoring large orphan tx (size: %u, hash: %s)\\n\", sz, hash.ToString().c_str());\n+        Log(\"mempool\") << \"ignoring large orphan tx (size: \" << sz << \", hash: \" << hash.ToString() << \")\\n\";\n         return false;\n     }\n \n     mapOrphanTransactions[hash] = tx;\n     BOOST_FOREACH(const CTxIn& txin, tx.vin)\n         mapOrphanTransactionsByPrev[txin.prevout.hash].insert(hash);\n \n-    LogPrint(\"mempool\", \"stored orphan tx %s (mapsz %\"PRIszu\")\\n\", hash.ToString().c_str(),\n-        mapOrphanTransactions.size());\n+    Log(\"mempool\") << \"stored orphan tx \" << hash.ToString() << \" (mapsz \" << mapOrphanTransactions.size() << \")\\n\";\n     return true;\n }\n \n@@ -374,7 +377,7 @@ bool IsFinalTx(const CTransaction &tx, int nBlockHeight, int64_t nBlockTime)\n     if (nBlockHeight == 0)\n         nBlockHeight = chainActive.Height();\n     if (nBlockTime == 0)\n-        nBlockTime = GetAdjustedTime();\n+        nBlockTime = BitcoinTime::GetAdjustedTime();\n     if ((int64_t)tx.nLockTime < ((int64_t)tx.nLockTime < LOCKTIME_THRESHOLD ? (int64_t)nBlockHeight : nBlockTime))\n         return true;\n     BOOST_FOREACH(const CTxIn& txin, tx.vin)\n@@ -505,7 +508,7 @@ int CMerkleTx::SetMerkleBranch(const CBlock* pblock)\n         {\n             vMerkleBranch.clear();\n             nIndex = -1;\n-            LogPrintf(\"ERROR: SetMerkleBranch() : couldn't find tx in block\\n\");\n+            Log() << \"ERROR: SetMerkleBranch() : couldn't find tx in block\\n\";\n             return 0;\n         }\n \n@@ -534,54 +537,74 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state)\n {\n     // Basic checks that don't depend on any context\n     if (tx.vin.empty())\n-        return state.DoS(10, error(\"CheckTransaction() : vin empty\"),\n-                         REJECT_INVALID, \"vin empty\");\n+    {\n+        Log() << \"ERROR: CheckTransaction() : vin empty\\n\";\n+        return state.DoS(10, false, REJECT_INVALID, \"vin empty\");\n+    }\n     if (tx.vout.empty())\n-        return state.DoS(10, error(\"CheckTransaction() : vout empty\"),\n-                         REJECT_INVALID, \"vout empty\");\n+    {\n+        Log() << \"ERROR: CheckTransaction() : vout empty\\n\";\n+        return state.DoS(10, false, REJECT_INVALID, \"vout empty\");\n+    }\n     // Size limits\n     if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n-        return state.DoS(100, error(\"CheckTransaction() : size limits failed\"),\n-                         REJECT_INVALID, \"oversize\");\n+    {\n+        Log() << \"ERROR: CheckTransaction() : size limits failed\\n\";\n+        return state.DoS(100, false, REJECT_INVALID, \"oversize\");\n+    }\n \n     // Check for negative or overflow output values\n     int64_t nValueOut = 0;\n     BOOST_FOREACH(const CTxOut& txout, tx.vout)\n     {\n         if (txout.nValue < 0)\n-            return state.DoS(100, error(\"CheckTransaction() : txout.nValue negative\"),\n-                             REJECT_INVALID, \"vout negative\");\n+        {\n+            Log() << \"ERROR: CheckTransaction() : txout.nValue negative\\n\";\n+            return state.DoS(100, false, REJECT_INVALID, \"vout negative\");\n+        }\n         if (txout.nValue > MAX_MONEY)\n-            return state.DoS(100, error(\"CheckTransaction() : txout.nValue too high\"),\n-                             REJECT_INVALID, \"vout too large\");\n+        {\n+            Log() << \"ERROR: CheckTransaction() : txout.nValue too high\\n\";\n+            return state.DoS(100, false, REJECT_INVALID, \"vout too large\");\n+        }\n         nValueOut += txout.nValue;\n         if (!MoneyRange(nValueOut))\n-            return state.DoS(100, error(\"CheckTransaction() : txout total out of range\"),\n-                             REJECT_INVALID, \"txout total too large\");\n+        {\n+            Log() << \"ERROR: CheckTransaction() : txout total out of range\\n\";\n+            return state.DoS(100, false, REJECT_INVALID, \"txout total too large\");\n+        }\n     }\n \n     // Check for duplicate inputs\n     set<COutPoint> vInOutPoints;\n     BOOST_FOREACH(const CTxIn& txin, tx.vin)\n     {\n         if (vInOutPoints.count(txin.prevout))\n-            return state.DoS(100, error(\"CheckTransaction() : duplicate inputs\"),\n-                             REJECT_INVALID, \"duplicate inputs\");\n+        {\n+            Log() << \"ERROR: CheckTransaction() : duplicate inputs\\n\";\n+            return state.DoS(100, false, REJECT_INVALID, \"duplicate inputs\");\n+        }\n         vInOutPoints.insert(txin.prevout);\n     }\n \n     if (tx.IsCoinBase())\n     {\n         if (tx.vin[0].scriptSig.size() < 2 || tx.vin[0].scriptSig.size() > 100)\n-            return state.DoS(100, error(\"CheckTransaction() : coinbase script size\"),\n-                             REJECT_INVALID, \"coinbase script too large\");\n+        {\n+            Log() << \"ERROR: CheckTransaction() : coinbase script size\\n\";\n+            return state.DoS(100, false, REJECT_INVALID, \"coinbase script too large\");\n+        }\n     }\n     else\n     {\n         BOOST_FOREACH(const CTxIn& txin, tx.vin)\n+        {\n             if (txin.prevout.IsNull())\n-                return state.DoS(10, error(\"CheckTransaction() : prevout is null\"),\n-                                 REJECT_INVALID, \"prevout null\");\n+            {\n+                Log() << \"ERROR: CheckTransaction() : prevout is null\\n\";\n+                return state.DoS(10, false, REJECT_INVALID, \"prevout null\");\n+            }\n+        }\n     }\n \n     return true;\n@@ -629,19 +652,25 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         *pfMissingInputs = false;\n \n     if (!CheckTransaction(tx, state))\n-        return error(\"AcceptToMemoryPool: : CheckTransaction failed\");\n+    {\n+        Log() << \"ERROR: AcceptToMemoryPool: : CheckTransaction failed\\n\";\n+        return false;\n+    }\n \n     // Coinbase is only valid in a block, not as a loose transaction\n     if (tx.IsCoinBase())\n-        return state.DoS(100, error(\"AcceptToMemoryPool: : coinbase as individual tx\"),\n-                         REJECT_INVALID, \"coinbase\");\n+    {\n+        Log() << \"ERROR: AcceptToMemoryPool: : coinbase as individual tx\\n\";\n+        return state.DoS(100, false, REJECT_INVALID, \"coinbase\");\n+    }\n \n     // Rather not work on nonstandard transactions (unless -testnet/-regtest)\n     string reason;\n     if (Params().NetworkID() == CChainParams::MAIN && !IsStandardTx(tx, reason))\n-        return state.DoS(0,\n-                         error(\"AcceptToMemoryPool : nonstandard transaction: %s\", reason.c_str()),\n-                         REJECT_NONSTANDARD, reason);\n+    {\n+        Log() << \"ERROR: AcceptToMemoryPool : nonstandard transaction: \" << reason.c_str() << \"\\n\";\n+        return state.DoS(0, false, REJECT_NONSTANDARD, reason);\n+    }\n \n     // is it already in the memory pool?\n     uint256 hash = tx.GetHash();\n@@ -688,8 +717,10 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n \n         // are the actual inputs available?\n         if (!view.HaveInputs(tx))\n-            return state.Invalid(error(\"AcceptToMemoryPool : inputs already spent\"),\n-                                 REJECT_DUPLICATE, \"inputs spent\");\n+        {\n+            Log() << \"ERROR: AcceptToMemoryPool : inputs already spent\\n\";\n+            return state.Invalid(false, REJECT_DUPLICATE, \"inputs spent\");\n+        }\n \n         // Bring the best block into scope\n         view.GetBestBlock();\n@@ -700,7 +731,10 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n \n         // Check for non-standard pay-to-script-hash in inputs\n         if (Params().NetworkID() == CChainParams::MAIN && !AreInputsStandard(tx, view))\n-            return error(\"AcceptToMemoryPool: : nonstandard transaction input\");\n+        {\n+            Log() << \"ERROR: AcceptToMemoryPool: : nonstandard transaction input\\n\";\n+            return false;\n+        }\n \n         // Note: if you modify this code to accept non-standard transactions, then\n         // you should add code here to check that the transaction does a\n@@ -711,15 +745,16 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         int64_t nFees = nValueIn-nValueOut;\n         double dPriority = view.GetPriority(tx, chainActive.Height());\n \n-        CTxMemPoolEntry entry(tx, nFees, GetTime(), dPriority, chainActive.Height());\n+        CTxMemPoolEntry entry(tx, nFees, BitcoinTime::GetTime(), dPriority, chainActive.Height());\n         unsigned int nSize = entry.GetTxSize();\n \n         // Don't accept it if it can't get into a block\n         int64_t txMinFee = GetMinFee(tx, nSize, true, GMF_RELAY);\n         if (fLimitFree && nFees < txMinFee)\n-            return state.DoS(0, error(\"AcceptToMemoryPool : not enough fees %s, %\"PRId64\" < %\"PRId64,\n-                                      hash.ToString().c_str(), nFees, txMinFee),\n-                             REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n+        {\n+            Log() << \"ERROR: AcceptToMemoryPool : not enough fees \" << hash.ToString() << \", \" << nFees << \" < \" << txMinFee << \"\\n\";\n+            return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n+        }\n \n         // Continuously rate-limit free transactions\n         // This mitigates 'penny-flooding' -- sending thousands of free transactions just to\n@@ -729,7 +764,7 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n             static CCriticalSection csFreeLimiter;\n             static double dFreeCount;\n             static int64_t nLastTime;\n-            int64_t nNow = GetTime();\n+            int64_t nNow = BitcoinTime::GetTime();\n \n             LOCK(csFreeLimiter);\n \n@@ -739,22 +774,26 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n             // -limitfreerelay unit is thousand-bytes-per-minute\n             // At default rate it would take over a month to fill 1GB\n             if (dFreeCount >= GetArg(\"-limitfreerelay\", 15)*10*1000)\n-                return state.DoS(0, error(\"AcceptToMemoryPool : free transaction rejected by rate limiter\"),\n-                                 REJECT_INSUFFICIENTFEE, \"insufficient priority\");\n-            LogPrint(\"mempool\", \"Rate limit dFreeCount: %g => %g\\n\", dFreeCount, dFreeCount+nSize);\n+            {\n+                Log() << \"ERROR: AcceptToMemoryPool : free transaction rejected by rate limiter\\n\";\n+                return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"insufficient priority\");\n+            }\n+            Log(\"mempool\") << \"Rate limit dFreeCount: \" << dFreeCount << \" => \" << (dFreeCount + nSize) << \"\\n\";\n             dFreeCount += nSize;\n         }\n \n         if (fRejectInsaneFee && nFees > CTransaction::nMinRelayTxFee * 10000)\n-            return error(\"AcceptToMemoryPool: : insane fees %s, %\"PRId64\" > %\"PRId64,\n-                         hash.ToString().c_str(),\n-                         nFees, CTransaction::nMinRelayTxFee * 10000);\n+        {\n+            Log() << \"ERROR: AcceptToMemoryPool: : insane fees \" << hash.ToString() << \", \" << nFees << \" > \" << (CTransaction::nMinRelayTxFee * 10000) << \"\\n\";\n+            return false;\n+        }\n \n         // Check against previous transactions\n         // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n         if (!CheckInputs(tx, state, view, true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC))\n         {\n-            return error(\"AcceptToMemoryPool: : ConnectInputs failed %s\", hash.ToString().c_str());\n+            Log() << \"ERROR: \" << \"AcceptToMemoryPool: : ConnectInputs failed \" << hash.ToString() << \"\\n\";\n+            return false;\n         }\n         // Store transaction in memory\n         pool.addUnchecked(hash, entry);\n@@ -830,11 +869,15 @@ bool GetTransaction(const uint256 &hash, CTransaction &txOut, uint256 &hashBlock\n                     fseek(file, postx.nTxOffset, SEEK_CUR);\n                     file >> txOut;\n                 } catch (std::exception &e) {\n-                    return error(\"%s() : deserialize or I/O error\", __PRETTY_FUNCTION__);\n+                    Log() << \"ERROR: \" << __PRETTY_FUNCTION__ << \"() : deserialize or I/O error\\n\";\n+                    return false;\n                 }\n                 hashBlock = header.GetHash();\n                 if (txOut.GetHash() != hash)\n-                    return error(\"%s() : txid mismatch\", __PRETTY_FUNCTION__);\n+                {\n+                    Log() << \"ERROR: \" << __PRETTY_FUNCTION__ << \"() : txid mismatch\\n\";\n+                    return false;\n+                }\n                 return true;\n             }\n         }\n@@ -883,7 +926,10 @@ bool WriteBlockToDisk(CBlock& block, CDiskBlockPos& pos)\n     // Open history file to append\n     CAutoFile fileout = CAutoFile(OpenBlockFile(pos), SER_DISK, CLIENT_VERSION);\n     if (!fileout)\n-        return error(\"WriteBlockToDisk() : OpenBlockFile failed\");\n+    {\n+        Log() << \"ERROR: WriteBlockToDisk() : OpenBlockFile failed\\n\";\n+        return false;\n+    }\n \n     // Write index header\n     unsigned int nSize = fileout.GetSerializeSize(block);\n@@ -892,7 +938,10 @@ bool WriteBlockToDisk(CBlock& block, CDiskBlockPos& pos)\n     // Write block\n     long fileOutPos = ftell(fileout);\n     if (fileOutPos < 0)\n-        return error(\"WriteBlockToDisk() : ftell failed\");\n+    {\n+        Log() << \"ERROR: WriteBlockToDisk() : ftell failed\\n\";\n+        return false;\n+    }\n     pos.nPos = (unsigned int)fileOutPos;\n     fileout << block;\n \n@@ -911,19 +960,26 @@ bool ReadBlockFromDisk(CBlock& block, const CDiskBlockPos& pos)\n     // Open history file to read\n     CAutoFile filein = CAutoFile(OpenBlockFile(pos, true), SER_DISK, CLIENT_VERSION);\n     if (!filein)\n-        return error(\"ReadBlockFromDisk(CBlock&, CDiskBlockPos&) : OpenBlockFile failed\");\n+    {\n+        Log() << \"ERROR: ReadBlockFromDisk(CBlock&, CDiskBlockPos&) : OpenBlockFile failed\\n\";\n+        return false;\n+    }\n \n     // Read block\n     try {\n         filein >> block;\n     }\n     catch (std::exception &e) {\n-        return error(\"%s() : deserialize or I/O error\", __PRETTY_FUNCTION__);\n+        Log() << \"ERROR: \" << __PRETTY_FUNCTION__ << \"() : deserialize or I/O error\\n\";\n+        return false;\n     }\n \n     // Check the header\n     if (!CheckProofOfWork(block.GetHash(), block.nBits))\n-        return error(\"ReadBlockFromDisk(CBlock&, CDiskBlockPos&) : errors in block header\");\n+    {\n+        Log() << \"ERROR: ReadBlockFromDisk(CBlock&, CDiskBlockPos&) : errors in block header\\n\";\n+        return false;\n+    }\n \n     return true;\n }\n@@ -933,7 +989,10 @@ bool ReadBlockFromDisk(CBlock& block, const CBlockIndex* pindex)\n     if (!ReadBlockFromDisk(block, pindex->GetBlockPos()))\n         return false;\n     if (block.GetHash() != pindex->GetBlockHash())\n-        return error(\"ReadBlockFromDisk(CBlock&, CBlockIndex*) : GetHash() doesn't match index\");\n+    {\n+        Log() << \"ERROR: ReadBlockFromDisk(CBlock&, CBlockIndex*) : GetHash() doesn't match index\\n\";\n+        return false;\n+    }\n     return true;\n }\n \n@@ -1023,7 +1082,7 @@ unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlockHead\n \n     // Limit adjustment step\n     int64_t nActualTimespan = pindexLast->GetBlockTime() - pindexFirst->GetBlockTime();\n-    LogPrintf(\"  nActualTimespan = %\"PRId64\"  before bounds\\n\", nActualTimespan);\n+    Log() << \"  nActualTimespan = \" << nActualTimespan << \"  before bounds\\n\";\n     if (nActualTimespan < nTargetTimespan/4)\n         nActualTimespan = nTargetTimespan/4;\n     if (nActualTimespan > nTargetTimespan*4)\n@@ -1039,10 +1098,10 @@ unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlockHead\n         bnNew = Params().ProofOfWorkLimit();\n \n     /// debug print\n-    LogPrintf(\"GetNextWorkRequired RETARGET\\n\");\n-    LogPrintf(\"nTargetTimespan = %\"PRId64\"    nActualTimespan = %\"PRId64\"\\n\", nTargetTimespan, nActualTimespan);\n-    LogPrintf(\"Before: %08x  %s\\n\", pindexLast->nBits, CBigNum().SetCompact(pindexLast->nBits).getuint256().ToString().c_str());\n-    LogPrintf(\"After:  %08x  %s\\n\", bnNew.GetCompact(), bnNew.getuint256().ToString().c_str());\n+    Log() << \"GetNextWorkRequired RETARGET\\n\";\n+    Log() << \"nTargetTimespan = \" << nTargetTimespan << \"    nActualTimespan = \" << nActualTimespan << \"\\n\";\n+    Log() << \"Before: \" << boost::format(\"%08x\") % pindexLast->nBits << \"  \" << CBigNum().SetCompact(pindexLast->nBits).getuint256().ToString() << \"\\n\";\n+    Log() << \"After:  \" << boost::format(\"%08x\") % bnNew.GetCompact() << \"  \" << bnNew.getuint256().ToString() << \"\\n\";\n \n     return bnNew.GetCompact();\n }\n@@ -1054,11 +1113,17 @@ bool CheckProofOfWork(uint256 hash, unsigned int nBits)\n \n     // Check range\n     if (bnTarget <= 0 || bnTarget > Params().ProofOfWorkLimit())\n-        return error(\"CheckProofOfWork() : nBits below minimum work\");\n+    {\n+        Log() << \"ERROR: CheckProofOfWork() : nBits below minimum work\\n\";\n+        return false;\n+    }\n \n     // Check proof of work matches claimed amount\n     if (hash > bnTarget.getuint256())\n-        return error(\"CheckProofOfWork() : hash doesn't match nBits\");\n+    {\n+        Log() << \"ERROR: CheckProofOfWork() : hash doesn't match nBits\\n\";\n+        return false;\n+    }\n \n     return true;\n }\n@@ -1078,10 +1143,10 @@ bool IsInitialBlockDownload()\n     if (chainActive.Tip() != pindexLastBest)\n     {\n         pindexLastBest = chainActive.Tip();\n-        nLastUpdate = GetTime();\n+        nLastUpdate = BitcoinTime::GetTime();\n     }\n-    return (GetTime() - nLastUpdate < 10 &&\n-            chainActive.Tip()->GetBlockTime() < GetTime() - 24 * 60 * 60);\n+    return (BitcoinTime::GetTime() - nLastUpdate < 10 &&\n+            chainActive.Tip()->GetBlockTime() < BitcoinTime::GetTime() - 24 * 60 * 60);\n }\n \n bool fLargeWorkForkFound = false;\n@@ -1115,14 +1180,15 @@ void CheckForkWarningConditions()\n         }\n         if (pindexBestForkTip)\n         {\n-            LogPrintf(\"CheckForkWarningConditions: Warning: Large valid fork found\\n  forking the chain at height %d (%s)\\n  lasting to height %d (%s).\\nChain state database corruption likely.\\n\",\n-                   pindexBestForkBase->nHeight, pindexBestForkBase->phashBlock->ToString().c_str(),\n-                   pindexBestForkTip->nHeight, pindexBestForkTip->phashBlock->ToString().c_str());\n+            Log() << \"CheckForkWarningConditions: Warning: Large valid fork found\\n\"\n+                  << \"  forking the chain at height \" << pindexBestForkBase->nHeight << \" (\" << pindexBestForkBase->phashBlock->ToString() << \")\\n\" \n+                  << \"  lasting to height \" << pindexBestForkTip->nHeight << \" (\" << pindexBestForkTip->phashBlock->ToString() << \").\\n\"\n+                  << \"Chain state database corruption likely.\\n\";\n             fLargeWorkForkFound = true;\n         }\n         else\n         {\n-            LogPrintf(\"CheckForkWarningConditions: Warning: Found invalid chain at least ~6 blocks longer than our best chain.\\nChain state database corruption likely.\\n\");\n+            Log() << \"CheckForkWarningConditions: Warning: Found invalid chain at least ~6 blocks longer than our best chain.\\nChain state database corruption likely.\\n\";\n             fLargeWorkInvalidChainFound = true;\n         }\n     }\n@@ -1176,13 +1242,10 @@ void static InvalidChainFound(CBlockIndex* pindexNew)\n         pblocktree->WriteBestInvalidWork(CBigNum(pindexBestInvalid->nChainWork));\n         uiInterface.NotifyBlocksChanged();\n     }\n-    LogPrintf(\"InvalidChainFound: invalid block=%s  height=%d  log2_work=%.8g  date=%s\\n\",\n-      pindexNew->GetBlockHash().ToString().c_str(), pindexNew->nHeight,\n-      log(pindexNew->nChainWork.getdouble())/log(2.0), DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\",\n-      pindexNew->GetBlockTime()).c_str());\n-    LogPrintf(\"InvalidChainFound:  current best=%s  height=%d  log2_work=%.8g  date=%s\\n\",\n-      chainActive.Tip()->GetBlockHash().ToString().c_str(), chainActive.Height(), log(chainActive.Tip()->nChainWork.getdouble())/log(2.0),\n-      DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", chainActive.Tip()->GetBlockTime()).c_str());\n+    Log() << \"InvalidChainFound: invalid block=\" << pindexNew->GetBlockHash().ToString() << \"  height=\" << pindexNew->nHeight \n+                          << \"  log2_work=\" << setprecision(8) << log(pindexNew->nChainWork.getdouble())/log(2.0) << \"  date=\" << BitcoinTime::DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", pindexNew->GetBlockTime()) << \"\\n\";\n+    Log() << \"InvalidChainFound:  current best=\" << chainActive.Tip()->GetBlockHash().ToString() << \"  height=\" << chainActive.Height()\n+                          << \"  log2_work=\" << setprecision(8) << log(chainActive.Tip()->nChainWork.getdouble())/log(2.0) << \"  date=\" << BitcoinTime::DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", chainActive.Tip()->GetBlockTime()) << \"\\n\";\n     CheckForkWarningConditions();\n }\n \n@@ -1239,7 +1302,7 @@ bool ConnectBestBlock(CValidationState &state) {\n                         if (!SetBestChain(state, pindexSwitch))\n                             return false;\n                     } catch(std::runtime_error &e) {\n-                        return state.Abort(_(\"System error: \") + e.what());\n+                        return state.Abort(_<string>(\"System error: \") + e.what());\n                     }\n                 }\n                 return true;\n@@ -1251,7 +1314,7 @@ bool ConnectBestBlock(CValidationState &state) {\n \n void UpdateTime(CBlockHeader& block, const CBlockIndex* pindexPrev)\n {\n-    block.nTime = max(pindexPrev->GetMedianTimePast()+1, GetAdjustedTime());\n+    block.nTime = max(pindexPrev->GetMedianTimePast()+1, BitcoinTime::GetAdjustedTime());\n \n     // Updating time can change work required on testnet:\n     if (TestNet())\n@@ -1290,7 +1353,10 @@ void UpdateCoins(const CTransaction& tx, CValidationState &state, CCoinsViewCach\n bool CScriptCheck::operator()() const {\n     const CScript &scriptSig = ptxTo->vin[nIn].scriptSig;\n     if (!VerifyScript(scriptSig, scriptPubKey, *ptxTo, nIn, nFlags, nHashType))\n-        return error(\"CScriptCheck() : %s VerifySignature failed\", ptxTo->GetHash().ToString().c_str());\n+    {\n+        Log() << \"ERROR: \" << \"CScriptCheck() : \" << ptxTo->GetHash().ToString() << \" VerifySignature failed\\n\";\n+        return false;\n+    }\n     return true;\n }\n \n@@ -1309,7 +1375,10 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, CCoinsViewCach\n         // This doesn't trigger the DoS code on purpose; if it did, it would make it easier\n         // for an attacker to attempt to split the network.\n         if (!inputs.HaveInputs(tx))\n-            return state.Invalid(error(\"CheckInputs() : %s inputs unavailable\", tx.GetHash().ToString().c_str()));\n+        {\n+            Log() << \"ERROR: \" << \"CheckInputs() : \" << tx.GetHash().ToString() << \" inputs unavailable\\n\";\n+            return state.Invalid(false);\n+        }\n \n         // While checking, GetBestBlock() refers to the parent block.\n         // This is also true for mempool checks.\n@@ -1325,32 +1394,40 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, CCoinsViewCach\n             // If prev is coinbase, check that it's matured\n             if (coins.IsCoinBase()) {\n                 if (nSpendHeight - coins.nHeight < COINBASE_MATURITY)\n-                    return state.Invalid(\n-                        error(\"CheckInputs() : tried to spend coinbase at depth %d\", nSpendHeight - coins.nHeight),\n-                        REJECT_INVALID, \"premature spend of coinbase\");\n+                {\n+                    Log() << \"ERROR: \" << \"CheckInputs() : tried to spend coinbase at depth \" << (nSpendHeight - coins.nHeight) << \"\\n\";\n+                    return state.Invalid(false, REJECT_INVALID, \"premature spend of coinbase\");\n+                }\n             }\n \n             // Check for negative or overflow input values\n             nValueIn += coins.vout[prevout.n].nValue;\n             if (!MoneyRange(coins.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n-                return state.DoS(100, error(\"CheckInputs() : txin values out of range\"),\n-                                 REJECT_INVALID, \"input values out of range\");\n-\n+            {\n+                Log() << \"ERROR: CheckInputs() : txin values out of range\\n\";\n+                return state.DoS(100, false, REJECT_INVALID, \"input values out of range\");\n+            }\n         }\n \n         if (nValueIn < tx.GetValueOut())\n-            return state.DoS(100, error(\"CheckInputs() : %s value in < value out\", tx.GetHash().ToString().c_str()),\n-                             REJECT_INVALID, \"in < out\");\n+        {\n+            Log() << \"ERROR: \" << \"CheckInputs() : \" << tx.GetHash().ToString() << \" value in < value out\\n\";\n+            return state.DoS(100, false, REJECT_INVALID, \"in < out\");\n+        }\n \n         // Tally transaction fees\n         int64_t nTxFee = nValueIn - tx.GetValueOut();\n         if (nTxFee < 0)\n-            return state.DoS(100, error(\"CheckInputs() : %s nTxFee < 0\", tx.GetHash().ToString().c_str()),\n-                             REJECT_INVALID, \"fee < 0\");\n+        {\n+            Log() << \"ERROR: \" << \"CheckInputs() : \" << tx.GetHash().ToString() << \" nTxFee < 0\\n\";\n+            return state.DoS(100, false, REJECT_INVALID, \"fee < 0\");\n+        }\n         nFees += nTxFee;\n         if (!MoneyRange(nFees))\n-            return state.DoS(100, error(\"CheckInputs() : nFees out of range\"),\n-                             REJECT_INVALID, \"fee out of range\");\n+        {\n+            Log() << \"ERROR: CheckInputs() : nFees out of range\\n\";\n+            return state.DoS(100, false, REJECT_INVALID, \"fee out of range\");\n+        }\n \n         // The first loop above does all the inexpensive checks.\n         // Only if ALL inputs pass do we perform expensive ECDSA signature checks.\n@@ -1400,12 +1477,21 @@ bool DisconnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex\n     CBlockUndo blockUndo;\n     CDiskBlockPos pos = pindex->GetUndoPos();\n     if (pos.IsNull())\n-        return error(\"DisconnectBlock() : no undo data available\");\n+    {\n+        Log() << \"ERROR: DisconnectBlock() : no undo data available\\n\";\n+        return false;\n+    }\n     if (!blockUndo.ReadFromDisk(pos, pindex->pprev->GetBlockHash()))\n-        return error(\"DisconnectBlock() : failure reading undo data\");\n+    {\n+        Log() << \"ERROR: DisconnectBlock() : failure reading undo data\\n\";\n+        return false;\n+    }\n \n     if (blockUndo.vtxundo.size() + 1 != block.vtx.size())\n-        return error(\"DisconnectBlock() : block and undo data inconsistent\");\n+    {\n+        Log() << \"ERROR: DisconnectBlock() : block and undo data inconsistent\\n\";\n+        return false;\n+    }\n \n     // undo transactions in reverse order\n     for (int i = block.vtx.size() - 1; i >= 0; i--) {\n@@ -1427,7 +1513,10 @@ bool DisconnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex\n         if (outsBlock.nVersion < 0)\n             outs.nVersion = outsBlock.nVersion;\n         if (outs != outsBlock)\n-            fClean = fClean && error(\"DisconnectBlock() : added transaction mismatch? database corrupted\");\n+        {\n+            Log() << \"ERROR: DisconnectBlock() : added transaction mismatch? database corrupted\\n\";\n+            fClean = false;\n+        }\n \n         // remove outputs\n         outs = CCoins();\n@@ -1436,7 +1525,10 @@ bool DisconnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex\n         if (i > 0) { // not coinbases\n             const CTxUndo &txundo = blockUndo.vtxundo[i-1];\n             if (txundo.vprevout.size() != tx.vin.size())\n-                return error(\"DisconnectBlock() : transaction and undo data inconsistent\");\n+            {\n+                Log() << \"ERROR: DisconnectBlock() : transaction and undo data inconsistent\\n\";\n+                return false;\n+            }\n             for (unsigned int j = tx.vin.size(); j-- > 0;) {\n                 const COutPoint &out = tx.vin[j].prevout;\n                 const CTxInUndo &undo = txundo.vprevout[j];\n@@ -1445,22 +1537,34 @@ bool DisconnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex\n                 if (undo.nHeight != 0) {\n                     // undo data contains height: this is the last output of the prevout tx being spent\n                     if (!coins.IsPruned())\n-                        fClean = fClean && error(\"DisconnectBlock() : undo data overwriting existing transaction\");\n+                    {\n+                        Log() << \"ERROR: DisconnectBlock() : undo data overwriting existing transaction\\n\";\n+                        fClean = false;\n+                    }\n                     coins = CCoins();\n                     coins.fCoinBase = undo.fCoinBase;\n                     coins.nHeight = undo.nHeight;\n                     coins.nVersion = undo.nVersion;\n                 } else {\n                     if (coins.IsPruned())\n-                        fClean = fClean && error(\"DisconnectBlock() : undo data adding output to missing transaction\");\n+                    {\n+                        Log() << \"ERROR: DisconnectBlock() : undo data adding output to missing transaction\\n\";\n+                        fClean = false;\n+                    }\n                 }\n                 if (coins.IsAvailable(out.n))\n-                    fClean = fClean && error(\"DisconnectBlock() : undo data overwriting existing output\");\n+                {\n+                    Log() << \"ERROR: DisconnectBlock() : undo data overwriting existing output\\n\";\n+                    fClean = false;\n+                }\n                 if (coins.vout.size() < out.n+1)\n                     coins.vout.resize(out.n+1);\n                 coins.vout[out.n] = undo.txout;\n                 if (!view.SetCoins(out.hash, coins))\n-                    return error(\"DisconnectBlock() : cannot restore coin inputs\");\n+                {\n+                    Log() << \"ERROR: DisconnectBlock() : cannot restore coin inputs\\n\";\n+                    return false;\n+                }\n             }\n         }\n     }\n@@ -1546,8 +1650,10 @@ bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, C\n         for (unsigned int i = 0; i < block.vtx.size(); i++) {\n             uint256 hash = block.GetTxHash(i);\n             if (view.HaveCoins(hash) && !view.GetCoins(hash).IsPruned())\n-                return state.DoS(100, error(\"ConnectBlock() : tried to overwrite transaction\"),\n-                                 REJECT_INVALID, \"BIP30\");\n+            {\n+                Log() << \"ERROR: ConnectBlock() : tried to overwrite transaction\\n\";\n+                return state.DoS(100, false, REJECT_INVALID, \"BIP30\");\n+            }\n         }\n     }\n \n@@ -1562,7 +1668,7 @@ bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, C\n \n     CCheckQueueControl<CScriptCheck> control(fScriptChecks && nScriptCheckThreads ? &scriptcheckqueue : NULL);\n \n-    int64_t nStart = GetTimeMicros();\n+    int64_t nStart = BitcoinTime::GetTimeMicros();\n     int64_t nFees = 0;\n     int nInputs = 0;\n     unsigned int nSigOps = 0;\n@@ -1576,14 +1682,18 @@ bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, C\n         nInputs += tx.vin.size();\n         nSigOps += GetLegacySigOpCount(tx);\n         if (nSigOps > MAX_BLOCK_SIGOPS)\n-            return state.DoS(100, error(\"ConnectBlock() : too many sigops\"),\n-                             REJECT_INVALID, \"too many sigops\");\n+        {\n+            Log() << \"ERROR: ConnectBlock() : too many sigops\\n\";\n+            return state.DoS(100, false, REJECT_INVALID, \"too many sigops\");\n+        }\n \n         if (!tx.IsCoinBase())\n         {\n             if (!view.HaveInputs(tx))\n-                return state.DoS(100, error(\"ConnectBlock() : inputs missing/spent\"),\n-                                 REJECT_INVALID, \"inputs missing/spent\");\n+            {\n+                Log() << \"ERROR: ConnectBlock() : inputs missing/spent\\n\";\n+                return state.DoS(100, false, REJECT_INVALID, \"inputs missing/spent\");\n+            }\n \n             if (fStrictPayToScriptHash)\n             {\n@@ -1592,8 +1702,10 @@ bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, C\n                 // an incredibly-expensive-to-validate block.\n                 nSigOps += GetP2SHSigOpCount(tx, view);\n                 if (nSigOps > MAX_BLOCK_SIGOPS)\n-                    return state.DoS(100, error(\"ConnectBlock() : too many sigops\"),\n-                                     REJECT_INVALID, \"too many sigops\");\n+                {\n+                    Log() << \"ERROR: ConnectBlock() : too many sigops\\n\";\n+                    return state.DoS(100, false, REJECT_INVALID, \"too many sigops\");\n+                }\n             }\n \n             nFees += view.GetValueIn(tx)-tx.GetValueOut();\n@@ -1612,21 +1724,22 @@ bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, C\n         vPos.push_back(std::make_pair(block.GetTxHash(i), pos));\n         pos.nTxOffset += ::GetSerializeSize(tx, SER_DISK, CLIENT_VERSION);\n     }\n-    int64_t nTime = GetTimeMicros() - nStart;\n+    int64_t nTime = BitcoinTime::GetTimeMicros() - nStart;\n     if (fBenchmark)\n-        LogPrintf(\"- Connect %u transactions: %.2fms (%.3fms/tx, %.3fms/txin)\\n\", (unsigned)block.vtx.size(), 0.001 * nTime, 0.001 * nTime / block.vtx.size(), nInputs <= 1 ? 0 : 0.001 * nTime / (nInputs-1));\n+        Log() << \"- Connect \" << (unsigned)block.vtx.size() << \" transactions: \" << fixed << setprecision(2) << (0.001 * nTime) << \"ms\"\n+                              << \" (\" << fixed << setprecision(3) << (0.001 * nTime / block.vtx.size()) << \"ms/tx, \" << fixed << setprecision(3) << (nInputs <= 1 ? 0 : 0.001 * nTime / (nInputs-1)) << \"ms/txin)\\n\";\n \n     if (block.vtx[0].GetValueOut() > GetBlockValue(pindex->nHeight, nFees))\n-        return state.DoS(100,\n-                         error(\"ConnectBlock() : coinbase pays too much (actual=%\"PRId64\" vs limit=%\"PRId64\")\",\n-                               block.vtx[0].GetValueOut(), GetBlockValue(pindex->nHeight, nFees)),\n-                         REJECT_INVALID, \"coinbase too large\");\n+    {\n+        Log() << \"ERROR: ConnectBlock() : coinbase pays too much (actual=\" << block.vtx[0].GetValueOut() << \" vs limit=\" << GetBlockValue(pindex->nHeight, nFees) << \")\\n\";\n+        return state.DoS(100, false, REJECT_INVALID, \"coinbase too large\");\n+    }\n \n     if (!control.Wait())\n         return state.DoS(100, false);\n-    int64_t nTime2 = GetTimeMicros() - nStart;\n+    int64_t nTime2 = BitcoinTime::GetTimeMicros() - nStart;\n     if (fBenchmark)\n-        LogPrintf(\"- Verify %u txins: %.2fms (%.3fms/txin)\\n\", nInputs - 1, 0.001 * nTime2, nInputs <= 1 ? 0 : 0.001 * nTime2 / (nInputs-1));\n+        Log() << \"- Verify \" << (nInputs - 1) << \" txins: \" << fixed << setprecision(2) << (0.001 * nTime2) << \"ms (\" << fixed << setprecision(3) << (nInputs <= 1 ? 0 : 0.001 * nTime2 / (nInputs-1)) << \"ms/txin)\\n\";\n \n     if (fJustCheck)\n         return true;\n@@ -1637,9 +1750,12 @@ bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, C\n         if (pindex->GetUndoPos().IsNull()) {\n             CDiskBlockPos pos;\n             if (!FindUndoPos(state, pindex->nFile, pos, ::GetSerializeSize(blockundo, SER_DISK, CLIENT_VERSION) + 40))\n-                return error(\"ConnectBlock() : FindUndoPos failed\");\n+            {\n+                Log() << \"ERROR: ConnectBlock() : FindUndoPos failed\\n\";\n+                return false;\n+            }\n             if (!blockundo.WriteToDisk(pos, pindex->pprev->GetBlockHash()))\n-                return state.Abort(_(\"Failed to write undo data\"));\n+                return state.Abort(_<string>(\"Failed to write undo data\"));\n \n             // update nUndoPos in block index\n             pindex->nUndoPos = pos.nPos;\n@@ -1650,12 +1766,12 @@ bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, C\n \n         CDiskBlockIndex blockindex(pindex);\n         if (!pblocktree->WriteBlockIndex(blockindex))\n-            return state.Abort(_(\"Failed to write block index\"));\n+            return state.Abort(_<string>(\"Failed to write block index\"));\n     }\n \n     if (fTxIndex)\n         if (!pblocktree->WriteTxIndex(vPos))\n-            return state.Abort(_(\"Failed to write transaction index\"));\n+            return state.Abort(_<string>(\"Failed to write transaction index\"));\n \n     // add this block to the view's block chain\n     bool ret;\n@@ -1706,21 +1822,24 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n     reverse(vConnect.begin(), vConnect.end());\n \n     if (vDisconnect.size() > 0) {\n-        LogPrintf(\"REORGANIZE: Disconnect %\"PRIszu\" blocks; %s...\\n\", vDisconnect.size(), pfork->GetBlockHash().ToString().c_str());\n-        LogPrintf(\"REORGANIZE: Connect %\"PRIszu\" blocks; ...%s\\n\", vConnect.size(), pindexNew->GetBlockHash().ToString().c_str());\n+        Log() << \"REORGANIZE: Disconnect \" << vDisconnect.size() << \" blocks; \" << pfork->GetBlockHash().ToString() << \"...\\n\";\n+        Log() << \"REORGANIZE: Connect \" << vConnect.size() << \" blocks; ...\" << pindexNew->GetBlockHash().ToString() << \"\\n\";\n     }\n \n     // Disconnect shorter branch\n     list<CTransaction> vResurrect;\n     BOOST_FOREACH(CBlockIndex* pindex, vDisconnect) {\n         CBlock block;\n         if (!ReadBlockFromDisk(block, pindex))\n-            return state.Abort(_(\"Failed to read block\"));\n-        int64_t nStart = GetTimeMicros();\n+            return state.Abort(_<string>(\"Failed to read block\"));\n+        int64_t nStart = BitcoinTime::GetTimeMicros();\n         if (!DisconnectBlock(block, state, pindex, view))\n-            return error(\"SetBestBlock() : DisconnectBlock %s failed\", pindex->GetBlockHash().ToString().c_str());\n+        {\n+            Log() << \"ERROR: \" << \"SetBestBlock() : DisconnectBlock \" << pindex->GetBlockHash().ToString() << \" failed\\n\";\n+            return false;\n+        }\n         if (fBenchmark)\n-            LogPrintf(\"- Disconnect: %.2fms\\n\", (GetTimeMicros() - nStart) * 0.001);\n+            Log() << \"- Disconnect: \" << fixed << setprecision(2) << ((BitcoinTime::GetTimeMicros() - nStart) * 0.001) << \"ms\\n\";\n \n         // Queue memory transactions to resurrect.\n         // We only do this for blocks after the last checkpoint (reorganisation before that\n@@ -1735,32 +1854,33 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n     BOOST_FOREACH(CBlockIndex *pindex, vConnect) {\n         CBlock block;\n         if (!ReadBlockFromDisk(block, pindex))\n-            return state.Abort(_(\"Failed to read block\"));\n-        int64_t nStart = GetTimeMicros();\n+            return state.Abort(_<string>(\"Failed to read block\"));\n+        int64_t nStart = BitcoinTime::GetTimeMicros();\n         if (!ConnectBlock(block, state, pindex, view)) {\n             if (state.IsInvalid()) {\n                 InvalidChainFound(pindexNew);\n                 InvalidBlockFound(pindex);\n             }\n-            return error(\"SetBestBlock() : ConnectBlock %s failed\", pindex->GetBlockHash().ToString().c_str());\n+            Log() << \"ERROR: \" << \"SetBestBlock() : ConnectBlock \" << pindex->GetBlockHash().ToString() << \" failed\\n\";\n+            return false;\n         }\n         if (fBenchmark)\n-            LogPrintf(\"- Connect: %.2fms\\n\", (GetTimeMicros() - nStart) * 0.001);\n+            Log() << \"- Connect: \" << fixed << setprecision(2) << ((BitcoinTime::GetTimeMicros() - nStart) * 0.001) << \"ms\\n\";\n \n         // Queue memory transactions to delete\n         BOOST_FOREACH(const CTransaction& tx, block.vtx)\n             vDelete.push_back(tx);\n     }\n \n     // Flush changes to global coin state\n-    int64_t nStart = GetTimeMicros();\n+    int64_t nStart = BitcoinTime::GetTimeMicros();\n     int nModified = view.GetCacheSize();\n     bool ret;\n     ret = view.Flush();\n     assert(ret);\n-    int64_t nTime = GetTimeMicros() - nStart;\n+    int64_t nTime = BitcoinTime::GetTimeMicros() - nStart;\n     if (fBenchmark)\n-        LogPrintf(\"- Flush %i transactions: %.2fms (%.4fms/tx)\\n\", nModified, 0.001 * nTime, 0.001 * nTime / nModified);\n+        Log() << \"- Flush \" << nModified << \" transactions: \" << fixed << setprecision(2) << (0.001 * nTime) << \"ms (\" << fixed << setprecision(4) << (0.001 * nTime / nModified) << \"ms/tx)\\n\";\n \n     // Make sure it's successfully written to disk before changing memory structure\n     bool fIsInitialDownload = IsInitialBlockDownload();\n@@ -1775,7 +1895,7 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n         FlushBlockFile();\n         pblocktree->Sync();\n         if (!pcoinsTip->Flush())\n-            return state.Abort(_(\"Failed to write to coin database\"));\n+            return state.Abort(_<string>(\"Failed to write to coin database\"));\n     }\n \n     // At this point, all changes have been done to the database.\n@@ -1805,12 +1925,11 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n         g_signals.SetBestChain(chainActive.GetLocator(pindexNew));\n \n     // New best block\n-    nTimeBestReceived = GetTime();\n+    nTimeBestReceived = BitcoinTime::GetTime();\n     mempool.AddTransactionsUpdated(1);\n-    LogPrintf(\"SetBestChain: new best=%s  height=%d  log2_work=%.8g  tx=%lu  date=%s progress=%f\\n\",\n-      chainActive.Tip()->GetBlockHash().ToString().c_str(), chainActive.Height(), log(chainActive.Tip()->nChainWork.getdouble())/log(2.0), (unsigned long)pindexNew->nChainTx,\n-      DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", chainActive.Tip()->GetBlockTime()).c_str(),\n-      Checkpoints::GuessVerificationProgress(chainActive.Tip()));\n+    Log() << \"SetBestChain: new best=\" << chainActive.Tip()->GetBlockHash().ToString() << \"  height=\" << chainActive.Height() \n+                          << \"  log2_work=\" << setprecision(8) << (log(chainActive.Tip()->nChainWork.getdouble())/log(2.0)) << \"  tx=\" << (unsigned long)pindexNew->nChainTx\n+                          << \"  date=\" << BitcoinTime::DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", chainActive.Tip()->GetBlockTime()) << \" progress=\" << fixed << Checkpoints::GuessVerificationProgress(chainActive.Tip()) << \"\\n\";\n \n     // Check the version of the last 100 blocks to see if we need to upgrade:\n     if (!fIsInitialDownload)\n@@ -1824,10 +1943,10 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n             pindex = pindex->pprev;\n         }\n         if (nUpgraded > 0)\n-            LogPrintf(\"SetBestChain: %d of last 100 blocks above version %d\\n\", nUpgraded, CBlock::CURRENT_VERSION);\n+            Log() << \"SetBestChain: \" << nUpgraded << \" of last 100 blocks above version \" << CBlock::CURRENT_VERSION << \"\\n\";\n         if (nUpgraded > 100/2)\n             // strMiscWarning is read by GetWarnings(), called by Qt and the JSON-RPC code to warn the user:\n-            strMiscWarning = _(\"Warning: This version is obsolete, upgrade required!\");\n+            strMiscWarning = _<string>(\"Warning: This version is obsolete, upgrade required!\");\n     }\n \n     std::string strCmd = GetArg(\"-blocknotify\", \"\");\n@@ -1847,7 +1966,10 @@ bool AddToBlockIndex(CBlock& block, CValidationState& state, const CDiskBlockPos\n     // Check for duplicate\n     uint256 hash = block.GetHash();\n     if (mapBlockIndex.count(hash))\n-        return state.Invalid(error(\"AddToBlockIndex() : %s already exists\", hash.ToString().c_str()));\n+    {\n+        Log() << \"ERROR: \" << \"AddToBlockIndex() \" << hash.ToString() << \" already exists\\n\";\n+        return state.Invalid(false);\n+    }\n \n     // Construct new block index object\n     CBlockIndex* pindexNew = new CBlockIndex(block);\n@@ -1870,7 +1992,7 @@ bool AddToBlockIndex(CBlock& block, CValidationState& state, const CDiskBlockPos\n     setBlockIndexValid.insert(pindexNew);\n \n     if (!pblocktree->WriteBlockIndex(CDiskBlockIndex(pindexNew)))\n-        return state.Abort(_(\"Failed to write block index\"));\n+        return state.Abort(_<string>(\"Failed to write block index\"));\n \n     // New best?\n     if (!ConnectBestBlock(state))\n@@ -1888,7 +2010,7 @@ bool AddToBlockIndex(CBlock& block, CValidationState& state, const CDiskBlockPos\n         CheckForkWarningConditionsOnNewFork(pindexNew);\n \n     if (!pblocktree->Flush())\n-        return state.Abort(_(\"Failed to sync block index\"));\n+        return state.Abort(_<string>(\"Failed to sync block index\"));\n \n     uiInterface.NotifyBlocksChanged();\n     return true;\n@@ -1910,7 +2032,7 @@ bool FindBlockPos(CValidationState &state, CDiskBlockPos &pos, unsigned int nAdd\n         }\n     } else {\n         while (infoLastBlockFile.nSize + nAddSize >= MAX_BLOCKFILE_SIZE) {\n-            LogPrintf(\"Leaving block file %i: %s\\n\", nLastBlockFile, infoLastBlockFile.ToString().c_str());\n+            Log() << \"Leaving block file \" << nLastBlockFile << \": \" << infoLastBlockFile.ToString() << \"\\n\";\n             FlushBlockFile(true);\n             nLastBlockFile++;\n             infoLastBlockFile.SetNull();\n@@ -1931,7 +2053,7 @@ bool FindBlockPos(CValidationState &state, CDiskBlockPos &pos, unsigned int nAdd\n             if (CheckDiskSpace(nNewChunks * BLOCKFILE_CHUNK_SIZE - pos.nPos)) {\n                 FILE *file = OpenBlockFile(pos);\n                 if (file) {\n-                    LogPrintf(\"Pre-allocating up to position 0x%x in blk%05u.dat\\n\", nNewChunks * BLOCKFILE_CHUNK_SIZE, pos.nFile);\n+                    Log() << \"Pre-allocating up to position 0x\" << boost::format(\"%x\") % (nNewChunks * BLOCKFILE_CHUNK_SIZE) << \" in blk\" << boost::format(\"%05u\") % pos.nFile << \".dat\\n\";\n                     AllocateFileRange(file, pos.nPos, nNewChunks * BLOCKFILE_CHUNK_SIZE - pos.nPos);\n                     fclose(file);\n                 }\n@@ -1942,7 +2064,7 @@ bool FindBlockPos(CValidationState &state, CDiskBlockPos &pos, unsigned int nAdd\n     }\n \n     if (!pblocktree->WriteBlockFileInfo(nLastBlockFile, infoLastBlockFile))\n-        return state.Abort(_(\"Failed to write file info\"));\n+        return state.Abort(_<string>(\"Failed to write file info\"));\n     if (fUpdatedLast)\n         pblocktree->WriteLastBlockFile(nLastBlockFile);\n \n@@ -1960,15 +2082,15 @@ bool FindUndoPos(CValidationState &state, int nFile, CDiskBlockPos &pos, unsigne\n         pos.nPos = infoLastBlockFile.nUndoSize;\n         nNewSize = (infoLastBlockFile.nUndoSize += nAddSize);\n         if (!pblocktree->WriteBlockFileInfo(nLastBlockFile, infoLastBlockFile))\n-            return state.Abort(_(\"Failed to write block info\"));\n+            return state.Abort(_<string>(\"Failed to write block info\"));\n     } else {\n         CBlockFileInfo info;\n         if (!pblocktree->ReadBlockFileInfo(nFile, info))\n-            return state.Abort(_(\"Failed to read block info\"));\n+            return state.Abort(_<string>(\"Failed to read block info\"));\n         pos.nPos = info.nUndoSize;\n         nNewSize = (info.nUndoSize += nAddSize);\n         if (!pblocktree->WriteBlockFileInfo(nFile, info))\n-            return state.Abort(_(\"Failed to write block info\"));\n+            return state.Abort(_<string>(\"Failed to write block info\"));\n     }\n \n     unsigned int nOldChunks = (pos.nPos + UNDOFILE_CHUNK_SIZE - 1) / UNDOFILE_CHUNK_SIZE;\n@@ -1977,7 +2099,7 @@ bool FindUndoPos(CValidationState &state, int nFile, CDiskBlockPos &pos, unsigne\n         if (CheckDiskSpace(nNewChunks * UNDOFILE_CHUNK_SIZE - pos.nPos)) {\n             FILE *file = OpenUndoFile(pos);\n             if (file) {\n-                LogPrintf(\"Pre-allocating up to position 0x%x in rev%05u.dat\\n\", nNewChunks * UNDOFILE_CHUNK_SIZE, pos.nFile);\n+                Log() << \"Pre-allocating up to position 0x\" << boost::format(\"%x\") % (nNewChunks * UNDOFILE_CHUNK_SIZE) << \" in rev\" << boost::format(\"%05u\") % pos.nFile << \".dat\\n\";\n                 AllocateFileRange(file, pos.nPos, nNewChunks * UNDOFILE_CHUNK_SIZE - pos.nPos);\n                 fclose(file);\n             }\n@@ -1997,32 +2119,49 @@ bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW, bo\n \n     // Size limits\n     if (block.vtx.empty() || block.vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n-        return state.DoS(100, error(\"CheckBlock() : size limits failed\"),\n-                         REJECT_INVALID, \"block size too large\");\n+    {\n+        Log() << \"ERROR: CheckBlock() : size limits failed\\n\";\n+        return state.DoS(100, false, REJECT_INVALID, \"block size too large\");\n+    }\n \n     // Check proof of work matches claimed amount\n     if (fCheckPOW && !CheckProofOfWork(block.GetHash(), block.nBits))\n-        return state.DoS(50, error(\"CheckBlock() : proof of work failed\"),\n-                         REJECT_INVALID, \"invalid pow\");\n+    {\n+        Log() << \"ERROR: CheckBlock() : proof of work failed\\n\";\n+        return state.DoS(50, false, REJECT_INVALID, \"invalid pow\");\n+    }\n \n     // Check timestamp\n-    if (block.GetBlockTime() > GetAdjustedTime() + 2 * 60 * 60)\n-        return state.Invalid(error(\"CheckBlock() : block timestamp too far in the future\"),\n-                             REJECT_INVALID, \"time in future\");\n+    if (block.GetBlockTime() > BitcoinTime::GetAdjustedTime() + 2 * 60 * 60)\n+    {\n+        Log() << \"ERROR: CheckBlock() : block timestamp too far in the future\\n\";\n+        return state.Invalid(false, REJECT_INVALID, \"time in future\");\n+    }\n \n     // First transaction must be coinbase, the rest must not be\n     if (block.vtx.empty() || !block.vtx[0].IsCoinBase())\n-        return state.DoS(100, error(\"CheckBlock() : first tx is not coinbase\"),\n-                         REJECT_INVALID, \"no coinbase\");\n+    {\n+        Log() << \"ERROR: CheckBlock() : first tx is not coinbase\\n\";\n+        return state.DoS(100, false, REJECT_INVALID, \"no coinbase\");\n+    }\n     for (unsigned int i = 1; i < block.vtx.size(); i++)\n+    {\n         if (block.vtx[i].IsCoinBase())\n-            return state.DoS(100, error(\"CheckBlock() : more than one coinbase\"),\n-                             REJECT_INVALID, \"duplicate coinbase\");\n+        {\n+            Log() << \"ERROR: CheckBlock() : more than one coinbase\\n\";\n+            return state.DoS(100, false, REJECT_INVALID, \"duplicate coinbase\");\n+        }\n+    }\n \n     // Check transactions\n     BOOST_FOREACH(const CTransaction& tx, block.vtx)\n+    {\n         if (!CheckTransaction(tx, state))\n-            return error(\"CheckBlock() : CheckTransaction failed\");\n+        {\n+            Log() << \"ERROR: CheckBlock() : CheckTransaction failed\\n\";\n+            return false;\n+        }\n+    }\n \n     // Build the merkle tree already. We need it anyway later, and it makes the\n     // block cache the transaction hashes, which means they don't need to be\n@@ -2036,22 +2175,28 @@ bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW, bo\n         uniqueTx.insert(block.GetTxHash(i));\n     }\n     if (uniqueTx.size() != block.vtx.size())\n-        return state.DoS(100, error(\"CheckBlock() : duplicate transaction\"),\n-                         REJECT_INVALID, \"duplicate transaction\", true);\n+    {\n+        Log() << \"ERROR: CheckBlock() : duplicate transaction\\n\";\n+        return state.DoS(100, false, REJECT_INVALID, \"duplicate transaction\", true);\n+    }\n \n     unsigned int nSigOps = 0;\n     BOOST_FOREACH(const CTransaction& tx, block.vtx)\n     {\n         nSigOps += GetLegacySigOpCount(tx);\n     }\n     if (nSigOps > MAX_BLOCK_SIGOPS)\n-        return state.DoS(100, error(\"CheckBlock() : out-of-bounds SigOpCount\"),\n-                         REJECT_INVALID, \"sig op count\", true);\n+    {\n+        Log() << \"ERROR: CheckBlock() : out-of-bounds SigOpCount\\n\";\n+        return state.DoS(100, false, REJECT_INVALID, \"sig op count\", true);\n+    }\n \n     // Check merkle root\n     if (fCheckMerkleRoot && block.hashMerkleRoot != block.vMerkleTree.back())\n-        return state.DoS(100, error(\"CheckBlock() : hashMerkleRoot mismatch\"),\n-                         REJECT_INVALID, \"bad merkle root\", true);\n+    {\n+        Log() << \"ERROR: CheckBlock() : hashMerkleRoot mismatch\\n\";\n+        return state.DoS(100, false, REJECT_INVALID, \"bad merkle root\", true);\n+    }\n \n     return true;\n }\n@@ -2061,47 +2206,63 @@ bool AcceptBlock(CBlock& block, CValidationState& state, CDiskBlockPos* dbp)\n     // Check for duplicate\n     uint256 hash = block.GetHash();\n     if (mapBlockIndex.count(hash))\n-        return state.Invalid(error(\"AcceptBlock() : block already in mapBlockIndex\"));\n+    {\n+        Log() << \"ERROR: AcceptBlock() : block already in mapBlockIndex\\n\";\n+        return state.Invalid(false);\n+    }\n \n     // Get prev block index\n     CBlockIndex* pindexPrev = NULL;\n     int nHeight = 0;\n     if (hash != Params().HashGenesisBlock()) {\n         map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(block.hashPrevBlock);\n         if (mi == mapBlockIndex.end())\n-            return state.DoS(10, error(\"AcceptBlock() : prev block not found\"));\n+        {\n+            Log() << \"ERROR: AcceptBlock() : prev block not found\\n\";\n+            return state.DoS(10, false);\n+        }\n         pindexPrev = (*mi).second;\n         nHeight = pindexPrev->nHeight+1;\n \n         // Check proof of work\n         if (block.nBits != GetNextWorkRequired(pindexPrev, &block))\n-            return state.DoS(100, error(\"AcceptBlock() : incorrect proof of work\"),\n-                             REJECT_INVALID, \"bad pow\");\n+        {\n+            Log() << \"ERROR: AcceptBlock() : incorrect proof of work\\n\";\n+            return state.DoS(100, false, REJECT_INVALID, \"bad pow\");\n+        }\n \n         // Check timestamp against prev\n         if (block.GetBlockTime() <= pindexPrev->GetMedianTimePast())\n-            return state.Invalid(error(\"AcceptBlock() : block's timestamp is too early\"),\n-                                 REJECT_INVALID, \"timestamp too early\");\n+        {\n+            Log() << \"ERROR: AcceptBlock() : block's timestamp is too early\\n\";\n+            return state.Invalid(false, REJECT_INVALID, \"timestamp too early\");\n+        }\n \n         // Check that all transactions are finalized\n         BOOST_FOREACH(const CTransaction& tx, block.vtx)\n+        {\n             if (!IsFinalTx(tx, nHeight, block.GetBlockTime()))\n-                return state.DoS(10, error(\"AcceptBlock() : contains a non-final transaction\"),\n-                                 REJECT_INVALID, \"non-final tx\");\n+            {\n+                Log() << \"ERROR: AcceptBlock() : contains a non-final transaction\\n\";\n+                return state.DoS(10, false, REJECT_INVALID, \"non-final tx\");\n+            }\n+        }\n \n         // Check that the block chain matches the known block chain up to a checkpoint\n         if (!Checkpoints::CheckBlock(nHeight, hash))\n-            return state.DoS(100, error(\"AcceptBlock() : rejected by checkpoint lock-in at %d\", nHeight),\n-                             REJECT_CHECKPOINT, \"checkpoint mismatch\");\n+        {\n+            Log() << \"ERROR: AcceptBlock() : rejected by checkpoint lock-in at \" << nHeight << \"\\n\";\n+            return state.DoS(100, false, REJECT_CHECKPOINT, \"checkpoint mismatch\");\n+        }\n \n         // Reject block.nVersion=1 blocks when 95% (75% on testnet) of the network has upgraded:\n         if (block.nVersion < 2)\n         {\n             if ((!TestNet() && CBlockIndex::IsSuperMajority(2, pindexPrev, 950, 1000)) ||\n                 (TestNet() && CBlockIndex::IsSuperMajority(2, pindexPrev, 75, 100)))\n             {\n-                return state.Invalid(error(\"AcceptBlock() : rejected nVersion=1 block\"),\n-                                     REJECT_OBSOLETE, \"version 1 blocks obsolete\");\n+                Log() << \"ERROR: AcceptBlock() : rejected nVersion=1 block\\n\";\n+                return state.Invalid(false, REJECT_OBSOLETE, \"version 1 blocks obsolete\");\n             }\n         }\n         // Enforce block.nVersion=2 rule that the coinbase starts with serialized block height\n@@ -2114,8 +2275,10 @@ bool AcceptBlock(CBlock& block, CValidationState& state, CDiskBlockPos* dbp)\n                 CScript expect = CScript() << nHeight;\n                 if (block.vtx[0].vin[0].scriptSig.size() < expect.size() ||\n                     !std::equal(expect.begin(), expect.end(), block.vtx[0].vin[0].scriptSig.begin()))\n-                    return state.DoS(100, error(\"AcceptBlock() : block height mismatch in coinbase\"),\n-                                     REJECT_INVALID, \"height incorrect in coinbase\");\n+                {\n+                    Log() << \"ERROR: AcceptBlock() : block height mismatch in coinbase\\n\";\n+                    return state.DoS(100, false, REJECT_INVALID, \"height incorrect in coinbase\");\n+                }\n             }\n         }\n     }\n@@ -2127,14 +2290,20 @@ bool AcceptBlock(CBlock& block, CValidationState& state, CDiskBlockPos* dbp)\n         if (dbp != NULL)\n             blockPos = *dbp;\n         if (!FindBlockPos(state, blockPos, nBlockSize+8, nHeight, block.nTime, dbp != NULL))\n-            return error(\"AcceptBlock() : FindBlockPos failed\");\n+        {\n+            Log() << \"ERROR: AcceptBlock() : FindBlockPos failed\\n\";\n+            return false;\n+        }\n         if (dbp == NULL)\n             if (!WriteBlockToDisk(block, blockPos))\n-                return state.Abort(_(\"Failed to write block\"));\n+                return state.Abort(_<string>(\"Failed to write block\"));\n         if (!AddToBlockIndex(block, state, blockPos))\n-            return error(\"AcceptBlock() : AddToBlockIndex failed\");\n+        {\n+            Log() << \"ERROR: AcceptBlock() : AddToBlockIndex failed\\n\";\n+            return false;\n+        }\n     } catch(std::runtime_error &e) {\n-        return state.Abort(_(\"System error: \") + e.what());\n+        return state.Abort(_<string>(\"System error: \") + e.what());\n     }\n \n     // Relay inventory, but don't relay old inventory during initial block download\n@@ -2192,13 +2361,22 @@ bool ProcessBlock(CValidationState &state, CNode* pfrom, CBlock* pblock, CDiskBl\n     // Check for duplicate\n     uint256 hash = pblock->GetHash();\n     if (mapBlockIndex.count(hash))\n-        return state.Invalid(error(\"ProcessBlock() : already have block %d %s\", mapBlockIndex[hash]->nHeight, hash.ToString().c_str()));\n+    {\n+        Log() << \"ERROR: \" << \"ProcessBlock() : already have block \" << mapBlockIndex[hash]->nHeight << \" \" << hash.ToString() << \"\\n\";\n+        return state.Invalid(false);\n+    }\n     if (mapOrphanBlocks.count(hash))\n-        return state.Invalid(error(\"ProcessBlock() : already have block (orphan) %s\", hash.ToString().c_str()));\n+    {\n+        Log() << \"ERROR: \" << \"ProcessBlock() : already have block (orphan) \" << hash.ToString() << \"\\n\";\n+        return state.Invalid(false);\n+    }\n \n     // Preliminary checks\n     if (!CheckBlock(*pblock, state))\n-        return error(\"ProcessBlock() : CheckBlock FAILED\");\n+    {\n+        Log() << \"ERROR: ProcessBlock() : CheckBlock FAILED\\n\";\n+        return false;\n+    }\n \n     CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint(mapBlockIndex);\n     if (pcheckpoint && pblock->hashPrevBlock != (chainActive.Tip() ? chainActive.Tip()->GetBlockHash() : uint256(0)))\n@@ -2207,25 +2385,25 @@ bool ProcessBlock(CValidationState &state, CNode* pfrom, CBlock* pblock, CDiskBl\n         int64_t deltaTime = pblock->GetBlockTime() - pcheckpoint->nTime;\n         if (deltaTime < 0)\n         {\n-            return state.DoS(100, error(\"ProcessBlock() : block with timestamp before last checkpoint\"),\n-                             REJECT_CHECKPOINT, \"timestamp before checkpoint\");\n+            Log() << \"ERROR: ProcessBlock() : block with timestamp before last checkpoint\\n\";\n+            return state.DoS(100, false, REJECT_CHECKPOINT, \"timestamp before checkpoint\");\n         }\n         CBigNum bnNewBlock;\n         bnNewBlock.SetCompact(pblock->nBits);\n         CBigNum bnRequired;\n         bnRequired.SetCompact(ComputeMinWork(pcheckpoint->nBits, deltaTime));\n         if (bnNewBlock > bnRequired)\n         {\n-            return state.DoS(100, error(\"ProcessBlock() : block with too little proof-of-work\"),\n-                             REJECT_INVALID, \"invalid pow\");\n+            Log() << \"ERROR: ProcessBlock() : block with too little proof-of-work\\n\";\n+            return state.DoS(100, false, REJECT_INVALID, \"invalid pow\");\n         }\n     }\n \n \n     // If we don't already have its previous block, shunt it off to holding area until we get it\n     if (pblock->hashPrevBlock != 0 && !mapBlockIndex.count(pblock->hashPrevBlock))\n     {\n-        LogPrintf(\"ProcessBlock: ORPHAN BLOCK, prev=%s\\n\", pblock->hashPrevBlock.ToString().c_str());\n+        Log() << \"ProcessBlock: ORPHAN BLOCK, prev=\" << pblock->hashPrevBlock.ToString() << \"\\n\";\n \n         // Accept orphans as long as there is a node to request its parents from\n         if (pfrom) {\n@@ -2241,7 +2419,10 @@ bool ProcessBlock(CValidationState &state, CNode* pfrom, CBlock* pblock, CDiskBl\n \n     // Store to disk\n     if (!AcceptBlock(*pblock, state, dbp))\n-        return error(\"ProcessBlock() : AcceptBlock FAILED\");\n+    {\n+        Log() << \"ERROR: ProcessBlock() : AcceptBlock FAILED\\n\";\n+        return false;\n+    }\n \n     // Recursively process any orphan blocks that depended on this one\n     vector<uint256> vWorkQueue;\n@@ -2264,7 +2445,7 @@ bool ProcessBlock(CValidationState &state, CNode* pfrom, CBlock* pblock, CDiskBl\n         mapOrphanBlocksByPrev.erase(hashPrev);\n     }\n \n-    LogPrintf(\"ProcessBlock: ACCEPTED\\n\");\n+    Log() << \"ProcessBlock: ACCEPTED\\n\";\n     return true;\n }\n \n@@ -2430,7 +2611,7 @@ uint256 CPartialMerkleTree::ExtractMatches(std::vector<uint256> &vMatch) {\n \n bool AbortNode(const std::string &strMessage) {\n     strMiscWarning = strMessage;\n-    LogPrintf(\"*** %s\\n\", strMessage.c_str());\n+    Log() << \"*** \" << strMessage << \"\\n\";\n     uiInterface.ThreadSafeMessageBox(strMessage, \"\", CClientUIInterface::MSG_ERROR);\n     StartShutdown();\n     return false;\n@@ -2442,7 +2623,7 @@ bool CheckDiskSpace(uint64_t nAdditionalBytes)\n \n     // Check for nMinDiskSpace bytes (currently 50MB)\n     if (nFreeBytesAvailable < nMinDiskSpace + nAdditionalBytes)\n-        return AbortNode(_(\"Error: Disk space is low!\"));\n+        return AbortNode(_<string>(\"Error: Disk space is low!\"));\n \n     return true;\n }\n@@ -2451,18 +2632,19 @@ FILE* OpenDiskFile(const CDiskBlockPos &pos, const char *prefix, bool fReadOnly)\n {\n     if (pos.IsNull())\n         return NULL;\n-    boost::filesystem::path path = GetDataDir() / \"blocks\" / strprintf(\"%s%05u.dat\", prefix, pos.nFile);\n+\n+    boost::filesystem::path path = GetDataDir() / \"blocks\" / boost::str(boost::format(\"%s%05u.dat\") % prefix % pos.nFile);\n     boost::filesystem::create_directories(path.parent_path());\n     FILE* file = fopen(path.string().c_str(), \"rb+\");\n     if (!file && !fReadOnly)\n         file = fopen(path.string().c_str(), \"wb+\");\n     if (!file) {\n-        LogPrintf(\"Unable to open file %s\\n\", path.string().c_str());\n+        Log() << \"Unable to open file \" << path.string() << \"\\n\";\n         return NULL;\n     }\n     if (pos.nPos) {\n         if (fseek(file, pos.nPos, SEEK_SET)) {\n-            LogPrintf(\"Unable to seek to position %u of %s\\n\", pos.nPos, path.string().c_str());\n+            Log() << \"Unable to seek to position \" << pos.nPos << \" of \" << path.string() << \"\\n\";\n             fclose(file);\n             return NULL;\n         }\n@@ -2527,9 +2709,9 @@ bool static LoadBlockIndexDB()\n \n     // Load block file info\n     pblocktree->ReadLastBlockFile(nLastBlockFile);\n-    LogPrintf(\"LoadBlockIndexDB(): last block file = %i\\n\", nLastBlockFile);\n+    Log() << \"LoadBlockIndexDB(): last block file = \" << nLastBlockFile << \"\\n\";\n     if (pblocktree->ReadBlockFileInfo(nLastBlockFile, infoLastBlockFile))\n-        LogPrintf(\"LoadBlockIndexDB(): last block file info: %s\\n\", infoLastBlockFile.ToString().c_str());\n+        Log() << \"LoadBlockIndexDB(): last block file info: \" << infoLastBlockFile.ToString() << \"\\n\";\n \n     // Check whether we need to continue reindexing\n     bool fReindexing = false;\n@@ -2538,16 +2720,15 @@ bool static LoadBlockIndexDB()\n \n     // Check whether we have a transaction index\n     pblocktree->ReadFlag(\"txindex\", fTxIndex);\n-    LogPrintf(\"LoadBlockIndexDB(): transaction index %s\\n\", fTxIndex ? \"enabled\" : \"disabled\");\n+    Log() << \"LoadBlockIndexDB(): transaction index \" << (fTxIndex ? \"enabled\" : \"disabled\") << \"\\n\";\n \n     // Load pointer to end of best chain\n     std::map<uint256, CBlockIndex*>::iterator it = mapBlockIndex.find(pcoinsTip->GetBestBlock());\n     if (it == mapBlockIndex.end())\n         return true;\n     chainActive.SetTip(it->second);\n-    LogPrintf(\"LoadBlockIndexDB(): hashBestChain=%s  height=%d date=%s\\n\",\n-        chainActive.Tip()->GetBlockHash().ToString().c_str(), chainActive.Height(),\n-        DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", chainActive.Tip()->GetBlockTime()).c_str());\n+    Log() << \"LoadBlockIndexDB(): hashBestChain=\" << chainActive.Tip()->GetBlockHash().ToString() << \"  height=\" << chainActive.Height() \n+          << \" date=\" << BitcoinTime::DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", chainActive.Tip()->GetBlockTime()) << \"\\n\";\n \n     return true;\n }\n@@ -2563,7 +2744,7 @@ bool VerifyDB(int nCheckLevel, int nCheckDepth)\n     if (nCheckDepth > chainActive.Height())\n         nCheckDepth = chainActive.Height();\n     nCheckLevel = std::max(0, std::min(4, nCheckLevel));\n-    LogPrintf(\"Verifying last %i blocks at level %i\\n\", nCheckDepth, nCheckLevel);\n+    Log() << \"Verifying last \" << nCheckDepth << \" blocks at level \" << nCheckLevel << \"\\n\";\n     CCoinsViewCache coins(*pcoinsTip, true);\n     CBlockIndex* pindexState = chainActive.Tip();\n     CBlockIndex* pindexFailure = NULL;\n@@ -2577,24 +2758,36 @@ bool VerifyDB(int nCheckLevel, int nCheckDepth)\n         CBlock block;\n         // check level 0: read from disk\n         if (!ReadBlockFromDisk(block, pindex))\n-            return error(\"VerifyDB() : *** ReadBlockFromDisk failed at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n+        {\n+            Log() << \"ERROR: \" << \"VerifyDB() : *** ReadBlockFromDisk failed at \" << pindex->nHeight << \", hash=\" << pindex->GetBlockHash().ToString() << \"\\n\\n\";\n+            return false;\n+        }\n         // check level 1: verify block validity\n         if (nCheckLevel >= 1 && !CheckBlock(block, state))\n-            return error(\"VerifyDB() : *** found bad block at %d, hash=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n+        {\n+            Log() << \"ERROR: \" << \"VerifyDB() : *** found bad block at \" << pindex->nHeight << \", hash=\" << pindex->GetBlockHash().ToString() << \"\\n\\n\";\n+            return false;\n+        }\n         // check level 2: verify undo validity\n         if (nCheckLevel >= 2 && pindex) {\n             CBlockUndo undo;\n             CDiskBlockPos pos = pindex->GetUndoPos();\n             if (!pos.IsNull()) {\n                 if (!undo.ReadFromDisk(pos, pindex->pprev->GetBlockHash()))\n-                    return error(\"VerifyDB() : *** found bad undo data at %d, hash=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n+                {\n+                    Log() << \"ERROR: \" << \"VerifyDB() : *** found bad undo data at \" << pindex->nHeight << \", hash=\" << pindex->GetBlockHash().ToString() << \"\\n\\n\";\n+                    return false;\n+                }\n             }\n         }\n         // check level 3: check for inconsistencies during memory-only disconnect of tip blocks\n         if (nCheckLevel >= 3 && pindex == pindexState && (coins.GetCacheSize() + pcoinsTip->GetCacheSize()) <= 2*nCoinCacheSize + 32000) {\n             bool fClean = true;\n             if (!DisconnectBlock(block, state, pindex, coins, &fClean))\n-                return error(\"VerifyDB() : *** irrecoverable inconsistency in block data at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n+            {\n+                Log() << \"ERROR: \" << \"VerifyDB() : *** irrecoverable inconsistency in block data at \" << pindex->nHeight << \", hash=\" << pindex->GetBlockHash().ToString() << \"\\n\";\n+                return false;\n+            }\n             pindexState = pindex->pprev;\n             if (!fClean) {\n                 nGoodTransactions = 0;\n@@ -2604,7 +2797,10 @@ bool VerifyDB(int nCheckLevel, int nCheckDepth)\n         }\n     }\n     if (pindexFailure)\n-        return error(\"VerifyDB() : *** coin database inconsistencies found (last %i blocks, %i good transactions before that)\\n\", chainActive.Height() - pindexFailure->nHeight + 1, nGoodTransactions);\n+    {\n+        Log() << \"ERROR: \" << \"VerifyDB() : *** coin database inconsistencies found (last \" << (chainActive.Height() - pindexFailure->nHeight + 1) << \" blocks, \" << nGoodTransactions << \" good transactions before that)\\n\\n\";\n+        return false;\n+    }\n \n     // check level 4: try reconnecting blocks\n     if (nCheckLevel >= 4) {\n@@ -2614,13 +2810,19 @@ bool VerifyDB(int nCheckLevel, int nCheckDepth)\n             pindex = chainActive.Next(pindex);\n             CBlock block;\n             if (!ReadBlockFromDisk(block, pindex))\n-                return error(\"VerifyDB() : *** ReadBlockFromDisk failed at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n+            {\n+                Log() << \"ERROR: \" << \"VerifyDB() : *** ReadBlockFromDisk failed at \" << pindex->nHeight << \", hash=\" << pindex->GetBlockHash().ToString() << \"\\n\";\n+                return false;\n+            }\n             if (!ConnectBlock(block, state, pindex, coins))\n-                return error(\"VerifyDB() : *** found unconnectable block at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n+            {\n+                Log() << \"ERROR: \" << \"VerifyDB() : *** found unconnectable block at \" << pindex->nHeight << \", hash=\" << pindex->GetBlockHash().ToString() << \"\\n\";\n+                return false;\n+            }\n         }\n     }\n \n-    LogPrintf(\"No coin database inconsistencies in last %i blocks (%i transactions)\\n\", chainActive.Height() - pindexState->nHeight, nGoodTransactions);\n+    Log() << \"No coin database inconsistencies in last \" << (chainActive.Height() - pindexState->nHeight) << \" blocks (\" << nGoodTransactions << \" transactions)\\n\";\n \n     return true;\n }\n@@ -2650,7 +2852,7 @@ bool InitBlockIndex() {\n     // Use the provided setting for -txindex in the new database\n     fTxIndex = GetBoolArg(\"-txindex\", false);\n     pblocktree->WriteFlag(\"txindex\", fTxIndex);\n-    LogPrintf(\"Initializing databases...\\n\");\n+    Log() << \"Initializing databases...\\n\";\n \n     // Only add the genesis block if not reindexing (in which case we reuse the one already on disk)\n     if (!fReindex) {\n@@ -2661,13 +2863,23 @@ bool InitBlockIndex() {\n             CDiskBlockPos blockPos;\n             CValidationState state;\n             if (!FindBlockPos(state, blockPos, nBlockSize+8, 0, block.nTime))\n-                return error(\"LoadBlockIndex() : FindBlockPos failed\");\n+            {\n+                Log() << \"ERROR: LoadBlockIndex() : FindBlockPos failed\\n\";\n+                return false;\n+            }\n             if (!WriteBlockToDisk(block, blockPos))\n-                return error(\"LoadBlockIndex() : writing genesis block to disk failed\");\n+            {\n+                Log() << \"ERROR: LoadBlockIndex() : writing genesis block to disk failed\\n\";\n+                return false;\n+            }\n             if (!AddToBlockIndex(block, state, blockPos))\n-                return error(\"LoadBlockIndex() : genesis block not accepted\");\n+            {\n+                Log() << \"ERROR: LoadBlockIndex() : genesis block not accepted\\n\";\n+                return false;\n+            }\n         } catch(std::runtime_error &e) {\n-            return error(\"LoadBlockIndex() : failed to initialize block database: %s\", e.what());\n+            Log() << \"ERROR: LoadBlockIndex() : failed to initialize block database: \" << e.what() << \"\\n\";\n+            return false;\n         }\n     }\n \n@@ -2703,29 +2915,26 @@ void PrintBlockTree()\n         if (nCol > nPrevCol)\n         {\n             for (int i = 0; i < nCol-1; i++)\n-                LogPrintf(\"| \");\n-            LogPrintf(\"|\\\\\\n\");\n+                Log() << \"| \";\n+            Log() << \"|\\\\\\n\";\n         }\n         else if (nCol < nPrevCol)\n         {\n             for (int i = 0; i < nCol; i++)\n-                LogPrintf(\"| \");\n-            LogPrintf(\"|\\n\");\n+                Log() << \"| \";\n+            Log() << \"|\\n\";\n        }\n         nPrevCol = nCol;\n \n         // print columns\n         for (int i = 0; i < nCol; i++)\n-            LogPrintf(\"| \");\n+            Log() << \"| \";\n \n         // print item\n         CBlock block;\n         ReadBlockFromDisk(block, pindex);\n-        LogPrintf(\"%d (blk%05u.dat:0x%x)  %s  tx %\"PRIszu\"\",\n-            pindex->nHeight,\n-            pindex->GetBlockPos().nFile, pindex->GetBlockPos().nPos,\n-            DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", block.GetBlockTime()).c_str(),\n-            block.vtx.size());\n+        Log() << pindex->nHeight << \" (blk\" << boost::format(\"%05u\") % pindex->GetBlockPos().nFile << \".dat:0x\" << boost::format(\"%x\") % pindex->GetBlockPos().nPos << \"  \" \n+              << BitcoinTime::DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", block.GetBlockTime()) << \"  tx \" << block.vtx.size();\n \n         // put the main time-chain first\n         vector<CBlockIndex*>& vNext = mapNext[pindex];\n@@ -2746,7 +2955,7 @@ void PrintBlockTree()\n \n bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos *dbp)\n {\n-    int64_t nStart = GetTimeMillis();\n+    int64_t nStart = BitcoinTime::GetTimeMillis();\n \n     int nLoaded = 0;\n     try {\n@@ -2804,15 +3013,15 @@ bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos *dbp)\n                         break;\n                 }\n             } catch (std::exception &e) {\n-                LogPrintf(\"%s() : Deserialize or I/O error caught during load\\n\", __PRETTY_FUNCTION__);\n+                Log() << __PRETTY_FUNCTION__ << \"() : Deserialize or I/O error caught during load\\n\";\n             }\n         }\n         fclose(fileIn);\n     } catch(std::runtime_error &e) {\n-        AbortNode(_(\"Error: system error: \") + e.what());\n+        AbortNode(_<string>(\"Error: system error: \") + e.what());\n     }\n     if (nLoaded > 0)\n-        LogPrintf(\"Loaded %i blocks from external file in %\"PRId64\"ms\\n\", nLoaded, GetTimeMillis() - nStart);\n+        Log() << \"Loaded \" << nLoaded << \" blocks from external file in \" << (BitcoinTime::GetTimeMillis() - nStart) << \"ms\\n\";\n     return nLoaded > 0;\n }\n \n@@ -2840,7 +3049,7 @@ string GetWarnings(string strFor)\n         strRPC = \"test\";\n \n     if (!CLIENT_VERSION_IS_RELEASE)\n-        strStatusBar = _(\"This is a pre-release test build - use at your own risk - do not use for mining or merchant applications\");\n+        strStatusBar = _<string>(\"This is a pre-release test build - use at your own risk - do not use for mining or merchant applications\");\n \n     // Misc warnings like out of disk space and clock is wrong\n     if (strMiscWarning != \"\")\n@@ -2852,12 +3061,12 @@ string GetWarnings(string strFor)\n     if (fLargeWorkForkFound)\n     {\n         nPriority = 2000;\n-        strStatusBar = strRPC = _(\"Warning: The network does not appear to fully agree! Some miners appear to be experiencing issues.\");\n+        strStatusBar = strRPC = _<string>(\"Warning: The network does not appear to fully agree! Some miners appear to be experiencing issues.\");\n     }\n     else if (fLargeWorkInvalidChainFound)\n     {\n         nPriority = 2000;\n-        strStatusBar = strRPC = _(\"Warning: We do not appear to fully agree with our peers! You may need to upgrade, or other nodes may need to upgrade.\");\n+        strStatusBar = strRPC = _<string>(\"Warning: We do not appear to fully agree with our peers! You may need to upgrade, or other nodes may need to upgrade.\");\n     }\n \n     // Alerts\n@@ -3031,10 +3240,10 @@ void static ProcessGetData(CNode* pfrom)\n bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n {\n     RandAddSeedPerfmon();\n-    LogPrint(\"net\", \"received: %s (%\"PRIszu\" bytes)\\n\", strCommand.c_str(), vRecv.size());\n-    if (mapArgs.count(\"-dropmessagestest\") && GetRand(atoi(mapArgs[\"-dropmessagestest\"])) == 0)\n+    Log(\"net\") << \"received: \" << strCommand << \" (\" << vRecv.size() << \" bytes)\\n\";\n+    if (mapArgs.count(\"-dropmessagestest\") && GetRand(fromstr<int>(mapArgs[\"-dropmessagestest\"])) == 0)\n     {\n-        LogPrintf(\"dropmessagestest DROPPING RECV MESSAGE\\n\");\n+        Log() << \"dropmessagestest DROPPING RECV MESSAGE\\n\";\n         return true;\n     }\n \n@@ -3060,9 +3269,10 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         if (pfrom->nVersion < MIN_PEER_PROTO_VERSION)\n         {\n             // disconnect from peers older than this proto version\n-            LogPrintf(\"partner %s using obsolete version %i; disconnecting\\n\", pfrom->addr.ToString().c_str(), pfrom->nVersion);\n-            pfrom->PushMessage(\"reject\", strCommand, REJECT_OBSOLETE,\n-                               strprintf(\"Version must be %d or greater\", MIN_PEER_PROTO_VERSION));\n+            Log() << \"partner \" << pfrom->addr.ToString() << \" using obsolete version \" << pfrom->nVersion << \"; disconnecting\\n\";\n+\n+            pfrom->PushMessage(\"reject\", strCommand, REJECT_OBSOLETE, \n+                               boost::str(boost::format(\"Version must be %d or greater\") % MIN_PEER_PROTO_VERSION));\n             pfrom->fDisconnect = true;\n             return false;\n         }\n@@ -3091,7 +3301,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         // Disconnect if we connected to ourself\n         if (nNonce == nLocalHostNonce && nNonce > 1)\n         {\n-            LogPrintf(\"connected to self at %s, disconnecting\\n\", pfrom->addr.ToString().c_str());\n+            Log() << \"connected to self at \" << pfrom->addr.ToString() << \", disconnecting\\n\";\n             pfrom->fDisconnect = true;\n             return true;\n         }\n@@ -3141,7 +3351,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n \n         pfrom->fSuccessfullyConnected = true;\n \n-        LogPrintf(\"receive version message: %s: version %d, blocks=%d, us=%s, them=%s, peer=%s\\n\", pfrom->cleanSubVer.c_str(), pfrom->nVersion, pfrom->nStartingHeight, addrMe.ToString().c_str(), addrFrom.ToString().c_str(), pfrom->addr.ToString().c_str());\n+        Log() << \"receive version message: \" << pfrom->cleanSubVer << \": version \" << pfrom->nVersion << \", blocks=\" << pfrom->nStartingHeight << \",\"\n+              << \" us=\" << addrMe.ToString() << \", them=\" << addrFrom.ToString() << \", peer=\" << pfrom->addr.ToString() << \"\\n\";\n \n         AddTimeData(pfrom->addr, nTime);\n \n@@ -3175,12 +3386,13 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         if (vAddr.size() > 1000)\n         {\n             pfrom->Misbehaving(20);\n-            return error(\"message addr size() = %\"PRIszu\"\", vAddr.size());\n+            Log() << \"ERROR: message addr size() = \" << vAddr.size() << \"\\n\";\n+            return false;\n         }\n \n         // Store the new addresses\n         vector<CAddress> vAddrOk;\n-        int64_t nNow = GetAdjustedTime();\n+        int64_t nNow = BitcoinTime::GetAdjustedTime();\n         int64_t nSince = nNow - 10 * 60;\n         BOOST_FOREACH(CAddress& addr, vAddr)\n         {\n@@ -3201,7 +3413,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n                     if (hashSalt == 0)\n                         hashSalt = GetRandHash();\n                     uint64_t hashAddr = addr.GetHash();\n-                    uint256 hashRand = hashSalt ^ (hashAddr<<32) ^ ((GetTime()+hashAddr)/(24*60*60));\n+                    uint256 hashRand = hashSalt ^ (hashAddr<<32) ^ ((BitcoinTime::GetTime()+hashAddr)/(24*60*60));\n                     hashRand = Hash(BEGIN(hashRand), END(hashRand));\n                     multimap<uint256, CNode*> mapMix;\n                     BOOST_FOREACH(CNode* pnode, vNodes)\n@@ -3238,7 +3450,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         if (vInv.size() > MAX_INV_SZ)\n         {\n             pfrom->Misbehaving(20);\n-            return error(\"message inv size() = %\"PRIszu\"\", vInv.size());\n+            Log() << \"ERROR: \" << \"message inv size() = \" << vInv.size() << \"\\n\";\n+            return false;\n         }\n \n         // find last block in inv vector\n@@ -3260,7 +3473,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n             pfrom->AddInventoryKnown(inv);\n \n             bool fAlreadyHave = AlreadyHave(inv);\n-            LogPrint(\"net\", \"  got inventory: %s  %s\\n\", inv.ToString().c_str(), fAlreadyHave ? \"have\" : \"new\");\n+            Log(\"net\") << \"  got inventory: \" << inv.ToString() << \"  \" << (fAlreadyHave ? \"have\" : \"new\") << \"\\n\";\n \n             if (!fAlreadyHave) {\n                 if (!fImporting && !fReindex)\n@@ -3272,8 +3485,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n                 // the last block in an inv bundle sent in response to getblocks. Try to detect\n                 // this situation and push another getblocks to continue.\n                 PushGetBlocks(pfrom, mapBlockIndex[inv.hash], uint256(0));\n-                if (fDebug)\n-                    LogPrintf(\"force request: %s\\n\", inv.ToString().c_str());\n+                if (Log::fDebug)\n+                    Log() << \"force request: \" << inv.ToString() << \"\\n\";\n             }\n \n             // Track requests for our stuff\n@@ -3289,14 +3502,15 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         if (vInv.size() > MAX_INV_SZ)\n         {\n             pfrom->Misbehaving(20);\n-            return error(\"message getdata size() = %\"PRIszu\"\", vInv.size());\n+            Log() << \"ERROR: \" << \"message getdata size() = \" << vInv.size() << \"\\n\";\n+            return false;\n         }\n \n-        if (fDebug || (vInv.size() != 1))\n-            LogPrint(\"net\", \"received getdata (%\"PRIszu\" invsz)\\n\", vInv.size());\n+        if (Log::fDebug || (vInv.size() != 1))\n+            Log(\"net\") << \"received getdata (\" << vInv.size() << \" invsz)\\n\";\n \n-        if ((fDebug && vInv.size() > 0) || (vInv.size() == 1))\n-            LogPrint(\"net\", \"received getdata for: %s\\n\", vInv[0].ToString().c_str());\n+        if ((Log::fDebug && vInv.size() > 0) || (vInv.size() == 1))\n+            Log(\"net\") << \"received getdata for: \" << vInv[0].ToString() << \"\\n\";\n \n         pfrom->vRecvGetData.insert(pfrom->vRecvGetData.end(), vInv.begin(), vInv.end());\n         ProcessGetData(pfrom);\n@@ -3318,20 +3532,20 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         if (pindex)\n             pindex = chainActive.Next(pindex);\n         int nLimit = 500;\n-        LogPrint(\"net\", \"getblocks %d to %s limit %d\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().c_str(), nLimit);\n+        Log(\"net\") << \"getblocks \" << (pindex ? pindex->nHeight : -1) << \" to \" << hashStop.ToString() << \" limit \" << nLimit << \"\\n\";\n         for (; pindex; pindex = chainActive.Next(pindex))\n         {\n             if (pindex->GetBlockHash() == hashStop)\n             {\n-                LogPrint(\"net\", \"  getblocks stopping at %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n+                Log(\"net\") << \"  getblocks stopping at \" << pindex->nHeight << \" \" << pindex->GetBlockHash().ToString() << \"\\n\";\n                 break;\n             }\n             pfrom->PushInventory(CInv(MSG_BLOCK, pindex->GetBlockHash()));\n             if (--nLimit <= 0)\n             {\n                 // When this block is requested, we'll send an inv that'll make them\n                 // getblocks the next batch of inventory.\n-                LogPrint(\"net\", \"  getblocks stopping at limit %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n+                Log(\"net\") << \"  getblocks stopping at limit \" << pindex->nHeight << \" \" << pindex->GetBlockHash().ToString() << \"\\n\";\n                 pfrom->hashContinue = pindex->GetBlockHash();\n                 break;\n             }\n@@ -3367,7 +3581,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         // we must use CBlocks, as CBlockHeaders won't include the 0x00 nTx count at the end\n         vector<CBlock> vHeaders;\n         int nLimit = 2000;\n-        LogPrint(\"net\", \"getheaders %d to %s\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().c_str());\n+        Log(\"net\") << \"getheaders \" << (pindex ? pindex->nHeight : -1) << \" to \" << hashStop.ToString() << \"\\n\";\n         for (; pindex; pindex = chainActive.Next(pindex))\n         {\n             vHeaders.push_back(pindex->GetBlockHeader());\n@@ -3401,10 +3615,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n             vEraseQueue.push_back(inv.hash);\n \n \n-            LogPrint(\"mempool\", \"AcceptToMemoryPool: %s %s : accepted %s (poolsz %\"PRIszu\")\\n\",\n-                pfrom->addr.ToString().c_str(), pfrom->cleanSubVer.c_str(),\n-                tx.GetHash().ToString().c_str(),\n-                mempool.mapTx.size());\n+            Log(\"mempool\") << \"AcceptToMemoryPool: \" << pfrom->addr.ToString() << \" \" << pfrom->cleanSubVer \n+                           << \" : accepted \" << tx.GetHash().ToString() << \" (poolsz \" << mempool.mapTx.size() << \")\\n\";\n \n             // Recursively process any orphan transactions that depended on this one\n             for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n@@ -3424,7 +3636,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n \n                     if (AcceptToMemoryPool(mempool, stateDummy, orphanTx, true, &fMissingInputs2))\n                     {\n-                        LogPrint(\"mempool\", \"   accepted orphan tx %s\\n\", orphanHash.ToString().c_str());\n+                        Log(\"mempool\") << \"   accepted orphan tx \" << orphanHash.ToString() << \"\\n\";\n                         RelayTransaction(orphanTx, orphanHash);\n                         mapAlreadyAskedFor.erase(CInv(MSG_TX, orphanHash));\n                         vWorkQueue.push_back(orphanHash);\n@@ -3434,7 +3646,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n                     {\n                         // invalid or too-little-fee orphan\n                         vEraseQueue.push_back(orphanHash);\n-                        LogPrint(\"mempool\", \"   removed orphan tx %s\\n\", orphanHash.ToString().c_str());\n+                        Log(\"mempool\") << \"   removed orphan tx \" << orphanHash.ToString() << \"\\n\";\n                     }\n                     mempool.check(pcoinsTip);\n                 }\n@@ -3450,14 +3662,13 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n             // DoS prevention: do not allow mapOrphanTransactions to grow unbounded\n             unsigned int nEvicted = LimitOrphanTxSize(MAX_ORPHAN_TRANSACTIONS);\n             if (nEvicted > 0)\n-                LogPrint(\"mempool\", \"mapOrphan overflow, removed %u tx\\n\", nEvicted);\n+                Log(\"mempool\") << \"mapOrphan overflow, removed \" << nEvicted << \" tx\\n\";\n         }\n         int nDoS = 0;\n         if (state.IsInvalid(nDoS))\n         { \n-            LogPrint(\"mempool\", \"%s from %s %s was not accepted into the memory pool: %s\\n\", tx.GetHash().ToString().c_str(), \n-                pfrom->addr.ToString().c_str(), pfrom->cleanSubVer.c_str(),\n-                state.GetRejectReason().c_str());\n+            Log(\"mempool\") << tx.GetHash().ToString() << \" from \" << pfrom->addr.ToString() << \" \" << pfrom->cleanSubVer\n+                           << \" was not accepted into the memory pool: \" << state.GetRejectReason() << \"\\n\";\n             pfrom->PushMessage(\"reject\", strCommand, state.GetRejectCode(),\n                                state.GetRejectReason(), inv.hash);\n             if (nDoS > 0)\n@@ -3471,7 +3682,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         CBlock block;\n         vRecv >> block;\n \n-        LogPrint(\"net\", \"received block %s\\n\", block.GetHash().ToString().c_str());\n+        Log(\"net\") << \"received block \" << block.GetHash().ToString() << \"\\n\";\n         // block.print();\n \n         CInv inv(MSG_BLOCK, block.GetHash());\n@@ -3551,7 +3762,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n \n     else if (strCommand == \"pong\")\n     {\n-        int64_t pingUsecEnd = GetTimeMicros();\n+        int64_t pingUsecEnd = BitcoinTime::GetTimeMicros();\n         uint64_t nonce = 0;\n         size_t nAvail = vRecv.in_avail();\n         bool bPingFinished = false;\n@@ -3592,13 +3803,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         }\n \n         if (!(sProblem.empty())) {\n-            LogPrint(\"net\", \"pong %s %s: %s, %\"PRIx64\" expected, %\"PRIx64\" received, %\"PRIszu\" bytes\\n\",\n-                pfrom->addr.ToString().c_str(),\n-                pfrom->cleanSubVer.c_str(),\n-                sProblem.c_str(),\n-                pfrom->nPingNonceSent,\n-                nonce,\n-                nAvail);\n+            Log(\"net\") << \"pong \" << pfrom->addr.ToString() << \" \" << pfrom->cleanSubVer << \": \" << sProblem << \", \" << hex << pfrom->nPingNonceSent << dec << \" expected, \" << hex << nonce << dec << \" received, \" << nAvail << \" bytes\\n\";\n+\n         }\n         if (bPingFinished) {\n             pfrom->nPingNonceSent = 0;\n@@ -3687,24 +3893,24 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n \n     else if (strCommand == \"reject\")\n     {\n-        if (fDebug)\n+        if (Log::fDebug)\n         {\n             string strMsg; unsigned char ccode; string strReason;\n             vRecv >> strMsg >> ccode >> strReason;\n \n-            ostringstream ss;\n-            ss << strMsg << \" code \" << itostr(ccode) << \": \" << strReason;\n+            ostringstream oss;\n+            oss << strMsg << \" code \" << tostr(ccode) << \": \" << strReason;\n \n             if (strMsg == \"block\" || strMsg == \"tx\")\n             {\n                 uint256 hash;\n                 vRecv >> hash;\n-                ss << \": hash \" << hash.ToString();\n+                oss << \": hash \" << hash.ToString();\n             }\n             // Truncate to reasonable length and sanitize before printing:\n-            string s = ss.str();\n+            string s = oss.str();\n             if (s.size() > 111) s.erase(111, string::npos);\n-            LogPrint(\"net\", \"Reject %s\\n\", SanitizeString(s).c_str());\n+            Log(\"net\") << \"Reject \" << SanitizeString(s) << \"\\n\";\n         }\n     }\n \n@@ -3726,8 +3932,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n // requires LOCK(cs_vRecvMsg)\n bool ProcessMessages(CNode* pfrom)\n {\n-    //if (fDebug)\n-    //    LogPrintf(\"ProcessMessages(%\"PRIszu\" messages)\\n\", pfrom->vRecvMsg.size());\n+    //if (Log::fDebug)\n+    //    Log() << \"ProcessMessages(\" << pfrom->vRecvMsg.size() << \" messages)\\n\";\n \n     //\n     // Message format\n@@ -3754,10 +3960,8 @@ bool ProcessMessages(CNode* pfrom)\n         // get next message\n         CNetMessage& msg = *it;\n \n-        //if (fDebug)\n-        //    LogPrintf(\"ProcessMessages(message %u msgsz, %\"PRIszu\" bytes, complete:%s)\\n\",\n-        //            msg.hdr.nMessageSize, msg.vRecv.size(),\n-        //            msg.complete() ? \"Y\" : \"N\");\n+        //if (Log::fDebug)\n+        //    Log() << \"ProcessMessages(message \" << msg.hdr.nMessageSize << \" msgsz, \" << msg.vRecv.size() << \" bytes, complete:\" << (msg.complete() ? \"Y\" : \"N\")) << \"\\n\",\n \n         // end, if an incomplete message is found\n         if (!msg.complete())\n@@ -3768,7 +3972,7 @@ bool ProcessMessages(CNode* pfrom)\n \n         // Scan for message start\n         if (memcmp(msg.hdr.pchMessageStart, Params().MessageStart(), MESSAGE_START_SIZE) != 0) {\n-            LogPrintf(\"\\n\\nPROCESSMESSAGE: INVALID MESSAGESTART\\n\\n\");\n+            Log() << \"\\n\\nPROCESSMESSAGE: INVALID MESSAGESTART\\n\\n\";\n             fOk = false;\n             break;\n         }\n@@ -3777,7 +3981,7 @@ bool ProcessMessages(CNode* pfrom)\n         CMessageHeader& hdr = msg.hdr;\n         if (!hdr.IsValid())\n         {\n-            LogPrintf(\"\\n\\nPROCESSMESSAGE: ERRORS IN HEADER %s\\n\\n\\n\", hdr.GetCommand().c_str());\n+            Log() << \"\\n\\nPROCESSMESSAGE: ERRORS IN HEADER \" << hdr.GetCommand() << \"\\n\\n\\n\";\n             continue;\n         }\n         string strCommand = hdr.GetCommand();\n@@ -3792,8 +3996,8 @@ bool ProcessMessages(CNode* pfrom)\n         memcpy(&nChecksum, &hash, sizeof(nChecksum));\n         if (nChecksum != hdr.nChecksum)\n         {\n-            LogPrintf(\"ProcessMessages(%s, %u bytes) : CHECKSUM ERROR nChecksum=%08x hdr.nChecksum=%08x\\n\",\n-               strCommand.c_str(), nMessageSize, nChecksum, hdr.nChecksum);\n+            Log() << \"ProcessMessages(\" << strCommand << \", \" << nMessageSize << \" bytes) : CHECKSUM ERROR nChecksum=\" << boost::format(\"%08x\") % nChecksum\n+                                  << \" hdr.nChecksum=\" << boost::format(\"%08x\") % hdr.nChecksum << \"\\n\";\n             continue;\n         }\n \n@@ -3810,12 +4014,12 @@ bool ProcessMessages(CNode* pfrom)\n             if (strstr(e.what(), \"end of data\"))\n             {\n                 // Allow exceptions from under-length message on vRecv\n-                LogPrintf(\"ProcessMessages(%s, %u bytes) : Exception '%s' caught, normally caused by a message being shorter than its stated length\\n\", strCommand.c_str(), nMessageSize, e.what());\n+                Log() << \"ProcessMessages(\" << strCommand << \", \" << nMessageSize << \" bytes) : Exception '\" << e.what() << \"' caught, normally caused by a message being shorter than its stated length\\n\";\n             }\n             else if (strstr(e.what(), \"size too large\"))\n             {\n                 // Allow exceptions from over-long size\n-                LogPrintf(\"ProcessMessages(%s, %u bytes) : Exception '%s' caught\\n\", strCommand.c_str(), nMessageSize, e.what());\n+                Log() << \"ProcessMessages(\" << strCommand << \", \" << nMessageSize << \" bytes) : Exception '\" << e.what() << \"' caught\\n\";\n             }\n             else\n             {\n@@ -3832,7 +4036,7 @@ bool ProcessMessages(CNode* pfrom)\n         }\n \n         if (!fRet)\n-            LogPrintf(\"ProcessMessage(%s, %u bytes) FAILED\\n\", strCommand.c_str(), nMessageSize);\n+            Log() << \"ProcessMessage(\" << strCommand << \", \" << nMessageSize << \" bytes) FAILED\\n\";\n \n         break;\n     }\n@@ -3860,7 +4064,7 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n             // RPC ping request by user\n             pingSend = true;\n         }\n-        if (pto->nLastSend && GetTime() - pto->nLastSend > 30 * 60 && pto->vSendMsg.empty()) {\n+        if (pto->nLastSend && BitcoinTime::GetTime() - pto->nLastSend > 30 * 60 && pto->vSendMsg.empty()) {\n             // Ping automatically sent as a keepalive\n             pingSend = true;\n         }\n@@ -3873,7 +4077,7 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n             pto->fPingQueued = false;\n             if (pto->nVersion > BIP0031_VERSION) {\n                 // Take timestamp as close as possible before transmitting ping\n-                pto->nPingUsecStart = GetTimeMicros();\n+                pto->nPingUsecStart = BitcoinTime::GetTimeMicros();\n                 pto->PushMessage(\"ping\", nonce);\n             } else {\n                 // Peer is too old to support ping command with nonce, pong will never arrive, disable timing\n@@ -3884,7 +4088,7 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n \n         // Address refresh broadcast\n         static int64_t nLastRebroadcast;\n-        if (!IsInitialBlockDownload() && (GetTime() - nLastRebroadcast > 24 * 60 * 60))\n+        if (!IsInitialBlockDownload() && (BitcoinTime::GetTime() - nLastRebroadcast > 24 * 60 * 60))\n         {\n             {\n                 LOCK(cs_vNodes);\n@@ -3903,7 +4107,7 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n                     }\n                 }\n             }\n-            nLastRebroadcast = GetTime();\n+            nLastRebroadcast = BitcoinTime::GetTime();\n         }\n \n         //\n@@ -4003,14 +4207,14 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n         // Message: getdata\n         //\n         vector<CInv> vGetData;\n-        int64_t nNow = GetTime() * 1000000;\n+        int64_t nNow = BitcoinTime::GetTime() * 1000000;\n         while (!pto->mapAskFor.empty() && (*pto->mapAskFor.begin()).first <= nNow)\n         {\n             const CInv& inv = (*pto->mapAskFor.begin()).second;\n             if (!AlreadyHave(inv))\n             {\n-                if (fDebug)\n-                    LogPrint(\"net\", \"sending getdata: %s\\n\", inv.ToString().c_str());\n+                if (Log::fDebug)\n+                    Log(\"net\") << \"sending getdata: \" << inv.ToString() << \"\\n\";\n                 vGetData.push_back(inv);\n                 if (vGetData.size() >= 1000)\n                 {"
      },
      {
        "sha": "ae6b5b30318b0d5b501c44a6e42035c6795d00ae",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 34,
        "deletions": 18,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -14,6 +14,7 @@\n #include \"chainparams.h\"\n #include \"coins.h\"\n #include \"core.h\"\n+#include \"log.h\"\n #include \"net.h\"\n #include \"script.h\"\n #include \"sync.h\"\n@@ -24,11 +25,14 @@\n #include <exception>\n #include <map>\n #include <set>\n+#include <sstream>\n #include <stdint.h>\n #include <string>\n #include <utility>\n #include <vector>\n \n+#include <boost/format.hpp>\n+\n class CBlockIndex;\n class CBloomFilter;\n class CInv;\n@@ -332,7 +336,10 @@ class CBlockUndo\n         // Open history file to append\n         CAutoFile fileout = CAutoFile(OpenUndoFile(pos), SER_DISK, CLIENT_VERSION);\n         if (!fileout)\n-            return error(\"CBlockUndo::WriteToDisk() : OpenUndoFile failed\");\n+        {\n+            Log() << \"ERROR: CBlockUndo::WriteToDisk() : OpenUndoFile failed\\n\";\n+            return false;\n+        }\n \n         // Write index header\n         unsigned int nSize = fileout.GetSerializeSize(*this);\n@@ -341,7 +348,11 @@ class CBlockUndo\n         // Write undo data\n         long fileOutPos = ftell(fileout);\n         if (fileOutPos < 0)\n-            return error(\"CBlockUndo::WriteToDisk() : ftell failed\");\n+        {\n+            Log() << \"ERROR: CBlockUndo::WriteToDisk() : ftell failed\\n\";\n+            return false;\n+        }\n+\n         pos.nPos = (unsigned int)fileOutPos;\n         fileout << *this;\n \n@@ -364,7 +375,10 @@ class CBlockUndo\n         // Open history file to read\n         CAutoFile filein = CAutoFile(OpenUndoFile(pos, true), SER_DISK, CLIENT_VERSION);\n         if (!filein)\n-            return error(\"CBlockUndo::ReadFromDisk() : OpenBlockFile failed\");\n+        {\n+            Log() << \"ERROR: CBlockUndo::ReadFromDisk() : OpenBlockFile failed\\n\";\n+            return false;\n+        }\n \n         // Read block\n         uint256 hashChecksum;\n@@ -373,15 +387,19 @@ class CBlockUndo\n             filein >> hashChecksum;\n         }\n         catch (std::exception &e) {\n-            return error(\"%s() : deserialize or I/O error\", __PRETTY_FUNCTION__);\n+            Log() << \"ERROR: \" << __PRETTY_FUNCTION__ << \"() : deserialize or I/O error\\n\";\n+            return false;\n         }\n \n         // Verify checksum\n         CHashWriter hasher(SER_GETHASH, PROTOCOL_VERSION);\n         hasher << hashBlock;\n         hasher << *this;\n         if (hashChecksum != hasher.GetHash())\n-            return error(\"CBlockUndo::ReadFromDisk() : checksum mismatch\");\n+        {\n+            Log() << \"ERROR: CBlockUndo::ReadFromDisk() : checksum mismatch\\n\";\n+            return false;\n+        }\n \n         return true;\n     }\n@@ -631,7 +649,10 @@ class CBlockFileInfo\n      }\n \n      std::string ToString() const {\n-         return strprintf(\"CBlockFileInfo(blocks=%u, size=%u, heights=%u...%u, time=%s...%s)\", nBlocks, nSize, nHeightFirst, nHeightLast, DateTimeStrFormat(\"%Y-%m-%d\", nTimeFirst).c_str(), DateTimeStrFormat(\"%Y-%m-%d\", nTimeLast).c_str());\n+         return boost::str(boost::format(\"CBlockFileInfo(blocks=%u, size=%u, heights=%u...%u, time=%s...%s)\") % \n+                                        nBlocks % nSize % nHeightFirst % nHeightLast % \n+                                        BitcoinTime::DateTimeStrFormat(\"%Y-%m-%d\", nTimeFirst) % \n+                                        BitcoinTime::DateTimeStrFormat(\"%Y-%m-%d\", nTimeLast));\n      }\n \n      // update statistics (does not update nSize)\n@@ -835,15 +856,15 @@ class CBlockIndex\n \n     std::string ToString() const\n     {\n-        return strprintf(\"CBlockIndex(pprev=%p, nHeight=%d, merkle=%s, hashBlock=%s)\",\n-            pprev, nHeight,\n-            hashMerkleRoot.ToString().c_str(),\n-            GetBlockHash().ToString().c_str());\n+        return boost::str(boost::format(\"CBlockIndex(pprev=%p, nHeight=%d, merkle=%s, hashBlock=%s)\") %\n+            pprev % nHeight %\n+            hashMerkleRoot.ToString() %\n+            GetBlockHash().ToString());\n     }\n \n     void print() const\n     {\n-        LogPrintf(\"%s\\n\", ToString().c_str());\n+        Log() << ToString() << \"\\n\";\n     }\n };\n \n@@ -902,17 +923,12 @@ class CDiskBlockIndex : public CBlockIndex\n \n     std::string ToString() const\n     {\n-        std::string str = \"CDiskBlockIndex(\";\n-        str += CBlockIndex::ToString();\n-        str += strprintf(\"\\n                hashBlock=%s, hashPrev=%s)\",\n-            GetBlockHash().ToString().c_str(),\n-            hashPrev.ToString().c_str());\n-        return str;\n+        return boost::str(boost::format(\"CDiskBlockIndex(%s\\nhashBlock=%s, hashPrev=%s)\") % CBlockIndex::ToString() % GetBlockHash().ToString() % hashPrev.ToString());\n     }\n \n     void print() const\n     {\n-        LogPrintf(\"%s\\n\", ToString().c_str());\n+        Log() << ToString() << \"\\n\";\n     }\n };\n "
      },
      {
        "sha": "334eb30c3582fa41808ab50035746e70e0746e35",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 39,
        "deletions": 27,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -5,11 +5,17 @@\n \n #include \"miner.h\"\n \n+#include \"bitcointime.h\"\n #include \"core.h\"\n+#include \"log.h\"\n #include \"main.h\"\n #include \"net.h\"\n #include \"wallet.h\"\n \n+#include <iomanip>\n+#include <ios>\n+#include <stdint.h>\n+\n double dHashesPerSec = 0.0;\n int64_t nHPSTimerStart = 0;\n \n@@ -106,10 +112,10 @@ class COrphan\n \n     void print() const\n     {\n-        LogPrintf(\"COrphan(hash=%s, dPriority=%.1f, dFeePerKb=%.1f)\\n\",\n-               ptx->GetHash().ToString().c_str(), dPriority, dFeePerKb);\n+        Log() << \"COrphan(hash=\" << ptx->GetHash().ToString() << \", dPriority=\" << std::fixed << std::setprecision(1) << dPriority << \",\" \n+                              << \" dFeePerKb=\" << std::fixed << std::setprecision(1) << dFeePerKb << \")\\n\";\n         BOOST_FOREACH(uint256 hash, setDependsOn)\n-            LogPrintf(\"   setDependsOn %s\\n\", hash.ToString().c_str());\n+            Log() << \"   setDependsOn \" << hash.ToString() << \"\\n\";\n     }\n };\n \n@@ -212,8 +218,8 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n                     // or other transactions in the memory pool.\n                     if (!mempool.mapTx.count(txin.prevout.hash))\n                     {\n-                        LogPrintf(\"ERROR: mempool transaction missing input\\n\");\n-                        if (fDebug) assert(\"mempool transaction missing input\" == 0);\n+                        Log() << \"ERROR: mempool transaction missing input\\n\";\n+                        if (Log::fDebug) assert(\"mempool transaction missing input\" == 0);\n                         fMissingInputs = true;\n                         if (porphan)\n                             vOrphan.pop_back();\n@@ -332,8 +338,9 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n \n             if (fPrintPriority)\n             {\n-                LogPrintf(\"priority %.1f feeperkb %.1f txid %s\\n\",\n-                       dPriority, dFeePerKb, tx.GetHash().ToString().c_str());\n+                Log() << \"priority \" << std::fixed << std::setprecision(1) << dPriority \n+                      << \" feeperkb \" << std::fixed << std::setprecision(1) << dFeePerKb \n+                      << \" txid \" << tx.GetHash().ToString() << \"\\n\";\n             }\n \n             // Add transactions that depend on this one to the priority queue\n@@ -356,7 +363,7 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n \n         nLastBlockTx = nBlockTx;\n         nLastBlockSize = nBlockSize;\n-        LogPrintf(\"CreateNewBlock(): total size %\"PRIu64\"\\n\", nBlockSize);\n+        Log() << \"CreateNewBlock(): total size \" << nBlockSize << \"\\n\";\n \n         pblock->vtx[0].vout[0].nValue = GetBlockValue(pindexPrev->nHeight+1, nFees);\n         pblocktemplate->vTxFees[0] = -nFees;\n@@ -464,16 +471,19 @@ bool CheckWork(CBlock* pblock, CWallet& wallet, CReserveKey& reservekey)\n         return false;\n \n     //// debug print\n-    LogPrintf(\"BitcoinMiner:\\n\");\n-    LogPrintf(\"proof-of-work found  \\n  hash: %s  \\ntarget: %s\\n\", hash.GetHex().c_str(), hashTarget.GetHex().c_str());\n+    Log() << \"BitcoinMiner:\\n\";\n+    Log() << \"proof-of-work found  \\n  hash: \" << hash.GetHex() << \"  \\ntarget: \" << hashTarget.GetHex() << \"\\n\";\n     pblock->print();\n-    LogPrintf(\"generated %s\\n\", FormatMoney(pblock->vtx[0].vout[0].nValue).c_str());\n+    Log() << \"generated \" << FormatMoney(pblock->vtx[0].vout[0].nValue) << \"\\n\";\n \n     // Found a solution\n     {\n         LOCK(cs_main);\n         if (pblock->hashPrevBlock != chainActive.Tip()->GetBlockHash())\n-            return error(\"BitcoinMiner : generated block is stale\");\n+        {\n+            Log() << \"ERROR: BitcoinMiner : generated block is stale\\n\";\n+            return false;\n+        }\n \n         // Remove key from key pool\n         reservekey.KeepKey();\n@@ -487,15 +497,18 @@ bool CheckWork(CBlock* pblock, CWallet& wallet, CReserveKey& reservekey)\n         // Process this block the same as if we had received it from another node\n         CValidationState state;\n         if (!ProcessBlock(state, NULL, pblock))\n-            return error(\"BitcoinMiner : ProcessBlock, block not accepted\");\n+        {\n+            Log() << \"ERROR: BitcoinMiner : ProcessBlock, block not accepted\\n\";\n+            return false;\n+        }\n     }\n \n     return true;\n }\n \n void static BitcoinMiner(CWallet *pwallet)\n {\n-    LogPrintf(\"BitcoinMiner started\\n\");\n+    Log() << \"BitcoinMiner started\\n\";\n     SetThreadPriority(THREAD_PRIORITY_LOWEST);\n     RenameThread(\"bitcoin-miner\");\n \n@@ -523,8 +536,7 @@ void static BitcoinMiner(CWallet *pwallet)\n         CBlock *pblock = &pblocktemplate->block;\n         IncrementExtraNonce(pblock, pindexPrev, nExtraNonce);\n \n-        LogPrintf(\"Running BitcoinMiner with %\"PRIszu\" transactions in block (%u bytes)\\n\", pblock->vtx.size(),\n-               ::GetSerializeSize(*pblock, SER_NETWORK, PROTOCOL_VERSION));\n+        Log() << \"Running BitcoinMiner with \" << pblock->vtx.size() << \" transactions in block (\" << ::GetSerializeSize(*pblock, SER_NETWORK, PROTOCOL_VERSION) << \" bytes)\\n\";\n \n         //\n         // Pre-build hash buffers\n@@ -543,7 +555,7 @@ void static BitcoinMiner(CWallet *pwallet)\n         //\n         // Search\n         //\n-        int64_t nStart = GetTime();\n+        int64_t nStart = BitcoinTime::GetTime();\n         uint256 hashTarget = CBigNum().SetCompact(pblock->nBits).getuint256();\n         uint256 hashbuf[2];\n         uint256& hash = *alignup<16>(hashbuf);\n@@ -585,26 +597,26 @@ void static BitcoinMiner(CWallet *pwallet)\n             static int64_t nHashCounter;\n             if (nHPSTimerStart == 0)\n             {\n-                nHPSTimerStart = GetTimeMillis();\n+                nHPSTimerStart = BitcoinTime::GetTimeMillis();\n                 nHashCounter = 0;\n             }\n             else\n                 nHashCounter += nHashesDone;\n-            if (GetTimeMillis() - nHPSTimerStart > 4000)\n+            if (BitcoinTime::GetTimeMillis() - nHPSTimerStart > 4000)\n             {\n                 static CCriticalSection cs;\n                 {\n                     LOCK(cs);\n-                    if (GetTimeMillis() - nHPSTimerStart > 4000)\n+                    if (BitcoinTime::GetTimeMillis() - nHPSTimerStart > 4000)\n                     {\n-                        dHashesPerSec = 1000.0 * nHashCounter / (GetTimeMillis() - nHPSTimerStart);\n-                        nHPSTimerStart = GetTimeMillis();\n+                        dHashesPerSec = 1000.0 * nHashCounter / (BitcoinTime::GetTimeMillis() - nHPSTimerStart);\n+                        nHPSTimerStart = BitcoinTime::GetTimeMillis();\n                         nHashCounter = 0;\n                         static int64_t nLogTime;\n-                        if (GetTime() - nLogTime > 30 * 60)\n+                        if (BitcoinTime::GetTime() - nLogTime > 30 * 60)\n                         {\n-                            nLogTime = GetTime();\n-                            LogPrintf(\"hashmeter %6.0f khash/s\\n\", dHashesPerSec/1000.0);\n+                            nLogTime = BitcoinTime::GetTime();\n+                            Log() << \"hashmeter \" << std::fixed << std::setw(6) << std::setprecision(0) << (dHashesPerSec/1000.0) << \" khash/s\\n\";\n                         }\n                     }\n                 }\n@@ -616,7 +628,7 @@ void static BitcoinMiner(CWallet *pwallet)\n                 break;\n             if (nBlockNonce >= 0xffff0000)\n                 break;\n-            if (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLast && GetTime() - nStart > 60)\n+            if (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLast && BitcoinTime::GetTime() - nStart > 60)\n                 break;\n             if (pindexPrev != chainActive.Tip())\n                 break;\n@@ -634,7 +646,7 @@ void static BitcoinMiner(CWallet *pwallet)\n     } }\n     catch (boost::thread_interrupted)\n     {\n-        LogPrintf(\"BitcoinMiner terminated\\n\");\n+        Log() << \"BitcoinMiner terminated\\n\";\n         throw;\n     }\n }"
      },
      {
        "sha": "759978e47daeacb0f0eab77af5cf9722ef44590f",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 88,
        "deletions": 80,
        "changes": 168,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -10,17 +10,25 @@\n #include \"net.h\"\n \n #include \"addrman.h\"\n+#include \"bitcointime.h\"\n #include \"chainparams.h\"\n #include \"core.h\"\n #include \"db.h\"\n #include \"ui_interface.h\"\n \n+#include <iomanip>\n+#include <ios>\n+#include <stdint.h>\n+#include <string>\n+\n #ifdef WIN32\n #include <string.h>\n #else\n #include <fcntl.h>\n #endif\n \n+#include <boost/format.hpp>\n+\n #ifdef USE_UPNP\n #include <miniupnpc/miniupnpc.h>\n #include <miniupnpc/miniwget.h>\n@@ -131,7 +139,7 @@ CAddress GetLocalAddress(const CNetAddr *paddrPeer)\n     {\n         ret = CAddress(addr);\n         ret.nServices = nLocalServices;\n-        ret.nTime = GetAdjustedTime();\n+        ret.nTime = BitcoinTime::GetAdjustedTime();\n     }\n     return ret;\n }\n@@ -172,14 +180,14 @@ bool RecvLine(SOCKET hSocket, string& strLine)\n             if (nBytes == 0)\n             {\n                 // socket closed\n-                LogPrint(\"net\", \"socket closed\\n\");\n+                Log(\"net\") <<  \"socket closed\\n\";\n                 return false;\n             }\n             else\n             {\n                 // socket error\n                 int nErr = WSAGetLastError();\n-                LogPrint(\"net\", \"recv failed: %d\\n\", nErr);\n+                Log(\"net\") << \"recv failed: \" << nErr << \"\\n\";\n                 return false;\n             }\n         }\n@@ -225,7 +233,7 @@ bool AddLocal(const CService& addr, int nScore)\n     if (IsLimited(addr))\n         return false;\n \n-    LogPrintf(\"AddLocal(%s,%i)\\n\", addr.ToString().c_str(), nScore);\n+    Log() << \"AddLocal(\" << addr.ToString() << \",\" << nScore << \")\\n\";\n \n     {\n         LOCK(cs_mapLocalHost);\n@@ -302,7 +310,10 @@ bool GetMyExternalIP2(const CService& addrConnect, const char* pszGet, const cha\n {\n     SOCKET hSocket;\n     if (!ConnectSocket(addrConnect, hSocket))\n-        return error(\"GetMyExternalIP() : connection to %s failed\", addrConnect.ToString().c_str());\n+    {\n+        Log() << \"ERROR: GetMyExternalIP() : connection to \" << addrConnect.ToString() << \" failed\\n\";\n+        return false;\n+    }\n \n     send(hSocket, pszGet, strlen(pszGet), MSG_NOSIGNAL);\n \n@@ -333,15 +344,16 @@ bool GetMyExternalIP2(const CService& addrConnect, const char* pszGet, const cha\n             while (strLine.size() > 0 && isspace(strLine[strLine.size()-1]))\n                 strLine.resize(strLine.size()-1);\n             CService addr(strLine,0,true);\n-            LogPrintf(\"GetMyExternalIP() received [%s] %s\\n\", strLine.c_str(), addr.ToString().c_str());\n+            Log() << \"GetMyExternalIP() received [\" << strLine << \"] \" << addr.ToString() << \"\\n\";\n             if (!addr.IsValid() || !addr.IsRoutable())\n                 return false;\n             ipRet.SetIP(addr);\n             return true;\n         }\n     }\n     closesocket(hSocket);\n-    return error(\"GetMyExternalIP() : connection closed\");\n+    Log() << \"ERROR: GetMyExternalIP() : connection closed\\n\";\n+    return false;\n }\n \n bool GetMyExternalIP(CNetAddr& ipRet)\n@@ -408,7 +420,7 @@ void ThreadGetMyExternalIP()\n     CNetAddr addrLocalHost;\n     if (GetMyExternalIP(addrLocalHost))\n     {\n-        LogPrintf(\"GetMyExternalIP() returned %s\\n\", addrLocalHost.ToStringIP().c_str());\n+        Log() << \"GetMyExternalIP() returned \" << addrLocalHost.ToStringIP() << \"\\n\";\n         AddLocal(addrLocalHost, LOCAL_HTTP);\n     }\n }\n@@ -474,26 +486,24 @@ CNode* ConnectNode(CAddress addrConnect, const char *pszDest)\n \n \n     /// debug print\n-    LogPrint(\"net\", \"trying connection %s lastseen=%.1fhrs\\n\",\n-        pszDest ? pszDest : addrConnect.ToString().c_str(),\n-        pszDest ? 0 : (double)(GetAdjustedTime() - addrConnect.nTime)/3600.0);\n+    Log(\"net\") << \"trying connection \" << (pszDest ? pszDest : addrConnect.ToString()) << \" lastseen=\" << fixed << setprecision(1) << (pszDest ? 0 : (double)(BitcoinTime::GetAdjustedTime() - addrConnect.nTime)/3600.0) << \"hrs\\n\";\n \n     // Connect\n     SOCKET hSocket;\n     if (pszDest ? ConnectSocketByName(addrConnect, hSocket, pszDest, Params().GetDefaultPort()) : ConnectSocket(addrConnect, hSocket))\n     {\n         addrman.Attempt(addrConnect);\n \n-        LogPrint(\"net\", \"connected %s\\n\", pszDest ? pszDest : addrConnect.ToString().c_str());\n+        Log(\"net\") << \"connected \" << (pszDest ? pszDest : addrConnect.ToString()) << \"\\n\";\n \n         // Set to non-blocking\n #ifdef WIN32\n         u_long nOne = 1;\n         if (ioctlsocket(hSocket, FIONBIO, &nOne) == SOCKET_ERROR)\n-            LogPrintf(\"ConnectSocket() : ioctlsocket non-blocking setting failed, error %d\\n\", WSAGetLastError());\n+            Log() << \"ConnectSocket() : ioctlsocket non-blocking setting failed, error \" << WSAGetLastError() << \"\\n\";\n #else\n         if (fcntl(hSocket, F_SETFL, O_NONBLOCK) == SOCKET_ERROR)\n-            LogPrintf(\"ConnectSocket() : fcntl non-blocking setting failed, error %d\\n\", errno);\n+            Log() << \"ConnectSocket() : fcntl non-blocking setting failed, error \" << errno << \"\\n\";\n #endif\n \n         // Add node\n@@ -505,7 +515,7 @@ CNode* ConnectNode(CAddress addrConnect, const char *pszDest)\n             vNodes.push_back(pnode);\n         }\n \n-        pnode->nTimeConnected = GetTime();\n+        pnode->nTimeConnected = BitcoinTime::GetTime();\n         return pnode;\n     }\n     else\n@@ -519,7 +529,7 @@ void CNode::CloseSocketDisconnect()\n     fDisconnect = true;\n     if (hSocket != INVALID_SOCKET)\n     {\n-        LogPrint(\"net\", \"disconnecting node %s\\n\", addrName.c_str());\n+        Log(\"net\") << \"disconnecting node \" << addrName << \"\\n\";\n         closesocket(hSocket);\n         hSocket = INVALID_SOCKET;\n     }\n@@ -543,12 +553,12 @@ void CNode::PushVersion()\n {\n     int nBestHeight = g_signals.GetHeight().get_value_or(0);\n \n-    /// when NTP implemented, change to just nTime = GetAdjustedTime()\n-    int64_t nTime = (fInbound ? GetAdjustedTime() : GetTime());\n+    /// when NTP implemented, change to just nTime = BitcoinTime::GetAdjustedTime()\n+    int64_t nTime = (fInbound ? BitcoinTime::GetAdjustedTime() : BitcoinTime::GetTime());\n     CAddress addrYou = (addr.IsRoutable() && !IsProxy(addr) ? addr : CAddress(CService(\"0.0.0.0\",0)));\n     CAddress addrMe = GetLocalAddress(&addr);\n     RAND_bytes((unsigned char*)&nLocalHostNonce, sizeof(nLocalHostNonce));\n-    LogPrint(\"net\", \"send version message: version %d, blocks=%d, us=%s, them=%s, peer=%s\\n\", PROTOCOL_VERSION, nBestHeight, addrMe.ToString().c_str(), addrYou.ToString().c_str(), addr.ToString().c_str());\n+    Log(\"net\") << \"send version message: version \" << PROTOCOL_VERSION << \", blocks=\" << nBestHeight << \", us=\" << addrMe.ToString() << \", them=\" << addrYou.ToString() << \", peer=\" << addr.ToString() << \"\\n\";\n     PushMessage(\"version\", PROTOCOL_VERSION, nLocalServices, nTime, addrYou, addrMe,\n                 nLocalHostNonce, FormatSubVersion(CLIENT_NAME, CLIENT_VERSION, std::vector<string>()), nBestHeight, true);\n }\n@@ -574,7 +584,7 @@ bool CNode::IsBanned(CNetAddr ip)\n         if (i != setBanned.end())\n         {\n             int64_t t = (*i).second;\n-            if (GetTime() < t)\n+            if (BitcoinTime::GetTime() < t)\n                 fResult = true;\n         }\n     }\n@@ -585,15 +595,15 @@ bool CNode::Misbehaving(int howmuch)\n {\n     if (addr.IsLocal())\n     {\n-        LogPrintf(\"Warning: Local node %s misbehaving (delta: %d)!\\n\", addrName.c_str(), howmuch);\n+        Log() << \"Warning: Local node \" << addrName << \" misbehaving (delta: \" << howmuch << \")!\\n\";\n         return false;\n     }\n \n     nMisbehavior += howmuch;\n     if (nMisbehavior >= GetArg(\"-banscore\", 100))\n     {\n-        int64_t banTime = GetTime()+GetArg(\"-bantime\", 60*60*24);  // Default 24-hour ban\n-        LogPrintf(\"Misbehaving: %s (%d -> %d) DISCONNECTING\\n\", addr.ToString().c_str(), nMisbehavior-howmuch, nMisbehavior);\n+        int64_t banTime = BitcoinTime::GetTime()+GetArg(\"-bantime\", 60*60*24);  // Default 24-hour ban\n+        Log() << \"Misbehaving: \" << addr.ToString() << \" (\" << (nMisbehavior - howmuch) << \" -> \" <<  nMisbehavior << \") DISCONNECTING\\n\";\n         {\n             LOCK(cs_setBanned);\n             if (setBanned[addr] < banTime)\n@@ -602,7 +612,7 @@ bool CNode::Misbehaving(int howmuch)\n         CloseSocketDisconnect();\n         return true;\n     } else\n-        LogPrintf(\"Misbehaving: %s (%d -> %d)\\n\", addr.ToString().c_str(), nMisbehavior-howmuch, nMisbehavior);\n+        Log() << \"Misbehaving: \" << addr.ToString() << \" (\" << (nMisbehavior - howmuch) << \" -> \" << nMisbehavior << \")\\n\";\n     return false;\n }\n \n@@ -632,7 +642,7 @@ void CNode::copyStats(CNodeStats &stats)\n     // the caller can immediately detect that this is happening.\n     int64_t nPingUsecWait = 0;\n     if ((0 != nPingNonceSent) && (0 != nPingUsecStart)) {\n-        nPingUsecWait = GetTimeMicros() - nPingUsecStart;\n+        nPingUsecWait = BitcoinTime::GetTimeMicros() - nPingUsecStart;\n     }\n \n     // Raw ping time is in microseconds, but show it to user as whole seconds (Bitcoin users should be well used to small numbers with many decimal places by now :)\n@@ -734,7 +744,7 @@ void SocketSendData(CNode *pnode)\n         assert(data.size() > pnode->nSendOffset);\n         int nBytes = send(pnode->hSocket, &data[pnode->nSendOffset], data.size() - pnode->nSendOffset, MSG_NOSIGNAL | MSG_DONTWAIT);\n         if (nBytes > 0) {\n-            pnode->nLastSend = GetTime();\n+            pnode->nLastSend = BitcoinTime::GetTime();\n             pnode->nSendBytes += nBytes;\n             pnode->nSendOffset += nBytes;\n             pnode->RecordBytesSent(nBytes);\n@@ -752,7 +762,7 @@ void SocketSendData(CNode *pnode)\n                 int nErr = WSAGetLastError();\n                 if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS)\n                 {\n-                    LogPrintf(\"socket send error %d\\n\", nErr);\n+                    Log() << \"socket send error \" << nErr << \"\\n\";\n                     pnode->CloseSocketDisconnect();\n                 }\n             }\n@@ -912,7 +922,7 @@ void ThreadSocketHandler()\n             if (have_fds)\n             {\n                 int nErr = WSAGetLastError();\n-                LogPrintf(\"socket select error %d\\n\", nErr);\n+                Log() << \"socket select error \" << nErr << \"\\n\";\n                 for (unsigned int i = 0; i <= hSocketMax; i++)\n                     FD_SET(i, &fdsetRecv);\n             }\n@@ -940,7 +950,7 @@ void ThreadSocketHandler()\n \n             if (hSocket != INVALID_SOCKET)\n                 if (!addr.SetSockAddr((const struct sockaddr*)&sockaddr))\n-                    LogPrintf(\"Warning: Unknown socket family\\n\");\n+                    Log() << \"Warning: Unknown socket family\\n\";\n \n             {\n                 LOCK(cs_vNodes);\n@@ -953,7 +963,7 @@ void ThreadSocketHandler()\n             {\n                 int nErr = WSAGetLastError();\n                 if (nErr != WSAEWOULDBLOCK)\n-                    LogPrintf(\"socket error accept failed: %d\\n\", nErr);\n+                    Log() << \"socket error accept failed: \" << nErr << \"\\n\";\n             }\n             else if (nInbound >= nMaxConnections - MAX_OUTBOUND_CONNECTIONS)\n             {\n@@ -965,12 +975,12 @@ void ThreadSocketHandler()\n             }\n             else if (CNode::IsBanned(addr))\n             {\n-                LogPrintf(\"connection from %s dropped (banned)\\n\", addr.ToString().c_str());\n+                Log() << \"connection from \" << addr.ToString() << \" dropped (banned)\\n\";\n                 closesocket(hSocket);\n             }\n             else\n             {\n-                LogPrint(\"net\", \"accepted connection %s\\n\", addr.ToString().c_str());\n+                Log(\"net\") << \"accepted connection \" << addr.ToString() << \"\\n\";\n                 CNode* pnode = new CNode(hSocket, addr, \"\", true);\n                 pnode->AddRef();\n                 {\n@@ -1013,15 +1023,15 @@ void ThreadSocketHandler()\n                         {\n                             if (!pnode->ReceiveMsgBytes(pchBuf, nBytes))\n                                 pnode->CloseSocketDisconnect();\n-                            pnode->nLastRecv = GetTime();\n+                            pnode->nLastRecv = BitcoinTime::GetTime();\n                             pnode->nRecvBytes += nBytes;\n                             pnode->RecordBytesRecv(nBytes);\n                         }\n                         else if (nBytes == 0)\n                         {\n                             // socket closed gracefully\n                             if (!pnode->fDisconnect)\n-                                LogPrint(\"net\", \"socket closed\\n\");\n+                                Log(\"net\") << \"socket closed\\n\";\n                             pnode->CloseSocketDisconnect();\n                         }\n                         else if (nBytes < 0)\n@@ -1031,7 +1041,7 @@ void ThreadSocketHandler()\n                             if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS)\n                             {\n                                 if (!pnode->fDisconnect)\n-                                    LogPrintf(\"socket recv error %d\\n\", nErr);\n+                                    Log() << \"socket recv error \" << nErr << \"\\n\";\n                                 pnode->CloseSocketDisconnect();\n                             }\n                         }\n@@ -1055,22 +1065,22 @@ void ThreadSocketHandler()\n             // Inactivity checking\n             //\n             if (pnode->vSendMsg.empty())\n-                pnode->nLastSendEmpty = GetTime();\n-            if (GetTime() - pnode->nTimeConnected > 60)\n+                pnode->nLastSendEmpty = BitcoinTime::GetTime();\n+            if (BitcoinTime::GetTime() - pnode->nTimeConnected > 60)\n             {\n                 if (pnode->nLastRecv == 0 || pnode->nLastSend == 0)\n                 {\n-                    LogPrint(\"net\", \"socket no message in first 60 seconds, %d %d\\n\", pnode->nLastRecv != 0, pnode->nLastSend != 0);\n+                    Log(\"net\") << \"socket no message in first 60 seconds, \" << (pnode->nLastRecv != 0) << \" \" << (pnode->nLastSend != 0) << \"\\n\";\n                     pnode->fDisconnect = true;\n                 }\n-                else if (GetTime() - pnode->nLastSend > 90*60 && GetTime() - pnode->nLastSendEmpty > 90*60)\n+                else if (BitcoinTime::GetTime() - pnode->nLastSend > 90*60 && BitcoinTime::GetTime() - pnode->nLastSendEmpty > 90*60)\n                 {\n-                    LogPrintf(\"socket not sending\\n\");\n+                    Log() << \"socket not sending\\n\";\n                     pnode->fDisconnect = true;\n                 }\n-                else if (GetTime() - pnode->nLastRecv > 90*60)\n+                else if (BitcoinTime::GetTime() - pnode->nLastRecv > 90*60)\n                 {\n-                    LogPrintf(\"socket inactivity timeout\\n\");\n+                    Log() << \"socket inactivity timeout\\n\";\n                     pnode->fDisconnect = true;\n                 }\n             }\n@@ -1096,7 +1106,7 @@ void ThreadSocketHandler()\n #ifdef USE_UPNP\n void ThreadMapPort()\n {\n-    std::string port = strprintf(\"%u\", GetListenPort());\n+    std::string port = boost::str(boost::format(\"%u\") % GetListenPort());\n     const char * multicastif = 0;\n     const char * minissdpdpath = 0;\n     struct UPNPDev * devlist = 0;\n@@ -1122,16 +1132,16 @@ void ThreadMapPort()\n             char externalIPAddress[40];\n             r = UPNP_GetExternalIPAddress(urls.controlURL, data.first.servicetype, externalIPAddress);\n             if(r != UPNPCOMMAND_SUCCESS)\n-                LogPrintf(\"UPnP: GetExternalIPAddress() returned %d\\n\", r);\n+                Log() << \"UPnP: GetExternalIPAddress() returned \" << r << \"\\n\";\n             else\n             {\n                 if(externalIPAddress[0])\n                 {\n-                    LogPrintf(\"UPnP: ExternalIPAddress = %s\\n\", externalIPAddress);\n+                    Log() << \"UPnP: ExternalIPAddress = \" << externalIPAddress << \"\\n\";\n                     AddLocal(CNetAddr(externalIPAddress), LOCAL_UPNP);\n                 }\n                 else\n-                    LogPrintf(\"UPnP: GetExternalIPAddress failed.\\n\");\n+                    Log() << \"UPnP: GetExternalIPAddress failed.\\n\";\n             }\n         }\n \n@@ -1150,24 +1160,23 @@ void ThreadMapPort()\n #endif\n \n                 if(r!=UPNPCOMMAND_SUCCESS)\n-                    LogPrintf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\",\n-                        port.c_str(), port.c_str(), lanaddr, r, strupnperror(r));\n+                    Log() << \"AddPortMapping(\" << port << \", \" << port << \", \" << lanaddr << \") failed with code \" << r << \" (\" << strupnperror(r) << \")\\n\";\n                 else\n-                    LogPrintf(\"UPnP Port Mapping successful.\\n\");;\n+                    Log() << \"UPnP Port Mapping successful.\\n\";\n \n                 MilliSleep(20*60*1000); // Refresh every 20 minutes\n             }\n         }\n         catch (boost::thread_interrupted)\n         {\n             r = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, port.c_str(), \"TCP\", 0);\n-            LogPrintf(\"UPNP_DeletePortMapping() returned : %d\\n\", r);\n+            Log() << \"UPNP_DeletePortMapping() returned : \" << r << \"\\n\";\n             freeUPNPDevlist(devlist); devlist = 0;\n             FreeUPNPUrls(&urls);\n             throw;\n         }\n     } else {\n-        LogPrintf(\"No valid UPnP IGDs found\\n\");\n+        Log() << \"No valid UPnP IGDs found\\n\";\n         freeUPNPDevlist(devlist); devlist = 0;\n         if (r != 0)\n             FreeUPNPUrls(&urls);\n@@ -1212,7 +1221,7 @@ void ThreadDNSAddressSeed()\n     const vector<CDNSSeedData> &vSeeds = Params().DNSSeeds();\n     int found = 0;\n \n-    LogPrintf(\"Loading addresses from DNS seeds (could take a while)\\n\");\n+    Log() << \"Loading addresses from DNS seeds (could take a while)\\n\";\n \n     BOOST_FOREACH(const CDNSSeedData &seed, vSeeds) {\n         if (HaveNameProxy()) {\n@@ -1226,7 +1235,7 @@ void ThreadDNSAddressSeed()\n                 {\n                     int nOneDay = 24*3600;\n                     CAddress addr = CAddress(CService(ip, Params().GetDefaultPort()));\n-                    addr.nTime = GetTime() - 3*nOneDay - GetRand(4*nOneDay); // use a random age between 3 and 7 days old\n+                    addr.nTime = BitcoinTime::GetTime() - 3*nOneDay - GetRand(4*nOneDay); // use a random age between 3 and 7 days old\n                     vAdd.push_back(addr);\n                     found++;\n                 }\n@@ -1235,7 +1244,7 @@ void ThreadDNSAddressSeed()\n         }\n     }\n \n-    LogPrintf(\"%d addresses found from DNS seeds\\n\", found);\n+    Log() << found << \" addresses found from DNS seeds\\n\";\n }\n \n \n@@ -1251,13 +1260,12 @@ void ThreadDNSAddressSeed()\n \n void DumpAddresses()\n {\n-    int64_t nStart = GetTimeMillis();\n+    int64_t nStart = BitcoinTime::GetTimeMillis();\n \n     CAddrDB adb;\n     adb.Write(addrman);\n \n-    LogPrint(\"net\", \"Flushed %d addresses to peers.dat  %\"PRId64\"ms\\n\",\n-           addrman.size(), GetTimeMillis() - nStart);\n+    Log(\"net\") << \"Flushed \" << addrman.size() << \" addresses to peers.dat  \" << (BitcoinTime::GetTimeMillis() - nStart) << \"ms\\n\";\n }\n \n void static ProcessOneShot()\n@@ -1300,7 +1308,7 @@ void ThreadOpenConnections()\n     }\n \n     // Initiate network connections\n-    int64_t nStart = GetTime();\n+    int64_t nStart = BitcoinTime::GetTime();\n     while (true)\n     {\n         ProcessOneShot();\n@@ -1311,10 +1319,10 @@ void ThreadOpenConnections()\n         boost::this_thread::interruption_point();\n \n         // Add seed nodes if DNS seeds are all down (an infrastructure attack?).\n-        if (addrman.size() == 0 && (GetTime() - nStart > 60)) {\n+        if (addrman.size() == 0 && (BitcoinTime::GetTime() - nStart > 60)) {\n             static bool done = false;\n             if (!done) {\n-                LogPrintf(\"Adding fixed seed nodes as DNS doesn't seem to be available.\\n\");\n+                Log() << \"Adding fixed seed nodes as DNS doesn't seem to be available.\\n\";\n                 addrman.Add(Params().FixedSeeds(), CNetAddr(\"127.0.0.1\"));\n                 done = true;\n             }\n@@ -1339,7 +1347,7 @@ void ThreadOpenConnections()\n             }\n         }\n \n-        int64_t nANow = GetAdjustedTime();\n+        int64_t nANow = BitcoinTime::GetAdjustedTime();\n \n         int nTries = 0;\n         while (true)\n@@ -1605,16 +1613,16 @@ bool BindListenPort(const CService &addrBind, string& strError)\n     socklen_t len = sizeof(sockaddr);\n     if (!addrBind.GetSockAddr((struct sockaddr*)&sockaddr, &len))\n     {\n-        strError = strprintf(\"Error: bind address family for %s not supported\", addrBind.ToString().c_str());\n-        LogPrintf(\"%s\\n\", strError.c_str());\n+        strError = boost::str(boost::format(\"Error: bind address family for %s not supported\") % addrBind.ToString());\n+        Log() << strError << \"\\n\";\n         return false;\n     }\n \n     SOCKET hListenSocket = socket(((struct sockaddr*)&sockaddr)->sa_family, SOCK_STREAM, IPPROTO_TCP);\n     if (hListenSocket == INVALID_SOCKET)\n     {\n-        strError = strprintf(\"Error: Couldn't open socket for incoming connections (socket returned error %d)\", WSAGetLastError());\n-        LogPrintf(\"%s\\n\", strError.c_str());\n+        strError = boost::str(boost::format(\"Error: Couldn't open socket for incoming connections (socket returned error %d)\") % WSAGetLastError());\n+        Log() << strError << \"\\n\";\n         return false;\n     }\n \n@@ -1637,8 +1645,8 @@ bool BindListenPort(const CService &addrBind, string& strError)\n     if (fcntl(hListenSocket, F_SETFL, O_NONBLOCK) == SOCKET_ERROR)\n #endif\n     {\n-        strError = strprintf(\"Error: Couldn't set properties on socket for incoming connections (error %d)\", WSAGetLastError());\n-        LogPrintf(\"%s\\n\", strError.c_str());\n+        strError = boost::str(boost::format(\"Error: Couldn't set properties on socket for incoming connections (error %d)\") % WSAGetLastError());\n+        Log() << strError << \"\\n\";\n         return false;\n     }\n \n@@ -1666,19 +1674,19 @@ bool BindListenPort(const CService &addrBind, string& strError)\n     {\n         int nErr = WSAGetLastError();\n         if (nErr == WSAEADDRINUSE)\n-            strError = strprintf(_(\"Unable to bind to %s on this computer. Bitcoin is probably already running.\"), addrBind.ToString().c_str());\n+            strError = str(_(\"Unable to bind to %s on this computer. Bitcoin is probably already running.\") % addrBind.ToString());\n         else\n-            strError = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %d, %s)\"), addrBind.ToString().c_str(), nErr, strerror(nErr));\n-        LogPrintf(\"%s\\n\", strError.c_str());\n+            strError = str(_(\"Unable to bind to %s on this computer (bind returned error %d, %s)\") % addrBind.ToString() % nErr % strerror(nErr));\n+        Log() << strError << \"\\n\";\n         return false;\n     }\n-    LogPrintf(\"Bound to %s\\n\", addrBind.ToString().c_str());\n+    Log() << \"Bound to \" << addrBind.ToString() << \"\\n\";\n \n     // Listen for incoming connections\n     if (listen(hListenSocket, SOMAXCONN) == SOCKET_ERROR)\n     {\n-        strError = strprintf(\"Error: Listening for incoming connections failed (listen returned error %d)\", WSAGetLastError());\n-        LogPrintf(\"%s\\n\", strError.c_str());\n+        strError = boost::str(boost::format(\"Error: Listening for incoming connections failed (listen returned error %d)\") % WSAGetLastError());\n+        Log() << strError << \"\\n\";\n         return false;\n     }\n \n@@ -1725,15 +1733,15 @@ void static Discover()\n                 struct sockaddr_in* s4 = (struct sockaddr_in*)(ifa->ifa_addr);\n                 CNetAddr addr(s4->sin_addr);\n                 if (AddLocal(addr, LOCAL_IF))\n-                    LogPrintf(\"IPv4 %s: %s\\n\", ifa->ifa_name, addr.ToString().c_str());\n+                    Log() << \"IPv4 \" << ifa->ifa_name << \": \" << addr.ToString() << \"\\n\";\n             }\n #ifdef USE_IPV6\n             else if (ifa->ifa_addr->sa_family == AF_INET6)\n             {\n                 struct sockaddr_in6* s6 = (struct sockaddr_in6*)(ifa->ifa_addr);\n                 CNetAddr addr(s6->sin6_addr);\n                 if (AddLocal(addr, LOCAL_IF))\n-                    LogPrintf(\"IPv6 %s: %s\\n\", ifa->ifa_name, addr.ToString().c_str());\n+                    Log() << \"IPv6 \" << ifa->ifa_name << \": \" << addr.ToString() << \"\\n\";\n             }\n #endif\n         }\n@@ -1764,7 +1772,7 @@ void StartNode(boost::thread_group& threadGroup)\n     //\n \n     if (!GetBoolArg(\"-dnsseed\", true))\n-        LogPrintf(\"DNS seeding disabled\\n\");\n+        Log() << \"DNS seeding disabled\\n\";\n     else\n         threadGroup.create_thread(boost::bind(&TraceThread<void (*)()>, \"dnsseed\", &ThreadDNSAddressSeed));\n \n@@ -1791,7 +1799,7 @@ void StartNode(boost::thread_group& threadGroup)\n \n bool StopNode()\n {\n-    LogPrintf(\"StopNode()\\n\");\n+    Log() << \"StopNode()\\n\";\n     MapPort(false);\n     if (semOutbound)\n         for (int i=0; i<MAX_OUTBOUND_CONNECTIONS; i++)\n@@ -1817,7 +1825,7 @@ class CNetCleanup\n         BOOST_FOREACH(SOCKET hListenSocket, vhListenSocket)\n             if (hListenSocket != INVALID_SOCKET)\n                 if (closesocket(hListenSocket) == SOCKET_ERROR)\n-                    LogPrintf(\"closesocket(hListenSocket) failed with error %d\\n\", WSAGetLastError());\n+                    Log() << \"closesocket(hListenSocket) failed with error \" << WSAGetLastError() << \"\\n\";\n \n         // clean up some globals (to help leak detection)\n         BOOST_FOREACH(CNode *pnode, vNodes)\n@@ -1859,15 +1867,15 @@ void RelayTransaction(const CTransaction& tx, const uint256& hash, const CDataSt\n     {\n         LOCK(cs_mapRelay);\n         // Expire old relay messages\n-        while (!vRelayExpiration.empty() && vRelayExpiration.front().first < GetTime())\n+        while (!vRelayExpiration.empty() && vRelayExpiration.front().first < BitcoinTime::GetTime())\n         {\n             mapRelay.erase(vRelayExpiration.front().second);\n             vRelayExpiration.pop_front();\n         }\n \n         // Save original serialized message so newer versions are preserved\n         mapRelay.insert(std::make_pair(inv, ss));\n-        vRelayExpiration.push_back(std::make_pair(GetTime() + 15 * 60, inv));\n+        vRelayExpiration.push_back(std::make_pair(BitcoinTime::GetTime() + 15 * 60, inv));\n     }\n     LOCK(cs_vNodes);\n     BOOST_FOREACH(CNode* pnode, vNodes)"
      },
      {
        "sha": "630d7a909fe5c7dfa928115a45250bb0b80aa836",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 10,
        "deletions": 9,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -6,10 +6,12 @@\n #ifndef BITCOIN_NET_H\n #define BITCOIN_NET_H\n \n+#include \"bitcointime.h\"\n #include \"bloom.h\"\n #include \"compat.h\"\n #include \"hash.h\"\n #include \"limitedmap.h\"\n+#include \"log.h\"\n #include \"mruset.h\"\n #include \"netbase.h\"\n #include \"protocol.h\"\n@@ -18,7 +20,6 @@\n #include \"util.h\"\n \n #include <deque>\n-#include <inttypes.h>\n #include <stdint.h>\n \n #ifndef WIN32\n@@ -268,8 +269,8 @@ class CNode\n         nLastRecv = 0;\n         nSendBytes = 0;\n         nRecvBytes = 0;\n-        nLastSendEmpty = GetTime();\n-        nTimeConnected = GetTime();\n+        nLastSendEmpty = BitcoinTime::GetTime();\n+        nTimeConnected = BitcoinTime::GetTime();\n         addr = addrIn;\n         addrName = addrNameIn == \"\" ? addr.ToStringIPPort() : addrNameIn;\n         nVersion = 0;\n@@ -408,10 +409,10 @@ class CNode\n             nRequestTime = it->second;\n         else\n             nRequestTime = 0;\n-        LogPrint(\"net\", \"askfor %s   %\"PRId64\" (%s)\\n\", inv.ToString().c_str(), nRequestTime, DateTimeStrFormat(\"%H:%M:%S\", nRequestTime/1000000).c_str());\n+        Log(\"net\") << \"askfor \" << inv.ToString() << \"   \" << nRequestTime << \" (\" << BitcoinTime::DateTimeStrFormat(\"%H:%M:%S\", nRequestTime/1000000) << \")\\n\";\n \n         // Make sure not to reuse time indexes to keep things in the same order\n-        int64_t nNow = (GetTime() - 1) * 1000000;\n+        int64_t nNow = (BitcoinTime::GetTime() - 1) * 1000000;\n         static int64_t nLastTime;\n         ++nLastTime;\n         nNow = std::max(nNow, nLastTime);\n@@ -434,7 +435,7 @@ class CNode\n         ENTER_CRITICAL_SECTION(cs_vSend);\n         assert(ssSend.size() == 0);\n         ssSend << CMessageHeader(pszCommand, 0);\n-        LogPrint(\"net\", \"sending: %s \", pszCommand);\n+        Log(\"net\") << \"sending: \" << pszCommand << \" \";\n     }\n \n     // TODO: Document the precondition of this function.  Is cs_vSend locked?\n@@ -444,7 +445,7 @@ class CNode\n \n         LEAVE_CRITICAL_SECTION(cs_vSend);\n \n-        LogPrint(\"net\", \"(aborted)\\n\");\n+        Log(\"net\") << \"(aborted)\\n\";\n     }\n \n     // TODO: Document the precondition of this function.  Is cs_vSend locked?\n@@ -455,7 +456,7 @@ class CNode\n         // not intended for end-users.\n         if (mapArgs.count(\"-dropmessagestest\") && GetRand(GetArg(\"-dropmessagestest\", 2)) == 0)\n         {\n-            LogPrint(\"net\", \"dropmessages DROPPING SEND MESSAGE\\n\");\n+            Log(\"net\") << \"dropmessages DROPPING SEND MESSAGE\\n\";\n             AbortMessage();\n             return;\n         }\n@@ -476,7 +477,7 @@ class CNode\n         assert(ssSend.size () >= CMessageHeader::CHECKSUM_OFFSET + sizeof(nChecksum));\n         memcpy((char*)&ssSend[CMessageHeader::CHECKSUM_OFFSET], &nChecksum, sizeof(nChecksum));\n \n-        LogPrint(\"net\", \"(%d bytes)\\n\", nSize);\n+        Log(\"net\") << \"(\" << nSize << \" bytes)\\n\";\n \n         std::deque<CSerializeData>::iterator it = vSendMsg.insert(vSendMsg.end(), CSerializeData());\n         ssSend.GetAndClear(*it);"
      },
      {
        "sha": "d88f0df817e89f4dbdd4d26abeb3e8ab3af08160",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 78,
        "deletions": 45,
        "changes": 123,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -6,16 +6,22 @@\n #include \"netbase.h\"\n \n #include \"hash.h\"\n+#include \"log.h\"\n #include \"sync.h\"\n #include \"uint256.h\"\n #include \"util.h\"\n \n+#include <ios>\n+#include <sstream>\n+#include <stdint.h>\n+\n #ifndef WIN32\n #include <fcntl.h>\n #endif\n \n #include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n #include <boost/algorithm/string/predicate.hpp> // for startswith() and endswith()\n+#include <boost/format.hpp>\n \n #if !defined(HAVE_MSG_NOSIGNAL) && !defined(MSG_NOSIGNAL)\n #define MSG_NOSIGNAL 0\n@@ -171,19 +177,21 @@ bool LookupNumeric(const char *pszName, CService& addr, int portDefault)\n \n bool static Socks4(const CService &addrDest, SOCKET& hSocket)\n {\n-    LogPrintf(\"SOCKS4 connecting %s\\n\", addrDest.ToString().c_str());\n+    Log() << \"SOCKS4 connecting \" << addrDest.ToString() << \"\\n\";\n     if (!addrDest.IsIPv4())\n     {\n         closesocket(hSocket);\n-        return error(\"Proxy destination is not IPv4\");\n+        Log() << \"ERROR: Proxy destination is not IPv4\\n\";\n+        return false;\n     }\n     char pszSocks4IP[] = \"\\4\\1\\0\\0\\0\\0\\0\\0user\";\n     struct sockaddr_in addr;\n     socklen_t len = sizeof(addr);\n     if (!addrDest.GetSockAddr((struct sockaddr*)&addr, &len) || addr.sin_family != AF_INET)\n     {\n         closesocket(hSocket);\n-        return error(\"Cannot get proxy destination address\");\n+        Log() << \"ERROR: Cannot get proxy destination address\\n\";\n+        return false;\n     }\n     memcpy(pszSocks4IP + 2, &addr.sin_port, 2);\n     memcpy(pszSocks4IP + 4, &addr.sin_addr, 4);\n@@ -194,32 +202,35 @@ bool static Socks4(const CService &addrDest, SOCKET& hSocket)\n     if (ret != nSize)\n     {\n         closesocket(hSocket);\n-        return error(\"Error sending to proxy\");\n+        Log() << \"ERROR: Error sending to proxy\\n\";\n+        return false;\n     }\n     char pchRet[8];\n     if (recv(hSocket, pchRet, 8, 0) != 8)\n     {\n         closesocket(hSocket);\n-        return error(\"Error reading proxy response\");\n+        Log() << \"ERROR: Error reading proxy response\\n\";\n+        return false;\n     }\n     if (pchRet[1] != 0x5a)\n     {\n         closesocket(hSocket);\n         if (pchRet[1] != 0x5b)\n-            LogPrintf(\"ERROR: Proxy returned error %d\\n\", pchRet[1]);\n+            Log() << \"ERROR: Proxy returned error \" << pchRet[1] << \"\\n\";\n         return false;\n     }\n-    LogPrintf(\"SOCKS4 connected %s\\n\", addrDest.ToString().c_str());\n+    Log() << \"SOCKS4 connected \" << addrDest.ToString() << \"\\n\";\n     return true;\n }\n \n bool static Socks5(string strDest, int port, SOCKET& hSocket)\n {\n-    LogPrintf(\"SOCKS5 connecting %s\\n\", strDest.c_str());\n+    Log() << \"SOCKS5 connecting \" << strDest << \"\\n\";\n     if (strDest.size() > 255)\n     {\n         closesocket(hSocket);\n-        return error(\"Hostname too long\");\n+        Log() << \"ERROR: Hostname too long\\n\";\n+        return false;\n     }\n     char pszSocks5Init[] = \"\\5\\1\\0\";\n     ssize_t nSize = sizeof(pszSocks5Init) - 1;\n@@ -228,18 +239,21 @@ bool static Socks5(string strDest, int port, SOCKET& hSocket)\n     if (ret != nSize)\n     {\n         closesocket(hSocket);\n-        return error(\"Error sending to proxy\");\n+        Log() << \"ERROR: Error sending to proxy\\n\";\n+        return false;\n     }\n     char pchRet1[2];\n     if (recv(hSocket, pchRet1, 2, 0) != 2)\n     {\n         closesocket(hSocket);\n-        return error(\"Error reading proxy response\");\n+        Log() << \"ERROR: Error reading proxy response\\n\";\n+        return false;\n     }\n     if (pchRet1[0] != 0x05 || pchRet1[1] != 0x00)\n     {\n         closesocket(hSocket);\n-        return error(\"Proxy failed to initialize\");\n+        Log() << \"ERROR: Proxy failed to initialize\\n\";\n+        return false;\n     }\n     string strSocks5(\"\\5\\1\");\n     strSocks5 += '\\000'; strSocks5 += '\\003';\n@@ -251,39 +265,44 @@ bool static Socks5(string strDest, int port, SOCKET& hSocket)\n     if (ret != (ssize_t)strSocks5.size())\n     {\n         closesocket(hSocket);\n-        return error(\"Error sending to proxy\");\n+        Log() << \"ERROR: Error sending to proxy\\n\";\n+        return false;\n     }\n     char pchRet2[4];\n     if (recv(hSocket, pchRet2, 4, 0) != 4)\n     {\n         closesocket(hSocket);\n-        return error(\"Error reading proxy response\");\n+        Log() << \"ERROR: Error reading proxy response\\n\";\n+        return false;\n     }\n     if (pchRet2[0] != 0x05)\n     {\n         closesocket(hSocket);\n-        return error(\"Proxy failed to accept request\");\n+        Log() << \"ERROR: Proxy failed to accept request\\n\";\n+        return false;\n     }\n     if (pchRet2[1] != 0x00)\n     {\n         closesocket(hSocket);\n         switch (pchRet2[1])\n         {\n-            case 0x01: return error(\"Proxy error: general failure\");\n-            case 0x02: return error(\"Proxy error: connection not allowed\");\n-            case 0x03: return error(\"Proxy error: network unreachable\");\n-            case 0x04: return error(\"Proxy error: host unreachable\");\n-            case 0x05: return error(\"Proxy error: connection refused\");\n-            case 0x06: return error(\"Proxy error: TTL expired\");\n-            case 0x07: return error(\"Proxy error: protocol error\");\n-            case 0x08: return error(\"Proxy error: address type not supported\");\n-            default:   return error(\"Proxy error: unknown\");\n+            case 0x01: Log() << \"ERROR: Proxy error: general failure\\n\";\n+            case 0x02: Log() << \"ERROR: Proxy error: connection not allowed\\n\";\n+            case 0x03: Log() << \"ERROR: Proxy error: network unreachable\\n\";\n+            case 0x04: Log() << \"ERROR: Proxy error: host unreachable\\n\";\n+            case 0x05: Log() << \"ERROR: Proxy error: connection refused\\n\";\n+            case 0x06: Log() << \"ERROR: Proxy error: TTL expired\\n\";\n+            case 0x07: Log() << \"ERROR: Proxy error: protocol error\\n\";\n+            case 0x08: Log() << \"ERROR: Proxy error: address type not supported\\n\";\n+            default:   Log() << \"ERROR: Proxy error: unknown\\n\";\n         }\n+        return false;\n     }\n     if (pchRet2[2] != 0x00)\n     {\n         closesocket(hSocket);\n-        return error(\"Error: malformed proxy response\");\n+        Log() << \"ERROR: Error: malformed proxy response\\n\";\n+        return false;\n     }\n     char pchRet3[256];\n     switch (pchRet2[3])\n@@ -294,24 +313,34 @@ bool static Socks5(string strDest, int port, SOCKET& hSocket)\n         {\n             ret = recv(hSocket, pchRet3, 1, 0) != 1;\n             if (ret)\n-                return error(\"Error reading from proxy\");\n+            {\n+                Log() << \"ERROR: Error reading from proxy\\n\";\n+                return false;\n+            }\n             int nRecv = pchRet3[0];\n             ret = recv(hSocket, pchRet3, nRecv, 0) != nRecv;\n             break;\n         }\n-        default: closesocket(hSocket); return error(\"Error: malformed proxy response\");\n+        default:\n+        {\n+            closesocket(hSocket); \n+            Log() << \"ERROR: Error: malformed proxy response\\n\";\n+            return false;\n+        }\n     }\n     if (ret)\n     {\n         closesocket(hSocket);\n-        return error(\"Error reading from proxy\");\n+        Log() << \"ERROR: Error reading from proxy\\n\";\n+        return false;\n     }\n     if (recv(hSocket, pchRet3, 2, 0) != 2)\n     {\n         closesocket(hSocket);\n-        return error(\"Error reading from proxy\");\n+        Log() << \"ERROR: Error reading from proxy\\n\";\n+        return false;\n     }\n-    LogPrintf(\"SOCKS5 connected %s\\n\", strDest.c_str());\n+    Log() << \"SOCKS5 connected \" << strDest << \"\\n\";\n     return true;\n }\n \n@@ -326,7 +355,7 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n #endif\n     socklen_t len = sizeof(sockaddr);\n     if (!addrConnect.GetSockAddr((struct sockaddr*)&sockaddr, &len)) {\n-        LogPrintf(\"Cannot connect to %s: unsupported network\\n\", addrConnect.ToString().c_str());\n+        Log() << \"Cannot connect to \" << addrConnect.ToString() << \": unsupported network\\n\";\n         return false;\n     }\n \n@@ -365,13 +394,13 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n             int nRet = select(hSocket + 1, NULL, &fdset, NULL, &timeout);\n             if (nRet == 0)\n             {\n-                LogPrint(\"net\", \"connection to %s timeout\\n\", addrConnect.ToString().c_str());\n+                Log(\"net\") << \"connection to \" << addrConnect.ToString() << \" timeout\\n\";\n                 closesocket(hSocket);\n                 return false;\n             }\n             if (nRet == SOCKET_ERROR)\n             {\n-                LogPrintf(\"select() for %s failed: %i\\n\", addrConnect.ToString().c_str(), WSAGetLastError());\n+                Log() << \"select() for \" << addrConnect.ToString() << \" failed: \" << WSAGetLastError() << \"\\n\";\n                 closesocket(hSocket);\n                 return false;\n             }\n@@ -382,13 +411,13 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n             if (getsockopt(hSocket, SOL_SOCKET, SO_ERROR, &nRet, &nRetSize) == SOCKET_ERROR)\n #endif\n             {\n-                LogPrintf(\"getsockopt() for %s failed: %i\\n\", addrConnect.ToString().c_str(), WSAGetLastError());\n+                Log() << \"getsockopt() for \" << addrConnect.ToString() << \" failed: \" << WSAGetLastError() << \"\\n\";\n                 closesocket(hSocket);\n                 return false;\n             }\n             if (nRet != 0)\n             {\n-                LogPrintf(\"connect() to %s failed after select(): %s\\n\", addrConnect.ToString().c_str(), strerror(nRet));\n+                Log() << \"connect() to \" << addrConnect.ToString() << \" failed after select(): \" << strerror(nRet) << \"\\n\";\n                 closesocket(hSocket);\n                 return false;\n             }\n@@ -399,7 +428,7 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n         else\n #endif\n         {\n-            LogPrintf(\"connect() to %s failed: %i\\n\", addrConnect.ToString().c_str(), WSAGetLastError());\n+            Log() << \"connect() to \" << addrConnect.ToString() << \" failed: \" << WSAGetLastError() << \"\\n\";\n             closesocket(hSocket);\n             return false;\n         }\n@@ -770,14 +799,18 @@ std::string CNetAddr::ToStringIP() const\n         if (!getnameinfo((const struct sockaddr*)&sockaddr, socklen, name, sizeof(name), NULL, 0, NI_NUMERICHOST))\n             return std::string(name);\n     }\n+\n+    ostringstream ossIP;\n     if (IsIPv4())\n-        return strprintf(\"%u.%u.%u.%u\", GetByte(3), GetByte(2), GetByte(1), GetByte(0));\n+        ossIP << GetByte(3) << \".\" << GetByte(2) << \".\" << GetByte(1) << \".\" << GetByte(0);\n     else\n-        return strprintf(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n-                         GetByte(15) << 8 | GetByte(14), GetByte(13) << 8 | GetByte(12),\n-                         GetByte(11) << 8 | GetByte(10), GetByte(9) << 8 | GetByte(8),\n-                         GetByte(7) << 8 | GetByte(6), GetByte(5) << 8 | GetByte(4),\n-                         GetByte(3) << 8 | GetByte(2), GetByte(1) << 8 | GetByte(0));\n+        ossIP << hex \n+              << (GetByte(15) << 8 | GetByte(14)) << \":\" << (GetByte(13) << 8 | GetByte(12)) << \":\" \n+              << (GetByte(11) << 8 | GetByte(10)) << \":\" << (GetByte(9) << 8 | GetByte(8)) << \":\" \n+              << (GetByte(7) << 8 | GetByte(6)) << \":\" << (GetByte(5) << 8 | GetByte(4)) << \":\" \n+              << (GetByte(3) << 8 | GetByte(2)) << \":\" << (GetByte(1) << 8 | GetByte(0)) << dec;\n+\n+    return ossIP.str();\n }\n \n std::string CNetAddr::ToString() const\n@@ -895,7 +928,7 @@ uint64_t CNetAddr::GetHash() const\n \n void CNetAddr::print() const\n {\n-    LogPrintf(\"CNetAddr(%s)\\n\", ToString().c_str());\n+    Log() << \"CNetAddr(\" << ToString() << \")\\n\";\n }\n \n // private extensions to enum Network, only returned by GetExtNetwork,\n@@ -1117,7 +1150,7 @@ std::vector<unsigned char> CService::GetKey() const\n \n std::string CService::ToStringPort() const\n {\n-    return strprintf(\"%u\", port);\n+    return boost::str(boost::format(\"%u\") % port);\n }\n \n std::string CService::ToStringIPPort() const\n@@ -1136,7 +1169,7 @@ std::string CService::ToString() const\n \n void CService::print() const\n {\n-    LogPrintf(\"CService(%s)\\n\", ToString().c_str());\n+    Log() << \"CService(\" << ToString() << \")\\n\";\n }\n \n void CService::SetPort(unsigned short portIn)"
      },
      {
        "sha": "8b83bbf29f765e7be14c9680d077f455589ed533",
        "filename": "src/noui.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 8,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/noui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/noui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/noui.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -5,32 +5,35 @@\n \n #include \"noui.h\"\n \n+#include \"log.h\"\n #include \"ui_interface.h\"\n #include \"util.h\"\n \n+#include <iostream>\n+#include <sstream>\n #include <stdint.h>\n #include <string>\n \n static bool noui_ThreadSafeMessageBox(const std::string& message, const std::string& caption, unsigned int style)\n {\n-    std::string strCaption;\n+    std::ostringstream ossCaption;\n     // Check for usage of predefined caption\n     switch (style) {\n     case CClientUIInterface::MSG_ERROR:\n-        strCaption += _(\"Error\");\n+        ossCaption << _<std::string>(\"Error\");\n         break;\n     case CClientUIInterface::MSG_WARNING:\n-        strCaption += _(\"Warning\");\n+        ossCaption << _<std::string>(\"Warning\");\n         break;\n     case CClientUIInterface::MSG_INFORMATION:\n-        strCaption += _(\"Information\");\n+        ossCaption << _<std::string>(\"Information\");\n         break;\n     default:\n-        strCaption += caption; // Use supplied caption (can be empty)\n+        ossCaption << caption; // Use supplied caption (can be empty)\n     }\n \n-    LogPrintf(\"%s: %s\\n\", strCaption.c_str(), message.c_str());\n-    fprintf(stderr, \"%s: %s\\n\", strCaption.c_str(), message.c_str());\n+    Log() << ossCaption << \": \" << message << \"\\n\";\n+    std::cerr << ossCaption << \": \" << message << \"\\n\";\n     return false;\n }\n \n@@ -41,7 +44,7 @@ static bool noui_ThreadSafeAskFee(int64_t /*nFeeRequired*/)\n \n static void noui_InitMessage(const std::string &message)\n {\n-    LogPrintf(\"init message: %s\\n\", message.c_str());\n+    Log() << \"init message: \" << message << \"\\n\";\n }\n \n void noui_connect()"
      },
      {
        "sha": "d672d857082244b3b76ecad57792716063b7aee8",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 5,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -5,8 +5,11 @@\n \n #include \"protocol.h\"\n \n+#include \"log.h\"\n #include \"util.h\"\n \n+#include <stdint.h>\n+\n #ifndef WIN32\n # include <arpa/inet.h>\n #endif\n@@ -67,7 +70,7 @@ bool CMessageHeader::IsValid() const\n     // Message size\n     if (nMessageSize > MAX_SIZE)\n     {\n-        LogPrintf(\"CMessageHeader::IsValid() : (%s, %u bytes) nMessageSize > MAX_SIZE\\n\", GetCommand().c_str(), nMessageSize);\n+        Log() << \"CMessageHeader::IsValid() : (\" << GetCommand() << \", \" << nMessageSize << \" bytes) nMessageSize > MAX_SIZE\\n\";\n         return false;\n     }\n \n@@ -118,7 +121,9 @@ CInv::CInv(const std::string& strType, const uint256& hashIn)\n         }\n     }\n     if (i == ARRAYLEN(ppszTypeName))\n-        throw std::out_of_range(strprintf(\"CInv::CInv(string, uint256) : unknown type '%s'\", strType.c_str()));\n+    {\n+        throw std::out_of_range(boost::str(boost::format(\"CInv::CInv(string, uint256) : unknown type '%s'\") % strType));\n+    }\n     hash = hashIn;\n }\n \n@@ -135,17 +140,19 @@ bool CInv::IsKnownType() const\n const char* CInv::GetCommand() const\n {\n     if (!IsKnownType())\n-        throw std::out_of_range(strprintf(\"CInv::GetCommand() : type=%d unknown type\", type));\n+    {\n+        throw std::out_of_range(boost::str(boost::format(\"CInv::GetCommand() : type=%d unknown type\") % type));\n+    }\n     return ppszTypeName[type];\n }\n \n std::string CInv::ToString() const\n {\n-    return strprintf(\"%s %s\", GetCommand(), hash.ToString().c_str());\n+    return boost::str(boost::format(\"%s %s\") % GetCommand() % hash.ToString());\n }\n \n void CInv::print() const\n {\n-    LogPrintf(\"CInv(%s)\\n\", ToString().c_str());\n+    Log() << \"CInv(\" << ToString() << \")\\n\";\n }\n "
      },
      {
        "sha": "36e5dcf3ee3c096b4284bb7bc44c9ae797798569",
        "filename": "src/qt/bitcoin.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 5,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/qt/bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/qt/bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoin.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -14,10 +14,12 @@\n #include \"walletmodel.h\"\n \n #include \"init.h\"\n+#include \"log.h\"\n #include \"main.h\"\n #include \"ui_interface.h\"\n #include \"util.h\"\n \n+#include <iostream>\n #include <stdint.h>\n \n #include <boost/filesystem/operations.hpp>\n@@ -69,8 +71,8 @@ static bool ThreadSafeMessageBox(const std::string& message, const std::string&\n     }\n     else\n     {\n-        LogPrintf(\"%s: %s\\n\", caption.c_str(), message.c_str());\n-        fprintf(stderr, \"%s: %s\\n\", caption.c_str(), message.c_str());\n+        Log() << caption << \": \" << message << \"\\n\";\n+        std::cerr << caption << \": \" << message << \"\\n\";\n         return false;\n     }\n }\n@@ -98,7 +100,7 @@ static void InitMessage(const std::string &message)\n         splashref->showMessage(QString::fromStdString(message), Qt::AlignBottom|Qt::AlignHCenter, QColor(55,55,55));\n         qApp->processEvents();\n     }\n-    LogPrintf(\"init message: %s\\n\", message.c_str());\n+    Log() << \"init message: \" << message << \"\\n\";\n }\n \n /*\n@@ -163,14 +165,14 @@ static void initTranslations(QTranslator &qtTranslatorBase, QTranslator &qtTrans\n void DebugMessageHandler(QtMsgType type, const char * msg)\n {\n     Q_UNUSED(type);\n-    LogPrint(\"qt\", \"Bitcoin-Qt: %s\\n\", msg);\n+    Log(\"qt\") << \"Bitcoin-Qt: \" << msg << \"\\n\";\n }\n #else\n void DebugMessageHandler(QtMsgType type, const QMessageLogContext& context, const QString &msg)\n {\n     Q_UNUSED(type);\n     Q_UNUSED(context);\n-    LogPrint(\"qt\", \"Bitcoin-Qt: %s\\n\", qPrintable(msg));\n+    Log(\"qt\") << \"Bitcoin-Qt: \" << qPrintable(msg) << \"\\n\";\n }\n #endif\n "
      },
      {
        "sha": "41153146958ed6dc99edb1931ba87653266a2642",
        "filename": "src/qt/bitcoinunits.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/qt/bitcoinunits.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/qt/bitcoinunits.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoinunits.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -102,7 +102,7 @@ int BitcoinUnits::decimals(int unit)\n \n QString BitcoinUnits::format(int unit, qint64 n, bool fPlus)\n {\n-    // Note: not using straight sprintf here because we do NOT want\n+    // Note: not using straight float formatting here because we do NOT want\n     // localized number formatting.\n     if(!valid(unit))\n         return QString(); // Refuse to format invalid unit"
      },
      {
        "sha": "f9dbc85249eb19bc28c1b0dfaf8a3a14b364367c",
        "filename": "src/qt/clientmodel.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/qt/clientmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/qt/clientmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -7,6 +7,7 @@\n #include \"guiconstants.h\"\n \n #include \"alert.h\"\n+#include \"bitcointime.h\"\n #include \"chainparams.h\"\n #include \"checkpoints.h\"\n #include \"main.h\"\n@@ -19,7 +20,7 @@\n #include <QDebug>\n #include <QTimer>\n \n-static const int64_t nClientStartupTime = GetTime();\n+static const int64_t nClientStartupTime = BitcoinTime::GetTime();\n \n ClientModel::ClientModel(OptionsModel *optionsModel, QObject *parent) :\n     QObject(parent), optionsModel(optionsModel),"
      },
      {
        "sha": "a4f79e3a38726aa99aded3e6bacd2fb967b04130",
        "filename": "src/qt/guiutil.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/qt/guiutil.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/qt/guiutil.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiutil.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -12,6 +12,8 @@\n #include \"init.h\"\n #include \"util.h\"\n \n+#include <iostream>\n+\n #ifdef WIN32\n #ifdef _WIN32_WINNT\n #undef _WIN32_WINNT\n@@ -617,7 +619,7 @@ void HelpMessageBox::printToConsole()\n {\n     // On other operating systems, the expected action is to print the message to the console.\n     QString strUsage = header + \"\\n\" + coreOptions + \"\\n\" + uiOptions;\n-    fprintf(stdout, \"%s\", strUsage.toStdString().c_str());\n+    std::cout << strUsage.toStdString();\n }\n \n void HelpMessageBox::showOrPrint()"
      },
      {
        "sha": "ab6581cc6f6364de128ba4f071fbc6ebfc877c08",
        "filename": "src/qt/sendcoinsdialog.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/qt/sendcoinsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/qt/sendcoinsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsdialog.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -14,6 +14,7 @@\n #include \"walletmodel.h\"\n \n #include \"base58.h\"\n+#include \"bitcointime.h\"\n #include \"coincontrol.h\"\n #include \"ui_interface.h\"\n \n@@ -380,7 +381,7 @@ bool SendCoinsDialog::handlePaymentRequest(const SendCoinsRecipient &rv)\n     if (rv.paymentRequest.IsInitialized()) {\n         // Expired payment request?\n         const payments::PaymentDetails& details = rv.paymentRequest.getDetails();\n-        if (details.has_expires() && (int64_t)details.expires() < GetTime())\n+        if (details.has_expires() && (int64_t)details.expires() < BitcoinTime::GetTime())\n         {\n             emit message(strSendCoins, tr(\"Payment request expired\"),\n                 CClientUIInterface::MSG_WARNING);"
      },
      {
        "sha": "16fac0eba4095a762a85524df50fd6a751a9d76a",
        "filename": "src/qt/transactiondesc.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/qt/transactiondesc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/qt/transactiondesc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiondesc.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -8,7 +8,9 @@\n #include \"guiutil.h\"\n \n #include \"base58.h\"\n+#include \"bitcointime.h\"\n #include \"db.h\"\n+#include \"log.h\"\n #include \"main.h\"\n #include \"paymentserver.h\"\n #include \"transactionrecord.h\"\n@@ -30,7 +32,7 @@ QString TransactionDesc::FormatTxStatus(const CWalletTx& wtx)\n     else\n     {\n         int nDepth = wtx.GetDepthInMainChain();\n-        if (GetAdjustedTime() - wtx.nTimeReceived > 2 * 60 && wtx.GetRequestCount() == 0)\n+        if (BitcoinTime::GetAdjustedTime() - wtx.nTimeReceived > 2 * 60 && wtx.GetRequestCount() == 0)\n             return tr(\"%1/offline\").arg(nDepth);\n         else if (nDepth < 6)\n             return tr(\"%1/unconfirmed\").arg(nDepth);\n@@ -248,7 +250,7 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, int vout, int u\n         //\n         // Debug view\n         //\n-        if (fDebug)\n+        if (Log::fDebug)\n         {\n             strHTML += \"<hr><br>\" + tr(\"Debug information\") + \"<br><br>\";\n             BOOST_FOREACH(const CTxIn& txin, wtx.vin)"
      },
      {
        "sha": "6add3dc90921d057599609652d3e4a25060da8d2",
        "filename": "src/qt/transactionrecord.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 7,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/qt/transactionrecord.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/qt/transactionrecord.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionrecord.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -5,10 +5,13 @@\n #include \"transactionrecord.h\"\n \n #include \"base58.h\"\n+#include \"bitcointime.h\"\n #include \"wallet.h\"\n \n #include <stdint.h>\n \n+#include <boost/format.hpp>\n+\n /* Return positive answer if transaction should be shown in list.\n  */\n bool TransactionRecord::showTransaction(const CWalletTx &wtx)\n@@ -159,11 +162,12 @@ void TransactionRecord::updateStatus(const CWalletTx &wtx)\n         pindex = (*mi).second;\n \n     // Sort order, unrecorded transactions sort to the top\n-    status.sortKey = strprintf(\"%010d-%01d-%010u-%03d\",\n-        (pindex ? pindex->nHeight : std::numeric_limits<int>::max()),\n-        (wtx.IsCoinBase() ? 1 : 0),\n-        wtx.nTimeReceived,\n+    status.sortKey = boost::str(boost::format(\"%010d-%01d-%010u-%03d\") %\n+        (pindex ? pindex->nHeight : std::numeric_limits<int>::max()) %\n+        (wtx.IsCoinBase() ? 1 : 0) %\n+        wtx.nTimeReceived %\n         idx);\n+\n     status.confirmed = wtx.IsConfirmed();\n     status.depth = wtx.GetDepthInMainChain();\n     status.cur_num_blocks = chainActive.Height();\n@@ -183,7 +187,7 @@ void TransactionRecord::updateStatus(const CWalletTx &wtx)\n     }\n     else\n     {\n-        if (GetAdjustedTime() - wtx.nTimeReceived > 2 * 60 && wtx.GetRequestCount() == 0)\n+        if (BitcoinTime::GetAdjustedTime() - wtx.nTimeReceived > 2 * 60 && wtx.GetRequestCount() == 0)\n         {\n             status.status = TransactionStatus::Offline;\n         }\n@@ -210,7 +214,7 @@ void TransactionRecord::updateStatus(const CWalletTx &wtx)\n                 status.matures_in = wtx.GetBlocksToMaturity();\n \n                 // Check if the block was requested by anyone\n-                if (GetAdjustedTime() - wtx.nTimeReceived > 2 * 60 && wtx.GetRequestCount() == 0)\n+                if (BitcoinTime::GetAdjustedTime() - wtx.nTimeReceived > 2 * 60 && wtx.GetRequestCount() == 0)\n                     status.maturity = TransactionStatus::MaturesWarning;\n             }\n             else\n@@ -237,6 +241,6 @@ QString TransactionRecord::getTxID() const\n \n QString TransactionRecord::formatSubTxId(const uint256 &hash, int vout)\n {\n-    return QString::fromStdString(hash.ToString() + strprintf(\"-%03d\", vout));\n+    return QString::fromStdString(boost::str(boost::format(\"%s-%03d\") % hash.ToString() % vout));\n }\n "
      },
      {
        "sha": "96855a9ec19f771138e78517a5f99accdf2fc149",
        "filename": "src/rpcclient.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 22,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/rpcclient.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/rpcclient.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcclient.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -10,6 +10,7 @@\n #include \"ui_interface.h\"\n #include \"chainparams.h\" // for Params().RPCPort()\n \n+#include <sstream>\n #include <stdint.h>\n \n #include <boost/algorithm/string.hpp>\n@@ -18,6 +19,7 @@\n #include <boost/bind.hpp>\n #include <boost/filesystem.hpp>\n #include <boost/foreach.hpp>\n+#include <boost/format.hpp>\n #include <boost/iostreams/concepts.hpp>\n #include <boost/iostreams/stream.hpp>\n #include <boost/lexical_cast.hpp>\n@@ -32,10 +34,11 @@ using namespace json_spirit;\n Object CallRPC(const string& strMethod, const Array& params)\n {\n     if (mapArgs[\"-rpcuser\"] == \"\" && mapArgs[\"-rpcpassword\"] == \"\")\n-        throw runtime_error(strprintf(\n+    {\n+        throw runtime_error(str(\n             _(\"You must set rpcpassword=<password> in the configuration file:\\n%s\\n\"\n-              \"If the file does not exist, create it with owner-readable-only file permissions.\"),\n-                GetConfigFile().string().c_str()));\n+              \"If the file does not exist, create it with owner-readable-only file permissions.\") % GetConfigFile().string()));\n+    }\n \n     // Connect to localhost\n     bool fUseSSL = GetBoolArg(\"-rpcssl\", false);\n@@ -48,7 +51,7 @@ Object CallRPC(const string& strMethod, const Array& params)\n \n     bool fWait = GetBoolArg(\"-rpcwait\", false); // -rpcwait means try until server has started\n     do {\n-        bool fConnected = d.connect(GetArg(\"-rpcconnect\", \"127.0.0.1\"), GetArg(\"-rpcport\", itostr(Params().RPCPort())));\n+        bool fConnected = d.connect(GetArg(\"-rpcconnect\", \"127.0.0.1\"), GetArg(\"-rpcport\", tostr(Params().RPCPort())));\n         if (fConnected) break;\n         if (fWait)\n             MilliSleep(1000);\n@@ -78,7 +81,7 @@ Object CallRPC(const string& strMethod, const Array& params)\n     if (nStatus == HTTP_UNAUTHORIZED)\n         throw runtime_error(\"incorrect rpcuser or rpcpassword (authorization failed)\");\n     else if (nStatus >= 400 && nStatus != HTTP_BAD_REQUEST && nStatus != HTTP_NOT_FOUND && nStatus != HTTP_INTERNAL_SERVER_ERROR)\n-        throw runtime_error(strprintf(\"server returned HTTP error %d\", nStatus));\n+        throw runtime_error(str(boost::format(\"server returned HTTP error %d\") % nStatus));\n     else if (strReply.empty())\n         throw runtime_error(\"no response from server\");\n \n@@ -248,32 +251,33 @@ int CommandLineRPC(int argc, char *argv[])\n \n std::string HelpMessageCli(bool mainProgram)\n {\n-    string strUsage;\n+    ostringstream ossUsage;\n     if(mainProgram)\n     {\n-        strUsage += _(\"Options:\") + \"\\n\";\n-        strUsage += \"  -?                     \" + _(\"This help message\") + \"\\n\";\n-        strUsage += \"  -conf=<file>           \" + _(\"Specify configuration file (default: bitcoin.conf)\") + \"\\n\";\n-        strUsage += \"  -datadir=<dir>         \" + _(\"Specify data directory\") + \"\\n\";\n-        strUsage += \"  -testnet               \" + _(\"Use the test network\") + \"\\n\";\n-        strUsage += \"  -regtest               \" + _(\"Enter regression test mode, which uses a special chain in which blocks can be \"\n-                                            \"solved instantly. This is intended for regression testing tools and app development.\") + \"\\n\";\n+        ossUsage << _(\"Options:\").str() << \"\\n\"\n+                 << \"  -?                     \" << _(\"This help message\").str() + \"\\n\"\n+                 << \"  -conf=<file>           \" << _(\"Specify configuration file (default: bitcoin.conf)\").str() + \"\\n\"\n+                 << \"  -datadir=<dir>         \" << _(\"Specify data directory\").str() + \"\\n\"\n+                 << \"  -testnet               \" << _(\"Use the test network\").str() + \"\\n\"\n+                 << \"  -regtest               \" << _(\"Enter regression test mode, which uses a special chain in which blocks can be \"\n+                                            \"solved instantly. This is intended for regression testing tools and app development.\").str() + \"\\n\";\n     } else {\n-        strUsage += _(\"RPC client options:\") + \"\\n\";\n+        ossUsage << _(\"RPC client options:\").str() << \"\\n\";\n     }\n \n-    strUsage += \"  -rpcconnect=<ip>       \" + _(\"Send commands to node running on <ip> (default: 127.0.0.1)\") + \"\\n\";\n-    strUsage += \"  -rpcport=<port>        \" + _(\"Connect to JSON-RPC on <port> (default: 8332 or testnet: 18332)\") + \"\\n\";\n-    strUsage += \"  -rpcwait               \" + _(\"Wait for RPC server to start\") + \"\\n\";\n-    strUsage += \"  -rpcuser=<user>        \" + _(\"Username for JSON-RPC connections\") + \"\\n\";\n-    strUsage += \"  -rpcpassword=<pw>      \" + _(\"Password for JSON-RPC connections\") + \"\\n\";\n+    ossUsage << \"  -rpcconnect=<ip>       \" << _(\"Send commands to node running on <ip> (default: 127.0.0.1)\").str() << \"\\n\"\n+             << \"  -rpcport=<port>        \" << _(\"Connect to JSON-RPC on <port> (default: 8332 or testnet: 18332)\").str() << \"\\n\"\n+             << \"  -rpcwait               \" << _(\"Wait for RPC server to start\").str() << \"\\n\"\n+             << \"  -rpcuser=<user>        \" << _(\"Username for JSON-RPC connections\").str() << \"\\n\"\n+             << \"  -rpcpassword=<pw>      \" << _(\"Password for JSON-RPC connections\").str() << \"\\n\";\n \n     if(mainProgram)\n     {\n-        strUsage += \"\\n\" + _(\"SSL options: (see the Bitcoin Wiki for SSL setup instructions)\") + \"\\n\";\n-        strUsage += \"  -rpcssl                \" + _(\"Use OpenSSL (https) for JSON-RPC connections\") + \"\\n\";\n+        ossUsage << \"\\n\"\n+                 << _(\"SSL options: (see the Bitcoin Wiki for SSL setup instructions)\").str() << \"\\n\"\n+                 << \"  -rpcssl                \" << _(\"Use OpenSSL (https) for JSON-RPC connections\").str() << \"\\n\";\n     }\n \n-    return strUsage;\n+    return ossUsage.str();\n }\n "
      },
      {
        "sha": "fb332a8e14354c3263124c2928aa29c5ac7bc449",
        "filename": "src/rpcdump.cpp",
        "status": "modified",
        "additions": 54,
        "deletions": 45,
        "changes": 99,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcdump.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -3,13 +3,16 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"base58.h\"\n-#include \"rpcserver.h\"\n+#include \"bitcointime.h\"\n #include \"init.h\"\n+#include \"log.h\"\n #include \"main.h\"\n+#include \"rpcserver.h\"\n #include \"sync.h\"\n #include \"wallet.h\"\n \n #include <fstream>\n+#include <sstream>\n #include <stdint.h>\n \n #include <boost/algorithm/string.hpp>\n@@ -23,7 +26,7 @@ using namespace std;\n void EnsureWalletIsUnlocked();\n \n std::string static EncodeDumpTime(int64_t nTime) {\n-    return DateTimeStrFormat(\"%Y-%m-%\"PRId64\"T%H:%M:%SZ\", nTime);\n+    return BitcoinTime::DateTimeStrFormat(\"%Y-%m-%dT%H:%M:%SZ\", nTime);\n }\n \n int64_t static DecodeDumpTime(const std::string &str) {\n@@ -68,23 +71,26 @@ std::string DecodeDumpString(const std::string &str) {\n Value importprivkey(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() < 1 || params.size() > 3)\n-        throw runtime_error(\n-            \"importprivkey \\\"bitcoinprivkey\\\" ( \\\"label\\\" rescan )\\n\"\n-            \"\\nAdds a private key (as returned by dumpprivkey) to your wallet.\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"bitcoinprivkey\\\"   (string, required) The private key (see dumpprivkey)\\n\"\n-            \"2. \\\"label\\\"            (string, optional) an optional label\\n\"\n-            \"3. rescan               (boolean, optional, default=true) Rescan the wallet for transactions\\n\"\n-            \"\\nExamples:\\n\"\n-            \"\\nDump a private key\\n\"\n-            + HelpExampleCli(\"dumpprivkey\", \"\\\"myaddress\\\"\") +\n-            \"\\nImport the private key\\n\"\n-            + HelpExampleCli(\"importprivkey\", \"\\\"mykey\\\"\") +\n-            \"\\nImport using a label\\n\"\n-            + HelpExampleCli(\"importprivkey\", \"\\\"mykey\\\" \\\"testing\\\" false\") +\n-            \"\\nAs a json rpc call\\n\"\n-            + HelpExampleRpc(\"importprivkey\", \"\\\"mykey\\\", \\\"testing\\\", false\")\n-        );\n+    {\n+        std::ostringstream ossError;\n+        ossError << \"importprivkey \\\"bitcoinprivkey\\\" ( \\\"label\\\" rescan )\\n\"\n+                 << \"\\nAdds a private key (as returned by dumpprivkey) to your wallet.\\n\"\n+                 << \"\\nArguments:\\n\"\n+                 << \"1. \\\"bitcoinprivkey\\\"   (string, required) The private key (see dumpprivkey)\\n\"\n+                 << \"2. \\\"label\\\"            (string, optional) an optional label\\n\"\n+                 << \"3. rescan               (boolean, optional, default=true) Rescan the wallet for transactions\\n\"\n+                 << \"\\nExamples:\\n\"\n+                 << \"\\nDump a private key\\n\"\n+                 << HelpExampleCli(\"dumpprivkey\", \"\\\"myaddress\\\"\")\n+                 << \"\\nImport the private key\\n\"\n+                 << HelpExampleCli(\"importprivkey\", \"\\\"mykey\\\"\")\n+                 << \"\\nImport using a label\\n\"\n+                 << HelpExampleCli(\"importprivkey\", \"\\\"mykey\\\" \\\"testing\\\" false\")\n+                 << \"\\nAs a json rpc call\\n\"\n+                 << HelpExampleRpc(\"importprivkey\", \"\\\"mykey\\\", \\\"testing\\\", false\");\n+\n+        throw runtime_error(ossError.str());\n+    }\n \n     string strSecret = params[0].get_str();\n     string strLabel = \"\";\n@@ -171,7 +177,7 @@ Value importwallet(const Array& params, bool fHelp)\n         CPubKey pubkey = key.GetPubKey();\n         CKeyID keyid = pubkey.GetID();\n         if (pwalletMain->HaveKey(keyid)) {\n-            LogPrintf(\"Skipping import of %s (key already present)\\n\", CBitcoinAddress(keyid).ToString().c_str());\n+            Log() << \"Skipping import of \" << CBitcoinAddress(keyid).ToString() << \" (key already present)\\n\";\n             continue;\n         }\n         int64_t nTime = DecodeDumpTime(vstr[1]);\n@@ -189,7 +195,7 @@ Value importwallet(const Array& params, bool fHelp)\n                 fLabel = true;\n             }\n         }\n-        LogPrintf(\"Importing %s...\\n\", CBitcoinAddress(keyid).ToString().c_str());\n+        Log() << \"Importing \" << CBitcoinAddress(keyid).ToString() << \"...\\n\";\n         if (!pwalletMain->AddKeyPubKey(key, pubkey)) {\n             fGood = false;\n             continue;\n@@ -205,7 +211,7 @@ Value importwallet(const Array& params, bool fHelp)\n     while (pindex && pindex->pprev && pindex->nTime > nTimeBegin - 7200)\n         pindex = pindex->pprev;\n \n-    LogPrintf(\"Rescanning last %i blocks\\n\", chainActive.Height() - pindex->nHeight + 1);\n+    Log() << \"Rescanning last \" << (chainActive.Height() - pindex->nHeight + 1) << \" blocks\\n\";\n     pwalletMain->ScanForWalletTransactions(pindex);\n     pwalletMain->ReacceptWalletTransactions();\n     pwalletMain->MarkDirty();\n@@ -219,19 +225,22 @@ Value importwallet(const Array& params, bool fHelp)\n Value dumpprivkey(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() != 1)\n-        throw runtime_error(\n-            \"dumpprivkey \\\"bitcoinaddress\\\"\\n\"\n-            \"\\nReveals the private key corresponding to 'bitcoinaddress'.\\n\"\n-            \"Then the importprivkey can be used with this output\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"bitcoinaddress\\\"   (string, required) The bitcoin address for the private key\\n\"\n-            \"\\nResult:\\n\"\n-            \"\\\"key\\\"                (string) The private key\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"dumpprivkey\", \"\\\"myaddress\\\"\")\n-            + HelpExampleCli(\"importprivkey\", \"\\\"mykey\\\"\")\n-            + HelpExampleRpc(\"dumpprivkey\", \"\\\"myaddress\\\"\")\n-        );\n+    {\n+        std::ostringstream oss;\n+        oss << \"dumpprivkey \\\"bitcoinaddress\\\"\\n\"\n+            << \"\\nReveals the private key corresponding to 'bitcoinaddress'.\\n\"\n+            << \"Then the importprivkey can be used with this output\\n\"\n+            << \"\\nArguments:\\n\"\n+            << \"1. \\\"bitcoinaddress\\\"   (string, required) The bitcoin address for the private key\\n\"\n+            << \"\\nResult:\\n\"\n+            << \"\\\"key\\\"                (string) The private key\\n\"\n+            << \"\\nExamples:\\n\"\n+            << HelpExampleCli(\"dumpprivkey\", \"\\\"myaddress\\\"\")\n+            << HelpExampleCli(\"importprivkey\", \"\\\"mykey\\\"\")\n+            << HelpExampleRpc(\"dumpprivkey\", \"\\\"myaddress\\\"\");\n+\n+        throw runtime_error(oss.str());\n+    }\n \n     EnsureWalletIsUnlocked();\n \n@@ -283,28 +292,28 @@ Value dumpwallet(const Array& params, bool fHelp)\n     std::sort(vKeyBirth.begin(), vKeyBirth.end());\n \n     // produce output\n-    file << strprintf(\"# Wallet dump created by Bitcoin %s (%s)\\n\", CLIENT_BUILD.c_str(), CLIENT_DATE.c_str());\n-    file << strprintf(\"# * Created on %s\\n\", EncodeDumpTime(GetTime()).c_str());\n-    file << strprintf(\"# * Best block at time of backup was %i (%s),\\n\", chainActive.Height(), chainActive.Tip()->GetBlockHash().ToString().c_str());\n-    file << strprintf(\"#   mined on %s\\n\", EncodeDumpTime(chainActive.Tip()->nTime).c_str());\n-    file << \"\\n\";\n+    file << \"# Wallet dump created by Bitcoin \" << CLIENT_BUILD << \" (\" << CLIENT_DATE << \")\\n\"\n+         << \"# * Created on \" << EncodeDumpTime(BitcoinTime::GetTime()) << \"\\n\"\n+         << \"# * Best block at time of backup was \" <<  chainActive.Height() << \" (\" << chainActive.Tip()->GetBlockHash().ToString() << \"),\\n\"\n+         << \"#   mined on \" << EncodeDumpTime(chainActive.Tip()->nTime) << \"\\n\" \n+         << \"\\n\";\n     for (std::vector<std::pair<int64_t, CKeyID> >::const_iterator it = vKeyBirth.begin(); it != vKeyBirth.end(); it++) {\n         const CKeyID &keyid = it->second;\n         std::string strTime = EncodeDumpTime(it->first);\n         std::string strAddr = CBitcoinAddress(keyid).ToString();\n         CKey key;\n         if (pwalletMain->GetKey(keyid, key)) {\n             if (pwalletMain->mapAddressBook.count(keyid)) {\n-                file << strprintf(\"%s %s label=%s # addr=%s\\n\", CBitcoinSecret(key).ToString().c_str(), strTime.c_str(), EncodeDumpString(pwalletMain->mapAddressBook[keyid].name).c_str(), strAddr.c_str());\n+                file << CBitcoinSecret(key).ToString() << \" \" << strTime << \" label=\" << EncodeDumpString(pwalletMain->mapAddressBook[keyid].name) << \" # addr=\" << strAddr << \"\\n\";\n             } else if (setKeyPool.count(keyid)) {\n-                file << strprintf(\"%s %s reserve=1 # addr=%s\\n\", CBitcoinSecret(key).ToString().c_str(), strTime.c_str(), strAddr.c_str());\n+                file << CBitcoinSecret(key).ToString() << \" \" << strTime << \" reserve=1 # addr=\" << strAddr << \"\\n\";\n             } else {\n-                file << strprintf(\"%s %s change=1 # addr=%s\\n\", CBitcoinSecret(key).ToString().c_str(), strTime.c_str(), strAddr.c_str());\n+                file << CBitcoinSecret(key).ToString() << \" \" << strTime << \" change=1 # addr=\" << strAddr << \"\\n\";\n             }\n         }\n     }\n-    file << \"\\n\";\n-    file << \"# End of dump\\n\";\n+    file << \"\\n\"\n+         << \"# End of dump\\n\";\n     file.close();\n     return Value::null;\n }"
      },
      {
        "sha": "98a6fcd7cc5a887be79768966fd65234f27410ae",
        "filename": "src/rpcmining.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 6,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/rpcmining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/rpcmining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcmining.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -3,13 +3,14 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include \"rpcserver.h\"\n+#include \"bitcointime.h\"\n #include \"chainparams.h\"\n #include \"db.h\"\n #include \"init.h\"\n #include \"net.h\"\n #include \"main.h\"\n #include \"miner.h\"\n+#include \"rpcserver.h\"\n #include \"wallet.h\"\n \n #include <stdint.h>\n@@ -156,6 +157,7 @@ Value setgenerate(const Array& params, bool fHelp)\n     if (params.size() > 1)\n     {\n         nGenProcLimit = params[1].get_int();\n+\n         if (nGenProcLimit == 0)\n             fGenerate = false;\n     }\n@@ -212,7 +214,7 @@ Value gethashespersec(const Array& params, bool fHelp)\n             + HelpExampleRpc(\"gethashespersec\", \"\")\n         );\n \n-    if (GetTimeMillis() - nHPSTimerStart > 8000)\n+    if (BitcoinTime::GetTimeMillis() - nHPSTimerStart > 8000)\n         return (boost::int64_t)0;\n     return (boost::int64_t)dHashesPerSec;\n }\n@@ -299,7 +301,7 @@ Value getwork(const Array& params, bool fHelp)\n         static int64_t nStart;\n         static CBlockTemplate* pblocktemplate;\n         if (pindexPrev != chainActive.Tip() ||\n-            (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLast && GetTime() - nStart > 60))\n+            (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLast && BitcoinTime::GetTime() - nStart > 60))\n         {\n             if (pindexPrev != chainActive.Tip())\n             {\n@@ -316,7 +318,7 @@ Value getwork(const Array& params, bool fHelp)\n             // Store the pindexBest used before CreateNewBlock, to avoid races\n             nTransactionsUpdatedLast = mempool.GetTransactionsUpdated();\n             CBlockIndex* pindexPrevNew = chainActive.Tip();\n-            nStart = GetTime();\n+            nStart = BitcoinTime::GetTime();\n \n             // Create new block\n             pblocktemplate = CreateNewBlockWithKey(*pMiningKey);\n@@ -475,15 +477,15 @@ Value getblocktemplate(const Array& params, bool fHelp)\n     static int64_t nStart;\n     static CBlockTemplate* pblocktemplate;\n     if (pindexPrev != chainActive.Tip() ||\n-        (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLast && GetTime() - nStart > 5))\n+        (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLast && BitcoinTime::GetTime() - nStart > 5))\n     {\n         // Clear pindexPrev so future calls make a new block, despite any failures from here on\n         pindexPrev = NULL;\n \n         // Store the pindexBest used before CreateNewBlock, to avoid races\n         nTransactionsUpdatedLast = mempool.GetTransactionsUpdated();\n         CBlockIndex* pindexPrevNew = chainActive.Tip();\n-        nStart = GetTime();\n+        nStart = BitcoinTime::GetTime();\n \n         // Create new block\n         if(pblocktemplate)"
      },
      {
        "sha": "e43f65cf656c588833acb189f7652eb0c5d0d10a",
        "filename": "src/rpcnet.cpp",
        "status": "modified",
        "additions": 128,
        "deletions": 92,
        "changes": 220,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/rpcnet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/rpcnet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcnet.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -2,16 +2,22 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include \"rpcserver.h\"\n+\n+\n+#include \"bitcointime.h\"\n #include \"net.h\"\n #include \"netbase.h\"\n #include \"protocol.h\"\n+#include \"rpcserver.h\"\n #include \"sync.h\"\n #include \"util.h\"\n \n-#include <inttypes.h>\n+#include <iomanip>\n+#include <ios>\n+#include <sstream>\n \n #include <boost/foreach.hpp>\n+#include <boost/format.hpp>\n #include \"json/json_spirit_value.h\"\n \n using namespace json_spirit;\n@@ -20,15 +26,21 @@ using namespace std;\n Value getconnectioncount(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() != 0)\n-        throw runtime_error(\n-            \"getconnectioncount\\n\"\n-            \"\\nReturns the number of connections to other nodes.\\n\"\n-            \"\\nbResult:\\n\"\n-            \"n          (numeric) The connection count\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getconnectioncount\", \"\")\n-            + HelpExampleRpc(\"getconnectioncount\", \"\")\n-        );\n+    {\n+        ostringstream ossError;\n+        ossError << \"getconnectioncount\\n\"\n+                 << \"\\n\"\n+                 << \"Returns the number of connections to other nodes.\\n\"\n+                 << \"\\n\"\n+                 << \"bResult:\\n\"\n+                 << \"n          (numeric) The connection count\\n\"\n+                 << \"\\n\"\n+                 << \"Examples:\\n\"\n+                 << HelpExampleCli(\"getconnectioncount\", \"\")\n+                 << HelpExampleRpc(\"getconnectioncount\", \"\");\n+\n+        throw runtime_error(ossError.str());\n+    }\n \n     LOCK(cs_vNodes);\n     return (int)vNodes.size();\n@@ -37,15 +49,20 @@ Value getconnectioncount(const Array& params, bool fHelp)\n Value ping(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() != 0)\n-        throw runtime_error(\n-            \"ping\\n\"\n-            \"\\nRequests that a ping be sent to all other nodes, to measure ping time.\\n\"\n-            \"Results provided in getpeerinfo, pingtime and pingwait fields are decimal seconds.\\n\"\n-            \"Ping command is handled in queue with all other commands, so it measures processing backlog, not just network ping.\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"ping\", \"\")\n-            + HelpExampleRpc(\"ping\", \"\")\n-        );\n+    {\n+        ostringstream ossError;\n+        ossError << \"ping\\n\"\n+                 << \"\\n\"\n+                 << \"Requests that a ping be sent to all other nodes, to measure ping time.\\n\"\n+                 << \"Results provided in getpeerinfo, pingtime and pingwait fields are decimal seconds.\\n\"\n+                 << \"Ping command is handled in queue with all other commands, so it measures processing backlog, not just network ping.\"\n+                 << \"\\n\"\n+                 << \"Examples:\\n\"\n+                 << HelpExampleCli(\"ping\", \"\")\n+                 << HelpExampleRpc(\"ping\", \"\");\n+\n+        throw runtime_error(ossError.str());\n+    }\n \n     // Request that each node send a ping during next message processing pass\n     LOCK(cs_vNodes);\n@@ -72,36 +89,41 @@ static void CopyNodeStats(std::vector<CNodeStats>& vstats)\n Value getpeerinfo(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() != 0)\n-        throw runtime_error(\n-            \"getpeerinfo\\n\"\n-            \"\\nReturns data about each connected network node as a json array of objects.\\n\"\n-            \"\\nbResult:\\n\"\n-            \"[\\n\"\n-            \"  {\\n\"\n-            \"    \\\"addr\\\":\\\"host:port\\\",      (string) The ip address and port of the peer\\n\"\n-            \"    \\\"addrlocal\\\":\\\"ip:port\\\",   (string) local address\\n\"\n-            \"    \\\"services\\\":\\\"00000001\\\",   (string) The services\\n\"\n-            \"    \\\"lastsend\\\": ttt,           (numeric) The time in seconds since epoch (Jan 1 1970 GMT) of the last send\\n\"\n-            \"    \\\"lastrecv\\\": ttt,           (numeric) The time in seconds since epoch (Jan 1 1970 GMT) of the last receive\\n\"\n-            \"    \\\"bytessent\\\": n,            (numeric) The total bytes sent\\n\"\n-            \"    \\\"bytesrecv\\\": n,            (numeric) The total bytes received\\n\"\n-            \"    \\\"conntime\\\": ttt,           (numeric) The connection time in seconds since epoch (Jan 1 1970 GMT)\\n\"\n-            \"    \\\"pingtime\\\": n,             (numeric) ping time\\n\"\n-            \"    \\\"pingwait\\\": n,             (numeric) ping wait\\n\"\n-            \"    \\\"version\\\": v,              (numeric) The peer version, such as 7001\\n\"\n-            \"    \\\"subver\\\": \\\"/Satoshi:0.8.5/\\\",  (string) The string version\\n\"\n-            \"    \\\"inbound\\\": true|false,     (boolean) Inbound (true) or Outbound (false)\\n\"\n-            \"    \\\"startingheight\\\": n,       (numeric) The starting height (block) of the peer\\n\"\n-            \"    \\\"banscore\\\": n,              (numeric) The ban score (stats.nMisbehavior)\\n\"\n-            \"    \\\"syncnode\\\" : true|false     (booleamn) if sync node\\n\"\n-            \"  }\\n\"\n-            \"  ,...\\n\"\n-            \"}\\n\"\n-\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getpeerinfo\", \"\")\n-            + HelpExampleRpc(\"getpeerinfo\", \"\")\n-        );\n+    {\n+        ostringstream ossError;\n+        ossError << \"getpeerinfo\\n\"\n+                 << \"\\n\"\n+                 << \"Returns data about each connected network node as a json array of objects.\\n\"\n+                 << \"\\n\"\n+                 << \"bResult:\\n\"\n+                 << \"[\\n\"\n+                 << \"  {\\n\"\n+                 << \"    \\\"addr\\\":\\\"host:port\\\",      (string) The ip address and port of the peer\\n\"\n+                 << \"    \\\"addrlocal\\\":\\\"ip:port\\\",   (string) local address\\n\"\n+                 << \"    \\\"services\\\":\\\"00000001\\\",   (string) The services\\n\"\n+                 << \"    \\\"lastsend\\\": ttt,           (numeric) The time in seconds since epoch (Jan 1 1970 GMT) of the last send\\n\"\n+                 << \"    \\\"lastrecv\\\": ttt,           (numeric) The time in seconds since epoch (Jan 1 1970 GMT) of the last receive\\n\"\n+                 << \"    \\\"bytessent\\\": n,            (numeric) The total bytes sent\\n\"\n+                 << \"    \\\"bytesrecv\\\": n,            (numeric) The total bytes received\\n\"\n+                 << \"    \\\"conntime\\\": ttt,           (numeric) The connection time in seconds since epoch (Jan 1 1970 GMT)\\n\"\n+                 << \"    \\\"pingtime\\\": n,             (numeric) ping time\\n\"\n+                 << \"    \\\"pingwait\\\": n,             (numeric) ping wait\\n\"\n+                 << \"    \\\"version\\\": v,              (numeric) The peer version, such as 7001\\n\"\n+                 << \"    \\\"subver\\\": \\\"/Satoshi:0.8.5/\\\",  (string) The string version\\n\"\n+                 << \"    \\\"inbound\\\": true|false,     (boolean) Inbound (true) or Outbound (false)\\n\"\n+                 << \"    \\\"startingheight\\\": n,       (numeric) The starting height (block) of the peer\\n\"\n+                 << \"    \\\"banscore\\\": n,              (numeric) The ban score (stats.nMisbehavior)\\n\"\n+                 << \"    \\\"syncnode\\\" : true|false     (booleamn) if sync node\\n\"\n+                 << \"  }\\n\"\n+                 << \"  ,...\\n\"\n+                 << \"}\\n\"\n+                 << \"\\n\"\n+                 << \"Examples:\\n\"\n+                 << HelpExampleCli(\"getpeerinfo\", \"\")\n+                 << HelpExampleRpc(\"getpeerinfo\", \"\");\n+\n+        throw runtime_error(ossError.str());\n+    }\n \n     vector<CNodeStats> vstats;\n     CopyNodeStats(vstats);\n@@ -114,7 +136,8 @@ Value getpeerinfo(const Array& params, bool fHelp)\n         obj.push_back(Pair(\"addr\", stats.addrName));\n         if (!(stats.addrLocal.empty()))\n             obj.push_back(Pair(\"addrlocal\", stats.addrLocal));\n-        obj.push_back(Pair(\"services\", strprintf(\"%08\"PRIx64, stats.nServices)));\n+\n+        obj.push_back(Pair(\"services\", boost::str(boost::format(\"%08x\") % stats.nServices)));\n         obj.push_back(Pair(\"lastsend\", (boost::int64_t)stats.nLastSend));\n         obj.push_back(Pair(\"lastrecv\", (boost::int64_t)stats.nLastRecv));\n         obj.push_back(Pair(\"bytessent\", (boost::int64_t)stats.nSendBytes));\n@@ -147,17 +170,23 @@ Value addnode(const Array& params, bool fHelp)\n         strCommand = params[1].get_str();\n     if (fHelp || params.size() != 2 ||\n         (strCommand != \"onetry\" && strCommand != \"add\" && strCommand != \"remove\"))\n-        throw runtime_error(\n-            \"addnode \\\"node\\\" \\\"add|remove|onetry\\\"\\n\"\n-            \"\\nAttempts add or remove a node from the addnode list.\\n\"\n-            \"Or try a connection to a node once.\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"node\\\"     (string, required) The node (see getpeerinfo for nodes)\\n\"\n-            \"2. \\\"command\\\"  (string, required) 'add' to add a node to the list, 'remove' to remove a node from the list, 'onetry' to try a connection to the node once\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"addnode\", \"\\\"192.168.0.6:8333\\\" \\\"onetry\\\"\")\n-            + HelpExampleRpc(\"addnode\", \"\\\"192.168.0.6:8333\\\", \\\"onetry\\\"\")\n-        );\n+    {\n+        ostringstream ossError;\n+        ossError << \"addnode \\\"node\\\" \\\"add|remove|onetry\\\"\\n\"\n+                 << \"\\n\"\n+                 << \"Attempts add or remove a node from the addnode list.\\n\"\n+                 << \"Or try a connection to a node once.\\n\"\n+                 << \"\\n\"\n+                 << \"Arguments:\\n\"\n+                 << \"1. \\\"node\\\"     (string, required) The node (see getpeerinfo for nodes)\\n\"\n+                 << \"2. \\\"command\\\"  (string, required) 'add' to add a node to the list, 'remove' to remove a node from the list, 'onetry' to try a connection to the node once\\n\"\n+                 << \"\\n\"\n+                 << \"Examples:\\n\"\n+                 << HelpExampleCli(\"addnode\", \"\\\"192.168.0.6:8333\\\" \\\"onetry\\\"\")\n+                 << HelpExampleRpc(\"addnode\", \"\\\"192.168.0.6:8333\\\", \\\"onetry\\\"\");\n+\n+        throw runtime_error(ossError.str());\n+    }\n \n     string strNode = params[0].get_str();\n \n@@ -193,35 +222,42 @@ Value addnode(const Array& params, bool fHelp)\n Value getaddednodeinfo(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() < 1 || params.size() > 2)\n-        throw runtime_error(\n-            \"getaddednodeinfo dns ( \\\"node\\\" )\\n\"\n-            \"\\nReturns information about the given added node, or all added nodes\\n\"\n-            \"(note that onetry addnodes are not listed here)\\n\"\n-            \"If dns is false, only a list of added nodes will be provided,\\n\"\n-            \"otherwise connected information will also be available.\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. dns        (boolean, required) If false, only a list of added nodes will be provided, otherwise connected information will also be available.\\n\"\n-            \"2. \\\"node\\\"   (string, optional) If provided, return information about this specific node, otherwise all nodes are returned.\\n\"\n-            \"\\nResult:\\n\"\n-            \"[\\n\"\n-            \"  {\\n\"\n-            \"    \\\"addednode\\\" : \\\"192.168.0.201\\\",   (string) The node ip address\\n\"\n-            \"    \\\"connected\\\" : true|false,          (boolean) If connected\\n\"\n-            \"    \\\"addresses\\\" : [\\n\"\n-            \"       {\\n\"\n-            \"         \\\"address\\\" : \\\"192.168.0.201:8333\\\",  (string) The bitcoin server host and port\\n\"\n-            \"         \\\"connected\\\" : \\\"outbound\\\"           (string) connection, inbound or outbound\\n\"\n-            \"       }\\n\"\n-            \"       ,...\\n\"\n-            \"     ]\\n\"\n-            \"  }\\n\"\n-            \"  ,...\\n\"\n-            \"]\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getaddednodeinfo\", \"true\")\n-            + HelpExampleCli(\"getaddednodeinfo\", \"true \\\"192.168.0.201\\\"\")\n-            + HelpExampleRpc(\"getaddednodeinfo\", \"true, \\\"192.168.0.201\\\"\")\n-        );\n+    {\n+        ostringstream ossError;\n+        ossError << \"getaddednodeinfo dns ( \\\"node\\\" )\\n\"\n+                 << \"\\n\"\n+                 << \"Returns information about the given added node, or all added nodes\\n\"\n+                 << \"(note that onetry addnodes are not listed here)\\n\"\n+                 << \"If dns is false, only a list of added nodes will be provided,\\n\"\n+                 << \"otherwise connected information will also be available.\\n\"\n+                 << \"\\n\"\n+                 << \"Arguments:\\n\"\n+                 << \"1. dns        (boolean, required) If false, only a list of added nodes will be provided, otherwise connected information will also be available.\\n\"\n+                 << \"2. \\\"node\\\"   (string, optional) If provided, return information about this specific node, otherwise all nodes are returned.\\n\"\n+                 << \"\\n\"\n+                 << \"Result:\\n\"\n+                 << \"[\\n\"\n+                 << \"  {\\n\"\n+                 << \"    \\\"addednode\\\" : \\\"192.168.0.201\\\",   (string) The node ip address\\n\"\n+                 << \"    \\\"connected\\\" : true|false,          (boolean) If connected\\n\"\n+                 << \"    \\\"addresses\\\" : [\\n\"\n+                 << \"       {\\n\"\n+                 << \"         \\\"address\\\" : \\\"192.168.0.201:8333\\\",  (string) The bitcoin server host and port\\n\"\n+                 << \"         \\\"connected\\\" : \\\"outbound\\\"           (string) connection, inbound or outbound\\n\"\n+                 << \"       }\\n\"\n+                 << \"       ,...\\n\"\n+                 << \"     ]\\n\"\n+                 << \"  }\\n\"\n+                 << \"  ,...\\n\"\n+                 << \"]\\n\"\n+                 << \"\\n\"\n+                 << \"Examples:\\n\"\n+                 << HelpExampleCli(\"getaddednodeinfo\", \"true\")\n+                 << HelpExampleCli(\"getaddednodeinfo\", \"true \\\"192.168.0.201\\\"\")\n+                 << HelpExampleRpc(\"getaddednodeinfo\", \"true, \\\"192.168.0.201\\\"\");\n+\n+        throw runtime_error(ossError.str());\n+    }\n \n     bool fDns = params[0].get_bool();\n \n@@ -326,6 +362,6 @@ Value getnettotals(const Array& params, bool fHelp)\n     Object obj;\n     obj.push_back(Pair(\"totalbytesrecv\", static_cast< boost::uint64_t>(CNode::GetTotalBytesRecv())));\n     obj.push_back(Pair(\"totalbytessent\", static_cast<boost::uint64_t>(CNode::GetTotalBytesSent())));\n-    obj.push_back(Pair(\"timemillis\", static_cast<boost::int64_t>(GetTimeMillis())));\n+    obj.push_back(Pair(\"timemillis\", static_cast<boost::int64_t>(BitcoinTime::GetTimeMillis())));\n     return obj;\n }"
      },
      {
        "sha": "f822b551568ab693323d48c06b621fab4aff3319",
        "filename": "src/rpcprotocol.cpp",
        "status": "modified",
        "additions": 41,
        "deletions": 39,
        "changes": 80,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/rpcprotocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/rpcprotocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcprotocol.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -65,46 +65,48 @@ static string rfc1123Time()\n \n string HTTPReply(int nStatus, const string& strMsg, bool keepalive)\n {\n+    std::ostringstream ossReply;\n+\n     if (nStatus == HTTP_UNAUTHORIZED)\n-        return strprintf(\"HTTP/1.0 401 Authorization Required\\r\\n\"\n-            \"Date: %s\\r\\n\"\n-            \"Server: bitcoin-json-rpc/%s\\r\\n\"\n-            \"WWW-Authenticate: Basic realm=\\\"jsonrpc\\\"\\r\\n\"\n-            \"Content-Type: text/html\\r\\n\"\n-            \"Content-Length: 296\\r\\n\"\n-            \"\\r\\n\"\n-            \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\"\\r\\n\"\n-            \"\\\"http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd\\\">\\r\\n\"\n-            \"<HTML>\\r\\n\"\n-            \"<HEAD>\\r\\n\"\n-            \"<TITLE>Error</TITLE>\\r\\n\"\n-            \"<META HTTP-EQUIV='Content-Type' CONTENT='text/html; charset=ISO-8859-1'>\\r\\n\"\n-            \"</HEAD>\\r\\n\"\n-            \"<BODY><H1>401 Unauthorized.</H1></BODY>\\r\\n\"\n-            \"</HTML>\\r\\n\", rfc1123Time().c_str(), FormatFullVersion().c_str());\n-    const char *cStatus;\n-         if (nStatus == HTTP_OK) cStatus = \"OK\";\n-    else if (nStatus == HTTP_BAD_REQUEST) cStatus = \"Bad Request\";\n-    else if (nStatus == HTTP_FORBIDDEN) cStatus = \"Forbidden\";\n-    else if (nStatus == HTTP_NOT_FOUND) cStatus = \"Not Found\";\n-    else if (nStatus == HTTP_INTERNAL_SERVER_ERROR) cStatus = \"Internal Server Error\";\n-    else cStatus = \"\";\n-    return strprintf(\n-            \"HTTP/1.1 %d %s\\r\\n\"\n-            \"Date: %s\\r\\n\"\n-            \"Connection: %s\\r\\n\"\n-            \"Content-Length: %\"PRIszu\"\\r\\n\"\n-            \"Content-Type: application/json\\r\\n\"\n-            \"Server: bitcoin-json-rpc/%s\\r\\n\"\n-            \"\\r\\n\"\n-            \"%s\",\n-        nStatus,\n-        cStatus,\n-        rfc1123Time().c_str(),\n-        keepalive ? \"keep-alive\" : \"close\",\n-        strMsg.size(),\n-        FormatFullVersion().c_str(),\n-        strMsg.c_str());\n+    {\n+        ossReply << \"HTTP/1.0 401 Authorization Required\\r\\n\"\n+                 << \"Date: \" << rfc1123Time() << \"\\r\\n\"\n+                 << \"Server: bitcoin-json-rpc/\" << FormatFullVersion() << \"\\r\\n\"\n+                 << \"WWW-Authenticate: Basic realm=\\\"jsonrpc\\\"\\r\\n\"\n+                 << \"Content-Type: text/html\\r\\n\"\n+                 << \"Content-Length: 296\\r\\n\"\n+                 << \"\\r\\n\"\n+                 << \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\"\\r\\n\"\n+                 << \"\\\"http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd\\\">\\r\\n\"\n+                 << \"<HTML>\\r\\n\"\n+                 << \"<HEAD>\\r\\n\"\n+                 << \"<TITLE>Error</TITLE>\\r\\n\"\n+                 << \"<META HTTP-EQUIV='Content-Type' CONTENT='text/html; charset=ISO-8859-1'>\\r\\n\"\n+                 << \"</HEAD>\\r\\n\"\n+                 << \"<BODY><H1>401 Unauthorized.</H1></BODY>\\r\\n\"\n+                 << \"</HTML>\\r\\n\";\n+\n+        return ossReply.str();\n+    }\n+\n+    ossReply << \"HTTP/1.1 \"<< nStatus << \" \";\n+\n+         if (nStatus == HTTP_OK) ossReply << \"OK\";\n+    else if (nStatus == HTTP_BAD_REQUEST) ossReply << \"Bad Request\";\n+    else if (nStatus == HTTP_FORBIDDEN) ossReply << \"Forbidden\";\n+    else if (nStatus == HTTP_NOT_FOUND) ossReply << \"Not Found\";\n+    else if (nStatus == HTTP_INTERNAL_SERVER_ERROR) ossReply << \"Internal Server Error\";\n+\n+    ossReply << \"\\r\\n\"\n+             << \"Date: \" << rfc1123Time() << \"\\r\\n\"\n+             << \"Connection: \" << (keepalive ? \"keep-alive\" : \"close\") << \"\\r\\n\"\n+             << \"Content-Length: \" << strMsg.size() << \"\\r\\n\"\n+             << \"Content-Type: application/json\\r\\n\"\n+             << \"Server: bitcoin-json-rpc/\" << FormatFullVersion() << \"\\r\\n\"\n+             << \"\\r\\n\"\n+             << strMsg;\n+\n+   return ossReply.str();\n }\n \n bool ReadHTTPRequestLine(std::basic_istream<char>& stream, int &proto,"
      },
      {
        "sha": "4f71997e1d76f0d4ce77936c3d46a81a7c8ec5d0",
        "filename": "src/rpcserver.cpp",
        "status": "modified",
        "additions": 29,
        "deletions": 30,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/rpcserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/rpcserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcserver.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -7,16 +7,23 @@\n \n #include \"base58.h\"\n #include \"init.h\"\n+#include \"log.h\"\n #include \"main.h\"\n+#include \"ui_interface.h\"\n #include \"util.h\"\n #include \"wallet.h\"\n \n+#include <iostream>\n+#include <sstream>\n+#include <stdint.h>\n+\n #include <boost/algorithm/string.hpp>\n #include <boost/asio.hpp>\n #include <boost/asio/ssl.hpp>\n #include <boost/bind.hpp>\n #include <boost/filesystem.hpp>\n #include <boost/foreach.hpp>\n+#include <boost/format.hpp>\n #include <boost/iostreams/concepts.hpp>\n #include <boost/iostreams/stream.hpp>\n #include <boost/lexical_cast.hpp>\n@@ -48,11 +55,7 @@ void RPCTypeCheck(const Array& params,\n \n         const Value& v = params[i];\n         if (!((v.type() == t) || (fAllowNull && (v.type() == null_type))))\n-        {\n-            string err = strprintf(\"Expected type %s, got %s\",\n-                                   Value_type_name[t], Value_type_name[v.type()]);\n-            throw JSONRPCError(RPC_TYPE_ERROR, err);\n-        }\n+            throw JSONRPCError(RPC_TYPE_ERROR, boost::str(boost::format(\"Expected type %s, got %s\") % Value_type_name[t] % Value_type_name[v.type()]));\n         i++;\n     }\n }\n@@ -65,14 +68,10 @@ void RPCTypeCheck(const Object& o,\n     {\n         const Value& v = find_value(o, t.first);\n         if (!fAllowNull && v.type() == null_type)\n-            throw JSONRPCError(RPC_TYPE_ERROR, strprintf(\"Missing %s\", t.first.c_str()));\n+            throw JSONRPCError(RPC_TYPE_ERROR, boost::str(boost::format(\"Missing %s\") % t.first));\n \n         if (!((v.type() == t.second) || (fAllowNull && (v.type() == null_type))))\n-        {\n-            string err = strprintf(\"Expected type %s for %s, got %s\",\n-                                   Value_type_name[t.second], t.first.c_str(), Value_type_name[v.type()]);\n-            throw JSONRPCError(RPC_TYPE_ERROR, err);\n-        }\n+            throw JSONRPCError(RPC_TYPE_ERROR, boost::str(boost::format(\"Expected type %s for %s, got %s\") % Value_type_name[t.second] % t.first % Value_type_name[v.type()]));\n     }\n }\n \n@@ -138,7 +137,7 @@ vector<unsigned char> ParseHexO(const Object& o, string strKey)\n \n string CRPCTable::help(string strCommand) const\n {\n-    string strRet;\n+    ostringstream ossRet;\n     set<rpcfn_type> setDone;\n     for (map<string, const CRPCCommand*>::const_iterator mi = mapCommands.begin(); mi != mapCommands.end(); ++mi)\n     {\n@@ -166,13 +165,13 @@ string CRPCTable::help(string strCommand) const\n             if (strCommand == \"\")\n                 if (strHelp.find('\\n') != string::npos)\n                     strHelp = strHelp.substr(0, strHelp.find('\\n'));\n-            strRet += strHelp + \"\\n\";\n+            ossRet << strHelp + \"\\n\";\n         }\n     }\n-    if (strRet == \"\")\n-        strRet = strprintf(\"help: unknown command: %s\\n\", strCommand.c_str());\n-    strRet = strRet.substr(0,strRet.size()-1);\n-    return strRet;\n+    if (ossRet.tellp() == 0)\n+        ossRet << \"help: unknown command: \" << strCommand << \"\\n\";\n+\n+    return ossRet.str().substr(0, (size_t) ossRet.tellp() - 1);\n }\n \n Value help(const Array& params, bool fHelp)\n@@ -484,10 +483,10 @@ void StartRPCThreads()\n         RAND_bytes(rand_pwd, 32);\n         string strWhatAmI = \"To use bitcoind\";\n         if (mapArgs.count(\"-server\"))\n-            strWhatAmI = strprintf(_(\"To use the %s option\"), \"\\\"-server\\\"\");\n+            strWhatAmI = str(_(\"To use the %s option\") % \"\\\"-server\\\"\");\n         else if (mapArgs.count(\"-daemon\"))\n-            strWhatAmI = strprintf(_(\"To use the %s option\"), \"\\\"-daemon\\\"\");\n-        uiInterface.ThreadSafeMessageBox(strprintf(\n+            strWhatAmI = str(_(\"To use the %s option\") % \"\\\"-daemon\\\"\");\n+        uiInterface.ThreadSafeMessageBox(str(\n             _(\"%s, you must set a rpcpassword in the configuration file:\\n\"\n               \"%s\\n\"\n               \"It is recommended you use the following random password:\\n\"\n@@ -497,10 +496,10 @@ void StartRPCThreads()\n               \"The username and password MUST NOT be the same.\\n\"\n               \"If the file does not exist, create it with owner-readable-only file permissions.\\n\"\n               \"It is also recommended to set alertnotify so you are notified of problems;\\n\"\n-              \"for example: alertnotify=echo %%s | mail -s \\\"Bitcoin Alert\\\" admin@foo.com\\n\"),\n-                strWhatAmI.c_str(),\n-                GetConfigFile().string().c_str(),\n-                EncodeBase58(&rand_pwd[0],&rand_pwd[0]+32).c_str()),\n+              \"for example: alertnotify=echo %%s | mail -s \\\"Bitcoin Alert\\\" admin@foo.com\\n\")\n+                % strWhatAmI\n+                % GetConfigFile().string()\n+                % EncodeBase58(&rand_pwd[0],&rand_pwd[0]+32)),\n                 \"\", CClientUIInterface::MSG_ERROR);\n         StartShutdown();\n         return;\n@@ -519,12 +518,12 @@ void StartRPCThreads()\n         filesystem::path pathCertFile(GetArg(\"-rpcsslcertificatechainfile\", \"server.cert\"));\n         if (!pathCertFile.is_complete()) pathCertFile = filesystem::path(GetDataDir()) / pathCertFile;\n         if (filesystem::exists(pathCertFile)) rpc_ssl_context->use_certificate_chain_file(pathCertFile.string());\n-        else LogPrintf(\"ThreadRPCServer ERROR: missing server certificate file %s\\n\", pathCertFile.string().c_str());\n+        else Log() << \"ThreadRPCServer ERROR: missing server certificate file \" << pathCertFile.string() << \"\\n\";\n \n         filesystem::path pathPKFile(GetArg(\"-rpcsslprivatekeyfile\", \"server.pem\"));\n         if (!pathPKFile.is_complete()) pathPKFile = filesystem::path(GetDataDir()) / pathPKFile;\n         if (filesystem::exists(pathPKFile)) rpc_ssl_context->use_private_key_file(pathPKFile.string(), ssl::context::pem);\n-        else LogPrintf(\"ThreadRPCServer ERROR: missing server private key file %s\\n\", pathPKFile.string().c_str());\n+        else Log() << \"ThreadRPCServer ERROR: missing server private key file \" << pathPKFile.string() << \"\\n\";\n \n         string strCiphers = GetArg(\"-rpcsslciphers\", \"TLSv1.2+HIGH:TLSv1+HIGH:!SSLv2:!aNULL:!eNULL:!3DES:@STRENGTH\");\n         SSL_CTX_set_cipher_list(rpc_ssl_context->impl(), strCiphers.c_str());\n@@ -556,7 +555,7 @@ void StartRPCThreads()\n     }\n     catch(boost::system::system_error &e)\n     {\n-        strerr = strprintf(_(\"An error occurred while setting up the RPC port %u for listening on IPv6, falling back to IPv4: %s\"), endpoint.port(), e.what());\n+        strerr = str(_(\"An error occurred while setting up the RPC port %u for listening on IPv6, falling back to IPv4: %s\") % endpoint.port() % e.what());\n     }\n \n     try {\n@@ -579,7 +578,7 @@ void StartRPCThreads()\n     }\n     catch(boost::system::system_error &e)\n     {\n-        strerr = strprintf(_(\"An error occurred while setting up the RPC port %u for listening on IPv4: %s\"), endpoint.port(), e.what());\n+        strerr = str(_(\"An error occurred while setting up the RPC port %u for listening on IPv4: %s\") % endpoint.port() % e.what());\n     }\n \n     if (!fListening) {\n@@ -654,7 +653,7 @@ void JSONRequest::parse(const Value& valRequest)\n         throw JSONRPCError(RPC_INVALID_REQUEST, \"Method must be a string\");\n     strMethod = valMethod.get_str();\n     if (strMethod != \"getwork\" && strMethod != \"getblocktemplate\")\n-        LogPrint(\"rpc\", \"ThreadRPCServer method=%s\\n\", strMethod.c_str());\n+        Log(\"rpc\") << \"ThreadRPCServer method=\" << strMethod << \"\\n\";\n \n     // Parse params\n     Value valParams = find_value(request, \"params\");\n@@ -729,7 +728,7 @@ void ServiceConnection(AcceptedConnection *conn)\n         }\n         if (!HTTPAuthorized(mapHeaders))\n         {\n-            LogPrintf(\"ThreadRPCServer incorrect password attempt from %s\\n\", conn->peer_address_to_string().c_str());\n+            Log() << \"ThreadRPCServer incorrect password attempt from \" << conn->peer_address_to_string() << \"\\n\";\n             /* Deter brute-forcing short passwords.\n                If this results in a DoS the user really\n                shouldn't have their RPC port exposed. */"
      },
      {
        "sha": "dad7ff78736f546c30aaf899b78461910815c969",
        "filename": "src/rpcwallet.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 12,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcwallet.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -4,17 +4,19 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"base58.h\"\n-#include \"rpcserver.h\"\n+#include \"bitcointime.h\"\n #include \"init.h\"\n #include \"net.h\"\n #include \"netbase.h\"\n+#include \"rpcserver.h\"\n #include \"util.h\"\n #include \"wallet.h\"\n #include \"walletdb.h\"\n \n #include <stdint.h>\n \n #include <boost/assign/list_of.hpp>\n+#include <boost/format.hpp>\n #include \"json/json_spirit_utils.h\"\n #include \"json/json_spirit_value.h\"\n \n@@ -115,7 +117,7 @@ Value getinfo(const Array& params, bool fHelp)\n         obj.push_back(Pair(\"balance\",       ValueFromAmount(pwalletMain->GetBalance())));\n     }\n     obj.push_back(Pair(\"blocks\",        (int)chainActive.Height()));\n-    obj.push_back(Pair(\"timeoffset\",    (boost::int64_t)GetTimeOffset()));\n+    obj.push_back(Pair(\"timeoffset\",    (boost::int64_t)BitcoinTime::GetTimeOffset()));\n     obj.push_back(Pair(\"connections\",   (int)vNodes.size()));\n     obj.push_back(Pair(\"proxy\",         (proxy.first.IsValid() ? proxy.first.ToStringIPPort() : string())));\n     obj.push_back(Pair(\"difficulty\",    (double)GetDifficulty()));\n@@ -804,7 +806,7 @@ Value movecmd(const Array& params, bool fHelp)\n     if (!walletdb.TxnBegin())\n         throw JSONRPCError(RPC_DATABASE_ERROR, \"database error\");\n \n-    int64_t nNow = GetAdjustedTime();\n+    int64_t nNow = BitcoinTime::GetAdjustedTime();\n \n     // Debit\n     CAccountingEntry debit;\n@@ -987,9 +989,7 @@ static CScript _createmultisig(const Array& params)\n     if (nRequired < 1)\n         throw runtime_error(\"a multisignature address must require at least one key to redeem\");\n     if ((int)keys.size() < nRequired)\n-        throw runtime_error(\n-            strprintf(\"not enough keys supplied \"\n-                      \"(got %\"PRIszu\" keys, but need at least %d to redeem)\", keys.size(), nRequired));\n+        throw runtime_error(boost::str(boost::format(\"not enough keys supplied (got %u keys, but need at least %u to redeem)\") % keys.size() % nRequired));\n     std::vector<CPubKey> pubkeys;\n     pubkeys.resize(keys.size());\n     for (unsigned int i = 0; i < keys.size(); i++)\n@@ -1002,14 +1002,12 @@ static CScript _createmultisig(const Array& params)\n         {\n             CKeyID keyID;\n             if (!address.GetKeyID(keyID))\n-                throw runtime_error(\n-                    strprintf(\"%s does not refer to a key\",ks.c_str()));\n+                throw runtime_error(ks + \" does not refer to a key\");\n             CPubKey vchPubKey;\n             if (!pwalletMain->GetPubKey(keyID, vchPubKey))\n-                throw runtime_error(\n-                    strprintf(\"no full public key for address %s\",ks.c_str()));\n+                throw runtime_error(string(\"no full public key for address \") + ks);\n             if (!vchPubKey.IsFullyValid())\n-                throw runtime_error(\" Invalid public key: \"+ks);\n+                throw runtime_error(\" Invalid public key: \" + ks);\n             pubkeys[i] = vchPubKey;\n         }\n \n@@ -1796,7 +1794,7 @@ Value walletpassphrase(const Array& params, bool fHelp)\n \n     int64_t nSleepTime = params[1].get_int64();\n     LOCK(cs_nWalletUnlockTime);\n-    nWalletUnlockTime = GetTime() + nSleepTime;\n+    nWalletUnlockTime = BitcoinTime::GetTime() + nSleepTime;\n     RPCRunLater(\"lockwallet\", boost::bind(LockWallet, pwalletMain), nSleepTime);\n \n     return Value::null;"
      },
      {
        "sha": "58ad95c524985419b19fa137b272056827390c80",
        "filename": "src/script.cpp",
        "status": "modified",
        "additions": 80,
        "deletions": 22,
        "changes": 102,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -236,15 +236,25 @@ bool IsCanonicalPubKey(const valtype &vchPubKey, unsigned int flags) {\n         return true;\n \n     if (vchPubKey.size() < 33)\n-        return error(\"Non-canonical public key: too short\");\n+    {\n+        Log() << \"ERROR: Non-canonical public key: too short\\n\";\n+        return false;\n+    }\n     if (vchPubKey[0] == 0x04) {\n         if (vchPubKey.size() != 65)\n-            return error(\"Non-canonical public key: invalid length for uncompressed key\");\n+        {\n+            Log() << \"ERROR: Non-canonical public key: invalid length for uncompressed key\\n\";\n+            return false;\n+        }\n     } else if (vchPubKey[0] == 0x02 || vchPubKey[0] == 0x03) {\n         if (vchPubKey.size() != 33)\n-            return error(\"Non-canonical public key: invalid length for compressed key\");\n+        {\n+            Log() << \"ERROR: Non-canonical public key: invalid length for compressed key\\n\";\n+            return false;\n+        }\n     } else {\n-        return error(\"Non-canonical public key: compressed nor uncompressed\");\n+        Log() << \"ERROR: Non-canonical public key: compressed nor uncompressed\\n\";\n+        return false;\n     }\n     return true;\n }\n@@ -259,46 +269,94 @@ bool IsCanonicalSignature(const valtype &vchSig, unsigned int flags) {\n     // excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,\n     // in which case a single 0 byte is necessary and even required).\n     if (vchSig.size() < 9)\n-        return error(\"Non-canonical signature: too short\");\n+    {\n+        Log() << \"ERROR: Non-canonical signature: too short\\n\";\n+        return false;\n+    }\n     if (vchSig.size() > 73)\n-        return error(\"Non-canonical signature: too long\");\n+    {\n+        Log() << \"ERROR: Non-canonical signature: too long\\n\";\n+        return false;\n+    }\n     unsigned char nHashType = vchSig[vchSig.size() - 1] & (~(SIGHASH_ANYONECANPAY));\n     if (nHashType < SIGHASH_ALL || nHashType > SIGHASH_SINGLE)\n-        return error(\"Non-canonical signature: unknown hashtype byte\");\n+    {\n+        Log() << \"ERROR: Non-canonical signature: unknown hashtype byte\\n\";\n+        return false;\n+    }\n     if (vchSig[0] != 0x30)\n-        return error(\"Non-canonical signature: wrong type\");\n+    {\n+        Log() << \"ERROR: Non-canonical signature: wrong type\\n\";\n+        return false;\n+    }\n     if (vchSig[1] != vchSig.size()-3)\n-        return error(\"Non-canonical signature: wrong length marker\");\n+    {\n+        Log() << \"ERROR: Non-canonical signature: wrong length marker\\n\";\n+        return false;\n+    }\n     unsigned int nLenR = vchSig[3];\n     if (5 + nLenR >= vchSig.size())\n-        return error(\"Non-canonical signature: S length misplaced\");\n+    {\n+        Log() << \"ERROR: Non-canonical signature: S length misplaced\\n\";\n+        return false;\n+    }\n     unsigned int nLenS = vchSig[5+nLenR];\n     if ((unsigned long)(nLenR+nLenS+7) != vchSig.size())\n-        return error(\"Non-canonical signature: R+S length mismatch\");\n+    {\n+        Log() << \"ERROR: Non-canonical signature: R+S length mismatch\\n\";\n+        return false;\n+    }\n \n     const unsigned char *R = &vchSig[4];\n     if (R[-2] != 0x02)\n-        return error(\"Non-canonical signature: R value type mismatch\");\n+    {\n+        Log() << \"ERROR: Non-canonical signature: R value type mismatch\\n\";\n+        return false;\n+    }\n     if (nLenR == 0)\n-        return error(\"Non-canonical signature: R length is zero\");\n+    {\n+        Log() << \"ERROR: Non-canonical signature: R length is zero\\n\";\n+        return false;\n+    }\n     if (R[0] & 0x80)\n-        return error(\"Non-canonical signature: R value negative\");\n+    {\n+        Log() << \"ERROR: Non-canonical signature: R value negative\\n\";\n+        return false;\n+    }\n     if (nLenR > 1 && (R[0] == 0x00) && !(R[1] & 0x80))\n-        return error(\"Non-canonical signature: R value excessively padded\");\n+    {\n+        Log() << \"ERROR: Non-canonical signature: R value excessively padded\\n\";\n+        return false;\n+    }\n \n     const unsigned char *S = &vchSig[6+nLenR];\n     if (S[-2] != 0x02)\n-        return error(\"Non-canonical signature: S value type mismatch\");\n+    {\n+        Log() << \"ERROR: Non-canonical signature: S value type mismatch\\n\";\n+        return false;\n+    }\n     if (nLenS == 0)\n-        return error(\"Non-canonical signature: S length is zero\");\n+    {\n+        Log() << \"ERROR: Non-canonical signature: S length is zero\\n\";\n+        return false;\n+    }\n     if (S[0] & 0x80)\n-        return error(\"Non-canonical signature: S value negative\");\n+    {\n+        Log() << \"ERROR: Non-canonical signature: S value negative\\n\";\n+        return false;\n+    }\n     if (nLenS > 1 && (S[0] == 0x00) && !(S[1] & 0x80))\n-        return error(\"Non-canonical signature: S value excessively padded\");\n+    {\n+        Log() << \"ERROR: Non-canonical signature: S value excessively padded\\n\";\n+        return false;\n+    }\n \n     if (flags & SCRIPT_VERIFY_EVEN_S) {\n         if (S[nLenS-1] & 1)\n-            return error(\"Non-canonical signature: S value odd\");\n+        {\n+            Log() << \"ERROR: Non-canonical signature: S value odd\\n\";\n+            return false;\n+        }\n     }\n \n     return true;\n@@ -1073,14 +1131,14 @@ class CTransactionSignatureSerializer {\n uint256 SignatureHash(const CScript &scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType)\n {\n     if (nIn >= txTo.vin.size()) {\n-        LogPrintf(\"ERROR: SignatureHash() : nIn=%d out of range\\n\", nIn);\n+        Log() << \"ERROR: SignatureHash() : nIn=\" << nIn << \" out of range\\n\";\n         return 1;\n     }\n \n     // Check for invalid use of SIGHASH_SINGLE\n     if ((nHashType & 0x1f) == SIGHASH_SINGLE) {\n         if (nIn >= txTo.vout.size()) {\n-            LogPrintf(\"ERROR: SignatureHash() : nOut=%d out of range\\n\", nIn);\n+            Log() << \"ERROR: SignatureHash() : nOut=\" << nIn << \" out of range\\n\";\n             return 1;\n         }\n     }"
      },
      {
        "sha": "505cf7300132c4a50894a2daa2a05d206217786f",
        "filename": "src/script.h",
        "status": "modified",
        "additions": 13,
        "deletions": 11,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.h?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -8,8 +8,10 @@\n \n #include \"bignum.h\"\n #include \"key.h\"\n+#include \"log.h\"\n #include \"util.h\"\n \n+#include <sstream>\n #include <stdexcept>\n #include <stdint.h>\n #include <string>\n@@ -224,7 +226,7 @@ const char* GetOpName(opcodetype opcode);\n inline std::string ValueString(const std::vector<unsigned char>& vch)\n {\n     if (vch.size() <= 4)\n-        return strprintf(\"%d\", CBigNum(vch).getint());\n+        return tostr(CBigNum(vch).getint());\n     else\n         return HexStr(vch);\n }\n@@ -574,35 +576,35 @@ class CScript : public std::vector<unsigned char>\n \n     void PrintHex() const\n     {\n-        LogPrintf(\"CScript(%s)\\n\", HexStr(begin(), end(), true).c_str());\n+        Log() << \"CScript(\" << HexStr(begin(), end(), true) << \"\\n\";\n     }\n \n     std::string ToString() const\n     {\n-        std::string str;\n+        std::ostringstream oss;\n         opcodetype opcode;\n         std::vector<unsigned char> vch;\n         const_iterator pc = begin();\n         while (pc < end())\n         {\n-            if (!str.empty())\n-                str += \" \";\n+            if (oss.tellp() > 0)\n+                oss << \" \";\n             if (!GetOp(pc, opcode, vch))\n             {\n-                str += \"[error]\";\n-                return str;\n+                oss << \"[error]\";\n+                return oss.str();\n             }\n             if (0 <= opcode && opcode <= OP_PUSHDATA4)\n-                str += ValueString(vch);\n+                oss << ValueString(vch);\n             else\n-                str += GetOpName(opcode);\n+                oss << GetOpName(opcode);\n         }\n-        return str;\n+        return oss.str();\n     }\n \n     void print() const\n     {\n-        LogPrintf(\"%s\\n\", ToString().c_str());\n+        Log() << ToString() << \"\\n\";\n     }\n \n     CScriptID GetID() const"
      },
      {
        "sha": "ecff0b86e7302392b824fa6e1b9a3860b0ea2346",
        "filename": "src/sync.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/sync.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/sync.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sync.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -39,7 +39,7 @@ struct CLockLocation\n \n     std::string ToString() const\n     {\n-        return mutexName+\"  \"+sourceFile+\":\"+itostr(sourceLine);\n+        return mutexName+\"  \"+sourceFile+\":\"+tostr(sourceLine);\n     }\n \n     std::string MutexName() const { return mutexName; }"
      },
      {
        "sha": "262f75b9f5fe99009927e9c11d5b1ea022bbd095",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 6,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -5,12 +5,15 @@\n \n \n #include \"bignum.h\"\n+#include \"bitcointime.h\"\n #include \"keystore.h\"\n+#include \"log.h\"\n #include \"main.h\"\n #include \"net.h\"\n #include \"script.h\"\n #include \"serialize.h\"\n \n+#include <iostream>\n #include <stdint.h>\n \n #include <boost/assign/list_of.hpp> // for 'map_list_of()'\n@@ -69,19 +72,19 @@ BOOST_AUTO_TEST_CASE(DoS_banscore)\n BOOST_AUTO_TEST_CASE(DoS_bantime)\n {\n     CNode::ClearBanned();\n-    int64_t nStartTime = GetTime();\n-    SetMockTime(nStartTime); // Overrides future calls to GetTime()\n+    int64_t nStartTime = BitcoinTime::GetTime();\n+    BitcoinTime::SetMockTime(nStartTime); // Overrides future calls to BitcoinTime::GetTime()\n \n     CAddress addr(ip(0xa0b0c001));\n     CNode dummyNode(INVALID_SOCKET, addr, \"\", true);\n \n     dummyNode.Misbehaving(100);\n     BOOST_CHECK(CNode::IsBanned(addr));\n \n-    SetMockTime(nStartTime+60*60);\n+    BitcoinTime::SetMockTime(nStartTime+60*60);\n     BOOST_CHECK(CNode::IsBanned(addr));\n \n-    SetMockTime(nStartTime+60*60*24+1);\n+    BitcoinTime::SetMockTime(nStartTime+60*60*24+1);\n     BOOST_CHECK(!CNode::IsBanned(addr));\n }\n \n@@ -261,7 +264,7 @@ BOOST_AUTO_TEST_CASE(DoS_checkSig)\n     boost::posix_time::ptime mst2 = boost::posix_time::microsec_clock::local_time();\n     boost::posix_time::time_duration msdiff = mst2 - mst1;\n     long nOneValidate = msdiff.total_milliseconds();\n-    if (fDebug) printf(\"DoS_Checksig sign: %ld\\n\", nOneValidate);\n+    if (Log::fDebug) std::cout << \"DoS_Checksig sign: \" << nOneValidate << \"\\n\";\n \n     // ... now validating repeatedly should be quick:\n     // 2.8GHz machine, -g build: Sign takes ~760ms,\n@@ -274,7 +277,7 @@ BOOST_AUTO_TEST_CASE(DoS_checkSig)\n     mst2 = boost::posix_time::microsec_clock::local_time();\n     msdiff = mst2 - mst1;\n     long nManyValidate = msdiff.total_milliseconds();\n-    if (fDebug) printf(\"DoS_Checksig five: %ld\\n\", nManyValidate);\n+    if (Log::fDebug) std::cout << \"DoS_Checksig five: \" << nManyValidate << \"\\n\";\n \n     BOOST_CHECK_MESSAGE(nManyValidate < nOneValidate, \"Signature cache timing failed\");\n "
      },
      {
        "sha": "6cfc322a92196f4fb5f6afdf58e5df0a6d79c8fd",
        "filename": "src/test/alert_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/test/alert_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/test/alert_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/alert_tests.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -5,6 +5,7 @@\n #include \"alert.h\"\n #include \"data/alertTests.raw.h\"\n \n+#include \"bitcointime.h\"\n #include \"serialize.h\"\n #include \"util.h\"\n #include \"version.h\"\n@@ -110,7 +111,7 @@ BOOST_FIXTURE_TEST_SUITE(Alert_tests, ReadAlerts)\n \n BOOST_AUTO_TEST_CASE(AlertApplies)\n {\n-    SetMockTime(11);\n+    BitcoinTime::SetMockTime(11);\n \n     BOOST_FOREACH(const CAlert& alert, alerts)\n     {\n@@ -144,7 +145,7 @@ BOOST_AUTO_TEST_CASE(AlertApplies)\n \n     BOOST_CHECK(!alerts[2].AppliesTo(1, \"/Satoshi:0.3.0/\"));\n \n-    SetMockTime(0);\n+    BitcoinTime::SetMockTime(0);\n }\n \n \n@@ -153,7 +154,7 @@ BOOST_AUTO_TEST_CASE(AlertApplies)\n #ifndef WIN32\n BOOST_AUTO_TEST_CASE(AlertNotify)\n {\n-    SetMockTime(11);\n+    BitcoinTime::SetMockTime(11);\n \n     boost::filesystem::path temp = GetTempPath() / \"alertnotify.txt\";\n     boost::filesystem::remove(temp);\n@@ -172,7 +173,7 @@ BOOST_AUTO_TEST_CASE(AlertNotify)\n \n     boost::filesystem::remove(temp);\n \n-    SetMockTime(0);\n+    BitcoinTime::SetMockTime(0);\n }\n #endif\n "
      },
      {
        "sha": "4f8eb3520d9357cdbc7f7695424cb8ff995e4a9b",
        "filename": "src/test/checkblock_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/test/checkblock_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/test/checkblock_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/checkblock_tests.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -4,6 +4,7 @@\n \n \n \n+#include \"bitcointime.h\"\n #include \"main.h\"\n \n #include <cstdio>\n@@ -46,7 +47,7 @@ BOOST_AUTO_TEST_CASE(May15)\n     // test/data/Mar12Fork.dat from\n     // http://sourceforge.net/projects/bitcoin/files/Bitcoin/blockchain/Mar12Fork.dat/download\n     unsigned int tMay15 = 1368576000;\n-    SetMockTime(tMay15); // Test as if it was right at May 15\n+    BitcoinTime::SetMockTime(tMay15); // Test as if it was right at May 15\n \n     CBlock forkingBlock;\n     if (read_block(\"Mar12Fork.dat\", forkingBlock))\n@@ -58,7 +59,7 @@ BOOST_AUTO_TEST_CASE(May15)\n         BOOST_CHECK(CheckBlock(forkingBlock, state, false, false));\n     }\n \n-    SetMockTime(0);\n+    BitcoinTime::SetMockTime(0);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "55273fec14c9332b1cca180835ebd08c28ebbfaa",
        "filename": "src/test/key_tests.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 6,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/test/key_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/test/key_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/key_tests.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -5,9 +5,11 @@\n #include \"uint256.h\"\n #include \"util.h\"\n \n+#include <iostream>\n #include <string>\n #include <vector>\n \n+#include <boost/format.hpp>\n #include <boost/test/unit_test.hpp>\n \n using namespace std;\n@@ -34,20 +36,20 @@ void dumpKeyInfo(uint256 privkey)\n     vector<unsigned char> sec;\n     sec.resize(32);\n     memcpy(&sec[0], &secret[0], 32);\n-    printf(\"  * secret (hex): %s\\n\", HexStr(sec).c_str());\n+    std::cout << \"  * secret (hex): \" << HexStr(sec) << \"\\n\";\n \n     for (int nCompressed=0; nCompressed<2; nCompressed++)\n     {\n         bool fCompressed = nCompressed == 1;\n-        printf(\"  * %s:\\n\", fCompressed ? \"compressed\" : \"uncompressed\");\n+        cout << (\"  * \" << (fCompressed ? \"compressed\" : \"uncompressed\") << \":\\n\");\n         CBitcoinSecret bsecret;\n         bsecret.SetSecret(secret, fCompressed);\n-        printf(\"    * secret (base58): %s\\n\", bsecret.ToString().c_str());\n+        cout << \"    * secret (base58): \" << bsecret.ToString() << \"\\n\";\n         CKey key;\n         key.SetSecret(secret, fCompressed);\n         vector<unsigned char> vchPubKey = key.GetPubKey();\n-        printf(\"    * pubkey (hex): %s\\n\", HexStr(vchPubKey).c_str());\n-        printf(\"    * address (base58): %s\\n\", CBitcoinAddress(vchPubKey).ToString().c_str());\n+        cout << \"    * pubkey (hex): \" << HexStr(vchPubKey) << \"\\n\";\n+        cout << \"    * address (base58): \" << CBitcoinAddress(vchPubKey).ToString() << \"\\n\";\n     }\n }\n #endif\n@@ -85,7 +87,7 @@ BOOST_AUTO_TEST_CASE(key_test1)\n \n     for (int n=0; n<16; n++)\n     {\n-        string strMsg = strprintf(\"Very secret message %i: 11\", n);\n+        string strMsg = boost::str(boost::format(\"Very secret message %d: 11\") % n);\n         uint256 hashMsg = Hash(strMsg.begin(), strMsg.end());\n \n         // normal signatures"
      },
      {
        "sha": "c1e9f45612ae19e85bf452c4ad05d7e4b592cefb",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 10,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -1,5 +1,6 @@\n \n \n+#include \"bitcointime.h\"\n #include \"main.h\"\n #include \"miner.h\"\n #include \"uint256.h\"\n@@ -101,7 +102,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     {\n         tx.vout[0].nValue -= 1000000;\n         hash = tx.GetHash();\n-        mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n+        mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, BitcoinTime::GetTime(), 111.0, 11));\n         tx.vin[0].prevout.hash = hash;\n     }\n     BOOST_CHECK(pblocktemplate = CreateNewBlockWithKey(reservekey));\n@@ -121,7 +122,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     {\n         tx.vout[0].nValue -= 10000000;\n         hash = tx.GetHash();\n-        mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n+        mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, BitcoinTime::GetTime(), 111.0, 11));\n         tx.vin[0].prevout.hash = hash;\n     }\n     BOOST_CHECK(pblocktemplate = CreateNewBlockWithKey(reservekey));\n@@ -130,7 +131,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n \n     // orphan in mempool\n     hash = tx.GetHash();\n-    mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n+    mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, BitcoinTime::GetTime(), 111.0, 11));\n     BOOST_CHECK(pblocktemplate = CreateNewBlockWithKey(reservekey));\n     delete pblocktemplate;\n     mempool.clear();\n@@ -140,15 +141,15 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vin[0].prevout.hash = txFirst[1]->GetHash();\n     tx.vout[0].nValue = 4900000000LL;\n     hash = tx.GetHash();\n-    mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n+    mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, BitcoinTime::GetTime(), 111.0, 11));\n     tx.vin[0].prevout.hash = hash;\n     tx.vin.resize(2);\n     tx.vin[1].scriptSig = CScript() << OP_1;\n     tx.vin[1].prevout.hash = txFirst[0]->GetHash();\n     tx.vin[1].prevout.n = 0;\n     tx.vout[0].nValue = 5900000000LL;\n     hash = tx.GetHash();\n-    mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n+    mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, BitcoinTime::GetTime(), 111.0, 11));\n     BOOST_CHECK(pblocktemplate = CreateNewBlockWithKey(reservekey));\n     delete pblocktemplate;\n     mempool.clear();\n@@ -159,7 +160,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vin[0].scriptSig = CScript() << OP_0 << OP_1;\n     tx.vout[0].nValue = 0;\n     hash = tx.GetHash();\n-    mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n+    mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, BitcoinTime::GetTime(), 111.0, 11));\n     BOOST_CHECK(pblocktemplate = CreateNewBlockWithKey(reservekey));\n     delete pblocktemplate;\n     mempool.clear();\n@@ -172,12 +173,12 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     script = CScript() << OP_0;\n     tx.vout[0].scriptPubKey.SetDestination(script.GetID());\n     hash = tx.GetHash();\n-    mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n+    mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, BitcoinTime::GetTime(), 111.0, 11));\n     tx.vin[0].prevout.hash = hash;\n     tx.vin[0].scriptSig = CScript() << (std::vector<unsigned char>)script;\n     tx.vout[0].nValue -= 1000000;\n     hash = tx.GetHash();\n-    mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n+    mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, BitcoinTime::GetTime(), 111.0, 11));\n     BOOST_CHECK(pblocktemplate = CreateNewBlockWithKey(reservekey));\n     delete pblocktemplate;\n     mempool.clear();\n@@ -188,10 +189,10 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vout[0].nValue = 4900000000LL;\n     tx.vout[0].scriptPubKey = CScript() << OP_1;\n     hash = tx.GetHash();\n-    mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n+    mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, BitcoinTime::GetTime(), 111.0, 11));\n     tx.vout[0].scriptPubKey = CScript() << OP_2;\n     hash = tx.GetHash();\n-    mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n+    mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, BitcoinTime::GetTime(), 111.0, 11));\n     BOOST_CHECK(pblocktemplate = CreateNewBlockWithKey(reservekey));\n     delete pblocktemplate;\n     mempool.clear();"
      },
      {
        "sha": "a8dfa68b3f83624dcbd11d426d1c2f92fa52cc5e",
        "filename": "src/test/multisig_tests.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 9,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/test/multisig_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/test/multisig_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/multisig_tests.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -8,6 +8,7 @@\n \n #include <boost/assign/std/vector.hpp>\n #include <boost/foreach.hpp>\n+#include <boost/format.hpp>\n #include <boost/test/unit_test.hpp>\n \n using namespace std;\n@@ -83,12 +84,12 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n         keys.clear();\n         keys += key[i];\n         s = sign_multisig(a_and_b, keys, txTo[0], 0);\n-        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, txTo[0], 0, flags, 0), strprintf(\"a&b 1: %d\", i));\n+        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, txTo[0], 0, flags, 0), boost::str(boost::format(\"a&b 1: %d\") % i));\n \n         keys.clear();\n         keys += key[1],key[i];\n         s = sign_multisig(a_and_b, keys, txTo[0], 0);\n-        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, txTo[0], 0, flags, 0), strprintf(\"a&b 2: %d\", i));\n+        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, txTo[0], 0, flags, 0), boost::str(boost::format(\"a&b 2: %d\") % i));\n     }\n \n     // Test a OR b:\n@@ -98,9 +99,9 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n         keys += key[i];\n         s = sign_multisig(a_or_b, keys, txTo[1], 0);\n         if (i == 0 || i == 1)\n-            BOOST_CHECK_MESSAGE(VerifyScript(s, a_or_b, txTo[1], 0, flags, 0), strprintf(\"a|b: %d\", i));\n+            BOOST_CHECK_MESSAGE(VerifyScript(s, a_or_b, txTo[1], 0, flags, 0), boost::str(boost::format(\"a|b 1: %d\") % i));\n         else\n-            BOOST_CHECK_MESSAGE(!VerifyScript(s, a_or_b, txTo[1], 0, flags, 0), strprintf(\"a|b: %d\", i));\n+            BOOST_CHECK_MESSAGE(!VerifyScript(s, a_or_b, txTo[1], 0, flags, 0), boost::str(boost::format(\"a|b 2: %d\") % i));\n     }\n     s.clear();\n     s << OP_0 << OP_0;\n@@ -117,9 +118,9 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n             keys += key[i],key[j];\n             s = sign_multisig(escrow, keys, txTo[2], 0);\n             if (i < j && i < 3 && j < 3)\n-                BOOST_CHECK_MESSAGE(VerifyScript(s, escrow, txTo[2], 0, flags, 0), strprintf(\"escrow 1: %d %d\", i, j));\n+                BOOST_CHECK_MESSAGE(VerifyScript(s, escrow, txTo[2], 0, flags, 0), boost::str(boost::format(\"escrow 1: %d %d\") % i % j));\n             else\n-                BOOST_CHECK_MESSAGE(!VerifyScript(s, escrow, txTo[2], 0, flags, 0), strprintf(\"escrow 2: %d %d\", i, j));\n+                BOOST_CHECK_MESSAGE(!VerifyScript(s, escrow, txTo[2], 0, flags, 0), boost::str(boost::format(\"escrow 2: %d %d\") % i % j));\n         }\n }\n \n@@ -285,9 +286,7 @@ BOOST_AUTO_TEST_CASE(multisig_Sign)\n     }\n \n     for (int i = 0; i < 3; i++)\n-    {\n-        BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0), strprintf(\"SignSignature %d\", i));\n-    }\n+        BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0), boost::str(boost::format(\"SignSignature %d\") % i));\n }\n \n "
      },
      {
        "sha": "004a359d0860502cdc995de256fa6ecaf5295213",
        "filename": "src/test/script_P2SH_tests.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 7,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/test/script_P2SH_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/test/script_P2SH_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_P2SH_tests.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -7,6 +7,7 @@\n \n #include <vector>\n \n+#include <boost/format.hpp>\n #include <boost/test/unit_test.hpp>\n \n using namespace std;\n@@ -93,24 +94,26 @@ BOOST_AUTO_TEST_CASE(sign)\n         txTo[i].vin[0].prevout.n = i;\n         txTo[i].vin[0].prevout.hash = txFrom.GetHash();\n         txTo[i].vout[0].nValue = 1;\n-        BOOST_CHECK_MESSAGE(IsMine(keystore, txFrom.vout[i].scriptPubKey), strprintf(\"IsMine %d\", i));\n+        BOOST_CHECK_MESSAGE(IsMine(keystore, txFrom.vout[i].scriptPubKey), boost::str(boost::format(\"IsMine %d\") % i));\n     }\n     for (int i = 0; i < 8; i++)\n     {\n-        BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0), strprintf(\"SignSignature %d\", i));\n+        BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0), boost::str(boost::format(\"SignSignature %d\") % i));\n     }\n     // All of the above should be OK, and the txTos have valid signatures\n     // Check to make sure signature verification fails if we use the wrong ScriptSig:\n     for (int i = 0; i < 8; i++)\n         for (int j = 0; j < 8; j++)\n         {\n+            string strMsg = boost::str(boost::format(\"VerifySignature %d %d\") % i % j);\n+\n             CScript sigSave = txTo[i].vin[0].scriptSig;\n             txTo[i].vin[0].scriptSig = txTo[j].vin[0].scriptSig;\n             bool sigOK = VerifySignature(CCoins(txFrom, 0), txTo[i], 0, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC, 0);\n             if (i == j)\n-                BOOST_CHECK_MESSAGE(sigOK, strprintf(\"VerifySignature %d %d\", i, j));\n+                BOOST_CHECK_MESSAGE(sigOK, strMsg);\n             else\n-                BOOST_CHECK_MESSAGE(!sigOK, strprintf(\"VerifySignature %d %d\", i, j));\n+                BOOST_CHECK_MESSAGE(!sigOK, strMsg);\n             txTo[i].vin[0].scriptSig = sigSave;\n         }\n }\n@@ -186,12 +189,12 @@ BOOST_AUTO_TEST_CASE(set)\n         txTo[i].vin[0].prevout.hash = txFrom.GetHash();\n         txTo[i].vout[0].nValue = 1*CENT;\n         txTo[i].vout[0].scriptPubKey = inner[i];\n-        BOOST_CHECK_MESSAGE(IsMine(keystore, txFrom.vout[i].scriptPubKey), strprintf(\"IsMine %d\", i));\n+        BOOST_CHECK_MESSAGE(IsMine(keystore, txFrom.vout[i].scriptPubKey), boost::str(boost::format(\"IsMine %d\") % i));\n     }\n     for (int i = 0; i < 4; i++)\n     {\n-        BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0), strprintf(\"SignSignature %d\", i));\n-        BOOST_CHECK_MESSAGE(IsStandardTx(txTo[i], reason), strprintf(\"txTo[%d].IsStandard\", i));\n+        BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0), boost::str(boost::format(\"SignSignature %d\") % i));\n+        BOOST_CHECK_MESSAGE(IsStandardTx(txTo[i], reason), boost::str(boost::format(\"txTo[%d].IsStamndard\") % i));\n     }\n }\n "
      },
      {
        "sha": "114efc5cf9f50f9e05acc3cc35901730f35a46a4",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -66,9 +66,7 @@ ParseScript(string s)\n         if (all(w, is_digit()) ||\n             (starts_with(w, \"-\") && all(string(w.begin()+1, w.end()), is_digit())))\n         {\n-            // Number\n-            int64_t n = atoi64(w);\n-            result << n;\n+            result << fromstr<int64_t>(w);\n         }\n         else if (starts_with(w, \"0x\") && IsHex(string(w.begin()+2, w.end())))\n         {"
      },
      {
        "sha": "7490e391a074528adabdb1420ec2266cccd054d4",
        "filename": "src/test/sighash_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/test/sighash_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/test/sighash_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sighash_tests.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -3,14 +3,16 @@\n #include \"main.h\"\n #include \"util.h\"\n \n+#include <iostream>\n+\n extern uint256 SignatureHash(const CScript &scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n \n // Old script.cpp SignatureHash function\n uint256 static SignatureHashOld(CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType)\n {\n     if (nIn >= txTo.vin.size())\n     {\n-        printf(\"ERROR: SignatureHash() : nIn=%d out of range\\n\", nIn);\n+        std::cout << \"ERROR: SignatureHash() : nIn=\" << nIn << \" out of range\\n\";\n         return 1;\n     }\n     CTransaction txTmp(txTo);\n@@ -41,7 +43,7 @@ uint256 static SignatureHashOld(CScript scriptCode, const CTransaction& txTo, un\n         unsigned int nOut = nIn;\n         if (nOut >= txTmp.vout.size())\n         {\n-            printf(\"ERROR: SignatureHash() : nOut=%d out of range\\n\", nOut);\n+            std::cout << \"ERROR: SignatureHash() : nOut=\" << nOut << \" out of range\\n\";\n             return 1;\n         }\n         txTmp.vout.resize(nOut+1);"
      },
      {
        "sha": "24bdd6e28c31f3e4b5fb76907c2b3ce7372575a3",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -2,14 +2,17 @@\n \n \n \n+#include \"bitcointime.h\"\n #include \"db.h\"\n+#include \"log.h\"\n #include \"main.h\"\n #include \"txdb.h\"\n #include \"ui_interface.h\"\n #include \"util.h\"\n #include \"wallet.h\"\n \n #include <boost/filesystem.hpp>\n+#include <boost/format.hpp>\n #include <boost/test/unit_test.hpp>\n \n \n@@ -24,10 +27,10 @@ struct TestingSetup {\n     boost::thread_group threadGroup;\n \n     TestingSetup() {\n-        fPrintToDebugger = true; // don't want to write to debug.log file\n+        Log::fPrintToDebugger = true; // don't want to write to debug.log file\n         noui_connect();\n         bitdb.MakeMock();\n-        pathTemp = GetTempPath() / strprintf(\"test_bitcoin_%lu_%i\", (unsigned long)GetTime(), (int)(GetRand(100000)));\n+        pathTemp = GetTempPath() / boost::str(boost::format(\"test_bitcoin_%u_%d\") % (unsigned long) BitcoinTime::GetTime() % (int) GetRand(100000));\n         boost::filesystem::create_directories(pathTemp);\n         mapArgs[\"-datadir\"] = pathTemp.string();\n         pblocktree = new CBlockTreeDB(1 << 20, true);"
      },
      {
        "sha": "e8bea0a004d5b53417706aba77e704a9e4770a2a",
        "filename": "src/test/uint256_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/test/uint256_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/test/uint256_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/uint256_tests.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -1,6 +1,7 @@\n #include \"uint256.h\"\n #include <string>\n \n+#include <iostream>\n #include <stdint.h>\n \n #include <boost/test/unit_test.hpp>"
      },
      {
        "sha": "b4f9f11f0fb58e6841e82fe27604e89532aaf6f9",
        "filename": "src/test/util_tests.cpp",
        "status": "modified",
        "additions": 90,
        "deletions": 19,
        "changes": 109,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/test/util_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/test/util_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util_tests.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -2,9 +2,12 @@\n \n #include \"sync.h\"\n \n+#include <ios>\n+#include <sstream>\n #include <stdint.h>\n #include <vector>\n \n+#include <boost/format.hpp>\n #include <boost/test/unit_test.hpp>\n \n using namespace std;\n@@ -303,30 +306,98 @@ BOOST_AUTO_TEST_CASE(util_TimingResistantEqual)\n     BOOST_CHECK(!TimingResistantEqual(std::string(\"abc\"), std::string(\"aba\")));\n }\n \n-/* Test strprintf formatting directives.\n+/* Test ostream and boost::format formatting directives.\n  * Put a string before and after to ensure sanity of element sizes on stack. */\n #define B \"check_prefix\"\n #define E \"check_postfix\"\n-BOOST_AUTO_TEST_CASE(strprintf_numbers)\n+BOOST_AUTO_TEST_CASE(ostream_numbers)\n {\n-    int64_t s64t = -9223372036854775807LL; /* signed 64 bit test value */\n-    uint64_t u64t = 18446744073709551615ULL; /* unsigned 64 bit test value */\n-    BOOST_CHECK(strprintf(\"%s %\"PRId64\" %s\", B, s64t, E) == B\" -9223372036854775807 \"E);\n-    BOOST_CHECK(strprintf(\"%s %\"PRIu64\" %s\", B, u64t, E) == B\" 18446744073709551615 \"E);\n-    BOOST_CHECK(strprintf(\"%s %\"PRIx64\" %s\", B, u64t, E) == B\" ffffffffffffffff \"E);\n-\n-    size_t st = 12345678; /* unsigned size_t test value */\n-    ssize_t sst = -12345678; /* signed size_t test value */\n-    BOOST_CHECK(strprintf(\"%s %\"PRIszd\" %s\", B, sst, E) == B\" -12345678 \"E);\n-    BOOST_CHECK(strprintf(\"%s %\"PRIszu\" %s\", B, st, E) == B\" 12345678 \"E);\n-    BOOST_CHECK(strprintf(\"%s %\"PRIszx\" %s\", B, st, E) == B\" bc614e \"E);\n-\n-    ptrdiff_t pt = 87654321; /* positive ptrdiff_t test value */\n-    ptrdiff_t spt = -87654321; /* negative ptrdiff_t test value */\n-    BOOST_CHECK(strprintf(\"%s %\"PRIpdd\" %s\", B, spt, E) == B\" -87654321 \"E);\n-    BOOST_CHECK(strprintf(\"%s %\"PRIpdu\" %s\", B, pt, E) == B\" 87654321 \"E);\n-    BOOST_CHECK(strprintf(\"%s %\"PRIpdx\" %s\", B, pt, E) == B\" 5397fb1 \"E);\n+    {\n+        int64_t s64t = -9223372036854775807LL; /* signed 64 bit test value */\n+        uint64_t u64t = 18446744073709551615ULL; /* unsigned 64 bit test value */\n+\n+        ostringstream ossSigned64, ossUnsigned64, ossHex64;\n+        ossSigned64   << B\" \" << s64t << \" \"E;\n+        ossUnsigned64 << B\" \" << u64t << \" \"E;\n+        ossHex64      << B\" \" << hex << u64t << \" \"E;\n+\n+        BOOST_CHECK(ossSigned64.str() == B\" -9223372036854775807 \"E);\n+        BOOST_CHECK(ossUnsigned64.str() == B\" 18446744073709551615 \"E);\n+        BOOST_CHECK(ossHex64.str() == B\" ffffffffffffffff \"E);\n+    }\n+\n+    {\n+        ssize_t sst = -12345678; /* signed size_t test value */\n+        size_t st = 12345678; /* unsigned size_t test value */\n+        \n+        ostringstream ossSSizet, ossSizet, ossHexSizet;\n+        ossSSizet   << B\" \" << sst << \" \"E;\n+        ossSizet    << B\" \" << st << \" \"E;\n+        ossHexSizet << B\" \" << hex << st << \" \"E;\n+        \n+        BOOST_CHECK(ossSSizet.str() == B\" -12345678 \"E);\n+        BOOST_CHECK(ossSizet.str() == B\" 12345678 \"E);\n+        BOOST_CHECK(ossHexSizet.str() == B\" bc614e \"E);\n+    }\n+\n+    {\n+        ptrdiff_t spt = -87654321; /* negative ptrdiff_t test value */\n+        ptrdiff_t pt = 87654321; /* positive ptrdiff_t test value */\n+\n+        ostringstream ossSPtrDiff, ossPtrDiff, ossHexPtrDiff;\n+        ossSPtrDiff   << B\" \" << spt << \" \"E;\n+        ossPtrDiff    << B\" \" << pt << \" \"E;\n+        ossHexPtrDiff << B\" \" << hex << pt << \" \"E;\n+\n+        BOOST_CHECK(ossSPtrDiff.str() == B\" -87654321 \"E);\n+        BOOST_CHECK(ossPtrDiff.str() == B\" 87654321 \"E);\n+        BOOST_CHECK(ossHexPtrDiff.str() == B\" 5397fb1 \"E);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(boost_format_numbers)\n+{\n+    {\n+        int64_t s64t = -9223372036854775807LL; /* signed 64 bit test value */\n+        uint64_t u64t = 18446744073709551615ULL; /* unsigned 64 bit test value */\n+\n+        string strSigned64   = boost::str(boost::format(B\" %d \"E) % s64t);\n+        string strUnsigned64 = boost::str(boost::format(B\" %u \"E) % u64t);\n+        string strHex64      = boost::str(boost::format(B\" %x \"E) % u64t);\n+\n+        BOOST_CHECK(strSigned64   == B\" -9223372036854775807 \"E);\n+        BOOST_CHECK(strUnsigned64 == B\" 18446744073709551615 \"E);\n+        BOOST_CHECK(strHex64      == B\" ffffffffffffffff \"E);\n+    }\n+\n+    {\n+        ssize_t sst = -12345678; /* signed size_t test value */\n+        size_t st = 12345678; /* unsigned size_t test value */\n+        \n+        string strSSizet   = boost::str(boost::format(B\" %d \"E) % sst);\n+        string strSizet    = boost::str(boost::format(B\" %u \"E) % st);\n+        string strHexSizet = boost::str(boost::format(B\" %x \"E) % st);\n+        \n+        BOOST_CHECK(strSSizet   == B\" -12345678 \"E);\n+        BOOST_CHECK(strSizet    == B\" 12345678 \"E);\n+        BOOST_CHECK(strHexSizet == B\" bc614e \"E);\n+    }\n+\n+    {\n+        ptrdiff_t spt = -87654321; /* negative ptrdiff_t test value */\n+        ptrdiff_t pt = 87654321; /* positive ptrdiff_t test value */\n+\n+        string strSPtrDiff   = boost::str(boost::format(B\" %d \"E) % spt);\n+        string strPtrDiff    = boost::str(boost::format(B\" %u \"E) % pt);\n+        string strHexPtrDiff = boost::str(boost::format(B\" %x \"E) % pt);\n+\n+        BOOST_CHECK(strSPtrDiff   == B\" -87654321 \"E);\n+        BOOST_CHECK(strPtrDiff    == B\" 87654321 \"E);\n+        BOOST_CHECK(strHexPtrDiff == B\" 5397fb1 \"E);\n+    }\n+    \n }\n+\n #undef B\n #undef E\n "
      },
      {
        "sha": "b265711dde878e2822d28865f46231605e0461e2",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 4,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -6,6 +6,7 @@\n #include \"txdb.h\"\n \n #include \"core.h\"\n+#include \"log.h\"\n #include \"uint256.h\"\n \n #include <stdint.h>\n@@ -54,7 +55,7 @@ bool CCoinsViewDB::SetBestBlock(const uint256 &hashBlock) {\n }\n \n bool CCoinsViewDB::BatchWrite(const std::map<uint256, CCoins> &mapCoins, const uint256 &hashBlock) {\n-    LogPrint(\"coindb\", \"Committing %u changed transactions to coin database...\\n\", (unsigned int)mapCoins.size());\n+    Log(\"coindb\") << \"Committing \" << (unsigned int) mapCoins.size() << \" changed transactions to coin database...\\n\";\n \n     CLevelDBBatch batch;\n     for (std::map<uint256, CCoins>::const_iterator it = mapCoins.begin(); it != mapCoins.end(); it++)\n@@ -148,7 +149,8 @@ bool CCoinsViewDB::GetStats(CCoinsStats &stats) {\n             }\n             pcursor->Next();\n         } catch (std::exception &e) {\n-            return error(\"%s() : deserialize error\", __PRETTY_FUNCTION__);\n+            Log() << \"ERROR: \" << __PRETTY_FUNCTION__ << \"() : deserialize error\\n\";\n+            return false;\n         }\n     }\n     delete pcursor;\n@@ -219,14 +221,18 @@ bool CBlockTreeDB::LoadBlockIndexGuts()\n                 pindexNew->nTx            = diskindex.nTx;\n \n                 if (!pindexNew->CheckIndex())\n-                    return error(\"LoadBlockIndex() : CheckIndex failed: %s\", pindexNew->ToString().c_str());\n+                {\n+                    Log() << \"ERROR: LoadBlockIndex() : CheckIndex failed: \" << pindexNew->ToString() << \"\\n\";\n+                    return false;\n+                }\n \n                 pcursor->Next();\n             } else {\n                 break; // if shutdown requested or finished loading block index\n             }\n         } catch (std::exception &e) {\n-            return error(\"%s() : deserialize error\", __PRETTY_FUNCTION__);\n+            Log() << \"ERROR: \" << __PRETTY_FUNCTION__ << \"() : deserialize error\\n\";\n+            return false;\n         }\n     }\n     delete pcursor;"
      },
      {
        "sha": "2260f0943f36490353f284fb4bcad79b52c4d6f4",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -4,6 +4,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"core.h\"\n+#include \"log.h\"\n #include \"txmempool.h\"\n \n using namespace std;\n@@ -138,7 +139,7 @@ void CTxMemPool::check(CCoinsViewCache *pcoins) const\n     if (!fSanityCheck)\n         return;\n \n-    LogPrint(\"mempool\", \"Checking mempool with %u transactions and %u inputs\\n\", (unsigned int)mapTx.size(), (unsigned int)mapNextTx.size());\n+    Log(\"mempool\") << \"Checking mempool with \" << (unsigned int) mapTx.size() << \" transactions and \" << (unsigned int)mapNextTx.size() << \" inputs\\n\";\n \n     LOCK(cs);\n     for (std::map<uint256, CTxMemPoolEntry>::const_iterator it = mapTx.begin(); it != mapTx.end(); it++) {"
      },
      {
        "sha": "e3916318a5b20ec1d5fecfecbae92bd5e6951215",
        "filename": "src/ui_interface.h",
        "status": "modified",
        "additions": 23,
        "deletions": 2,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/ui_interface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/ui_interface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ui_interface.h?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -9,6 +9,7 @@\n #include <stdint.h>\n #include <string>\n \n+#include <boost/format.hpp>\n #include <boost/signals2/last_value.hpp>\n #include <boost/signals2/signal.hpp>\n \n@@ -103,10 +104,30 @@ extern CClientUIInterface uiInterface;\n  * Translation function: Call Translate signal on UI interface, which returns a boost::optional result.\n  * If no translation slot is registered, nothing is returned, and simply return the input.\n  */\n-inline std::string _(const char* psz)\n+inline boost::format _(const char* psz)\n {\n     boost::optional<std::string> rv = uiInterface.Translate(psz);\n-    return rv ? (*rv) : psz;\n+    return boost::format(rv ? (*rv) : psz);\n }\n \n+\n+template <typename T>\n+inline T _(const char* psz);\n+\n+template <>\n+inline std::string _<std::string>(const char* psz)\n+{\n+    boost::optional<std::string> rv = uiInterface.Translate(psz);\n+    return (rv ? (*rv) : std::string(psz));\\\n+    }\n+\n+/* TODO: Move fromstr out of util.h to allow:\n+\n+template <typename T>\n+inline T _(const char* psz)\n+{\n+    return fromstr<T>(_<std::string>(psz));\n+}\n+*/\n+\n #endif"
      },
      {
        "sha": "2187a193d19222b99625168be06fff4d78946add",
        "filename": "src/uint256.h",
        "status": "modified",
        "additions": 60,
        "deletions": 50,
        "changes": 110,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/uint256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/uint256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/uint256.h?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -6,6 +6,11 @@\n #ifndef BITCOIN_UINT256_H\n #define BITCOIN_UINT256_H\n \n+#include \"log.h\"\n+\n+#include <iomanip>\n+#include <ios>\n+#include <sstream>\n #include <stdint.h>\n #include <stdio.h>\n #include <string>\n@@ -299,10 +304,13 @@ class base_uint\n \n     std::string GetHex() const\n     {\n-        char psz[sizeof(pn)*2 + 1];\n+        std::ostringstream oss;\n+        oss << std::hex << std::setfill('0');\n+\n         for (unsigned int i = 0; i < sizeof(pn); i++)\n-            sprintf(psz + i*2, \"%02x\", ((unsigned char*)pn)[sizeof(pn) - i - 1]);\n-        return std::string(psz, psz + sizeof(pn)*2);\n+            oss << std::setw(2) << static_cast<unsigned>(reinterpret_cast<const unsigned char*>(pn)[sizeof(pn) - i - 1]);\n+        \n+        return oss.str();\n     }\n \n     void SetHex(const char* psz)\n@@ -654,126 +662,128 @@ inline int Testuint256AdHoc(std::vector<std::string> vArg)\n     uint256 g(0);\n \n \n-    LogPrintf(\"%s\\n\", g.ToString().c_str());\n-    g--;  LogPrintf(\"g--\\n\");\n-    LogPrintf(\"%s\\n\", g.ToString().c_str());\n-    g--;  LogPrintf(\"g--\\n\");\n-    LogPrintf(\"%s\\n\", g.ToString().c_str());\n-    g++;  LogPrintf(\"g++\\n\");\n-    LogPrintf(\"%s\\n\", g.ToString().c_str());\n-    g++;  LogPrintf(\"g++\\n\");\n-    LogPrintf(\"%s\\n\", g.ToString().c_str());\n-    g++;  LogPrintf(\"g++\\n\");\n-    LogPrintf(\"%s\\n\", g.ToString().c_str());\n-    g++;  LogPrintf(\"g++\\n\");\n-    LogPrintf(\"%s\\n\", g.ToString().c_str());\n+    Log() << g.ToString() << \"\\n\";\n+    g--;  Log() << \"g--\\n\";\n+    Log() << g.ToString() << \"\\n\";\n+    g--;  Log() << \"g--\\n\";\n+    Log() << g.ToString() << \"\\n\";\n+    g++;  Log() << \"g++\\n\";\n+    Log() << g.ToString() << \"\\n\";\n+    g++;  Log() << \"g++\\n\";\n+    Log() << g.ToString() << \"\\n\";\n+    g++;  Log() << \"g++\\n\";\n+    Log() << g.ToString() << \"\\n\";\n+    g++;  Log() << \"g++\\n\";\n+    Log() << g.ToString() << \"\\n\";\n \n \n \n     uint256 a(7);\n-    LogPrintf(\"a=7\\n\");\n-    LogPrintf(\"%s\\n\", a.ToString().c_str());\n+    Log() << \"a=7\\n\";\n+    Log() << a.ToString() << \"\\n\";\n \n     uint256 b;\n-    LogPrintf(\"b undefined\\n\");\n-    LogPrintf(\"%s\\n\", b.ToString().c_str());\n+    Log() << \"b undefined\\n\";\n+    Log() << b.ToString() << \"\\n\";\n     int c = 3;\n \n     a = c;\n     a.pn[3] = 15;\n-    LogPrintf(\"%s\\n\", a.ToString().c_str());\n+    Log() << a.ToString() << \"\\n\";\n     uint256 k(c);\n \n     a = 5;\n     a.pn[3] = 15;\n-    LogPrintf(\"%s\\n\", a.ToString().c_str());\n+    Log() << a.ToString() << \"\\n\";\n     b = 1;\n     b <<= 52;\n \n     a |= b;\n \n     a ^= 0x500;\n \n-    LogPrintf(\"a %s\\n\", a.ToString().c_str());\n+    Log() << \"a \" << a.ToString() << \"\\n\";\n \n     a = a | b | (uint256)0x1000;\n \n \n-    LogPrintf(\"a %s\\n\", a.ToString().c_str());\n-    LogPrintf(\"b %s\\n\", b.ToString().c_str());\n+    Log() << \"a \" << a.ToString() << \"\\n\";\n+    Log() << \"b \" << b.ToString() << \"\\n\";\n \n     a = 0xfffffffe;\n     a.pn[4] = 9;\n \n-    LogPrintf(\"%s\\n\", a.ToString().c_str());\n+    Log() << a.ToString() << \"\\n\";\n     a++;\n-    LogPrintf(\"%s\\n\", a.ToString().c_str());\n+    Log() << a.ToString() << \"\\n\";\n     a++;\n-    LogPrintf(\"%s\\n\", a.ToString().c_str());\n+    Log() << a.ToString() << \"\\n\";\n     a++;\n-    LogPrintf(\"%s\\n\", a.ToString().c_str());\n+    Log() << a.ToString() << \"\\n\";\n     a++;\n-    LogPrintf(\"%s\\n\", a.ToString().c_str());\n+    Log() << a.ToString() << \"\\n\";\n \n     a--;\n-    LogPrintf(\"%s\\n\", a.ToString().c_str());\n+    Log() << a.ToString() << \"\\n\";\n     a--;\n-    LogPrintf(\"%s\\n\", a.ToString().c_str());\n+    Log() << a.ToString() << \"\\n\";\n     a--;\n-    LogPrintf(\"%s\\n\", a.ToString().c_str());\n+    Log() << a.ToString() << \"\\n\";\n     uint256 d = a--;\n-    LogPrintf(\"%s\\n\", d.ToString().c_str());\n-    LogPrintf(\"%s\\n\", a.ToString().c_str());\n+    Log() << d.ToString() << \"\\n\";\n+    Log() << a.ToString() << \"\\n\";\n     a--;\n-    LogPrintf(\"%s\\n\", a.ToString().c_str());\n+    Log() << a.ToString() << \"\\n\";\n     a--;\n-    LogPrintf(\"%s\\n\", a.ToString().c_str());\n+    Log() << a.ToString() << \"\\n\";\n \n     d = a;\n \n-    LogPrintf(\"%s\\n\", d.ToString().c_str());\n-    for (int i = uint256::WIDTH-1; i >= 0; i--) LogPrintf(\"%08x\", d.pn[i]); LogPrintf(\"\\n\");\n+    Log() << d.ToString() << \"\\n\";\n+    for (int i = uint256::WIDTH-1; i >= 0; i--) \n+        Log() << boost::format(\"%08x\") % d.pn[i]; \n+    Log() << \"\\n\";\n \n     uint256 neg = d;\n     neg = ~neg;\n-    LogPrintf(\"%s\\n\", neg.ToString().c_str());\n+    Log() << neg.ToString() << \"\\n\";\n \n \n     uint256 e = uint256(\"0xABCDEF123abcdef12345678909832180000011111111\");\n-    LogPrintf(\"\\n\");\n-    LogPrintf(\"%s\\n\", e.ToString().c_str());\n+    Log() << \"\\n\";\n+    Log() << e.ToString() << \"\\n\";\n \n \n-    LogPrintf(\"\\n\");\n+    Log() << \"\\n\";\n     uint256 x1 = uint256(\"0xABCDEF123abcdef12345678909832180000011111111\");\n     uint256 x2;\n-    LogPrintf(\"%s\\n\", x1.ToString().c_str());\n+    Log() << x1.ToString() << \"\\n\";\n     for (int i = 0; i < 270; i += 4)\n     {\n         x2 = x1 << i;\n-        LogPrintf(\"%s\\n\", x2.ToString().c_str());\n+        Log() << x2.ToString() << \"\\n\";\n     }\n \n-    LogPrintf(\"\\n\");\n-    LogPrintf(\"%s\\n\", x1.ToString().c_str());\n+    Log(\"\\n\");\n+    Log() << x1.ToString() << \"\\n\";\n     for (int i = 0; i < 270; i += 4)\n     {\n         x2 = x1;\n         x2 >>= i;\n-        LogPrintf(\"%s\\n\", x2.ToString().c_str());\n+        Log() << x2.ToString() << \"\\n\";\n     }\n \n \n     for (int i = 0; i < 100; i++)\n     {\n         uint256 k = (~uint256(0) >> i);\n-        LogPrintf(\"%s\\n\", k.ToString().c_str());\n+        Log() << k.ToString() << \"\\n\";\n     }\n \n     for (int i = 0; i < 100; i++)\n     {\n         uint256 k = (~uint256(0) << i);\n-        LogPrintf(\"%s\\n\", k.ToString().c_str());\n+        Log() << k.ToString() << \"\\n\";\n     }\n \n     return (0);"
      },
      {
        "sha": "e5c5111d10bc950a92b44785639bbd26fec105a9",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 50,
        "deletions": 255,
        "changes": 305,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -5,13 +5,18 @@\n \n #include \"util.h\"\n \n+#include \"bitcointime.h\"\n #include \"chainparams.h\"\n #include \"netbase.h\"\n #include \"sync.h\"\n+#include \"time.h\"\n #include \"ui_interface.h\"\n #include \"uint256.h\"\n #include \"version.h\"\n \n+#include <iomanip>\n+#include <ios>\n+#include <iostream>\n #include <stdarg.h>\n \n #ifndef WIN32\n@@ -86,15 +91,10 @@ using namespace std;\n \n map<string, string> mapArgs;\n map<string, vector<string> > mapMultiArgs;\n-bool fDebug = false;\n-bool fPrintToConsole = false;\n-bool fPrintToDebugger = false;\n bool fDaemon = false;\n bool fServer = false;\n string strMiscWarning;\n bool fNoListen = false;\n-bool fLogTimestamps = false;\n-volatile bool fReopenDebugLog = false;\n CClientUIInterface uiInterface;\n \n // Init OpenSSL library multithreading support\n@@ -160,9 +160,9 @@ void RandAddSeedPerfmon()\n \n     // This can take up to 2 seconds, so only do it every 10 minutes\n     static int64_t nLastPerfmon;\n-    if (GetTime() < nLastPerfmon + 10 * 60)\n+    if (BitcoinTime::GetTime() < nLastPerfmon + 10 * 60)\n         return;\n-    nLastPerfmon = GetTime();\n+    nLastPerfmon = BitcoinTime::GetTime();\n \n #ifdef WIN32\n     // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n@@ -176,7 +176,7 @@ void RandAddSeedPerfmon()\n     {\n         RAND_add(pdata, nSize, nSize/100.0);\n         OPENSSL_cleanse(pdata, nSize);\n-        LogPrint(\"rand\", \"RandAddSeed() %lu bytes\\n\", nSize);\n+        Log(\"rand\") << \"RandAddSeed() \" << nSize << \" bytes\\n\";\n     }\n #endif\n }\n@@ -208,178 +208,6 @@ uint256 GetRandHash()\n     return hash;\n }\n \n-// LogPrintf() has been broken a couple of times now\n-// by well-meaning people adding mutexes in the most straightforward way.\n-// It breaks because it may be called by global destructors during shutdown.\n-// Since the order of destruction of static/global objects is undefined,\n-// defining a mutex as a global object doesn't work (the mutex gets\n-// destroyed, and then some later destructor calls OutputDebugStringF,\n-// maybe indirectly, and you get a core dump at shutdown trying to lock\n-// the mutex).\n-\n-static boost::once_flag debugPrintInitFlag = BOOST_ONCE_INIT;\n-// We use boost::call_once() to make sure these are initialized in\n-// in a thread-safe manner the first time it is called:\n-static FILE* fileout = NULL;\n-static boost::mutex* mutexDebugLog = NULL;\n-\n-static void DebugPrintInit()\n-{\n-    assert(fileout == NULL);\n-    assert(mutexDebugLog == NULL);\n-\n-    boost::filesystem::path pathDebug = GetDataDir() / \"debug.log\";\n-    fileout = fopen(pathDebug.string().c_str(), \"a\");\n-    if (fileout) setbuf(fileout, NULL); // unbuffered\n-\n-    mutexDebugLog = new boost::mutex();\n-}\n-\n-int LogPrint(const char* category, const char* pszFormat, ...)\n-{\n-    if (category != NULL)\n-    {\n-        if (!fDebug)\n-            return 0;\n-\n-        const vector<string>& categories = mapMultiArgs[\"-debug\"];\n-        bool allCategories = count(categories.begin(), categories.end(), string(\"\"));\n-\n-        // Only look for categories, if not -debug/-debug=1 was passed,\n-        // as that implies every category should be logged.\n-        if (!allCategories)\n-        {\n-            // Category was not found (not supplied via -debug=<category>)\n-            if (find(categories.begin(), categories.end(), string(category)) == categories.end())\n-                return 0;\n-        }\n-    }\n-\n-    int ret = 0; // Returns total number of characters written\n-    if (fPrintToConsole)\n-    {\n-        // print to console\n-        va_list arg_ptr;\n-        va_start(arg_ptr, pszFormat);\n-        ret += vprintf(pszFormat, arg_ptr);\n-        va_end(arg_ptr);\n-    }\n-    else if (!fPrintToDebugger)\n-    {\n-        static bool fStartedNewLine = true;\n-        boost::call_once(&DebugPrintInit, debugPrintInitFlag);\n-\n-        if (fileout == NULL)\n-            return ret;\n-\n-        boost::mutex::scoped_lock scoped_lock(*mutexDebugLog);\n-\n-        // reopen the log file, if requested\n-        if (fReopenDebugLog) {\n-            fReopenDebugLog = false;\n-            boost::filesystem::path pathDebug = GetDataDir() / \"debug.log\";\n-            if (freopen(pathDebug.string().c_str(),\"a\",fileout) != NULL)\n-                setbuf(fileout, NULL); // unbuffered\n-        }\n-\n-        // Debug print useful for profiling\n-        if (fLogTimestamps && fStartedNewLine)\n-            ret += fprintf(fileout, \"%s \", DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", GetTime()).c_str());\n-        if (pszFormat[strlen(pszFormat) - 1] == '\\n')\n-            fStartedNewLine = true;\n-        else\n-            fStartedNewLine = false;\n-\n-        va_list arg_ptr;\n-        va_start(arg_ptr, pszFormat);\n-        ret += vfprintf(fileout, pszFormat, arg_ptr);\n-        va_end(arg_ptr);\n-    }\n-\n-#ifdef WIN32\n-    if (fPrintToDebugger)\n-    {\n-        static CCriticalSection cs_OutputDebugStringF;\n-\n-        // accumulate and output a line at a time\n-        {\n-            LOCK(cs_OutputDebugStringF);\n-            static std::string buffer;\n-\n-            va_list arg_ptr;\n-            va_start(arg_ptr, pszFormat);\n-            buffer += vstrprintf(pszFormat, arg_ptr);\n-            va_end(arg_ptr);\n-\n-            int line_start = 0, line_end;\n-            while((line_end = buffer.find('\\n', line_start)) != -1)\n-            {\n-                OutputDebugStringA(buffer.substr(line_start, line_end - line_start).c_str());\n-                line_start = line_end + 1;\n-                ret += line_end-line_start;\n-            }\n-            buffer.erase(0, line_start);\n-        }\n-    }\n-#endif\n-    return ret;\n-}\n-\n-string vstrprintf(const char *format, va_list ap)\n-{\n-    char buffer[50000];\n-    char* p = buffer;\n-    int limit = sizeof(buffer);\n-    int ret;\n-    while (true)\n-    {\n-        va_list arg_ptr;\n-        va_copy(arg_ptr, ap);\n-        ret = vsnprintf(p, limit, format, arg_ptr);\n-        va_end(arg_ptr);\n-        if (ret >= 0 && ret < limit)\n-            break;\n-        if (p != buffer)\n-            delete[] p;\n-        limit *= 2;\n-        p = new char[limit];\n-        if (p == NULL)\n-            throw std::bad_alloc();\n-    }\n-    string str(p, p+ret);\n-    if (p != buffer)\n-        delete[] p;\n-    return str;\n-}\n-\n-string real_strprintf(const char *format, int dummy, ...)\n-{\n-    va_list arg_ptr;\n-    va_start(arg_ptr, dummy);\n-    string str = vstrprintf(format, arg_ptr);\n-    va_end(arg_ptr);\n-    return str;\n-}\n-\n-string real_strprintf(const std::string &format, int dummy, ...)\n-{\n-    va_list arg_ptr;\n-    va_start(arg_ptr, dummy);\n-    string str = vstrprintf(format.c_str(), arg_ptr);\n-    va_end(arg_ptr);\n-    return str;\n-}\n-\n-bool error(const char *format, ...)\n-{\n-    va_list arg_ptr;\n-    va_start(arg_ptr, format);\n-    std::string str = vstrprintf(format, arg_ptr);\n-    va_end(arg_ptr);\n-    LogPrintf(\"ERROR: %s\\n\", str.c_str());\n-    return false;\n-}\n-\n \n void ParseString(const string& str, char c, vector<string>& v)\n {\n@@ -403,12 +231,13 @@ void ParseString(const string& str, char c, vector<string>& v)\n \n string FormatMoney(int64_t n, bool fPlus)\n {\n-    // Note: not using straight sprintf here because we do NOT want\n+    // Note: not using straight float formatting here because we do NOT want\n     // localized number formatting.\n     int64_t n_abs = (n > 0 ? n : -n);\n     int64_t quotient = n_abs/COIN;\n     int64_t remainder = n_abs%COIN;\n-    string str = strprintf(\"%\"PRId64\".%08\"PRId64, quotient, remainder);\n+    \n+    string str = boost::str(boost::format(\"%d.%08d\") % quotient % remainder);\n \n     // Right-trim excess zeros before the decimal point:\n     int nTrim = 0;\n@@ -463,8 +292,7 @@ bool ParseMoney(const char* pszIn, int64_t& nRet)\n         return false;\n     if (nUnits < 0 || nUnits > COIN)\n         return false;\n-    int64_t nWhole = atoi64(strWhole);\n-    int64_t nValue = nWhole*COIN + nUnits;\n+    int64_t nValue = fromstr<int64_t>(strWhole)*COIN + nUnits;\n \n     nRet = nValue;\n     return true;\n@@ -608,7 +436,7 @@ std::string GetArg(const std::string& strArg, const std::string& strDefault)\n int64_t GetArg(const std::string& strArg, int64_t nDefault)\n {\n     if (mapArgs.count(strArg))\n-        return atoi64(mapArgs[strArg]);\n+        return fromstr<int64_t>(mapArgs[strArg]);\n     return nDefault;\n }\n \n@@ -618,7 +446,7 @@ bool GetBoolArg(const std::string& strArg, bool fDefault)\n     {\n         if (mapArgs[strArg].empty())\n             return true;\n-        return (atoi(mapArgs[strArg]) != 0);\n+        return (fromstr<int>(mapArgs[strArg]) != 0);\n     }\n     return fDefault;\n }\n@@ -1012,34 +840,38 @@ static std::string FormatException(std::exception* pex, const char* pszThread)\n #else\n     const char* pszModule = \"bitcoin\";\n #endif\n+    std::ostringstream oss;\n+\n     if (pex)\n-        return strprintf(\n-            \"EXCEPTION: %s       \\n%s       \\n%s in %s       \\n\", typeid(*pex).name(), pex->what(), pszModule, pszThread);\n+        oss << \"EXCEPTION: \" << typeid(*pex).name() << \"       \\n\" << pex->what();\n     else\n-        return strprintf(\n-            \"UNKNOWN EXCEPTION       \\n%s in %s       \\n\", pszModule, pszThread);\n+        oss << \"UNKNOWN EXCEPTION\";\n+        \n+    oss << \"       \\n\" << pszModule << \" in \" << pszThread << \"\\n\";\n+\n+    return oss.str();\n }\n \n void LogException(std::exception* pex, const char* pszThread)\n {\n     std::string message = FormatException(pex, pszThread);\n-    LogPrintf(\"\\n%s\", message.c_str());\n+    Log() << \"\\n\" << message;\n }\n \n void PrintException(std::exception* pex, const char* pszThread)\n {\n     std::string message = FormatException(pex, pszThread);\n-    LogPrintf(\"\\n\\n************************\\n%s\\n\", message.c_str());\n-    fprintf(stderr, \"\\n\\n************************\\n%s\\n\", message.c_str());\n+    Log() << \"\\n\\n************************\\n\" << message << \"\\n\";\n+    std::cerr << \"\\n\\n************************\\n\" << message << \"\\n\";\n     strMiscWarning = message;\n     throw;\n }\n \n void PrintExceptionContinue(std::exception* pex, const char* pszThread)\n {\n     std::string message = FormatException(pex, pszThread);\n-    LogPrintf(\"\\n\\n************************\\n%s\\n\", message.c_str());\n-    fprintf(stderr, \"\\n\\n************************\\n%s\\n\", message.c_str());\n+    Log() << \"\\n\\n************************\\n\" << message << \"\\n\";\n+    std::cerr << \"\\n\\n************************\\n\" << message << \"\\n\";\n     strMiscWarning = message;\n }\n \n@@ -1086,7 +918,7 @@ const boost::filesystem::path &GetDataDir(bool fNetSpecific)\n \n     fs::path &path = pathCached[nNet];\n \n-    // This can be called during exceptions by LogPrintf(), so we cache the\n+    // This can be called during exceptions by Log(), so we cache the\n     // value so we don't have to do memory allocations after that.\n     if (!path.empty())\n         return path;\n@@ -1301,52 +1133,12 @@ void ShrinkDebugFile()\n }\n \n \n-\n-\n-\n-\n-\n-\n-//\n-// \"Never go to sea with two chronometers; take one or three.\"\n-// Our three time sources are:\n-//  - System clock\n-//  - Median of other nodes clocks\n-//  - The user (asking the user to fix the system clock if the first two disagree)\n-//\n-static int64_t nMockTime = 0;  // For unit testing\n-\n-int64_t GetTime()\n-{\n-    if (nMockTime) return nMockTime;\n-\n-    return time(NULL);\n-}\n-\n-void SetMockTime(int64_t nMockTimeIn)\n-{\n-    nMockTime = nMockTimeIn;\n-}\n-\n-static CCriticalSection cs_nTimeOffset;\n-static int64_t nTimeOffset = 0;\n-\n-int64_t GetTimeOffset()\n-{\n-    LOCK(cs_nTimeOffset);\n-    return nTimeOffset;\n-}\n-\n-int64_t GetAdjustedTime()\n-{\n-    return GetTime() + GetTimeOffset();\n-}\n-\n+static CCriticalSection cs_addTimeData;\n void AddTimeData(const CNetAddr& ip, int64_t nTime)\n {\n-    int64_t nOffsetSample = nTime - GetTime();\n+    int64_t nOffsetSample = nTime - BitcoinTime::GetTime();\n \n-    LOCK(cs_nTimeOffset);\n+    LOCK(cs_addTimeData);\n     // Ignore duplicates\n     static set<CNetAddr> setKnown;\n     if (!setKnown.insert(ip).second)\n@@ -1355,19 +1147,19 @@ void AddTimeData(const CNetAddr& ip, int64_t nTime)\n     // Add data\n     static CMedianFilter<int64_t> vTimeOffsets(200,0);\n     vTimeOffsets.input(nOffsetSample);\n-    LogPrintf(\"Added time data, samples %d, offset %+\"PRId64\" (%+\"PRId64\" minutes)\\n\", vTimeOffsets.size(), nOffsetSample, nOffsetSample/60);\n+    Log() << \"Added time data, samples \" << vTimeOffsets.size() << \", offset \" << showpos << nOffsetSample << \" (\" << showpos << (nOffsetSample / 60) << \" minutes)\\n\";\n     if (vTimeOffsets.size() >= 5 && vTimeOffsets.size() % 2 == 1)\n     {\n         int64_t nMedian = vTimeOffsets.median();\n         std::vector<int64_t> vSorted = vTimeOffsets.sorted();\n         // Only let other nodes change our time by so much\n         if (abs64(nMedian) < 70 * 60)\n         {\n-            nTimeOffset = nMedian;\n+            BitcoinTime::SetTimeOffset(nMedian);\n         }\n         else\n         {\n-            nTimeOffset = 0;\n+            BitcoinTime::SetTimeOffset(0);\n \n             static bool fDone;\n             if (!fDone)\n@@ -1381,19 +1173,19 @@ void AddTimeData(const CNetAddr& ip, int64_t nTime)\n                 if (!fMatch)\n                 {\n                     fDone = true;\n-                    string strMessage = _(\"Warning: Please check that your computer's date and time are correct! If your clock is wrong Bitcoin will not work properly.\");\n+                    string strMessage = _<std::string>(\"Warning: Please check that your computer's date and time are correct! If your clock is wrong Bitcoin will not work properly.\");\n                     strMiscWarning = strMessage;\n-                    LogPrintf(\"*** %s\\n\", strMessage.c_str());\n+                    Log() << \"*** \" << strMessage << \"\\n\";\n                     uiInterface.ThreadSafeMessageBox(strMessage, \"\", CClientUIInterface::MSG_WARNING);\n                 }\n             }\n         }\n-        if (fDebug) {\n+        if (Log::fDebug) {\n             BOOST_FOREACH(int64_t n, vSorted)\n-                LogPrintf(\"%+\"PRId64\"  \", n);\n-            LogPrintf(\"|  \");\n+                Log() << showpos << n;\n+            Log() << \"|  \";\n         }\n-        LogPrintf(\"nTimeOffset = %+\"PRId64\"  (%+\"PRId64\" minutes)\\n\", nTimeOffset, nTimeOffset/60);\n+        Log() << \"nTimeOffset = \" << showpos << BitcoinTime::GetTimeOffset() << \"  (\" << showpos << (BitcoinTime::GetTimeOffset() / 60) << \" minutes)\\n\";\n     }\n }\n \n@@ -1420,10 +1212,13 @@ void seed_insecure_rand(bool fDeterministic)\n \n string FormatVersion(int nVersion)\n {\n-    if (nVersion%100 == 0)\n-        return strprintf(\"%d.%d.%d\", nVersion/1000000, (nVersion/10000)%100, (nVersion/100)%100);\n-    else\n-        return strprintf(\"%d.%d.%d.%d\", nVersion/1000000, (nVersion/10000)%100, (nVersion/100)%100, nVersion%100);\n+    std::ostringstream oss;\n+    oss << nVersion/1000000 << \".\" << (nVersion/10000)%100 << \".\" << (nVersion/100)%100;\n+    \n+    if (nVersion%100 != 0)\n+        oss << \".\" << nVersion%100;\n+\n+    return oss.str();\n }\n \n string FormatFullVersion()\n@@ -1455,7 +1250,7 @@ boost::filesystem::path GetSpecialFolderPath(int nFolder, bool fCreate)\n         return fs::path(pszPath);\n     }\n \n-    LogPrintf(\"SHGetSpecialFolderPathA() failed, could not obtain requested path.\\n\");\n+    Log() << \"SHGetSpecialFolderPathA() failed, could not obtain requested path.\\n\";\n     return fs::path(\"\");\n }\n #endif\n@@ -1475,7 +1270,7 @@ boost::filesystem::path GetTempPath() {\n     path = boost::filesystem::path(\"/tmp\");\n #endif\n     if (path.empty() || !boost::filesystem::is_directory(path)) {\n-        LogPrintf(\"GetTempPath(): failed to find temp path\\n\");\n+        Log() << \"GetTempPath(): failed to find temp path\\n\";\n         return boost::filesystem::path(\"\");\n     }\n     return path;\n@@ -1486,7 +1281,7 @@ void runCommand(std::string strCommand)\n {\n     int nErr = ::system(strCommand.c_str());\n     if (nErr)\n-        LogPrintf(\"runCommand error: system(%s) returned %d\\n\", strCommand.c_str(), nErr);\n+        Log() << \"runCommand error: system(\" << strCommand << \") returned \" << nErr << \"\\n\";\n }\n \n void RenameThread(const char* name)"
      },
      {
        "sha": "f65386811ba5c51f1bfaa3e6e12d2b23490b6441",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 26,
        "deletions": 113,
        "changes": 139,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -11,12 +11,13 @@\n #endif\n \n #include \"compat.h\"\n+#include \"log.h\"\n #include \"serialize.h\"\n \n #include <cstdio>\n #include <exception>\n-#include <inttypes.h>\n #include <map>\n+#include <sstream>\n #include <stdarg.h>\n #include <stdint.h>\n #include <string>\n@@ -25,11 +26,11 @@\n \n #ifndef WIN32\n #include <sys/resource.h>\n-#include <sys/time.h>\n #include <sys/types.h>\n #endif\n \n #include <boost/filesystem/path.hpp>\n+#include <boost/format.hpp>\n #include <boost/thread.hpp>\n \n class CNetAddr;\n@@ -44,14 +45,6 @@ static const int64_t CENT = 1000000;\n #define UEND(a)             ((unsigned char*)&((&(a))[1]))\n #define ARRAYLEN(array)     (sizeof(array)/sizeof((array)[0]))\n \n-/* Format characters for (s)size_t and ptrdiff_t (C99 standard) */\n-#define PRIszx    \"zx\"\n-#define PRIszu    \"zu\"\n-#define PRIszd    \"zd\"\n-#define PRIpdx    \"tx\"\n-#define PRIpdu    \"tu\"\n-#define PRIpdd    \"td\"\n-\n // This is needed because the foreach macro can't get over the comma in pair<t1, t2>\n #define PAIRTYPE(t1, t2)    std::pair<t1, t2>\n \n@@ -99,60 +92,21 @@ inline void MilliSleep(int64_t n)\n #endif\n }\n \n-/* This GNU C extension enables the compiler to check the format string against the parameters provided.\n- * X is the number of the \"format string\" parameter, and Y is the number of the first variadic parameter.\n- * Parameters count from 1.\n- */\n-#ifdef __GNUC__\n-#define ATTR_WARN_PRINTF(X,Y) __attribute__((format(gnu_printf,X,Y)))\n-#else\n-#define ATTR_WARN_PRINTF(X,Y)\n-#endif\n-\n-\n-\n \n \n \n \n \n extern std::map<std::string, std::string> mapArgs;\n extern std::map<std::string, std::vector<std::string> > mapMultiArgs;\n-extern bool fDebug;\n-extern bool fPrintToConsole;\n-extern bool fPrintToDebugger;\n extern bool fDaemon;\n extern bool fServer;\n extern std::string strMiscWarning;\n extern bool fNoListen;\n-extern bool fLogTimestamps;\n-extern volatile bool fReopenDebugLog;\n \n void RandAddSeed();\n void RandAddSeedPerfmon();\n \n-// Print to debug.log if -debug=category switch is given OR category is NULL.\n-int ATTR_WARN_PRINTF(2,3) LogPrint(const char* category, const char* pszFormat, ...);\n-#define LogPrintf(...) LogPrint(NULL, __VA_ARGS__)\n-\n-/*\n-  Rationale for the real_strprintf / strprintf construction:\n-    It is not allowed to use va_start with a pass-by-reference argument.\n-    (C++ standard, 18.7, paragraph 3). Use a dummy argument to work around this, and use a\n-    macro to keep similar semantics.\n-*/\n-\n-/** Overload strprintf for char*, so that GCC format type warnings can be given */\n-std::string ATTR_WARN_PRINTF(1,3) real_strprintf(const char *format, int dummy, ...);\n-/** Overload strprintf for std::string, to be able to use it with _ (translation).\n- * This will not support GCC format type warnings (-Wformat) so be careful.\n- */\n-std::string real_strprintf(const std::string &format, int dummy, ...);\n-#define strprintf(format, ...) real_strprintf(format, 0, __VA_ARGS__)\n-std::string vstrprintf(const char *format, va_list ap);\n-\n-bool ATTR_WARN_PRINTF(1,2) error(const char *format, ...);\n-\n void LogException(std::exception* pex, const char* pszThread);\n void PrintException(std::exception* pex, const char* pszThread);\n void PrintExceptionContinue(std::exception* pex, const char* pszThread);\n@@ -197,10 +151,6 @@ void ShrinkDebugFile();\n int GetRandInt(int nMax);\n uint64_t GetRand(uint64_t nMax);\n uint256 GetRandHash();\n-int64_t GetTime();\n-void SetMockTime(int64_t nMockTimeIn);\n-int64_t GetAdjustedTime();\n-int64_t GetTimeOffset();\n std::string FormatFullVersion();\n std::string FormatSubVersion(const std::string& name, int nClientVersion, const std::vector<std::string>& comments);\n void AddTimeData(const CNetAddr& ip, int64_t nTime);\n@@ -213,38 +163,20 @@ void runCommand(std::string strCommand);\n \n \n \n-\n-inline std::string i64tostr(int64_t n)\n-{\n-    return strprintf(\"%\"PRId64, n);\n-}\n-\n-inline std::string itostr(int n)\n-{\n-    return strprintf(\"%d\", n);\n-}\n-\n-inline int64_t atoi64(const char* psz)\n-{\n-#ifdef _MSC_VER\n-    return _atoi64(psz);\n-#else\n-    return strtoll(psz, NULL, 10);\n-#endif\n-}\n-\n-inline int64_t atoi64(const std::string& str)\n+template<typename T>\n+inline std::string tostr(const T n)\n {\n-#ifdef _MSC_VER\n-    return _atoi64(str.c_str());\n-#else\n-    return strtoll(str.c_str(), NULL, 10);\n-#endif\n+    std::ostringstream oss;\n+    oss << n;\n+    return oss.str();\n }\n \n-inline int atoi(const std::string& str)\n+template<typename T>\n+inline T fromstr(const std::string& str)\n {\n-    return atoi(str.c_str());\n+    T tTemp = T();\n+    std::istringstream(str) >> tTemp;\n+    return tTemp;\n }\n \n inline int roundint(double d)\n@@ -290,12 +222,12 @@ inline std::string HexStr(const T& vch, bool fSpaces=false)\n template<typename T>\n void PrintHex(const T pbegin, const T pend, const char* pszFormat=\"%s\", bool fSpaces=true)\n {\n-    LogPrintf(pszFormat, HexStr(pbegin, pend, fSpaces).c_str());\n+    Log() << HexStr(pbegin, pend, fSpaces);\n }\n \n inline void PrintHex(const std::vector<unsigned char>& vch, const char* pszFormat=\"%s\", bool fSpaces=true)\n {\n-    LogPrintf(pszFormat, HexStr(vch, fSpaces).c_str());\n+    Log() << HexStr(vch, fSpaces);\n }\n \n inline int64_t GetPerformanceCounter()\n@@ -311,27 +243,6 @@ inline int64_t GetPerformanceCounter()\n     return nCounter;\n }\n \n-inline int64_t GetTimeMillis()\n-{\n-    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n-            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n-}\n-\n-inline int64_t GetTimeMicros()\n-{\n-    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n-            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_microseconds();\n-}\n-\n-inline std::string DateTimeStrFormat(const char* pszFormat, int64_t nTime)\n-{\n-    time_t n = nTime;\n-    struct tm* ptmTime = gmtime(&n);\n-    char pszTime[200];\n-    strftime(pszTime, sizeof(pszTime), pszFormat, ptmTime);\n-    return pszTime;\n-}\n-\n template<typename T>\n void skipspaces(T& it)\n {\n@@ -531,9 +442,10 @@ inline uint32_t ByteReverse(uint32_t value)\n //    threadGroup.create_thread(boost::bind(&LoopForever<boost::function<void()> >, \"nothing\", f, milliseconds));\n template <typename Callable> void LoopForever(const char* name,  Callable func, int64_t msecs)\n {\n-    std::string s = strprintf(\"bitcoin-%s\", name);\n-    RenameThread(s.c_str());\n-    LogPrintf(\"%s thread start\\n\", name);\n+    std::string strNameVersion = boost::str(boost::format(\"bitcoin-%s\") % name);\n+\n+    RenameThread(strNameVersion.c_str());\n+    Log() << name << \" thread start\\n\";\n     try\n     {\n         while (1)\n@@ -544,7 +456,7 @@ template <typename Callable> void LoopForever(const char* name,  Callable func,\n     }\n     catch (boost::thread_interrupted)\n     {\n-        LogPrintf(\"%s thread stop\\n\", name);\n+        Log() << name << \" thread stop\\n\";\n         throw;\n     }\n     catch (std::exception& e) {\n@@ -557,17 +469,18 @@ template <typename Callable> void LoopForever(const char* name,  Callable func,\n // .. and a wrapper that just calls func once\n template <typename Callable> void TraceThread(const char* name,  Callable func)\n {\n-    std::string s = strprintf(\"bitcoin-%s\", name);\n-    RenameThread(s.c_str());\n+    std::string strNameVersion = boost::str(boost::format(\"bitcoin-%s\") % name);\n+\n+    RenameThread(strNameVersion.c_str());\n     try\n     {\n-        LogPrintf(\"%s thread start\\n\", name);\n+        Log() << name << \" thread start\\n\";\n         func();\n-        LogPrintf(\"%s thread exit\\n\", name);\n+        Log() << name << \" thread exit\\n\";\n     }\n     catch (boost::thread_interrupted)\n     {\n-        LogPrintf(\"%s thread interrupt\\n\", name);\n+        Log() << name << \" thread interrupt\\n\";\n         throw;\n     }\n     catch (std::exception& e) {"
      },
      {
        "sha": "537475e731dbb4e7349580864121c446fd0bed08",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 50,
        "deletions": 52,
        "changes": 102,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -6,10 +6,11 @@\n #include \"wallet.h\"\n \n #include \"base58.h\"\n+#include \"bitcointime.h\"\n #include \"coincontrol.h\"\n #include \"net.h\"\n \n-#include <inttypes.h>\n+#include <stdint.h>\n \n #include <boost/algorithm/string/replace.hpp>\n #include <openssl/rand.h>\n@@ -46,7 +47,7 @@ CPubKey CWallet::GenerateNewKey()\n     CPubKey pubkey = secret.GetPubKey();\n \n     // Create new metadata\n-    int64_t nCreationTime = GetTime();\n+    int64_t nCreationTime = BitcoinTime::GetTime();\n     mapKeyMetadata[pubkey.GetID()] = CKeyMetadata(nCreationTime);\n     if (!nTimeFirstKey || nCreationTime < nTimeFirstKey)\n         nTimeFirstKey = nCreationTime;\n@@ -152,18 +153,18 @@ bool CWallet::ChangeWalletPassphrase(const SecureString& strOldWalletPassphrase,\n                 return false;\n             if (CCryptoKeyStore::Unlock(vMasterKey))\n             {\n-                int64_t nStartTime = GetTimeMillis();\n+                int64_t nStartTime = BitcoinTime::GetTimeMillis();\n                 crypter.SetKeyFromPassphrase(strNewWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod);\n-                pMasterKey.second.nDeriveIterations = pMasterKey.second.nDeriveIterations * (100 / ((double)(GetTimeMillis() - nStartTime)));\n+                pMasterKey.second.nDeriveIterations = pMasterKey.second.nDeriveIterations * (100 / ((double)(BitcoinTime::GetTimeMillis() - nStartTime)));\n \n-                nStartTime = GetTimeMillis();\n+                nStartTime = BitcoinTime::GetTimeMillis();\n                 crypter.SetKeyFromPassphrase(strNewWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod);\n-                pMasterKey.second.nDeriveIterations = (pMasterKey.second.nDeriveIterations + pMasterKey.second.nDeriveIterations * 100 / ((double)(GetTimeMillis() - nStartTime))) / 2;\n+                pMasterKey.second.nDeriveIterations = (pMasterKey.second.nDeriveIterations + pMasterKey.second.nDeriveIterations * 100 / ((double)(BitcoinTime::GetTimeMillis() - nStartTime))) / 2;\n \n                 if (pMasterKey.second.nDeriveIterations < 25000)\n                     pMasterKey.second.nDeriveIterations = 25000;\n \n-                LogPrintf(\"Wallet passphrase changed to an nDeriveIterations of %i\\n\", pMasterKey.second.nDeriveIterations);\n+                Log() << \"Wallet passphrase changed to an nDeriveIterations of \" << pMasterKey.second.nDeriveIterations << \"\\n\";\n \n                 if (!crypter.SetKeyFromPassphrase(strNewWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod))\n                     return false;\n@@ -260,18 +261,18 @@ bool CWallet::EncryptWallet(const SecureString& strWalletPassphrase)\n     RAND_bytes(&kMasterKey.vchSalt[0], WALLET_CRYPTO_SALT_SIZE);\n \n     CCrypter crypter;\n-    int64_t nStartTime = GetTimeMillis();\n+    int64_t nStartTime = BitcoinTime::GetTimeMillis();\n     crypter.SetKeyFromPassphrase(strWalletPassphrase, kMasterKey.vchSalt, 25000, kMasterKey.nDerivationMethod);\n-    kMasterKey.nDeriveIterations = 2500000 / ((double)(GetTimeMillis() - nStartTime));\n+    kMasterKey.nDeriveIterations = 2500000 / ((double)(BitcoinTime::GetTimeMillis() - nStartTime));\n \n-    nStartTime = GetTimeMillis();\n+    nStartTime = BitcoinTime::GetTimeMillis();\n     crypter.SetKeyFromPassphrase(strWalletPassphrase, kMasterKey.vchSalt, kMasterKey.nDeriveIterations, kMasterKey.nDerivationMethod);\n-    kMasterKey.nDeriveIterations = (kMasterKey.nDeriveIterations + kMasterKey.nDeriveIterations * 100 / ((double)(GetTimeMillis() - nStartTime))) / 2;\n+    kMasterKey.nDeriveIterations = (kMasterKey.nDeriveIterations + kMasterKey.nDeriveIterations * 100 / ((double)(BitcoinTime::GetTimeMillis() - nStartTime))) / 2;\n \n     if (kMasterKey.nDeriveIterations < 25000)\n         kMasterKey.nDeriveIterations = 25000;\n \n-    LogPrintf(\"Encrypting Wallet with an nDeriveIterations of %i\\n\", kMasterKey.nDeriveIterations);\n+    Log() << \"Encrypting Wallet with an nDeriveIterations of \" << kMasterKey.nDeriveIterations << \"\\n\";\n \n     if (!crypter.SetKeyFromPassphrase(strWalletPassphrase, kMasterKey.vchSalt, kMasterKey.nDeriveIterations, kMasterKey.nDerivationMethod))\n         return false;\n@@ -372,10 +373,10 @@ void CWallet::WalletUpdateSpent(const CTransaction &tx)\n             {\n                 CWalletTx& wtx = (*mi).second;\n                 if (txin.prevout.n >= wtx.vout.size())\n-                    LogPrintf(\"WalletUpdateSpent: bad wtx %s\\n\", wtx.GetHash().ToString().c_str());\n+                    Log() << \"WalletUpdateSpent: bad wtx \" << wtx.GetHash().ToString() << \"\\n\";\n                 else if (!wtx.IsSpent(txin.prevout.n) && IsMine(wtx.vout[txin.prevout.n]))\n                 {\n-                    LogPrintf(\"WalletUpdateSpent found spent coin %sbc %s\\n\", FormatMoney(wtx.GetCredit()).c_str(), wtx.GetHash().ToString().c_str());\n+                    Log() << \"WalletUpdateSpent found spent coin \" << FormatMoney(wtx.GetCredit()) << \"bc \" << wtx.GetHash().ToString() << \"\\n\";\n                     wtx.MarkSpent(txin.prevout.n);\n                     wtx.WriteToDisk();\n                     NotifyTransactionChanged(this, txin.prevout.hash, CT_UPDATED);\n@@ -406,7 +407,7 @@ bool CWallet::AddToWallet(const CWalletTx& wtxIn)\n         bool fInsertedNew = ret.second;\n         if (fInsertedNew)\n         {\n-            wtx.nTimeReceived = GetAdjustedTime();\n+            wtx.nTimeReceived = BitcoinTime::GetAdjustedTime();\n             wtx.nOrderPos = IncOrderPosNext();\n \n             wtx.nTimeSmart = wtx.nTimeReceived;\n@@ -450,9 +451,7 @@ bool CWallet::AddToWallet(const CWalletTx& wtxIn)\n                     wtx.nTimeSmart = std::max(latestEntry, std::min(blocktime, latestNow));\n                 }\n                 else\n-                    LogPrintf(\"AddToWallet() : found %s in block %s not in index\\n\",\n-                             wtxIn.GetHash().ToString().c_str(),\n-                             wtxIn.hashBlock.ToString().c_str());\n+                    Log() << \"AddToWallet() : found \" << wtxIn.GetHash().ToString() << \" in block \" << wtxIn.hashBlock.ToString() << \" not in index\\n\";\n             }\n         }\n \n@@ -480,7 +479,7 @@ bool CWallet::AddToWallet(const CWalletTx& wtxIn)\n         }\n \n         //// debug print\n-        LogPrintf(\"AddToWallet %s  %s%s\\n\", wtxIn.GetHash().ToString().c_str(), (fInsertedNew ? \"new\" : \"\"), (fUpdated ? \"update\" : \"\"));\n+        Log() << \"AddToWallet \" << wtxIn.GetHash().ToString() << \"  \" << (fInsertedNew ? \"new\" : \"\") << (fUpdated ? \"update\" : \"\") << \"\\n\";\n \n         // Write to disk\n         if (fInsertedNew || fUpdated)\n@@ -680,8 +679,7 @@ void CWalletTx::GetAmounts(list<pair<CTxDestination, int64_t> >& listReceived,\n         CTxDestination address;\n         if (!ExtractDestination(txout.scriptPubKey, address))\n         {\n-            LogPrintf(\"CWalletTx::GetAmounts: Unknown transaction type found, txid %s\\n\",\n-                     this->GetHash().ToString().c_str());\n+            Log() << \"CWalletTx::GetAmounts: Unknown transaction type found, txid \" << this->GetHash().ToString() << \"\\n\";\n             address = CNoDestination();\n         }\n \n@@ -874,7 +872,7 @@ void CWallet::ReacceptWalletTransactions()\n                 }\n                 if (fUpdated)\n                 {\n-                    LogPrintf(\"ReacceptWalletTransactions found spent coin %sbc %s\\n\", FormatMoney(wtx.GetCredit()).c_str(), wtx.GetHash().ToString().c_str());\n+                    Log() << \"ReacceptWalletTransactions found spent coin \" << FormatMoney(wtx.GetCredit()) << \"bc \" << wtx.GetHash().ToString() << \"\\n\";\n                     wtx.MarkDirty();\n                     wtx.WriteToDisk();\n                 }\n@@ -910,7 +908,7 @@ void CWalletTx::RelayWalletTransaction()\n     {\n         if (GetDepthInMainChain() == 0) {\n             uint256 hash = GetHash();\n-            LogPrintf(\"Relaying wtx %s\\n\", hash.ToString().c_str());\n+            Log() << \"Relaying wtx \" << hash.ToString() << \"\\n\";\n             RelayTransaction((CTransaction)*this, hash);\n         }\n     }\n@@ -920,20 +918,20 @@ void CWallet::ResendWalletTransactions()\n {\n     // Do this infrequently and randomly to avoid giving away\n     // that these are our transactions.\n-    if (GetTime() < nNextResend)\n+    if (BitcoinTime::GetTime() < nNextResend)\n         return;\n     bool fFirst = (nNextResend == 0);\n-    nNextResend = GetTime() + GetRand(30 * 60);\n+    nNextResend = BitcoinTime::GetTime() + GetRand(30 * 60);\n     if (fFirst)\n         return;\n \n     // Only do it if there's been a new block since last time\n     if (nTimeBestReceived < nLastResend)\n         return;\n-    nLastResend = GetTime();\n+    nLastResend = BitcoinTime::GetTime();\n \n     // Rebroadcast any of our txes that aren't in a block yet\n-    LogPrintf(\"ResendWalletTransactions()\\n\");\n+    Log() << \"ResendWalletTransactions()\\n\";\n     {\n         LOCK(cs_wallet);\n         // Sort them in chronological order\n@@ -1174,11 +1172,11 @@ bool CWallet::SelectCoinsMinConf(int64_t nTargetValue, int nConfMine, int nConfT\n                 nValueRet += vValue[i].first;\n             }\n \n-        LogPrint(\"selectcoins\", \"SelectCoins() best subset: \");\n+        Log(\"selectcoins\") << \"SelectCoins() best subset: \";\n         for (unsigned int i = 0; i < vValue.size(); i++)\n             if (vfBest[i])\n-                LogPrint(\"selectcoins\", \"%s \", FormatMoney(vValue[i].first).c_str());\n-        LogPrint(\"selectcoins\", \"total %s\\n\", FormatMoney(nBest).c_str());\n+                Log(\"selectcoins\") <<  FormatMoney(vValue[i].first) << \" \";\n+        Log(\"selectcoins\") << \"total \" << FormatMoney(nBest) << \"\\n\";\n     }\n \n     return true;\n@@ -1216,14 +1214,14 @@ bool CWallet::CreateTransaction(const vector<pair<CScript, int64_t> >& vecSend,\n     {\n         if (nValue < 0)\n         {\n-            strFailReason = _(\"Transaction amounts must be positive\");\n+            strFailReason = _<string>(\"Transaction amounts must be positive\");\n             return false;\n         }\n         nValue += s.second;\n     }\n     if (vecSend.empty() || nValue < 0)\n     {\n-        strFailReason = _(\"Transaction amounts must be positive\");\n+        strFailReason = _<string>(\"Transaction amounts must be positive\");\n         return false;\n     }\n \n@@ -1247,7 +1245,7 @@ bool CWallet::CreateTransaction(const vector<pair<CScript, int64_t> >& vecSend,\n                     CTxOut txout(s.second, s.first);\n                     if (txout.IsDust(CTransaction::nMinRelayTxFee))\n                     {\n-                        strFailReason = _(\"Transaction amount too small\");\n+                        strFailReason = _<string>(\"Transaction amount too small\");\n                         return false;\n                     }\n                     wtxNew.vout.push_back(txout);\n@@ -1258,7 +1256,7 @@ bool CWallet::CreateTransaction(const vector<pair<CScript, int64_t> >& vecSend,\n                 int64_t nValueIn = 0;\n                 if (!SelectCoins(nTotalValue, setCoins, nValueIn, coinControl))\n                 {\n-                    strFailReason = _(\"Insufficient funds\");\n+                    strFailReason = _<string>(\"Insufficient funds\");\n                     return false;\n                 }\n                 BOOST_FOREACH(PAIRTYPE(const CWalletTx*, unsigned int) pcoin, setCoins)\n@@ -1340,15 +1338,15 @@ bool CWallet::CreateTransaction(const vector<pair<CScript, int64_t> >& vecSend,\n                 BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)& coin, setCoins)\n                     if (!SignSignature(*this, *coin.first, wtxNew, nIn++))\n                     {\n-                        strFailReason = _(\"Signing transaction failed\");\n+                        strFailReason = _<string>(\"Signing transaction failed\");\n                         return false;\n                     }\n \n                 // Limit size\n                 unsigned int nBytes = ::GetSerializeSize(*(CTransaction*)&wtxNew, SER_NETWORK, PROTOCOL_VERSION);\n                 if (nBytes >= MAX_STANDARD_TX_SIZE)\n                 {\n-                    strFailReason = _(\"Transaction too large\");\n+                    strFailReason = _<string>(\"Transaction too large\");\n                     return false;\n                 }\n                 dPriority = wtxNew.ComputePriority(dPriority, nBytes);\n@@ -1387,7 +1385,7 @@ bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n {\n     {\n         LOCK2(cs_main, cs_wallet);\n-        LogPrintf(\"CommitTransaction:\\n%s\", wtxNew.ToString().c_str());\n+        Log() << \"CommitTransaction:\\n\" << wtxNew.ToString();\n         {\n             // This is only to keep the database open to defeat the auto-flush for the\n             // duration of this scope.  This is the only place where this optimization\n@@ -1423,7 +1421,7 @@ bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n         if (!wtxNew.AcceptToMemoryPool(false))\n         {\n             // This must not fail. The transaction has already been signed and recorded.\n-            LogPrintf(\"CommitTransaction() : Error: Transaction not valid\");\n+            Log() << \"CommitTransaction() : Error: Transaction not valid\";\n             return false;\n         }\n         wtxNew.RelayWalletTransaction();\n@@ -1441,24 +1439,24 @@ string CWallet::SendMoney(CScript scriptPubKey, int64_t nValue, CWalletTx& wtxNe\n \n     if (IsLocked())\n     {\n-        string strError = _(\"Error: Wallet locked, unable to create transaction!\");\n-        LogPrintf(\"SendMoney() : %s\", strError.c_str());\n+        string strError = _<string>(\"Error: Wallet locked, unable to create transaction!\");\n+        Log() << \"SendMoney() : \" << strError;\n         return strError;\n     }\n     string strError;\n     if (!CreateTransaction(scriptPubKey, nValue, wtxNew, reservekey, nFeeRequired, strError))\n     {\n         if (nValue + nFeeRequired > GetBalance())\n-            strError = strprintf(_(\"Error: This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds!\"), FormatMoney(nFeeRequired).c_str());\n-        LogPrintf(\"SendMoney() : %s\\n\", strError.c_str());\n+            strError = str(_(\"Error: This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds!\") % FormatMoney(nFeeRequired));\n+        Log() << \"SendMoney() : \" << strError << \"\\n\";\n         return strError;\n     }\n \n     if (fAskFee && !uiInterface.ThreadSafeAskFee(nFeeRequired))\n         return \"ABORTED\";\n \n     if (!CommitTransaction(wtxNew, reservekey))\n-        return _(\"Error: The transaction was rejected! This might happen if some of the coins in your wallet were already spent, such as if you used a copy of wallet.dat and coins were spent in the copy but not marked as spent here.\");\n+        return _<string>(\"Error: The transaction was rejected! This might happen if some of the coins in your wallet were already spent, such as if you used a copy of wallet.dat and coins were spent in the copy but not marked as spent here.\");\n \n     return \"\";\n }\n@@ -1469,9 +1467,9 @@ string CWallet::SendMoneyToDestination(const CTxDestination& address, int64_t nV\n {\n     // Check amount\n     if (nValue <= 0)\n-        return _(\"Invalid amount\");\n+        return _<string>(\"Invalid amount\");\n     if (nValue + nTransactionFee > GetBalance())\n-        return _(\"Insufficient funds\");\n+        return _<string>(\"Insufficient funds\");\n \n     // Parse Bitcoin address\n     CScript scriptPubKey;\n@@ -1568,7 +1566,7 @@ bool CWallet::NewKeyPool()\n             walletdb.WritePool(nIndex, CKeyPool(GenerateNewKey()));\n             setKeyPool.insert(nIndex);\n         }\n-        LogPrintf(\"CWallet::NewKeyPool wrote %\"PRId64\" new keys\\n\", nKeys);\n+        Log() << \"CWallet::NewKeyPool wrote \" << nKeys << \" new keys\\n\";\n     }\n     return true;\n }\n@@ -1598,7 +1596,7 @@ bool CWallet::TopUpKeyPool(unsigned int kpSize)\n             if (!walletdb.WritePool(nEnd, CKeyPool(GenerateNewKey())))\n                 throw runtime_error(\"TopUpKeyPool() : writing generated key failed\");\n             setKeyPool.insert(nEnd);\n-            LogPrintf(\"keypool added key %\"PRId64\", size=%\"PRIszu\"\\n\", nEnd, setKeyPool.size());\n+            Log() << \"keypool added key \" << nEnd << \", size=\" << setKeyPool.size() << \"\\n\";\n         }\n     }\n     return true;\n@@ -1627,7 +1625,7 @@ void CWallet::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool)\n         if (!HaveKey(keypool.vchPubKey.GetID()))\n             throw runtime_error(\"ReserveKeyFromKeyPool() : unknown key in key pool\");\n         assert(keypool.vchPubKey.IsValid());\n-        LogPrintf(\"keypool reserve %\"PRId64\"\\n\", nIndex);\n+        Log() << \"keypool reserve \" << nIndex << \"\\n\";\n     }\n }\n \n@@ -1654,7 +1652,7 @@ void CWallet::KeepKey(int64_t nIndex)\n         CWalletDB walletdb(strWalletFile);\n         walletdb.ErasePool(nIndex);\n     }\n-    LogPrintf(\"keypool keep %\"PRId64\"\\n\", nIndex);\n+    Log() << \"keypool keep \" << nIndex << \"\\n\";\n }\n \n void CWallet::ReturnKey(int64_t nIndex)\n@@ -1664,7 +1662,7 @@ void CWallet::ReturnKey(int64_t nIndex)\n         LOCK(cs_wallet);\n         setKeyPool.insert(nIndex);\n     }\n-    LogPrintf(\"keypool return %\"PRId64\"\\n\", nIndex);\n+    Log() << \"keypool return \" << nIndex << \"\\n\";\n }\n \n bool CWallet::GetKeyFromPool(CPubKey& result)\n@@ -1692,7 +1690,7 @@ int64_t CWallet::GetOldestKeyPoolTime()\n     CKeyPool keypool;\n     ReserveKeyFromKeyPool(nIndex, keypool);\n     if (nIndex == -1)\n-        return GetTime();\n+        return BitcoinTime::GetTime();\n     ReturnKey(nIndex);\n     return keypool.nTime;\n }\n@@ -1852,7 +1850,7 @@ bool CReserveKey::GetReservedKey(CPubKey& pubkey)\n             vchPubKey = keypool.vchPubKey;\n         else {\n             if (pwallet->vchDefaultKey.IsValid()) {\n-                LogPrintf(\"CReserveKey::GetReservedKey(): Warning: Using default key instead of a new key, top up your keypool!\");\n+                Log() << \"CReserveKey::GetReservedKey(): Warning: Using default key instead of a new key, top up your keypool!\";\n                 vchPubKey = pwallet->vchDefaultKey;\n             } else\n                 return false;"
      },
      {
        "sha": "f9c4682faf65f974e1e3a73acd699e23366fda7c",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 13,
        "deletions": 9,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -5,10 +5,12 @@\n #ifndef BITCOIN_WALLET_H\n #define BITCOIN_WALLET_H\n \n+#include \"bitcointime.h\"\n #include \"core.h\"\n #include \"crypter.h\"\n #include \"key.h\"\n #include \"keystore.h\"\n+#include \"log.h\"\n #include \"main.h\"\n #include \"ui_interface.h\"\n #include \"util.h\"\n@@ -23,6 +25,8 @@\n #include <utility>\n #include <vector>\n \n+#include <boost/format.hpp>\n+\n class CAccountingEntry;\n class CCoinControl;\n class COutput;\n@@ -51,12 +55,12 @@ class CKeyPool\n \n     CKeyPool()\n     {\n-        nTime = GetTime();\n+        nTime = BitcoinTime::GetTime();\n     }\n \n     CKeyPool(const CPubKey& vchPubKeyIn)\n     {\n-        nTime = GetTime();\n+        nTime = BitcoinTime::GetTime();\n         vchPubKey = vchPubKeyIn;\n     }\n \n@@ -384,15 +388,15 @@ static void ReadOrderPos(int64_t& nOrderPos, mapValue_t& mapValue)\n         nOrderPos = -1; // TODO: calculate elsewhere\n         return;\n     }\n-    nOrderPos = atoi64(mapValue[\"n\"].c_str());\n+    nOrderPos = fromstr<int64_t>(mapValue[\"n\"]);\n }\n \n \n static void WriteOrderPos(const int64_t& nOrderPos, mapValue_t& mapValue)\n {\n     if (nOrderPos == -1)\n         return;\n-    mapValue[\"n\"] = i64tostr(nOrderPos);\n+    mapValue[\"n\"] = tostr(nOrderPos);\n }\n \n \n@@ -496,7 +500,7 @@ class CWalletTx : public CMerkleTx\n             WriteOrderPos(pthis->nOrderPos, pthis->mapValue);\n \n             if (nTimeSmart)\n-                pthis->mapValue[\"timesmart\"] = strprintf(\"%u\", nTimeSmart);\n+                pthis->mapValue[\"timesmart\"] = tostr(nTimeSmart);\n         }\n \n         nSerSize += SerReadWrite(s, *(CMerkleTx*)this, nType, nVersion,ser_action);\n@@ -520,7 +524,7 @@ class CWalletTx : public CMerkleTx\n \n             ReadOrderPos(pthis->nOrderPos, pthis->mapValue);\n \n-            pthis->nTimeSmart = mapValue.count(\"timesmart\") ? (unsigned int)atoi64(pthis->mapValue[\"timesmart\"]) : 0;\n+            pthis->nTimeSmart = mapValue.count(\"timesmart\") ? fromstr<unsigned int>(pthis->mapValue[\"timesmart\"]) : 0;\n         }\n \n         pthis->mapValue.erase(\"fromaccount\");\n@@ -742,12 +746,12 @@ class COutput\n \n     std::string ToString() const\n     {\n-        return strprintf(\"COutput(%s, %d, %d) [%s]\", tx->GetHash().ToString().c_str(), i, nDepth, FormatMoney(tx->vout[i].nValue).c_str());\n+        return boost::str(boost::format(\"COutput(%s, %d, %d) [%s]\") % tx->GetHash().ToString() % i % nDepth % FormatMoney(tx->vout[i].nValue));\n     }\n \n     void print() const\n     {\n-        LogPrintf(\"%s\\n\", ToString().c_str());\n+        Log() << ToString() << \"\\n\";\n     }\n };\n \n@@ -767,7 +771,7 @@ class CWalletKey\n \n     CWalletKey(int64_t nExpires=0)\n     {\n-        nTimeCreated = (nExpires ? GetTime() : 0);\n+        nTimeCreated = (nExpires ? BitcoinTime::GetTime() : 0);\n         nTimeExpires = nExpires;\n     }\n "
      },
      {
        "sha": "9d4343d0f3b51721706bbfac617599f08c47aaa3",
        "filename": "src/walletdb.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 34,
        "changes": 67,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e39b26c0e839dc5b2e8436da2b25816ccb1938d9/src/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/walletdb.cpp?ref=e39b26c0e839dc5b2e8436da2b25816ccb1938d9",
        "patch": "@@ -6,15 +6,19 @@\n #include \"walletdb.h\"\n \n #include \"base58.h\"\n+#include \"bitcointime.h\"\n #include \"protocol.h\"\n #include \"serialize.h\"\n #include \"sync.h\"\n #include \"wallet.h\"\n \n-#include <inttypes.h>\n+#include <iomanip>\n+#include <sstream>\n+#include <stdint.h>\n \n #include <boost/filesystem.hpp>\n #include <boost/foreach.hpp>\n+#include <boost/format.hpp>\n \n using namespace std;\n using namespace boost;\n@@ -376,13 +380,14 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n                     char fTmp;\n                     char fUnused;\n                     ssValue >> fTmp >> fUnused >> wtx.strFromAccount;\n-                    strErr = strprintf(\"LoadWallet() upgrading tx ver=%d %d '%s' %s\",\n-                                       wtx.fTimeReceivedIsTxTime, fTmp, wtx.strFromAccount.c_str(), hash.ToString().c_str());\n+\n+                    strErr = boost::str(boost::format(\"LoadWallet() upgrading tx ver=%d %d '%s' %s\") %\n+                                                      wtx.fTimeReceivedIsTxTime % fTmp % wtx.strFromAccount % hash.ToString());\n                     wtx.fTimeReceivedIsTxTime = fTmp;\n                 }\n                 else\n                 {\n-                    strErr = strprintf(\"LoadWallet() repairing tx ver=%d %s\", wtx.fTimeReceivedIsTxTime, hash.ToString().c_str());\n+                    strErr = boost::str(boost::format(\"LoadWallet() repairing tx ver=%d %s\") % wtx.fTimeReceivedIsTxTime % hash.ToString());\n                     wtx.fTimeReceivedIsTxTime = 0;\n                 }\n                 wss.vWalletUpgrade.push_back(hash);\n@@ -392,12 +397,8 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n                 wss.fAnyUnordered = true;\n \n             //// debug print\n-            //LogPrintf(\"LoadWallet  %s\\n\", wtx.GetHash().ToString().c_str());\n-            //LogPrintf(\" %12\"PRId64\"  %s  %s  %s\\n\",\n-            //    wtx.vout[0].nValue,\n-            //    DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", wtx.GetBlockTime()).c_str(),\n-            //    wtx.hashBlock.ToString().c_str(),\n-            //    wtx.mapValue[\"message\"].c_str());\n+            //Log() << \"LoadWallet  \" << wtx.GetHash().ToString() << \"\\n\", .c_str();\n+            //Log() << \" \" << setw(12) << wtx.vout[0].nValue << \"  \" << DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", wtx.GetBlockTime()) << \"  \" << wtx.hashBlock.ToString() << \"  \" << wtx.mapValue[\"message\"] << \"\\n\";\n         }\n         else if (strType == \"acentry\")\n         {\n@@ -488,7 +489,7 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n             ssValue >> kMasterKey;\n             if(pwallet->mapMasterKeys.count(nID) != 0)\n             {\n-                strErr = strprintf(\"Error reading wallet database: duplicate CMasterKey id %u\", nID);\n+                strErr = boost::str(boost::format(\"Error reading wallet database: duplicate CMasterKey id %u\") % nID);\n                 return false;\n             }\n             pwallet->mapMasterKeys[nID] = kMasterKey;\n@@ -600,7 +601,7 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n         Dbc* pcursor = GetCursor();\n         if (!pcursor)\n         {\n-            LogPrintf(\"Error getting wallet database cursor\\n\");\n+            Log() << \"Error getting wallet database cursor\\n\";\n             return DB_CORRUPT;\n         }\n \n@@ -614,7 +615,7 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n                 break;\n             else if (ret != 0)\n             {\n-                LogPrintf(\"Error reading next record from wallet database\\n\");\n+                Log() << \"Error reading next record from wallet database\\n\";\n                 return DB_CORRUPT;\n             }\n \n@@ -636,7 +637,7 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n                 }\n             }\n             if (!strErr.empty())\n-                LogPrintf(\"%s\\n\", strErr.c_str());\n+                Log() << strErr << \"\\n\";\n         }\n         pcursor->close();\n     }\n@@ -655,10 +656,8 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n     if (result != DB_LOAD_OK)\n         return result;\n \n-    LogPrintf(\"nFileVersion = %d\\n\", wss.nFileVersion);\n-\n-    LogPrintf(\"Keys: %u plaintext, %u encrypted, %u w/ metadata, %u total\\n\",\n-           wss.nKeys, wss.nCKeys, wss.nKeyMeta, wss.nKeys + wss.nCKeys);\n+    Log() << \"nFileVersion = \" << wss.nFileVersion << \"\\n\";\n+    Log() << \"Keys: \" << wss.nKeys << \" plaintext, \" << wss.nCKeys << \" encrypted, \" << wss.nKeyMeta << \" w/ metadata, \" << (wss.nKeys + wss.nCKeys) << \" total\\n\";\n \n     // nTimeFirstKey is only reliable if all keys have metadata\n     if ((wss.nKeys + wss.nCKeys) != wss.nKeyMeta)\n@@ -694,18 +693,18 @@ void ThreadFlushWalletDB(const string& strFile)\n \n     unsigned int nLastSeen = nWalletDBUpdated;\n     unsigned int nLastFlushed = nWalletDBUpdated;\n-    int64_t nLastWalletUpdate = GetTime();\n+    int64_t nLastWalletUpdate = BitcoinTime::GetTime();\n     while (true)\n     {\n         MilliSleep(500);\n \n         if (nLastSeen != nWalletDBUpdated)\n         {\n             nLastSeen = nWalletDBUpdated;\n-            nLastWalletUpdate = GetTime();\n+            nLastWalletUpdate = BitcoinTime::GetTime();\n         }\n \n-        if (nLastFlushed != nWalletDBUpdated && GetTime() - nLastWalletUpdate >= 2)\n+        if (nLastFlushed != nWalletDBUpdated && BitcoinTime::GetTime() - nLastWalletUpdate >= 2)\n         {\n             TRY_LOCK(bitdb.cs_db,lockDb);\n             if (lockDb)\n@@ -725,16 +724,16 @@ void ThreadFlushWalletDB(const string& strFile)\n                     map<string, int>::iterator mi = bitdb.mapFileUseCount.find(strFile);\n                     if (mi != bitdb.mapFileUseCount.end())\n                     {\n-                        LogPrint(\"db\", \"Flushing wallet.dat\\n\");\n+                        Log(\"db\") << \"Flushing wallet.dat\\n\";\n                         nLastFlushed = nWalletDBUpdated;\n-                        int64_t nStart = GetTimeMillis();\n+                        int64_t nStart = BitcoinTime::GetTimeMillis();\n \n                         // Flush wallet.dat so it's self contained\n                         bitdb.CloseDb(strFile);\n                         bitdb.CheckpointLSN(strFile);\n \n                         bitdb.mapFileUseCount.erase(mi++);\n-                        LogPrint(\"db\", \"Flushed wallet.dat %\"PRId64\"ms\\n\", GetTimeMillis() - nStart);\n+                        Log(\"db\") << \"Flushed wallet.dat \" << (BitcoinTime::GetTimeMillis() - nStart) << \"ms\\n\";\n                     }\n                 }\n             }\n@@ -769,10 +768,10 @@ bool BackupWallet(const CWallet& wallet, const string& strDest)\n #else\n                     filesystem::copy_file(pathSrc, pathDest);\n #endif\n-                    LogPrintf(\"copied wallet.dat to %s\\n\", pathDest.string().c_str());\n+                    Log() << \"copied wallet.dat to \" << pathDest.string() << \"\\n\";\n                     return true;\n                 } catch(const filesystem::filesystem_error &e) {\n-                    LogPrintf(\"error copying wallet.dat to %s - %s\\n\", pathDest.string().c_str(), e.what());\n+                    Log() << \"error copying wallet.dat to \" << pathDest.string() << \" - \" << e.what() << \"\\n\";\n                     return false;\n                 }\n             }\n@@ -794,27 +793,27 @@ bool CWalletDB::Recover(CDBEnv& dbenv, std::string filename, bool fOnlyKeys)\n     // Rewrite salvaged data to wallet.dat\n     // Set -rescan so any missing transactions will be\n     // found.\n-    int64_t now = GetTime();\n-    std::string newFilename = strprintf(\"wallet.%\"PRId64\".bak\", now);\n+    int64_t now = BitcoinTime::GetTime();\n+    std::string newFilename = boost::str(boost::format(\"wallet.%d.bak\") % now);\n \n     int result = dbenv.dbenv.dbrename(NULL, filename.c_str(), NULL,\n                                       newFilename.c_str(), DB_AUTO_COMMIT);\n     if (result == 0)\n-        LogPrintf(\"Renamed %s to %s\\n\", filename.c_str(), newFilename.c_str());\n+        Log() << \"Renamed \" << filename << \" to \" << newFilename << \"\\n\";\n     else\n     {\n-        LogPrintf(\"Failed to rename %s to %s\\n\", filename.c_str(), newFilename.c_str());\n+        Log() << \"Failed to rename \" << filename << \" to \" << newFilename << \"\\n\";\n         return false;\n     }\n \n     std::vector<CDBEnv::KeyValPair> salvagedData;\n     bool allOK = dbenv.Salvage(newFilename, true, salvagedData);\n     if (salvagedData.empty())\n     {\n-        LogPrintf(\"Salvage(aggressive) found no records in %s.\\n\", newFilename.c_str());\n+        Log() << \"Salvage(aggressive) found no records in \" << newFilename << \".\\n\";\n         return false;\n     }\n-    LogPrintf(\"Salvage(aggressive) found %\"PRIszu\" records\\n\", salvagedData.size());\n+    Log() << \"Salvage(aggressive) found \" << salvagedData.size() << \" records\\n\";\n \n     bool fSuccess = allOK;\n     Db* pdbCopy = new Db(&dbenv.dbenv, 0);\n@@ -826,7 +825,7 @@ bool CWalletDB::Recover(CDBEnv& dbenv, std::string filename, bool fOnlyKeys)\n                             0);\n     if (ret > 0)\n     {\n-        LogPrintf(\"Cannot create database file %s\\n\", filename.c_str());\n+        Log() << \"Cannot create database file \" << filename << \"\\n\";\n         return false;\n     }\n     CWallet dummyWallet;\n@@ -846,7 +845,7 @@ bool CWalletDB::Recover(CDBEnv& dbenv, std::string filename, bool fOnlyKeys)\n                 continue;\n             if (!fReadOK)\n             {\n-                LogPrintf(\"WARNING: CWalletDB::Recover skipping %s: %s\\n\", strType.c_str(), strErr.c_str());\n+                Log() << \"WARNING: CWalletDB::Recover skipping \" << strType << \": \" << strErr << \"\\n\";\n                 continue;\n             }\n         }"
      }
    ]
  }
]