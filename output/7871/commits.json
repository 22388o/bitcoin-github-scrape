[
  {
    "sha": "1fc4ec7bf224748d3d6271bffa23d121f015cbf3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxZmM0ZWM3YmYyMjQ3NDhkM2Q2MjcxYmZmYTIzZDEyMWYwMTVjYmYz",
    "commit": {
      "author": {
        "name": "mrbandrews",
        "email": "bandrewsny@gmail.com",
        "date": "2016-11-29T17:39:19Z"
      },
      "committer": {
        "name": "mrbandrews",
        "email": "bandrewsny@gmail.com",
        "date": "2017-01-10T13:14:50Z"
      },
      "message": "Add pruneblockchain RPC to enable manual block file pruning.",
      "tree": {
        "sha": "a726cadbb46e5e41932be2f06477a145f16df911",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a726cadbb46e5e41932be2f06477a145f16df911"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1fc4ec7bf224748d3d6271bffa23d121f015cbf3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1fc4ec7bf224748d3d6271bffa23d121f015cbf3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1fc4ec7bf224748d3d6271bffa23d121f015cbf3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1fc4ec7bf224748d3d6271bffa23d121f015cbf3/comments",
    "author": {
      "login": "mrbandrews",
      "id": 7504522,
      "node_id": "MDQ6VXNlcjc1MDQ1MjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7504522?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mrbandrews",
      "html_url": "https://github.com/mrbandrews",
      "followers_url": "https://api.github.com/users/mrbandrews/followers",
      "following_url": "https://api.github.com/users/mrbandrews/following{/other_user}",
      "gists_url": "https://api.github.com/users/mrbandrews/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mrbandrews/subscriptions",
      "organizations_url": "https://api.github.com/users/mrbandrews/orgs",
      "repos_url": "https://api.github.com/users/mrbandrews/repos",
      "events_url": "https://api.github.com/users/mrbandrews/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mrbandrews/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "mrbandrews",
      "id": 7504522,
      "node_id": "MDQ6VXNlcjc1MDQ1MjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7504522?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mrbandrews",
      "html_url": "https://github.com/mrbandrews",
      "followers_url": "https://api.github.com/users/mrbandrews/followers",
      "following_url": "https://api.github.com/users/mrbandrews/following{/other_user}",
      "gists_url": "https://api.github.com/users/mrbandrews/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mrbandrews/subscriptions",
      "organizations_url": "https://api.github.com/users/mrbandrews/orgs",
      "repos_url": "https://api.github.com/users/mrbandrews/repos",
      "events_url": "https://api.github.com/users/mrbandrews/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mrbandrews/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5754e0341b7c033d4caf99534aca47e9981bd7ed",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5754e0341b7c033d4caf99534aca47e9981bd7ed",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5754e0341b7c033d4caf99534aca47e9981bd7ed"
      }
    ],
    "stats": {
      "total": 231,
      "additions": 207,
      "deletions": 24
    },
    "files": [
      {
        "sha": "2129a151e2de3875c49d7fc943d3b3cbfd922bb0",
        "filename": "doc/man/bitcoin-qt.1",
        "status": "modified",
        "additions": 7,
        "deletions": 5,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1fc4ec7bf224748d3d6271bffa23d121f015cbf3/doc/man/bitcoin-qt.1",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1fc4ec7bf224748d3d6271bffa23d121f015cbf3/doc/man/bitcoin-qt.1",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/man/bitcoin-qt.1?ref=1fc4ec7bf224748d3d6271bffa23d121f015cbf3",
        "patch": "@@ -75,11 +75,13 @@ Specify pid file (default: bitcoind.pid)\n .HP\n \\fB\\-prune=\\fR<n>\n .IP\n-Reduce storage requirements by pruning (deleting) old blocks. This mode\n-is incompatible with \\fB\\-txindex\\fR and \\fB\\-rescan\\fR. Warning: Reverting\n-this setting requires re\\-downloading the entire blockchain.\n-(default: 0 = disable pruning blocks, >550 = target size in MiB\n-to use for block files)\n+Reduce storage requirements by enabling pruning (deleting) of old blocks.\n+This allows the pruneblockchain RPC to be called to delete specific blocks,\n+and enables automatic pruning of old blocks if a target size in MiB is\n+provided. This mode is incompatible with \\fB\\-txindex\\fR and \\fB\\-rescan\\fR.\n+Warning: Reverting this setting requires re\\-downloading the entire blockchain.\n+(default: 0 = disable pruning blocks, 1 = allow manual pruning via RPC, >550 =\n+automatically prune block files to stay under the specified target size in MiB)\n .HP\n \\fB\\-reindex\\-chainstate\\fR\n .IP"
      },
      {
        "sha": "47539d81319eb7549dcce68c80d8e776546902ea",
        "filename": "doc/man/bitcoind.1",
        "status": "modified",
        "additions": 7,
        "deletions": 5,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1fc4ec7bf224748d3d6271bffa23d121f015cbf3/doc/man/bitcoind.1",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1fc4ec7bf224748d3d6271bffa23d121f015cbf3/doc/man/bitcoind.1",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/man/bitcoind.1?ref=1fc4ec7bf224748d3d6271bffa23d121f015cbf3",
        "patch": "@@ -80,11 +80,13 @@ Specify pid file (default: bitcoind.pid)\n .HP\n \\fB\\-prune=\\fR<n>\n .IP\n-Reduce storage requirements by pruning (deleting) old blocks. This mode\n-is incompatible with \\fB\\-txindex\\fR and \\fB\\-rescan\\fR. Warning: Reverting\n-this setting requires re\\-downloading the entire blockchain.\n-(default: 0 = disable pruning blocks, >550 = target size in MiB\n-to use for block files)\n+Reduce storage requirements by enabling pruning (deleting) of old blocks.\n+This allows the pruneblockchain RPC to be called to delete specific blocks,\n+and enables automatic pruning of old blocks if a target size in MiB is\n+provided. This mode is incompatible with \\fB\\-txindex\\fR and \\fB\\-rescan\\fR.\n+Warning: Reverting this setting requires re\\-downloading the entire blockchain.\n+(default: 0 = disable pruning blocks, 1 = allow manual pruning via RPC, >550 =\n+automatically prune block files to stay under the specified target size in MiB)\n .HP\n \\fB\\-reindex\\-chainstate\\fR\n .IP"
      },
      {
        "sha": "062bc8dda49634ec5105e4e2fc4c3a9248797a86",
        "filename": "qa/rpc-tests/pruning.py",
        "status": "modified",
        "additions": 110,
        "deletions": 3,
        "changes": 113,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1fc4ec7bf224748d3d6271bffa23d121f015cbf3/qa/rpc-tests/pruning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1fc4ec7bf224748d3d6271bffa23d121f015cbf3/qa/rpc-tests/pruning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/pruning.py?ref=1fc4ec7bf224748d3d6271bffa23d121f015cbf3",
        "patch": "@@ -25,7 +25,7 @@ class PruneTest(BitcoinTestFramework):\n     def __init__(self):\n         super().__init__()\n         self.setup_clean_chain = True\n-        self.num_nodes = 3\n+        self.num_nodes = 5\n \n         # Cache for utxos, as the listunspent may take a long time later in the test\n         self.utxo_cache_0 = []\n@@ -43,10 +43,21 @@ def setup_network(self):\n         self.nodes.append(start_node(2, self.options.tmpdir, [\"-debug\",\"-maxreceivebuffer=20000\",\"-prune=550\"], timewait=900))\n         self.prunedir = self.options.tmpdir+\"/node2/regtest/blocks/\"\n \n+        # Create node 3 to test manual pruning (it will be re-started with manual pruning later)\n+        self.nodes.append(start_node(3, self.options.tmpdir, [\"-debug=0\",\"-maxreceivebuffer=20000\",\"-blockmaxsize=999000\"], timewait=900))\n+        self.manualdir = self.options.tmpdir+\"/node3/regtest/blocks/\"\n+\n+        # Create node 4 to test wallet in prune mode, but do not connect\n+        self.nodes.append(start_node(4, self.options.tmpdir, [\"-debug=0\", \"-prune=550\"]))\n+\n+        # Determine default relay fee\n+        self.relayfee = self.nodes[0].getnetworkinfo()[\"relayfee\"]\n+\n         connect_nodes(self.nodes[0], 1)\n         connect_nodes(self.nodes[1], 2)\n         connect_nodes(self.nodes[2], 0)\n-        sync_blocks(self.nodes[0:3])\n+        connect_nodes(self.nodes[0], 3)\n+        sync_blocks(self.nodes[0:4])\n \n     def create_big_chain(self):\n         # Start by creating some coinbases we can spend later\n@@ -57,7 +68,7 @@ def create_big_chain(self):\n         for i in range(645):\n             mine_large_block(self.nodes[0], self.utxo_cache_0)\n \n-        sync_blocks(self.nodes[0:3])\n+        sync_blocks(self.nodes[0:4])\n \n     def test_height_min(self):\n         if not os.path.isfile(self.prunedir+\"blk00000.dat\"):\n@@ -212,6 +223,93 @@ def reorg_back(self):\n         # Verify we can now have the data for a block previously pruned\n         assert(self.nodes[2].getblock(self.forkhash)[\"height\"] == self.forkheight)\n \n+    def manual_test(self):\n+        # at this point, node3 has 995 blocks and has not yet run in prune mode\n+        self.nodes[3] = start_node(3, self.options.tmpdir, [\"-debug=0\"], timewait=900)\n+        assert_raises_message(JSONRPCException, \"not in prune mode\", self.nodes[3].pruneblockchain, 500)\n+        stop_node(self.nodes[3],3)\n+\n+        # now re-start in manual pruning mode\n+        self.nodes[3] = start_node(3, self.options.tmpdir, [\"-debug=0\",\"-prune=1\"], timewait=900)\n+        assert_equal(self.nodes[3].getblockcount(), 995)\n+\n+        # should not prune because chain tip of node 3 (995) < PruneAfterHeight (1000)\n+        assert_raises_message(JSONRPCException, \"Blockchain is too short for pruning\", self.nodes[3].pruneblockchain, 500)\n+\n+        # mine 6 blocks so we are at height 1001 (i.e., above PruneAfterHeight)\n+        self.nodes[3].generate(6)\n+\n+        # negative and zero inputs should raise an exception\n+        try:\n+            self.nodes[3].pruneblockchain(-10)\n+            raise AssertionError(\"pruneblockchain(-10) should have failed.\")\n+        except:\n+            pass\n+\n+        try:\n+            self.nodes[3].pruneblockchain(0)\n+            raise AssertionError(\"pruneblockchain(0) should have failed.\")\n+        except:\n+            pass\n+\n+        # height=100 too low to prune first block file so this is a no-op\n+        self.nodes[3].pruneblockchain(100)\n+        if not os.path.isfile(self.manualdir+\"blk00000.dat\"):\n+            raise AssertionError(\"blk00000.dat is missing when should still be there\")\n+\n+        # height=500 should prune first file\n+        self.nodes[3].pruneblockchain(500)\n+        if os.path.isfile(self.manualdir+\"blk00000.dat\"):\n+            raise AssertionError(\"blk00000.dat is still there, should be pruned by now\")\n+        if not os.path.isfile(self.manualdir+\"blk00001.dat\"):\n+            raise AssertionError(\"blk00001.dat is missing when should still be there\")\n+\n+        # height=650 should prune second file\n+        self.nodes[3].pruneblockchain(650)\n+        if os.path.isfile(self.manualdir+\"blk00001.dat\"):\n+            raise AssertionError(\"blk00001.dat is still there, should be pruned by now\")\n+\n+        # height=1000 should not prune anything more, because tip-288 is in blk00002.dat.\n+        self.nodes[3].pruneblockchain(1000)\n+        if not os.path.isfile(self.manualdir+\"blk00002.dat\"):\n+            raise AssertionError(\"blk00002.dat is still there, should be pruned by now\")\n+\n+        # advance the tip so blk00002.dat and blk00003.dat can be pruned (the last 288 blocks should now be in blk00004.dat)\n+        self.nodes[3].generate(288)\n+        self.nodes[3].pruneblockchain(1000)\n+        if os.path.isfile(self.manualdir+\"blk00002.dat\"):\n+            raise AssertionError(\"blk00002.dat is still there, should be pruned by now\")\n+        if os.path.isfile(self.manualdir+\"blk00003.dat\"):\n+            raise AssertionError(\"blk00003.dat is still there, should be pruned by now\")\n+\n+        # stop node, start back up with auto-prune at 550MB, make sure still runs\n+        stop_node(self.nodes[3],3)\n+        self.nodes[3] = start_node(3, self.options.tmpdir, [\"-debug=0\",\"-prune=550\"], timewait=900)\n+\n+        print(\"Success\")\n+\n+    def wallet_test(self):\n+        # check that the pruning node's wallet is still in good shape\n+        print(\"Stop and start pruning node to trigger wallet rescan\")\n+        try:\n+            stop_node(self.nodes[2], 2)\n+            start_node(2, self.options.tmpdir, [\"-debug=1\",\"-prune=550\"])\n+            print(\"Success\")\n+        except Exception as detail:\n+            raise AssertionError(\"Wallet test: unable to re-start the pruning node\")\n+\n+        # check that wallet loads loads successfully when restarting a pruned node after IBD.\n+        # this was reported to fail in #7494.\n+        print (\"Syncing node 4 to test wallet\")\n+        connect_nodes(self.nodes[0], 4)\n+        nds = [self.nodes[0], self.nodes[4]]\n+        sync_blocks(nds)\n+        try:\n+            stop_node(self.nodes[4],4) #stop and start to trigger rescan\n+            start_node(4, self.options.tmpdir, [\"-debug=1\",\"-prune=550\"])\n+            print (\"Success\")\n+        except Exception as detail:\n+            raise AssertionError(\"Wallet test: unable to re-start node4\")\n \n     def run_test(self):\n         print(\"Warning! This test requires 4GB of disk space and takes over 30 mins (up to 2 hours)\")\n@@ -226,6 +324,9 @@ def run_test(self):\n         # Start by mining a simple chain that all nodes have\n         # N0=N1=N2 **...*(995)\n \n+        # stop manual-pruning node with 995 blocks\n+        stop_node(self.nodes[3],3)\n+\n         print(\"Check that we haven't started pruning yet because we're below PruneAfterHeight\")\n         self.test_height_min()\n         # Extend this chain past the PruneAfterHeight\n@@ -308,6 +409,12 @@ def run_test(self):\n         #\n         # N1 doesn't change because 1033 on main chain (*) is invalid\n \n+        print(\"Test manual pruning\")\n+        self.manual_test()\n+\n+        print(\"Test wallet re-scan\")\n+        self.wallet_test()\n+\n         print(\"Done\")\n \n if __name__ == '__main__':"
      },
      {
        "sha": "9ac69b7d39c2f57a00a786ca737422fa71dbd81b",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 6,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1fc4ec7bf224748d3d6271bffa23d121f015cbf3/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1fc4ec7bf224748d3d6271bffa23d121f015cbf3/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=1fc4ec7bf224748d3d6271bffa23d121f015cbf3",
        "patch": "@@ -351,9 +351,9 @@ std::string HelpMessage(HelpMessageMode mode)\n #ifndef WIN32\n     strUsage += HelpMessageOpt(\"-pid=<file>\", strprintf(_(\"Specify pid file (default: %s)\"), BITCOIN_PID_FILENAME));\n #endif\n-    strUsage += HelpMessageOpt(\"-prune=<n>\", strprintf(_(\"Reduce storage requirements by pruning (deleting) old blocks. This mode is incompatible with -txindex and -rescan. \"\n+    strUsage += HelpMessageOpt(\"-prune=<n>\", strprintf(_(\"Reduce storage requirements by enabling pruning (deleting) of old blocks. This allows the pruneblockchain RPC to be called to delete specific blocks, and enables automatic pruning of old blocks if a target size in MiB is provided. This mode is incompatible with -txindex and -rescan. \"\n             \"Warning: Reverting this setting requires re-downloading the entire blockchain. \"\n-            \"(default: 0 = disable pruning blocks, >%u = target size in MiB to use for block files)\"), MIN_DISK_SPACE_FOR_BLOCK_FILES / 1024 / 1024));\n+            \"(default: 0 = disable pruning blocks, 1 = allow manual pruning via RPC, >%u = automatically prune block files to stay under the specified target size in MiB)\"), MIN_DISK_SPACE_FOR_BLOCK_FILES / 1024 / 1024));\n     strUsage += HelpMessageOpt(\"-reindex-chainstate\", _(\"Rebuild chain state from the currently indexed blocks\"));\n     strUsage += HelpMessageOpt(\"-reindex\", _(\"Rebuild chain state and block index from the blk*.dat files on disk\"));\n #ifndef WIN32\n@@ -936,12 +936,16 @@ bool AppInitParameterInteraction()\n         nScriptCheckThreads = MAX_SCRIPTCHECK_THREADS;\n \n     // block pruning; get the amount of disk space (in MiB) to allot for block & undo files\n-    int64_t nSignedPruneTarget = GetArg(\"-prune\", 0) * 1024 * 1024;\n-    if (nSignedPruneTarget < 0) {\n+    int64_t nPruneArg = GetArg(\"-prune\", 0);\n+    if (nPruneArg < 0) {\n         return InitError(_(\"Prune cannot be configured with a negative value.\"));\n     }\n-    nPruneTarget = (uint64_t) nSignedPruneTarget;\n-    if (nPruneTarget) {\n+    nPruneTarget = (uint64_t) nPruneArg * 1024 * 1024;\n+    if (nPruneArg == 1) {  // manual pruning: -prune=1\n+        LogPrintf(\"Block pruning enabled.  Use RPC call pruneblockchain(height) to manually prune block and undo files.\\n\");\n+        nPruneTarget = std::numeric_limits<uint64_t>::max();\n+        fPruneMode = true;\n+    } else if (nPruneTarget) {\n         if (nPruneTarget < MIN_DISK_SPACE_FOR_BLOCK_FILES) {\n             return InitError(strprintf(_(\"Prune configured below the minimum of %d MiB.  Please use a higher number.\"), MIN_DISK_SPACE_FOR_BLOCK_FILES / 1024 / 1024));\n         }"
      },
      {
        "sha": "f49a3332796913935831e0735e43d86842bda056",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 31,
        "deletions": 0,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1fc4ec7bf224748d3d6271bffa23d121f015cbf3/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1fc4ec7bf224748d3d6271bffa23d121f015cbf3/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=1fc4ec7bf224748d3d6271bffa23d121f015cbf3",
        "patch": "@@ -814,6 +814,36 @@ static bool GetUTXOStats(CCoinsView *view, CCoinsStats &stats)\n     return true;\n }\n \n+UniValue pruneblockchain(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw runtime_error(\n+            \"pruneblockchain\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"height\\\"       (int, required) The block height to prune up to.\\n\");\n+\n+    if (!fPruneMode)\n+        throw JSONRPCError(RPC_METHOD_NOT_FOUND, \"Cannot prune blocks because node is not in prune mode.\");\n+\n+    LOCK(cs_main);\n+\n+    int heightParam = request.params[0].get_int();\n+    if (heightParam < 0)\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Negative block height.\");\n+\n+    unsigned int height = (unsigned int) heightParam;\n+    unsigned int chainHeight = (unsigned int) chainActive.Height();\n+    if (chainHeight < Params().PruneAfterHeight())\n+        throw JSONRPCError(RPC_INTERNAL_ERROR, \"Blockchain is too short for pruning.\");\n+    else if (height > chainHeight)\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Blockchain is shorter than the attempted prune height.\");\n+    else if (height > chainHeight - MIN_BLOCKS_TO_KEEP)\n+        LogPrint(\"rpc\", \"Attempt to prune blocks close to the tip.  Retaining the minimum number of blocks.\");\n+\n+    PruneBlockFilesManual(height);\n+    return NullUniValue;\n+}\n+\n UniValue gettxoutsetinfo(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n@@ -1384,6 +1414,7 @@ static const CRPCCommand commands[] =\n     { \"blockchain\",         \"getrawmempool\",          &getrawmempool,          true,  {\"verbose\"} },\n     { \"blockchain\",         \"gettxout\",               &gettxout,               true,  {\"txid\",\"n\",\"include_mempool\"} },\n     { \"blockchain\",         \"gettxoutsetinfo\",        &gettxoutsetinfo,        true,  {} },\n+    { \"blockchain\",         \"pruneblockchain\",        &pruneblockchain,        true,  {\"height\"} },\n     { \"blockchain\",         \"verifychain\",            &verifychain,            true,  {\"checklevel\",\"nblocks\"} },\n \n     { \"blockchain\",         \"preciousblock\",          &preciousblock,          true,  {\"blockhash\"} },"
      },
      {
        "sha": "5d3c4584558ae8f2d90ca7c60f4ecc7856f5e419",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1fc4ec7bf224748d3d6271bffa23d121f015cbf3/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1fc4ec7bf224748d3d6271bffa23d121f015cbf3/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=1fc4ec7bf224748d3d6271bffa23d121f015cbf3",
        "patch": "@@ -103,6 +103,7 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"importmulti\", 1, \"options\" },\n     { \"verifychain\", 0, \"checklevel\" },\n     { \"verifychain\", 1, \"nblocks\" },\n+    { \"pruneblockchain\", 0, \"height\" },\n     { \"keypoolrefill\", 0, \"newsize\" },\n     { \"getrawmempool\", 0, \"verbose\" },\n     { \"estimatefee\", 0, \"nblocks\" },"
      },
      {
        "sha": "109a71fe74d4e5fd8e96c00087c21a6f89a15c5d",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 39,
        "deletions": 5,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1fc4ec7bf224748d3d6271bffa23d121f015cbf3/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1fc4ec7bf224748d3d6271bffa23d121f015cbf3/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=1fc4ec7bf224748d3d6271bffa23d121f015cbf3",
        "patch": "@@ -185,7 +185,8 @@ enum FlushStateMode {\n };\n \n // See definition for documentation\n-bool static FlushStateToDisk(CValidationState &state, FlushStateMode mode);\n+bool static FlushStateToDisk(CValidationState &state, FlushStateMode mode, int nManualPruneHeight=0);\n+void FindFilesToPruneManual(std::set<int>& setFilesToPrune, int nManualPruneHeight);\n \n bool IsFinalTx(const CTransaction &tx, int nBlockHeight, int64_t nBlockTime)\n {\n@@ -1934,7 +1935,7 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n  * if they're too large, if it's been a while since the last write,\n  * or always and in all cases if we're in prune mode and are deleting files.\n  */\n-bool static FlushStateToDisk(CValidationState &state, FlushStateMode mode) {\n+bool static FlushStateToDisk(CValidationState &state, FlushStateMode mode, int nManualPruneHeight) {\n     int64_t nMempoolUsage = mempool.DynamicMemoryUsage();\n     const CChainParams& chainparams = Params();\n     LOCK2(cs_main, cs_LastBlockFile);\n@@ -1944,9 +1945,13 @@ bool static FlushStateToDisk(CValidationState &state, FlushStateMode mode) {\n     std::set<int> setFilesToPrune;\n     bool fFlushForPrune = false;\n     try {\n-    if (fPruneMode && fCheckForPruning && !fReindex) {\n-        FindFilesToPrune(setFilesToPrune, chainparams.PruneAfterHeight());\n-        fCheckForPruning = false;\n+    if (fPruneMode && (fCheckForPruning || nManualPruneHeight > 0) && !fReindex) {\n+        if (nManualPruneHeight > 0) {\n+            FindFilesToPruneManual(setFilesToPrune, nManualPruneHeight);\n+        } else {\n+            FindFilesToPrune(setFilesToPrune, chainparams.PruneAfterHeight());\n+            fCheckForPruning = false;\n+        }\n         if (!setFilesToPrune.empty()) {\n             fFlushForPrune = true;\n             if (!fHavePruned) {\n@@ -3247,6 +3252,35 @@ void UnlinkPrunedFiles(std::set<int>& setFilesToPrune)\n     }\n }\n \n+/* Calculate the block/rev files to delete based on height specified by user with RPC command pruneblockchain */\n+void FindFilesToPruneManual(std::set<int>& setFilesToPrune, int nManualPruneHeight)\n+{\n+    assert(fPruneMode && nManualPruneHeight > 0);\n+\n+    LOCK2(cs_main, cs_LastBlockFile);\n+    if (chainActive.Tip() == NULL)\n+        return;\n+\n+    // last block to prune is the lesser of (user-specified height, MIN_BLOCKS_TO_KEEP from the tip)\n+    unsigned int nLastBlockWeCanPrune = min((unsigned)nManualPruneHeight, chainActive.Tip()->nHeight - MIN_BLOCKS_TO_KEEP);\n+    int count=0;\n+    for (int fileNumber = 0; fileNumber < nLastBlockFile; fileNumber++) {\n+        if (vinfoBlockFile[fileNumber].nSize == 0 || vinfoBlockFile[fileNumber].nHeightLast > nLastBlockWeCanPrune)\n+            continue;\n+        PruneOneBlockFile(fileNumber);\n+        setFilesToPrune.insert(fileNumber);\n+        count++;\n+    }\n+    LogPrintf(\"Prune (Manual): prune_height=%d removed %d blk/rev pairs\\n\", nLastBlockWeCanPrune, count);\n+}\n+\n+/* This function is called from the RPC code for pruneblockchain */\n+void PruneBlockFilesManual(int nManualPruneHeight)\n+{\n+    CValidationState state;\n+    FlushStateToDisk(state, FLUSH_STATE_NONE, nManualPruneHeight);\n+}\n+\n /* Calculate the block/rev files that should be deleted to remain under target*/\n void FindFilesToPrune(std::set<int>& setFilesToPrune, uint64_t nPruneAfterHeight)\n {"
      },
      {
        "sha": "f5e76c7d31e69288547220d175287e16eb2dc4f3",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1fc4ec7bf224748d3d6271bffa23d121f015cbf3/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1fc4ec7bf224748d3d6271bffa23d121f015cbf3/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=1fc4ec7bf224748d3d6271bffa23d121f015cbf3",
        "patch": "@@ -309,6 +309,8 @@ CBlockIndex * InsertBlockIndex(uint256 hash);\n void FlushStateToDisk();\n /** Prune block files and flush state to disk. */\n void PruneAndFlush();\n+/** Prune block files up to a given height */\n+void PruneBlockFilesManual(int nPruneUpToHeight);\n \n /** (try to) add transaction to memory pool **/\n bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransactionRef &tx, bool fLimitFree,"
      }
    ]
  },
  {
    "sha": "afffeea7d98ba358acd54a89bc0e7ae1c4d54023",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphZmZmZWVhN2Q5OGJhMzU4YWNkNTRhODliYzBlN2FlMWM0ZDU0MDIz",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2017-01-09T18:35:12Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2017-01-10T13:14:50Z"
      },
      "message": "fixup! Add pruneblockchain RPC to enable manual block file pruning.\n\nExtend pruneblockchain RPC to accept block timestamps as well as block indices.",
      "tree": {
        "sha": "249616d481c9e141d30ce070dbdcfc784934f537",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/249616d481c9e141d30ce070dbdcfc784934f537"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/afffeea7d98ba358acd54a89bc0e7ae1c4d54023",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/afffeea7d98ba358acd54a89bc0e7ae1c4d54023",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/afffeea7d98ba358acd54a89bc0e7ae1c4d54023",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/afffeea7d98ba358acd54a89bc0e7ae1c4d54023/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1fc4ec7bf224748d3d6271bffa23d121f015cbf3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1fc4ec7bf224748d3d6271bffa23d121f015cbf3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1fc4ec7bf224748d3d6271bffa23d121f015cbf3"
      }
    ],
    "stats": {
      "total": 109,
      "additions": 67,
      "deletions": 42
    },
    "files": [
      {
        "sha": "25f07790034d304c597145a5643006b6286314d3",
        "filename": "qa/rpc-tests/pruning.py",
        "status": "modified",
        "additions": 56,
        "deletions": 41,
        "changes": 97,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/afffeea7d98ba358acd54a89bc0e7ae1c4d54023/qa/rpc-tests/pruning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/afffeea7d98ba358acd54a89bc0e7ae1c4d54023/qa/rpc-tests/pruning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/pruning.py?ref=afffeea7d98ba358acd54a89bc0e7ae1c4d54023",
        "patch": "@@ -25,7 +25,7 @@ class PruneTest(BitcoinTestFramework):\n     def __init__(self):\n         super().__init__()\n         self.setup_clean_chain = True\n-        self.num_nodes = 5\n+        self.num_nodes = 6\n \n         # Cache for utxos, as the listunspent may take a long time later in the test\n         self.utxo_cache_0 = []\n@@ -43,12 +43,12 @@ def setup_network(self):\n         self.nodes.append(start_node(2, self.options.tmpdir, [\"-debug\",\"-maxreceivebuffer=20000\",\"-prune=550\"], timewait=900))\n         self.prunedir = self.options.tmpdir+\"/node2/regtest/blocks/\"\n \n-        # Create node 3 to test manual pruning (it will be re-started with manual pruning later)\n+        # Create nodes 3 and 4 to test manual pruning (they will be re-started with manual pruning later)\n         self.nodes.append(start_node(3, self.options.tmpdir, [\"-debug=0\",\"-maxreceivebuffer=20000\",\"-blockmaxsize=999000\"], timewait=900))\n-        self.manualdir = self.options.tmpdir+\"/node3/regtest/blocks/\"\n+        self.nodes.append(start_node(4, self.options.tmpdir, [\"-debug=0\",\"-maxreceivebuffer=20000\",\"-blockmaxsize=999000\"], timewait=900))\n \n-        # Create node 4 to test wallet in prune mode, but do not connect\n-        self.nodes.append(start_node(4, self.options.tmpdir, [\"-debug=0\", \"-prune=550\"]))\n+        # Create nodes 5 to test wallet in prune mode, but do not connect\n+        self.nodes.append(start_node(5, self.options.tmpdir, [\"-debug=0\", \"-prune=550\"]))\n \n         # Determine default relay fee\n         self.relayfee = self.nodes[0].getnetworkinfo()[\"relayfee\"]\n@@ -57,7 +57,8 @@ def setup_network(self):\n         connect_nodes(self.nodes[1], 2)\n         connect_nodes(self.nodes[2], 0)\n         connect_nodes(self.nodes[0], 3)\n-        sync_blocks(self.nodes[0:4])\n+        connect_nodes(self.nodes[0], 4)\n+        sync_blocks(self.nodes[0:5])\n \n     def create_big_chain(self):\n         # Start by creating some coinbases we can spend later\n@@ -68,7 +69,7 @@ def create_big_chain(self):\n         for i in range(645):\n             mine_large_block(self.nodes[0], self.utxo_cache_0)\n \n-        sync_blocks(self.nodes[0:4])\n+        sync_blocks(self.nodes[0:5])\n \n     def test_height_min(self):\n         if not os.path.isfile(self.prunedir+\"blk00000.dat\"):\n@@ -223,68 +224,78 @@ def reorg_back(self):\n         # Verify we can now have the data for a block previously pruned\n         assert(self.nodes[2].getblock(self.forkhash)[\"height\"] == self.forkheight)\n \n-    def manual_test(self):\n-        # at this point, node3 has 995 blocks and has not yet run in prune mode\n-        self.nodes[3] = start_node(3, self.options.tmpdir, [\"-debug=0\"], timewait=900)\n-        assert_raises_message(JSONRPCException, \"not in prune mode\", self.nodes[3].pruneblockchain, 500)\n-        stop_node(self.nodes[3],3)\n+    def manual_test(self, node_number, use_timestamp):\n+        # at this point, node has 995 blocks and has not yet run in prune mode\n+        node = self.nodes[node_number] = start_node(node_number, self.options.tmpdir, [\"-debug=0\"], timewait=900)\n+        assert_equal(node.getblockcount(), 995)\n+        assert_raises_message(JSONRPCException, \"not in prune mode\", node.pruneblockchain, 500)\n+        stop_node(node, node_number)\n \n         # now re-start in manual pruning mode\n-        self.nodes[3] = start_node(3, self.options.tmpdir, [\"-debug=0\",\"-prune=1\"], timewait=900)\n-        assert_equal(self.nodes[3].getblockcount(), 995)\n+        node = self.nodes[node_number] = start_node(node_number, self.options.tmpdir, [\"-debug=0\",\"-prune=1\"], timewait=900)\n+        assert_equal(node.getblockcount(), 995)\n+\n+        def height(index):\n+            if use_timestamp:\n+                return node.getblockheader(node.getblockhash(index))[\"time\"]\n+            else:\n+                return index\n+\n+        def has_block(index):\n+            return os.path.isfile(self.options.tmpdir + \"/node{}/regtest/blocks/blk{:05}.dat\".format(node_number, index))\n \n         # should not prune because chain tip of node 3 (995) < PruneAfterHeight (1000)\n-        assert_raises_message(JSONRPCException, \"Blockchain is too short for pruning\", self.nodes[3].pruneblockchain, 500)\n+        assert_raises_message(JSONRPCException, \"Blockchain is too short for pruning\", node.pruneblockchain, height(500))\n \n         # mine 6 blocks so we are at height 1001 (i.e., above PruneAfterHeight)\n-        self.nodes[3].generate(6)\n+        node.generate(6)\n \n         # negative and zero inputs should raise an exception\n         try:\n-            self.nodes[3].pruneblockchain(-10)\n+            node.pruneblockchain(-10)\n             raise AssertionError(\"pruneblockchain(-10) should have failed.\")\n         except:\n             pass\n \n         try:\n-            self.nodes[3].pruneblockchain(0)\n+            node.pruneblockchain(0)\n             raise AssertionError(\"pruneblockchain(0) should have failed.\")\n         except:\n             pass\n \n         # height=100 too low to prune first block file so this is a no-op\n-        self.nodes[3].pruneblockchain(100)\n-        if not os.path.isfile(self.manualdir+\"blk00000.dat\"):\n+        node.pruneblockchain(height(100))\n+        if not has_block(0):\n             raise AssertionError(\"blk00000.dat is missing when should still be there\")\n \n         # height=500 should prune first file\n-        self.nodes[3].pruneblockchain(500)\n-        if os.path.isfile(self.manualdir+\"blk00000.dat\"):\n+        node.pruneblockchain(height(500))\n+        if has_block(0):\n             raise AssertionError(\"blk00000.dat is still there, should be pruned by now\")\n-        if not os.path.isfile(self.manualdir+\"blk00001.dat\"):\n+        if not has_block(1):\n             raise AssertionError(\"blk00001.dat is missing when should still be there\")\n \n         # height=650 should prune second file\n-        self.nodes[3].pruneblockchain(650)\n-        if os.path.isfile(self.manualdir+\"blk00001.dat\"):\n+        node.pruneblockchain(height(650))\n+        if has_block(1):\n             raise AssertionError(\"blk00001.dat is still there, should be pruned by now\")\n \n         # height=1000 should not prune anything more, because tip-288 is in blk00002.dat.\n-        self.nodes[3].pruneblockchain(1000)\n-        if not os.path.isfile(self.manualdir+\"blk00002.dat\"):\n+        node.pruneblockchain(height(1000))\n+        if not has_block(2):\n             raise AssertionError(\"blk00002.dat is still there, should be pruned by now\")\n \n         # advance the tip so blk00002.dat and blk00003.dat can be pruned (the last 288 blocks should now be in blk00004.dat)\n-        self.nodes[3].generate(288)\n-        self.nodes[3].pruneblockchain(1000)\n-        if os.path.isfile(self.manualdir+\"blk00002.dat\"):\n+        node.generate(288)\n+        node.pruneblockchain(height(1000))\n+        if has_block(2):\n             raise AssertionError(\"blk00002.dat is still there, should be pruned by now\")\n-        if os.path.isfile(self.manualdir+\"blk00003.dat\"):\n+        if has_block(3):\n             raise AssertionError(\"blk00003.dat is still there, should be pruned by now\")\n \n         # stop node, start back up with auto-prune at 550MB, make sure still runs\n-        stop_node(self.nodes[3],3)\n-        self.nodes[3] = start_node(3, self.options.tmpdir, [\"-debug=0\",\"-prune=550\"], timewait=900)\n+        stop_node(node, node_number)\n+        self.nodes[node_number] = start_node(node_number, self.options.tmpdir, [\"-debug=0\",\"-prune=550\"], timewait=900)\n \n         print(\"Success\")\n \n@@ -300,16 +311,16 @@ def wallet_test(self):\n \n         # check that wallet loads loads successfully when restarting a pruned node after IBD.\n         # this was reported to fail in #7494.\n-        print (\"Syncing node 4 to test wallet\")\n-        connect_nodes(self.nodes[0], 4)\n-        nds = [self.nodes[0], self.nodes[4]]\n+        print (\"Syncing node 5 to test wallet\")\n+        connect_nodes(self.nodes[0], 5)\n+        nds = [self.nodes[0], self.nodes[5]]\n         sync_blocks(nds)\n         try:\n-            stop_node(self.nodes[4],4) #stop and start to trigger rescan\n-            start_node(4, self.options.tmpdir, [\"-debug=1\",\"-prune=550\"])\n+            stop_node(self.nodes[5],5) #stop and start to trigger rescan\n+            start_node(5, self.options.tmpdir, [\"-debug=1\",\"-prune=550\"])\n             print (\"Success\")\n         except Exception as detail:\n-            raise AssertionError(\"Wallet test: unable to re-start node4\")\n+            raise AssertionError(\"Wallet test: unable to re-start node5\")\n \n     def run_test(self):\n         print(\"Warning! This test requires 4GB of disk space and takes over 30 mins (up to 2 hours)\")\n@@ -326,6 +337,7 @@ def run_test(self):\n \n         # stop manual-pruning node with 995 blocks\n         stop_node(self.nodes[3],3)\n+        stop_node(self.nodes[4],4)\n \n         print(\"Check that we haven't started pruning yet because we're below PruneAfterHeight\")\n         self.test_height_min()\n@@ -409,8 +421,11 @@ def run_test(self):\n         #\n         # N1 doesn't change because 1033 on main chain (*) is invalid\n \n-        print(\"Test manual pruning\")\n-        self.manual_test()\n+        print(\"Test manual pruning with block indices\")\n+        self.manual_test(3, use_timestamp=False)\n+\n+        print(\"Test manual pruning with timestamps\")\n+        self.manual_test(4, use_timestamp=True)\n \n         print(\"Test wallet re-scan\")\n         self.wallet_test()"
      },
      {
        "sha": "e828618a8243020b0b88f4a5fc82cc8622ba2176",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 1,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/afffeea7d98ba358acd54a89bc0e7ae1c4d54023/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/afffeea7d98ba358acd54a89bc0e7ae1c4d54023/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=afffeea7d98ba358acd54a89bc0e7ae1c4d54023",
        "patch": "@@ -820,7 +820,7 @@ UniValue pruneblockchain(const JSONRPCRequest& request)\n         throw runtime_error(\n             \"pruneblockchain\\n\"\n             \"\\nArguments:\\n\"\n-            \"1. \\\"height\\\"       (int, required) The block height to prune up to.\\n\");\n+            \"1. \\\"height\\\"       (numeric, required) The block height to prune up to. May be set to a discrete height, or to a unix timestamp to prune based on block time.\\n\");\n \n     if (!fPruneMode)\n         throw JSONRPCError(RPC_METHOD_NOT_FOUND, \"Cannot prune blocks because node is not in prune mode.\");\n@@ -831,6 +831,16 @@ UniValue pruneblockchain(const JSONRPCRequest& request)\n     if (heightParam < 0)\n         throw JSONRPCError(RPC_INVALID_PARAMETER, \"Negative block height.\");\n \n+    // Height value more than a billion is too high to be a block height, and\n+    // too low to be a block time (corresponds to timestamp from Sep 2001).\n+    if (heightParam > 1000000000) {\n+        CBlockIndex* pindex = chainActive.FindLatestBefore(heightParam);\n+        if (!pindex) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Could not find block before specified timestamp.\");\n+        }\n+        heightParam = pindex->nHeight;\n+    }\n+\n     unsigned int height = (unsigned int) heightParam;\n     unsigned int chainHeight = (unsigned int) chainActive.Height();\n     if (chainHeight < Params().PruneAfterHeight())"
      }
    ]
  }
]