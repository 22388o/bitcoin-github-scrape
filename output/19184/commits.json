[
  {
    "sha": "259bf92d4abbc8c2923754106ef965e959cfd053",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNTliZjkyZDRhYmJjOGMyOTIzNzU0MTA2ZWY5NjVlOTU5Y2ZkMDUz",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-06-06T02:59:04Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-07-21T00:37:16Z"
      },
      "message": "Add txrequest module",
      "tree": {
        "sha": "5869fe1c5dbc8d4274dc85afd34f7d64226222a5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5869fe1c5dbc8d4274dc85afd34f7d64226222a5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/259bf92d4abbc8c2923754106ef965e959cfd053",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/259bf92d4abbc8c2923754106ef965e959cfd053",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/259bf92d4abbc8c2923754106ef965e959cfd053",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/259bf92d4abbc8c2923754106ef965e959cfd053/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "476436b2dec254bb988f8c7a6cbec1d7bb7cecfd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/476436b2dec254bb988f8c7a6cbec1d7bb7cecfd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/476436b2dec254bb988f8c7a6cbec1d7bb7cecfd"
      }
    ],
    "stats": {
      "total": 588,
      "additions": 588,
      "deletions": 0
    },
    "files": [
      {
        "sha": "30803996c9f5c1044e937578c05c8852e3c90e18",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/259bf92d4abbc8c2923754106ef965e959cfd053/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/259bf92d4abbc8c2923754106ef965e959cfd053/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=259bf92d4abbc8c2923754106ef965e959cfd053",
        "patch": "@@ -212,6 +212,7 @@ BITCOIN_CORE_H = \\\n   timedata.h \\\n   torcontrol.h \\\n   txdb.h \\\n+  txrequest.h \\\n   txmempool.h \\\n   undo.h \\\n   util/asmap.h \\\n@@ -323,6 +324,7 @@ libbitcoin_server_a_SOURCES = \\\n   timedata.cpp \\\n   torcontrol.cpp \\\n   txdb.cpp \\\n+  txrequest.cpp \\\n   txmempool.cpp \\\n   validation.cpp \\\n   validationinterface.cpp \\"
      },
      {
        "sha": "abd87703d7e2bdaff39635df4fda47eac235509e",
        "filename": "src/txrequest.cpp",
        "status": "added",
        "additions": 238,
        "deletions": 0,
        "changes": 238,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/259bf92d4abbc8c2923754106ef965e959cfd053/src/txrequest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/259bf92d4abbc8c2923754106ef965e959cfd053/src/txrequest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txrequest.cpp?ref=259bf92d4abbc8c2923754106ef965e959cfd053",
        "patch": "@@ -0,0 +1,238 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <random.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+PriorityComputer::PriorityComputer(bool deterministic) :\n+    m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+    m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+TxRequestTracker::TxRequestTracker(std::chrono::microseconds timeout, bool deterministic) :\n+    m_timeout(timeout),\n+    m_computer(deterministic),\n+    // Explicitly initialize m_index as we need to pass a reference to m_computer to\n+    // EntryTxidExtractor.\n+    m_index(boost::make_tuple(\n+        boost::make_tuple(\n+            boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>(),\n+            std::less<EntryPeer>()\n+        ),\n+        boost::make_tuple(\n+            EntryTxidExtractor(m_computer),\n+            std::less<EntryTxid>()\n+        ),\n+        boost::make_tuple(\n+            boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>(),\n+            std::less<EntryTime>()\n+        )\n+    )) {}\n+\n+void TxRequestTracker::PromoteCandidateNew(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it)\n+{\n+    assert(it->GetState() == State::CANDIDATE_DELAYED);\n+    // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+    Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+    // The following code relies on the fact that the ByTxid is sorted by txid, and then by state (first _DELAYED,\n+    // then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority) comes first.\n+    // Thus, if an existing _BEST exists for the same txid that this entry may be preferred over, it must immediately\n+    // precede the newly created _READY.\n+    if (it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != it->m_txid ||\n+        std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+        // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txid already.\n+        Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+    } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+        uint64_t priority_old = std::prev(it)->ComputePriority(m_computer);\n+        uint64_t priority_new = it->ComputePriority(m_computer);\n+        if (priority_new < priority_old) {\n+            // There is a CANDIDATE_BEST entry already, but this one is better.\n+            Modify<ByTxid>(std::prev(it), [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+            Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        }\n+    }\n+}\n+\n+void TxRequestTracker::ChangeAndReselect(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it,\n+    TxRequestTracker::State new_state)\n+{\n+    if (it->IsSelected()) {\n+        auto it_next = std::next(it);\n+        // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in the\n+        // ByTxid index.\n+        if (it_next != m_index.get<ByTxid>().end() && it_next->m_txid == it->m_txid &&\n+            it_next->GetState() == State::CANDIDATE_READY) {\n+            // If one such CANDIDATE_READY exists (for this txid), convert it to CANDIDATE_BEST.\n+            Modify<ByTxid>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        }\n+    }\n+    Modify<ByTxid>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+    assert(!it->IsSelected());\n+}\n+\n+bool TxRequestTracker::MakeCompleted(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it)\n+{\n+    // Nothing to be done if it's already COMPLETED.\n+    if (it->GetState() == State::COMPLETED) return true;\n+\n+    if ((it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != it->m_txid) &&\n+        (std::next(it) == m_index.get<ByTxid>().end() || std::next(it)->m_txid != it->m_txid ||\n+        std::next(it)->GetState() == State::COMPLETED)) {\n+        // This is the first entry for this txid, and the last non-COMPLETED one. There are only COMPLETED ones left.\n+        // Delete them all.\n+        uint256 txid = it->m_txid;\n+        do {\n+            it = Erase<ByTxid>(it);\n+        } while (it != m_index.get<ByTxid>().end() && it->m_txid == txid);\n+        return false;\n+    }\n+\n+    // Mark the entry COMPLETED, and select the best best entry if needed.\n+    ChangeAndReselect(it, State::COMPLETED);\n+\n+    return true;\n+}\n+\n+void TxRequestTracker::SetTimePoint(std::chrono::microseconds now)\n+{\n+    // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+    // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+    while (!m_index.empty()) {\n+        auto it = m_index.get<ByTime>().begin();\n+        if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+            PromoteCandidateNew(m_index.project<ByTxid>(it));\n+        } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+            MakeCompleted(m_index.project<ByTxid>(it));\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    while (!m_index.empty()) {\n+        // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+        // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+        // it makes it much easier to specify and test TxRequestTracker's behaviour.\n+        auto it = std::prev(m_index.get<ByTime>().end());\n+        if (it->IsSelectable() && it->m_time > now) {\n+            ChangeAndReselect(m_index.project<ByTxid>(it), State::CANDIDATE_DELAYED);\n+        } else {\n+            break;\n+        }\n+    }\n+}\n+\n+void TxRequestTracker::AlreadyHaveTx(const uint256& txid)\n+{\n+    auto it = m_index.get<ByTxid>().lower_bound(EntryTxid{txid, State::CANDIDATE_DELAYED, 0});\n+    while (it != m_index.get<ByTxid>().end() && it->m_txid == txid) {\n+        it = Erase<ByTxid>(it);\n+    }\n+}\n+\n+static const uint256 UINT256_ZERO;\n+\n+void TxRequestTracker::DeletedPeer(uint64_t peer)\n+{\n+    auto& index = m_index.get<ByPeer>();\n+    auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+    while (it != index.end() && it->m_peer == peer) {\n+        // Check what to continue with after this iteration. Note that 'it' may change position, and std::next(it)\n+        // may be deleted in the process, so this needs to be decided beforehand.\n+        auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ? index.end() : std::next(it);\n+        // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+        // CANDIDATE_BEST, or delete all of a txid's entries if no non-COMPLETED ones are left).\n+        if (MakeCompleted(m_index.project<ByTxid>(it))) {\n+            // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+            Erase<ByPeer>(it);\n+        }\n+        it = it_next;\n+    }\n+}\n+\n+void TxRequestTracker::ReceivedInv(uint64_t peer, const uint256& txid, std::chrono::microseconds reqtime)\n+{\n+    // Bail out if we already have a CANDIDATE_BEST entry for this (txid, peer) combination. The case where there is\n+    // a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index\n+    // automatically.\n+    if (m_index.get<ByPeer>().count(EntryPeer{peer, true, txid})) return;\n+\n+    auto ret = m_index.get<ByPeer>().emplace(txid, peer, reqtime, m_sequence);\n+    if (ret.second) {\n+        auto it = m_index.project<ByTxid>(ret.first);\n+        ++m_peerinfo[peer].m_total;\n+        ++m_sequence;\n+        if ((it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != txid) &&\n+            (std::next(it) == m_index.get<ByTxid>().end() || std::next(it)->m_txid != txid)) {\n+            // This is both the first and the last entry for a given txid; set its m_first.\n+            ret.first->m_first = true;\n+        }\n+    }\n+}\n+\n+void TxRequestTracker::RequestedTx(uint64_t peer, const uint256& txid, std::chrono::microseconds now)\n+{\n+    auto it = m_index.get<ByPeer>().find(EntryPeer{peer, true, txid});\n+    // RequestedTx can only be called on CANDIDATE_BEST entries (this is implied by its condition that it can only be\n+    // called on txids returned by GetRequestable (and only AlreadyHave and RequestedTx can be called in between,\n+    // which preserve the state of other txids).\n+    assert(it != m_index.get<ByPeer>().end());\n+    assert(it->GetState() == State::CANDIDATE_BEST);\n+    Modify<ByPeer>(it, [now,this](Entry& entry) {\n+        entry.SetState(State::REQUESTED);\n+        entry.m_time = now + m_timeout;\n+    });\n+}\n+\n+void TxRequestTracker::ReceivedResponse(uint64_t peer, const uint256& txid)\n+{\n+    // We need to search the ByPeer index for both (peer, false, txid) and (peer, true, txid).\n+    auto it = m_index.get<ByPeer>().find(EntryPeer{peer, false, txid});\n+    if (it == m_index.get<ByPeer>().end()) it = m_index.get<ByPeer>().find(EntryPeer{peer, true, txid});\n+    if (it != m_index.get<ByPeer>().end()) MakeCompleted(m_index.project<ByTxid>(it));\n+}\n+\n+size_t TxRequestTracker::CountInFlight(uint64_t peer) const\n+{\n+    auto it = m_peerinfo.find(peer);\n+    if (it != m_peerinfo.end()) return it->second.m_requested;\n+    return 0;\n+}\n+\n+size_t TxRequestTracker::CountTracked(uint64_t peer) const\n+{\n+    auto it = m_peerinfo.find(peer);\n+    if (it != m_peerinfo.end()) return it->second.m_total;\n+    return 0;\n+}\n+\n+std::vector<uint256> TxRequestTracker::GetRequestable(uint64_t peer, std::chrono::microseconds now)\n+{\n+    // Move time.\n+    SetTimePoint(now);\n+\n+    // Find all CANDIDATE_BEST entries for this peer.\n+    std::vector<std::pair<uint64_t, const uint256*>> selected;\n+    auto it_peer = m_index.get<ByPeer>().lower_bound(EntryPeer{peer, true, UINT256_ZERO});\n+    while (it_peer != m_index.get<ByPeer>().end() && it_peer->m_peer == peer &&\n+        it_peer->GetState() == State::CANDIDATE_BEST) {\n+        selected.emplace_back(it_peer->m_sequence, &it_peer->m_txid);\n+        ++it_peer;\n+    }\n+\n+    // Return them, sorted by sequence number.\n+    std::sort(selected.begin(), selected.end());\n+    std::vector<uint256> ret;\n+    for (auto& item : selected) {\n+        ret.push_back(*item.second);\n+    }\n+    return ret;\n+}"
      },
      {
        "sha": "8d580175a167d9048c664ce40d7a41e5140defd3",
        "filename": "src/txrequest.h",
        "status": "added",
        "additions": 347,
        "deletions": 0,
        "changes": 347,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/259bf92d4abbc8c2923754106ef965e959cfd053/src/txrequest.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/259bf92d4abbc8c2923754106ef965e959cfd053/src/txrequest.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txrequest.h?ref=259bf92d4abbc8c2923754106ef965e959cfd053",
        "patch": "@@ -0,0 +1,347 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Entries are called delayed if they have a reqtime different from std::chrono::microseconds::min(). This is the\n+ *   case for entries from inbound non-whitelisted nodes. The priority for delayed entries is always higher than\n+ *   non-delayed ones, so non-delayed ones are always preferred.\n+ * - Within the set of delayed peers and within the set of non-delayed peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool delayed, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t{delayed} << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among non-delayed peers, then delayed\n+ * ones whose delay has passed. When a NOTFOUND is received, an invalid transaction is received, or a download\n+ * times out (after a configurable delay), the next candidate is immediately scheduled according to the same rules\n+ * above. The same transaction is never re-requested from the same peer, unless the transaction was forgotten about\n+ * in the mean time. This happens whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed. The reqtime can std::chrono::microseconds::min() for immediate entries,\n+ *   or some timestamp in the future for delayed ones.\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer had a delay, immediate entries will always be\n+ *     picked first as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_DELAYED,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST.\n+        CANDIDATE_READY,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+    };\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxid-based index.\n+    struct ByTxid {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxid index is sorted by (txid, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+    using EntryTxid = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txid;\n+        //! For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the exptime\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 59;\n+        //! Whether the request was delayed (which deprioritizes it, even after reqtime has passed).\n+        const bool m_delayed : 1;\n+        //! What state this announcement is in\n+        //! This is a uint8_t instead of a State to silence a GCC warning.\n+        uint8_t m_state : 3;\n+        //! Whether this was the very first announcement for this txid.\n+        //! It's only modified right after insertion, at which point it doesn't affect position\n+        //! in any of the indexes. Make it mutable to enable changing without triggering reindex.\n+        mutable bool m_first : 1;\n+\n+        //! Convert the m_state variable to a State enum.\n+        State GetState() const { return State(m_state); }\n+        //! Convert a State to a uint8_t and store it in m_state.\n+        void SetState(State state) { m_state = uint8_t(state); }\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txid.\n+        bool IsSelected() const\n+        {\n+            return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+        }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const\n+        {\n+            return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+        }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const\n+        {\n+            return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+        }\n+\n+        //! Construct a new entry from scratch\n+        Entry(const uint256& txid, uint64_t peer, std::chrono::microseconds reqtime, uint64_t sequence) :\n+            m_txid(txid), m_time(reqtime), m_peer(peer), m_sequence(sequence),\n+            m_delayed(reqtime != std::chrono::microseconds::min()), m_state(uint8_t(State::CANDIDATE_DELAYED)),\n+            m_first(false) {}\n+\n+        //! Compute this Entry's priority.\n+        uint64_t ComputePriority(const PriorityComputer& computer) const\n+        {\n+            return computer(m_txid, m_peer, m_delayed, m_first);\n+        }\n+\n+        //! Extract the EntryPeer from this Entry.\n+        EntryPeer ExtractPeer() const { return EntryPeer{m_peer, GetState() == State::CANDIDATE_BEST, m_txid}; }\n+\n+        //! Extract the EntryTxid from this Entry.\n+        EntryTxid ExtractTxid(const PriorityComputer& computer) const\n+        {\n+            return EntryTxid{m_txid, GetState(), GetState() == State::CANDIDATE_READY ? ComputePriority(computer) : 0};\n+        }\n+\n+        //! Extract the EntryTime from this Entry.\n+        EntryTime ExtractTime() const { return EntryTime{IsWaiting() ? 0 : IsSelectable() ? 2 : 1, m_time}; }\n+    };\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    /** An extractor for EntryTxids (with encapsulated PriorityComputer reference).\n+     *\n+     * See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+     * for more information about the key extraction concept.\n+     */\n+    struct EntryTxidExtractor {\n+    private:\n+        const PriorityComputer& m_computer;\n+    public:\n+        EntryTxidExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+        using result_type = EntryTxid; // Needed to comply with key extractor interface\n+        result_type operator()(const Entry& entry) const { return entry.ExtractTxid(m_computer); }\n+    };\n+\n+    //! Data type for the main data structure (Entry objects with ByPeer/ByTxid/ByTime indexes).\n+    using Index = boost::multi_index_container<\n+        Entry,\n+        boost::multi_index::indexed_by<\n+            boost::multi_index::ordered_unique<\n+                boost::multi_index::tag<ByPeer>,\n+                boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTxid>,\n+                EntryTxidExtractor\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTime>,\n+                boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>\n+            >\n+        >\n+    >;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Per-peer statistics object.\n+    struct PeerInfo {\n+        size_t m_total = 0; //!< Total number of entries for this peer.\n+        size_t m_requested = 0; //!< Total number of REQUESTED entries for this peer.\n+\n+        friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+        {\n+            return std::tie(a.m_total, a.m_requested) == std::tie(b.m_total, b.m_requested);\n+        }\n+    };\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    typename Index::index<Tag>::type::iterator Erase(typename Index::index<Tag>::type::iterator it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(typename Index::index<Tag>::type::iterator it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(typename Index::index<ByTxid>::type::iterator it, State new_state);\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY (and no\n+    //! REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateNew(typename Index::index<ByTxid>::type::iterator it);\n+\n+    //! Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txid, they are all\n+    //! deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+    //! CANDIDATE_BEST. Returns whether the Entry still exists.\n+    bool MakeCompleted(typename Index::index<ByTxid>::type::iterator it);\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with exptime <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now);\n+\n+public:\n+    //! Construct a TxRequestTracker with the specified parameters.\n+    TxRequestTracker(std::chrono::microseconds timeout, bool deterministic = false);\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxidExtractor).\n+    TxRequestTracker(const TxRequestTracker&) = delete;\n+    TxRequestTracker& operator=(const TxRequestTracker&) = delete;\n+\n+    //! A peer went offline, delete any data related to it.\n+    void DeletedPeer(uint64_t uint64_t);\n+\n+    //! For whatever reason, we no longer need this txid. Delete any data related to it.\n+    void AlreadyHaveTx(const uint256& txid);\n+\n+    //! We received a new inv, enter it into the data structure.\n+    void ReceivedInv(uint64_t peer, const uint256& txid, std::chrono::microseconds reqtime);\n+\n+    //! Find the txids to request now from peer.\n+    std::vector<uint256> GetRequestable(uint64_t peer, std::chrono::microseconds now);\n+\n+    //! Inform the data structure that a txid was requested. This can only be called for txids returned by the last\n+    //! GetRequestable call (which must have been for the same peer), with only other RequestedTx and AlreadyHaveTx\n+    //! calls in between (which must have been for the same peer but different txids).\n+    void RequestedTx(uint64_t peer, const uint256& txid, std::chrono::microseconds now);\n+\n+    //! We received a response (a tx, or a NOTFOUND) for txid from peer. Note that if a good tx is received (such\n+    //! that we don't need it anymore), AlreadyHaveTx should be called instead of (or in addition to)\n+    //! ReceivedResponse.\n+    void ReceivedResponse(uint64_t peer, const uint256& txid);\n+\n+    //! Count how many in-flight transactions a peer has.\n+    size_t CountInFlight(uint64_t peer) const;\n+\n+    //! Count how many transactions are being tracked for a peer (including timed-out ones and in-flight ones).\n+    size_t CountTracked(uint64_t peer) const;\n+\n+    //! Count how many announcements are being tracked in total across all peers and transactions.\n+    size_t Size() const { return m_index.size(); }\n+\n+    //! Query configuration parameter timeout.\n+    std::chrono::microseconds GetTimeout() const { return m_timeout; }\n+};\n+\n+#endif // BITCOIN_TXREQUEST_H"
      },
      {
        "sha": "a8e859d12f6c8b4735f4c725381366f88614413e",
        "filename": "test/lint/lint-includes.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/259bf92d4abbc8c2923754106ef965e959cfd053/test/lint/lint-includes.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/259bf92d4abbc8c2923754106ef965e959cfd053/test/lint/lint-includes.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/lint/lint-includes.sh?ref=259bf92d4abbc8c2923754106ef965e959cfd053",
        "patch": "@@ -58,6 +58,7 @@ EXPECTED_BOOST_INCLUDES=(\n     boost/filesystem/fstream.hpp\n     boost/multi_index/hashed_index.hpp\n     boost/multi_index/ordered_index.hpp\n+    boost/multi_index/mem_fun.hpp\n     boost/multi_index/sequenced_index.hpp\n     boost/multi_index_container.hpp\n     boost/optional.hpp"
      }
    ]
  },
  {
    "sha": "75fd5dcba5441b0710aa348baa014f41df3e8458",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3NWZkNWRjYmE1NDQxYjA3MTBhYTM0OGJhYTAxNGY0MWRmM2U4NDU4",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-06-06T02:59:12Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-07-21T00:37:16Z"
      },
      "message": "Add txrequest unit tests",
      "tree": {
        "sha": "def5324e212266ad288eecb63060f35621bfdbbc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/def5324e212266ad288eecb63060f35621bfdbbc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/75fd5dcba5441b0710aa348baa014f41df3e8458",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/75fd5dcba5441b0710aa348baa014f41df3e8458",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/75fd5dcba5441b0710aa348baa014f41df3e8458",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/75fd5dcba5441b0710aa348baa014f41df3e8458/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "259bf92d4abbc8c2923754106ef965e959cfd053",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/259bf92d4abbc8c2923754106ef965e959cfd053",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/259bf92d4abbc8c2923754106ef965e959cfd053"
      }
    ],
    "stats": {
      "total": 331,
      "additions": 331,
      "deletions": 0
    },
    "files": [
      {
        "sha": "3b7105943724c83c2ebb4cf9cbadd24beb047ef6",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/75fd5dcba5441b0710aa348baa014f41df3e8458/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/75fd5dcba5441b0710aa348baa014f41df3e8458/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=75fd5dcba5441b0710aa348baa014f41df3e8458",
        "patch": "@@ -270,6 +270,7 @@ BITCOIN_TESTS =\\\n   test/torcontrol_tests.cpp \\\n   test/transaction_tests.cpp \\\n   test/txindex_tests.cpp \\\n+  test/txrequest_tests.cpp \\\n   test/txvalidation_tests.cpp \\\n   test/txvalidationcache_tests.cpp \\\n   test/uint256_tests.cpp \\"
      },
      {
        "sha": "c5808e47080ab59b4cae90e455c32854e6b41009",
        "filename": "src/test/txrequest_tests.cpp",
        "status": "added",
        "additions": 237,
        "deletions": 0,
        "changes": 237,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/75fd5dcba5441b0710aa348baa014f41df3e8458/src/test/txrequest_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/75fd5dcba5441b0710aa348baa014f41df3e8458/src/test/txrequest_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txrequest_tests.cpp?ref=75fd5dcba5441b0710aa348baa014f41df3e8458",
        "patch": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txrequest_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+constexpr std::chrono::microseconds TEST_TIMEOUT = std::chrono::minutes{2};\n+constexpr std::chrono::microseconds TEST_DELAY = std::chrono::seconds{2};\n+\n+constexpr std::chrono::microseconds ReqTime(std::chrono::microseconds now, bool delay)\n+{\n+    return delay ? now + TEST_DELAY : std::chrono::microseconds::min();\n+}\n+\n+constexpr int TEST_ITERATIONS = 1000;\n+\n+uint256 GenTxid(const TxRequestTracker& tracker, const std::vector<uint64_t>& order)\n+{\n+    const auto& computer = tracker.GetPriorityComputer();\n+\n+    uint256 ret;\n+    bool ok;\n+    do {\n+        ret = InsecureRand256();\n+\n+        ok = true;\n+        for (size_t pos = 1; pos < order.size(); ++pos) {\n+            if (computer(ret, order[pos - 1], true, false) >= computer(ret, order[pos], true, false)) {\n+                ok = false;\n+                break;\n+            }\n+        }\n+    } while(!ok);\n+\n+    return ret;\n+}\n+\n+std::vector<uint64_t> GenPeers(size_t num)\n+{\n+    std::set<uint64_t> retset;\n+    while (retset.size() < num) {\n+        retset.insert(InsecureRandBits(63));\n+    }\n+\n+    std::vector<uint64_t> ret(retset.begin(), retset.end());\n+    Shuffle(ret.begin(), ret.end(), g_insecure_rand_ctx);\n+    return ret;\n+}\n+\n+std::chrono::microseconds RandomTime(int bits=44) { return std::chrono::microseconds{InsecureRandBits(bits)}; }\n+\n+void CheckRequestable(TxRequestTracker& tracker, uint64_t peer, std::chrono::microseconds now, const std::vector<uint256>& expected)\n+{\n+    BOOST_CHECK(tracker.GetRequestable(peer, now) == expected);\n+    tracker.SanityCheck();\n+    tracker.TimeSanityCheck(now);\n+}\n+\n+void TestBasicNonDelayed()\n+{\n+    TxRequestTracker tracker(TEST_TIMEOUT);\n+    auto peers = GenPeers(1);\n+    auto txid = GenTxid(tracker, {});\n+    auto now = RandomTime();\n+\n+    tracker.ReceivedInv(peers[0], txid, ReqTime(now, false)); // Announce from non-delayed peer\n+    CheckRequestable(tracker, peers[0], now, {txid}); // Becomes requestable immediately.\n+    BOOST_CHECK_EQUAL(tracker.Size(), 1U);\n+}\n+\n+void TestBasicDelayed()\n+{\n+    TxRequestTracker tracker(TEST_TIMEOUT);\n+    auto peers = GenPeers(1);\n+    auto txid = GenTxid(tracker, {});\n+    auto now = RandomTime();\n+\n+    tracker.ReceivedInv(peers[0], txid, ReqTime(now, true)); // Announce from delayed peer\n+    CheckRequestable(tracker, peers[0], now, {}); // Does not become requestable immediately.\n+    now += TEST_DELAY - std::chrono::microseconds{1};\n+    CheckRequestable(tracker, peers[0], now, {}); // Does not become requestable after 1.999999s.\n+    now += std::chrono::microseconds{1};\n+    CheckRequestable(tracker, peers[0], now, {txid}); // Does become requestable after 2s.\n+    BOOST_CHECK_EQUAL(tracker.Size(), 1U);\n+}\n+\n+void TestFirstAnnouncementWins(bool delay)\n+{\n+    TxRequestTracker tracker(TEST_TIMEOUT);\n+    auto peers = GenPeers(2);\n+    auto txid = GenTxid(tracker, {});\n+    auto now = RandomTime();\n+\n+    tracker.ReceivedInv(peers[0], txid, ReqTime(now, delay)); // Announce from peer 0\n+    tracker.ReceivedInv(peers[1], txid, ReqTime(now, delay)); // Announce from peer 1\n+    if (delay) now += TEST_DELAY;\n+    CheckRequestable(tracker, peers[0], now, {txid}); // Becomes requestable immediately from peer 0.\n+    CheckRequestable(tracker, peers[1], now, {}); // And not from peer 1 (very first announcement always wins)\n+    BOOST_CHECK_EQUAL(tracker.Size(), 2U);\n+}\n+\n+void TestNoDelayPreference()\n+{\n+    TxRequestTracker tracker(TEST_TIMEOUT);\n+    auto peers = GenPeers(2);\n+    auto txid = GenTxid(tracker, {});\n+    auto now = RandomTime();\n+\n+    tracker.ReceivedInv(peers[0], txid, ReqTime(now, true)); // Announce from delayed peer 0\n+    CheckRequestable(tracker, peers[0], now, {}); // Does not become requestable\n+    now += TEST_DELAY;\n+    CheckRequestable(tracker, peers[0], now, {txid}); // Becomes requestable after enough time\n+    now += RandomTime(32);\n+    CheckRequestable(tracker, peers[0], now, {txid}); // Remains requestable after arbitrary amounts of time\n+    tracker.ReceivedInv(peers[1], txid, ReqTime(now, false)); // Then announced by non-delayed peer 1\n+    CheckRequestable(tracker, peers[1], now, {txid}); // Immediately becomes requestable from peer 1 (non-delayed)\n+    CheckRequestable(tracker, peers[0], now, {}); // And stops being requestable from peer 0 (can only be assigned to one peer)\n+    BOOST_CHECK_EQUAL(tracker.Size(), 2U);\n+}\n+\n+void TestPriorityPreference(bool delay, int remove_reason)\n+{\n+    TxRequestTracker tracker(TEST_TIMEOUT);\n+    auto peers = GenPeers(3);\n+    auto txid = GenTxid(tracker, {peers[1], peers[2]}); // A txid such that peer 1 is prioritized over peer 2\n+    auto now = RandomTime();\n+\n+    tracker.ReceivedInv(peers[0], txid, ReqTime(now, delay)); // Announce from peer 0\n+    now += std::chrono::microseconds{1};\n+    tracker.ReceivedInv(peers[2], txid, ReqTime(now, delay)); // Slightly later, announce from peer 2\n+    now += std::chrono::microseconds{1};\n+    tracker.ReceivedInv(peers[1], txid, ReqTime(now, delay)); // Even later, announce from peer 1\n+    if (delay) now += TEST_DELAY;\n+    CheckRequestable(tracker, peers[0], now, {txid}); // As peer 0 was the very first to announce, it gets the request first\n+    CheckRequestable(tracker, peers[1], now, {});\n+    CheckRequestable(tracker, peers[2], now, {});\n+    if (remove_reason == 0) {\n+        tracker.DeletedPeer(peers[0]);\n+    } else if (remove_reason == 1) {\n+        tracker.RequestedTx(peers[0], txid, now);\n+        now += TEST_TIMEOUT;\n+    } else if (remove_reason == 2) {\n+        tracker.RequestedTx(peers[0], txid, now);\n+        tracker.ReceivedResponse(peers[0], txid);\n+    }\n+\n+    CheckRequestable(tracker, peers[0], now, {}); // If peer 0 goes offline, or the request times out, or a NOTFOUND is received, does peer 1 gets it (despite peer 2 being earlier)\n+    CheckRequestable(tracker, peers[1], now, {txid});\n+    CheckRequestable(tracker, peers[2], now, {});\n+    if (remove_reason == 0) {\n+        tracker.DeletedPeer(peers[1]);\n+    } else if (remove_reason == 1) {\n+        tracker.RequestedTx(peers[1], txid, now);\n+        now += TEST_TIMEOUT;\n+    } else if (remove_reason == 2) {\n+        tracker.RequestedTx(peers[1], txid, now);\n+        tracker.ReceivedResponse(peers[1], txid);\n+    }\n+    CheckRequestable(tracker, peers[0], now, {}); // Only if peer 1 also goes offline, or the request times out, does peer 2 get it.\n+    CheckRequestable(tracker, peers[1], now, {});\n+    CheckRequestable(tracker, peers[2], now, {txid});\n+}\n+\n+void TestOrderDependsOnPeers(bool delay)\n+{\n+    TxRequestTracker tracker(TEST_TIMEOUT);\n+    auto peers = GenPeers(3);\n+    auto txid1 = GenTxid(tracker, {peers[1], peers[2]}); // A txid such that peer 1 is prioritized over peer 2\n+    auto txid2 = GenTxid(tracker, {peers[2], peers[1]}); // A txid such that peer 2 is prioritized over peer 1\n+    auto now = RandomTime();\n+\n+    for (auto peer : peers) {\n+        tracker.ReceivedInv(peer, txid1, ReqTime(now, delay)); // Announce both txids for all peers\n+        tracker.ReceivedInv(peer, txid2, ReqTime(now, delay));\n+    }\n+    if (delay) now += TEST_DELAY;\n+    CheckRequestable(tracker, peers[0], now, {txid1, txid2}); // Both are requestable\n+    tracker.DeletedPeer(peers[0]); // Peer 0 goes offline\n+    CheckRequestable(tracker, peers[1], now, {txid1}); // txid1 is now requestable from peer 1\n+    CheckRequestable(tracker, peers[2], now, {txid2}); // While txid2 is now requestable from peer 2\n+}\n+\n+void TestRequestableOrder(bool delay)\n+{\n+    TxRequestTracker tracker(TEST_TIMEOUT);\n+    auto peers = GenPeers(2);\n+    auto txid1 = GenTxid(tracker, {});\n+    auto txid2 = GenTxid(tracker, {});\n+    auto now = RandomTime();\n+\n+    tracker.ReceivedInv(peers[0], txid1, ReqTime(now, delay));\n+    tracker.ReceivedInv(peers[0], txid2, ReqTime(now, delay));\n+    tracker.ReceivedInv(peers[1], txid2, ReqTime(now, delay));\n+    now -= std::chrono::microseconds{1};\n+    tracker.ReceivedInv(peers[1], txid1, ReqTime(now, delay));\n+    if (delay) now += TEST_DELAY;\n+    now += std::chrono::microseconds{1};\n+    CheckRequestable(tracker, peers[0], now, {txid1, txid2}); // Check that for each peer, requests go out in announcement order,\n+    tracker.DeletedPeer(peers[0]);\n+    CheckRequestable(tracker, peers[1], now, {txid2, txid1}); // even when the clock went backwards during announcements.\n+}\n+\n+void TestAll()\n+{\n+    TestBasicNonDelayed();\n+    TestBasicDelayed();\n+    TestNoDelayPreference();\n+    for (int delay = 0; delay < 2; ++delay) {\n+        TestFirstAnnouncementWins(delay);\n+        TestOrderDependsOnPeers(delay);\n+        TestRequestableOrder(delay);\n+        for (int reason = 0; reason < 3; ++reason) {\n+            TestPriorityPreference(delay, reason);\n+        }\n+    }\n+}\n+\n+}\n+\n+BOOST_AUTO_TEST_CASE(TxRequestTest)\n+{\n+    for (int i = 0; i < TEST_ITERATIONS; ++i) TestAll();\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "6864873158e0d3c1d0b0d556c0be25ad0ca8b52b",
        "filename": "src/txrequest.cpp",
        "status": "modified",
        "additions": 84,
        "deletions": 0,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/75fd5dcba5441b0710aa348baa014f41df3e8458/src/txrequest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/75fd5dcba5441b0710aa348baa014f41df3e8458/src/txrequest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txrequest.cpp?ref=75fd5dcba5441b0710aa348baa014f41df3e8458",
        "patch": "@@ -236,3 +236,87 @@ std::vector<uint256> TxRequestTracker::GetRequestable(uint64_t peer, std::chrono\n     }\n     return ret;\n }\n+\n+void TxRequestTracker::SanityCheck() const\n+{\n+    // Recompute m_peerdata.\n+    // This verifies the data in it, including the invariant\n+    // that no entries with m_total_announcements==0 exist.\n+    std::unordered_map<uint64_t, PeerInfo> peerinfo;\n+    for (const auto& a : m_index) {\n+        auto& entry = peerinfo[a.m_peer];\n+        ++entry.m_total;\n+        entry.m_requested += (a.GetState() == State::REQUESTED);\n+    }\n+    assert(m_peerinfo == peerinfo);\n+\n+    struct Counts {\n+        //! Number of CANDIDATE_DELAYED entries for this txid.\n+        int m_candidate_delayed = 0;\n+        //! Number of CANDIDATE_READY entries for this txid.\n+        int m_candidate_ready = 0;\n+        //! Number of CANDIDATE_BEST entries for this txid (at most one).\n+        int m_candidate_best = 0;\n+        //! Number of REQUESTED entries for this txid.\n+        int m_requested = 0;\n+        //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+        uint64_t m_priority_candidate_best = 0;\n+        //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+        uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+        //! All peers we have an entry for this txid for.\n+        std::vector<uint64_t> m_peers;\n+    };\n+\n+    std::map<uint256, Counts> table;\n+    for (const auto& a : m_index) {\n+        auto& entry = table[a.m_txid];\n+        // Classify how many types peers we have for this txid.\n+        entry.m_candidate_delayed += (a.GetState() == State::CANDIDATE_DELAYED);\n+        entry.m_candidate_ready += (a.GetState() == State::CANDIDATE_READY);\n+        entry.m_candidate_best += (a.GetState() == State::CANDIDATE_BEST);\n+        entry.m_requested += (a.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (a.GetState() == State::CANDIDATE_BEST) entry.m_priority_candidate_best = a.ComputePriority(m_computer);\n+        if (a.GetState() == State::CANDIDATE_READY) {\n+            entry.m_priority_best_candidate_ready = std::min(entry.m_priority_best_candidate_ready,\n+                a.ComputePriority(m_computer));\n+        }\n+        // Also keep track of which peers this txid has an entry for (so we can detect duplicates).\n+        entry.m_peers.push_back(a.m_peer);\n+    }\n+    for (auto& entry : table) {\n+        // Cannot have only COMPLETED peers (txid should have been deleted)\n+        assert(entry.second.m_candidate_delayed + entry.second.m_candidate_ready + entry.second.m_candidate_best +\n+            entry.second.m_requested > 0);\n+        // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+        assert(entry.second.m_candidate_best + entry.second.m_requested <= 1);\n+        // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED entry.\n+        if (entry.second.m_candidate_ready > 0) {\n+            assert(entry.second.m_candidate_best + entry.second.m_requested == 1);\n+        }\n+        // If there is both a CANDIDATE_READY and a CANDIDATE_BEST entry, the CANDIDATE_BEST one must be at least\n+        // as good as the best CANDIDATE_READY.\n+        if (entry.second.m_candidate_ready && entry.second.m_candidate_best) {\n+            assert(entry.second.m_priority_candidate_best <= entry.second.m_priority_best_candidate_ready);\n+        }\n+        // Detect duplicate (peer, txid) entries\n+        std::sort(entry.second.m_peers.begin(), entry.second.m_peers.end());\n+        assert(std::adjacent_find(entry.second.m_peers.begin(), entry.second.m_peers.end()) ==\n+            entry.second.m_peers.end());\n+    }\n+}\n+\n+void TxRequestTracker::TimeSanityCheck(std::chrono::microseconds now) const\n+{\n+    for (const auto& entry : m_index) {\n+        if (entry.IsWaiting()) {\n+            // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted to\n+            // COMPLETED/CANDIDATE_READY respectively).\n+            assert(entry.m_time > now);\n+        } else if (entry.IsSelectable()) {\n+            // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+            // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+            assert(entry.m_time <= now);\n+        }\n+    }\n+}"
      },
      {
        "sha": "c937e15bc822251a6c6e073da6e63932e10c80bd",
        "filename": "src/txrequest.h",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/75fd5dcba5441b0710aa348baa014f41df3e8458/src/txrequest.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/75fd5dcba5441b0710aa348baa014f41df3e8458/src/txrequest.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txrequest.h?ref=75fd5dcba5441b0710aa348baa014f41df3e8458",
        "patch": "@@ -342,6 +342,15 @@ class TxRequestTracker {\n \n     //! Query configuration parameter timeout.\n     std::chrono::microseconds GetTimeout() const { return m_timeout; }\n+\n+    //! Access to the internal PriorityComputer (for testing)\n+    const PriorityComputer& GetPriorityComputer() const { return m_computer; }\n+\n+    //! Run internal consistency check (test only)\n+    void SanityCheck() const;\n+\n+    //! Run a time-dependent consistency check (only expected to hold after GetRequestable; test only)\n+    void TimeSanityCheck(std::chrono::microseconds now) const;\n };\n \n #endif // BITCOIN_TXREQUEST_H"
      }
    ]
  },
  {
    "sha": "4f4f2f2de6b7f7f3f941ef92553c9bddfaccbd92",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ZjRmMmYyZGU2YjdmN2YzZjk0MWVmOTI1NTNjOWJkZGZhY2NiZDky",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-06-06T02:59:20Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-07-21T00:41:14Z"
      },
      "message": "Switch net_processing over to txrequest-based fetching",
      "tree": {
        "sha": "0702e445988f3f30b3e67a5e74710bd3a61c2580",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0702e445988f3f30b3e67a5e74710bd3a61c2580"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4f4f2f2de6b7f7f3f941ef92553c9bddfaccbd92",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4f4f2f2de6b7f7f3f941ef92553c9bddfaccbd92",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4f4f2f2de6b7f7f3f941ef92553c9bddfaccbd92",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4f4f2f2de6b7f7f3f941ef92553c9bddfaccbd92/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "75fd5dcba5441b0710aa348baa014f41df3e8458",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/75fd5dcba5441b0710aa348baa014f41df3e8458",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/75fd5dcba5441b0710aa348baa014f41df3e8458"
      }
    ],
    "stats": {
      "total": 264,
      "additions": 29,
      "deletions": 235
    },
    "files": [
      {
        "sha": "032604103f7d03015d0b1461de9848bf5184be9a",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4f4f2f2de6b7f7f3f941ef92553c9bddfaccbd92/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4f4f2f2de6b7f7f3f941ef92553c9bddfaccbd92/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=4f4f2f2de6b7f7f3f941ef92553c9bddfaccbd92",
        "patch": "@@ -13,7 +13,6 @@\n #include <compat.h>\n #include <crypto/siphash.h>\n #include <hash.h>\n-#include <limitedmap.h>\n #include <netaddress.h>\n #include <net_permissions.h>\n #include <policy/feerate.h>"
      },
      {
        "sha": "fe07d77484bfe672a5395e7c4947d4e9ec4e82bc",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 194,
        "changes": 220,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4f4f2f2de6b7f7f3f941ef92553c9bddfaccbd92/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4f4f2f2de6b7f7f3f941ef92553c9bddfaccbd92/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=4f4f2f2de6b7f7f3f941ef92553c9bddfaccbd92",
        "patch": "@@ -25,6 +25,7 @@\n #include <scheduler.h>\n #include <tinyformat.h>\n #include <txmempool.h>\n+#include <txrequest.h>\n #include <util/check.h> // For NDEBUG compile time check\n #include <util/strencodings.h>\n #include <util/system.h>\n@@ -71,20 +72,12 @@ static constexpr std::chrono::minutes PING_INTERVAL{2};\n static const unsigned int MAX_LOCATOR_SZ = 101;\n /** The maximum number of entries in an 'inv' protocol message */\n static const unsigned int MAX_INV_SZ = 50000;\n-/** Maximum number of in-flight transactions from a peer */\n-static constexpr int32_t MAX_PEER_TX_IN_FLIGHT = 100;\n /** Maximum number of announced transactions from a peer */\n static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 2 * MAX_INV_SZ;\n /** How many microseconds to delay requesting transactions from inbound peers */\n static constexpr std::chrono::microseconds INBOUND_PEER_TX_DELAY{std::chrono::seconds{2}};\n /** How long to wait (in microseconds) before downloading a transaction from an additional peer */\n static constexpr std::chrono::microseconds GETDATA_TX_INTERVAL{std::chrono::seconds{60}};\n-/** Maximum delay (in microseconds) for transaction requests to avoid biasing some peers over others. */\n-static constexpr std::chrono::microseconds MAX_GETDATA_RANDOM_DELAY{std::chrono::seconds{2}};\n-/** How long to wait (in microseconds) before expiring an in-flight getdata request to a peer */\n-static constexpr std::chrono::microseconds TX_EXPIRY_INTERVAL{GETDATA_TX_INTERVAL * 10};\n-static_assert(INBOUND_PEER_TX_DELAY >= MAX_GETDATA_RANDOM_DELAY,\n-\"To preserve security, MAX_GETDATA_RANDOM_DELAY should not exceed INBOUND_PEER_DELAY\");\n /** Limit to avoid sending big packets. Not used in processing incoming GETDATA for compatibility */\n static const unsigned int MAX_GETDATA_SZ = 1000;\n /** Number of blocks that can be requested at any given time from a single peer. */\n@@ -337,69 +330,6 @@ struct CNodeState {\n     //! Time of last new block announcement\n     int64_t m_last_block_announcement;\n \n-    /*\n-     * State associated with transaction download.\n-     *\n-     * Tx download algorithm:\n-     *\n-     *   When inv comes in, queue up (process_time, txid) inside the peer's\n-     *   CNodeState (m_tx_process_time) as long as m_tx_announced for the peer\n-     *   isn't too big (MAX_PEER_TX_ANNOUNCEMENTS).\n-     *\n-     *   The process_time for a transaction is set to nNow for outbound peers,\n-     *   nNow + 2 seconds for inbound peers. This is the time at which we'll\n-     *   consider trying to request the transaction from the peer in\n-     *   SendMessages(). The delay for inbound peers is to allow outbound peers\n-     *   a chance to announce before we request from inbound peers, to prevent\n-     *   an adversary from using inbound connections to blind us to a\n-     *   transaction (InvBlock).\n-     *\n-     *   When we call SendMessages() for a given peer,\n-     *   we will loop over the transactions in m_tx_process_time, looking\n-     *   at the transactions whose process_time <= nNow. We'll request each\n-     *   such transaction that we don't have already and that hasn't been\n-     *   requested from another peer recently, up until we hit the\n-     *   MAX_PEER_TX_IN_FLIGHT limit for the peer. Then we'll update\n-     *   g_already_asked_for for each requested txid, storing the time of the\n-     *   GETDATA request. We use g_already_asked_for to coordinate transaction\n-     *   requests amongst our peers.\n-     *\n-     *   For transactions that we still need but we have already recently\n-     *   requested from some other peer, we'll reinsert (process_time, txid)\n-     *   back into the peer's m_tx_process_time at the point in the future at\n-     *   which the most recent GETDATA request would time out (ie\n-     *   GETDATA_TX_INTERVAL + the request time stored in g_already_asked_for).\n-     *   We add an additional delay for inbound peers, again to prefer\n-     *   attempting download from outbound peers first.\n-     *   We also add an extra small random delay up to 2 seconds\n-     *   to avoid biasing some peers over others. (e.g., due to fixed ordering\n-     *   of peer processing in ThreadMessageHandler).\n-     *\n-     *   When we receive a transaction from a peer, we remove the txid from the\n-     *   peer's m_tx_in_flight set and from their recently announced set\n-     *   (m_tx_announced).  We also clear g_already_asked_for for that entry, so\n-     *   that if somehow the transaction is not accepted but also not added to\n-     *   the reject filter, then we will eventually redownload from other\n-     *   peers.\n-     */\n-    struct TxDownloadState {\n-        /* Track when to attempt download of announced transactions (process\n-         * time in micros -> txid)\n-         */\n-        std::multimap<std::chrono::microseconds, uint256> m_tx_process_time;\n-\n-        //! Store all the transactions a peer has recently announced\n-        std::set<uint256> m_tx_announced;\n-\n-        //! Store transactions which were requested by us, with timestamp\n-        std::map<uint256, std::chrono::microseconds> m_tx_in_flight;\n-\n-        //! Periodically check for stuck getdata requests\n-        std::chrono::microseconds m_check_expiry_timer{0};\n-    };\n-\n-    TxDownloadState m_tx_download;\n-\n     //! Whether this peer is an inbound connection\n     bool m_is_inbound;\n \n@@ -440,8 +370,7 @@ struct CNodeState {\n     }\n };\n \n-// Keeps track of the time (in microseconds) when transactions were requested last time\n-limitedmap<uint256, std::chrono::microseconds> g_already_asked_for GUARDED_BY(cs_main)(MAX_INV_SZ);\n+static TxRequestTracker g_txrequest GUARDED_BY(cs_main) {GETDATA_TX_INTERVAL};\n \n /** Map maintaining per-node state. */\n static std::map<NodeId, CNodeState> mapNodeState GUARDED_BY(cs_main);\n@@ -736,66 +665,19 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const uint256& txid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(txid);\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const uint256& txid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(txid);\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const uint256& txid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(txid);\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(txid, request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const uint256& txid, std::chrono::microseconds current_time, bool use_inbound_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(txid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    return process_time;\n-}\n-\n-void RequestTx(CNodeState* state, const uint256& txid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void RequestTx(CNode& node, const uint256& txid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(txid)) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    if (g_txrequest.CountTracked(node.GetId()) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(txid);\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(txid, current_time, !state->fPreferredDownload);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, txid);\n+    // Requests from non-preferred peers are delayed by INBOUND_PEER_TX_DELAY.\n+    auto delay = std::chrono::microseconds{0};\n+    if (!State(node.GetId())->fPreferredDownload) {\n+        delay += INBOUND_PEER_TX_DELAY;\n+    }\n+    auto reqtime = delay.count() ? current_time + delay : std::chrono::microseconds::min();\n+    g_txrequest.ReceivedInv(node.GetId(), txid, reqtime);\n }\n \n } // namespace\n@@ -864,6 +746,7 @@ void PeerLogicValidation::FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTim\n         mapBlocksInFlight.erase(entry.hash);\n     }\n     EraseOrphansFor(nodeid);\n+    g_txrequest.DeletedPeer(nodeid);\n     nPreferredDownload -= state->fPreferredDownload;\n     nPeersWithValidatedDownloads -= (state->nBlocksInFlightValidHeaders != 0);\n     assert(nPeersWithValidatedDownloads >= 0);\n@@ -2599,7 +2482,7 @@ void ProcessMessage(\n                     pfrom.fDisconnect = true;\n                     return;\n                 } else if (!fAlreadyHave && !chainman.ActiveChainstate().IsInitialBlockDownload()) {\n-                    RequestTx(State(pfrom.GetId()), inv.hash, current_time);\n+                    RequestTx(pfrom, inv.hash, current_time);\n                 }\n             }\n         }\n@@ -2839,10 +2722,7 @@ void ProcessMessage(\n \n         TxValidationState state;\n \n-        CNodeState* nodestate = State(pfrom.GetId());\n-        nodestate->m_tx_download.m_tx_announced.erase(inv.hash);\n-        nodestate->m_tx_download.m_tx_in_flight.erase(inv.hash);\n-        EraseTxRequest(inv.hash);\n+        g_txrequest.ReceivedResponse(pfrom.GetId(), inv.hash);\n \n         std::list<CTransactionRef> lRemovedTxn;\n \n@@ -2885,7 +2765,7 @@ void ProcessMessage(\n                 for (const CTxIn& txin : tx.vin) {\n                     CInv _inv(MSG_TX | nFetchFlags, txin.prevout.hash);\n                     pfrom.AddInventoryKnown(_inv);\n-                    if (!AlreadyHave(_inv, mempool)) RequestTx(State(pfrom.GetId()), _inv.hash, current_time);\n+                    if (!AlreadyHave(_inv, mempool)) RequestTx(pfrom, _inv.hash, current_time);\n                 }\n                 AddOrphanTx(ptx, pfrom.GetId());\n \n@@ -3559,22 +3439,14 @@ void ProcessMessage(\n     if (msg_type == NetMsgType::NOTFOUND) {\n         // Remove the NOTFOUND transactions from the peer\n         LOCK(cs_main);\n-        CNodeState *state = State(pfrom.GetId());\n         std::vector<CInv> vInv;\n         vRecv >> vInv;\n-        if (vInv.size() <= MAX_PEER_TX_IN_FLIGHT + MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n+        if (vInv.size() <= MAX_PEER_TX_ANNOUNCEMENTS + MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n             for (CInv &inv : vInv) {\n                 if (inv.type == MSG_TX || inv.type == MSG_WITNESS_TX) {\n                     // If we receive a NOTFOUND message for a txid we requested, erase\n                     // it from our data structures for this peer.\n-                    auto in_flight_it = state->m_tx_download.m_tx_in_flight.find(inv.hash);\n-                    if (in_flight_it == state->m_tx_download.m_tx_in_flight.end()) {\n-                        // Skip any further work if this is a spurious NOTFOUND\n-                        // message.\n-                        continue;\n-                    }\n-                    state->m_tx_download.m_tx_in_flight.erase(in_flight_it);\n-                    state->m_tx_download.m_tx_announced.erase(inv.hash);\n+                    g_txrequest.ReceivedResponse(pfrom.GetId(), inv.hash);\n                 }\n             }\n         }\n@@ -4349,59 +4221,19 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n         //\n         // Message: getdata (non-blocks)\n         //\n-\n-        // For robustness, expire old requests after a long timeout, so that\n-        // we can resume downloading transactions from a peer even if they\n-        // were unresponsive in the past.\n-        // Eventually we should consider disconnecting peers, but this is\n-        // conservative.\n-        if (state.m_tx_download.m_check_expiry_timer <= current_time) {\n-            for (auto it=state.m_tx_download.m_tx_in_flight.begin(); it != state.m_tx_download.m_tx_in_flight.end();) {\n-                if (it->second <= current_time - TX_EXPIRY_INTERVAL) {\n-                    LogPrint(BCLog::NET, \"timeout of inflight tx %s from peer=%d\\n\", it->first.ToString(), pto->GetId());\n-                    state.m_tx_download.m_tx_announced.erase(it->first);\n-                    state.m_tx_download.m_tx_in_flight.erase(it++);\n-                } else {\n-                    ++it;\n-                }\n-            }\n-            // On average, we do this check every TX_EXPIRY_INTERVAL. Randomize\n-            // so that we're not doing this for all peers at the same time.\n-            state.m_tx_download.m_check_expiry_timer = current_time + TX_EXPIRY_INTERVAL / 2 + GetRandMicros(TX_EXPIRY_INTERVAL);\n-        }\n-\n-        auto& tx_process_time = state.m_tx_download.m_tx_process_time;\n-        while (!tx_process_time.empty() && tx_process_time.begin()->first <= current_time && state.m_tx_download.m_tx_in_flight.size() < MAX_PEER_TX_IN_FLIGHT) {\n-            const uint256 txid = tx_process_time.begin()->second;\n-            // Erase this entry from tx_process_time (it may be added back for\n-            // processing at a later time, see below)\n-            tx_process_time.erase(tx_process_time.begin());\n+        for (const uint256& txid : g_txrequest.GetRequestable(pto->GetId(), current_time)) {\n             CInv inv(MSG_TX | GetFetchFlags(*pto), txid);\n             if (!AlreadyHave(inv, m_mempool)) {\n-                // If this transaction was last requested more than 1 minute ago,\n-                // then request.\n-                const auto last_request_time = GetTxRequestTime(inv.hash);\n-                if (last_request_time <= current_time - GETDATA_TX_INTERVAL) {\n-                    LogPrint(BCLog::NET, \"Requesting %s peer=%d\\n\", inv.ToString(), pto->GetId());\n-                    vGetData.push_back(inv);\n-                    if (vGetData.size() >= MAX_GETDATA_SZ) {\n-                        connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n-                        vGetData.clear();\n-                    }\n-                    UpdateTxRequestTime(inv.hash, current_time);\n-                    state.m_tx_download.m_tx_in_flight.emplace(inv.hash, current_time);\n-                } else {\n-                    // This transaction is in flight from someone else; queue\n-                    // up processing to happen after the download times out\n-                    // (with a slight delay for inbound peers, to prefer\n-                    // requests to outbound peers).\n-                    const auto next_process_time = CalculateTxGetDataTime(txid, current_time, !state.fPreferredDownload);\n-                    tx_process_time.emplace(next_process_time, txid);\n+                LogPrint(BCLog::NET, \"Requesting %s peer=%d\\n\", inv.ToString(), pto->GetId());\n+                vGetData.push_back(inv);\n+                if (vGetData.size() >= MAX_GETDATA_SZ) {\n+                    connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n+                    vGetData.clear();\n                 }\n+                g_txrequest.RequestedTx(pto->GetId(), inv.hash, current_time);\n             } else {\n                 // We have already seen this transaction, no need to download.\n-                state.m_tx_download.m_tx_announced.erase(inv.hash);\n-                state.m_tx_download.m_tx_in_flight.erase(inv.hash);\n+                g_txrequest.AlreadyHaveTx(inv.hash);\n             }\n         }\n "
      },
      {
        "sha": "dda2f0b10ecd7ebd4e741383c32faddda82759cd",
        "filename": "test/functional/p2p_tx_download.py",
        "status": "modified",
        "additions": 3,
        "deletions": 40,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4f4f2f2de6b7f7f3f941ef92553c9bddfaccbd92/test/functional/p2p_tx_download.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4f4f2f2de6b7f7f3f941ef92553c9bddfaccbd92/test/functional/p2p_tx_download.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_tx_download.py?ref=4f4f2f2de6b7f7f3f941ef92553c9bddfaccbd92",
        "patch": "@@ -20,10 +20,7 @@\n     mininode_lock,\n )\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import (\n-    assert_equal,\n-    wait_until,\n-)\n+from test_framework.util import wait_until\n from test_framework.address import ADDRESS_BCRT1_UNSPENDABLE\n \n import time\n@@ -42,14 +39,12 @@ def on_getdata(self, message):\n \n # Constants from net_processing\n GETDATA_TX_INTERVAL = 60  # seconds\n-MAX_GETDATA_RANDOM_DELAY = 2  # seconds\n INBOUND_PEER_TX_DELAY = 2  # seconds\n-MAX_GETDATA_IN_FLIGHT = 100\n TX_EXPIRY_INTERVAL = GETDATA_TX_INTERVAL * 10\n \n # Python test constants\n NUM_INBOUND = 10\n-MAX_GETDATA_INBOUND_WAIT = GETDATA_TX_INTERVAL + MAX_GETDATA_RANDOM_DELAY + INBOUND_PEER_TX_DELAY\n+MAX_GETDATA_INBOUND_WAIT = GETDATA_TX_INTERVAL + INBOUND_PEER_TX_DELAY\n \n \n class TxDownloadTest(BitcoinTestFramework):\n@@ -120,38 +115,10 @@ def test_inv_block(self):\n         # * the first time it is re-requested from the outbound peer, plus\n         # * 2 seconds to avoid races\n         assert self.nodes[1].getpeerinfo()[0]['inbound'] == False\n-        timeout = 2 + (MAX_GETDATA_RANDOM_DELAY + INBOUND_PEER_TX_DELAY) + (\n-            GETDATA_TX_INTERVAL + MAX_GETDATA_RANDOM_DELAY)\n+        timeout = 2 + INBOUND_PEER_TX_DELAY + GETDATA_TX_INTERVAL\n         self.log.info(\"Tx should be received at node 1 after {} seconds\".format(timeout))\n         self.sync_mempools(timeout=timeout)\n \n-    def test_in_flight_max(self):\n-        self.log.info(\"Test that we don't request more than {} transactions from any peer, every {} minutes\".format(\n-            MAX_GETDATA_IN_FLIGHT, TX_EXPIRY_INTERVAL / 60))\n-        txids = [i for i in range(MAX_GETDATA_IN_FLIGHT + 2)]\n-\n-        p = self.nodes[0].p2ps[0]\n-\n-        with mininode_lock:\n-            p.tx_getdata_count = 0\n-\n-        p.send_message(msg_inv([CInv(t=MSG_TX, h=i) for i in txids]))\n-        wait_until(lambda: p.tx_getdata_count >= MAX_GETDATA_IN_FLIGHT, lock=mininode_lock)\n-        with mininode_lock:\n-            assert_equal(p.tx_getdata_count, MAX_GETDATA_IN_FLIGHT)\n-\n-        self.log.info(\"Now check that if we send a NOTFOUND for a transaction, we'll get one more request\")\n-        p.send_message(msg_notfound(vec=[CInv(t=MSG_TX, h=txids[0])]))\n-        wait_until(lambda: p.tx_getdata_count >= MAX_GETDATA_IN_FLIGHT + 1, timeout=10, lock=mininode_lock)\n-        with mininode_lock:\n-            assert_equal(p.tx_getdata_count, MAX_GETDATA_IN_FLIGHT + 1)\n-\n-        WAIT_TIME = TX_EXPIRY_INTERVAL // 2 + TX_EXPIRY_INTERVAL\n-        self.log.info(\"if we wait about {} minutes, we should eventually get more requests\".format(WAIT_TIME / 60))\n-        self.nodes[0].setmocktime(int(time.time() + WAIT_TIME))\n-        wait_until(lambda: p.tx_getdata_count == MAX_GETDATA_IN_FLIGHT + 2)\n-        self.nodes[0].setmocktime(0)\n-\n     def test_spurious_notfound(self):\n         self.log.info('Check that spurious notfound is ignored')\n         self.nodes[0].p2ps[0].send_message(msg_notfound(vec=[CInv(MSG_TX, 1)]))\n@@ -167,10 +134,6 @@ def run_test(self):\n \n         self.test_spurious_notfound()\n \n-        # Test the in-flight max first, because we want no transactions in\n-        # flight ahead of this test.\n-        self.test_in_flight_max()\n-\n         self.test_inv_block()\n \n         self.test_tx_requests()"
      }
    ]
  },
  {
    "sha": "5ffa197f30ad3b856da90e8aeddc1801cd57dc7d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1ZmZhMTk3ZjMwYWQzYjg1NmRhOTBlOGFlZGRjMTgwMWNkNTdkYzdk",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-06-06T02:59:23Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-07-21T00:41:19Z"
      },
      "message": "More accurate removal of transactions from g_txrequest",
      "tree": {
        "sha": "154c9a4bb2e1d89bcd41ab0878ff2a34786005f1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/154c9a4bb2e1d89bcd41ab0878ff2a34786005f1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5ffa197f30ad3b856da90e8aeddc1801cd57dc7d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5ffa197f30ad3b856da90e8aeddc1801cd57dc7d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5ffa197f30ad3b856da90e8aeddc1801cd57dc7d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5ffa197f30ad3b856da90e8aeddc1801cd57dc7d/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4f4f2f2de6b7f7f3f941ef92553c9bddfaccbd92",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4f4f2f2de6b7f7f3f941ef92553c9bddfaccbd92",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4f4f2f2de6b7f7f3f941ef92553c9bddfaccbd92"
      }
    ],
    "stats": {
      "total": 10,
      "additions": 10,
      "deletions": 0
    },
    "files": [
      {
        "sha": "ff1e6805bb57acbf472a7936b8278e03ce1a2435",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5ffa197f30ad3b856da90e8aeddc1801cd57dc7d/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5ffa197f30ad3b856da90e8aeddc1801cd57dc7d/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=5ffa197f30ad3b856da90e8aeddc1801cd57dc7d",
        "patch": "@@ -1129,6 +1129,12 @@ void PeerLogicValidation::BlockConnected(const std::shared_ptr<const CBlock>& pb\n             g_recent_confirmed_transactions->insert(ptx->GetHash());\n         }\n     }\n+    {\n+        LOCK(cs_main);\n+        for (const auto& ptx : pblock->vtx) {\n+            g_txrequest.AlreadyHaveTx(ptx->GetHash());\n+        }\n+    }\n }\n \n void PeerLogicValidation::BlockDisconnected(const std::shared_ptr<const CBlock> &block, const CBlockIndex* pindex)\n@@ -2729,6 +2735,7 @@ void ProcessMessage(\n         if (!AlreadyHave(inv, mempool) &&\n             AcceptToMemoryPool(mempool, state, ptx, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n             mempool.check(&::ChainstateActive().CoinsTip());\n+            g_txrequest.AlreadyHaveTx(inv.hash);\n             RelayTransaction(tx.GetHash(), connman);\n             for (unsigned int i = 0; i < tx.vout.size(); i++) {\n                 auto it_by_prev = mapOrphanTransactionsByPrev.find(COutPoint(inv.hash, i));\n@@ -2769,6 +2776,9 @@ void ProcessMessage(\n                 }\n                 AddOrphanTx(ptx, pfrom.GetId());\n \n+                // Once added to the orphan pool, it is considered AlreadyHave, and we shouldn't request it anymore.\n+                g_txrequest.AlreadyHaveTx(tx.GetHash());\n+\n                 // DoS prevention: do not allow mapOrphanTransactions to grow unbounded (see CVE-2012-3789)\n                 unsigned int nMaxOrphanTx = (unsigned int)std::max((int64_t)0, gArgs.GetArg(\"-maxorphantx\", DEFAULT_MAX_ORPHAN_TRANSACTIONS));\n                 unsigned int nEvicted = LimitOrphanTxSize(nMaxOrphanTx);"
      }
    ]
  },
  {
    "sha": "0bcbe4ef3b19fb78e6d8aa3c5bb246943206ee48",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowYmNiZTRlZjNiMTlmYjc4ZTZkOGFhM2M1YmIyNDY5NDMyMDZlZTQ4",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-06-06T02:59:36Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-07-21T00:41:19Z"
      },
      "message": "Delete limitedmap as it is unused",
      "tree": {
        "sha": "d0597b6ade9b694f0422b4695e9fd726f99d0a2a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d0597b6ade9b694f0422b4695e9fd726f99d0a2a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0bcbe4ef3b19fb78e6d8aa3c5bb246943206ee48",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0bcbe4ef3b19fb78e6d8aa3c5bb246943206ee48",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0bcbe4ef3b19fb78e6d8aa3c5bb246943206ee48",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0bcbe4ef3b19fb78e6d8aa3c5bb246943206ee48/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5ffa197f30ad3b856da90e8aeddc1801cd57dc7d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5ffa197f30ad3b856da90e8aeddc1801cd57dc7d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5ffa197f30ad3b856da90e8aeddc1801cd57dc7d"
      }
    ],
    "stats": {
      "total": 203,
      "additions": 0,
      "deletions": 203
    },
    "files": [
      {
        "sha": "ed01c95fd0cb39f87ccd3ab67621f26b0fda1baf",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0bcbe4ef3b19fb78e6d8aa3c5bb246943206ee48/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0bcbe4ef3b19fb78e6d8aa3c5bb246943206ee48/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=0bcbe4ef3b19fb78e6d8aa3c5bb246943206ee48",
        "patch": "@@ -149,7 +149,6 @@ BITCOIN_CORE_H = \\\n   interfaces/wallet.h \\\n   key.h \\\n   key_io.h \\\n-  limitedmap.h \\\n   logging.h \\\n   logging/timer.h \\\n   memusage.h \\"
      },
      {
        "sha": "c0277ccdd7bafa797f2549a419f786ff3248c7c2",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0bcbe4ef3b19fb78e6d8aa3c5bb246943206ee48/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0bcbe4ef3b19fb78e6d8aa3c5bb246943206ee48/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=0bcbe4ef3b19fb78e6d8aa3c5bb246943206ee48",
        "patch": "@@ -231,7 +231,6 @@ BITCOIN_TESTS =\\\n   test/interfaces_tests.cpp \\\n   test/key_io_tests.cpp \\\n   test/key_tests.cpp \\\n-  test/limitedmap_tests.cpp \\\n   test/logging_tests.cpp \\\n   test/dbwrapper_tests.cpp \\\n   test/validation_tests.cpp \\"
      },
      {
        "sha": "7d66964e36aa5119dbe41c9cf322e7ec1a94a094",
        "filename": "src/limitedmap.h",
        "status": "removed",
        "additions": 0,
        "deletions": 100,
        "changes": 100,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5ffa197f30ad3b856da90e8aeddc1801cd57dc7d/src/limitedmap.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5ffa197f30ad3b856da90e8aeddc1801cd57dc7d/src/limitedmap.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/limitedmap.h?ref=5ffa197f30ad3b856da90e8aeddc1801cd57dc7d",
        "patch": "@@ -1,100 +0,0 @@\n-// Copyright (c) 2012-2018 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#ifndef BITCOIN_LIMITEDMAP_H\n-#define BITCOIN_LIMITEDMAP_H\n-\n-#include <assert.h>\n-#include <map>\n-\n-/** STL-like map container that only keeps the N elements with the highest value. */\n-template <typename K, typename V>\n-class limitedmap\n-{\n-public:\n-    typedef K key_type;\n-    typedef V mapped_type;\n-    typedef std::pair<const key_type, mapped_type> value_type;\n-    typedef typename std::map<K, V>::const_iterator const_iterator;\n-    typedef typename std::map<K, V>::size_type size_type;\n-\n-protected:\n-    std::map<K, V> map;\n-    typedef typename std::map<K, V>::iterator iterator;\n-    std::multimap<V, iterator> rmap;\n-    typedef typename std::multimap<V, iterator>::iterator rmap_iterator;\n-    size_type nMaxSize;\n-\n-public:\n-    explicit limitedmap(size_type nMaxSizeIn)\n-    {\n-        assert(nMaxSizeIn > 0);\n-        nMaxSize = nMaxSizeIn;\n-    }\n-    const_iterator begin() const { return map.begin(); }\n-    const_iterator end() const { return map.end(); }\n-    size_type size() const { return map.size(); }\n-    bool empty() const { return map.empty(); }\n-    const_iterator find(const key_type& k) const { return map.find(k); }\n-    size_type count(const key_type& k) const { return map.count(k); }\n-    void insert(const value_type& x)\n-    {\n-        std::pair<iterator, bool> ret = map.insert(x);\n-        if (ret.second) {\n-            if (map.size() > nMaxSize) {\n-                map.erase(rmap.begin()->second);\n-                rmap.erase(rmap.begin());\n-            }\n-            rmap.insert(make_pair(x.second, ret.first));\n-        }\n-    }\n-    void erase(const key_type& k)\n-    {\n-        iterator itTarget = map.find(k);\n-        if (itTarget == map.end())\n-            return;\n-        std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n-        for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n-            if (it->second == itTarget) {\n-                rmap.erase(it);\n-                map.erase(itTarget);\n-                return;\n-            }\n-        // Shouldn't ever get here\n-        assert(0);\n-    }\n-    void update(const_iterator itIn, const mapped_type& v)\n-    {\n-        // Using map::erase() with empty range instead of map::find() to get a non-const iterator,\n-        // since it is a constant time operation in C++11. For more details, see\n-        // https://stackoverflow.com/questions/765148/how-to-remove-constness-of-const-iterator\n-        iterator itTarget = map.erase(itIn, itIn);\n-\n-        if (itTarget == map.end())\n-            return;\n-        std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n-        for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n-            if (it->second == itTarget) {\n-                rmap.erase(it);\n-                itTarget->second = v;\n-                rmap.insert(make_pair(v, itTarget));\n-                return;\n-            }\n-        // Shouldn't ever get here\n-        assert(0);\n-    }\n-    size_type max_size() const { return nMaxSize; }\n-    size_type max_size(size_type s)\n-    {\n-        assert(s > 0);\n-        while (map.size() > s) {\n-            map.erase(rmap.begin()->second);\n-            rmap.erase(rmap.begin());\n-        }\n-        nMaxSize = s;\n-        return nMaxSize;\n-    }\n-};\n-\n-#endif // BITCOIN_LIMITEDMAP_H"
      },
      {
        "sha": "ea18debbd3ec71db013df160d4377f7bc71c0ce1",
        "filename": "src/test/limitedmap_tests.cpp",
        "status": "removed",
        "additions": 0,
        "deletions": 101,
        "changes": 101,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5ffa197f30ad3b856da90e8aeddc1801cd57dc7d/src/test/limitedmap_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5ffa197f30ad3b856da90e8aeddc1801cd57dc7d/src/test/limitedmap_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/limitedmap_tests.cpp?ref=5ffa197f30ad3b856da90e8aeddc1801cd57dc7d",
        "patch": "@@ -1,101 +0,0 @@\n-// Copyright (c) 2012-2019 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include <limitedmap.h>\n-\n-#include <test/util/setup_common.h>\n-\n-#include <boost/test/unit_test.hpp>\n-\n-BOOST_FIXTURE_TEST_SUITE(limitedmap_tests, BasicTestingSetup)\n-\n-BOOST_AUTO_TEST_CASE(limitedmap_test)\n-{\n-    // create a limitedmap capped at 10 items\n-    limitedmap<int, int> map(10);\n-\n-    // check that the max size is 10\n-    BOOST_CHECK(map.max_size() == 10);\n-\n-    // check that it's empty\n-    BOOST_CHECK(map.size() == 0);\n-\n-    // insert (-1, -1)\n-    map.insert(std::pair<int, int>(-1, -1));\n-\n-    // make sure that the size is updated\n-    BOOST_CHECK(map.size() == 1);\n-\n-    // make sure that the new item is in the map\n-    BOOST_CHECK(map.count(-1) == 1);\n-\n-    // insert 10 new items\n-    for (int i = 0; i < 10; i++) {\n-        map.insert(std::pair<int, int>(i, i + 1));\n-    }\n-\n-    // make sure that the map now contains 10 items...\n-    BOOST_CHECK(map.size() == 10);\n-\n-    // ...and that the first item has been discarded\n-    BOOST_CHECK(map.count(-1) == 0);\n-\n-    // iterate over the map, both with an index and an iterator\n-    limitedmap<int, int>::const_iterator it = map.begin();\n-    for (int i = 0; i < 10; i++) {\n-        // make sure the item is present\n-        BOOST_CHECK(map.count(i) == 1);\n-\n-        // use the iterator to check for the expected key and value\n-        BOOST_CHECK(it->first == i);\n-        BOOST_CHECK(it->second == i + 1);\n-\n-        // use find to check for the value\n-        BOOST_CHECK(map.find(i)->second == i + 1);\n-\n-        // update and recheck\n-        map.update(it, i + 2);\n-        BOOST_CHECK(map.find(i)->second == i + 2);\n-\n-        it++;\n-    }\n-\n-    // check that we've exhausted the iterator\n-    BOOST_CHECK(it == map.end());\n-\n-    // resize the map to 5 items\n-    map.max_size(5);\n-\n-    // check that the max size and size are now 5\n-    BOOST_CHECK(map.max_size() == 5);\n-    BOOST_CHECK(map.size() == 5);\n-\n-    // check that items less than 5 have been discarded\n-    // and items greater than 5 are retained\n-    for (int i = 0; i < 10; i++) {\n-        if (i < 5) {\n-            BOOST_CHECK(map.count(i) == 0);\n-        } else {\n-            BOOST_CHECK(map.count(i) == 1);\n-        }\n-    }\n-\n-    // erase some items not in the map\n-    for (int i = 100; i < 1000; i += 100) {\n-        map.erase(i);\n-    }\n-\n-    // check that the size is unaffected\n-    BOOST_CHECK(map.size() == 5);\n-\n-    // erase the remaining elements\n-    for (int i = 5; i < 10; i++) {\n-        map.erase(i);\n-    }\n-\n-    // check that the map is now empty\n-    BOOST_CHECK(map.empty());\n-}\n-\n-BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ZmZlYWE5OTg3NTdmNWExYzYxMDk5OWY5MDRjNWQ1YzYyZmMxNGI5",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-06-06T02:59:41Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-07-21T01:28:35Z"
      },
      "message": "Add txrequest fuzzer that compares with naive implementation",
      "tree": {
        "sha": "841cb7a52e1c86a6dfae9d2938c21d48567b6047",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/841cb7a52e1c86a6dfae9d2938c21d48567b6047"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ffeaa998757f5a1c610999f904c5d5c62fc14b9/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0bcbe4ef3b19fb78e6d8aa3c5bb246943206ee48",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0bcbe4ef3b19fb78e6d8aa3c5bb246943206ee48",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0bcbe4ef3b19fb78e6d8aa3c5bb246943206ee48"
      }
    ],
    "stats": {
      "total": 396,
      "additions": 396,
      "deletions": 0
    },
    "files": [
      {
        "sha": "9d2df8c5f20238f17791f2dfd7f82eedb3418280",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4ffeaa998757f5a1c610999f904c5d5c62fc14b9/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4ffeaa998757f5a1c610999f904c5d5c62fc14b9/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
        "patch": "@@ -147,6 +147,7 @@ FUZZ_TARGETS = \\\n   test/fuzz/tx_in_deserialize \\\n   test/fuzz/tx_out \\\n   test/fuzz/txoutcompressor_deserialize \\\n+  test/fuzz/txrequest \\\n   test/fuzz/txundo_deserialize \\\n   test/fuzz/uint160_deserialize \\\n   test/fuzz/uint256_deserialize\n@@ -1182,6 +1183,12 @@ test_fuzz_txoutcompressor_deserialize_LDADD = $(FUZZ_SUITE_LD_COMMON)\n test_fuzz_txoutcompressor_deserialize_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n test_fuzz_txoutcompressor_deserialize_SOURCES = test/fuzz/deserialize.cpp\n \n+test_fuzz_txrequest_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n+test_fuzz_txrequest_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n+test_fuzz_txrequest_LDADD = $(FUZZ_SUITE_LD_COMMON)\n+test_fuzz_txrequest_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n+test_fuzz_txrequest_SOURCES = test/fuzz/txrequest.cpp\n+\n test_fuzz_txundo_deserialize_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) -DTXUNDO_DESERIALIZE=1\n test_fuzz_txundo_deserialize_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n test_fuzz_txundo_deserialize_LDADD = $(FUZZ_SUITE_LD_COMMON)"
      },
      {
        "sha": "51081f781355e795b5f4c9884d79cb834ef96b62",
        "filename": "src/test/fuzz/txrequest.cpp",
        "status": "added",
        "additions": 389,
        "deletions": 0,
        "changes": 389,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4ffeaa998757f5a1c610999f904c5d5c62fc14b9/src/test/fuzz/txrequest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4ffeaa998757f5a1c610999f904c5d5c62fc14b9/src/test/fuzz/txrequest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/txrequest.cpp?ref=4ffeaa998757f5a1c610999f904c5d5c62fc14b9",
        "patch": "@@ -0,0 +1,389 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <random.h>\n+#include <txrequest.h>\n+#include <test/fuzz/fuzz.h>\n+#include <crypto/common.h>\n+#include <crypto/siphash.h>\n+\n+#include <bitset>\n+#include <cstdint>\n+#include <queue>\n+#include <vector>\n+\n+namespace {\n+\n+static constexpr int MAX_TXIDS = 16;\n+static constexpr int MAX_PEERS = 16;\n+\n+//! Randomly generated TXIDs used in this test.\n+uint256 TXIDS[MAX_TXIDS];\n+\n+/** Precomputed random timeouts/delays (~exponentially distributed). */\n+std::chrono::microseconds DELAYS[256];\n+\n+struct Initializer\n+{\n+    Initializer()\n+    {\n+        // Use deterministic RNG to fill in txids and delays.\n+        // Non-determinism hurts fuzzing.\n+        FastRandomContext rng(true);\n+        for (int txidnum = 0; txidnum < MAX_TXIDS; ++txidnum) {\n+            TXIDS[txidnum] = rng.rand256();\n+        }\n+        for (int i = 0; i < 16; ++i) {\n+            DELAYS[i] = std::chrono::microseconds{1 + i};\n+        }\n+        for (int i = 16; i < 256; ++i) {\n+            DELAYS[i] = DELAYS[i - 1] + std::chrono::microseconds{1 + rng.randbits(i / 10)};\n+        }\n+    }\n+} g_initializer;\n+\n+/** Tester class for TxRequestTracker\n+ *\n+ * It includes a naive reimplementation of its behavior, for a limited set\n+ * of MAX_TXIDS distinct txids, and MAX_PEERS peer identifiers.\n+ *\n+ * All of the public member functions perform the same operation on\n+ * an actual TxRequestTracker and on the state of the reimplementation.\n+ * The output of GetRequestable is compared with the expected value\n+ * as well.\n+ *\n+ * Check() calls the TxRequestTracker's sanity check, plus compares the\n+ * output of the constant accessors (Size(), CountInFlight(), CountTracked())\n+ * with expected values.\n+ */\n+class Tester\n+{\n+    //! TxRequestTracker object being tested.\n+    TxRequestTracker m_tracker;\n+\n+    //! States for txid/peer combinations in the naive data structure.\n+    enum class State {\n+        NOTHING, //!< Absence of this txid/peer combination\n+\n+        // Note that this implementation does not distinguish between BEST/NEW/OTHER variants of CANDIDATE.\n+        CANDIDATE,\n+        REQUESTED,\n+        COMPLETED,\n+    };\n+\n+    //! Sequence numbers, incremented whenever a new CANDIDATE is added.\n+    uint64_t m_sequence{0};\n+\n+    //! List of future 'events' (all inserted reqtimes/exptimes). This is used to implement AdvanceToEvent.\n+    std::priority_queue<std::chrono::microseconds, std::vector<std::chrono::microseconds>, std::greater<std::chrono::microseconds>> m_events;\n+\n+    //! Information about a txid/peer combination.\n+    struct Entry\n+    {\n+        std::chrono::microseconds m_time;\n+        uint64_t m_sequence;\n+        State m_state{State::NOTHING};\n+        bool m_delayed;\n+        bool m_first;\n+    };\n+\n+    //! Information about all txid/peer combination.\n+    Entry m_entries[MAX_TXIDS][MAX_PEERS];\n+\n+    //! The current time; can move forward and backward.\n+    std::chrono::microseconds m_now{112223333};\n+\n+    //! The last peer we've called GetRequestable for, or -1 if none.\n+    //! Also reset to -1 whenever an operation is performed that removes the ability to call RequestedTx.\n+    int m_get_requestable_last_peer = -1;\n+\n+    //! The txidnums returned by the last GetRequestable, which AlreadyHaveTx or RequestedTx haven't been called on yet.\n+    std::bitset<MAX_TXIDS> m_get_requestable_last_result;\n+\n+    //! Check if there are any entries for txidnum (including COMPLETED ones)\n+    bool HaveAny(int txidnum)\n+    {\n+        for (int peer = 0; peer < MAX_PEERS; ++peer) {\n+            if (m_entries[txidnum][peer].m_state != State::NOTHING) return true;\n+        }\n+        return false;\n+    }\n+\n+    //! Delete txids whose only entries are COMPLETED.\n+    void Cleanup(int txidnum)\n+    {\n+        bool all_nothing = true;\n+        for (int peer = 0; peer < MAX_PEERS; ++peer) {\n+            const Entry& entry = m_entries[txidnum][peer];\n+            if (entry.m_state == State::CANDIDATE || entry.m_state == State::REQUESTED) return;\n+            if (entry.m_state != State::NOTHING) all_nothing = false;\n+        }\n+        if (all_nothing) return;\n+        for (int peer = 0; peer < MAX_PEERS; ++peer) {\n+            m_entries[txidnum][peer].m_state = State::NOTHING;\n+        }\n+    }\n+\n+    //! Find the current best peer to request from for a txid (or -1 if none).\n+    int GetSelected(int txidnum) const\n+    {\n+        int ret = -1;\n+        uint64_t ret_priority = 0;\n+        for (int peer = 0; peer < MAX_PEERS; ++peer) {\n+            // Return -1 if there already is a (non-expired) in-flight request.\n+            if (m_entries[txidnum][peer].m_state == State::REQUESTED) return -1;\n+            // If it's a viable candidate, see if it has lower priority than the best one so far.\n+            if (m_entries[txidnum][peer].m_state == State::CANDIDATE && m_entries[txidnum][peer].m_time <= m_now) {\n+                uint64_t peer_priority = m_tracker.GetPriorityComputer()(TXIDS[txidnum], peer, m_entries[txidnum][peer].m_delayed, m_entries[txidnum][peer].m_first);\n+                if (ret == -1 || peer_priority < ret_priority) std::tie(ret, ret_priority) = std::tie(peer, peer_priority);\n+            }\n+        }\n+        return ret;\n+    }\n+\n+public:\n+    Tester(std::chrono::microseconds timeout) : m_tracker(timeout, true)\n+    {\n+        assert(m_tracker.GetTimeout() == timeout);\n+    }\n+\n+    std::chrono::microseconds Now() const { return m_now; }\n+\n+    void AdvanceTime(std::chrono::microseconds offset)\n+    {\n+        m_now += offset;\n+        while (!m_events.empty() && m_events.top() <= m_now) m_events.pop();\n+    }\n+\n+    void AdvanceToEvent()\n+    {\n+        while (!m_events.empty() && m_events.top() <= m_now) m_events.pop();\n+        if (!m_events.empty()) {\n+            m_now = m_events.top();\n+            m_events.pop();\n+        }\n+    }\n+\n+    void DeletedPeer(int peer)\n+    {\n+        // Removes the ability to call RequestedTx until the next GetRequestable.\n+        m_get_requestable_last_peer = -1;\n+\n+        // Apply to naive structure: all entries for that peer are wiped.\n+        for (int txidnum = 0; txidnum < MAX_TXIDS; ++txidnum) {\n+            if (m_entries[txidnum][peer].m_state != State::NOTHING) {\n+                m_entries[txidnum][peer].m_state = State::NOTHING;\n+                Cleanup(txidnum);\n+            }\n+        }\n+\n+        // Call TxRequestTracker's implementation.\n+        m_tracker.DeletedPeer(peer);\n+    }\n+\n+    void AlreadyHaveTx(int txidnum)\n+    {\n+        // RequestedTx cannot be called on this txidnum anymore.\n+        m_get_requestable_last_result.reset(txidnum);\n+\n+        // Apply to naive structure: all entries for that txid are wiped.\n+        for (int peer = 0; peer < MAX_PEERS; ++peer) {\n+            m_entries[txidnum][peer].m_state = State::NOTHING;\n+        }\n+        // No need to call Cleanup(txidnum); it's already all NOTHING.\n+\n+        // Call TxRequestTracker's implementation.\n+        m_tracker.AlreadyHaveTx(TXIDS[txidnum]);\n+    }\n+\n+    void ReceivedInv(int peer, int txidnum, std::chrono::microseconds reqtime)\n+    {\n+        // Removes the ability to call RequestedTx until the next GetRequestable.\n+        m_get_requestable_last_peer = -1;\n+\n+        // Apply to naive structure: if no entry for txidnum/peer combination\n+        // already, create a new CANDIDATE; otherwise do nothing.\n+        Entry& entry = m_entries[txidnum][peer];\n+        if (entry.m_state == State::NOTHING) {\n+            entry.m_first = !HaveAny(txidnum);\n+            entry.m_delayed = reqtime != std::chrono::microseconds::min();\n+            entry.m_state = State::CANDIDATE;\n+            entry.m_time = reqtime;\n+            entry.m_sequence = m_sequence++;\n+\n+            // Add event so that AdvanceToEvent can quickly jump to the point where its reqtime passes.\n+            if (reqtime > m_now) m_events.push(reqtime);\n+        }\n+\n+        // Call TxRequestTracker's implementation.\n+        m_tracker.ReceivedInv(peer, TXIDS[txidnum], reqtime);\n+    }\n+\n+    void RequestedTx(int txidnum)\n+    {\n+        // Must be called with a txid that was returned by GetRequestable\n+        int peer = m_get_requestable_last_peer;\n+        if (peer == -1) return;\n+        if (!m_get_requestable_last_result[txidnum]) return;\n+        m_get_requestable_last_result.reset(txidnum);\n+\n+        // Apply to naive structure: convert CANDIDATE to REQUESTED.\n+        assert(m_entries[txidnum][peer].m_state == State::CANDIDATE);\n+        m_entries[txidnum][peer].m_state = State::REQUESTED;\n+        m_entries[txidnum][peer].m_time = m_now + m_tracker.GetTimeout();\n+\n+        // Add event so that AdvanceToEvent can quickly jump to the point where its exptime passes.\n+        m_events.push(m_now + m_tracker.GetTimeout());\n+\n+        // Call TxRequestTracker's implementation.\n+        m_tracker.RequestedTx(peer, TXIDS[txidnum], m_now);\n+    }\n+\n+    void ReceivedResponse(int peer, int txidnum)\n+    {\n+        // Removes the ability to call RequestedTx until the next GetRequestable.\n+        m_get_requestable_last_peer = -1;\n+\n+        // Apply to naive structure: convert anything to COMPLETED.\n+        if (m_entries[txidnum][peer].m_state != State::NOTHING) {\n+            m_entries[txidnum][peer].m_state = State::COMPLETED;\n+            Cleanup(txidnum);\n+        }\n+\n+        // Call TxRequestTracker's implementation.\n+        m_tracker.ReceivedResponse(peer, TXIDS[txidnum]);\n+    }\n+\n+    void GetRequestable(int peer)\n+    {\n+        // Enables future calls to RequestedTx for this peer, and the call's response as txids.\n+        m_get_requestable_last_peer = peer;\n+        m_get_requestable_last_result.reset();\n+\n+        // Implement using naive structure:\n+        std::vector<std::pair<uint64_t, int>> result; //!< list of (sequence number, txidnum) pairs.\n+        for (int txidnum = 0; txidnum < MAX_TXIDS; ++txidnum) {\n+            // Mark any expired REQUESTED entries as COMPLETED.\n+            for (int peer2 = 0; peer2 < MAX_PEERS; ++peer2) {\n+                if (m_entries[txidnum][peer2].m_state == State::REQUESTED && m_entries[txidnum][peer2].m_time <= m_now) {\n+                    m_entries[txidnum][peer2].m_state = State::COMPLETED;\n+                    break;\n+                }\n+            }\n+            // And delete txids with only COMPLETED entries left.\n+            Cleanup(txidnum);\n+            // CANDIDATEs for which this entry has the lowest priority get returned.\n+            if (m_entries[txidnum][peer].m_state == State::CANDIDATE && GetSelected(txidnum) == peer) {\n+                m_get_requestable_last_result.set(txidnum);\n+                result.emplace_back(m_entries[txidnum][peer].m_sequence, txidnum);\n+            }\n+        }\n+        // Sort the results by sequence number.\n+        std::sort(result.begin(), result.end());\n+\n+        // Compare with TxRequestTracker's implementation.\n+        std::vector<uint256> actual = m_tracker.GetRequestable(peer, m_now);\n+        m_tracker.TimeSanityCheck(m_now); // Invoke time-dependent sanity check, which should hold after GetRequestable\n+        assert(result.size() == actual.size());\n+        for (size_t pos = 0; pos < actual.size(); ++pos) {\n+            assert(TXIDS[result[pos].second] == actual[pos]);\n+        }\n+    }\n+\n+    void Check()\n+    {\n+        // Compare CountTracked and CountInFlight with naive structure.\n+        size_t total = 0;\n+        for (int peer = 0; peer < MAX_PEERS; ++peer) {\n+            size_t tracked = 0;\n+            size_t inflight = 0;\n+            for (int txidnum = 0; txidnum < MAX_TXIDS; ++txidnum) {\n+                tracked += m_entries[txidnum][peer].m_state != State::NOTHING;\n+                inflight += m_entries[txidnum][peer].m_state == State::REQUESTED;\n+            }\n+            assert(m_tracker.CountTracked(peer) == tracked);\n+            assert(m_tracker.CountInFlight(peer) == inflight);\n+            total += tracked;\n+        }\n+        // Compare Size.\n+        assert(m_tracker.Size() == total);\n+\n+        // Invoke internal consistency check of TxRequestTracker object.\n+        m_tracker.SanityCheck();\n+    }\n+};\n+\n+} // namespace\n+\n+void test_one_input(const std::vector<uint8_t>& buffer)\n+{\n+    // The first 4 bytes configure the timeout.\n+    if (buffer.size() < 4) return;\n+    auto timeout = DELAYS[buffer[0]] + DELAYS[buffer[1]] + DELAYS[buffer[2]] + DELAYS[buffer[3]];\n+\n+    // Tester object (which encapsulates a TxRequestTracker).\n+    Tester tester(timeout);\n+\n+    // Decode the input as a sequence of instructions with parameters\n+    auto it = buffer.begin() + 4;\n+    while (it != buffer.end()) {\n+        int cmd = *(it++) % 11;\n+        int peer, txidnum, delaynum;\n+        switch (cmd) {\n+        case 0: // Make time jump to the next event (m_time of PENDING or REQUESTED)\n+            tester.AdvanceToEvent();\n+            break;\n+        case 1: // Increase time (1 byte param: delaynum)\n+            delaynum = it == buffer.end() ? 0 : *(it++);\n+            tester.AdvanceTime(DELAYS[delaynum]);\n+            break;\n+        case 2: // Decrease time (1 byte param: delaynum)\n+            delaynum = it == buffer.end() ? 0 : *(it++);\n+            tester.AdvanceTime(-DELAYS[delaynum]);\n+            break;\n+        case 3: // Query for requestable txids (1 byte param: peer)\n+            peer = it == buffer.end() ? 0 : *(it++) % MAX_PEERS;\n+            tester.GetRequestable(peer);\n+            break;\n+        case 4: // Peer went offline (1 byte param: peer)\n+            peer = it == buffer.end() ? 0 : *(it++) % MAX_PEERS;\n+            tester.DeletedPeer(peer);\n+            break;\n+        case 5: // No longer need txid (1 byte param: txidnum)\n+            txidnum = it == buffer.end() ? 0 : *(it++) % MAX_TXIDS;\n+            tester.AlreadyHaveTx(txidnum);\n+            break;\n+        case 6: // Received inv from peer with no delay (2 byte param: peer, txidnum)\n+            peer = it == buffer.end() ? 0 : *(it++) % MAX_PEERS;\n+            txidnum = it == buffer.end() ? 0 : *(it++) % MAX_TXIDS;\n+            tester.ReceivedInv(peer, txidnum, std::chrono::microseconds::min());\n+            break;\n+        case 7: // Received inv from peer with delay (3 byte param: peer, txidnum, delaynum)\n+            peer = it == buffer.end() ? 0 : *(it++) % MAX_PEERS;\n+            txidnum = it == buffer.end() ? 0 : *(it++) % MAX_TXIDS;\n+            delaynum = it == buffer.end() ? 0 : *(it++);\n+            tester.ReceivedInv(peer, txidnum, tester.Now() + DELAYS[delaynum]);\n+            break;\n+        case 8: // Received inv from peer with negative delay (3 byte param: peer, txidnum, delaynum)\n+            peer = it == buffer.end() ? 0 : *(it++) % MAX_PEERS;\n+            txidnum = it == buffer.end() ? 0 : *(it++) % MAX_TXIDS;\n+            delaynum = it == buffer.end() ? 0 : *(it++);\n+            tester.ReceivedInv(peer, txidnum, tester.Now() - DELAYS[delaynum]);\n+            break;\n+        case 9: // Requested tx from peer (1 byte param: txidnum)\n+            txidnum = it == buffer.end() ? 0 : *(it++) % MAX_TXIDS;\n+            tester.RequestedTx(txidnum);\n+            break;\n+        case 10: // Received response (2 byte param: peernum, txidnum)\n+            peer = it == buffer.end() ? 0 : *(it++) % MAX_PEERS;\n+            txidnum = it == buffer.end() ? 0 : *(it++) % MAX_TXIDS;\n+            tester.ReceivedResponse(peer, txidnum);\n+            break;\n+        default:\n+            assert(false);\n+        }\n+    }\n+\n+    tester.Check();\n+}"
      }
    ]
  }
]