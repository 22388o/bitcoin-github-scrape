DrahtBot,2020-05-17 11:05:26,<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nNo conflicts as of last run.,https://github.com/bitcoin/bitcoin/pull/18994#issuecomment-629779615,629779615,
MarcoFalke,2020-05-29 00:01:45,Needs rebase,https://github.com/bitcoin/bitcoin/pull/18994#issuecomment-635679615,635679615,
MarcoFalke,2020-05-31 22:58:29,"ACK f898ef65c947776750e49d050633f830546bbdc6 ðŸ”‰\n\n<details><summary>Show signature and timestamp</summary>\n\nSignature:\n\n```\n-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA512\n\nACK f898ef65c947776750e49d050633f830546bbdc6 ðŸ”‰\n-----BEGIN PGP SIGNATURE-----\n\niQGzBAEBCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUgtcwwAk2++KR5/UnaZ6/Gls4rZq7sjVolrOPUw/ADuxRyFu/qM7nmAOu",https://github.com/bitcoin/bitcoin/pull/18994#issuecomment-636543317,636543317,
MarcoFalke,2020-05-17 11:37:05,unrelated nit: At compile time this can never be null. I'd prefer if the return value for strings was always `std::string`. Every caller of `ScriptErrorString` converts to `std::string` anyway.,https://github.com/bitcoin/bitcoin/pull/18994#discussion_r426250850,426250850,src/test/fuzz/script.cpp
MarcoFalke,2020-05-17 11:42:17,this looks like a unit test that does not depend on any fuzz input,https://github.com/bitcoin/bitcoin/pull/18994#discussion_r426251317,426251317,src/test/fuzz/script.cpp
MarcoFalke,2020-05-17 11:58:00,"unrelated, but I was wondering if `ConsumeDeserializable<T>` could always return type `T` (if the stream was empty, it would return `T{}`). Not returning optional would bring this helper in line with all other helpers. For example `ConsumeRandomLengthString` always return `std::string`.",https://github.com/bitcoin/bitcoin/pull/18994#discussion_r426252814,426252814,src/test/fuzz/script_sign.cpp
MarcoFalke,2020-05-17 11:59:38,My suggestion would be to construct a random `CTxDestination`.,https://github.com/bitcoin/bitcoin/pull/18994#discussion_r426252948,426252948,src/test/fuzz/script.cpp
practicalswift,2020-05-17 16:24:47,"I agree, we should always return `std::string`. Will do that in a follow-up PR since that will touch validation code and thus need more scrutiny than adding tests.",https://github.com/bitcoin/bitcoin/pull/18994#discussion_r426279217,426279217,src/test/fuzz/script.cpp
practicalswift,2020-05-18 13:28:59,Done! :),https://github.com/bitcoin/bitcoin/pull/18994#discussion_r426625962,426625962,src/test/fuzz/script.cpp
practicalswift,2020-05-18 13:48:03,"You mean something along the lines of:\n\n```c++\ntemplate <typename T>\nNODISCARD inline T ConsumeDeserializable(FuzzedDataProvider& fuzzed_data_provider, const size_t max_length = 4096) noexcept\n{\n    const std::vector<uint8_t> buffer = ConsumeRandomLengthByteVector(fuzzed_data_provider, max_length);\n    CDataStream ds{buffer, SER_NETWORK, INIT_PROTO_VERSION};\n    T obj;\n    try {",https://github.com/bitcoin/bitcoin/pull/18994#discussion_r426638879,426638879,src/test/fuzz/script_sign.cpp
MarcoFalke,2020-05-18 14:34:34,"I think when it comes to trading off giving the fuzz test more freedom to explore more code branches vs micro-optimizing for performance, we should always pick the option that gives the fuzz engine more freedom. Fuzzing is great to complement traditional tests (e.g. our unit and functional tests). Those traditional tests offer a reasonable line coverage, but fuzz testing can offer great branch cov",https://github.com/bitcoin/bitcoin/pull/18994#discussion_r426672035,426672035,src/test/fuzz/script_sign.cpp
practicalswift,2020-05-18 15:06:21,"I agree regarding the coverage vs performance trade-off: I'd choose ""explore more code branches"" over performance any day in the week :)\n\nDo you see a scenario where returning a default constructed object in case of serialisation failure is likely to give more freedom to explore more code branches (in a way that will have a positive impact of coverage) compared to not doing so?\n\nIf so we'd",https://github.com/bitcoin/bitcoin/pull/18994#discussion_r426695025,426695025,src/test/fuzz/script_sign.cpp
MarcoFalke,2020-05-18 15:11:30,"> Do you see a scenario where returning a default constructed object in case of serialisation failure is likely to give more freedom to explore more code branches compared to not doing so?\n\nUnclear. This question boils down to whether default initialization leaves members uninitialized or initializes them with values that can not be the result of deserialization.",https://github.com/bitcoin/bitcoin/pull/18994#discussion_r426698810,426698810,src/test/fuzz/script_sign.cpp
practicalswift,2020-05-18 19:43:47,Agreed. Sounds like we agree on the need for experimentation and measuring before proceeding with this :),https://github.com/bitcoin/bitcoin/pull/18994#discussion_r426854421,426854421,src/test/fuzz/script_sign.cpp
MarcoFalke,2020-05-31 22:59:33,@practicalswift Are you going to create a pull with the branch or should I do it?,https://github.com/bitcoin/bitcoin/pull/18994#discussion_r432993158,432993158,src/test/fuzz/script_sign.cpp
practicalswift,2020-06-01 09:21:40,@MarcoFalke I plan to do a FuzzBench style test between the two variations (`T ConsumeDeserializable(â€¦)` and `std::optional<T> ConsumeDeserializable(â€¦)`) to see which one that helps us reach the highest coverage after 24 hours of fuzzing using `libFuzzer` (with each harness given `1/N` slice of the runtime) with an empty input corpus. Does that sound like a fair experimental setup that could guide,https://github.com/bitcoin/bitcoin/pull/18994#discussion_r433129784,433129784,src/test/fuzz/script_sign.cpp
MarcoFalke,2020-06-01 10:27:18,"Sure, can't hurt to do a benchmark",https://github.com/bitcoin/bitcoin/pull/18994#discussion_r433156970,433156970,src/test/fuzz/script_sign.cpp
