[
  {
    "sha": "d33a9218abda80d32239789f6ceaec6d68a290ce",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkMzNhOTIxOGFiZGE4MGQzMjIzOTc4OWY2Y2VhZWM2ZDY4YTI5MGNl",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-12-01T15:46:23Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-12-02T00:43:35Z"
      },
      "message": "Make SetBestChain() atomic\n\nIn case a reorganisation fails, the internal state could become\ninconsistent (memory only). Previously, a cache per block connect\nor disconnect action was used, so blocks could not be applied in\na partial way. Extend this to a cache for the entire reorganisation,\nmaking it atomic entirely. This also simplifies the code a bit.",
      "tree": {
        "sha": "e0666c57d3c63f73ae496607d913baa0107a6404",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e0666c57d3c63f73ae496607d913baa0107a6404"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d33a9218abda80d32239789f6ceaec6d68a290ce",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d33a9218abda80d32239789f6ceaec6d68a290ce",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d33a9218abda80d32239789f6ceaec6d68a290ce",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d33a9218abda80d32239789f6ceaec6d68a290ce/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "cd7fb7d1deece9da15d7750b3e05f729555a2cbe",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cd7fb7d1deece9da15d7750b3e05f729555a2cbe",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cd7fb7d1deece9da15d7750b3e05f729555a2cbe"
      }
    ],
    "stats": {
      "total": 22,
      "additions": 11,
      "deletions": 11
    },
    "files": [
      {
        "sha": "21c54befcb8ca0e54337ddaf29891eb6f25f9f8c",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d33a9218abda80d32239789f6ceaec6d68a290ce/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d33a9218abda80d32239789f6ceaec6d68a290ce/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=d33a9218abda80d32239789f6ceaec6d68a290ce",
        "patch": "@@ -1667,7 +1667,9 @@ bool CBlock::ConnectBlock(CBlockIndex* pindex, CCoinsViewCache &view, bool fJust\n \n bool SetBestChain(CBlockIndex* pindexNew)\n {\n-    CCoinsViewCache &view = *pcoinsTip;\n+    // All modifications to the coin state will be done in this cache.\n+    // Only when all have succeeded, we push it to pcoinsTip.\n+    CCoinsViewCache view(*pcoinsTip, true);\n \n     // special case for attaching the genesis block\n     // note that no ConnectBlock is called, so its coinbase output is non-spendable\n@@ -1720,11 +1722,8 @@ bool SetBestChain(CBlockIndex* pindexNew)\n         CBlock block;\n         if (!block.ReadFromDisk(pindex))\n             return error(\"SetBestBlock() : ReadFromDisk for disconnect failed\");\n-        CCoinsViewCache viewTemp(view, true);\n-        if (!block.DisconnectBlock(pindex, viewTemp))\n+        if (!block.DisconnectBlock(pindex, view))\n             return error(\"SetBestBlock() : DisconnectBlock %s failed\", BlockHashStr(pindex->GetBlockHash()).c_str());\n-        if (!viewTemp.Flush())\n-            return error(\"SetBestBlock() : Cache flush failed after disconnect\");\n \n         // Queue memory transactions to resurrect\n         BOOST_FOREACH(const CTransaction& tx, block.vtx)\n@@ -1738,26 +1737,27 @@ bool SetBestChain(CBlockIndex* pindexNew)\n         CBlock block;\n         if (!block.ReadFromDisk(pindex))\n             return error(\"SetBestBlock() : ReadFromDisk for connect failed\");\n-        CCoinsViewCache viewTemp(view, true);\n-        if (!block.ConnectBlock(pindex, viewTemp)) {\n+        if (!block.ConnectBlock(pindex, view)) {\n             InvalidChainFound(pindexNew);\n             InvalidBlockFound(pindex);\n             return error(\"SetBestBlock() : ConnectBlock %s failed\", BlockHashStr(pindex->GetBlockHash()).c_str());\n         }\n-        if (!viewTemp.Flush())\n-            return error(\"SetBestBlock() : Cache flush failed after connect\");\n \n         // Queue memory transactions to delete\n         BOOST_FOREACH(const CTransaction& tx, block.vtx)\n             vDelete.push_back(tx);\n     }\n \n+    // Flush changes to global coin state\n+    if (!view.Flush())\n+        return error(\"SetBestBlock() : unable to modify coin state\");\n+\n     // Make sure it's successfully written to disk before changing memory structure\n     bool fIsInitialDownload = IsInitialBlockDownload();\n-    if (!fIsInitialDownload || view.GetCacheSize() > nCoinCacheSize) {\n+    if (!fIsInitialDownload || pcoinsTip->GetCacheSize() > nCoinCacheSize) {\n         FlushBlockFile();\n         pblocktree->Sync();\n-        if (!view.Flush())\n+        if (!pcoinsTip->Flush())\n             return false;\n     }\n "
      }
    ]
  }
]