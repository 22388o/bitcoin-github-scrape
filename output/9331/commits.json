[
  {
    "sha": "d8c0b9f525250565abd5d430a5150e62bf449384",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkOGMwYjlmNTI1MjUwNTY1YWJkNWQ0MzBhNTE1MGU2MmJmNDQ5Mzg0",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2016-12-12T15:18:11Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2016-12-12T15:18:11Z"
      },
      "message": "[qa] Add test for rescan feature of wallet key import RPCs\n\nCovers importaddress, importpubkey, importprivkey, and importmulti RPCs.",
      "tree": {
        "sha": "e762bff89f2b01931a5b5a5cafb06ccce9c7d7bc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e762bff89f2b01931a5b5a5cafb06ccce9c7d7bc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d8c0b9f525250565abd5d430a5150e62bf449384",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d8c0b9f525250565abd5d430a5150e62bf449384",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d8c0b9f525250565abd5d430a5150e62bf449384",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d8c0b9f525250565abd5d430a5150e62bf449384/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "76fcd9d5034143a5b041766552670d19f926097d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/76fcd9d5034143a5b041766552670d19f926097d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/76fcd9d5034143a5b041766552670d19f926097d"
      }
    ],
    "stats": {
      "total": 156,
      "additions": 156,
      "deletions": 0
    },
    "files": [
      {
        "sha": "be31cbbdd30d090de2b1fdb67279ffa758c46a46",
        "filename": "qa/pull-tester/rpc-tests.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d8c0b9f525250565abd5d430a5150e62bf449384/qa/pull-tester/rpc-tests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d8c0b9f525250565abd5d430a5150e62bf449384/qa/pull-tester/rpc-tests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/rpc-tests.py?ref=d8c0b9f525250565abd5d430a5150e62bf449384",
        "patch": "@@ -150,6 +150,7 @@\n     'importprunedfunds.py',\n     'signmessages.py',\n     'nulldummy.py',\n+    'import-rescan.py',\n ]\n if ENABLE_ZMQ:\n     testScripts.append('zmq_test.py')"
      },
      {
        "sha": "e683df26db6258bec6b9efc913b2d409edb68f60",
        "filename": "qa/rpc-tests/import-rescan.py",
        "status": "added",
        "additions": 155,
        "deletions": 0,
        "changes": 155,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d8c0b9f525250565abd5d430a5150e62bf449384/qa/rpc-tests/import-rescan.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d8c0b9f525250565abd5d430a5150e62bf449384/qa/rpc-tests/import-rescan.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/import-rescan.py?ref=d8c0b9f525250565abd5d430a5150e62bf449384",
        "patch": "@@ -0,0 +1,155 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2014-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (start_nodes, connect_nodes, sync_blocks, assert_equal)\n+from decimal import Decimal\n+\n+import collections\n+import enum\n+import itertools\n+import functools\n+\n+Call = enum.Enum(\"Call\", \"single multi\")\n+Data = enum.Enum(\"Data\", \"address pub priv\")\n+ImportNode = collections.namedtuple(\"ImportNode\", \"rescan\")\n+\n+\n+def call_import_rpc(call, data, address, scriptPubKey, pubkey, key, label, node, rescan):\n+    \"\"\"Helper that calls a wallet import RPC on a bitcoin node.\"\"\"\n+    watchonly = data != Data.priv\n+    if call == Call.single:\n+        if data == Data.address:\n+            response = node.importaddress(address, label, rescan)\n+        elif data == Data.pub:\n+            response = node.importpubkey(pubkey, label, rescan)\n+        elif data == Data.priv:\n+            response = node.importprivkey(key, label, rescan)\n+        assert_equal(response, None)\n+    elif call == Call.multi:\n+        response = node.importmulti([{\n+            \"scriptPubKey\": {\n+                \"address\": address\n+            },\n+            \"pubkeys\": [pubkey] if data == Data.pub else [],\n+            \"keys\": [key] if data == Data.priv else [],\n+            \"label\": label,\n+            \"watchonly\": watchonly\n+        }], {\"rescan\": rescan})\n+        assert_equal(response, [{\"success\": True}])\n+    return watchonly\n+\n+\n+# List of RPCs that import a wallet key or address in various ways.\n+IMPORT_RPCS = [functools.partial(call_import_rpc, call, data) for call, data in itertools.product(Call, Data)]\n+\n+# List of bitcoind nodes that will import keys.\n+IMPORT_NODES = [\n+    ImportNode(rescan=True),\n+    ImportNode(rescan=False),\n+]\n+\n+\n+class ImportRescanTest(BitcoinTestFramework):\n+    def __init__(self):\n+        super().__init__()\n+        self.num_nodes = 1 + len(IMPORT_NODES)\n+\n+    def setup_network(self):\n+        extra_args = [[\"-debug=1\"] for _ in range(self.num_nodes)]\n+        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, extra_args)\n+        for i in range(1, self.num_nodes):\n+            connect_nodes(self.nodes[i], 0)\n+\n+    def run_test(self):\n+        # Create one transaction on node 0 with a unique amount and label for\n+        # each possible type of wallet import RPC.\n+        import_rpc_variants = []\n+        for i, import_rpc in enumerate(IMPORT_RPCS):\n+            label = \"label{}\".format(i)\n+            addr = self.nodes[0].validateaddress(self.nodes[0].getnewaddress(label))\n+            key = self.nodes[0].dumpprivkey(addr[\"address\"])\n+            amount = 24.9375 - i * .0625\n+            txid = self.nodes[0].sendtoaddress(addr[\"address\"], amount)\n+            import_rpc = functools.partial(import_rpc, addr[\"address\"], addr[\"scriptPubKey\"], addr[\"pubkey\"], key,\n+                                           label)\n+            import_rpc_variants.append((import_rpc, label, amount, txid, addr))\n+\n+        self.nodes[0].generate(1)\n+        assert_equal(self.nodes[0].getrawmempool(), [])\n+        sync_blocks(self.nodes)\n+\n+        # For each importing node and variation of wallet import RPC, invoke\n+        # the RPC and check the results from getbalance and listtransactions.\n+        for node, import_node in zip(self.nodes[1:], IMPORT_NODES):\n+            for import_rpc, label, amount, txid, addr in import_rpc_variants:\n+                watchonly = import_rpc(node, import_node.rescan)\n+\n+                balance = node.getbalance(label, 0, True)\n+                if import_node.rescan:\n+                    assert_equal(balance, amount)\n+                else:\n+                    assert_equal(balance, 0)\n+\n+                txs = node.listtransactions(label, 10000, 0, True)\n+                if import_node.rescan:\n+                    assert_equal(len(txs), 1)\n+                    assert_equal(txs[0][\"account\"], label)\n+                    assert_equal(txs[0][\"address\"], addr[\"address\"])\n+                    assert_equal(txs[0][\"amount\"], amount)\n+                    assert_equal(txs[0][\"category\"], \"receive\")\n+                    assert_equal(txs[0][\"label\"], label)\n+                    assert_equal(txs[0][\"txid\"], txid)\n+                    assert_equal(txs[0][\"confirmations\"], 1)\n+                    assert_equal(\"trusted\" not in txs[0], True)\n+                    if watchonly:\n+                        assert_equal(txs[0][\"involvesWatchonly\"], True)\n+                    else:\n+                        assert_equal(\"involvesWatchonly\" not in txs[0], True)\n+                else:\n+                    assert_equal(len(txs), 0)\n+\n+        # Create spends for all the imported addresses.\n+        spend_txids = []\n+        fee = self.nodes[0].getnetworkinfo()[\"relayfee\"]\n+        for import_rpc, label, amount, txid, addr in import_rpc_variants:\n+            raw_tx = self.nodes[0].getrawtransaction(txid)\n+            decoded_tx = self.nodes[0].decoderawtransaction(raw_tx)\n+            input_vout = next(out[\"n\"] for out in decoded_tx[\"vout\"]\n+                              if out[\"scriptPubKey\"][\"addresses\"] == [addr[\"address\"]])\n+            inputs = [{\"txid\": txid, \"vout\": input_vout}]\n+            outputs = {self.nodes[0].getnewaddress(): Decimal(amount) - fee}\n+            raw_spend_tx = self.nodes[0].createrawtransaction(inputs, outputs)\n+            signed_spend_tx = self.nodes[0].signrawtransaction(raw_spend_tx)\n+            spend_txid = self.nodes[0].sendrawtransaction(signed_spend_tx[\"hex\"])\n+            spend_txids.append(spend_txid)\n+\n+        self.nodes[0].generate(1)\n+        assert_equal(self.nodes[0].getrawmempool(), [])\n+        sync_blocks(self.nodes)\n+\n+        # Check the results from getbalance and listtransactions after the spends.\n+        for node, import_node in zip(self.nodes[1:], IMPORT_NODES):\n+            txs = node.listtransactions(\"*\", 10000, 0, True)\n+            for (import_rpc, label, amount, txid, addr), spend_txid in zip(import_rpc_variants, spend_txids):\n+                balance = node.getbalance(label, 0, True)\n+                spend_tx = [tx for tx in txs if tx[\"txid\"] == spend_txid]\n+                if import_node.rescan:\n+                    assert_equal(balance, amount)\n+                    assert_equal(len(spend_tx), 1)\n+                    assert_equal(spend_tx[0][\"account\"], \"\")\n+                    assert_equal(spend_tx[0][\"amount\"] + spend_tx[0][\"fee\"], -amount)\n+                    assert_equal(spend_tx[0][\"category\"], \"send\")\n+                    assert_equal(\"label\" not in spend_tx[0], True)\n+                    assert_equal(spend_tx[0][\"confirmations\"], 1)\n+                    assert_equal(\"trusted\" not in spend_tx[0], True)\n+                    assert_equal(\"involvesWatchonly\" not in txs[0], True)\n+                else:\n+                    assert_equal(balance, 0)\n+                    assert_equal(spend_tx, [])\n+\n+\n+if __name__ == \"__main__\":\n+    ImportRescanTest().main()"
      }
    ]
  }
]