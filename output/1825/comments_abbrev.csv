BitcoinPullTester,2012-09-15T22:22:59Z,"Automatic sanity-testing: PASSED, see http://jenkins.bluematt.me/pull-tester/34b6e1c052024a0c80069ef1a7ce63764a496007 for binaries and test log.\n",https://github.com/bitcoin/bitcoin/pull/1825#issuecomment-8589807,8589807,
xanatos,2012-09-17T08:22:47Z,"I haven't benchmarked it, but just to be sure, would it be possible to make a one-shot program to compare all the 4 billion possible compact value SetCompactOld() == SetCompactNew() and from the SetCompact() result GetCompactOld() == GetCompactNew()? (with possible I mean that I don't know how much fast are GetCompact and SetCompact. Being one shot I would find acceptable to take 24h, so it would ",https://github.com/bitcoin/bitcoin/pull/1825#issuecomment-8607208,8607208,
xanatos,2012-09-17T09:44:23Z,"And if you want to document the compact format (something very useful I think), please write in the ""big comment"" the endianness of the mantissa and if ABCD are the 4 bytes of the compact number, which one is the exponent (A?) and which one is the mantissa (BCD in ?endian). As it is I think the format seems still ""black magic"".\n\nI'll add that you haven't really removed the internals of bignumber",https://github.com/bitcoin/bitcoin/pull/1825#issuecomment-8609011,8609011,
roques,2012-09-17T14:30:24Z,"@xanatos: You're raising good questions and I've thus pushed an updated ""big comment"".\n\nOn testing the correctness of the implementation:  I've tested the equivalence of the old and new implementations for a reasonably big subset of all possible compact numbers.  While doing so I've benchmarked the new against the old implementation:  For sizes relevant to bitcoin the new implementation is ~80% ",https://github.com/bitcoin/bitcoin/pull/1825#issuecomment-8616586,8616586,
BitcoinPullTester,2012-09-17T19:05:25Z,"Automatic sanity-testing: PASSED, see http://jenkins.bluematt.me/pull-tester/48a10a37804a01b2533aea920567867deedc6b9e for binaries and test log.\n",https://github.com/bitcoin/bitcoin/pull/1825#issuecomment-8626864,8626864,
laanwj,2012-09-21T15:35:27Z,"I really like that this defines the number formats without relying on OpenSSL internals.\n\nI've checked all 32 bit numbers for SetCompact, comparing old and new implementations, with the following mismatches:\n- 0180xxxx  returns -0 (old) versus  0 (new)\n- 80800000 returns -0 (old) versus  0 (new)\n- 028000xx returns -0 (old) versus  0 (new)\n- xx800000 returns -0 (old) versus  0 (new)\n\nI'm no",https://github.com/bitcoin/bitcoin/pull/1825#issuecomment-8768541,8768541,
roques,2012-09-25T14:30:10Z,"OpenSSL's `BN_set_negative()` can not be used to create a -0:\n`void BN_set_negative(BIGNUM *a, int b)\n        {\n        if (b && !BN_is_zero(a))\n                a->neg = 1;\n        else\n                a->neg = 0;\n        }\n`\nIn fact, all of the OpenSSL basic arithmetic routines are careful not to create a -0.  `BN_mpi2bn()` however can be used to create a -0.\n\nI've looked at the uses o",https://github.com/bitcoin/bitcoin/pull/1825#issuecomment-8856180,8856180,
xanatos,2012-10-20T20:34:33Z,"As another interesting sidenote, contrary to what it's written in the documentation, bn_get_word ignores the sign. So -255 returns 255 (the documentation says ""BN_get_word() returns the value a, and 0xffffffffL if a cannot be represented as an unsigned long."" http://linux.die.net/man/3/bn_get_word , but clearly -255 can't be represented as an unsigned long)\n",https://github.com/bitcoin/bitcoin/pull/1825#issuecomment-9635727,9635727,
sipa,2012-11-14T09:10:24Z,ACK\n,https://github.com/bitcoin/bitcoin/pull/1825#issuecomment-10359490,10359490,
