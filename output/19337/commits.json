[
  {
    "sha": "4df6567e4cbb4677e8048de2f8008612e1b860b9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ZGY2NTY3ZTRjYmI0Njc3ZTgwNDhkZTJmODAwODYxMmUxYjg2MGI5",
    "commit": {
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-06-19T18:51:16Z"
      },
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-08-05T07:42:42Z"
      },
      "message": "sync: make EnterCritical() & push_lock() type safe\n\nThe functions `EnterCritical()` and `push_lock()` take a pointer to a\nmutex, but that pointer used to be of type `void*` because we use a few\ndifferent types for mutexes. This `void*` argument was not type safe\nbecause somebody could have send a pointer to anything that is not a\nmutex. Furthermore it wouldn't allow to check whether the passed mutex\nis recursive or not.\n\nThus, change the functions to templated ones so that we can implement\nstricter checks for non-recursive mutexes. This also simplifies the\ncallers of `EnterCritical()`.",
      "tree": {
        "sha": "b33c0dbe0e968d4157b3fb565408a290d12864f6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b33c0dbe0e968d4157b3fb565408a290d12864f6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4df6567e4cbb4677e8048de2f8008612e1b860b9",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAl8qYvQACgkQVN8G9ktV\ny79jKh//ZYIb2pzaZvEwKraa3SBy/bKRBZaljg6FaYz6dz+L/EPeHPf4Id96Gjqn\nXXspAyQutW/2aeb1eNuo6226y2qAImE0VOBF8TyLoqa6kOpCIgS4oXCGj7IdL7a1\npLfL6lChl4fFkMx6gI9nxDWEpfPDN2j18XVHAIyPOiVcTtB3gZ97XktET8z0oMoa\nt8GR1nm67l+RnGzgiXvQjk9oLWTlYDo1GVBa5BUqPGXC13NEaVhlBosJVwrYytK/\nh9fFGF0XQ9RduJTFVP6d+WL7pNGKiEpg7I+P7lhsMxu/I7kse0lXxHBIPdHI+BHf\nW2QiSusxyzTJ8T0mX0e4+//ECsW8a3NYUsG/SxdYDvUwMHwL7ZHqKup6ZhDjFDVc\nVsDpwAwQXfXlaSz9anVRBSOXxRTKajm68/1cByp1taPRGtHgmTRYXQ0cFI5F0P3w\nIC7fMtm3pRIKhGKB/Ms3vLkaIMYrjHdRd/R0/pw3NnPiKIUBfcJ9SH1zemb+nXUz\n1G9aiHWm3wbnKDxuEKyfeQW/r3EveWb4RgYGFz796ShBvfcHBIBbDHSNv4307IhS\nWgm/CxAcsuZwSMdFmEitkTaUAZmKhwiG/6CpPlA40W+Bg52sYSbbCd64pZzF6qq/\nJyXFgNFKm2FlNDZ8R6YrgFCwWLEOkxUFKAwOH7eGGoFHdguNZyBOsj1TlRLlLrmJ\nvS/fypQhBPPur/6j1kM4/gx1+sFgO5rq+2rkE55fzUeKr76lZYQSVCajV+rbZCof\nQUPwA81RUv2Bq379ZvFxfgAkA/hZw60lhMoevsx7/Lvj6Gct0k7mo/CmjYUrAfg4\ni4s4LbFcDGU15R+23DqlvRK5tOJfXXmtIqE/2HY7x8TgazH+MU/6zayy3R85td/W\nErATUE52YLFBCMJOgX3s6etZo/CSD8cD7ju5kKVJ19oaVvi+IRd4Wv+G+3L1kLrY\n3PCOSy6gxz3lJ4REIaavKUM9SZjiXcciZOsVM7E1trk/VaAAzFAJKthyr6bgG8vg\n9mYYAkWtE9J1iPLMJR+HI1DC4581YmL6Gk6slrJ/rMn+f6UGlSjafrZYxmcMOPiw\n8CS+ZxU9K0+gmb1asnGLlc8GQLtzTSq4379IVC93vY6zKjvRmfhXQzaJBQ5bTLmk\nve71lPO7QM8u1lkkcJNVy2+WBgplT4xaCFOL7pu6GQGzWVQwzugWK4K3TZ/uIy2O\nNOiZTsJH1ugDQjcuuvMaGnoQ8QtcuSuGLR3LQRPxqcmT3wN03RoCjlDtavGLoP1N\nqHzzyt4RKRRskPsqeZT/IP0Gq8dRyOdFHAGJXVre4ZhQELGvZ0h8qbP40Pk1Om4V\njoU/D2nLjHQGj7VRD9WadnRb2vreCA==\n=d6lL\n-----END PGP SIGNATURE-----",
        "payload": "tree b33c0dbe0e968d4157b3fb565408a290d12864f6\nparent 0f16212c5931b30f430014caa485de53f9a14920\nauthor Vasil Dimov <vd@FreeBSD.org> 1592592676 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1596613362 +0200\n\nsync: make EnterCritical() & push_lock() type safe\n\nThe functions `EnterCritical()` and `push_lock()` take a pointer to a\nmutex, but that pointer used to be of type `void*` because we use a few\ndifferent types for mutexes. This `void*` argument was not type safe\nbecause somebody could have send a pointer to anything that is not a\nmutex. Furthermore it wouldn't allow to check whether the passed mutex\nis recursive or not.\n\nThus, change the functions to templated ones so that we can implement\nstricter checks for non-recursive mutexes. This also simplifies the\ncallers of `EnterCritical()`.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4df6567e4cbb4677e8048de2f8008612e1b860b9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4df6567e4cbb4677e8048de2f8008612e1b860b9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4df6567e4cbb4677e8048de2f8008612e1b860b9/comments",
    "author": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0f16212c5931b30f430014caa485de53f9a14920",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0f16212c5931b30f430014caa485de53f9a14920",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0f16212c5931b30f430014caa485de53f9a14920"
      }
    ],
    "stats": {
      "total": 28,
      "additions": 20,
      "deletions": 8
    },
    "files": [
      {
        "sha": "7de8439d6fe84d1d474f312554676ce250ace87a",
        "filename": "src/sync.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 2,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4df6567e4cbb4677e8048de2f8008612e1b860b9/src/sync.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4df6567e4cbb4677e8048de2f8008612e1b860b9/src/sync.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sync.cpp?ref=4df6567e4cbb4677e8048de2f8008612e1b860b9",
        "patch": "@@ -13,7 +13,10 @@\n #include <util/strencodings.h>\n #include <util/threadnames.h>\n \n+#include <boost/thread/mutex.hpp>\n+\n #include <map>\n+#include <mutex>\n #include <set>\n #include <system_error>\n #include <thread>\n@@ -135,7 +138,8 @@ static void potential_deadlock_detected(const LockPair& mismatch, const LockStac\n     throw std::logic_error(strprintf(\"potential deadlock detected: %s -> %s -> %s\", mutex_b, mutex_a, mutex_b));\n }\n \n-static void push_lock(void* c, const CLockLocation& locklocation)\n+template <typename MutexType>\n+static void push_lock(MutexType* c, const CLockLocation& locklocation)\n {\n     LockData& lockdata = GetLockData();\n     std::lock_guard<std::mutex> lock(lockdata.dd_mutex);\n@@ -175,10 +179,16 @@ static void pop_lock()\n     }\n }\n \n-void EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry)\n+template <typename MutexType>\n+void EnterCritical(const char* pszName, const char* pszFile, int nLine, MutexType* cs, bool fTry)\n {\n     push_lock(cs, CLockLocation(pszName, pszFile, nLine, fTry, util::ThreadGetInternalName()));\n }\n+template void EnterCritical(const char*, const char*, int, Mutex*, bool);\n+template void EnterCritical(const char*, const char*, int, RecursiveMutex*, bool);\n+template void EnterCritical(const char*, const char*, int, std::mutex*, bool);\n+template void EnterCritical(const char*, const char*, int, std::recursive_mutex*, bool);\n+template void EnterCritical(const char*, const char*, int, boost::mutex*, bool);\n \n void CheckLastCritical(void* cs, std::string& lockname, const char* guardname, const char* file, int line)\n {"
      },
      {
        "sha": "ef9ad4c5451d44147b359975bf593aef6b4af377",
        "filename": "src/sync.h",
        "status": "modified",
        "additions": 8,
        "deletions": 6,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4df6567e4cbb4677e8048de2f8008612e1b860b9/src/sync.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4df6567e4cbb4677e8048de2f8008612e1b860b9/src/sync.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sync.h?ref=4df6567e4cbb4677e8048de2f8008612e1b860b9",
        "patch": "@@ -48,7 +48,8 @@ LEAVE_CRITICAL_SECTION(mutex); // no RAII\n ///////////////////////////////\n \n #ifdef DEBUG_LOCKORDER\n-void EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false);\n+template <typename MutexType>\n+void EnterCritical(const char* pszName, const char* pszFile, int nLine, MutexType* cs, bool fTry = false);\n void LeaveCritical();\n void CheckLastCritical(void* cs, std::string& lockname, const char* guardname, const char* file, int line);\n std::string LocksHeld();\n@@ -65,7 +66,8 @@ bool LockStackEmpty();\n  */\n extern bool g_debug_lockorder_abort;\n #else\n-inline void EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false) {}\n+template <typename MutexType>\n+inline void EnterCritical(const char* pszName, const char* pszFile, int nLine, MutexType* cs, bool fTry = false) {}\n inline void LeaveCritical() {}\n inline void CheckLastCritical(void* cs, std::string& lockname, const char* guardname, const char* file, int line) {}\n template <typename MutexType>\n@@ -133,7 +135,7 @@ class SCOPED_LOCKABLE UniqueLock : public Base\n private:\n     void Enter(const char* pszName, const char* pszFile, int nLine)\n     {\n-        EnterCritical(pszName, pszFile, nLine, (void*)(Base::mutex()));\n+        EnterCritical(pszName, pszFile, nLine, Base::mutex());\n #ifdef DEBUG_LOCKCONTENTION\n         if (!Base::try_lock()) {\n             PrintLockContention(pszName, pszFile, nLine);\n@@ -146,7 +148,7 @@ class SCOPED_LOCKABLE UniqueLock : public Base\n \n     bool TryEnter(const char* pszName, const char* pszFile, int nLine)\n     {\n-        EnterCritical(pszName, pszFile, nLine, (void*)(Base::mutex()), true);\n+        EnterCritical(pszName, pszFile, nLine, Base::mutex(), true);\n         Base::try_lock();\n         if (!Base::owns_lock())\n             LeaveCritical();\n@@ -203,7 +205,7 @@ class SCOPED_LOCKABLE UniqueLock : public Base\n \n         ~reverse_lock() {\n             templock.swap(lock);\n-            EnterCritical(lockname.c_str(), file.c_str(), line, (void*)lock.mutex());\n+            EnterCritical(lockname.c_str(), file.c_str(), line, lock.mutex());\n             lock.lock();\n         }\n \n@@ -234,7 +236,7 @@ using DebugLock = UniqueLock<typename std::remove_reference<typename std::remove\n \n #define ENTER_CRITICAL_SECTION(cs)                            \\\n     {                                                         \\\n-        EnterCritical(#cs, __FILE__, __LINE__, (void*)(&cs)); \\\n+        EnterCritical(#cs, __FILE__, __LINE__, &cs); \\\n         (cs).lock();                                          \\\n     }\n "
      }
    ]
  },
  {
    "sha": "95975dd08d8fdaaeaf28e0d06b861ce2748c17b6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NTk3NWRkMDhkOGZkYWFlYWYyOGUwZDA2Yjg2MWNlMjc0OGMxN2I2",
    "commit": {
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-06-20T13:31:55Z"
      },
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-08-10T16:43:08Z"
      },
      "message": "sync: detect double lock from the same thread\n\nDouble lock of the same (non-recursive) mutex from the same thread\nis producing an undefined behavior. Detect this from DEBUG_LOCKORDER\nand react similarly to the deadlock detection.",
      "tree": {
        "sha": "c2fb3525064d0a722cad4c27cccdef67f41e4647",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c2fb3525064d0a722cad4c27cccdef67f41e4647"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/95975dd08d8fdaaeaf28e0d06b861ce2748c17b6",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAl8xeSAACgkQVN8G9ktV\ny793Eh//Z3eJYcwNbnmcvfJWI332Xy4P7i0jOE3Iw5TMr6LGZ+ofT1E/tqDSojwP\nFd4X0gG/lweS3YzZTIxRBW2gYkDpbc1bxL0i+67asfVkkPkurQKk7vViqxkhlhwm\ncajJYVJkd0OXvB/zI1twf9l7L91XmEZ82TKPlWHQO9BcudSiSiZVsI44lFM2lvK9\nFds0qW4kxEysyA1I4nlkuugiDC8dy9pmOkD4y3dywAZyvAkrrsHpkO4L7C0U5mCV\npkhyPYoR6D2dQat2lCMs3+QnXk5HfL+QpkrtvgKdXZlt/5SdU6a+DKo92+DBMXUo\nOsIZ8mIUoEvw2zz/w5nfwrllUQWoJJ11q999JSZ6DM3lrkaPseSqOxFTWYegvvPJ\nFsrSD2gBfuBehaJ5f/QYBzA2zoB57OvFjF245X/KuCiVPWK2iEmHo3jEgMG+oabG\n8YKXlpy3Z3qhO1E2PbjwMp9JtI+ghxclZyKfZqfuLZCXPdGzHX5ntHc6MGpqsNOp\ndEY/sTZuMGaRRXMwnA7Ljt5CRZ+CAljXCKQ2YE/Sem/woLWgV+0KK60XMtS9OIRA\nfojVaCnebBOu4YP4FieulzsN4hIvFYSBmW8FcI/V+pFEl0KctyuuVuyrr7fnum1u\nfdkZ93rmjahgv2mTLuDvIegDNhgOqqni7pMfC/26uQpjXqxaESEtgZNcMSl2YDbx\n7yQ7O2toqbYsTTlKPo2+8TK1LY1MEJbiAL/KiMC0eTUGE3lge9YWZVk99sVFPwkJ\njzlHbxio1dHkYPkfurjPVw/28VWFF8F59VnJfNwmNbMNpEb25QiikMytQJRha6mm\nvv8L73G3WX2zfJFaXaIuGoO2zmVU1jpS8FLtNxI9u2UNn5KCvV3shArhyeKqFMf7\nkT3OZbehiBnG/Pp5crs9vPUQVdqTXpkQz23YGAZiOa93OmYOhWqHWuCD6BFUlsgX\nuqyPQ9X6B0+v5f9cNcnZHqaHwcwmuZPxy5JeehsrB8D0HtVnSUwZtWrOI4N/1Xv7\nwfRHRxABrh2Q44oeSnDVb6sXTWnxezelQRp4g4XyRixQJQDS2Jmp77QJ+a1nMwwP\ndyrNcoDdASSGYgkUWppwRWo59Gwkg95OD2JNTaaSk4iLB5OuPFHN5kiJsFFCbMh5\nBxHONXIFuLIcB9/pRkWNaVsSsKJ6PPVlrsSj5tMEcqO2F4uMEL1iqIo38vk+gxw+\n0LBEVy/cqaZNTx4dM4tpOAKnXJUr5SJEZ5/QCNJCwVdKTTLqluYreaJX2xk1rQ0+\nD+BQo/FNV+IIu2jY+tX8iR4jLbplmVvSwE/NgxX6GdNSGwhllbqPCKc+E92gj/yT\nsPvLOYxERnrVDpFQMZWpQ6Bf5I9VIw==\n=+C8Q\n-----END PGP SIGNATURE-----",
        "payload": "tree c2fb3525064d0a722cad4c27cccdef67f41e4647\nparent 4df6567e4cbb4677e8048de2f8008612e1b860b9\nauthor Vasil Dimov <vd@FreeBSD.org> 1592659915 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1597077788 +0200\n\nsync: detect double lock from the same thread\n\nDouble lock of the same (non-recursive) mutex from the same thread\nis producing an undefined behavior. Detect this from DEBUG_LOCKORDER\nand react similarly to the deadlock detection.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/95975dd08d8fdaaeaf28e0d06b861ce2748c17b6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/95975dd08d8fdaaeaf28e0d06b861ce2748c17b6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/95975dd08d8fdaaeaf28e0d06b861ce2748c17b6/comments",
    "author": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4df6567e4cbb4677e8048de2f8008612e1b860b9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4df6567e4cbb4677e8048de2f8008612e1b860b9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4df6567e4cbb4677e8048de2f8008612e1b860b9"
      }
    ],
    "stats": {
      "total": 95,
      "additions": 92,
      "deletions": 3
    },
    "files": [
      {
        "sha": "d020b4e3345d20ae408245bce64401357239f69b",
        "filename": "src/sync.cpp",
        "status": "modified",
        "additions": 37,
        "deletions": 3,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/95975dd08d8fdaaeaf28e0d06b861ce2748c17b6/src/sync.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/95975dd08d8fdaaeaf28e0d06b861ce2748c17b6/src/sync.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sync.cpp?ref=95975dd08d8fdaaeaf28e0d06b861ce2748c17b6",
        "patch": "@@ -20,6 +20,7 @@\n #include <set>\n #include <system_error>\n #include <thread>\n+#include <type_traits>\n #include <unordered_map>\n #include <utility>\n #include <vector>\n@@ -138,17 +139,50 @@ static void potential_deadlock_detected(const LockPair& mismatch, const LockStac\n     throw std::logic_error(strprintf(\"potential deadlock detected: %s -> %s -> %s\", mutex_b, mutex_a, mutex_b));\n }\n \n+static void double_lock_detected(const void* mutex, LockStack& lock_stack)\n+{\n+    LogPrintf(\"DOUBLE LOCK DETECTED\\n\");\n+    LogPrintf(\"Lock order:\\n\");\n+    for (const LockStackItem& i : lock_stack) {\n+        if (i.first == mutex) {\n+            LogPrintf(\" (*)\"); /* Continued */\n+        }\n+        LogPrintf(\" %s\\n\", i.second.ToString());\n+    }\n+    if (g_debug_lockorder_abort) {\n+        tfm::format(std::cerr, \"Assertion failed: detected double lock at %s:%i, details in debug log.\\n\", __FILE__, __LINE__);\n+        abort();\n+    }\n+    throw std::logic_error(\"double lock detected\");\n+}\n+\n template <typename MutexType>\n static void push_lock(MutexType* c, const CLockLocation& locklocation)\n {\n+    constexpr bool is_recursive_mutex =\n+        std::is_base_of<RecursiveMutex, MutexType>::value ||\n+        std::is_base_of<std::recursive_mutex, MutexType>::value;\n+\n     LockData& lockdata = GetLockData();\n     std::lock_guard<std::mutex> lock(lockdata.dd_mutex);\n \n     LockStack& lock_stack = lockdata.m_lock_stacks[std::this_thread::get_id()];\n     lock_stack.emplace_back(c, locklocation);\n-    for (const LockStackItem& i : lock_stack) {\n-        if (i.first == c)\n-            break;\n+    for (size_t j = 0; j < lock_stack.size() - 1; ++j) {\n+        const LockStackItem& i = lock_stack[j];\n+        if (i.first == c) {\n+            if (is_recursive_mutex) {\n+                break;\n+            }\n+            // It is not a recursive mutex and it appears in the stack two times:\n+            // at position `j` and at the end (which we added just before this loop).\n+            // Can't allow locking the same (non-recursive) mutex two times from the\n+            // same thread as that results in an undefined behavior.\n+            auto lock_stack_copy = lock_stack;\n+            lock_stack.pop_back();\n+            double_lock_detected(c, lock_stack_copy);\n+            // double_lock_detected() does not return.\n+        }\n \n         const LockPair p1 = std::make_pair(i.first, c);\n         if (lockdata.lockorders.count(p1))"
      },
      {
        "sha": "6c148672110cee935f2a30656b5ae4359b0c81b6",
        "filename": "src/test/sync_tests.cpp",
        "status": "modified",
        "additions": 55,
        "deletions": 0,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/95975dd08d8fdaaeaf28e0d06b861ce2748c17b6/src/test/sync_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/95975dd08d8fdaaeaf28e0d06b861ce2748c17b6/src/test/sync_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sync_tests.cpp?ref=95975dd08d8fdaaeaf28e0d06b861ce2748c17b6",
        "patch": "@@ -6,6 +6,9 @@\n #include <test/util/setup_common.h>\n \n #include <boost/test/unit_test.hpp>\n+#include <boost/thread/mutex.hpp>\n+\n+#include <mutex>\n \n namespace {\n template <typename MutexType>\n@@ -29,6 +32,38 @@ void TestPotentialDeadLockDetected(MutexType& mutex1, MutexType& mutex2)\n     BOOST_CHECK(!error_thrown);\n     #endif\n }\n+\n+#ifdef DEBUG_LOCKORDER\n+template <typename MutexType>\n+void TestDoubleLock2(MutexType& m)\n+{\n+    ENTER_CRITICAL_SECTION(m);\n+    LEAVE_CRITICAL_SECTION(m);\n+}\n+\n+template <typename MutexType>\n+void TestDoubleLock(bool should_throw)\n+{\n+    const bool prev = g_debug_lockorder_abort;\n+    g_debug_lockorder_abort = false;\n+\n+    MutexType m;\n+    ENTER_CRITICAL_SECTION(m);\n+    if (should_throw) {\n+        BOOST_CHECK_EXCEPTION(\n+            TestDoubleLock2(m), std::logic_error, [](const std::logic_error& e) {\n+                return strcmp(e.what(), \"double lock detected\") == 0;\n+            });\n+    } else {\n+        BOOST_CHECK_NO_THROW(TestDoubleLock2(m));\n+    }\n+    LEAVE_CRITICAL_SECTION(m);\n+\n+    BOOST_CHECK(LockStackEmpty());\n+\n+    g_debug_lockorder_abort = prev;\n+}\n+#endif /* DEBUG_LOCKORDER */\n } // namespace\n \n BOOST_FIXTURE_TEST_SUITE(sync_tests, BasicTestingSetup)\n@@ -55,4 +90,24 @@ BOOST_AUTO_TEST_CASE(potential_deadlock_detected)\n     #endif\n }\n \n+/* Double lock would produce an undefined behavior. Thus, we only do that if\n+ * DEBUG_LOCKORDER is activated to detect it. We don't want non-DEBUG_LOCKORDER\n+ * build to produce tests that exhibit known undefined behavior. */\n+#ifdef DEBUG_LOCKORDER\n+BOOST_AUTO_TEST_CASE(double_lock_mutex)\n+{\n+    TestDoubleLock<Mutex>(true /* should throw */);\n+}\n+\n+BOOST_AUTO_TEST_CASE(double_lock_boost_mutex)\n+{\n+    TestDoubleLock<boost::mutex>(true /* should throw */);\n+}\n+\n+BOOST_AUTO_TEST_CASE(double_lock_recursive_mutex)\n+{\n+    TestDoubleLock<RecursiveMutex>(false /* should not throw */);\n+}\n+#endif /* DEBUG_LOCKORDER */\n+\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  }
]