[
  {
    "sha": "0ec16f35d6b8d9f1fe876f1405f105f6e5aa0933",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowZWMxNmYzNWQ2YjhkOWYxZmU4NzZmMTQwNWYxMDVmNmU1YWEwOTMz",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-11-16T17:40:55Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-01-27T20:13:48Z"
      },
      "message": "Move only: extract WriteChainState and UpdatedTip from SetBestChain.",
      "tree": {
        "sha": "168735fd5687e83b50448b7e78640728b5ade3eb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/168735fd5687e83b50448b7e78640728b5ade3eb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0ec16f35d6b8d9f1fe876f1405f105f6e5aa0933",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0ec16f35d6b8d9f1fe876f1405f105f6e5aa0933",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0ec16f35d6b8d9f1fe876f1405f105f6e5aa0933",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0ec16f35d6b8d9f1fe876f1405f105f6e5aa0933/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ca1913e8f64fc245157b008d6b37160306aa1d83",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ca1913e8f64fc245157b008d6b37160306aa1d83",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ca1913e8f64fc245157b008d6b37160306aa1d83"
      }
    ],
    "stats": {
      "total": 123,
      "additions": 63,
      "deletions": 60
    },
    "files": [
      {
        "sha": "6e1919c9a69dea48d107a44e8429a37a978e9840",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 63,
        "deletions": 60,
        "changes": 123,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0ec16f35d6b8d9f1fe876f1405f105f6e5aa0933/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0ec16f35d6b8d9f1fe876f1405f105f6e5aa0933/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=0ec16f35d6b8d9f1fe876f1405f105f6e5aa0933",
        "patch": "@@ -1746,6 +1746,66 @@ bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, C\n     return true;\n }\n \n+bool static WriteChainState(CValidationState &state) {\n+    if (!IsInitialBlockDownload() || pcoinsTip->GetCacheSize() > nCoinCacheSize) {\n+        // Typical CCoins structures on disk are around 100 bytes in size.\n+        // Pushing a new one to the database can cause it to be written\n+        // twice (once in the log, and once in the tables). This is already\n+        // an overestimation, as most will delete an existing entry or\n+        // overwrite one. Still, use a conservative safety factor of 2.\n+        if (!CheckDiskSpace(100 * 2 * 2 * pcoinsTip->GetCacheSize()))\n+            return state.Error();\n+        FlushBlockFile();\n+        pblocktree->Sync();\n+        if (!pcoinsTip->Flush())\n+            return state.Abort(_(\"Failed to write to coin database\"));\n+    }\n+    return true;\n+}\n+\n+void static UpdateTip(CBlockIndex *pindexNew) {\n+    chainActive.SetTip(pindexNew);\n+\n+    // Update best block in wallet (so we can detect restored wallets)\n+    bool fIsInitialDownload = IsInitialBlockDownload();\n+    if ((chainActive.Height() % 20160) == 0 || (!fIsInitialDownload && (chainActive.Height() % 144) == 0))\n+        g_signals.SetBestChain(chainActive.GetLocator());\n+\n+    // New best block\n+    nTimeBestReceived = GetTime();\n+    mempool.AddTransactionsUpdated(1);\n+    LogPrintf(\"UpdateTip: new best=%s  height=%d  log2_work=%.8g  tx=%lu  date=%s progress=%f\\n\",\n+      chainActive.Tip()->GetBlockHash().ToString(), chainActive.Height(), log(chainActive.Tip()->nChainWork.getdouble())/log(2.0), (unsigned long)chainActive.Tip()->nChainTx,\n+      DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", chainActive.Tip()->GetBlockTime()),\n+      Checkpoints::GuessVerificationProgress(chainActive.Tip()));\n+\n+    // Check the version of the last 100 blocks to see if we need to upgrade:\n+    if (!fIsInitialDownload)\n+    {\n+        int nUpgraded = 0;\n+        const CBlockIndex* pindex = chainActive.Tip();\n+        for (int i = 0; i < 100 && pindex != NULL; i++)\n+        {\n+            if (pindex->nVersion > CBlock::CURRENT_VERSION)\n+                ++nUpgraded;\n+            pindex = pindex->pprev;\n+        }\n+        if (nUpgraded > 0)\n+            LogPrintf(\"SetBestChain: %d of last 100 blocks above version %d\\n\", nUpgraded, (int)CBlock::CURRENT_VERSION);\n+        if (nUpgraded > 100/2)\n+            // strMiscWarning is read by GetWarnings(), called by Qt and the JSON-RPC code to warn the user:\n+            strMiscWarning = _(\"Warning: This version is obsolete, upgrade required!\");\n+    }\n+\n+    std::string strCmd = GetArg(\"-blocknotify\", \"\");\n+\n+    if (!fIsInitialDownload && !strCmd.empty())\n+    {\n+        boost::replace_all(strCmd, \"%s\", chainActive.Tip()->GetBlockHash().GetHex());\n+        boost::thread t(runCommand, strCmd); // thread runs free\n+    }\n+}\n+\n bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n {\n     mempool.check(pcoinsTip);\n@@ -1839,27 +1899,8 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n     if (fBenchmark)\n         LogPrintf(\"- Flush %i transactions: %.2fms (%.4fms/tx)\\n\", nModified, 0.001 * nTime, 0.001 * nTime / nModified);\n \n-    // Make sure it's successfully written to disk before changing memory structure\n-    bool fIsInitialDownload = IsInitialBlockDownload();\n-    if (!fIsInitialDownload || pcoinsTip->GetCacheSize() > nCoinCacheSize) {\n-        // Typical CCoins structures on disk are around 100 bytes in size.\n-        // Pushing a new one to the database can cause it to be written\n-        // twice (once in the log, and once in the tables). This is already\n-        // an overestimation, as most will delete an existing entry or\n-        // overwrite one. Still, use a conservative safety factor of 2.\n-        if (!CheckDiskSpace(100 * 2 * 2 * pcoinsTip->GetCacheSize()))\n-            return state.Error();\n-        FlushBlockFile();\n-        pblocktree->Sync();\n-        if (!pcoinsTip->Flush())\n-            return state.Abort(_(\"Failed to write to coin database\"));\n-    }\n-\n-    // At this point, all changes have been done to the database.\n-    // Proceed by updating the memory structures.\n-\n-    // Register new best chain\n-    chainActive.SetTip(pindexNew);\n+    if (!WriteChainState(state))\n+        return false;\n \n     // Resurrect memory transactions that were in the disconnected branch\n     BOOST_FOREACH(CTransaction& tx, vResurrect) {\n@@ -1877,48 +1918,10 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n \n     mempool.check(pcoinsTip);\n \n-    // Update best block in wallet (so we can detect restored wallets)\n-    if ((pindexNew->nHeight % 20160) == 0 || (!fIsInitialDownload && (pindexNew->nHeight % 144) == 0))\n-        g_signals.SetBestChain(chainActive.GetLocator(pindexNew));\n-\n-    // New best block\n-    nTimeBestReceived = GetTime();\n-    mempool.AddTransactionsUpdated(1);\n-    LogPrintf(\"SetBestChain: new best=%s  height=%d  log2_work=%.8g  tx=%lu  date=%s progress=%f\\n\",\n-      chainActive.Tip()->GetBlockHash().ToString(), chainActive.Height(), log(chainActive.Tip()->nChainWork.getdouble())/log(2.0), (unsigned long)pindexNew->nChainTx,\n-      DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", chainActive.Tip()->GetBlockTime()),\n-      Checkpoints::GuessVerificationProgress(chainActive.Tip()));\n-\n-    // Check the version of the last 100 blocks to see if we need to upgrade:\n-    if (!fIsInitialDownload)\n-    {\n-        int nUpgraded = 0;\n-        const CBlockIndex* pindex = chainActive.Tip();\n-        for (int i = 0; i < 100 && pindex != NULL; i++)\n-        {\n-            if (pindex->nVersion > CBlock::CURRENT_VERSION)\n-                ++nUpgraded;\n-            pindex = pindex->pprev;\n-        }\n-        if (nUpgraded > 0)\n-            LogPrintf(\"SetBestChain: %d of last 100 blocks above version %d\\n\", nUpgraded, (int)CBlock::CURRENT_VERSION);\n-        if (nUpgraded > 100/2)\n-            // strMiscWarning is read by GetWarnings(), called by Qt and the JSON-RPC code to warn the user:\n-            strMiscWarning = _(\"Warning: This version is obsolete, upgrade required!\");\n-    }\n-\n-    std::string strCmd = GetArg(\"-blocknotify\", \"\");\n-\n-    if (!fIsInitialDownload && !strCmd.empty())\n-    {\n-        boost::replace_all(strCmd, \"%s\", chainActive.Tip()->GetBlockHash().GetHex());\n-        boost::thread t(runCommand, strCmd); // thread runs free\n-    }\n-\n+    UpdateTip(pindexNew);\n     return true;\n }\n \n-\n bool AddToBlockIndex(CBlock& block, CValidationState& state, const CDiskBlockPos& pos)\n {\n     // Check for duplicate"
      }
    ]
  },
  {
    "sha": "75f51f2a63e0ebe34ab290c2b7141dd240b98c3b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3NWY1MWYyYTYzZTBlYmUzNGFiMjkwYzJiNzE0MWRkMjQwYjk4YzNi",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-11-16T18:28:24Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-01-27T20:20:41Z"
      },
      "message": "Prepare block connection logic for headers-first.\n\nThis changes the block processing logic from \"try to atomically switch\nto a new block\" to a continuous \"(dis)connect a block, aiming for the\nassumed best chain\".\n\nThis means the smallest atomic operations on the chainstate become\nindividual block connections or disconnections, instead of entire\nreorganizations. It may mean that we try to reorganize to one block,\nfail, and rereorganize again to the old block. This is slower, but\ndoesn't require unbounded RAM.\n\nIt also means that a ConnectBlock which fails may be no longer called\nfrom the ProcessBlock which knows which node sent it. To deal with that,\na mapBlockSource is kept, and invalid blocks cause asynchronous \"reject\"\nmessages and banning (if necessary).",
      "tree": {
        "sha": "ed9be9e3acbcd9d9df9f67264042109b8cd7db98",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ed9be9e3acbcd9d9df9f67264042109b8cd7db98"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/75f51f2a63e0ebe34ab290c2b7141dd240b98c3b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/75f51f2a63e0ebe34ab290c2b7141dd240b98c3b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/75f51f2a63e0ebe34ab290c2b7141dd240b98c3b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/75f51f2a63e0ebe34ab290c2b7141dd240b98c3b/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0ec16f35d6b8d9f1fe876f1405f105f6e5aa0933",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0ec16f35d6b8d9f1fe876f1405f105f6e5aa0933",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0ec16f35d6b8d9f1fe876f1405f105f6e5aa0933"
      }
    ],
    "stats": {
      "total": 460,
      "additions": 256,
      "deletions": 204
    },
    "files": [
      {
        "sha": "8520d63c89ef41789272302431696b28eca2ca45",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/75f51f2a63e0ebe34ab290c2b7141dd240b98c3b/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/75f51f2a63e0ebe34ab290c2b7141dd240b98c3b/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=75f51f2a63e0ebe34ab290c2b7141dd240b98c3b",
        "patch": "@@ -983,7 +983,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n \n     // scan for better chains in the block chain database, that are not yet connected in the active best chain\n     CValidationState state;\n-    if (!ConnectBestBlock(state))\n+    if (!ActivateBestChain(state))\n         strErrors << \"Failed to connect best block\";\n \n     std::vector<boost::filesystem::path> vImportFiles;"
      },
      {
        "sha": "660380b99185f23edf27d936fb1c0a8d67c22e04",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 243,
        "deletions": 195,
        "changes": 438,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/75f51f2a63e0ebe34ab290c2b7141dd240b98c3b/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/75f51f2a63e0ebe34ab290c2b7141dd240b98c3b/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=75f51f2a63e0ebe34ab290c2b7141dd240b98c3b",
        "patch": "@@ -41,6 +41,7 @@ CTxMemPool mempool;\n \n map<uint256, CBlockIndex*> mapBlockIndex;\n CChain chainActive;\n+CChain chainMostWork;\n int64_t nTimeBestReceived = 0;\n int nScriptCheckThreads = 0;\n bool fImporting = false;\n@@ -77,13 +78,21 @@ namespace {\n struct CBlockIndexWorkComparator\n {\n     bool operator()(CBlockIndex *pa, CBlockIndex *pb) {\n+        // First sort by most total work, ...\n         if (pa->nChainWork > pb->nChainWork) return false;\n         if (pa->nChainWork < pb->nChainWork) return true;\n \n-        if (pa->GetBlockHash() < pb->GetBlockHash()) return false;\n-        if (pa->GetBlockHash() > pb->GetBlockHash()) return true;\n+        // ... then by earliest time received, ...\n+        if (pa->nSequenceId < pb->nSequenceId) return false;\n+        if (pa->nSequenceId > pb->nSequenceId) return true;\n \n-        return false; // identical blocks\n+        // Use pointer address as tie breaker (should only happen with blocks\n+        // loaded from disk, as those all have id 0).\n+        if (pa < pb) return false;\n+        if (pa > pb) return true;\n+\n+        // Identical blocks.\n+        return false;\n     }\n };\n \n@@ -93,6 +102,16 @@ set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexValid; // may contain\n CCriticalSection cs_LastBlockFile;\n CBlockFileInfo infoLastBlockFile;\n int nLastBlockFile = 0;\n+\n+// Every received block is assigned a unique and increasing identifier, so we\n+// know which one to give priority in case of a fork.\n+CCriticalSection cs_nBlockSequenceId;\n+// Blocks loaded from disk are assigned id 0, so start the counter at 1.\n+uint32_t nBlockSequenceId = 1;\n+\n+// Sources of received blocks, to be able to send them reject messages or ban\n+// them, if processing happens afterwards. Protected by cs_main.\n+map<uint256, NodeId> mapBlockSource;\n }\n \n //////////////////////////////////////////////////////////////////////////////\n@@ -156,21 +175,34 @@ void SyncWithWallets(const uint256 &hash, const CTransaction &tx, const CBlock *\n //\n \n namespace {\n+\n+struct CBlockReject {\n+    unsigned char chRejectCode;\n+    string strRejectReason;\n+    uint256 hashBlock;\n+};\n+\n // Maintain validation-specific state about nodes, protected by cs_main, instead\n // by CNode's own locks. This simplifies asynchronous operation, where\n // processing of incoming data is done after the ProcessMessage call returns,\n // and we're no longer holding the node's locks.\n struct CNodeState {\n+    // Accumulated misbehaviour score for this peer.\n     int nMisbehavior;\n+    // Whether this peer should be disconnected and banned.\n     bool fShouldBan;\n+    // String name of this peer (debugging/logging purposes).\n     std::string name;\n+    // List of asynchronously-determined block rejections to notify this peer about.\n+    std::vector<CBlockReject> rejects;\n \n     CNodeState() {\n         nMisbehavior = 0;\n         fShouldBan = false;\n     }\n };\n \n+// Map maintaining per-node state. Requires cs_main.\n map<NodeId, CNodeState> mapNodeState;\n \n // Requires cs_main.\n@@ -1242,6 +1274,24 @@ void CheckForkWarningConditionsOnNewFork(CBlockIndex* pindexNewForkTip)\n     CheckForkWarningConditions();\n }\n \n+void Misbehaving(NodeId pnode, int howmuch)\n+{\n+    if (howmuch == 0)\n+        return;\n+\n+    CNodeState *state = State(pnode);\n+    if (state == NULL)\n+        return;\n+\n+    state->nMisbehavior += howmuch;\n+    if (state->nMisbehavior >= GetArg(\"-banscore\", 100))\n+    {\n+        LogPrintf(\"Misbehaving: %s (%d -> %d) BAN THRESHOLD EXCEEDED\\n\", state->name, state->nMisbehavior-howmuch, state->nMisbehavior);\n+        state->fShouldBan = true;\n+    } else\n+        LogPrintf(\"Misbehaving: %s (%d -> %d)\\n\", state->name, state->nMisbehavior-howmuch, state->nMisbehavior);\n+}\n+\n void static InvalidChainFound(CBlockIndex* pindexNew)\n {\n     if (!pindexBestInvalid || pindexNew->nChainWork > pindexBestInvalid->nChainWork)\n@@ -1263,67 +1313,23 @@ void static InvalidChainFound(CBlockIndex* pindexNew)\n     CheckForkWarningConditions();\n }\n \n-void static InvalidBlockFound(CBlockIndex *pindex) {\n-    pindex->nStatus |= BLOCK_FAILED_VALID;\n-    pblocktree->WriteBlockIndex(CDiskBlockIndex(pindex));\n-    setBlockIndexValid.erase(pindex);\n-    InvalidChainFound(pindex);\n-    if (chainActive.Next(pindex)) {\n-        CValidationState stateDummy;\n-        ConnectBestBlock(stateDummy); // reorganise away from the failed block\n-    }\n-}\n-\n-bool ConnectBestBlock(CValidationState &state) {\n-    do {\n-        CBlockIndex *pindexNewBest;\n-\n-        {\n-            std::set<CBlockIndex*,CBlockIndexWorkComparator>::reverse_iterator it = setBlockIndexValid.rbegin();\n-            if (it == setBlockIndexValid.rend())\n-                return true;\n-            pindexNewBest = *it;\n+void static InvalidBlockFound(CBlockIndex *pindex, const CValidationState &state) {\n+    int nDoS = 0;\n+    if (state.IsInvalid(nDoS)) {\n+        std::map<uint256, NodeId>::iterator it = mapBlockSource.find(pindex->GetBlockHash());\n+        if (it != mapBlockSource.end() && State(it->second)) {\n+            CBlockReject reject = {state.GetRejectCode(), state.GetRejectReason(), pindex->GetBlockHash()};\n+            State(it->second)->rejects.push_back(reject);\n+            if (nDoS > 0)\n+                Misbehaving(it->second, nDoS);\n         }\n-\n-        if (pindexNewBest == chainActive.Tip() || (chainActive.Tip() && pindexNewBest->nChainWork == chainActive.Tip()->nChainWork))\n-            return true; // nothing to do\n-\n-        // check ancestry\n-        CBlockIndex *pindexTest = pindexNewBest;\n-        std::vector<CBlockIndex*> vAttach;\n-        do {\n-            if (pindexTest->nStatus & BLOCK_FAILED_MASK) {\n-                // mark descendants failed\n-                CBlockIndex *pindexFailed = pindexNewBest;\n-                while (pindexTest != pindexFailed) {\n-                    pindexFailed->nStatus |= BLOCK_FAILED_CHILD;\n-                    setBlockIndexValid.erase(pindexFailed);\n-                    pblocktree->WriteBlockIndex(CDiskBlockIndex(pindexFailed));\n-                    pindexFailed = pindexFailed->pprev;\n-                }\n-                InvalidChainFound(pindexNewBest);\n-                break;\n-            }\n-\n-            if (chainActive.Tip() == NULL || pindexTest->nChainWork > chainActive.Tip()->nChainWork)\n-                vAttach.push_back(pindexTest);\n-\n-            if (pindexTest->pprev == NULL || chainActive.Next(pindexTest)) {\n-                reverse(vAttach.begin(), vAttach.end());\n-                BOOST_FOREACH(CBlockIndex *pindexSwitch, vAttach) {\n-                    boost::this_thread::interruption_point();\n-                    try {\n-                        if (!SetBestChain(state, pindexSwitch))\n-                            return false;\n-                    } catch(std::runtime_error &e) {\n-                        return state.Abort(_(\"System error: \") + e.what());\n-                    }\n-                }\n-                return true;\n-            }\n-            pindexTest = pindexTest->pprev;\n-        } while(true);\n-    } while(true);\n+    }\n+    if (!state.CorruptionPossible()) {\n+        pindex->nStatus |= BLOCK_FAILED_VALID;\n+        pblocktree->WriteBlockIndex(CDiskBlockIndex(pindex));\n+        setBlockIndexValid.erase(pindex);\n+        InvalidChainFound(pindex);\n+    }\n }\n \n void UpdateTime(CBlockHeader& block, const CBlockIndex* pindexPrev)\n@@ -1746,8 +1752,10 @@ bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, C\n     return true;\n }\n \n+// Update the on-disk chain state.\n bool static WriteChainState(CValidationState &state) {\n-    if (!IsInitialBlockDownload() || pcoinsTip->GetCacheSize() > nCoinCacheSize) {\n+    static int64_t nLastWrite = 0;\n+    if (!IsInitialBlockDownload() || pcoinsTip->GetCacheSize() > nCoinCacheSize || GetTimeMicros() > nLastWrite + 600*1000000) {\n         // Typical CCoins structures on disk are around 100 bytes in size.\n         // Pushing a new one to the database can cause it to be written\n         // twice (once in the log, and once in the tables). This is already\n@@ -1759,10 +1767,12 @@ bool static WriteChainState(CValidationState &state) {\n         pblocktree->Sync();\n         if (!pcoinsTip->Flush())\n             return state.Abort(_(\"Failed to write to coin database\"));\n+        nLastWrite = GetTimeMicros();\n     }\n     return true;\n }\n \n+// Update chainActive and related internal data structures.\n void static UpdateTip(CBlockIndex *pindexNew) {\n     chainActive.SetTip(pindexNew);\n \n@@ -1796,129 +1806,179 @@ void static UpdateTip(CBlockIndex *pindexNew) {\n             // strMiscWarning is read by GetWarnings(), called by Qt and the JSON-RPC code to warn the user:\n             strMiscWarning = _(\"Warning: This version is obsolete, upgrade required!\");\n     }\n+}\n \n-    std::string strCmd = GetArg(\"-blocknotify\", \"\");\n-\n-    if (!fIsInitialDownload && !strCmd.empty())\n+// Disconnect chainActive's tip.\n+bool static DisconnectTip(CValidationState &state) {\n+    CBlockIndex *pindexDelete = chainActive.Tip();\n+    assert(pindexDelete);\n+    mempool.check(pcoinsTip);\n+    // Read block from disk.\n+    CBlock block;\n+    if (!ReadBlockFromDisk(block, pindexDelete))\n+        return state.Abort(_(\"Failed to read block\"));\n+    // Apply the block atomically to the chain state.\n+    int64_t nStart = GetTimeMicros();\n     {\n-        boost::replace_all(strCmd, \"%s\", chainActive.Tip()->GetBlockHash().GetHex());\n-        boost::thread t(runCommand, strCmd); // thread runs free\n+        CCoinsViewCache view(*pcoinsTip, true);\n+        if (!DisconnectBlock(block, state, pindexDelete, view))\n+            return error(\"DisconnectTip() : DisconnectBlock %s failed\", pindexDelete->GetBlockHash().ToString());\n+        assert(view.Flush());\n     }\n+    if (fBenchmark)\n+        LogPrintf(\"- Disconnect: %.2fms\\n\", (GetTimeMicros() - nStart) * 0.001);\n+    // Write the chain state to disk, if necessary.\n+    if (!WriteChainState(state))\n+        return false;\n+    // Ressurect mempool transactions from the disconnected block.\n+    BOOST_FOREACH(const CTransaction &tx, block.vtx) {\n+        // ignore validation errors in resurrected transactions\n+        CValidationState stateDummy; \n+        if (!tx.IsCoinBase())\n+            if (!AcceptToMemoryPool(mempool, stateDummy, tx, false, NULL))\n+                mempool.remove(tx, true);\n+    }\n+    mempool.check(pcoinsTip);\n+    // Update chainActive and related variables.\n+    UpdateTip(pindexDelete->pprev);\n+    return true;\n }\n \n-bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n-{\n+// Connect a new block to chainActive.\n+bool static ConnectTip(CValidationState &state, CBlockIndex *pindexNew) {\n+    assert(pindexNew->pprev == chainActive.Tip());\n     mempool.check(pcoinsTip);\n-\n-    // All modifications to the coin state will be done in this cache.\n-    // Only when all have succeeded, we push it to pcoinsTip.\n-    CCoinsViewCache view(*pcoinsTip, true);\n-\n-    // Find the fork (typically, there is none)\n-    std::map<uint256, CBlockIndex*>::iterator it = mapBlockIndex.find(view.GetBestBlock());\n-    CBlockIndex* ptip = (it != mapBlockIndex.end()) ? it->second : NULL;\n-    CBlockIndex* pfork = ptip;\n-    CBlockIndex* plonger = pindexNew;\n-    while (pfork && pfork != plonger)\n+    // Read block from disk.\n+    CBlock block;\n+    if (!ReadBlockFromDisk(block, pindexNew))\n+        return state.Abort(_(\"Failed to read block\"));\n+    // Apply the block atomically to the chain state.\n+    int64_t nStart = GetTimeMicros();\n     {\n-        while (plonger->nHeight > pfork->nHeight) {\n-            plonger = plonger->pprev;\n-            assert(plonger != NULL);\n+        CCoinsViewCache view(*pcoinsTip, true);\n+        CInv inv(MSG_BLOCK, pindexNew->GetBlockHash());\n+        if (!ConnectBlock(block, state, pindexNew, view)) {\n+            if (state.IsInvalid())\n+                InvalidBlockFound(pindexNew, state);\n+            return error(\"ConnectTip() : ConnectBlock %s failed\", pindexNew->GetBlockHash().ToString());\n         }\n-        if (pfork == plonger)\n-            break;\n-        pfork = pfork->pprev;\n-        assert(pfork != NULL);\n+        mapBlockSource.erase(inv.hash);\n+        assert(view.Flush());\n     }\n+    if (fBenchmark)\n+        LogPrintf(\"- Connect: %.2fms\\n\", (GetTimeMicros() - nStart) * 0.001);\n+    // Write the chain state to disk, if necessary.\n+    if (!WriteChainState(state))\n+        return false;\n+    // Remove conflicting transactions from the mempool.\n+    BOOST_FOREACH(const CTransaction &tx, block.vtx) {\n+        mempool.remove(tx);\n+        mempool.removeConflicts(tx);\n+    }\n+    mempool.check(pcoinsTip);\n+    // Update chainActive & related variables.\n+    UpdateTip(pindexNew);\n+    return true;\n+}\n \n-    // List of what to disconnect (typically nothing)\n-    vector<CBlockIndex*> vDisconnect;\n-    for (CBlockIndex* pindex = ptip; pindex != pfork; pindex = pindex->pprev)\n-        vDisconnect.push_back(pindex);\n-\n-    // List of what to connect (typically only pindexNew)\n-    vector<CBlockIndex*> vConnect;\n-    for (CBlockIndex* pindex = pindexNew; pindex != pfork; pindex = pindex->pprev)\n-        vConnect.push_back(pindex);\n-    reverse(vConnect.begin(), vConnect.end());\n+// Make chainMostWork correspond to the chain with the most work in it, that isn't\n+// known to be invalid (it's however far from certain to be valid).\n+void static FindMostWorkChain() {\n+    CBlockIndex *pindexNew = NULL;\n \n-    if (vDisconnect.size() > 0) {\n-        LogPrintf(\"REORGANIZE: Disconnect %\"PRIszu\" blocks; %s...\\n\", vDisconnect.size(), pfork->GetBlockHash().ToString());\n-        LogPrintf(\"REORGANIZE: Connect %\"PRIszu\" blocks; ...%s\\n\", vConnect.size(), pindexNew->GetBlockHash().ToString());\n+    // In case the current best is invalid, do not consider it.\n+    while (chainMostWork.Tip() && (chainMostWork.Tip()->nStatus & BLOCK_FAILED_MASK)) {\n+        setBlockIndexValid.erase(chainMostWork.Tip());\n+        chainMostWork.SetTip(chainMostWork.Tip()->pprev);\n     }\n \n-    // Disconnect shorter branch\n-    list<CTransaction> vResurrect;\n-    BOOST_FOREACH(CBlockIndex* pindex, vDisconnect) {\n-        CBlock block;\n-        if (!ReadBlockFromDisk(block, pindex))\n-            return state.Abort(_(\"Failed to read block\"));\n-        int64_t nStart = GetTimeMicros();\n-        if (!DisconnectBlock(block, state, pindex, view))\n-            return error(\"SetBestBlock() : DisconnectBlock %s failed\", pindex->GetBlockHash().ToString());\n-        if (fBenchmark)\n-            LogPrintf(\"- Disconnect: %.2fms\\n\", (GetTimeMicros() - nStart) * 0.001);\n-\n-        // Queue memory transactions to resurrect.\n-        // We only do this for blocks after the last checkpoint (reorganisation before that\n-        // point should only happen with -reindex/-loadblock, or a misbehaving peer.\n-        BOOST_REVERSE_FOREACH(const CTransaction& tx, block.vtx)\n-            if (!tx.IsCoinBase() && pindex->nHeight > Checkpoints::GetTotalBlocksEstimate())\n-                vResurrect.push_front(tx);\n-    }\n+    do {\n+        // Find the best candidate header.\n+        {\n+            std::set<CBlockIndex*, CBlockIndexWorkComparator>::reverse_iterator it = setBlockIndexValid.rbegin();\n+            if (it == setBlockIndexValid.rend())\n+                return;\n+            pindexNew = *it;\n+        }\n \n-    // Connect longer branch\n-    vector<CTransaction> vDelete;\n-    BOOST_FOREACH(CBlockIndex *pindex, vConnect) {\n-        CBlock block;\n-        if (!ReadBlockFromDisk(block, pindex))\n-            return state.Abort(_(\"Failed to read block\"));\n-        int64_t nStart = GetTimeMicros();\n-        if (!ConnectBlock(block, state, pindex, view)) {\n-            if (state.IsInvalid()) {\n-                InvalidChainFound(pindexNew);\n-                InvalidBlockFound(pindex);\n+        // Check whether all blocks on the path between the currently active chain and the candidate are valid.\n+        // Just going until the active chain is an optimization, as we know all blocks in it are valid already.\n+        CBlockIndex *pindexTest = pindexNew;\n+        bool fInvalidAncestor = false;\n+        while (pindexTest && !chainActive.Contains(pindexTest)) {\n+            if (pindexTest->nStatus & BLOCK_FAILED_MASK) {\n+                // Candidate has an invalid ancestor, remove entire chain from the set.\n+                if (pindexBestInvalid == NULL || pindexNew->nChainWork > pindexBestInvalid->nChainWork)\n+                    pindexBestInvalid = pindexNew;                CBlockIndex *pindexFailed = pindexNew;\n+                while (pindexTest != pindexFailed) {\n+                    pindexFailed->nStatus |= BLOCK_FAILED_CHILD;\n+                    setBlockIndexValid.erase(pindexFailed);\n+                    pindexFailed = pindexFailed->pprev;\n+                }\n+                fInvalidAncestor = true;\n+                break;\n             }\n-            return error(\"SetBestBlock() : ConnectBlock %s failed\", pindex->GetBlockHash().ToString());\n+            pindexTest = pindexTest->pprev;\n         }\n-        if (fBenchmark)\n-            LogPrintf(\"- Connect: %.2fms\\n\", (GetTimeMicros() - nStart) * 0.001);\n+        if (fInvalidAncestor)\n+            continue;\n \n-        // Queue memory transactions to delete\n-        BOOST_FOREACH(const CTransaction& tx, block.vtx)\n-            vDelete.push_back(tx);\n-    }\n+        break;\n+    } while(true);\n \n-    // Flush changes to global coin state\n-    int64_t nStart = GetTimeMicros();\n-    int nModified = view.GetCacheSize();\n-    bool ret;\n-    ret = view.Flush();\n-    assert(ret);\n-    int64_t nTime = GetTimeMicros() - nStart;\n-    if (fBenchmark)\n-        LogPrintf(\"- Flush %i transactions: %.2fms (%.4fms/tx)\\n\", nModified, 0.001 * nTime, 0.001 * nTime / nModified);\n+    // Check whether it's actually an improvement.\n+    if (chainMostWork.Tip() && !CBlockIndexWorkComparator()(chainMostWork.Tip(), pindexNew))\n+        return;\n \n-    if (!WriteChainState(state))\n-        return false;\n+    // We have a new best.\n+    chainMostWork.SetTip(pindexNew);\n+}\n \n-    // Resurrect memory transactions that were in the disconnected branch\n-    BOOST_FOREACH(CTransaction& tx, vResurrect) {\n-        // ignore validation errors in resurrected transactions\n-        CValidationState stateDummy;\n-        if (!AcceptToMemoryPool(mempool,stateDummy, tx, false, NULL))\n-            mempool.remove(tx, true);\n-    }\n+// Try to activate to the most-work chain (thereby connecting it).\n+bool ActivateBestChain(CValidationState &state) {\n+    CBlockIndex *pindexOldTip = chainActive.Tip();\n+    bool fComplete = false;\n+    while (!fComplete) {\n+        FindMostWorkChain();\n+        fComplete = true;\n \n-    // Delete redundant memory transactions that are in the connected branch\n-    BOOST_FOREACH(CTransaction& tx, vDelete) {\n-        mempool.remove(tx);\n-        mempool.removeConflicts(tx);\n+        // Check whether we have something to do.\n+        if (chainMostWork.Tip() == NULL) break;\n+\n+        // Disconnect active blocks which are no longer in the best chain.\n+        while (chainActive.Tip() && !chainMostWork.Contains(chainActive.Tip())) {\n+            if (!DisconnectTip(state))\n+                return false;\n+        }\n+\n+        // Connect new blocks.\n+        while (!chainActive.Contains(chainMostWork.Tip())) {\n+            CBlockIndex *pindexConnect = chainMostWork[chainActive.Height() + 1];\n+            if (!ConnectTip(state, pindexConnect)) {\n+                if (state.IsInvalid()) {\n+                    // The block violates a consensus rule.\n+                    if (!state.CorruptionPossible())\n+                        InvalidChainFound(chainMostWork.Tip());\n+                    fComplete = false;\n+                    state = CValidationState();\n+                    break;\n+                } else {\n+                    // A system error occurred (disk space, database error, ...).\n+                    return false;\n+                }\n+            }\n+        }\n     }\n \n-    mempool.check(pcoinsTip);\n+    if (chainActive.Tip() != pindexOldTip) {\n+        std::string strCmd = GetArg(\"-blocknotify\", \"\");\n+        if (!IsInitialBlockDownload() && !strCmd.empty())\n+        {\n+            boost::replace_all(strCmd, \"%s\", chainActive.Tip()->GetBlockHash().GetHex());\n+            boost::thread t(runCommand, strCmd); // thread runs free\n+        }\n+    }\n \n-    UpdateTip(pindexNew);\n     return true;\n }\n \n@@ -1931,7 +1991,12 @@ bool AddToBlockIndex(CBlock& block, CValidationState& state, const CDiskBlockPos\n \n     // Construct new block index object\n     CBlockIndex* pindexNew = new CBlockIndex(block);\n+    {\n+         LOCK(cs_nBlockSequenceId);\n+         pindexNew->nSequenceId = nBlockSequenceId++;\n+    }\n     assert(pindexNew);\n+    mapAlreadyAskedFor.erase(CInv(MSG_BLOCK, hash));\n     map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.insert(make_pair(hash, pindexNew)).first;\n     pindexNew->phashBlock = &((*mi).first);\n     map<uint256, CBlockIndex*>::iterator miPrev = mapBlockIndex.find(block.hashPrevBlock);\n@@ -1953,7 +2018,7 @@ bool AddToBlockIndex(CBlock& block, CValidationState& state, const CDiskBlockPos\n         return state.Abort(_(\"Failed to write block index\"));\n \n     // New best?\n-    if (!ConnectBestBlock(state))\n+    if (!ActivateBestChain(state))\n         return false;\n \n     if (pindexNew == chainActive.Tip())\n@@ -2277,8 +2342,11 @@ bool ProcessBlock(CValidationState &state, CNode* pfrom, CBlock* pblock, CDiskBl\n         return state.Invalid(error(\"ProcessBlock() : already have block (orphan) %s\", hash.ToString()));\n \n     // Preliminary checks\n-    if (!CheckBlock(*pblock, state))\n+    if (!CheckBlock(*pblock, state)) {\n+        if (state.CorruptionPossible())\n+            mapAlreadyAskedFor.erase(CInv(MSG_BLOCK, hash));\n         return error(\"ProcessBlock() : CheckBlock FAILED\");\n+    }\n \n     CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint(mapBlockIndex);\n     if (pcheckpoint && pblock->hashPrevBlock != (chainActive.Tip() ? chainActive.Tip()->GetBlockHash() : uint256(0)))\n@@ -3007,24 +3075,6 @@ bool static AlreadyHave(const CInv& inv)\n }\n \n \n-void Misbehaving(NodeId pnode, int howmuch)\n-{\n-    if (howmuch == 0)\n-        return;\n-\n-    CNodeState *state = State(pnode);\n-    if (state == NULL)\n-        return;\n-\n-    state->nMisbehavior += howmuch;\n-    if (state->nMisbehavior >= GetArg(\"-banscore\", 100))\n-    {\n-        LogPrintf(\"Misbehaving: %s (%d -> %d) BAN THRESHOLD EXCEEDED\\n\", state->name, state->nMisbehavior-howmuch, state->nMisbehavior);\n-        state->fShouldBan = true;\n-    } else\n-        LogPrintf(\"Misbehaving: %s (%d -> %d)\\n\", state->name, state->nMisbehavior-howmuch, state->nMisbehavior);\n-}\n-\n void static ProcessGetData(CNode* pfrom)\n {\n     std::deque<CInv>::iterator it = pfrom->vRecvGetData.begin();\n@@ -3587,18 +3637,11 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         pfrom->AddInventoryKnown(inv);\n \n         LOCK(cs_main);\n+        // Remember who we got this block from.\n+        mapBlockSource[inv.hash] = pfrom->GetId();\n \n         CValidationState state;\n-        if (ProcessBlock(state, pfrom, &block) || state.CorruptionPossible())\n-            mapAlreadyAskedFor.erase(inv);\n-        int nDoS = 0;\n-        if (state.IsInvalid(nDoS))\n-        {\n-            pfrom->PushMessage(\"reject\", strCommand, state.GetRejectCode(),\n-                               state.GetRejectReason(), inv.hash);\n-            if (nDoS > 0)\n-                Misbehaving(pfrom->GetId(), nDoS);\n-        }\n+        ProcessBlock(state, pfrom, &block);\n     }\n \n \n@@ -4045,16 +4088,21 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n         if (!lockMain)\n             return true;\n \n-        if (State(pto->GetId())->fShouldBan) {\n+        CNodeState &state = *State(pto->GetId());\n+        if (state.fShouldBan) {\n             if (pto->addr.IsLocal())\n                 LogPrintf(\"Warning: not banning local node %s!\\n\", pto->addr.ToString());\n             else {\n                 pto->fDisconnect = true;\n                 CNode::Ban(pto->addr);\n             }\n-            State(pto->GetId())->fShouldBan = false;\n+            state.fShouldBan = false;\n         }\n \n+        BOOST_FOREACH(const CBlockReject& reject, state.rejects)\n+            pto->PushMessage(\"reject\", (string)\"block\", reject.chRejectCode, reject.strRejectReason, reject.hashBlock);\n+        state.rejects.clear();\n+\n         // Start block sync\n         if (pto->fStartSync && !fImporting && !fReindex) {\n             pto->fStartSync = false;"
      },
      {
        "sha": "ba353a885b32e95994c6cc706f68e7e2a5747423",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 12,
        "deletions": 8,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/75f51f2a63e0ebe34ab290c2b7141dd240b98c3b/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/75f51f2a63e0ebe34ab290c2b7141dd240b98c3b/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=75f51f2a63e0ebe34ab290c2b7141dd240b98c3b",
        "patch": "@@ -165,10 +165,8 @@ bool IsInitialBlockDownload();\n std::string GetWarnings(std::string strFor);\n /** Retrieve a transaction (from memory pool, or from disk, if possible) */\n bool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock, bool fAllowSlow = false);\n-/** Connect/disconnect blocks until pindexNew is the new tip of the active block chain */\n-bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew);\n /** Find the best known block, and make it the tip of the block chain */\n-bool ConnectBestBlock(CValidationState &state);\n+bool ActivateBestChain(CValidationState &state);\n int64_t GetBlockValue(int nHeight, int64_t nFees);\n unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlockHeader *pblock);\n \n@@ -716,6 +714,8 @@ class CBlockIndex\n     unsigned int nBits;\n     unsigned int nNonce;\n \n+    // (memory only) Sequencial id assigned to distinguish order in which blocks are received.\n+    uint32_t nSequenceId;\n \n     CBlockIndex()\n     {\n@@ -729,6 +729,7 @@ class CBlockIndex\n         nTx = 0;\n         nChainTx = 0;\n         nStatus = 0;\n+        nSequenceId = 0;\n \n         nVersion       = 0;\n         hashMerkleRoot = 0;\n@@ -749,6 +750,7 @@ class CBlockIndex\n         nTx = 0;\n         nChainTx = 0;\n         nStatus = 0;\n+        nSequenceId = 0;\n \n         nVersion       = block.nVersion;\n         hashMerkleRoot = block.hashMerkleRoot;\n@@ -958,23 +960,23 @@ class CValidationState {\n         AbortNode(msg);\n         return Error();\n     }\n-    bool IsValid() {\n+    bool IsValid() const {\n         return mode == MODE_VALID;\n     }\n-    bool IsInvalid() {\n+    bool IsInvalid() const {\n         return mode == MODE_INVALID;\n     }\n-    bool IsError() {\n+    bool IsError() const {\n         return mode == MODE_ERROR;\n     }\n-    bool IsInvalid(int &nDoSOut) {\n+    bool IsInvalid(int &nDoSOut) const {\n         if (IsInvalid()) {\n             nDoSOut = nDoS;\n             return true;\n         }\n         return false;\n     }\n-    bool CorruptionPossible() {\n+    bool CorruptionPossible() const {\n         return corruptionPossible;\n     }\n     unsigned char GetRejectCode() const { return chRejectCode; }\n@@ -1041,6 +1043,8 @@ class CChain {\n /** The currently-connected chain of blocks. */\n extern CChain chainActive;\n \n+/** The currently best known chain of headers (some of which may be invalid). */\n+extern CChain chainMostWork;\n \n /** Global variable that points to the active CCoinsView (protected by cs_main) */\n extern CCoinsViewCache *pcoinsTip;"
      }
    ]
  }
]