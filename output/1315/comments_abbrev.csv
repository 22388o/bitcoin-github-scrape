rebroad,2012-05-15T15:43:25Z,I suspected getblocks was probably the answer :)\n\nIt would be very nice to see a mini white paper on what this does and how it works....\n,https://github.com/bitcoin/bitcoin/pull/1315#issuecomment-5719161,5719161,
gmaxwell,2012-05-16T02:13:22Z,"K. Tested resync from start several times. Tested partial resync. Tested recovery from fork with reorg on non-stuck node. Tested recovery from a forkmode stuck node. Tested with loadblocks.   Make sure it wasn't bloating up the chain with a ton of copies of extra block ....  I can't break it, so I'm pulling.\n",https://github.com/bitcoin/bitcoin/pull/1315#issuecomment-5732165,5732165,
rebroad,2012-05-17T02:09:02Z,"Just out of interest, does the initial getblocks (that's sent to the first peer upon starting the node) also cause the recovery from afork stuck node? Is it that this change is to enable it to become unstuck without restarting the node? Or did even restarting not fix things?\n",https://github.com/bitcoin/bitcoin/pull/1315#issuecomment-5756764,5756764,
gmaxwell,2012-05-17T02:23:05Z,Even restarting did not fix the particular issue this fix was needed to address— but normal nodes probably can't get into that state.  (The nodes in question were ones that got stuck due to incorrectly rejecting the correct chain because e.g. of premature BIP16 enforcement)\n,https://github.com/bitcoin/bitcoin/pull/1315#issuecomment-5756911,5756911,
sipa,2012-05-17T10:10:53Z,"A bit more elaborate: if you were running an 0.6 RC, you would have code that used the old BIP16 switchover date. The date passed, but you did not update your software. Suddenly someone sends an invalid BIP transaction (so, one that is valid according to the traditional rules, but not according to the BIP16 rules). On the main network BIP16 validation is not active, so the transaction gets accepte",https://github.com/bitcoin/bitcoin/pull/1315#issuecomment-5761362,5761362,
rebroad,2012-05-17T10:22:59Z,"I understand the explanation so far but it still doesn't explain how the new getblocks achieves that, and why upon receiving the very latest block, that that doesn't fix it, nor why it can't be coded to re-evaluate the last 6 or so blocks in the last known valid again to see if they are still valid by any new rules. The last solution would be better, IMHO, as it wouldn't increase network traffic, ",https://github.com/bitcoin/bitcoin/pull/1315#issuecomment-5761515,5761515,
rebroad,2012-05-17T10:29:57Z,"Sorry, meant to say, that it could re-check the invalid again upon start up, perhaps by giving a command line option or perhaps automatically whenever the invalid again is longer by 6 blocks or more.\n\nSent from my Nokia phone\n-----Original Message-----\nFrom: Pieter Wuille\nSent:  17/05/2012 11:10:55\nSubject:  Re: [bitcoin] Hopefully final fix for the stuck blockchain issue (#1315)\n\nA bit mo",https://github.com/bitcoin/bitcoin/pull/1315#issuecomment-5761599,5761599,
sipa,2012-05-17T10:30:36Z,"This fix will - over the course of an entire blockchain syncup - maybe cause 50 kilobytes extra communication. What you suggest is also possible, but harder and with less guarantees, in my opinion. You'd need to traverse the entire blockchain database and find stale chains, and re-evaluate them all?\n",https://github.com/bitcoin/bitcoin/pull/1315#issuecomment-5761609,5761609,
rebroad,2012-05-17T10:35:16Z,"Doesn't this fix also increase data transfer even after the node has caught up? I thought it does getblocks upon receipt of every block, doesn't it?\n\nTo re-evaluate the invalid again it would only need to re-evaluate one block upon start-up in the example you give. The first block in the longest invalid chain. \n",https://github.com/bitcoin/bitcoin/pull/1315#issuecomment-5761659,5761659,
rebroad,2012-05-17T10:37:06Z,"Also, technically, i'd say this current fix requires a BIP.\n",https://github.com/bitcoin/bitcoin/pull/1315#issuecomment-5761691,5761691,
sipa,2012-05-17T10:44:16Z,"In normal operation, this patch does nothing. It only sends out a getblocks when an inv is received with blocks that are already known and part of the block tree. During normal operation, this never happens, as you only request invs for the part after the main chain. And the block-sync process has never been well-formalized, though the responses to the network requests are. Those aren't changed ho",https://github.com/bitcoin/bitcoin/pull/1315#issuecomment-5761765,5761765,
rebroad,2012-05-17T10:51:09Z,"I think you are incorrect to say it doesn't happen during normal operation. This is not my experience. When i new block arrives on the network, let's say 8 nodes announce it in invs. My node will getdata it from the first one, download it and ProcessBlock it usually well before the last connected peer sends invs for it, so with this code with each new block, the slowest peers to announce it will r",https://github.com/bitcoin/bitcoin/pull/1315#issuecomment-5761856,5761856,
gmaxwell,2012-05-17T13:15:34Z,"While previously testing this I specifically looked for excess requests during normal operations and didn't see any.  Either I made a mistake or just had unlucky timing— or it's something about the peer mix thats triggering it, because I see ones now— about 1769 of them on 05/16.\n\nActually, they seem to be being caused in high volume by specific peers. E.g. I have a couple which are each respons",https://github.com/bitcoin/bitcoin/pull/1315#issuecomment-5763769,5763769,
rebroad,2012-05-17T16:32:18Z,"I've added a fix to this, in my current bitcoin-ParallelBlockDownload branch (the 3rd commit of pull #1326).... I still think the ideal solution is to do it without using the network though....\n",https://github.com/bitcoin/bitcoin/pull/1315#issuecomment-5767885,5767885,
