[
  {
    "sha": "64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2NGRmZGRlMGFhN2Y3ZWYyNGU2Y2JmM2M1N2U2ZDI0ZWZjNTUzNjdl",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2016-12-13T11:37:40Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2016-12-13T11:37:40Z"
      },
      "message": "Squashed 'src/secp256k1/' changes from 6c527ec..8225239\n\n8225239 Merge #433: Make the libcrypto detection fail the newer API.\n12de863 Make the libcrypto detection fail the newer API.\n2928420 Merge #427: Remove Schnorr from travis as well\n8eecc4a Remove Schnorr from travis as well\na8abae7 Merge #310: Add exhaustive test for group functions on a low-order subgroup\nb4ceedf Add exhaustive test for verification\n83836a9 Add exhaustive tests for group arithmetic, signing, and ecmult on a small group\n20b8877 Add exhaustive test for group functions on a low-order subgroup\n80773a6 Merge #425: Remove Schnorr experiment\ne06e878 Remove Schnorr experiment\n04c8ef3 Merge #407: Modify parameter order of internal functions to match API parameter order\n6e06696 Merge #411: Remove guarantees about memcmp-ability\n40c8d7e Merge #421: Update scalar_4x64_impl.h\na922365 Merge #422: Restructure nonce clearing\n3769783 Restructure nonce clearing\n0f9e69d Restructure nonce clearing\n9d67afa Update scalar_4x64_impl.h\n7d15cd7 Merge #413: fix auto-enabled static precompuatation\n00c5d2e fix auto-enabled static precompuatation\n91219a1 Remove guarantees about memcmp-ability\n7a49cac Merge #410: Add string.h include to ecmult_impl\n0bbd5d4 Add string.h include to ecmult_impl\n353c1bf Fix secp256k1_ge_set_table_gej_var parameter order\n541b783 Fix secp256k1_ge_set_all_gej_var parameter order\n7d893f4 Fix secp256k1_fe_inv_all_var parameter order\nc5b32e1 Merge #405: Make secp256k1_fe_sqrt constant time\n926836a Make secp256k1_fe_sqrt constant time\ne2a8e92 Merge #404: Replace 3M + 4S doubling formula with 2M + 5S one\n8ec49d8 Add note about 2M + 5S doubling formula\n5a91bd7 Merge #400: A couple minor cleanups\nac01378 build: add -DSECP256K1_BUILD to benchmark_internal build flags\na6c6f99 Remove a bunch of unused stdlib #includes\n65285a6 Merge #403: configure: add flag to disable OpenSSL tests\na9b2a5d configure: add flag to disable OpenSSL tests\nb340123 Merge #402: Add support for testing quadratic residues\ne6e9805 Add function for testing quadratic residue field/group elements.\nefd953a Add Jacobi symbol test via GMP\nfa36a0d Merge #401: ecmult_const: unify endomorphism and non-endomorphism skew cases\nc6191fd ecmult_const: unify endomorphism and non-endomorphism skew cases\n0b3e618 Merge #378: .gitignore build-aux cleanup\n6042217 Merge #384: JNI: align shared files copyright/comments to bitcoinj's\n24ad20f Merge #399: build: verify that the native compiler works for static precomp\nb3be852 Merge #398: Test whether ECDH and Schnorr are enabled for JNI\naa0b1fd build: verify that the native compiler works for static precomp\neee808d Test whether ECDH and Schnorr are enabled for JNI\n7b0fb18 Merge #366: ARM assembly implementation of field_10x26 inner (rebase of #173)\n001f176 ARM assembly implementation of field_10x26 inner\n0172be9 Merge #397: Small fixes for sha256\n3f8b78e Fix undefs in hash_impl.h\n2ab4695 Fix state size in sha256 struct\n6875b01 Merge #386: Add some missing `VERIFY_CHECK(ctx != NULL)`\n2c52b5d Merge #389: Cast pointers through uintptr_t under JNI\n43097a4 Merge #390: Update bitcoin-core GitHub links\n31c9c12 Merge #391: JNI: Only call ecdsa_verify if its inputs parsed correctly\n1cb2302 Merge #392: Add testcase which hits additional branch in secp256k1_scalar_sqr\nd2ee340 Merge #388: bench_ecdh: fix call to secp256k1_context_create\n093a497 Add testcase which hits additional branch in secp256k1_scalar_sqr\na40c701 JNI: Only call ecdsa_verify if its inputs parsed correctly\nfaa2a11 Update bitcoin-core GitHub links\n47b9e78 Cast pointers through uintptr_t under JNI\nf36f9c6 bench_ecdh: fix call to secp256k1_context_create\nbcc4881 Add some missing `VERIFY_CHECK(ctx != NULL)` for functions that use `ARG_CHECK`\n6ceea2c align shared files copyright/comments to bitcoinj's\n70141a8 Update .gitignore\n7b549b1 Merge #373: build: fix x86_64 asm detection for some compilers\nbc7c93c Merge #374: Add note about y=0 being possible on one of the sextic twists\ne457018 Merge #364: JNI rebased\n86e2d07 JNI library: cleanup, removed unimplemented code\n3093576a JNI library\nbd2895f Merge pull request #371\ne72e93a Add note about y=0 being possible on one of the sextic twists\n3f8fdfb build: fix x86_64 asm detection for some compilers\ne5a9047 [Trivial] Remove double semicolons\nc18b869 Merge pull request #360\n3026daa Merge pull request #302\n03d4611 Add sage verification script for the group laws\na965937 Merge pull request #361\n83221ec Add experimental features to configure\n5d4c5a3 Prevent damage_array in the signature test from going out of bounds.\n419bf7f Merge pull request #356\n03d84a4 Benchmark against OpenSSL verification\n\ngit-subtree-dir: src/secp256k1\ngit-subtree-split: 8225239f490f79842a5a3b82ad6cc8aa11d5208e",
      "tree": {
        "sha": "8a1dfe59fe37e649e6c687386318cf6f2194f199",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8a1dfe59fe37e649e6c687386318cf6f2194f199"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5ad54630935d1f340666de7bc9ffef9b8a1df296",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5ad54630935d1f340666de7bc9ffef9b8a1df296",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5ad54630935d1f340666de7bc9ffef9b8a1df296"
      }
    ],
    "stats": {
      "total": 5477,
      "additions": 4463,
      "deletions": 1014
    },
    "files": [
      {
        "sha": "87fea161ba5aea04756cb378d487b703bb2e2ab2",
        "filename": ".gitignore",
        "status": "modified",
        "additions": 14,
        "deletions": 6,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.gitignore?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -6,6 +6,7 @@ bench_schnorr_verify\n bench_recover\n bench_internal\n tests\n+exhaustive_tests\n gen_context\n *.exe\n *.so\n@@ -25,17 +26,24 @@ config.status\n libtool\n .deps/\n .dirstamp\n-build-aux/\n *.lo\n *.o\n *~\n src/libsecp256k1-config.h\n src/libsecp256k1-config.h.in\n src/ecmult_static_context.h\n-m4/libtool.m4\n-m4/ltoptions.m4\n-m4/ltsugar.m4\n-m4/ltversion.m4\n-m4/lt~obsolete.m4\n+build-aux/config.guess\n+build-aux/config.sub\n+build-aux/depcomp\n+build-aux/install-sh\n+build-aux/ltmain.sh\n+build-aux/m4/libtool.m4\n+build-aux/m4/lt~obsolete.m4\n+build-aux/m4/ltoptions.m4\n+build-aux/m4/ltsugar.m4\n+build-aux/m4/ltversion.m4\n+build-aux/missing\n+build-aux/compile\n+build-aux/test-driver\n src/stamp-h1\n libsecp256k1.pc"
      },
      {
        "sha": "24395292426d697856f34b0b0d6c8f26d81d6856",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 12,
        "deletions": 6,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -6,26 +6,30 @@ addons:\n compiler:\n   - clang\n   - gcc\n+cache:\n+  directories:\n+  - src/java/guava/\n env:\n   global:\n-    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  schnorr=no  RECOVERY=no\n+    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  RECOVERY=no  EXPERIMENTAL=no\n+    - GUAVA_URL=https://search.maven.org/remotecontent?filepath=com/google/guava/guava/18.0/guava-18.0.jar GUAVA_JAR=src/java/guava/guava-18.0.jar\n   matrix:\n     - SCALAR=32bit    RECOVERY=yes\n-    - SCALAR=32bit    FIELD=32bit       ECDH=yes\n+    - SCALAR=32bit    FIELD=32bit       ECDH=yes  EXPERIMENTAL=yes\n     - SCALAR=64bit\n     - FIELD=64bit     RECOVERY=yes\n     - FIELD=64bit     ENDOMORPHISM=yes\n-    - FIELD=64bit     ENDOMORPHISM=yes  ECDH=yes\n+    - FIELD=64bit     ENDOMORPHISM=yes  ECDH=yes EXPERIMENTAL=yes\n     - FIELD=64bit                       ASM=x86_64\n     - FIELD=64bit     ENDOMORPHISM=yes  ASM=x86_64\n-    - FIELD=32bit     SCHNORR=yes\n     - FIELD=32bit     ENDOMORPHISM=yes\n     - BIGNUM=no\n-    - BIGNUM=no       ENDOMORPHISM=yes SCHNORR=yes  RECOVERY=yes\n+    - BIGNUM=no       ENDOMORPHISM=yes RECOVERY=yes EXPERIMENTAL=yes\n     - BIGNUM=no       STATICPRECOMPUTATION=no\n     - BUILD=distcheck\n     - EXTRAFLAGS=CPPFLAGS=-DDETERMINISTIC\n     - EXTRAFLAGS=CFLAGS=-O0\n+    - BUILD=check-java ECDH=yes EXPERIMENTAL=yes\n matrix:\n   fast_finish: true\n   include:\n@@ -55,9 +59,11 @@ matrix:\n           packages:\n             - gcc-multilib\n             - libgmp-dev:i386\n+before_install: mkdir -p `dirname $GUAVA_JAR`\n+install: if [ ! -f $GUAVA_JAR ]; then wget $GUAVA_URL -O $GUAVA_JAR; fi\n before_script: ./autogen.sh\n script:\n  - if [ -n \"$HOST\" ]; then export USE_HOST=\"--host=$HOST\"; fi\n  - if [ \"x$HOST\" = \"xi686-linux-gnu\" ]; then export CC=\"$CC -m32\"; fi\n- - ./configure --enable-endomorphism=$ENDOMORPHISM --with-field=$FIELD --with-bignum=$BIGNUM --with-scalar=$SCALAR --enable-ecmult-static-precomputation=$STATICPRECOMPUTATION --enable-module-ecdh=$ECDH --enable-module-schnorr=$SCHNORR --enable-module-recovery=$RECOVERY $EXTRAFLAGS $USE_HOST && make -j2 $BUILD\n+ - ./configure --enable-experimental=$EXPERIMENTAL --enable-endomorphism=$ENDOMORPHISM --with-field=$FIELD --with-bignum=$BIGNUM --with-scalar=$SCALAR --enable-ecmult-static-precomputation=$STATICPRECOMPUTATION --enable-module-ecdh=$ECDH --enable-module-recovery=$RECOVERY $EXTRAFLAGS $USE_HOST && make -j2 $BUILD\n os: linux"
      },
      {
        "sha": "e5657f7f31307852c4dc90750cabea1e2bf1947f",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 75,
        "deletions": 15,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -1,14 +1,22 @@\n ACLOCAL_AMFLAGS = -I build-aux/m4\n \n lib_LTLIBRARIES = libsecp256k1.la\n+if USE_JNI\n+JNI_LIB = libsecp256k1_jni.la\n+noinst_LTLIBRARIES = $(JNI_LIB)\n+else\n+JNI_LIB =\n+endif\n include_HEADERS = include/secp256k1.h\n noinst_HEADERS =\n noinst_HEADERS += src/scalar.h\n noinst_HEADERS += src/scalar_4x64.h\n noinst_HEADERS += src/scalar_8x32.h\n+noinst_HEADERS += src/scalar_low.h\n noinst_HEADERS += src/scalar_impl.h\n noinst_HEADERS += src/scalar_4x64_impl.h\n noinst_HEADERS += src/scalar_8x32_impl.h\n+noinst_HEADERS += src/scalar_low_impl.h\n noinst_HEADERS += src/group.h\n noinst_HEADERS += src/group_impl.h\n noinst_HEADERS += src/num_gmp.h\n@@ -32,6 +40,7 @@ noinst_HEADERS += src/field_5x52_impl.h\n noinst_HEADERS += src/field_5x52_int128_impl.h\n noinst_HEADERS += src/field_5x52_asm_impl.h\n noinst_HEADERS += src/java/org_bitcoin_NativeSecp256k1.h\n+noinst_HEADERS += src/java/org_bitcoin_Secp256k1Context.h\n noinst_HEADERS += src/util.h\n noinst_HEADERS += src/testrand.h\n noinst_HEADERS += src/testrand_impl.h\n@@ -45,33 +54,88 @@ noinst_HEADERS += contrib/lax_der_parsing.c\n noinst_HEADERS += contrib/lax_der_privatekey_parsing.h\n noinst_HEADERS += contrib/lax_der_privatekey_parsing.c\n \n+if USE_EXTERNAL_ASM\n+COMMON_LIB = libsecp256k1_common.la\n+noinst_LTLIBRARIES = $(COMMON_LIB)\n+else\n+COMMON_LIB =\n+endif\n+\n pkgconfigdir = $(libdir)/pkgconfig\n pkgconfig_DATA = libsecp256k1.pc\n \n+if USE_EXTERNAL_ASM\n+if USE_ASM_ARM\n+libsecp256k1_common_la_SOURCES = src/asm/field_10x26_arm.s\n+endif\n+endif\n+\n libsecp256k1_la_SOURCES = src/secp256k1.c\n-libsecp256k1_la_CPPFLAGS = -I$(top_srcdir)/include -I$(top_srcdir)/src $(SECP_INCLUDES)\n-libsecp256k1_la_LIBADD = $(SECP_LIBS)\n+libsecp256k1_la_CPPFLAGS = -DSECP256K1_BUILD -I$(top_srcdir)/include -I$(top_srcdir)/src $(SECP_INCLUDES)\n+libsecp256k1_la_LIBADD = $(JNI_LIB) $(SECP_LIBS) $(COMMON_LIB)\n \n+libsecp256k1_jni_la_SOURCES  = src/java/org_bitcoin_NativeSecp256k1.c src/java/org_bitcoin_Secp256k1Context.c\n+libsecp256k1_jni_la_CPPFLAGS = -DSECP256K1_BUILD $(JNI_INCLUDES)\n \n noinst_PROGRAMS =\n if USE_BENCHMARK\n noinst_PROGRAMS += bench_verify bench_sign bench_internal\n bench_verify_SOURCES = src/bench_verify.c\n-bench_verify_LDADD = libsecp256k1.la $(SECP_LIBS)\n+bench_verify_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n bench_sign_SOURCES = src/bench_sign.c\n-bench_sign_LDADD = libsecp256k1.la $(SECP_LIBS)\n+bench_sign_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n bench_internal_SOURCES = src/bench_internal.c\n-bench_internal_LDADD = $(SECP_LIBS)\n-bench_internal_CPPFLAGS = $(SECP_INCLUDES)\n+bench_internal_LDADD = $(SECP_LIBS) $(COMMON_LIB)\n+bench_internal_CPPFLAGS = -DSECP256K1_BUILD $(SECP_INCLUDES)\n endif\n \n+TESTS =\n if USE_TESTS\n noinst_PROGRAMS += tests\n tests_SOURCES = src/tests.c\n-tests_CPPFLAGS = -DVERIFY -I$(top_srcdir)/src -I$(top_srcdir)/include $(SECP_INCLUDES) $(SECP_TEST_INCLUDES)\n-tests_LDADD = $(SECP_LIBS) $(SECP_TEST_LIBS)\n+tests_CPPFLAGS = -DSECP256K1_BUILD -DVERIFY -I$(top_srcdir)/src -I$(top_srcdir)/include $(SECP_INCLUDES) $(SECP_TEST_INCLUDES)\n+tests_LDADD = $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n tests_LDFLAGS = -static\n-TESTS = tests\n+TESTS += tests\n+endif\n+\n+if USE_EXHAUSTIVE_TESTS\n+noinst_PROGRAMS += exhaustive_tests\n+exhaustive_tests_SOURCES = src/tests_exhaustive.c\n+exhaustive_tests_CPPFLAGS = -DSECP256K1_BUILD -DVERIFY -I$(top_srcdir)/src $(SECP_INCLUDES)\n+exhaustive_tests_LDADD = $(SECP_LIBS)\n+exhaustive_tests_LDFLAGS = -static\n+TESTS += exhaustive_tests\n+endif\n+\n+JAVAROOT=src/java\n+JAVAORG=org/bitcoin\n+JAVA_GUAVA=$(srcdir)/$(JAVAROOT)/guava/guava-18.0.jar\n+CLASSPATH_ENV=CLASSPATH=$(JAVA_GUAVA)\n+JAVA_FILES= \\\n+  $(JAVAROOT)/$(JAVAORG)/NativeSecp256k1.java \\\n+  $(JAVAROOT)/$(JAVAORG)/NativeSecp256k1Test.java \\\n+  $(JAVAROOT)/$(JAVAORG)/NativeSecp256k1Util.java \\\n+  $(JAVAROOT)/$(JAVAORG)/Secp256k1Context.java\n+\n+if USE_JNI\n+\n+$(JAVA_GUAVA):\n+\t@echo Guava is missing. Fetch it via: \\\n+\twget https://search.maven.org/remotecontent?filepath=com/google/guava/guava/18.0/guava-18.0.jar -O $(@)\n+\t@false\n+\n+.stamp-java: $(JAVA_FILES)\n+\t@echo   Compiling $^\n+\t$(AM_V_at)$(CLASSPATH_ENV) javac $^\n+\t@touch $@\n+\n+if USE_TESTS\n+\n+check-java: libsecp256k1.la $(JAVA_GUAVA) .stamp-java\n+\t$(AM_V_at)java -Djava.library.path=\"./:./src:./src/.libs:.libs/\" -cp \"$(JAVA_GUAVA):$(JAVAROOT)\" $(JAVAORG)/NativeSecp256k1Test\n+\n+endif\n endif\n \n if USE_ECMULT_STATIC_PRECOMPUTATION\n@@ -93,19 +157,15 @@ $(bench_internal_OBJECTS): src/ecmult_static_context.h\n src/ecmult_static_context.h: $(gen_context_BIN)\n \t./$(gen_context_BIN)\n \n-CLEANFILES = $(gen_context_BIN) src/ecmult_static_context.h\n+CLEANFILES = $(gen_context_BIN) src/ecmult_static_context.h $(JAVAROOT)/$(JAVAORG)/*.class .stamp-java\n endif\n \n-EXTRA_DIST = autogen.sh src/gen_context.c src/basic-config.h\n+EXTRA_DIST = autogen.sh src/gen_context.c src/basic-config.h $(JAVA_FILES)\n \n if ENABLE_MODULE_ECDH\n include src/modules/ecdh/Makefile.am.include\n endif\n \n-if ENABLE_MODULE_SCHNORR\n-include src/modules/schnorr/Makefile.am.include\n-endif\n-\n if ENABLE_MODULE_RECOVERY\n include src/modules/recovery/Makefile.am.include\n endif"
      },
      {
        "sha": "8cd344ea81232413cf9004bc50dec4ec2fe112a6",
        "filename": "README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/README.md?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -1,7 +1,7 @@\n libsecp256k1\n ============\n \n-[![Build Status](https://travis-ci.org/bitcoin/secp256k1.svg?branch=master)](https://travis-ci.org/bitcoin/secp256k1)\n+[![Build Status](https://travis-ci.org/bitcoin-core/secp256k1.svg?branch=master)](https://travis-ci.org/bitcoin-core/secp256k1)\n \n Optimized C library for EC operations on curve secp256k1.\n "
      },
      {
        "sha": "1fc36276144a2fb7740c436bd53f09f42b12daff",
        "filename": "build-aux/m4/ax_jni_include_dir.m4",
        "status": "added",
        "additions": 140,
        "deletions": 0,
        "changes": 140,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/build-aux/m4/ax_jni_include_dir.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/build-aux/m4/ax_jni_include_dir.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/ax_jni_include_dir.m4?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -0,0 +1,140 @@\n+# ===========================================================================\n+#    http://www.gnu.org/software/autoconf-archive/ax_jni_include_dir.html\n+# ===========================================================================\n+#\n+# SYNOPSIS\n+#\n+#   AX_JNI_INCLUDE_DIR\n+#\n+# DESCRIPTION\n+#\n+#   AX_JNI_INCLUDE_DIR finds include directories needed for compiling\n+#   programs using the JNI interface.\n+#\n+#   JNI include directories are usually in the Java distribution. This is\n+#   deduced from the value of $JAVA_HOME, $JAVAC, or the path to \"javac\", in\n+#   that order. When this macro completes, a list of directories is left in\n+#   the variable JNI_INCLUDE_DIRS.\n+#\n+#   Example usage follows:\n+#\n+#     AX_JNI_INCLUDE_DIR\n+#\n+#     for JNI_INCLUDE_DIR in $JNI_INCLUDE_DIRS\n+#     do\n+#             CPPFLAGS=\"$CPPFLAGS -I$JNI_INCLUDE_DIR\"\n+#     done\n+#\n+#   If you want to force a specific compiler:\n+#\n+#   - at the configure.in level, set JAVAC=yourcompiler before calling\n+#   AX_JNI_INCLUDE_DIR\n+#\n+#   - at the configure level, setenv JAVAC\n+#\n+#   Note: This macro can work with the autoconf M4 macros for Java programs.\n+#   This particular macro is not part of the original set of macros.\n+#\n+# LICENSE\n+#\n+#   Copyright (c) 2008 Don Anderson <dda@sleepycat.com>\n+#\n+#   Copying and distribution of this file, with or without modification, are\n+#   permitted in any medium without royalty provided the copyright notice\n+#   and this notice are preserved. This file is offered as-is, without any\n+#   warranty.\n+\n+#serial 10\n+\n+AU_ALIAS([AC_JNI_INCLUDE_DIR], [AX_JNI_INCLUDE_DIR])\n+AC_DEFUN([AX_JNI_INCLUDE_DIR],[\n+\n+JNI_INCLUDE_DIRS=\"\"\n+\n+if test \"x$JAVA_HOME\" != x; then\n+\t_JTOPDIR=\"$JAVA_HOME\"\n+else\n+\tif test \"x$JAVAC\" = x; then\n+\t\tJAVAC=javac\n+\tfi\n+\tAC_PATH_PROG([_ACJNI_JAVAC], [$JAVAC], [no])\n+\tif test \"x$_ACJNI_JAVAC\" = xno; then\n+\t\tAC_MSG_WARN([cannot find JDK; try setting \\$JAVAC or \\$JAVA_HOME])\n+\tfi\n+\t_ACJNI_FOLLOW_SYMLINKS(\"$_ACJNI_JAVAC\")\n+\t_JTOPDIR=`echo \"$_ACJNI_FOLLOWED\" | sed -e 's://*:/:g' -e 's:/[[^/]]*$::'`\n+fi\n+\n+case \"$host_os\" in\n+        darwin*)        _JTOPDIR=`echo \"$_JTOPDIR\" | sed -e 's:/[[^/]]*$::'`\n+                        _JINC=\"$_JTOPDIR/Headers\";;\n+        *)              _JINC=\"$_JTOPDIR/include\";;\n+esac\n+_AS_ECHO_LOG([_JTOPDIR=$_JTOPDIR])\n+_AS_ECHO_LOG([_JINC=$_JINC])\n+\n+# On Mac OS X 10.6.4, jni.h is a symlink:\n+# /System/Library/Frameworks/JavaVM.framework/Versions/Current/Headers/jni.h\n+# -> ../../CurrentJDK/Headers/jni.h.\n+\n+AC_CACHE_CHECK(jni headers, ac_cv_jni_header_path,\n+[\n+if test -f \"$_JINC/jni.h\"; then\n+  ac_cv_jni_header_path=\"$_JINC\"\n+  JNI_INCLUDE_DIRS=\"$JNI_INCLUDE_DIRS $ac_cv_jni_header_path\"\n+else\n+  _JTOPDIR=`echo \"$_JTOPDIR\" | sed -e 's:/[[^/]]*$::'`\n+  if test -f \"$_JTOPDIR/include/jni.h\"; then\n+    ac_cv_jni_header_path=\"$_JTOPDIR/include\"\n+    JNI_INCLUDE_DIRS=\"$JNI_INCLUDE_DIRS $ac_cv_jni_header_path\"\n+  else\n+    ac_cv_jni_header_path=none\n+  fi\n+fi\n+])\n+\n+\n+\n+# get the likely subdirectories for system specific java includes\n+case \"$host_os\" in\n+bsdi*)          _JNI_INC_SUBDIRS=\"bsdos\";;\n+darwin*)        _JNI_INC_SUBDIRS=\"darwin\";;\n+freebsd*)       _JNI_INC_SUBDIRS=\"freebsd\";;\n+linux*)         _JNI_INC_SUBDIRS=\"linux genunix\";;\n+osf*)           _JNI_INC_SUBDIRS=\"alpha\";;\n+solaris*)       _JNI_INC_SUBDIRS=\"solaris\";;\n+mingw*)\t\t_JNI_INC_SUBDIRS=\"win32\";;\n+cygwin*)\t_JNI_INC_SUBDIRS=\"win32\";;\n+*)              _JNI_INC_SUBDIRS=\"genunix\";;\n+esac\n+\n+if test \"x$ac_cv_jni_header_path\" != \"xnone\"; then\n+  # add any subdirectories that are present\n+  for JINCSUBDIR in $_JNI_INC_SUBDIRS\n+  do\n+      if test -d \"$_JTOPDIR/include/$JINCSUBDIR\"; then\n+           JNI_INCLUDE_DIRS=\"$JNI_INCLUDE_DIRS $_JTOPDIR/include/$JINCSUBDIR\"\n+      fi\n+  done\n+fi\n+])\n+\n+# _ACJNI_FOLLOW_SYMLINKS <path>\n+# Follows symbolic links on <path>,\n+# finally setting variable _ACJNI_FOLLOWED\n+# ----------------------------------------\n+AC_DEFUN([_ACJNI_FOLLOW_SYMLINKS],[\n+# find the include directory relative to the javac executable\n+_cur=\"$1\"\n+while ls -ld \"$_cur\" 2>/dev/null | grep \" -> \" >/dev/null; do\n+        AC_MSG_CHECKING([symlink for $_cur])\n+        _slink=`ls -ld \"$_cur\" | sed 's/.* -> //'`\n+        case \"$_slink\" in\n+        /*) _cur=\"$_slink\";;\n+        # 'X' avoids triggering unwanted echo options.\n+        *) _cur=`echo \"X$_cur\" | sed -e 's/^X//' -e 's:[[^/]]*$::'`\"$_slink\";;\n+        esac\n+        AC_MSG_RESULT([$_cur])\n+done\n+_ACJNI_FOLLOWED=\"$_cur\"\n+])# _ACJNI"
      },
      {
        "sha": "b74acb8c138823c67e7fd0a11d059a90bd2551a9",
        "filename": "build-aux/m4/bitcoin_secp.m4",
        "status": "modified",
        "additions": 6,
        "deletions": 2,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/build-aux/m4/bitcoin_secp.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/build-aux/m4/bitcoin_secp.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/bitcoin_secp.m4?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -3,13 +3,13 @@ AC_DEFUN([SECP_INT128_CHECK],[\n has_int128=$ac_cv_type___int128\n ])\n \n-dnl \n+dnl escape \"$0x\" below using the m4 quadrigaph @S|@, and escape it again with a \\ for the shell.\n AC_DEFUN([SECP_64BIT_ASM_CHECK],[\n AC_MSG_CHECKING(for x86_64 assembly availability)\n AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n   #include <stdint.h>]],[[\n   uint64_t a = 11, tmp;\n-  __asm__ __volatile__(\"movq $0x100000000,%1; mulq %%rsi\" : \"+a\"(a) : \"S\"(tmp) : \"cc\", \"%rdx\");\n+  __asm__ __volatile__(\"movq \\@S|@0x100000000,%1; mulq %%rsi\" : \"+a\"(a) : \"S\"(tmp) : \"cc\", \"%rdx\");\n   ]])],[has_64bit_asm=yes],[has_64bit_asm=no])\n AC_MSG_RESULT([$has_64bit_asm])\n ])\n@@ -46,6 +46,10 @@ if test x\"$has_libcrypto\" = x\"yes\" && test x\"$has_openssl_ec\" = x; then\n     ECDSA_sign(0, NULL, 0, NULL, NULL, eckey);\n     ECDSA_verify(0, NULL, 0, NULL, 0, eckey);\n     EC_KEY_free(eckey);\n+    ECDSA_SIG *sig_openssl;\n+    sig_openssl = ECDSA_SIG_new();\n+    (void)sig_openssl->r;\n+    ECDSA_SIG_free(sig_openssl);\n   ]])],[has_openssl_ec=yes],[has_openssl_ec=no])\n   AC_MSG_RESULT([$has_openssl_ec])\n fi"
      },
      {
        "sha": "ec50ffe3a251b653cdcd9eb88b887e6374934c0e",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 130,
        "deletions": 28,
        "changes": 158,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -29,6 +29,7 @@ AC_PROG_CC_C89\n if test x\"$ac_cv_prog_cc_c89\" = x\"no\"; then\n   AC_MSG_ERROR([c89 compiler support required])\n fi\n+AM_PROG_AS\n \n case $host_os in\n   *darwin*)\n@@ -93,31 +94,46 @@ AC_ARG_ENABLE(tests,\n     [use_tests=$enableval],\n     [use_tests=yes])\n \n+AC_ARG_ENABLE(openssl_tests,\n+    AS_HELP_STRING([--enable-openssl-tests],[enable OpenSSL tests, if OpenSSL is available (default is auto)]),\n+    [enable_openssl_tests=$enableval],\n+    [enable_openssl_tests=auto])\n+\n+AC_ARG_ENABLE(experimental,\n+    AS_HELP_STRING([--enable-experimental],[allow experimental configure options (default is no)]),\n+    [use_experimental=$enableval],\n+    [use_experimental=no])\n+\n+AC_ARG_ENABLE(exhaustive_tests,\n+    AS_HELP_STRING([--enable-exhaustive-tests],[compile exhaustive tests (default is yes)]),\n+    [use_exhaustive_tests=$enableval],\n+    [use_exhaustive_tests=yes])\n+\n AC_ARG_ENABLE(endomorphism,\n     AS_HELP_STRING([--enable-endomorphism],[enable endomorphism (default is no)]),\n     [use_endomorphism=$enableval],\n     [use_endomorphism=no])\n-    \n+\n AC_ARG_ENABLE(ecmult_static_precomputation,\n     AS_HELP_STRING([--enable-ecmult-static-precomputation],[enable precomputed ecmult table for signing (default is yes)]),\n     [use_ecmult_static_precomputation=$enableval],\n-    [use_ecmult_static_precomputation=yes])\n+    [use_ecmult_static_precomputation=auto])\n \n AC_ARG_ENABLE(module_ecdh,\n-    AS_HELP_STRING([--enable-module-ecdh],[enable ECDH shared secret computation (default is no)]),\n+    AS_HELP_STRING([--enable-module-ecdh],[enable ECDH shared secret computation (experimental)]),\n     [enable_module_ecdh=$enableval],\n     [enable_module_ecdh=no])\n \n-AC_ARG_ENABLE(module_schnorr,\n-    AS_HELP_STRING([--enable-module-schnorr],[enable Schnorr signature module (default is no)]),\n-    [enable_module_schnorr=$enableval],\n-    [enable_module_schnorr=no])\n-\n AC_ARG_ENABLE(module_recovery,\n     AS_HELP_STRING([--enable-module-recovery],[enable ECDSA pubkey recovery module (default is no)]),\n     [enable_module_recovery=$enableval],\n     [enable_module_recovery=no])\n \n+AC_ARG_ENABLE(jni,\n+    AS_HELP_STRING([--enable-jni],[enable libsecp256k1_jni (default is auto)]),\n+    [use_jni=$enableval],\n+    [use_jni=auto])\n+\n AC_ARG_WITH([field], [AS_HELP_STRING([--with-field=64bit|32bit|auto],\n [Specify Field Implementation. Default is auto])],[req_field=$withval], [req_field=auto])\n \n@@ -127,8 +143,8 @@ AC_ARG_WITH([bignum], [AS_HELP_STRING([--with-bignum=gmp|no|auto],\n AC_ARG_WITH([scalar], [AS_HELP_STRING([--with-scalar=64bit|32bit|auto],\n [Specify scalar implementation. Default is auto])],[req_scalar=$withval], [req_scalar=auto])\n \n-AC_ARG_WITH([asm], [AS_HELP_STRING([--with-asm=x86_64|no|auto]\n-[Specify assembly optimizations to use. Default is auto])],[req_asm=$withval], [req_asm=auto])\n+AC_ARG_WITH([asm], [AS_HELP_STRING([--with-asm=x86_64|arm|no|auto]\n+[Specify assembly optimizations to use. Default is auto (experimental: arm)])],[req_asm=$withval], [req_asm=auto])\n \n AC_CHECK_TYPES([__int128])\n \n@@ -138,6 +154,34 @@ AC_COMPILE_IFELSE([AC_LANG_SOURCE([[void myfunc() {__builtin_expect(0,0);}]])],\n     [ AC_MSG_RESULT([no])\n     ])\n \n+if test x\"$use_ecmult_static_precomputation\" != x\"no\"; then\n+  save_cross_compiling=$cross_compiling\n+  cross_compiling=no\n+  TEMP_CC=\"$CC\"\n+  CC=\"$CC_FOR_BUILD\"\n+  AC_MSG_CHECKING([native compiler: ${CC_FOR_BUILD}])\n+  AC_RUN_IFELSE(\n+    [AC_LANG_PROGRAM([], [return 0])],\n+    [working_native_cc=yes],\n+    [working_native_cc=no],[dnl])\n+  CC=\"$TEMP_CC\"\n+  cross_compiling=$save_cross_compiling\n+\n+  if test x\"$working_native_cc\" = x\"no\"; then\n+    set_precomp=no\n+    if test x\"$use_ecmult_static_precomputation\" = x\"yes\";  then\n+      AC_MSG_ERROR([${CC_FOR_BUILD} does not produce working binaries. Please set CC_FOR_BUILD])\n+    else\n+      AC_MSG_RESULT([${CC_FOR_BUILD} does not produce working binaries. Please set CC_FOR_BUILD])\n+    fi\n+  else\n+    AC_MSG_RESULT([ok])\n+    set_precomp=yes\n+  fi\n+else\n+  set_precomp=no\n+fi\n+\n if test x\"$req_asm\" = x\"auto\"; then\n   SECP_64BIT_ASM_CHECK\n   if test x\"$has_64bit_asm\" = x\"yes\"; then\n@@ -155,6 +199,8 @@ else\n       AC_MSG_ERROR([x86_64 assembly optimization requested but not available])\n     fi\n     ;;\n+  arm)\n+    ;;\n   no)\n     ;;\n   *)\n@@ -247,10 +293,15 @@ else\n fi\n \n # select assembly optimization\n+use_external_asm=no\n+\n case $set_asm in\n x86_64)\n   AC_DEFINE(USE_ASM_X86_64, 1, [Define this symbol to enable x86_64 assembly optimizations])\n   ;;\n+arm)\n+  use_external_asm=yes\n+  ;;\n no)\n   ;;\n *)\n@@ -305,16 +356,48 @@ esac\n if test x\"$use_tests\" = x\"yes\"; then\n   SECP_OPENSSL_CHECK\n   if test x\"$has_openssl_ec\" = x\"yes\"; then\n-    AC_DEFINE(ENABLE_OPENSSL_TESTS, 1, [Define this symbol if OpenSSL EC functions are available])\n-    SECP_TEST_INCLUDES=\"$SSL_CFLAGS $CRYPTO_CFLAGS\"\n-    SECP_TEST_LIBS=\"$CRYPTO_LIBS\"\n-\n-    case $host in\n-    *mingw*)\n-      SECP_TEST_LIBS=\"$SECP_TEST_LIBS -lgdi32\"\n-      ;;\n-    esac\n+    if test x\"$enable_openssl_tests\" != x\"no\"; then\n+      AC_DEFINE(ENABLE_OPENSSL_TESTS, 1, [Define this symbol if OpenSSL EC functions are available])\n+      SECP_TEST_INCLUDES=\"$SSL_CFLAGS $CRYPTO_CFLAGS\"\n+      SECP_TEST_LIBS=\"$CRYPTO_LIBS\"\n+\n+      case $host in\n+      *mingw*)\n+        SECP_TEST_LIBS=\"$SECP_TEST_LIBS -lgdi32\"\n+        ;;\n+      esac\n+    fi\n+  else\n+    if test x\"$enable_openssl_tests\" = x\"yes\"; then\n+      AC_MSG_ERROR([OpenSSL tests requested but OpenSSL with EC support is not available])\n+    fi\n+  fi\n+else\n+  if test x\"$enable_openssl_tests\" = x\"yes\"; then\n+    AC_MSG_ERROR([OpenSSL tests requested but tests are not enabled])\n+  fi\n+fi\n \n+if test x\"$use_jni\" != x\"no\"; then\n+  AX_JNI_INCLUDE_DIR\n+  have_jni_dependencies=yes\n+  if test x\"$enable_module_ecdh\" = x\"no\"; then\n+    have_jni_dependencies=no\n+  fi\n+  if test \"x$JNI_INCLUDE_DIRS\" = \"x\"; then\n+    have_jni_dependencies=no\n+  fi\n+  if test \"x$have_jni_dependencies\" = \"xno\"; then\n+    if test x\"$use_jni\" = x\"yes\"; then\n+      AC_MSG_ERROR([jni support explicitly requested but headers/dependencies were not found. Enable ECDH and try again.])\n+    fi\n+    AC_MSG_WARN([jni headers/dependencies not found. jni support disabled])\n+    use_jni=no\n+  else\n+    use_jni=yes\n+    for JNI_INCLUDE_DIR in $JNI_INCLUDE_DIRS; do\n+      JNI_INCLUDES=\"$JNI_INCLUDES -I$JNI_INCLUDE_DIR\"\n+    done\n   fi\n fi\n \n@@ -327,46 +410,65 @@ if test x\"$use_endomorphism\" = x\"yes\"; then\n   AC_DEFINE(USE_ENDOMORPHISM, 1, [Define this symbol to use endomorphism optimization])\n fi\n \n-if test x\"$use_ecmult_static_precomputation\" = x\"yes\"; then\n+if test x\"$set_precomp\" = x\"yes\"; then\n   AC_DEFINE(USE_ECMULT_STATIC_PRECOMPUTATION, 1, [Define this symbol to use a statically generated ecmult table])\n fi\n \n if test x\"$enable_module_ecdh\" = x\"yes\"; then\n   AC_DEFINE(ENABLE_MODULE_ECDH, 1, [Define this symbol to enable the ECDH module])\n fi\n \n-if test x\"$enable_module_schnorr\" = x\"yes\"; then\n-  AC_DEFINE(ENABLE_MODULE_SCHNORR, 1, [Define this symbol to enable the Schnorr signature module])\n-fi\n-\n if test x\"$enable_module_recovery\" = x\"yes\"; then\n   AC_DEFINE(ENABLE_MODULE_RECOVERY, 1, [Define this symbol to enable the ECDSA pubkey recovery module])\n fi\n \n AC_C_BIGENDIAN()\n \n+if test x\"$use_external_asm\" = x\"yes\"; then\n+  AC_DEFINE(USE_EXTERNAL_ASM, 1, [Define this symbol if an external (non-inline) assembly implementation is used])\n+fi\n+\n+AC_MSG_NOTICE([Using static precomputation: $set_precomp])\n AC_MSG_NOTICE([Using assembly optimizations: $set_asm])\n AC_MSG_NOTICE([Using field implementation: $set_field])\n AC_MSG_NOTICE([Using bignum implementation: $set_bignum])\n AC_MSG_NOTICE([Using scalar implementation: $set_scalar])\n AC_MSG_NOTICE([Using endomorphism optimizations: $use_endomorphism])\n AC_MSG_NOTICE([Building ECDH module: $enable_module_ecdh])\n-\n-AC_MSG_NOTICE([Building Schnorr signatures module: $enable_module_schnorr])\n AC_MSG_NOTICE([Building ECDSA pubkey recovery module: $enable_module_recovery])\n+AC_MSG_NOTICE([Using jni: $use_jni])\n+\n+if test x\"$enable_experimental\" = x\"yes\"; then\n+  AC_MSG_NOTICE([******])\n+  AC_MSG_NOTICE([WARNING: experimental build])\n+  AC_MSG_NOTICE([Experimental features do not have stable APIs or properties, and may not be safe for production use.])\n+  AC_MSG_NOTICE([Building ECDH module: $enable_module_ecdh])\n+  AC_MSG_NOTICE([******])\n+else\n+  if test x\"$enable_module_ecdh\" = x\"yes\"; then\n+    AC_MSG_ERROR([ECDH module is experimental. Use --enable-experimental to allow.])\n+  fi\n+  if test x\"$set_asm\" = x\"arm\"; then\n+    AC_MSG_ERROR([ARM assembly optimization is experimental. Use --enable-experimental to allow.])\n+  fi\n+fi\n \n AC_CONFIG_HEADERS([src/libsecp256k1-config.h])\n AC_CONFIG_FILES([Makefile libsecp256k1.pc])\n+AC_SUBST(JNI_INCLUDES)\n AC_SUBST(SECP_INCLUDES)\n AC_SUBST(SECP_LIBS)\n AC_SUBST(SECP_TEST_LIBS)\n AC_SUBST(SECP_TEST_INCLUDES)\n AM_CONDITIONAL([USE_TESTS], [test x\"$use_tests\" != x\"no\"])\n+AM_CONDITIONAL([USE_EXHAUSTIVE_TESTS], [test x\"$use_exhaustive_tests\" != x\"no\"])\n AM_CONDITIONAL([USE_BENCHMARK], [test x\"$use_benchmark\" = x\"yes\"])\n-AM_CONDITIONAL([USE_ECMULT_STATIC_PRECOMPUTATION], [test x\"$use_ecmult_static_precomputation\" = x\"yes\"])\n+AM_CONDITIONAL([USE_ECMULT_STATIC_PRECOMPUTATION], [test x\"$set_precomp\" = x\"yes\"])\n AM_CONDITIONAL([ENABLE_MODULE_ECDH], [test x\"$enable_module_ecdh\" = x\"yes\"])\n-AM_CONDITIONAL([ENABLE_MODULE_SCHNORR], [test x\"$enable_module_schnorr\" = x\"yes\"])\n AM_CONDITIONAL([ENABLE_MODULE_RECOVERY], [test x\"$enable_module_recovery\" = x\"yes\"])\n+AM_CONDITIONAL([USE_JNI], [test x\"$use_jni\" == x\"yes\"])\n+AM_CONDITIONAL([USE_EXTERNAL_ASM], [test x\"$use_external_asm\" = x\"yes\"])\n+AM_CONDITIONAL([USE_ASM_ARM], [test x\"$set_asm\" = x\"arm\"])\n \n dnl make sure nothing new is exported so that we don't break the cache\n PKGCONFIG_PATH_TEMP=\"$PKG_CONFIG_PATH\""
      },
      {
        "sha": "f268e309d0bf5d0db21bc61224bb798aba14dbf0",
        "filename": "include/secp256k1.h",
        "status": "modified",
        "additions": 4,
        "deletions": 10,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/include/secp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/include/secp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1.h?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -47,11 +47,8 @@ typedef struct secp256k1_context_struct secp256k1_context;\n  *  The exact representation of data inside is implementation defined and not\n  *  guaranteed to be portable between different platforms or versions. It is\n  *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n- *  If you need to convert to a format suitable for storage or transmission, use\n- *  secp256k1_ec_pubkey_serialize and secp256k1_ec_pubkey_parse.\n- *\n- *  Furthermore, it is guaranteed that identical public keys (ignoring\n- *  compression) will have identical representation, so they can be memcmp'ed.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_ec_pubkey_serialize and secp256k1_ec_pubkey_parse.\n  */\n typedef struct {\n     unsigned char data[64];\n@@ -62,12 +59,9 @@ typedef struct {\n  *  The exact representation of data inside is implementation defined and not\n  *  guaranteed to be portable between different platforms or versions. It is\n  *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n- *  If you need to convert to a format suitable for storage or transmission, use\n- *  the secp256k1_ecdsa_signature_serialize_* and\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the secp256k1_ecdsa_signature_serialize_* and\n  *  secp256k1_ecdsa_signature_serialize_* functions.\n- *\n- *  Furthermore, it is guaranteed to identical signatures will have identical\n- *  representation, so they can be memcmp'ed.\n  */\n typedef struct {\n     unsigned char data[64];"
      },
      {
        "sha": "dc32fec1eac0380e687399c0cf66e0c44cb2e1a3",
        "filename": "include/secp256k1_schnorr.h",
        "status": "removed",
        "additions": 0,
        "deletions": 173,
        "changes": 173,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5ad54630935d1f340666de7bc9ffef9b8a1df296/include/secp256k1_schnorr.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5ad54630935d1f340666de7bc9ffef9b8a1df296/include/secp256k1_schnorr.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1_schnorr.h?ref=5ad54630935d1f340666de7bc9ffef9b8a1df296",
        "patch": "@@ -1,173 +0,0 @@\n-#ifndef _SECP256K1_SCHNORR_\n-# define _SECP256K1_SCHNORR_\n-\n-# include \"secp256k1.h\"\n-\n-# ifdef __cplusplus\n-extern \"C\" {\n-# endif\n-\n-/** Create a signature using a custom EC-Schnorr-SHA256 construction. It\n- *  produces non-malleable 64-byte signatures which support public key recovery\n- *  batch validation, and multiparty signing.\n- *  Returns: 1: signature created\n- *           0: the nonce generation function failed, or the private key was\n- *              invalid.\n- *  Args:    ctx:    pointer to a context object, initialized for signing\n- *                   (cannot be NULL)\n- *  Out:     sig64:  pointer to a 64-byte array where the signature will be\n- *                   placed (cannot be NULL)\n- *  In:      msg32:  the 32-byte message hash being signed (cannot be NULL)\n- *           seckey: pointer to a 32-byte secret key (cannot be NULL)\n- *           noncefp:pointer to a nonce generation function. If NULL,\n- *                   secp256k1_nonce_function_default is used\n- *           ndata:  pointer to arbitrary data used by the nonce generation\n- *                   function (can be NULL)\n- */\n-SECP256K1_API int secp256k1_schnorr_sign(\n-  const secp256k1_context* ctx,\n-  unsigned char *sig64,\n-  const unsigned char *msg32,\n-  const unsigned char *seckey,\n-  secp256k1_nonce_function noncefp,\n-  const void *ndata\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n-\n-/** Verify a signature created by secp256k1_schnorr_sign.\n- *  Returns: 1: correct signature\n- *           0: incorrect signature\n- *  Args:    ctx:       a secp256k1 context object, initialized for verification.\n- *  In:      sig64:     the 64-byte signature being verified (cannot be NULL)\n- *           msg32:     the 32-byte message hash being verified (cannot be NULL)\n- *           pubkey:    the public key to verify with (cannot be NULL)\n- */\n-SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_schnorr_verify(\n-  const secp256k1_context* ctx,\n-  const unsigned char *sig64,\n-  const unsigned char *msg32,\n-  const secp256k1_pubkey *pubkey\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n-\n-/** Recover an EC public key from a Schnorr signature created using\n- *  secp256k1_schnorr_sign.\n- *  Returns: 1: public key successfully recovered (which guarantees a correct\n- *           signature).\n- *           0: otherwise.\n- *  Args:    ctx:        pointer to a context object, initialized for\n- *                       verification (cannot be NULL)\n- *  Out:     pubkey:     pointer to a pubkey to set to the recovered public key\n- *                       (cannot be NULL).\n- *  In:      sig64:      signature as 64 byte array (cannot be NULL)\n- *           msg32:      the 32-byte message hash assumed to be signed (cannot\n- *                       be NULL)\n- */\n-SECP256K1_API int secp256k1_schnorr_recover(\n-  const secp256k1_context* ctx,\n-  secp256k1_pubkey *pubkey,\n-  const unsigned char *sig64,\n-  const unsigned char *msg32\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n-\n-/** Generate a nonce pair deterministically for use with\n- *  secp256k1_schnorr_partial_sign.\n- *  Returns: 1: valid nonce pair was generated.\n- *           0: otherwise (nonce generation function failed)\n- *  Args:    ctx:         pointer to a context object, initialized for signing\n- *                        (cannot be NULL)\n- *  Out:     pubnonce:    public side of the nonce (cannot be NULL)\n- *           privnonce32: private side of the nonce (32 byte) (cannot be NULL)\n- *  In:      msg32:       the 32-byte message hash assumed to be signed (cannot\n- *                        be NULL)\n- *           sec32:       the 32-byte private key (cannot be NULL)\n- *           noncefp:     pointer to a nonce generation function. If NULL,\n- *                        secp256k1_nonce_function_default is used\n- *           noncedata:   pointer to arbitrary data used by the nonce generation\n- *                        function (can be NULL)\n- *\n- *  Do not use the output as a private/public key pair for signing/validation.\n- */\n-SECP256K1_API int secp256k1_schnorr_generate_nonce_pair(\n-  const secp256k1_context* ctx,\n-  secp256k1_pubkey *pubnonce,\n-  unsigned char *privnonce32,\n-  const unsigned char *msg32,\n-  const unsigned char *sec32,\n-  secp256k1_nonce_function noncefp,\n-  const void* noncedata\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n-\n-/** Produce a partial Schnorr signature, which can be combined using\n- *  secp256k1_schnorr_partial_combine, to end up with a full signature that is\n- *  verifiable using secp256k1_schnorr_verify.\n- *  Returns: 1: signature created successfully.\n- *           0: no valid signature exists with this combination of keys, nonces\n- *              and message (chance around 1 in 2^128)\n- *          -1: invalid private key, nonce, or public nonces.\n- *  Args: ctx:             pointer to context object, initialized for signing (cannot\n- *                         be NULL)\n- *  Out:  sig64:           pointer to 64-byte array to put partial signature in\n- *  In:   msg32:           pointer to 32-byte message to sign\n- *        sec32:           pointer to 32-byte private key\n- *        pubnonce_others: pointer to pubkey containing the sum of the other's\n- *                         nonces (see secp256k1_ec_pubkey_combine)\n- *        secnonce32:      pointer to 32-byte array containing our nonce\n- *\n- * The intended procedure for creating a multiparty signature is:\n- * - Each signer S[i] with private key x[i] and public key Q[i] runs\n- *   secp256k1_schnorr_generate_nonce_pair to produce a pair (k[i],R[i]) of\n- *   private/public nonces.\n- * - All signers communicate their public nonces to each other (revealing your\n- *   private nonce can lead to discovery of your private key, so it should be\n- *   considered secret).\n- * - All signers combine all the public nonces they received (excluding their\n- *   own) using secp256k1_ec_pubkey_combine to obtain an\n- *   Rall[i] = sum(R[0..i-1,i+1..n]).\n- * - All signers produce a partial signature using\n- *   secp256k1_schnorr_partial_sign, passing in their own private key x[i],\n- *   their own private nonce k[i], and the sum of the others' public nonces\n- *   Rall[i].\n- * - All signers communicate their partial signatures to each other.\n- * - Someone combines all partial signatures using\n- *   secp256k1_schnorr_partial_combine, to obtain a full signature.\n- * - The resulting signature is validatable using secp256k1_schnorr_verify, with\n- *   public key equal to the result of secp256k1_ec_pubkey_combine of the\n- *   signers' public keys (sum(Q[0..n])).\n- *\n- *  Note that secp256k1_schnorr_partial_combine and secp256k1_ec_pubkey_combine\n- *  function take their arguments in any order, and it is possible to\n- *  pre-combine several inputs already with one call, and add more inputs later\n- *  by calling the function again (they are commutative and associative).\n- */\n-SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_schnorr_partial_sign(\n-  const secp256k1_context* ctx,\n-  unsigned char *sig64,\n-  const unsigned char *msg32,\n-  const unsigned char *sec32,\n-  const secp256k1_pubkey *pubnonce_others,\n-  const unsigned char *secnonce32\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5) SECP256K1_ARG_NONNULL(6);\n-\n-/** Combine multiple Schnorr partial signatures.\n- * Returns: 1: the passed signatures were successfully combined.\n- *          0: the resulting signature is not valid (chance of 1 in 2^256)\n- *         -1: some inputs were invalid, or the signatures were not created\n- *             using the same set of nonces\n- * Args:   ctx:      pointer to a context object\n- * Out:    sig64:    pointer to a 64-byte array to place the combined signature\n- *                   (cannot be NULL)\n- * In:     sig64sin: pointer to an array of n pointers to 64-byte input\n- *                   signatures\n- *         n:        the number of signatures to combine (at least 1)\n- */\n-SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_schnorr_partial_combine(\n-  const secp256k1_context* ctx,\n-  unsigned char *sig64,\n-  const unsigned char * const * sig64sin,\n-  size_t n\n-) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n-\n-# ifdef __cplusplus\n-}\n-# endif\n-\n-#endif"
      },
      {
        "sha": "a0d006f1131f47d9bb80de6d425e38912e1258f0",
        "filename": "libsecp256k1.pc.in",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/libsecp256k1.pc.in",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/libsecp256k1.pc.in",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/libsecp256k1.pc.in?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -5,7 +5,7 @@ includedir=@includedir@\n \n Name: libsecp256k1\n Description: Optimized C library for EC operations on curve secp256k1\n-URL: https://github.com/bitcoin/secp256k1\n+URL: https://github.com/bitcoin-core/secp256k1\n Version: @PACKAGE_VERSION@\n Cflags: -I${includedir}\n Libs.private: @SECP_LIBS@"
      },
      {
        "sha": "ab580c5b23bbf786f41757b8a3800958db37c7a7",
        "filename": "sage/group_prover.sage",
        "status": "added",
        "additions": 322,
        "deletions": 0,
        "changes": 322,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/sage/group_prover.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/sage/group_prover.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/sage/group_prover.sage?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -0,0 +1,322 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map(numerator, assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+class constraints:\n+  \"\"\"A set of constraints, consisting of zero and nonzero expressions.\n+\n+  Constraints can either be used to express knowledge or a requirement.\n+\n+  Both the fields zero and nonzero are maps from expressions to description\n+  strings. The expressions that are the keys in zero are required to be zero,\n+  and the expressions that are the keys in nonzero are required to be nonzero.\n+\n+  Note that (a != 0) and (b != 0) is the same as (a*b != 0), so all keys in\n+  nonzero could be multiplied into a single key. This is often much less\n+  efficient to work with though, so we keep them separate inside the\n+  constraints. This allows higher-level code to do fast checks on the individual\n+  nonzero elements, or combine them if needed for stronger checks.\n+\n+  We can't multiply the different zero elements, as it would suffice for one of\n+  the factors to be zero, instead of all of them. Instead, the zero elements are\n+  typically combined into an ideal first.\n+  \"\"\"\n+\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map(numerator, con.zero))\n+  if 1 in zero:\n+    return True\n+  # First a cheap check whether any of the individual nonzero terms conflict on\n+  # their own.\n+  for nonzero in con.nonzero:\n+    if nonzero.iszero(zero):\n+      return True\n+  # It can be the case that entries in the nonzero set do not individually\n+  # conflict with the zero set, but their combination does. For example, knowing\n+  # that either x or y is zero is equivalent to having x*y in the zero set.\n+  # Having x or y individually in the nonzero set is not a conflict, but both\n+  # simultaneously is, so that is the right thing to check for.\n+  if reduce(lambda a,b: a * b, con.nonzero, fastfrac(R, 1)).iszero(zero):\n+    return True\n+  return False\n+\n+\n+def get_nonzero_set(R, assume):\n+  \"\"\"Calculate a simple set of nonzero expressions\"\"\"\n+  zero = R.ideal(map(numerator, assume.zero))\n+  nonzero = set()\n+  for nz in map(numerator, assume.nonzero):\n+    for (f,n) in nz.factor():\n+      nonzero.add(f)\n+    rnz = zero.reduce(nz)\n+    for (f,n) in rnz.factor():\n+      nonzero.add(f)\n+  return nonzero\n+\n+\n+def prove_nonzero(R, exprs, assume):\n+  \"\"\"Check whether an expression is provably nonzero, given assumptions\"\"\"\n+  zero = R.ideal(map(numerator, assume.zero))\n+  nonzero = get_nonzero_set(R, assume)\n+  expl = set()\n+  ok = True\n+  for expr in exprs:\n+    if numerator(expr) in zero:\n+      return (False, [exprs[expr]])\n+  allexprs = reduce(lambda a,b: numerator(a)*numerator(b), exprs, 1)\n+  for (f, n) in allexprs.factor():\n+    if f not in nonzero:\n+      ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for (f, n) in zero.reduce(numerator(allexprs)).factor():\n+    if f not in nonzero:\n+      ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for expr in exprs:\n+    for (f,n) in numerator(expr).factor():\n+      if f not in nonzero:\n+        ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for expr in exprs:\n+    for (f,n) in zero.reduce(numerator(expr)).factor():\n+      if f not in nonzero:\n+        expl.add(exprs[expr])\n+  if expl:\n+    return (False, list(expl))\n+  else:\n+    return (True, None)\n+\n+\n+def prove_zero(R, exprs, assume):\n+  \"\"\"Check whether all of the passed expressions are provably zero, given assumptions\"\"\"\n+  r, e = prove_nonzero(R, dict(map(lambda x: (fastfrac(R, x.bot, 1), exprs[x]), exprs)), assume)\n+  if not r:\n+    return (False, map(lambda x: \"Possibly zero denominator: %s\" % x, e))\n+  zero = R.ideal(map(numerator, assume.zero))\n+  nonzero = prod(x for x in assume.nonzero)\n+  expl = []\n+  for expr in exprs:\n+    if not expr.iszero(zero):\n+      expl.append(exprs[expr])\n+  if not expl:\n+    return (True, None)\n+  return (False, expl)\n+\n+\n+def describe_extra(R, assume, assumeExtra):\n+  \"\"\"Describe what assumptions are added, given existing assumptions\"\"\"\n+  zerox = assume.zero.copy()\n+  zerox.update(assumeExtra.zero)\n+  zero = R.ideal(map(numerator, assume.zero))\n+  zeroextra = R.ideal(map(numerator, zerox))\n+  nonzero = get_nonzero_set(R, assume)\n+  ret = set()\n+  # Iterate over the extra zero expressions\n+  for base in assumeExtra.zero:\n+    if base not in zero:\n+      add = []\n+      for (f, n) in numerator(base).factor():\n+        if f not in nonzero:\n+          add += [\"%s\" % f]\n+      if add:\n+        ret.add((\" * \".join(add)) + \" = 0 [%s]\" % assumeExtra.zero[base])\n+  # Iterate over the extra nonzero expressions\n+  for nz in assumeExtra.nonzero:\n+    nzr = zeroextra.reduce(numerator(nz))\n+    if nzr not in zeroextra:\n+      for (f,n) in nzr.factor():\n+        if zeroextra.reduce(f) not in nonzero:\n+          ret.add(\"%s != 0\" % zeroextra.reduce(f))\n+  return \", \".join(x for x in ret)\n+\n+\n+def check_symbolic(R, assumeLaw, assumeAssert, assumeBranch, require):\n+  \"\"\"Check a set of zero and nonzero requirements, given a set of zero and nonzero assumptions\"\"\"\n+  assume = assumeLaw + assumeAssert + assumeBranch\n+\n+  if conflicts(R, assume):\n+    # This formula does not apply\n+    return None\n+\n+  describe = describe_extra(R, assumeLaw + assumeBranch, assumeAssert)\n+\n+  ok, msg = prove_zero(R, require.zero, assume)\n+  if not ok:\n+    return \"FAIL, %s fails (assuming %s)\" % (str(msg), describe)\n+\n+  res, expl = prove_nonzero(R, require.nonzero, assume)\n+  if not res:\n+    return \"FAIL, %s fails (assuming %s)\" % (str(expl), describe)\n+\n+  if describe != \"\":\n+    return \"OK (assuming %s)\" % describe\n+  else:\n+    return \"OK\"\n+\n+\n+def concrete_verify(c):\n+  for k in c.zero:\n+    if k != 0:\n+      return (False, c.zero[k])\n+  for k in c.nonzero:\n+    if k == 0:\n+      return (False, c.nonzero[k])\n+  return (True, None)"
      },
      {
        "sha": "a97e732f7fa3ab681a63070eda20455cda3a6c32",
        "filename": "sage/secp256k1.sage",
        "status": "added",
        "additions": 306,
        "deletions": 0,
        "changes": 306,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/sage/secp256k1.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/sage/secp256k1.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/sage/secp256k1.sage?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -0,0 +1,306 @@\n+# Test libsecp256k1' group operation implementations using prover.sage\n+\n+import sys\n+\n+load(\"group_prover.sage\")\n+load(\"weierstrass_prover.sage\")\n+\n+def formula_secp256k1_gej_double_var(a):\n+  \"\"\"libsecp256k1's secp256k1_gej_double_var, used by various addition functions\"\"\"\n+  rz = a.Z * a.Y\n+  rz = rz * 2\n+  t1 = a.X^2\n+  t1 = t1 * 3\n+  t2 = t1^2\n+  t3 = a.Y^2\n+  t3 = t3 * 2\n+  t4 = t3^2\n+  t4 = t4 * 2\n+  t3 = t3 * a.X\n+  rx = t3\n+  rx = rx * 4\n+  rx = -rx\n+  rx = rx + t2\n+  t2 = -t2\n+  t3 = t3 * 6\n+  t3 = t3 + t2\n+  ry = t1 * t3\n+  t2 = -t4\n+  ry = ry + t2\n+  return jacobianpoint(rx, ry, rz)\n+\n+def formula_secp256k1_gej_add_var(branch, a, b):\n+  \"\"\"libsecp256k1's secp256k1_gej_add_var\"\"\"\n+  if branch == 0:\n+    return (constraints(), constraints(nonzero={a.Infinity : 'a_infinite'}), b)\n+  if branch == 1:\n+    return (constraints(), constraints(zero={a.Infinity : 'a_finite'}, nonzero={b.Infinity : 'b_infinite'}), a)\n+  z22 = b.Z^2\n+  z12 = a.Z^2\n+  u1 = a.X * z22\n+  u2 = b.X * z12\n+  s1 = a.Y * z22\n+  s1 = s1 * b.Z\n+  s2 = b.Y * z12\n+  s2 = s2 * a.Z\n+  h = -u1\n+  h = h + u2\n+  i = -s1\n+  i = i + s2\n+  if branch == 2:\n+    r = formula_secp256k1_gej_double_var(a)\n+    return (constraints(), constraints(zero={h : 'h=0', i : 'i=0', a.Infinity : 'a_finite', b.Infinity : 'b_finite'}), r)\n+  if branch == 3:\n+    return (constraints(), constraints(zero={h : 'h=0', a.Infinity : 'a_finite', b.Infinity : 'b_finite'}, nonzero={i : 'i!=0'}), point_at_infinity())\n+  i2 = i^2\n+  h2 = h^2\n+  h3 = h2 * h\n+  h = h * b.Z\n+  rz = a.Z * h\n+  t = u1 * h2\n+  rx = t\n+  rx = rx * 2\n+  rx = rx + h3\n+  rx = -rx\n+  rx = rx + i2\n+  ry = -rx\n+  ry = ry + t\n+  ry = ry * i\n+  h3 = h3 * s1\n+  h3 = -h3\n+  ry = ry + h3\n+  return (constraints(), constraints(zero={a.Infinity : 'a_finite', b.Infinity : 'b_finite'}, nonzero={h : 'h!=0'}), jacobianpoint(rx, ry, rz))\n+\n+def formula_secp256k1_gej_add_ge_var(branch, a, b):\n+  \"\"\"libsecp256k1's secp256k1_gej_add_ge_var, which assume bz==1\"\"\"\n+  if branch == 0:\n+    return (constraints(zero={b.Z - 1 : 'b.z=1'}), constraints(nonzero={a.Infinity : 'a_infinite'}), b)\n+  if branch == 1:\n+    return (constraints(zero={b.Z - 1 : 'b.z=1'}), constraints(zero={a.Infinity : 'a_finite'}, nonzero={b.Infinity : 'b_infinite'}), a)\n+  z12 = a.Z^2\n+  u1 = a.X\n+  u2 = b.X * z12\n+  s1 = a.Y\n+  s2 = b.Y * z12\n+  s2 = s2 * a.Z\n+  h = -u1\n+  h = h + u2\n+  i = -s1\n+  i = i + s2\n+  if (branch == 2):\n+    r = formula_secp256k1_gej_double_var(a)\n+    return (constraints(zero={b.Z - 1 : 'b.z=1'}), constraints(zero={a.Infinity : 'a_finite', b.Infinity : 'b_finite', h : 'h=0', i : 'i=0'}), r)\n+  if (branch == 3):\n+    return (constraints(zero={b.Z - 1 : 'b.z=1'}), constraints(zero={a.Infinity : 'a_finite', b.Infinity : 'b_finite', h : 'h=0'}, nonzero={i : 'i!=0'}), point_at_infinity())\n+  i2 = i^2\n+  h2 = h^2\n+  h3 = h * h2\n+  rz = a.Z * h\n+  t = u1 * h2\n+  rx = t\n+  rx = rx * 2\n+  rx = rx + h3\n+  rx = -rx\n+  rx = rx + i2\n+  ry = -rx\n+  ry = ry + t\n+  ry = ry * i\n+  h3 = h3 * s1\n+  h3 = -h3\n+  ry = ry + h3\n+  return (constraints(zero={b.Z - 1 : 'b.z=1'}), constraints(zero={a.Infinity : 'a_finite', b.Infinity : 'b_finite'}, nonzero={h : 'h!=0'}), jacobianpoint(rx, ry, rz))\n+\n+def formula_secp256k1_gej_add_zinv_var(branch, a, b):\n+  \"\"\"libsecp256k1's secp256k1_gej_add_zinv_var\"\"\"\n+  bzinv = b.Z^(-1)\n+  if branch == 0:\n+    return (constraints(), constraints(nonzero={b.Infinity : 'b_infinite'}), a)\n+  if branch == 1:\n+    bzinv2 = bzinv^2\n+    bzinv3 = bzinv2 * bzinv\n+    rx = b.X * bzinv2\n+    ry = b.Y * bzinv3\n+    rz = 1\n+    return (constraints(), constraints(zero={b.Infinity : 'b_finite'}, nonzero={a.Infinity : 'a_infinite'}), jacobianpoint(rx, ry, rz))\n+  azz = a.Z * bzinv\n+  z12 = azz^2\n+  u1 = a.X\n+  u2 = b.X * z12\n+  s1 = a.Y\n+  s2 = b.Y * z12\n+  s2 = s2 * azz\n+  h = -u1\n+  h = h + u2\n+  i = -s1\n+  i = i + s2\n+  if branch == 2:\n+    r = formula_secp256k1_gej_double_var(a)\n+    return (constraints(), constraints(zero={a.Infinity : 'a_finite', b.Infinity : 'b_finite', h : 'h=0', i : 'i=0'}), r)\n+  if branch == 3:\n+    return (constraints(), constraints(zero={a.Infinity : 'a_finite', b.Infinity : 'b_finite', h : 'h=0'}, nonzero={i : 'i!=0'}), point_at_infinity())\n+  i2 = i^2\n+  h2 = h^2\n+  h3 = h * h2\n+  rz = a.Z\n+  rz = rz * h\n+  t = u1 * h2\n+  rx = t\n+  rx = rx * 2\n+  rx = rx + h3\n+  rx = -rx\n+  rx = rx + i2\n+  ry = -rx\n+  ry = ry + t\n+  ry = ry * i\n+  h3 = h3 * s1\n+  h3 = -h3\n+  ry = ry + h3\n+  return (constraints(), constraints(zero={a.Infinity : 'a_finite', b.Infinity : 'b_finite'}, nonzero={h : 'h!=0'}), jacobianpoint(rx, ry, rz))\n+\n+def formula_secp256k1_gej_add_ge(branch, a, b):\n+  \"\"\"libsecp256k1's secp256k1_gej_add_ge\"\"\"\n+  zeroes = {}\n+  nonzeroes = {}\n+  a_infinity = False\n+  if (branch & 4) != 0:\n+    nonzeroes.update({a.Infinity : 'a_infinite'})\n+    a_infinity = True\n+  else:\n+    zeroes.update({a.Infinity : 'a_finite'})\n+  zz = a.Z^2\n+  u1 = a.X\n+  u2 = b.X * zz\n+  s1 = a.Y\n+  s2 = b.Y * zz\n+  s2 = s2 * a.Z\n+  t = u1\n+  t = t + u2\n+  m = s1\n+  m = m + s2\n+  rr = t^2\n+  m_alt = -u2\n+  tt = u1 * m_alt\n+  rr = rr + tt\n+  degenerate = (branch & 3) == 3\n+  if (branch & 1) != 0:\n+    zeroes.update({m : 'm_zero'})\n+  else:\n+    nonzeroes.update({m : 'm_nonzero'})\n+  if (branch & 2) != 0:\n+    zeroes.update({rr : 'rr_zero'})\n+  else:\n+    nonzeroes.update({rr : 'rr_nonzero'})\n+  rr_alt = s1\n+  rr_alt = rr_alt * 2\n+  m_alt = m_alt + u1\n+  if not degenerate:\n+    rr_alt = rr\n+    m_alt = m\n+  n = m_alt^2\n+  q = n * t\n+  n = n^2\n+  if degenerate:\n+    n = m\n+  t = rr_alt^2\n+  rz = a.Z * m_alt\n+  infinity = False\n+  if (branch & 8) != 0:\n+    if not a_infinity:\n+      infinity = True\n+    zeroes.update({rz : 'r.z=0'})\n+  else:\n+    nonzeroes.update({rz : 'r.z!=0'})\n+  rz = rz * 2\n+  q = -q\n+  t = t + q\n+  rx = t\n+  t = t * 2\n+  t = t + q\n+  t = t * rr_alt\n+  t = t + n\n+  ry = -t\n+  rx = rx * 4\n+  ry = ry * 4\n+  if a_infinity:\n+    rx = b.X\n+    ry = b.Y\n+    rz = 1\n+  if infinity:\n+    return (constraints(zero={b.Z - 1 : 'b.z=1', b.Infinity : 'b_finite'}), constraints(zero=zeroes, nonzero=nonzeroes), point_at_infinity())\n+  return (constraints(zero={b.Z - 1 : 'b.z=1', b.Infinity : 'b_finite'}), constraints(zero=zeroes, nonzero=nonzeroes), jacobianpoint(rx, ry, rz))\n+\n+def formula_secp256k1_gej_add_ge_old(branch, a, b):\n+  \"\"\"libsecp256k1's old secp256k1_gej_add_ge, which fails when ay+by=0 but ax!=bx\"\"\"\n+  a_infinity = (branch & 1) != 0\n+  zero = {}\n+  nonzero = {}\n+  if a_infinity:\n+    nonzero.update({a.Infinity : 'a_infinite'})\n+  else:\n+    zero.update({a.Infinity : 'a_finite'})\n+  zz = a.Z^2\n+  u1 = a.X\n+  u2 = b.X * zz\n+  s1 = a.Y\n+  s2 = b.Y * zz\n+  s2 = s2 * a.Z\n+  z = a.Z\n+  t = u1\n+  t = t + u2\n+  m = s1\n+  m = m + s2\n+  n = m^2\n+  q = n * t\n+  n = n^2\n+  rr = t^2\n+  t = u1 * u2\n+  t = -t\n+  rr = rr + t\n+  t = rr^2\n+  rz = m * z\n+  infinity = False\n+  if (branch & 2) != 0:\n+    if not a_infinity:\n+      infinity = True\n+    else:\n+      return (constraints(zero={b.Z - 1 : 'b.z=1', b.Infinity : 'b_finite'}), constraints(nonzero={z : 'conflict_a'}, zero={z : 'conflict_b'}), point_at_infinity())\n+    zero.update({rz : 'r.z=0'})\n+  else:\n+    nonzero.update({rz : 'r.z!=0'})\n+  rz = rz * (0 if a_infinity else 2)\n+  rx = t\n+  q = -q\n+  rx = rx + q\n+  q = q * 3\n+  t = t * 2\n+  t = t + q\n+  t = t * rr\n+  t = t + n\n+  ry = -t\n+  rx = rx * (0 if a_infinity else 4)\n+  ry = ry * (0 if a_infinity else 4)\n+  t = b.X\n+  t = t * (1 if a_infinity else 0)\n+  rx = rx + t\n+  t = b.Y\n+  t = t * (1 if a_infinity else 0)\n+  ry = ry + t\n+  t = (1 if a_infinity else 0)\n+  rz = rz + t\n+  if infinity:\n+    return (constraints(zero={b.Z - 1 : 'b.z=1', b.Infinity : 'b_finite'}), constraints(zero=zero, nonzero=nonzero), point_at_infinity())\n+  return (constraints(zero={b.Z - 1 : 'b.z=1', b.Infinity : 'b_finite'}), constraints(zero=zero, nonzero=nonzero), jacobianpoint(rx, ry, rz))\n+\n+if __name__ == \"__main__\":\n+  check_symbolic_jacobian_weierstrass(\"secp256k1_gej_add_var\", 0, 7, 5, formula_secp256k1_gej_add_var)\n+  check_symbolic_jacobian_weierstrass(\"secp256k1_gej_add_ge_var\", 0, 7, 5, formula_secp256k1_gej_add_ge_var)\n+  check_symbolic_jacobian_weierstrass(\"secp256k1_gej_add_zinv_var\", 0, 7, 5, formula_secp256k1_gej_add_zinv_var)\n+  check_symbolic_jacobian_weierstrass(\"secp256k1_gej_add_ge\", 0, 7, 16, formula_secp256k1_gej_add_ge)\n+  check_symbolic_jacobian_weierstrass(\"secp256k1_gej_add_ge_old [should fail]\", 0, 7, 4, formula_secp256k1_gej_add_ge_old)\n+\n+  if len(sys.argv) >= 2 and sys.argv[1] == \"--exhaustive\":\n+    check_exhaustive_jacobian_weierstrass(\"secp256k1_gej_add_var\", 0, 7, 5, formula_secp256k1_gej_add_var, 43)\n+    check_exhaustive_jacobian_weierstrass(\"secp256k1_gej_add_ge_var\", 0, 7, 5, formula_secp256k1_gej_add_ge_var, 43)\n+    check_exhaustive_jacobian_weierstrass(\"secp256k1_gej_add_zinv_var\", 0, 7, 5, formula_secp256k1_gej_add_zinv_var, 43)\n+    check_exhaustive_jacobian_weierstrass(\"secp256k1_gej_add_ge\", 0, 7, 16, formula_secp256k1_gej_add_ge, 43)\n+    check_exhaustive_jacobian_weierstrass(\"secp256k1_gej_add_ge_old [should fail]\", 0, 7, 4, formula_secp256k1_gej_add_ge_old, 43)"
      },
      {
        "sha": "03ef2ec901ea9cafa47b4ccdce7bbba61279930f",
        "filename": "sage/weierstrass_prover.sage",
        "status": "added",
        "additions": 264,
        "deletions": 0,
        "changes": 264,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/sage/weierstrass_prover.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/sage/weierstrass_prover.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/sage/weierstrass_prover.sage?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -0,0 +1,264 @@\n+# Prover implementation for Weierstrass curves of the form\n+# y^2 = x^3 + A * x + B, specifically with a = 0 and b = 7, with group laws\n+# operating on affine and Jacobian coordinates, including the point at infinity\n+# represented by a 4th variable in coordinates.\n+\n+load(\"group_prover.sage\")\n+\n+\n+class affinepoint:\n+  def __init__(self, x, y, infinity=0):\n+    self.x = x\n+    self.y = y\n+    self.infinity = infinity\n+  def __str__(self):\n+    return \"affinepoint(x=%s,y=%s,inf=%s)\" % (self.x, self.y, self.infinity)\n+\n+\n+class jacobianpoint:\n+  def __init__(self, x, y, z, infinity=0):\n+    self.X = x\n+    self.Y = y\n+    self.Z = z\n+    self.Infinity = infinity\n+  def __str__(self):\n+    return \"jacobianpoint(X=%s,Y=%s,Z=%s,inf=%s)\" % (self.X, self.Y, self.Z, self.Infinity)\n+\n+\n+def point_at_infinity():\n+  return jacobianpoint(1, 1, 1, 1)\n+\n+\n+def negate(p):\n+  if p.__class__ == affinepoint:\n+    return affinepoint(p.x, -p.y)\n+  if p.__class__ == jacobianpoint:\n+    return jacobianpoint(p.X, -p.Y, p.Z)\n+  assert(False)\n+\n+\n+def on_weierstrass_curve(A, B, p):\n+  \"\"\"Return a set of zero-expressions for an affine point to be on the curve\"\"\"\n+  return constraints(zero={p.x^3 + A*p.x + B - p.y^2: 'on_curve'})\n+\n+\n+def tangential_to_weierstrass_curve(A, B, p12, p3):\n+  \"\"\"Return a set of zero-expressions for ((x12,y12),(x3,y3)) to be a line that is tangential to the curve at (x12,y12)\"\"\"\n+  return constraints(zero={\n+    (p12.y - p3.y) * (p12.y * 2) - (p12.x^2 * 3 + A) * (p12.x - p3.x): 'tangential_to_curve'\n+  })\n+\n+\n+def colinear(p1, p2, p3):\n+  \"\"\"Return a set of zero-expressions for ((x1,y1),(x2,y2),(x3,y3)) to be collinear\"\"\"\n+  return constraints(zero={\n+    (p1.y - p2.y) * (p1.x - p3.x) - (p1.y - p3.y) * (p1.x - p2.x): 'colinear_1',\n+    (p2.y - p3.y) * (p2.x - p1.x) - (p2.y - p1.y) * (p2.x - p3.x): 'colinear_2',\n+    (p3.y - p1.y) * (p3.x - p2.x) - (p3.y - p2.y) * (p3.x - p1.x): 'colinear_3'\n+  })\n+\n+\n+def good_affine_point(p):\n+  return constraints(nonzero={p.x : 'nonzero_x', p.y : 'nonzero_y'})\n+\n+\n+def good_jacobian_point(p):\n+  return constraints(nonzero={p.X : 'nonzero_X', p.Y : 'nonzero_Y', p.Z^6 : 'nonzero_Z'})\n+\n+\n+def good_point(p):\n+  return constraints(nonzero={p.Z^6 : 'nonzero_X'})\n+\n+\n+def finite(p, *affine_fns):\n+  con = good_point(p) + constraints(zero={p.Infinity : 'finite_point'})\n+  if p.Z != 0:\n+    return con + reduce(lambda a, b: a + b, (f(affinepoint(p.X / p.Z^2, p.Y / p.Z^3)) for f in affine_fns), con)\n+  else:\n+    return con\n+\n+def infinite(p):\n+  return constraints(nonzero={p.Infinity : 'infinite_point'})\n+\n+\n+def law_jacobian_weierstrass_add(A, B, pa, pb, pA, pB, pC):\n+  \"\"\"Check whether the passed set of coordinates is a valid Jacobian add, given assumptions\"\"\"\n+  assumeLaw = (good_affine_point(pa) +\n+               good_affine_point(pb) +\n+               good_jacobian_point(pA) +\n+               good_jacobian_point(pB) +\n+               on_weierstrass_curve(A, B, pa) +\n+               on_weierstrass_curve(A, B, pb) +\n+               finite(pA) +\n+               finite(pB) +\n+               constraints(nonzero={pa.x - pb.x : 'different_x'}))\n+  require = (finite(pC, lambda pc: on_weierstrass_curve(A, B, pc) +\n+             colinear(pa, pb, negate(pc))))\n+  return (assumeLaw, require)\n+\n+\n+def law_jacobian_weierstrass_double(A, B, pa, pb, pA, pB, pC):\n+  \"\"\"Check whether the passed set of coordinates is a valid Jacobian doubling, given assumptions\"\"\"\n+  assumeLaw = (good_affine_point(pa) +\n+               good_affine_point(pb) +\n+               good_jacobian_point(pA) +\n+               good_jacobian_point(pB) +\n+               on_weierstrass_curve(A, B, pa) +\n+               on_weierstrass_curve(A, B, pb) +\n+               finite(pA) +\n+               finite(pB) +\n+               constraints(zero={pa.x - pb.x : 'equal_x', pa.y - pb.y : 'equal_y'}))\n+  require = (finite(pC, lambda pc: on_weierstrass_curve(A, B, pc) +\n+             tangential_to_weierstrass_curve(A, B, pa, negate(pc))))\n+  return (assumeLaw, require)\n+\n+\n+def law_jacobian_weierstrass_add_opposites(A, B, pa, pb, pA, pB, pC):\n+  assumeLaw = (good_affine_point(pa) +\n+               good_affine_point(pb) +\n+               good_jacobian_point(pA) +\n+               good_jacobian_point(pB) +\n+               on_weierstrass_curve(A, B, pa) +\n+               on_weierstrass_curve(A, B, pb) +\n+               finite(pA) +\n+               finite(pB) +\n+               constraints(zero={pa.x - pb.x : 'equal_x', pa.y + pb.y : 'opposite_y'}))\n+  require = infinite(pC)\n+  return (assumeLaw, require)\n+\n+\n+def law_jacobian_weierstrass_add_infinite_a(A, B, pa, pb, pA, pB, pC):\n+  assumeLaw = (good_affine_point(pa) +\n+               good_affine_point(pb) +\n+               good_jacobian_point(pA) +\n+               good_jacobian_point(pB) +\n+               on_weierstrass_curve(A, B, pb) +\n+               infinite(pA) +\n+               finite(pB))\n+  require = finite(pC, lambda pc: constraints(zero={pc.x - pb.x : 'c.x=b.x', pc.y - pb.y : 'c.y=b.y'}))\n+  return (assumeLaw, require)\n+\n+\n+def law_jacobian_weierstrass_add_infinite_b(A, B, pa, pb, pA, pB, pC):\n+  assumeLaw = (good_affine_point(pa) +\n+               good_affine_point(pb) +\n+               good_jacobian_point(pA) +\n+               good_jacobian_point(pB) +\n+               on_weierstrass_curve(A, B, pa) +\n+               infinite(pB) +\n+               finite(pA))\n+  require = finite(pC, lambda pc: constraints(zero={pc.x - pa.x : 'c.x=a.x', pc.y - pa.y : 'c.y=a.y'}))\n+  return (assumeLaw, require)\n+\n+\n+def law_jacobian_weierstrass_add_infinite_ab(A, B, pa, pb, pA, pB, pC):\n+  assumeLaw = (good_affine_point(pa) +\n+               good_affine_point(pb) +\n+               good_jacobian_point(pA) +\n+               good_jacobian_point(pB) +\n+               infinite(pA) +\n+               infinite(pB))\n+  require = infinite(pC)\n+  return (assumeLaw, require)\n+\n+\n+laws_jacobian_weierstrass = {\n+  'add': law_jacobian_weierstrass_add,\n+  'double': law_jacobian_weierstrass_double,\n+  'add_opposite': law_jacobian_weierstrass_add_opposites,\n+  'add_infinite_a': law_jacobian_weierstrass_add_infinite_a,\n+  'add_infinite_b': law_jacobian_weierstrass_add_infinite_b,\n+  'add_infinite_ab': law_jacobian_weierstrass_add_infinite_ab\n+}\n+\n+\n+def check_exhaustive_jacobian_weierstrass(name, A, B, branches, formula, p):\n+  \"\"\"Verify an implementation of addition of Jacobian points on a Weierstrass curve, by executing and validating the result for every possible addition in a prime field\"\"\"\n+  F = Integers(p)\n+  print \"Formula %s on Z%i:\" % (name, p)\n+  points = []\n+  for x in xrange(0, p):\n+    for y in xrange(0, p):\n+      point = affinepoint(F(x), F(y))\n+      r, e = concrete_verify(on_weierstrass_curve(A, B, point))\n+      if r:\n+        points.append(point)\n+\n+  for za in xrange(1, p):\n+    for zb in xrange(1, p):\n+      for pa in points:\n+        for pb in points:\n+          for ia in xrange(2):\n+            for ib in xrange(2):\n+              pA = jacobianpoint(pa.x * F(za)^2, pa.y * F(za)^3, F(za), ia)\n+              pB = jacobianpoint(pb.x * F(zb)^2, pb.y * F(zb)^3, F(zb), ib)\n+              for branch in xrange(0, branches):\n+                assumeAssert, assumeBranch, pC = formula(branch, pA, pB)\n+                pC.X = F(pC.X)\n+                pC.Y = F(pC.Y)\n+                pC.Z = F(pC.Z)\n+                pC.Infinity = F(pC.Infinity)\n+                r, e = concrete_verify(assumeAssert + assumeBranch)\n+                if r:\n+                  match = False\n+                  for key in laws_jacobian_weierstrass:\n+                    assumeLaw, require = laws_jacobian_weierstrass[key](A, B, pa, pb, pA, pB, pC)\n+                    r, e = concrete_verify(assumeLaw)\n+                    if r:\n+                      if match:\n+                        print \"  multiple branches for (%s,%s,%s,%s) + (%s,%s,%s,%s)\" % (pA.X, pA.Y, pA.Z, pA.Infinity, pB.X, pB.Y, pB.Z, pB.Infinity)\n+                      else:\n+                        match = True\n+                      r, e = concrete_verify(require)\n+                      if not r:\n+                        print \"  failure in branch %i for (%s,%s,%s,%s) + (%s,%s,%s,%s) = (%s,%s,%s,%s): %s\" % (branch, pA.X, pA.Y, pA.Z, pA.Infinity, pB.X, pB.Y, pB.Z, pB.Infinity, pC.X, pC.Y, pC.Z, pC.Infinity, e)\n+  print\n+\n+\n+def check_symbolic_function(R, assumeAssert, assumeBranch, f, A, B, pa, pb, pA, pB, pC):\n+  assumeLaw, require = f(A, B, pa, pb, pA, pB, pC)\n+  return check_symbolic(R, assumeLaw, assumeAssert, assumeBranch, require)\n+\n+def check_symbolic_jacobian_weierstrass(name, A, B, branches, formula):\n+  \"\"\"Verify an implementation of addition of Jacobian points on a Weierstrass curve symbolically\"\"\"\n+  R.<ax,bx,ay,by,Az,Bz,Ai,Bi> = PolynomialRing(QQ,8,order='invlex')\n+  lift = lambda x: fastfrac(R,x)\n+  ax = lift(ax)\n+  ay = lift(ay)\n+  Az = lift(Az)\n+  bx = lift(bx)\n+  by = lift(by)\n+  Bz = lift(Bz)\n+  Ai = lift(Ai)\n+  Bi = lift(Bi)\n+\n+  pa = affinepoint(ax, ay, Ai)\n+  pb = affinepoint(bx, by, Bi)\n+  pA = jacobianpoint(ax * Az^2, ay * Az^3, Az, Ai)\n+  pB = jacobianpoint(bx * Bz^2, by * Bz^3, Bz, Bi)\n+\n+  res = {}\n+\n+  for key in laws_jacobian_weierstrass:\n+    res[key] = []\n+\n+  print (\"Formula \" + name + \":\")\n+  count = 0\n+  for branch in xrange(branches):\n+    assumeFormula, assumeBranch, pC = formula(branch, pA, pB)\n+    pC.X = lift(pC.X)\n+    pC.Y = lift(pC.Y)\n+    pC.Z = lift(pC.Z)\n+    pC.Infinity = lift(pC.Infinity)\n+\n+    for key in laws_jacobian_weierstrass:\n+      res[key].append((check_symbolic_function(R, assumeFormula, assumeBranch, laws_jacobian_weierstrass[key], A, B, pa, pb, pA, pB, pC), branch))\n+\n+  for key in res:\n+    print \"  %s:\" % key\n+    val = res[key]\n+    for x in val:\n+      if x[0] is not None:\n+        print \"    branch %i: %s\" % (x[1], x[0])\n+\n+  print"
      },
      {
        "sha": "5df561f2fc939e332dae7137345a18fdef9906eb",
        "filename": "src/asm/field_10x26_arm.s",
        "status": "added",
        "additions": 919,
        "deletions": 0,
        "changes": 919,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/asm/field_10x26_arm.s",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/asm/field_10x26_arm.s",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/asm/field_10x26_arm.s?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -0,0 +1,919 @@\n+@ vim: set tabstop=8 softtabstop=8 shiftwidth=8 noexpandtab syntax=armasm:\n+/**********************************************************************\n+ * Copyright (c) 2014 Wladimir J. van der Laan                        *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+/*\n+ARM implementation of field_10x26 inner loops.\n+\n+Note:\n+\n+- To avoid unnecessary loads and make use of available registers, two\n+  'passes' have every time been interleaved, with the odd passes accumulating c' and d' \n+  which will be added to c and d respectively in the the even passes\n+\n+*/\n+\n+\t.syntax unified\n+\t.arch armv7-a\n+\t@ eabi attributes - see readelf -A\n+\t.eabi_attribute 8, 1  @ Tag_ARM_ISA_use = yes\n+\t.eabi_attribute 9, 0  @ Tag_Thumb_ISA_use = no\n+\t.eabi_attribute 10, 0 @ Tag_FP_arch = none\n+\t.eabi_attribute 24, 1 @ Tag_ABI_align_needed = 8-byte\n+\t.eabi_attribute 25, 1 @ Tag_ABI_align_preserved = 8-byte, except leaf SP\n+\t.eabi_attribute 30, 2 @ Tag_ABI_optimization_goals = Agressive Speed\n+\t.eabi_attribute 34, 1 @ Tag_CPU_unaligned_access = v6\n+\t.text\n+\n+\t@ Field constants\n+\t.set field_R0, 0x3d10\n+\t.set field_R1, 0x400\n+\t.set field_not_M, 0xfc000000\t@ ~M = ~0x3ffffff\n+\n+\t.align\t2\n+\t.global secp256k1_fe_mul_inner\n+\t.type\tsecp256k1_fe_mul_inner, %function\n+\t@ Arguments:\n+\t@  r0  r      Restrict: can overlap with a, not with b\n+\t@  r1  a\n+\t@  r2  b\n+\t@ Stack (total 4+10*4 = 44)\n+\t@  sp + #0        saved 'r' pointer\n+\t@  sp + #4 + 4*X  t0,t1,t2,t3,t4,t5,t6,t7,u8,t9\n+secp256k1_fe_mul_inner:\n+\tstmfd\tsp!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}\n+\tsub\tsp, sp, #48\t\t\t@ frame=44 + alignment\n+\tstr     r0, [sp, #0]\t\t\t@ save result address, we need it only at the end\n+\n+\t/******************************************\n+\t * Main computation code.\n+\t ******************************************\n+\n+\tAllocation:\n+\t    r0,r14,r7,r8   scratch\n+\t    r1       a (pointer)\n+\t    r2       b (pointer)\n+\t    r3:r4    c\n+\t    r5:r6    d\n+\t    r11:r12  c'\n+\t    r9:r10   d'\n+\n+\tNote: do not write to r[] here, it may overlap with a[]\n+\t*/\n+\n+\t/* A - interleaved with B */\n+\tldr\tr7, [r1, #0*4]\t\t\t@ a[0]\n+\tldr\tr8, [r2, #9*4]\t\t\t@ b[9]\n+\tldr\tr0, [r1, #1*4]\t\t\t@ a[1]\n+\tumull\tr5, r6, r7, r8\t\t\t@ d = a[0] * b[9]\n+\tldr\tr14, [r2, #8*4]\t\t\t@ b[8]\n+\tumull\tr9, r10, r0, r8\t\t\t@ d' = a[1] * b[9]\n+\tldr\tr7, [r1, #2*4]\t\t\t@ a[2]\n+\tumlal\tr5, r6, r0, r14\t\t\t@ d += a[1] * b[8]\n+\tldr\tr8, [r2, #7*4] \t\t\t@ b[7]\n+\tumlal\tr9, r10, r7, r14\t\t@ d' += a[2] * b[8]\n+\tldr\tr0, [r1, #3*4]   \t\t@ a[3]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[2] * b[7]\n+\tldr\tr14, [r2, #6*4]   \t\t@ b[6]\n+\tumlal\tr9, r10, r0, r8  \t\t@ d' += a[3] * b[7]\n+\tldr\tr7, [r1, #4*4]   \t\t@ a[4]\n+\tumlal\tr5, r6, r0, r14   \t\t@ d += a[3] * b[6]\n+\tldr\tr8, [r2, #5*4]   \t\t@ b[5]\n+\tumlal\tr9, r10, r7, r14  \t\t@ d' += a[4] * b[6]\n+\tldr\tr0, [r1, #5*4]   \t\t@ a[5]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[4] * b[5]\n+\tldr\tr14, [r2, #4*4]   \t\t@ b[4]\n+\tumlal\tr9, r10, r0, r8  \t\t@ d' += a[5] * b[5]\n+\tldr\tr7, [r1, #6*4]   \t\t@ a[6]\n+\tumlal\tr5, r6, r0, r14   \t\t@ d += a[5] * b[4]\n+\tldr\tr8, [r2, #3*4]   \t\t@ b[3]\n+\tumlal\tr9, r10, r7, r14  \t\t@ d' += a[6] * b[4]\n+\tldr\tr0, [r1, #7*4]   \t\t@ a[7]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[6] * b[3]\n+\tldr\tr14, [r2, #2*4]   \t\t@ b[2]\n+\tumlal\tr9, r10, r0, r8  \t\t@ d' += a[7] * b[3]\n+\tldr\tr7, [r1, #8*4]   \t\t@ a[8]\n+\tumlal\tr5, r6, r0, r14   \t\t@ d += a[7] * b[2]\n+\tldr\tr8, [r2, #1*4]   \t\t@ b[1]\n+\tumlal\tr9, r10, r7, r14  \t\t@ d' += a[8] * b[2]\n+\tldr\tr0, [r1, #9*4]   \t\t@ a[9]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[8] * b[1]\n+\tldr\tr14, [r2, #0*4]   \t\t@ b[0]\n+\tumlal\tr9, r10, r0, r8  \t\t@ d' += a[9] * b[1]\n+\tldr\tr7, [r1, #0*4]   \t\t@ a[0]\n+\tumlal\tr5, r6, r0, r14   \t\t@ d += a[9] * b[0]\n+\t@ r7,r14 used in B\n+\n+\tbic\tr0, r5, field_not_M \t\t@ t9 = d & M\n+\tstr     r0, [sp, #4 + 4*9]\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26 \n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\n+\t/* B */\n+\tumull\tr3, r4, r7, r14   \t\t@ c = a[0] * b[0]\n+\tadds\tr5, r5, r9       \t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u0 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u0 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t0 = c & M\n+\tstr\tr14, [sp, #4 + 0*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u0 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* C - interleaved with D */\n+\tldr\tr7, [r1, #0*4]   \t\t@ a[0]\n+\tldr\tr8, [r2, #2*4]   \t\t@ b[2]\n+\tldr\tr14, [r2, #1*4]   \t\t@ b[1]\n+\tumull\tr11, r12, r7, r8   \t\t@ c' = a[0] * b[2]\n+\tldr\tr0, [r1, #1*4]   \t\t@ a[1]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[0] * b[1]\n+\tldr\tr8, [r2, #0*4]   \t\t@ b[0]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[1] * b[1]\n+\tldr\tr7, [r1, #2*4]   \t\t@ a[2]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[1] * b[0]\n+\tldr\tr14, [r2, #9*4]   \t\t@ b[9]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[2] * b[0]\n+\tldr\tr0, [r1, #3*4]   \t\t@ a[3]\n+\tumlal\tr5, r6, r7, r14   \t\t@ d += a[2] * b[9]\n+\tldr\tr8, [r2, #8*4]   \t\t@ b[8]\n+\tumull\tr9, r10, r0, r14   \t\t@ d' = a[3] * b[9]\n+\tldr\tr7, [r1, #4*4]   \t\t@ a[4]\n+\tumlal\tr5, r6, r0, r8   \t\t@ d += a[3] * b[8]\n+\tldr\tr14, [r2, #7*4]   \t\t@ b[7]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[4] * b[8]\n+\tldr\tr0, [r1, #5*4]   \t\t@ a[5]\n+\tumlal\tr5, r6, r7, r14   \t\t@ d += a[4] * b[7]\n+\tldr\tr8, [r2, #6*4]   \t\t@ b[6]\n+\tumlal\tr9, r10, r0, r14   \t\t@ d' += a[5] * b[7]\n+\tldr\tr7, [r1, #6*4]   \t\t@ a[6]\n+\tumlal\tr5, r6, r0, r8   \t\t@ d += a[5] * b[6]\n+\tldr\tr14, [r2, #5*4]   \t\t@ b[5]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[6] * b[6]\n+\tldr\tr0, [r1, #7*4]   \t\t@ a[7]\n+\tumlal\tr5, r6, r7, r14   \t\t@ d += a[6] * b[5]\n+\tldr\tr8, [r2, #4*4]   \t\t@ b[4]\n+\tumlal\tr9, r10, r0, r14   \t\t@ d' += a[7] * b[5]\n+\tldr\tr7, [r1, #8*4]   \t\t@ a[8]\n+\tumlal\tr5, r6, r0, r8   \t\t@ d += a[7] * b[4]\n+\tldr\tr14, [r2, #3*4]   \t\t@ b[3]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[8] * b[4]\n+\tldr\tr0, [r1, #9*4]   \t\t@ a[9]\n+\tumlal\tr5, r6, r7, r14   \t\t@ d += a[8] * b[3]\n+\tldr\tr8, [r2, #2*4]   \t\t@ b[2]\n+\tumlal\tr9, r10, r0, r14   \t\t@ d' += a[9] * b[3]\n+\tumlal\tr5, r6, r0, r8   \t\t@ d += a[9] * b[2]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u1 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u1 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t1 = c & M\n+\tstr\tr14, [sp, #4 + 1*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u1 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* D */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u2 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u2 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t2 = c & M\n+\tstr\tr14, [sp, #4 + 2*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u2 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* E - interleaved with F */\n+\tldr\tr7, [r1, #0*4]   \t\t@ a[0]\n+\tldr\tr8, [r2, #4*4]   \t\t@ b[4]\n+\tumull\tr11, r12, r7, r8   \t\t@ c' = a[0] * b[4]\n+\tldr\tr8, [r2, #3*4]   \t\t@ b[3]\n+\tumlal   r3, r4, r7, r8   \t\t@ c += a[0] * b[3]\n+\tldr\tr7, [r1, #1*4]   \t\t@ a[1]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[1] * b[3]\n+\tldr\tr8, [r2, #2*4]   \t\t@ b[2]\n+\tumlal   r3, r4, r7, r8   \t\t@ c += a[1] * b[2]\n+\tldr\tr7, [r1, #2*4]   \t\t@ a[2]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[2] * b[2]\n+\tldr\tr8, [r2, #1*4]   \t\t@ b[1]\n+\tumlal   r3, r4, r7, r8   \t\t@ c += a[2] * b[1]\n+\tldr\tr7, [r1, #3*4]   \t\t@ a[3]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[3] * b[1]\n+\tldr\tr8, [r2, #0*4]   \t\t@ b[0]\n+\tumlal   r3, r4, r7, r8   \t\t@ c += a[3] * b[0]\n+\tldr\tr7, [r1, #4*4]   \t\t@ a[4]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[4] * b[0]\n+\tldr\tr8, [r2, #9*4]   \t\t@ b[9]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[4] * b[9]\n+\tldr\tr7, [r1, #5*4]   \t\t@ a[5]\n+\tumull\tr9, r10, r7, r8   \t\t@ d' = a[5] * b[9]\n+\tldr\tr8, [r2, #8*4]   \t\t@ b[8]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[5] * b[8]\n+\tldr\tr7, [r1, #6*4]   \t\t@ a[6]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[6] * b[8]\n+\tldr\tr8, [r2, #7*4]   \t\t@ b[7]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[6] * b[7]\n+\tldr\tr7, [r1, #7*4]   \t\t@ a[7]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[7] * b[7]\n+\tldr\tr8, [r2, #6*4]   \t\t@ b[6]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[7] * b[6]\n+\tldr\tr7, [r1, #8*4]   \t\t@ a[8]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[8] * b[6]\n+\tldr\tr8, [r2, #5*4]   \t\t@ b[5]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[8] * b[5]\n+\tldr\tr7, [r1, #9*4]   \t\t@ a[9]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[9] * b[5]\n+\tldr\tr8, [r2, #4*4]   \t\t@ b[4]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[9] * b[4]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u3 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u3 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t3 = c & M\n+\tstr\tr14, [sp, #4 + 3*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u3 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* F */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u4 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u4 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t4 = c & M\n+\tstr\tr14, [sp, #4 + 4*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u4 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* G - interleaved with H */\n+\tldr\tr7, [r1, #0*4]   \t\t@ a[0]\n+\tldr\tr8, [r2, #6*4]   \t\t@ b[6]\n+\tldr\tr14, [r2, #5*4]   \t\t@ b[5]\n+\tumull\tr11, r12, r7, r8   \t\t@ c' = a[0] * b[6]\n+\tldr\tr0, [r1, #1*4]   \t\t@ a[1]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[0] * b[5]\n+\tldr\tr8, [r2, #4*4]   \t\t@ b[4]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[1] * b[5]\n+\tldr\tr7, [r1, #2*4]   \t\t@ a[2]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[1] * b[4]\n+\tldr\tr14, [r2, #3*4]   \t\t@ b[3]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[2] * b[4]\n+\tldr\tr0, [r1, #3*4]   \t\t@ a[3]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[2] * b[3]\n+\tldr\tr8, [r2, #2*4]   \t\t@ b[2]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[3] * b[3]\n+\tldr\tr7, [r1, #4*4]   \t\t@ a[4]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[3] * b[2]\n+\tldr\tr14, [r2, #1*4]   \t\t@ b[1]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[4] * b[2]\n+\tldr\tr0, [r1, #5*4]   \t\t@ a[5]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[4] * b[1]\n+\tldr\tr8, [r2, #0*4]   \t\t@ b[0]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[5] * b[1]\n+\tldr\tr7, [r1, #6*4]   \t\t@ a[6]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[5] * b[0]\n+\tldr\tr14, [r2, #9*4]   \t\t@ b[9]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[6] * b[0]\n+\tldr\tr0, [r1, #7*4]   \t\t@ a[7]\n+\tumlal\tr5, r6, r7, r14   \t\t@ d += a[6] * b[9]\n+\tldr\tr8, [r2, #8*4]   \t\t@ b[8]\n+\tumull\tr9, r10, r0, r14   \t\t@ d' = a[7] * b[9]\n+\tldr\tr7, [r1, #8*4]   \t\t@ a[8]\n+\tumlal\tr5, r6, r0, r8   \t\t@ d += a[7] * b[8]\n+\tldr\tr14, [r2, #7*4]   \t\t@ b[7]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[8] * b[8]\n+\tldr\tr0, [r1, #9*4]   \t\t@ a[9]\n+\tumlal\tr5, r6, r7, r14   \t\t@ d += a[8] * b[7]\n+\tldr\tr8, [r2, #6*4]   \t\t@ b[6]\n+\tumlal\tr9, r10, r0, r14   \t\t@ d' += a[9] * b[7]\n+\tumlal\tr5, r6, r0, r8   \t\t@ d += a[9] * b[6]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u5 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u5 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t5 = c & M\n+\tstr\tr14, [sp, #4 + 5*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u5 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* H */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u6 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u6 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t6 = c & M\n+\tstr\tr14, [sp, #4 + 6*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u6 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* I - interleaved with J */\n+\tldr\tr8, [r2, #8*4]   \t\t@ b[8]\n+\tldr\tr7, [r1, #0*4]   \t\t@ a[0]\n+\tldr\tr14, [r2, #7*4]   \t\t@ b[7]\n+\tumull   r11, r12, r7, r8   \t\t@ c' = a[0] * b[8]\n+\tldr\tr0, [r1, #1*4]   \t\t@ a[1]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[0] * b[7]\n+\tldr\tr8, [r2, #6*4]   \t\t@ b[6]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[1] * b[7]\n+\tldr\tr7, [r1, #2*4]   \t\t@ a[2]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[1] * b[6]\n+\tldr\tr14, [r2, #5*4]   \t\t@ b[5]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[2] * b[6]\n+\tldr\tr0, [r1, #3*4]   \t\t@ a[3]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[2] * b[5]\n+\tldr\tr8, [r2, #4*4]   \t\t@ b[4]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[3] * b[5]\n+\tldr\tr7, [r1, #4*4]   \t\t@ a[4]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[3] * b[4]\n+\tldr\tr14, [r2, #3*4]   \t\t@ b[3]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[4] * b[4]\n+\tldr\tr0, [r1, #5*4]   \t\t@ a[5]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[4] * b[3]\n+\tldr\tr8, [r2, #2*4]   \t\t@ b[2]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[5] * b[3]\n+\tldr\tr7, [r1, #6*4]   \t\t@ a[6]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[5] * b[2]\n+\tldr\tr14, [r2, #1*4]   \t\t@ b[1]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[6] * b[2]\n+\tldr\tr0, [r1, #7*4]   \t\t@ a[7]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[6] * b[1]\n+\tldr\tr8, [r2, #0*4]   \t\t@ b[0]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[7] * b[1]\n+\tldr\tr7, [r1, #8*4]   \t\t@ a[8]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[7] * b[0]\n+\tldr\tr14, [r2, #9*4]   \t\t@ b[9]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[8] * b[0]\n+\tldr\tr0, [r1, #9*4]   \t\t@ a[9]\n+\tumlal\tr5, r6, r7, r14   \t\t@ d += a[8] * b[9]\n+\tldr\tr8, [r2, #8*4]   \t\t@ b[8]\n+\tumull\tr9, r10, r0, r14  \t\t@ d' = a[9] * b[9]\n+\tumlal\tr5, r6, r0, r8   \t\t@ d += a[9] * b[8]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u7 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u7 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t7 = c & M\n+\tstr\tr14, [sp, #4 + 7*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u7 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* J */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u8 = d & M\n+\tstr\tr0, [sp, #4 + 8*4]\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u8 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\t/******************************************\n+\t * compute and write back result\n+\t ******************************************\n+\tAllocation:\n+\t    r0    r\n+\t    r3:r4 c\n+\t    r5:r6 d\n+\t    r7    t0\n+\t    r8    t1\n+\t    r9    t2\n+\t    r11   u8\n+\t    r12   t9\n+\t    r1,r2,r10,r14 scratch\n+\n+\tNote: do not read from a[] after here, it may overlap with r[]\n+\t*/\n+\tldr\tr0, [sp, #0]\n+\tadd\tr1, sp, #4 + 3*4\t\t@ r[3..7] = t3..7, r11=u8, r12=t9\n+\tldmia\tr1, {r2,r7,r8,r9,r10,r11,r12}\n+\tadd\tr1, r0, #3*4\n+\tstmia\tr1, {r2,r7,r8,r9,r10}\n+\n+\tbic\tr2, r3, field_not_M \t\t@ r[8] = c & M\n+\tstr\tr2, [r0, #8*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u8 * R1\n+\tumlal   r3, r4, r11, r14\n+\tmovw    r14, field_R0\t\t\t@ c += d * R0\n+\tumlal   r3, r4, r5, r14\n+\tadds\tr3, r3, r12\t\t\t@ c += t9\n+\tadc\tr4, r4, #0\n+\n+\tadd\tr1, sp, #4 + 0*4\t\t@ r7,r8,r9 = t0,t1,t2\n+\tldmia\tr1, {r7,r8,r9}\n+\n+\tubfx\tr2, r3, #0, #22     \t\t@ r[9] = c & (M >> 4)\n+\tstr\tr2, [r0, #9*4]\n+\tmov\tr3, r3, lsr #22     \t\t@ c >>= 22\n+\torr\tr3, r3, r4, asl #10\n+\tmov     r4, r4, lsr #22\n+\tmovw    r14, field_R1 << 4   \t\t@ c += d * (R1 << 4)\n+\tumlal   r3, r4, r5, r14\n+\n+\tmovw    r14, field_R0 >> 4   \t\t@ d = c * (R0 >> 4) + t0 (64x64 multiply+add)\n+\tumull\tr5, r6, r3, r14\t\t\t@ d = c.lo * (R0 >> 4)\n+\tadds\tr5, r5, r7\t    \t\t@ d.lo += t0\n+\tmla\tr6, r14, r4, r6\t\t\t@ d.hi += c.hi * (R0 >> 4)\n+\tadc\tr6, r6, 0\t     \t\t@ d.hi += carry\n+\n+\tbic\tr2, r5, field_not_M \t\t@ r[0] = d & M\n+\tstr\tr2, [r0, #0*4]\n+\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\t\n+\tmovw    r14, field_R1 >> 4   \t\t@ d += c * (R1 >> 4) + t1 (64x64 multiply+add)\n+\tumull\tr1, r2, r3, r14       \t\t@ tmp = c.lo * (R1 >> 4)\n+\tadds\tr5, r5, r8\t    \t\t@ d.lo += t1\n+\tadc\tr6, r6, #0\t    \t\t@ d.hi += carry\n+\tadds\tr5, r5, r1\t    \t\t@ d.lo += tmp.lo\n+\tmla\tr2, r14, r4, r2      \t\t@ tmp.hi += c.hi * (R1 >> 4)\n+\tadc\tr6, r6, r2\t   \t\t@ d.hi += carry + tmp.hi\n+\n+\tbic\tr2, r5, field_not_M \t\t@ r[1] = d & M\n+\tstr\tr2, [r0, #1*4]\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26 (ignore hi)\n+\torr\tr5, r5, r6, asl #6\n+\n+\tadd\tr5, r5, r9\t  \t\t@ d += t2\n+\tstr\tr5, [r0, #2*4]      \t\t@ r[2] = d\n+\n+\tadd\tsp, sp, #48\n+\tldmfd\tsp!, {r4, r5, r6, r7, r8, r9, r10, r11, pc}\n+\t.size\tsecp256k1_fe_mul_inner, .-secp256k1_fe_mul_inner\n+\n+\t.align\t2\n+\t.global secp256k1_fe_sqr_inner\n+\t.type\tsecp256k1_fe_sqr_inner, %function\n+\t@ Arguments:\n+\t@  r0  r\t Can overlap with a\n+\t@  r1  a\n+\t@ Stack (total 4+10*4 = 44)\n+\t@  sp + #0        saved 'r' pointer\n+\t@  sp + #4 + 4*X  t0,t1,t2,t3,t4,t5,t6,t7,u8,t9\n+secp256k1_fe_sqr_inner:\n+\tstmfd\tsp!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}\n+\tsub\tsp, sp, #48\t\t\t@ frame=44 + alignment\n+\tstr     r0, [sp, #0]\t\t\t@ save result address, we need it only at the end\n+\t/******************************************\n+\t * Main computation code.\n+\t ******************************************\n+\n+\tAllocation:\n+\t    r0,r14,r2,r7,r8   scratch\n+\t    r1       a (pointer)\n+\t    r3:r4    c\n+\t    r5:r6    d\n+\t    r11:r12  c'\n+\t    r9:r10   d'\n+\n+\tNote: do not write to r[] here, it may overlap with a[]\n+\t*/\n+\t/* A interleaved with B */\n+\tldr\tr0, [r1, #1*4]\t\t\t@ a[1]*2\n+\tldr\tr7, [r1, #0*4]\t\t\t@ a[0]\n+\tmov\tr0, r0, asl #1\n+\tldr\tr14, [r1, #9*4]\t\t\t@ a[9]\n+\tumull\tr3, r4, r7, r7\t\t\t@ c = a[0] * a[0]\n+\tldr\tr8, [r1, #8*4]\t\t\t@ a[8]\n+\tmov\tr7, r7, asl #1\n+\tumull\tr5, r6, r7, r14\t\t\t@ d = a[0]*2 * a[9]\n+\tldr\tr7, [r1, #2*4]\t\t\t@ a[2]*2\n+\tumull\tr9, r10, r0, r14\t\t@ d' = a[1]*2 * a[9]\n+\tldr\tr14, [r1, #7*4]\t\t\t@ a[7]\n+\tumlal\tr5, r6, r0, r8\t\t\t@ d += a[1]*2 * a[8]\n+\tmov\tr7, r7, asl #1\n+\tldr\tr0, [r1, #3*4]\t\t\t@ a[3]*2\n+\tumlal\tr9, r10, r7, r8\t\t\t@ d' += a[2]*2 * a[8]\n+\tldr\tr8, [r1, #6*4]\t\t\t@ a[6]\n+\tumlal\tr5, r6, r7, r14\t\t\t@ d += a[2]*2 * a[7]\n+\tmov\tr0, r0, asl #1\n+\tldr\tr7, [r1, #4*4]\t\t\t@ a[4]*2\n+\tumlal\tr9, r10, r0, r14\t\t@ d' += a[3]*2 * a[7]\n+\tldr\tr14, [r1, #5*4]\t\t\t@ a[5]\n+\tmov\tr7, r7, asl #1\n+\tumlal\tr5, r6, r0, r8\t\t\t@ d += a[3]*2 * a[6]\n+\tumlal\tr9, r10, r7, r8\t\t\t@ d' += a[4]*2 * a[6]\n+\tumlal\tr5, r6, r7, r14\t\t\t@ d += a[4]*2 * a[5]\n+\tumlal\tr9, r10, r14, r14\t\t@ d' += a[5] * a[5]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ t9 = d & M\n+\tstr     r0, [sp, #4 + 9*4]\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26 \n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\n+\t/* B */\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u0 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u0 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t0 = c & M\n+\tstr\tr14, [sp, #4 + 0*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u0 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* C interleaved with D */\n+\tldr\tr0, [r1, #0*4]\t\t\t@ a[0]*2\n+\tldr\tr14, [r1, #1*4]\t\t\t@ a[1]\n+\tmov\tr0, r0, asl #1\n+\tldr\tr8, [r1, #2*4]\t\t\t@ a[2]\n+\tumlal\tr3, r4, r0, r14\t\t\t@ c += a[0]*2 * a[1]\n+\tmov\tr7, r8, asl #1                  @ a[2]*2\n+\tumull\tr11, r12, r14, r14\t\t@ c' = a[1] * a[1]\n+\tldr\tr14, [r1, #9*4]\t\t\t@ a[9]\n+\tumlal\tr11, r12, r0, r8\t\t@ c' += a[0]*2 * a[2]\n+\tldr\tr0, [r1, #3*4]\t\t\t@ a[3]*2\n+\tldr\tr8, [r1, #8*4]\t\t\t@ a[8]\n+\tumlal\tr5, r6, r7, r14\t\t\t@ d += a[2]*2 * a[9]\n+\tmov\tr0, r0, asl #1\n+\tldr\tr7, [r1, #4*4]\t\t\t@ a[4]*2\n+\tumull\tr9, r10, r0, r14\t\t@ d' = a[3]*2 * a[9]\n+\tldr\tr14, [r1, #7*4]\t\t\t@ a[7]\n+\tumlal\tr5, r6, r0, r8\t\t\t@ d += a[3]*2 * a[8]\n+\tmov\tr7, r7, asl #1\n+\tldr\tr0, [r1, #5*4]\t\t\t@ a[5]*2\n+\tumlal\tr9, r10, r7, r8\t\t\t@ d' += a[4]*2 * a[8]\n+\tldr\tr8, [r1, #6*4]\t\t\t@ a[6]\n+\tmov\tr0, r0, asl #1\n+\tumlal\tr5, r6, r7, r14\t\t\t@ d += a[4]*2 * a[7]\n+\tumlal\tr9, r10, r0, r14\t\t@ d' += a[5]*2 * a[7]\n+\tumlal\tr5, r6, r0, r8\t\t\t@ d += a[5]*2 * a[6]\n+\tumlal\tr9, r10, r8, r8\t\t\t@ d' += a[6] * a[6]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u1 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u1 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t1 = c & M\n+\tstr\tr14, [sp, #4 + 1*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u1 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* D */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u2 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u2 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t2 = c & M\n+\tstr\tr14, [sp, #4 + 2*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u2 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* E interleaved with F */\n+\tldr\tr7, [r1, #0*4]\t\t\t@ a[0]*2\n+\tldr\tr0, [r1, #1*4]\t\t\t@ a[1]*2\n+\tldr\tr14, [r1, #2*4]\t\t\t@ a[2]\n+\tmov\tr7, r7, asl #1\n+\tldr\tr8, [r1, #3*4]\t\t\t@ a[3]\n+\tldr\tr2, [r1, #4*4]\n+\tumlal\tr3, r4, r7, r8\t\t\t@ c += a[0]*2 * a[3]\n+\tmov\tr0, r0, asl #1\n+\tumull\tr11, r12, r7, r2\t\t@ c' = a[0]*2 * a[4]\n+\tmov\tr2, r2, asl #1\t\t\t@ a[4]*2\n+\tumlal\tr11, r12, r0, r8\t\t@ c' += a[1]*2 * a[3]\n+\tldr\tr8, [r1, #9*4]\t\t\t@ a[9]\n+\tumlal\tr3, r4, r0, r14\t\t\t@ c += a[1]*2 * a[2]\n+\tldr\tr0, [r1, #5*4]\t\t\t@ a[5]*2\n+\tumlal\tr11, r12, r14, r14\t\t@ c' += a[2] * a[2]\n+\tldr\tr14, [r1, #8*4]\t\t\t@ a[8]\n+\tmov\tr0, r0, asl #1\n+\tumlal\tr5, r6, r2, r8\t\t\t@ d += a[4]*2 * a[9]\n+\tldr\tr7, [r1, #6*4]\t\t\t@ a[6]*2\n+\tumull\tr9, r10, r0, r8\t\t\t@ d' = a[5]*2 * a[9]\n+\tmov\tr7, r7, asl #1\n+\tldr\tr8, [r1, #7*4]\t\t\t@ a[7]\n+\tumlal\tr5, r6, r0, r14\t\t\t@ d += a[5]*2 * a[8]\n+\tumlal\tr9, r10, r7, r14\t\t@ d' += a[6]*2 * a[8]\n+\tumlal\tr5, r6, r7, r8\t\t\t@ d += a[6]*2 * a[7]\n+\tumlal\tr9, r10, r8, r8\t\t\t@ d' += a[7] * a[7]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u3 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u3 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t3 = c & M\n+\tstr\tr14, [sp, #4 + 3*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u3 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* F */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u4 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u4 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t4 = c & M\n+\tstr\tr14, [sp, #4 + 4*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u4 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* G interleaved with H */\n+\tldr\tr7, [r1, #0*4]\t\t\t@ a[0]*2\n+\tldr\tr0, [r1, #1*4]\t\t\t@ a[1]*2\n+\tmov\tr7, r7, asl #1\n+\tldr\tr8, [r1, #5*4]\t\t\t@ a[5]\n+\tldr\tr2, [r1, #6*4]\t\t\t@ a[6]\n+\tumlal\tr3, r4, r7, r8\t\t\t@ c += a[0]*2 * a[5]\n+\tldr\tr14, [r1, #4*4]\t\t\t@ a[4]\n+\tmov\tr0, r0, asl #1\n+\tumull\tr11, r12, r7, r2\t\t@ c' = a[0]*2 * a[6]\n+\tldr\tr7, [r1, #2*4]\t\t\t@ a[2]*2\n+\tumlal\tr11, r12, r0, r8\t\t@ c' += a[1]*2 * a[5]\n+\tmov\tr7, r7, asl #1\n+\tldr\tr8, [r1, #3*4]\t\t\t@ a[3]\n+\tumlal\tr3, r4, r0, r14\t\t\t@ c += a[1]*2 * a[4]\n+\tmov\tr0, r2, asl #1\t\t\t@ a[6]*2\n+\tumlal\tr11, r12, r7, r14\t\t@ c' += a[2]*2 * a[4]\n+\tldr\tr14, [r1, #9*4]\t\t\t@ a[9]\n+\tumlal\tr3, r4, r7, r8\t\t\t@ c += a[2]*2 * a[3]\n+\tldr\tr7, [r1, #7*4]\t\t\t@ a[7]*2\n+\tumlal\tr11, r12, r8, r8\t\t@ c' += a[3] * a[3]\n+\tmov\tr7, r7, asl #1\n+\tldr\tr8, [r1, #8*4]\t\t\t@ a[8]\n+\tumlal\tr5, r6, r0, r14\t\t\t@ d += a[6]*2 * a[9]\n+\tumull\tr9, r10, r7, r14\t\t@ d' = a[7]*2 * a[9]\n+\tumlal\tr5, r6, r7, r8\t\t\t@ d += a[7]*2 * a[8]\n+\tumlal\tr9, r10, r8, r8\t\t\t@ d' += a[8] * a[8]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u5 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u5 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t5 = c & M\n+\tstr\tr14, [sp, #4 + 5*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u5 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* H */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u6 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u6 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t6 = c & M\n+\tstr\tr14, [sp, #4 + 6*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u6 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* I interleaved with J */\n+\tldr\tr7, [r1, #0*4]\t\t\t@ a[0]*2\n+\tldr\tr0, [r1, #1*4]\t\t\t@ a[1]*2\n+\tmov\tr7, r7, asl #1\n+\tldr\tr8, [r1, #7*4]\t\t\t@ a[7]\n+\tldr\tr2, [r1, #8*4]\t\t\t@ a[8]\n+\tumlal\tr3, r4, r7, r8\t\t\t@ c += a[0]*2 * a[7]\n+\tldr\tr14, [r1, #6*4]\t\t\t@ a[6]\n+\tmov\tr0, r0, asl #1\n+\tumull\tr11, r12, r7, r2\t\t@ c' = a[0]*2 * a[8]\n+\tldr\tr7, [r1, #2*4]\t\t\t@ a[2]*2\n+\tumlal\tr11, r12, r0, r8\t\t@ c' += a[1]*2 * a[7]\n+\tldr\tr8, [r1, #5*4]\t\t\t@ a[5]\n+\tumlal\tr3, r4, r0, r14\t\t\t@ c += a[1]*2 * a[6]\n+\tldr\tr0, [r1, #3*4]\t\t\t@ a[3]*2\n+\tmov\tr7, r7, asl #1\n+\tumlal\tr11, r12, r7, r14\t\t@ c' += a[2]*2 * a[6]\n+\tldr\tr14, [r1, #4*4]\t\t\t@ a[4]\n+\tmov\tr0, r0, asl #1\n+\tumlal\tr3, r4, r7, r8\t\t\t@ c += a[2]*2 * a[5]\n+\tmov\tr2, r2, asl #1\t\t\t@ a[8]*2\n+\tumlal\tr11, r12, r0, r8\t\t@ c' += a[3]*2 * a[5]\n+\tumlal\tr3, r4, r0, r14\t\t\t@ c += a[3]*2 * a[4]\n+\tumlal\tr11, r12, r14, r14\t\t@ c' += a[4] * a[4]\n+\tldr\tr8, [r1, #9*4]\t\t\t@ a[9]\n+\tumlal\tr5, r6, r2, r8\t\t\t@ d += a[8]*2 * a[9]\n+\t@ r8 will be used in J\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u7 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u7 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t7 = c & M\n+\tstr\tr14, [sp, #4 + 7*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u7 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* J */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tumlal\tr5, r6, r8, r8\t\t\t@ d += a[9] * a[9]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u8 = d & M\n+\tstr\tr0, [sp, #4 + 8*4]\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u8 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\t/******************************************\n+\t * compute and write back result\n+\t ******************************************\n+\tAllocation:\n+\t    r0    r\n+\t    r3:r4 c\n+\t    r5:r6 d\n+\t    r7    t0\n+\t    r8    t1\n+\t    r9    t2\n+\t    r11   u8\n+\t    r12   t9\n+\t    r1,r2,r10,r14 scratch\n+\n+\tNote: do not read from a[] after here, it may overlap with r[]\n+\t*/\n+\tldr\tr0, [sp, #0]\n+\tadd\tr1, sp, #4 + 3*4\t\t@ r[3..7] = t3..7, r11=u8, r12=t9\n+\tldmia\tr1, {r2,r7,r8,r9,r10,r11,r12}\n+\tadd\tr1, r0, #3*4\n+\tstmia\tr1, {r2,r7,r8,r9,r10}\n+\n+\tbic\tr2, r3, field_not_M \t\t@ r[8] = c & M\n+\tstr\tr2, [r0, #8*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u8 * R1\n+\tumlal   r3, r4, r11, r14\n+\tmovw    r14, field_R0\t\t\t@ c += d * R0\n+\tumlal   r3, r4, r5, r14\n+\tadds\tr3, r3, r12\t\t\t@ c += t9\n+\tadc\tr4, r4, #0\n+\n+\tadd\tr1, sp, #4 + 0*4\t\t@ r7,r8,r9 = t0,t1,t2\n+\tldmia\tr1, {r7,r8,r9}\n+\n+\tubfx\tr2, r3, #0, #22     \t\t@ r[9] = c & (M >> 4)\n+\tstr\tr2, [r0, #9*4]\n+\tmov\tr3, r3, lsr #22     \t\t@ c >>= 22\n+\torr\tr3, r3, r4, asl #10\n+\tmov     r4, r4, lsr #22\n+\tmovw    r14, field_R1 << 4   \t\t@ c += d * (R1 << 4)\n+\tumlal   r3, r4, r5, r14\n+\n+\tmovw    r14, field_R0 >> 4   \t\t@ d = c * (R0 >> 4) + t0 (64x64 multiply+add)\n+\tumull\tr5, r6, r3, r14\t\t\t@ d = c.lo * (R0 >> 4)\n+\tadds\tr5, r5, r7\t    \t\t@ d.lo += t0\n+\tmla\tr6, r14, r4, r6\t\t\t@ d.hi += c.hi * (R0 >> 4)\n+\tadc\tr6, r6, 0\t     \t\t@ d.hi += carry\n+\n+\tbic\tr2, r5, field_not_M \t\t@ r[0] = d & M\n+\tstr\tr2, [r0, #0*4]\n+\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\t\n+\tmovw    r14, field_R1 >> 4   \t\t@ d += c * (R1 >> 4) + t1 (64x64 multiply+add)\n+\tumull\tr1, r2, r3, r14       \t\t@ tmp = c.lo * (R1 >> 4)\n+\tadds\tr5, r5, r8\t    \t\t@ d.lo += t1\n+\tadc\tr6, r6, #0\t    \t\t@ d.hi += carry\n+\tadds\tr5, r5, r1\t    \t\t@ d.lo += tmp.lo\n+\tmla\tr2, r14, r4, r2      \t\t@ tmp.hi += c.hi * (R1 >> 4)\n+\tadc\tr6, r6, r2\t   \t\t@ d.hi += carry + tmp.hi\n+\n+\tbic\tr2, r5, field_not_M \t\t@ r[1] = d & M\n+\tstr\tr2, [r0, #1*4]\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26 (ignore hi)\n+\torr\tr5, r5, r6, asl #6\n+\n+\tadd\tr5, r5, r9\t  \t\t@ d += t2\n+\tstr\tr5, [r0, #2*4]      \t\t@ r[2] = d\n+\n+\tadd\tsp, sp, #48\n+\tldmfd\tsp!, {r4, r5, r6, r7, r8, r9, r10, r11, pc}\n+\t.size\tsecp256k1_fe_sqr_inner, .-secp256k1_fe_sqr_inner\n+"
      },
      {
        "sha": "cde5e2dbb4e4ea1bd4fedced7ba1fecea7de8aa1",
        "filename": "src/bench_ecdh.c",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/bench_ecdh.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/bench_ecdh.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_ecdh.c?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -28,7 +28,8 @@ static void bench_ecdh_setup(void* arg) {\n         0xa2, 0xba, 0xd1, 0x84, 0xf8, 0x83, 0xc6, 0x9f\n     };\n \n-    data->ctx = secp256k1_context_create(0);\n+    /* create a context with no capabilities */\n+    data->ctx = secp256k1_context_create(SECP256K1_FLAGS_TYPE_CONTEXT);\n     for (i = 0; i < 32; i++) {\n         data->scalar[i] = i + 1;\n     }"
      },
      {
        "sha": "0809f77bda108dacd5a9a2c6208827c985f00f54",
        "filename": "src/bench_internal.c",
        "status": "modified",
        "additions": 31,
        "deletions": 3,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/bench_internal.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/bench_internal.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_internal.c?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -181,12 +181,12 @@ void bench_field_inverse_var(void* arg) {\n     }\n }\n \n-void bench_field_sqrt_var(void* arg) {\n+void bench_field_sqrt(void* arg) {\n     int i;\n     bench_inv_t *data = (bench_inv_t*)arg;\n \n     for (i = 0; i < 20000; i++) {\n-        secp256k1_fe_sqrt_var(&data->fe_x, &data->fe_x);\n+        secp256k1_fe_sqrt(&data->fe_x, &data->fe_x);\n         secp256k1_fe_add(&data->fe_x, &data->fe_y);\n     }\n }\n@@ -227,6 +227,15 @@ void bench_group_add_affine_var(void* arg) {\n     }\n }\n \n+void bench_group_jacobi_var(void* arg) {\n+    int i;\n+    bench_inv_t *data = (bench_inv_t*)arg;\n+\n+    for (i = 0; i < 20000; i++) {\n+        secp256k1_gej_has_quad_y_var(&data->gej_x);\n+    }\n+}\n+\n void bench_ecmult_wnaf(void* arg) {\n     int i;\n     bench_inv_t *data = (bench_inv_t*)arg;\n@@ -299,6 +308,21 @@ void bench_context_sign(void* arg) {\n     }\n }\n \n+#ifndef USE_NUM_NONE\n+void bench_num_jacobi(void* arg) {\n+    int i;\n+    bench_inv_t *data = (bench_inv_t*)arg;\n+    secp256k1_num nx, norder;\n+\n+    secp256k1_scalar_get_num(&nx, &data->scalar_x);\n+    secp256k1_scalar_order_get_num(&norder);\n+    secp256k1_scalar_get_num(&norder, &data->scalar_y);\n+\n+    for (i = 0; i < 200000; i++) {\n+        secp256k1_num_jacobi(&nx, &norder);\n+    }\n+}\n+#endif\n \n int have_flag(int argc, char** argv, char *flag) {\n     char** argm = argv + argc;\n@@ -333,12 +357,13 @@ int main(int argc, char **argv) {\n     if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"mul\")) run_benchmark(\"field_mul\", bench_field_mul, bench_setup, NULL, &data, 10, 200000);\n     if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"field_inverse\", bench_field_inverse, bench_setup, NULL, &data, 10, 20000);\n     if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"field_inverse_var\", bench_field_inverse_var, bench_setup, NULL, &data, 10, 20000);\n-    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"sqrt\")) run_benchmark(\"field_sqrt_var\", bench_field_sqrt_var, bench_setup, NULL, &data, 10, 20000);\n+    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"sqrt\")) run_benchmark(\"field_sqrt\", bench_field_sqrt, bench_setup, NULL, &data, 10, 20000);\n \n     if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"double\")) run_benchmark(\"group_double_var\", bench_group_double_var, bench_setup, NULL, &data, 10, 200000);\n     if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_var\", bench_group_add_var, bench_setup, NULL, &data, 10, 200000);\n     if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_affine\", bench_group_add_affine, bench_setup, NULL, &data, 10, 200000);\n     if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_affine_var\", bench_group_add_affine_var, bench_setup, NULL, &data, 10, 200000);\n+    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"jacobi\")) run_benchmark(\"group_jacobi_var\", bench_group_jacobi_var, bench_setup, NULL, &data, 10, 20000);\n \n     if (have_flag(argc, argv, \"ecmult\") || have_flag(argc, argv, \"wnaf\")) run_benchmark(\"wnaf_const\", bench_wnaf_const, bench_setup, NULL, &data, 10, 20000);\n     if (have_flag(argc, argv, \"ecmult\") || have_flag(argc, argv, \"wnaf\")) run_benchmark(\"ecmult_wnaf\", bench_ecmult_wnaf, bench_setup, NULL, &data, 10, 20000);\n@@ -350,5 +375,8 @@ int main(int argc, char **argv) {\n     if (have_flag(argc, argv, \"context\") || have_flag(argc, argv, \"verify\")) run_benchmark(\"context_verify\", bench_context_verify, bench_setup, NULL, &data, 10, 20);\n     if (have_flag(argc, argv, \"context\") || have_flag(argc, argv, \"sign\")) run_benchmark(\"context_sign\", bench_context_sign, bench_setup, NULL, &data, 10, 200);\n \n+#ifndef USE_NUM_NONE\n+    if (have_flag(argc, argv, \"num\") || have_flag(argc, argv, \"jacobi\")) run_benchmark(\"num_jacobi\", bench_num_jacobi, bench_setup, NULL, &data, 10, 200000);\n+#endif\n     return 0;\n }"
      },
      {
        "sha": "418defa0aa22a06dff07d3f1567e205235706976",
        "filename": "src/bench_verify.c",
        "status": "modified",
        "additions": 44,
        "deletions": 0,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/bench_verify.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/bench_verify.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_verify.c?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -11,6 +11,12 @@\n #include \"util.h\"\n #include \"bench.h\"\n \n+#ifdef ENABLE_OPENSSL_TESTS\n+#include <openssl/bn.h>\n+#include <openssl/ecdsa.h>\n+#include <openssl/obj_mac.h>\n+#endif\n+\n typedef struct {\n     secp256k1_context *ctx;\n     unsigned char msg[32];\n@@ -19,6 +25,9 @@ typedef struct {\n     size_t siglen;\n     unsigned char pubkey[33];\n     size_t pubkeylen;\n+#ifdef ENABLE_OPENSSL_TESTS\n+    EC_GROUP* ec_group;\n+#endif\n } benchmark_verify_t;\n \n static void benchmark_verify(void* arg) {\n@@ -40,6 +49,36 @@ static void benchmark_verify(void* arg) {\n     }\n }\n \n+#ifdef ENABLE_OPENSSL_TESTS\n+static void benchmark_verify_openssl(void* arg) {\n+    int i;\n+    benchmark_verify_t* data = (benchmark_verify_t*)arg;\n+\n+    for (i = 0; i < 20000; i++) {\n+        data->sig[data->siglen - 1] ^= (i & 0xFF);\n+        data->sig[data->siglen - 2] ^= ((i >> 8) & 0xFF);\n+        data->sig[data->siglen - 3] ^= ((i >> 16) & 0xFF);\n+        {\n+            EC_KEY *pkey = EC_KEY_new();\n+            const unsigned char *pubkey = &data->pubkey[0];\n+            int result;\n+\n+            CHECK(pkey != NULL);\n+            result = EC_KEY_set_group(pkey, data->ec_group);\n+            CHECK(result);\n+            result = (o2i_ECPublicKey(&pkey, &pubkey, data->pubkeylen)) != NULL;\n+            CHECK(result);\n+            result = ECDSA_verify(0, &data->msg[0], sizeof(data->msg), &data->sig[0], data->siglen, pkey) == (i == 0);\n+            CHECK(result);\n+            EC_KEY_free(pkey);\n+        }\n+        data->sig[data->siglen - 1] ^= (i & 0xFF);\n+        data->sig[data->siglen - 2] ^= ((i >> 8) & 0xFF);\n+        data->sig[data->siglen - 3] ^= ((i >> 16) & 0xFF);\n+    }\n+}\n+#endif\n+\n int main(void) {\n     int i;\n     secp256k1_pubkey pubkey;\n@@ -62,6 +101,11 @@ int main(void) {\n     CHECK(secp256k1_ec_pubkey_serialize(data.ctx, data.pubkey, &data.pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED) == 1);\n \n     run_benchmark(\"ecdsa_verify\", benchmark_verify, NULL, NULL, &data, 10, 20000);\n+#ifdef ENABLE_OPENSSL_TESTS\n+    data.ec_group = EC_GROUP_new_by_curve_name(NID_secp256k1);\n+    run_benchmark(\"ecdsa_verify_openssl\", benchmark_verify_openssl, NULL, NULL, &data, 10, 20000);\n+    EC_GROUP_free(data.ec_group);\n+#endif\n \n     secp256k1_context_destroy(data.ctx);\n     return 0;"
      },
      {
        "sha": "9a42e519bd580c6f505d66deec88bbed6dabecf8",
        "filename": "src/ecdsa_impl.h",
        "status": "modified",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/ecdsa_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/ecdsa_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecdsa_impl.h?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -203,7 +203,9 @@ static int secp256k1_ecdsa_sig_serialize(unsigned char *sig, size_t *size, const\n static int secp256k1_ecdsa_sig_verify(const secp256k1_ecmult_context *ctx, const secp256k1_scalar *sigr, const secp256k1_scalar *sigs, const secp256k1_ge *pubkey, const secp256k1_scalar *message) {\n     unsigned char c[32];\n     secp256k1_scalar sn, u1, u2;\n+#if !defined(EXHAUSTIVE_TEST_ORDER)\n     secp256k1_fe xr;\n+#endif\n     secp256k1_gej pubkeyj;\n     secp256k1_gej pr;\n \n@@ -219,6 +221,21 @@ static int secp256k1_ecdsa_sig_verify(const secp256k1_ecmult_context *ctx, const\n     if (secp256k1_gej_is_infinity(&pr)) {\n         return 0;\n     }\n+\n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+{\n+    secp256k1_scalar computed_r;\n+    int overflow = 0;\n+    secp256k1_ge pr_ge;\n+    secp256k1_ge_set_gej(&pr_ge, &pr);\n+    secp256k1_fe_normalize(&pr_ge.x);\n+\n+    secp256k1_fe_get_b32(c, &pr_ge.x);\n+    secp256k1_scalar_set_b32(&computed_r, c, &overflow);\n+    /* we fully expect overflow */\n+    return secp256k1_scalar_eq(sigr, &computed_r);\n+}\n+#else\n     secp256k1_scalar_get_b32(c, sigr);\n     secp256k1_fe_set_b32(&xr, c);\n \n@@ -252,6 +269,7 @@ static int secp256k1_ecdsa_sig_verify(const secp256k1_ecmult_context *ctx, const\n         return 1;\n     }\n     return 0;\n+#endif\n }\n \n static int secp256k1_ecdsa_sig_sign(const secp256k1_ecmult_gen_context *ctx, secp256k1_scalar *sigr, secp256k1_scalar *sigs, const secp256k1_scalar *seckey, const secp256k1_scalar *message, const secp256k1_scalar *nonce, int *recid) {"
      },
      {
        "sha": "0db314c48e0cdc844a89cb4a6d5b4ce4c9352578",
        "filename": "src/ecmult_const_impl.h",
        "status": "modified",
        "additions": 24,
        "deletions": 45,
        "changes": 69,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/ecmult_const_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/ecmult_const_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_const_impl.h?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -58,25 +58,27 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w) {\n     int global_sign;\n     int skew = 0;\n     int word = 0;\n+\n     /* 1 2 3 */\n     int u_last;\n     int u;\n \n-#ifdef USE_ENDOMORPHISM\n     int flip;\n     int bit;\n     secp256k1_scalar neg_s;\n     int not_neg_one;\n-    /* If we are using the endomorphism, we cannot handle even numbers by negating\n-     * them, since we are working with 128-bit numbers whose negations would be 256\n-     * bits, eliminating the performance advantage. Instead we use a technique from\n+    /* Note that we cannot handle even numbers by negating them to be odd, as is\n+     * done in other implementations, since if our scalars were specified to have\n+     * width < 256 for performance reasons, their negations would have width 256\n+     * and we'd lose any performance benefit. Instead, we use a technique from\n      * Section 4.2 of the Okeya/Tagaki paper, which is to add either 1 (for even)\n-     * or 2 (for odd) to the number we are encoding, then compensating after the\n-     * multiplication. */\n-    /* Negative 128-bit numbers will be negated, since otherwise they are 256-bit */\n+     * or 2 (for odd) to the number we are encoding, returning a skew value indicating\n+     * this, and having the caller compensate after doing the multiplication. */\n+\n+    /* Negative numbers will be negated to keep their bit representation below the maximum width */\n     flip = secp256k1_scalar_is_high(&s);\n     /* We add 1 to even numbers, 2 to odd ones, noting that negation flips parity */\n-    bit = flip ^ (s.d[0] & 1);\n+    bit = flip ^ !secp256k1_scalar_is_even(&s);\n     /* We check for negative one, since adding 2 to it will cause an overflow */\n     secp256k1_scalar_negate(&neg_s, &s);\n     not_neg_one = !secp256k1_scalar_is_one(&neg_s);\n@@ -89,11 +91,6 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w) {\n     global_sign = secp256k1_scalar_cond_negate(&s, flip);\n     global_sign *= not_neg_one * 2 - 1;\n     skew = 1 << bit;\n-#else\n-    /* Otherwise, we just negate to force oddness */\n-    int is_even = secp256k1_scalar_is_even(&s);\n-    global_sign = secp256k1_scalar_cond_negate(&s, is_even);\n-#endif\n \n     /* 4 */\n     u_last = secp256k1_scalar_shr_int(&s, w);\n@@ -127,15 +124,13 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n     secp256k1_ge tmpa;\n     secp256k1_fe Z;\n \n+    int skew_1;\n+    int wnaf_1[1 + WNAF_SIZE(WINDOW_A - 1)];\n #ifdef USE_ENDOMORPHISM\n     secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n-    int wnaf_1[1 + WNAF_SIZE(WINDOW_A - 1)];\n     int wnaf_lam[1 + WNAF_SIZE(WINDOW_A - 1)];\n-    int skew_1;\n     int skew_lam;\n     secp256k1_scalar q_1, q_lam;\n-#else\n-    int wnaf[1 + WNAF_SIZE(WINDOW_A - 1)];\n #endif\n \n     int i;\n@@ -145,18 +140,10 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n #ifdef USE_ENDOMORPHISM\n     /* split q into q_1 and q_lam (where q = q_1 + q_lam*lambda, and q_1 and q_lam are ~128 bit) */\n     secp256k1_scalar_split_lambda(&q_1, &q_lam, &sc);\n-    /* no need for zero correction when using endomorphism since even\n-     * numbers have one added to them anyway */\n     skew_1   = secp256k1_wnaf_const(wnaf_1,   q_1,   WINDOW_A - 1);\n     skew_lam = secp256k1_wnaf_const(wnaf_lam, q_lam, WINDOW_A - 1);\n #else\n-    int is_zero = secp256k1_scalar_is_zero(scalar);\n-    /* the wNAF ladder cannot handle zero, so bump this to one .. we will\n-     * correct the result after the fact */\n-    sc.d[0] += is_zero;\n-    VERIFY_CHECK(!secp256k1_scalar_is_zero(&sc));\n-\n-    secp256k1_wnaf_const(wnaf, sc, WINDOW_A - 1);\n+    skew_1   = secp256k1_wnaf_const(wnaf_1, sc, WINDOW_A - 1);\n #endif\n \n     /* Calculate odd multiples of a.\n@@ -179,21 +166,15 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n     /* first loop iteration (separated out so we can directly set r, rather\n      * than having it start at infinity, get doubled several times, then have\n      * its new value added to it) */\n-#ifdef USE_ENDOMORPHISM\n     i = wnaf_1[WNAF_SIZE(WINDOW_A - 1)];\n     VERIFY_CHECK(i != 0);\n     ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a, i, WINDOW_A);\n     secp256k1_gej_set_ge(r, &tmpa);\n-\n+#ifdef USE_ENDOMORPHISM\n     i = wnaf_lam[WNAF_SIZE(WINDOW_A - 1)];\n     VERIFY_CHECK(i != 0);\n     ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a_lam, i, WINDOW_A);\n     secp256k1_gej_add_ge(r, r, &tmpa);\n-#else\n-    i = wnaf[WNAF_SIZE(WINDOW_A - 1)];\n-    VERIFY_CHECK(i != 0);\n-    ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a, i, WINDOW_A);\n-    secp256k1_gej_set_ge(r, &tmpa);\n #endif\n     /* remaining loop iterations */\n     for (i = WNAF_SIZE(WINDOW_A - 1) - 1; i >= 0; i--) {\n@@ -202,59 +183,57 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n         for (j = 0; j < WINDOW_A - 1; ++j) {\n             secp256k1_gej_double_nonzero(r, r, NULL);\n         }\n-#ifdef USE_ENDOMORPHISM\n+\n         n = wnaf_1[i];\n         ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a, n, WINDOW_A);\n         VERIFY_CHECK(n != 0);\n         secp256k1_gej_add_ge(r, r, &tmpa);\n-\n+#ifdef USE_ENDOMORPHISM\n         n = wnaf_lam[i];\n         ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a_lam, n, WINDOW_A);\n         VERIFY_CHECK(n != 0);\n         secp256k1_gej_add_ge(r, r, &tmpa);\n-#else\n-        n = wnaf[i];\n-        VERIFY_CHECK(n != 0);\n-        ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a, n, WINDOW_A);\n-        secp256k1_gej_add_ge(r, r, &tmpa);\n #endif\n     }\n \n     secp256k1_fe_mul(&r->z, &r->z, &Z);\n \n-#ifdef USE_ENDOMORPHISM\n     {\n         /* Correct for wNAF skew */\n         secp256k1_ge correction = *a;\n         secp256k1_ge_storage correction_1_stor;\n+#ifdef USE_ENDOMORPHISM\n         secp256k1_ge_storage correction_lam_stor;\n+#endif\n         secp256k1_ge_storage a2_stor;\n         secp256k1_gej tmpj;\n         secp256k1_gej_set_ge(&tmpj, &correction);\n         secp256k1_gej_double_var(&tmpj, &tmpj, NULL);\n         secp256k1_ge_set_gej(&correction, &tmpj);\n         secp256k1_ge_to_storage(&correction_1_stor, a);\n+#ifdef USE_ENDOMORPHISM\n         secp256k1_ge_to_storage(&correction_lam_stor, a);\n+#endif\n         secp256k1_ge_to_storage(&a2_stor, &correction);\n \n         /* For odd numbers this is 2a (so replace it), for even ones a (so no-op) */\n         secp256k1_ge_storage_cmov(&correction_1_stor, &a2_stor, skew_1 == 2);\n+#ifdef USE_ENDOMORPHISM\n         secp256k1_ge_storage_cmov(&correction_lam_stor, &a2_stor, skew_lam == 2);\n+#endif\n \n         /* Apply the correction */\n         secp256k1_ge_from_storage(&correction, &correction_1_stor);\n         secp256k1_ge_neg(&correction, &correction);\n         secp256k1_gej_add_ge(r, r, &correction);\n \n+#ifdef USE_ENDOMORPHISM\n         secp256k1_ge_from_storage(&correction, &correction_lam_stor);\n         secp256k1_ge_neg(&correction, &correction);\n         secp256k1_ge_mul_lambda(&correction, &correction);\n         secp256k1_gej_add_ge(r, r, &correction);\n-    }\n-#else\n-    /* correct for zero */\n-    r->infinity |= is_zero;\n #endif\n+    }\n }\n \n #endif"
      },
      {
        "sha": "35f25460773f3ab1819beb6a1633ef264c83408d",
        "filename": "src/ecmult_gen_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/ecmult_gen_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/ecmult_gen_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_gen_impl.h?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -77,7 +77,7 @@ static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context *ctx\n                 secp256k1_gej_add_var(&numsbase, &numsbase, &nums_gej, NULL);\n             }\n         }\n-        secp256k1_ge_set_all_gej_var(1024, prec, precj, cb);\n+        secp256k1_ge_set_all_gej_var(prec, precj, 1024, cb);\n     }\n     for (j = 0; j < 64; j++) {\n         for (i = 0; i < 16; i++) {"
      },
      {
        "sha": "4e40104ad43ceb12845b79994c5bd5d28f3b31a0",
        "filename": "src/ecmult_impl.h",
        "status": "modified",
        "additions": 19,
        "deletions": 2,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/ecmult_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/ecmult_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_impl.h?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -7,13 +7,29 @@\n #ifndef _SECP256K1_ECMULT_IMPL_H_\n #define _SECP256K1_ECMULT_IMPL_H_\n \n+#include <string.h>\n+\n #include \"group.h\"\n #include \"scalar.h\"\n #include \"ecmult.h\"\n \n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/* We need to lower these values for exhaustive tests because\n+ * the tables cannot have infinities in them (this breaks the\n+ * affine-isomorphism stuff which tracks z-ratios) */\n+#  if EXHAUSTIVE_TEST_ORDER > 128\n+#    define WINDOW_A 5\n+#    define WINDOW_G 8\n+#  elif EXHAUSTIVE_TEST_ORDER > 8\n+#    define WINDOW_A 4\n+#    define WINDOW_G 4\n+#  else\n+#    define WINDOW_A 2\n+#    define WINDOW_G 2\n+#  endif\n+#else\n /* optimal for 128-bit and 256-bit exponents. */\n #define WINDOW_A 5\n-\n /** larger numbers may result in slightly better performance, at the cost of\n     exponentially larger precomputed tables. */\n #ifdef USE_ENDOMORPHISM\n@@ -23,6 +39,7 @@\n /** One table for window size 16: 1.375 MiB. */\n #define WINDOW_G 16\n #endif\n+#endif\n \n /** The number of entries a table with precomputed multiples needs to have. */\n #define ECMULT_TABLE_SIZE(w) (1 << ((w)-2))\n@@ -101,7 +118,7 @@ static void secp256k1_ecmult_odd_multiples_table_storage_var(int n, secp256k1_ge\n     /* Compute the odd multiples in Jacobian form. */\n     secp256k1_ecmult_odd_multiples_table(n, prej, zr, a);\n     /* Convert them in batch to affine coordinates. */\n-    secp256k1_ge_set_table_gej_var(n, prea, prej, zr);\n+    secp256k1_ge_set_table_gej_var(prea, prej, zr, n);\n     /* Convert them to compact storage form. */\n     for (i = 0; i < n; i++) {\n         secp256k1_ge_to_storage(&pre[i], &prea[i]);"
      },
      {
        "sha": "bbb1ee866cc427108f03a4f94fc1da27981c29fa",
        "filename": "src/field.h",
        "status": "modified",
        "additions": 13,
        "deletions": 2,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/field.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/field.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field.h?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -30,6 +30,8 @@\n #error \"Please select field implementation\"\n #endif\n \n+#include \"util.h\"\n+\n /** Normalize a field element. */\n static void secp256k1_fe_normalize(secp256k1_fe *r);\n \n@@ -50,13 +52,19 @@ static int secp256k1_fe_normalizes_to_zero_var(secp256k1_fe *r);\n /** Set a field element equal to a small integer. Resulting field element is normalized. */\n static void secp256k1_fe_set_int(secp256k1_fe *r, int a);\n \n+/** Sets a field element equal to zero, initializing all fields. */\n+static void secp256k1_fe_clear(secp256k1_fe *a);\n+\n /** Verify whether a field element is zero. Requires the input to be normalized. */\n static int secp256k1_fe_is_zero(const secp256k1_fe *a);\n \n /** Check the \"oddness\" of a field element. Requires the input to be normalized. */\n static int secp256k1_fe_is_odd(const secp256k1_fe *a);\n \n /** Compare two field elements. Requires magnitude-1 inputs. */\n+static int secp256k1_fe_equal(const secp256k1_fe *a, const secp256k1_fe *b);\n+\n+/** Same as secp256k1_fe_equal, but may be variable time. */\n static int secp256k1_fe_equal_var(const secp256k1_fe *a, const secp256k1_fe *b);\n \n /** Compare two field elements. Requires both inputs to be normalized */\n@@ -92,7 +100,10 @@ static void secp256k1_fe_sqr(secp256k1_fe *r, const secp256k1_fe *a);\n  *  The input's magnitude can be at most 8. The output magnitude is 1 (but not\n  *  guaranteed to be normalized). The result in r will always be a square\n  *  itself. */\n-static int secp256k1_fe_sqrt_var(secp256k1_fe *r, const secp256k1_fe *a);\n+static int secp256k1_fe_sqrt(secp256k1_fe *r, const secp256k1_fe *a);\n+\n+/** Checks whether a field element is a quadratic residue. */\n+static int secp256k1_fe_is_quad_var(const secp256k1_fe *a);\n \n /** Sets a field element to be the (modular) inverse of another. Requires the input's magnitude to be\n  *  at most 8. The output magnitude is 1 (but not guaranteed to be normalized). */\n@@ -104,7 +115,7 @@ static void secp256k1_fe_inv_var(secp256k1_fe *r, const secp256k1_fe *a);\n /** Calculate the (modular) inverses of a batch of field elements. Requires the inputs' magnitudes to be\n  *  at most 8. The output magnitudes are 1 (but not guaranteed to be normalized). The inputs and\n  *  outputs must not overlap in memory. */\n-static void secp256k1_fe_inv_all_var(size_t len, secp256k1_fe *r, const secp256k1_fe *a);\n+static void secp256k1_fe_inv_all_var(secp256k1_fe *r, const secp256k1_fe *a, size_t len);\n \n /** Convert a field element to the storage type. */\n static void secp256k1_fe_to_storage(secp256k1_fe_storage *r, const secp256k1_fe *a);"
      },
      {
        "sha": "7b8c07960847ebe8a4dfde401bc6596795b83b15",
        "filename": "src/field_10x26_impl.h",
        "status": "modified",
        "additions": 9,
        "deletions": 3,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/field_10x26_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/field_10x26_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_10x26_impl.h?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -7,8 +7,6 @@\n #ifndef _SECP256K1_FIELD_REPR_IMPL_H_\n #define _SECP256K1_FIELD_REPR_IMPL_H_\n \n-#include <stdio.h>\n-#include <string.h>\n #include \"util.h\"\n #include \"num.h\"\n #include \"field.h\"\n@@ -429,6 +427,14 @@ SECP256K1_INLINE static void secp256k1_fe_add(secp256k1_fe *r, const secp256k1_f\n #endif\n }\n \n+#if defined(USE_EXTERNAL_ASM)\n+\n+/* External assembler implementation */\n+void secp256k1_fe_mul_inner(uint32_t *r, const uint32_t *a, const uint32_t * SECP256K1_RESTRICT b);\n+void secp256k1_fe_sqr_inner(uint32_t *r, const uint32_t *a);\n+\n+#else\n+\n #ifdef VERIFY\n #define VERIFY_BITS(x, n) VERIFY_CHECK(((x) >> (n)) == 0)\n #else\n@@ -1037,7 +1043,7 @@ SECP256K1_INLINE static void secp256k1_fe_sqr_inner(uint32_t *r, const uint32_t\n     VERIFY_BITS(r[2], 27);\n     /* [r9 r8 r7 r6 r5 r4 r3 r2 r1 r0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n }\n-\n+#endif\n \n static void secp256k1_fe_mul(secp256k1_fe *r, const secp256k1_fe *a, const secp256k1_fe * SECP256K1_RESTRICT b) {\n #ifdef VERIFY"
      },
      {
        "sha": "7a99eb21eccc6bcea99d6d015bf0a7307d26db21",
        "filename": "src/field_5x52_impl.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/field_5x52_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/field_5x52_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_5x52_impl.h?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -11,7 +11,6 @@\n #include \"libsecp256k1-config.h\"\n #endif\n \n-#include <string.h>\n #include \"util.h\"\n #include \"num.h\"\n #include \"field.h\""
      },
      {
        "sha": "0bf22bdd3ec887251346dac826291fd1432c13ce",
        "filename": "src/field_5x52_int128_impl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/field_5x52_int128_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/field_5x52_int128_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_5x52_int128_impl.h?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -137,7 +137,7 @@ SECP256K1_INLINE static void secp256k1_fe_mul_inner(uint64_t *r, const uint64_t\n     VERIFY_BITS(r[2], 52);\n     VERIFY_BITS(c, 63);\n     /* [d 0 0 0 t4 t3+c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n-    c   += d * R + t3;;\n+    c   += d * R + t3;\n     VERIFY_BITS(c, 100);\n     /* [t4 c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n     r[3] = c & M; c >>= 52;\n@@ -259,7 +259,7 @@ SECP256K1_INLINE static void secp256k1_fe_sqr_inner(uint64_t *r, const uint64_t\n     VERIFY_BITS(c, 63);\n     /* [d 0 0 0 t4 t3+c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n \n-    c   += d * R + t3;;\n+    c   += d * R + t3;\n     VERIFY_BITS(c, 100);\n     /* [t4 c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n     r[3] = c & M; c >>= 52;"
      },
      {
        "sha": "5127b279bc7f56b621042d9f79bfc200dd7086c7",
        "filename": "src/field_impl.h",
        "status": "modified",
        "additions": 35,
        "deletions": 3,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/field_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/field_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_impl.h?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -21,14 +21,21 @@\n #error \"Please select field implementation\"\n #endif\n \n+SECP256K1_INLINE static int secp256k1_fe_equal(const secp256k1_fe *a, const secp256k1_fe *b) {\n+    secp256k1_fe na;\n+    secp256k1_fe_negate(&na, a, 1);\n+    secp256k1_fe_add(&na, b);\n+    return secp256k1_fe_normalizes_to_zero(&na);\n+}\n+\n SECP256K1_INLINE static int secp256k1_fe_equal_var(const secp256k1_fe *a, const secp256k1_fe *b) {\n     secp256k1_fe na;\n     secp256k1_fe_negate(&na, a, 1);\n     secp256k1_fe_add(&na, b);\n     return secp256k1_fe_normalizes_to_zero_var(&na);\n }\n \n-static int secp256k1_fe_sqrt_var(secp256k1_fe *r, const secp256k1_fe *a) {\n+static int secp256k1_fe_sqrt(secp256k1_fe *r, const secp256k1_fe *a) {\n     /** Given that p is congruent to 3 mod 4, we can compute the square root of\n      *  a mod p as the (p+1)/4'th power of a.\n      *\n@@ -123,7 +130,7 @@ static int secp256k1_fe_sqrt_var(secp256k1_fe *r, const secp256k1_fe *a) {\n     /* Check that a square root was actually calculated */\n \n     secp256k1_fe_sqr(&t1, r);\n-    return secp256k1_fe_equal_var(&t1, a);\n+    return secp256k1_fe_equal(&t1, a);\n }\n \n static void secp256k1_fe_inv(secp256k1_fe *r, const secp256k1_fe *a) {\n@@ -253,7 +260,7 @@ static void secp256k1_fe_inv_var(secp256k1_fe *r, const secp256k1_fe *a) {\n #endif\n }\n \n-static void secp256k1_fe_inv_all_var(size_t len, secp256k1_fe *r, const secp256k1_fe *a) {\n+static void secp256k1_fe_inv_all_var(secp256k1_fe *r, const secp256k1_fe *a, size_t len) {\n     secp256k1_fe u;\n     size_t i;\n     if (len < 1) {\n@@ -280,4 +287,29 @@ static void secp256k1_fe_inv_all_var(size_t len, secp256k1_fe *r, const secp256k\n     r[0] = u;\n }\n \n+static int secp256k1_fe_is_quad_var(const secp256k1_fe *a) {\n+#ifndef USE_NUM_NONE\n+    unsigned char b[32];\n+    secp256k1_num n;\n+    secp256k1_num m;\n+    /* secp256k1 field prime, value p defined in \"Standards for Efficient Cryptography\" (SEC2) 2.7.1. */\n+    static const unsigned char prime[32] = {\n+        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n+        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n+        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n+        0xFF,0xFF,0xFF,0xFE,0xFF,0xFF,0xFC,0x2F\n+    };\n+\n+    secp256k1_fe c = *a;\n+    secp256k1_fe_normalize_var(&c);\n+    secp256k1_fe_get_b32(b, &c);\n+    secp256k1_num_set_bin(&n, b, 32);\n+    secp256k1_num_set_bin(&m, prime, 32);\n+    return secp256k1_num_jacobi(&n, &m) >= 0;\n+#else\n+    secp256k1_fe r;\n+    return secp256k1_fe_sqrt(&r, a);\n+#endif\n+}\n+\n #endif"
      },
      {
        "sha": "4957b248fe6a608b8ae825b9b200b263415f36c4",
        "filename": "src/group.h",
        "status": "modified",
        "additions": 6,
        "deletions": 3,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/group.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/group.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/group.h?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -47,7 +47,7 @@ static void secp256k1_ge_set_xy(secp256k1_ge *r, const secp256k1_fe *x, const se\n  *  and a Y coordinate that is a quadratic residue modulo p. The return value\n  *  is true iff a coordinate with the given X coordinate exists.\n  */\n-static int secp256k1_ge_set_xquad_var(secp256k1_ge *r, const secp256k1_fe *x);\n+static int secp256k1_ge_set_xquad(secp256k1_ge *r, const secp256k1_fe *x);\n \n /** Set a group element (affine) equal to the point with the given X coordinate, and given oddness\n  *  for Y. Return value indicates whether the result is valid. */\n@@ -65,12 +65,12 @@ static void secp256k1_ge_neg(secp256k1_ge *r, const secp256k1_ge *a);\n static void secp256k1_ge_set_gej(secp256k1_ge *r, secp256k1_gej *a);\n \n /** Set a batch of group elements equal to the inputs given in jacobian coordinates */\n-static void secp256k1_ge_set_all_gej_var(size_t len, secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_callback *cb);\n+static void secp256k1_ge_set_all_gej_var(secp256k1_ge *r, const secp256k1_gej *a, size_t len, const secp256k1_callback *cb);\n \n /** Set a batch of group elements equal to the inputs given in jacobian\n  *  coordinates (with known z-ratios). zr must contain the known z-ratios such\n  *  that mul(a[i].z, zr[i+1]) == a[i+1].z. zr[0] is ignored. */\n-static void secp256k1_ge_set_table_gej_var(size_t len, secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_fe *zr);\n+static void secp256k1_ge_set_table_gej_var(secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_fe *zr, size_t len);\n \n /** Bring a batch inputs given in jacobian coordinates (with known z-ratios) to\n  *  the same global z \"denominator\". zr must contain the known z-ratios such\n@@ -94,6 +94,9 @@ static void secp256k1_gej_neg(secp256k1_gej *r, const secp256k1_gej *a);\n /** Check whether a group element is the point at infinity. */\n static int secp256k1_gej_is_infinity(const secp256k1_gej *a);\n \n+/** Check whether a group element's y coordinate is a quadratic residue. */\n+static int secp256k1_gej_has_quad_y_var(const secp256k1_gej *a);\n+\n /** Set r equal to the double of a. If rzr is not-NULL, r->z = a->z * *rzr (where infinity means an implicit z = 0).\n  * a may not be zero. Constant time. */\n static void secp256k1_gej_double_nonzero(secp256k1_gej *r, const secp256k1_gej *a, secp256k1_fe *rzr);"
      },
      {
        "sha": "2e192b62fd2ce7fa83f0b3d1876c0fbc6876f60e",
        "filename": "src/group_impl.h",
        "status": "modified",
        "additions": 96,
        "deletions": 16,
        "changes": 112,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/group_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/group_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/group_impl.h?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -7,12 +7,57 @@\n #ifndef _SECP256K1_GROUP_IMPL_H_\n #define _SECP256K1_GROUP_IMPL_H_\n \n-#include <string.h>\n-\n #include \"num.h\"\n #include \"field.h\"\n #include \"group.h\"\n \n+/* These points can be generated in sage as follows:\n+ *\n+ * 0. Setup a worksheet with the following parameters.\n+ *   b = 4  # whatever CURVE_B will be set to\n+ *   F = FiniteField (0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F)\n+ *   C = EllipticCurve ([F (0), F (b)])\n+ *\n+ * 1. Determine all the small orders available to you. (If there are\n+ *    no satisfactory ones, go back and change b.)\n+ *   print C.order().factor(limit=1000)\n+ *\n+ * 2. Choose an order as one of the prime factors listed in the above step.\n+ *    (You can also multiply some to get a composite order, though the\n+ *    tests will crash trying to invert scalars during signing.) We take a\n+ *    random point and scale it to drop its order to the desired value.\n+ *    There is some probability this won't work; just try again.\n+ *   order = 199\n+ *   P = C.random_point()\n+ *   P = (int(P.order()) / int(order)) * P\n+ *   assert(P.order() == order)\n+ *\n+ * 3. Print the values. You'll need to use a vim macro or something to\n+ *    split the hex output into 4-byte chunks.\n+ *   print \"%x %x\" % P.xy()\n+ */\n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+#  if EXHAUSTIVE_TEST_ORDER == 199\n+const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n+    0xFA7CC9A7, 0x0737F2DB, 0xA749DD39, 0x2B4FB069,\n+    0x3B017A7D, 0xA808C2F1, 0xFB12940C, 0x9EA66C18,\n+    0x78AC123A, 0x5ED8AEF3, 0x8732BC91, 0x1F3A2868,\n+    0x48DF246C, 0x808DAE72, 0xCFE52572, 0x7F0501ED\n+);\n+\n+const int CURVE_B = 4;\n+#  elif EXHAUSTIVE_TEST_ORDER == 13\n+const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n+    0xedc60018, 0xa51a786b, 0x2ea91f4d, 0x4c9416c0,\n+    0x9de54c3b, 0xa1316554, 0x6cf4345c, 0x7277ef15,\n+    0x54cb1b6b, 0xdc8c1273, 0x087844ea, 0x43f4603e,\n+    0x0eaf9a43, 0xf6effe55, 0x939f806d, 0x37adf8ac\n+);\n+const int CURVE_B = 2;\n+#  else\n+#    error No known generator for the specified exhaustive test group order.\n+#  endif\n+#else\n /** Generator for secp256k1, value 'g' defined in\n  *  \"Standards for Efficient Cryptography\" (SEC2) 2.7.1.\n  */\n@@ -23,8 +68,11 @@ static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n     0xFD17B448UL, 0xA6855419UL, 0x9C47D08FUL, 0xFB10D4B8UL\n );\n \n+const int CURVE_B = 7;\n+#endif\n+\n static void secp256k1_ge_set_gej_zinv(secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_fe *zi) {\n-    secp256k1_fe zi2; \n+    secp256k1_fe zi2;\n     secp256k1_fe zi3;\n     secp256k1_fe_sqr(&zi2, zi);\n     secp256k1_fe_mul(&zi3, &zi2, zi);\n@@ -78,7 +126,7 @@ static void secp256k1_ge_set_gej_var(secp256k1_ge *r, secp256k1_gej *a) {\n     r->y = a->y;\n }\n \n-static void secp256k1_ge_set_all_gej_var(size_t len, secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_callback *cb) {\n+static void secp256k1_ge_set_all_gej_var(secp256k1_ge *r, const secp256k1_gej *a, size_t len, const secp256k1_callback *cb) {\n     secp256k1_fe *az;\n     secp256k1_fe *azi;\n     size_t i;\n@@ -91,7 +139,7 @@ static void secp256k1_ge_set_all_gej_var(size_t len, secp256k1_ge *r, const secp\n     }\n \n     azi = (secp256k1_fe *)checked_malloc(cb, sizeof(secp256k1_fe) * count);\n-    secp256k1_fe_inv_all_var(count, azi, az);\n+    secp256k1_fe_inv_all_var(azi, az, count);\n     free(az);\n \n     count = 0;\n@@ -104,7 +152,7 @@ static void secp256k1_ge_set_all_gej_var(size_t len, secp256k1_ge *r, const secp\n     free(azi);\n }\n \n-static void secp256k1_ge_set_table_gej_var(size_t len, secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_fe *zr) {\n+static void secp256k1_ge_set_table_gej_var(secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_fe *zr, size_t len) {\n     size_t i = len - 1;\n     secp256k1_fe zi;\n \n@@ -147,9 +195,15 @@ static void secp256k1_ge_globalz_set_table_gej(size_t len, secp256k1_ge *r, secp\n \n static void secp256k1_gej_set_infinity(secp256k1_gej *r) {\n     r->infinity = 1;\n-    secp256k1_fe_set_int(&r->x, 0);\n-    secp256k1_fe_set_int(&r->y, 0);\n-    secp256k1_fe_set_int(&r->z, 0);\n+    secp256k1_fe_clear(&r->x);\n+    secp256k1_fe_clear(&r->y);\n+    secp256k1_fe_clear(&r->z);\n+}\n+\n+static void secp256k1_ge_set_infinity(secp256k1_ge *r) {\n+    r->infinity = 1;\n+    secp256k1_fe_clear(&r->x);\n+    secp256k1_fe_clear(&r->y);\n }\n \n static void secp256k1_gej_clear(secp256k1_gej *r) {\n@@ -165,19 +219,19 @@ static void secp256k1_ge_clear(secp256k1_ge *r) {\n     secp256k1_fe_clear(&r->y);\n }\n \n-static int secp256k1_ge_set_xquad_var(secp256k1_ge *r, const secp256k1_fe *x) {\n+static int secp256k1_ge_set_xquad(secp256k1_ge *r, const secp256k1_fe *x) {\n     secp256k1_fe x2, x3, c;\n     r->x = *x;\n     secp256k1_fe_sqr(&x2, x);\n     secp256k1_fe_mul(&x3, x, &x2);\n     r->infinity = 0;\n-    secp256k1_fe_set_int(&c, 7);\n+    secp256k1_fe_set_int(&c, CURVE_B);\n     secp256k1_fe_add(&c, &x3);\n-    return secp256k1_fe_sqrt_var(&r->y, &c);\n+    return secp256k1_fe_sqrt(&r->y, &c);\n }\n \n static int secp256k1_ge_set_xo_var(secp256k1_ge *r, const secp256k1_fe *x, int odd) {\n-    if (!secp256k1_ge_set_xquad_var(r, x)) {\n+    if (!secp256k1_ge_set_xquad(r, x)) {\n         return 0;\n     }\n     secp256k1_fe_normalize_var(&r->y);\n@@ -230,7 +284,7 @@ static int secp256k1_gej_is_valid_var(const secp256k1_gej *a) {\n     secp256k1_fe_sqr(&x3, &a->x); secp256k1_fe_mul(&x3, &x3, &a->x);\n     secp256k1_fe_sqr(&z2, &a->z);\n     secp256k1_fe_sqr(&z6, &z2); secp256k1_fe_mul(&z6, &z6, &z2);\n-    secp256k1_fe_mul_int(&z6, 7);\n+    secp256k1_fe_mul_int(&z6, CURVE_B);\n     secp256k1_fe_add(&x3, &z6);\n     secp256k1_fe_normalize_weak(&x3);\n     return secp256k1_fe_equal_var(&y2, &x3);\n@@ -244,18 +298,30 @@ static int secp256k1_ge_is_valid_var(const secp256k1_ge *a) {\n     /* y^2 = x^3 + 7 */\n     secp256k1_fe_sqr(&y2, &a->y);\n     secp256k1_fe_sqr(&x3, &a->x); secp256k1_fe_mul(&x3, &x3, &a->x);\n-    secp256k1_fe_set_int(&c, 7);\n+    secp256k1_fe_set_int(&c, CURVE_B);\n     secp256k1_fe_add(&x3, &c);\n     secp256k1_fe_normalize_weak(&x3);\n     return secp256k1_fe_equal_var(&y2, &x3);\n }\n \n static void secp256k1_gej_double_var(secp256k1_gej *r, const secp256k1_gej *a, secp256k1_fe *rzr) {\n-    /* Operations: 3 mul, 4 sqr, 0 normalize, 12 mul_int/add/negate */\n+    /* Operations: 3 mul, 4 sqr, 0 normalize, 12 mul_int/add/negate.\n+     *\n+     * Note that there is an implementation described at\n+     *     https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-dbl-2009-l\n+     * which trades a multiply for a square, but in practice this is actually slower,\n+     * mainly because it requires more normalizations.\n+     */\n     secp256k1_fe t1,t2,t3,t4;\n     /** For secp256k1, 2Q is infinity if and only if Q is infinity. This is because if 2Q = infinity,\n      *  Q must equal -Q, or that Q.y == -(Q.y), or Q.y is 0. For a point on y^2 = x^3 + 7 to have\n      *  y=0, x^3 must be -7 mod p. However, -7 has no cube root mod p.\n+     *\n+     *  Having said this, if this function receives a point on a sextic twist, e.g. by\n+     *  a fault attack, it is possible for y to be 0. This happens for y^2 = x^3 + 6,\n+     *  since -6 does have a cube root mod p. For this point, this function will not set\n+     *  the infinity flag even though the point doubles to infinity, and the result\n+     *  point will be gibberish (z = 0 but infinity = 0).\n      */\n     r->infinity = a->infinity;\n     if (r->infinity) {\n@@ -623,4 +689,18 @@ static void secp256k1_ge_mul_lambda(secp256k1_ge *r, const secp256k1_ge *a) {\n }\n #endif\n \n+static int secp256k1_gej_has_quad_y_var(const secp256k1_gej *a) {\n+    secp256k1_fe yz;\n+\n+    if (a->infinity) {\n+        return 0;\n+    }\n+\n+    /* We rely on the fact that the Jacobi symbol of 1 / a->z^3 is the same as\n+     * that of a->z. Thus a->y / a->z^3 is a quadratic residue iff a->y * a->z\n+       is */\n+    secp256k1_fe_mul(&yz, &a->y, &a->z);\n+    return secp256k1_fe_is_quad_var(&yz);\n+}\n+\n #endif"
      },
      {
        "sha": "fca98cab9f8315bd4fa5c165d9f8e2f16dc2a493",
        "filename": "src/hash.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/hash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/hash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.h?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -11,7 +11,7 @@\n #include <stdint.h>\n \n typedef struct {\n-    uint32_t s[32];\n+    uint32_t s[8];\n     uint32_t buf[16]; /* In big endian */\n     size_t bytes;\n } secp256k1_sha256_t;"
      },
      {
        "sha": "b47e65f830a906fc0eb9ff7939d62966823202b1",
        "filename": "src/hash_impl.h",
        "status": "modified",
        "additions": 4,
        "deletions": 6,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/hash_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/hash_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash_impl.h?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -269,15 +269,13 @@ static void secp256k1_rfc6979_hmac_sha256_finalize(secp256k1_rfc6979_hmac_sha256\n     rng->retry = 0;\n }\n \n-\n+#undef BE32\n #undef Round\n-#undef sigma0\n #undef sigma1\n-#undef Sigma0\n+#undef sigma0\n #undef Sigma1\n-#undef Ch\n+#undef Sigma0\n #undef Maj\n-#undef ReadBE32\n-#undef WriteBE32\n+#undef Ch\n \n #endif"
      },
      {
        "sha": "1c67802fba82e60498c560473e9966c161939ffb",
        "filename": "src/java/org/bitcoin/NativeSecp256k1.java",
        "status": "modified",
        "additions": 413,
        "deletions": 27,
        "changes": 440,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/java/org/bitcoin/NativeSecp256k1.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/java/org/bitcoin/NativeSecp256k1.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org/bitcoin/NativeSecp256k1.java?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -1,60 +1,446 @@\n+/*\n+ * Copyright 2013 Google Inc.\n+ * Copyright 2014-2016 the libsecp256k1 contributors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n package org.bitcoin;\n \n import java.nio.ByteBuffer;\n import java.nio.ByteOrder;\n \n+import java.math.BigInteger;\n import com.google.common.base.Preconditions;\n-\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import static org.bitcoin.NativeSecp256k1Util.*;\n \n /**\n- * This class holds native methods to handle ECDSA verification.\n- * You can find an example library that can be used for this at\n- * https://github.com/sipa/secp256k1\n+ * <p>This class holds native methods to handle ECDSA verification.</p>\n+ *\n+ * <p>You can find an example library that can be used for this at https://github.com/bitcoin/secp256k1</p>\n+ *\n+ * <p>To build secp256k1 for use with bitcoinj, run\n+ * `./configure --enable-jni --enable-experimental --enable-module-ecdh`\n+ * and `make` then copy `.libs/libsecp256k1.so` to your system library path\n+ * or point the JVM to the folder containing it with -Djava.library.path\n+ * </p>\n  */\n public class NativeSecp256k1 {\n-    public static final boolean enabled;\n-    static {\n-        boolean isEnabled = true;\n-        try {\n-            System.loadLibrary(\"javasecp256k1\");\n-        } catch (UnsatisfiedLinkError e) {\n-            isEnabled = false;\n-        }\n-        enabled = isEnabled;\n-    }\n-    \n+\n+    private static final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n+    private static final Lock r = rwl.readLock();\n+    private static final Lock w = rwl.writeLock();\n     private static ThreadLocal<ByteBuffer> nativeECDSABuffer = new ThreadLocal<ByteBuffer>();\n     /**\n      * Verifies the given secp256k1 signature in native code.\n      * Calling when enabled == false is undefined (probably library not loaded)\n-     * \n+     *\n      * @param data The data which was signed, must be exactly 32 bytes\n      * @param signature The signature\n      * @param pub The public key which did the signing\n      */\n-    public static boolean verify(byte[] data, byte[] signature, byte[] pub) {\n+    public static boolean verify(byte[] data, byte[] signature, byte[] pub) throws AssertFailException{\n         Preconditions.checkArgument(data.length == 32 && signature.length <= 520 && pub.length <= 520);\n \n         ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null) {\n-            byteBuff = ByteBuffer.allocateDirect(32 + 8 + 520 + 520);\n+        if (byteBuff == null || byteBuff.capacity() < 520) {\n+            byteBuff = ByteBuffer.allocateDirect(520);\n             byteBuff.order(ByteOrder.nativeOrder());\n             nativeECDSABuffer.set(byteBuff);\n         }\n         byteBuff.rewind();\n         byteBuff.put(data);\n-        byteBuff.putInt(signature.length);\n-        byteBuff.putInt(pub.length);\n         byteBuff.put(signature);\n         byteBuff.put(pub);\n-        return secp256k1_ecdsa_verify(byteBuff) == 1;\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          return secp256k1_ecdsa_verify(byteBuff, Secp256k1Context.getContext(), signature.length, pub.length) == 1;\n+        } finally {\n+          r.unlock();\n+        }\n+    }\n+\n+    /**\n+     * libsecp256k1 Create an ECDSA signature.\n+     *\n+     * @param data Message hash, 32 bytes\n+     * @param key Secret key, 32 bytes\n+     *\n+     * Return values\n+     * @param sig byte array of signature\n+     */\n+    public static byte[] sign(byte[] data, byte[] sec) throws AssertFailException{\n+        Preconditions.checkArgument(data.length == 32 && sec.length <= 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < 32 + 32) {\n+            byteBuff = ByteBuffer.allocateDirect(32 + 32);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(data);\n+        byteBuff.put(sec);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ecdsa_sign(byteBuff, Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] sigArr = retByteArray[0];\n+        int sigLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(sigArr.length, sigLen, \"Got bad signature length.\");\n+\n+        return retVal == 0 ? new byte[0] : sigArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Seckey Verify - returns 1 if valid, 0 if invalid\n+     *\n+     * @param seckey ECDSA Secret key, 32 bytes\n+     */\n+    public static boolean secKeyVerify(byte[] seckey) {\n+        Preconditions.checkArgument(seckey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+\n+        r.lock();\n+        try {\n+          return secp256k1_ec_seckey_verify(byteBuff,Secp256k1Context.getContext()) == 1;\n+        } finally {\n+          r.unlock();\n+        }\n+    }\n+\n+\n+    /**\n+     * libsecp256k1 Compute Pubkey - computes public key from secret key\n+     *\n+     * @param seckey ECDSA Secret key, 32 bytes\n+     *\n+     * Return values\n+     * @param pubkey ECDSA Public key, 33 or 65 bytes\n+     */\n+    //TODO add a 'compressed' arg\n+    public static byte[] computePubkey(byte[] seckey) throws AssertFailException{\n+        Preconditions.checkArgument(seckey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ec_pubkey_create(byteBuff, Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] pubArr = retByteArray[0];\n+        int pubLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n+\n+        return retVal == 0 ? new byte[0]: pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Cleanup - This destroys the secp256k1 context object\n+     * This should be called at the end of the program for proper cleanup of the context.\n+     */\n+    public static synchronized void cleanup() {\n+        w.lock();\n+        try {\n+          secp256k1_destroy_context(Secp256k1Context.getContext());\n+        } finally {\n+          w.unlock();\n+        }\n+    }\n+\n+    public static long cloneContext() {\n+       r.lock();\n+       try {\n+        return secp256k1_ctx_clone(Secp256k1Context.getContext());\n+       } finally { r.unlock(); }\n+    }\n+\n+    /**\n+     * libsecp256k1 PrivKey Tweak-Mul - Tweak privkey by multiplying to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param seckey 32-byte seckey\n+     */\n+    public static byte[] privKeyTweakMul(byte[] privkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(privkey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < privkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(privkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(privkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_privkey_tweak_mul(byteBuff,Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, privLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 PrivKey Tweak-Add - Tweak privkey by adding to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param seckey 32-byte seckey\n+     */\n+    public static byte[] privKeyTweakAdd(byte[] privkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(privkey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < privkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(privkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(privkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_privkey_tweak_add(byteBuff,Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, privLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 PubKey Tweak-Add - Tweak pubkey by adding to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param pubkey 32-byte seckey\n+     */\n+    public static byte[] pubKeyTweakAdd(byte[] pubkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(pubkey.length == 33 || pubkey.length == 65);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < pubkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(pubkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(pubkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_pubkey_tweak_add(byteBuff,Secp256k1Context.getContext(), pubkey.length);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] pubArr = retByteArray[0];\n+\n+        int pubLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 PubKey Tweak-Mul - Tweak pubkey by multiplying to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param pubkey 32-byte seckey\n+     */\n+    public static byte[] pubKeyTweakMul(byte[] pubkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(pubkey.length == 33 || pubkey.length == 65);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < pubkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(pubkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(pubkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_pubkey_tweak_mul(byteBuff,Secp256k1Context.getContext(), pubkey.length);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] pubArr = retByteArray[0];\n+\n+        int pubLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return pubArr;\n     }\n \n     /**\n-     * @param byteBuff signature format is byte[32] data,\n-     *        native-endian int signatureLength, native-endian int pubkeyLength,\n-     *        byte[signatureLength] signature, byte[pubkeyLength] pub\n-     * @returns 1 for valid signature, anything else for invalid\n+     * libsecp256k1 create ECDH secret - constant time ECDH calculation\n+     *\n+     * @param seckey byte array of secret key used in exponentiaion\n+     * @param pubkey byte array of public key used in exponentiaion\n      */\n-    private static native int secp256k1_ecdsa_verify(ByteBuffer byteBuff);\n+    public static byte[] createECDHSecret(byte[] seckey, byte[] pubkey) throws AssertFailException{\n+        Preconditions.checkArgument(seckey.length <= 32 && pubkey.length <= 65);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < 32 + pubkey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(32 + pubkey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+        byteBuff.put(pubkey);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ecdh(byteBuff, Secp256k1Context.getContext(), pubkey.length);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] resArr = retByteArray[0];\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+\n+        assertEquals(resArr.length, 32, \"Got bad result length.\");\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return resArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 randomize - updates the context randomization\n+     *\n+     * @param seed 32-byte random seed\n+     */\n+    public static synchronized boolean randomize(byte[] seed) throws AssertFailException{\n+        Preconditions.checkArgument(seed.length == 32 || seed == null);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seed.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seed.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seed);\n+\n+        w.lock();\n+        try {\n+          return secp256k1_context_randomize(byteBuff, Secp256k1Context.getContext()) == 1;\n+        } finally {\n+          w.unlock();\n+        }\n+    }\n+\n+    private static native long secp256k1_ctx_clone(long context);\n+\n+    private static native int secp256k1_context_randomize(ByteBuffer byteBuff, long context);\n+\n+    private static native byte[][] secp256k1_privkey_tweak_add(ByteBuffer byteBuff, long context);\n+\n+    private static native byte[][] secp256k1_privkey_tweak_mul(ByteBuffer byteBuff, long context);\n+\n+    private static native byte[][] secp256k1_pubkey_tweak_add(ByteBuffer byteBuff, long context, int pubLen);\n+\n+    private static native byte[][] secp256k1_pubkey_tweak_mul(ByteBuffer byteBuff, long context, int pubLen);\n+\n+    private static native void secp256k1_destroy_context(long context);\n+\n+    private static native int secp256k1_ecdsa_verify(ByteBuffer byteBuff, long context, int sigLen, int pubLen);\n+\n+    private static native byte[][] secp256k1_ecdsa_sign(ByteBuffer byteBuff, long context);\n+\n+    private static native int secp256k1_ec_seckey_verify(ByteBuffer byteBuff, long context);\n+\n+    private static native byte[][] secp256k1_ec_pubkey_create(ByteBuffer byteBuff, long context);\n+\n+    private static native byte[][] secp256k1_ec_pubkey_parse(ByteBuffer byteBuff, long context, int inputLen);\n+\n+    private static native byte[][] secp256k1_ecdh(ByteBuffer byteBuff, long context, int inputLen);\n+\n }"
      },
      {
        "sha": "c00d08899b9b004af75a4e98569c460ad83395a1",
        "filename": "src/java/org/bitcoin/NativeSecp256k1Test.java",
        "status": "added",
        "additions": 226,
        "deletions": 0,
        "changes": 226,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org/bitcoin/NativeSecp256k1Test.java?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -0,0 +1,226 @@\n+package org.bitcoin;\n+\n+import com.google.common.io.BaseEncoding;\n+import java.util.Arrays;\n+import java.math.BigInteger;\n+import javax.xml.bind.DatatypeConverter;\n+import static org.bitcoin.NativeSecp256k1Util.*;\n+\n+/**\n+ * This class holds test cases defined for testing this library.\n+ */\n+public class NativeSecp256k1Test {\n+\n+    //TODO improve comments/add more tests\n+    /**\n+      * This tests verify() for a valid signature\n+      */\n+    public static void testVerifyPos() throws AssertFailException{\n+        boolean result = false;\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"CF80CD8AED482D5D1527D7DC72FCEFF84E6326592848447D2DC0B0E87DFC9A90\".toLowerCase()); //sha256hash of \"testing\"\n+        byte[] sig = BaseEncoding.base16().lowerCase().decode(\"3044022079BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F817980220294F14E883B3F525B5367756C2A11EF6CF84B730B36C17CB0C56F0AAB2C98589\".toLowerCase());\n+        byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n+\n+        result = NativeSecp256k1.verify( data, sig, pub);\n+        assertEquals( result, true , \"testVerifyPos\");\n+    }\n+\n+    /**\n+      * This tests verify() for a non-valid signature\n+      */\n+    public static void testVerifyNeg() throws AssertFailException{\n+        boolean result = false;\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"CF80CD8AED482D5D1527D7DC72FCEFF84E6326592848447D2DC0B0E87DFC9A91\".toLowerCase()); //sha256hash of \"testing\"\n+        byte[] sig = BaseEncoding.base16().lowerCase().decode(\"3044022079BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F817980220294F14E883B3F525B5367756C2A11EF6CF84B730B36C17CB0C56F0AAB2C98589\".toLowerCase());\n+        byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n+\n+        result = NativeSecp256k1.verify( data, sig, pub);\n+        //System.out.println(\" TEST \" + new BigInteger(1, resultbytes).toString(16));\n+        assertEquals( result, false , \"testVerifyNeg\");\n+    }\n+\n+    /**\n+      * This tests secret key verify() for a valid secretkey\n+      */\n+    public static void testSecKeyVerifyPos() throws AssertFailException{\n+        boolean result = false;\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n+\n+        result = NativeSecp256k1.secKeyVerify( sec );\n+        //System.out.println(\" TEST \" + new BigInteger(1, resultbytes).toString(16));\n+        assertEquals( result, true , \"testSecKeyVerifyPos\");\n+    }\n+\n+    /**\n+      * This tests secret key verify() for a invalid secretkey\n+      */\n+    public static void testSecKeyVerifyNeg() throws AssertFailException{\n+        boolean result = false;\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\".toLowerCase());\n+\n+        result = NativeSecp256k1.secKeyVerify( sec );\n+        //System.out.println(\" TEST \" + new BigInteger(1, resultbytes).toString(16));\n+        assertEquals( result, false , \"testSecKeyVerifyNeg\");\n+    }\n+\n+    /**\n+      * This tests public key create() for a valid secretkey\n+      */\n+    public static void testPubKeyCreatePos() throws AssertFailException{\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n+\n+        byte[] resultArr = NativeSecp256k1.computePubkey( sec);\n+        String pubkeyString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( pubkeyString , \"04C591A8FF19AC9C4E4E5793673B83123437E975285E7B442F4EE2654DFFCA5E2D2103ED494718C697AC9AEBCFD19612E224DB46661011863ED2FC54E71861E2A6\" , \"testPubKeyCreatePos\");\n+    }\n+\n+    /**\n+      * This tests public key create() for a invalid secretkey\n+      */\n+    public static void testPubKeyCreateNeg() throws AssertFailException{\n+       byte[] sec = BaseEncoding.base16().lowerCase().decode(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\".toLowerCase());\n+\n+       byte[] resultArr = NativeSecp256k1.computePubkey( sec);\n+       String pubkeyString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+       assertEquals( pubkeyString, \"\" , \"testPubKeyCreateNeg\");\n+    }\n+\n+    /**\n+      * This tests sign() for a valid secretkey\n+      */\n+    public static void testSignPos() throws AssertFailException{\n+\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"CF80CD8AED482D5D1527D7DC72FCEFF84E6326592848447D2DC0B0E87DFC9A90\".toLowerCase()); //sha256hash of \"testing\"\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n+\n+        byte[] resultArr = NativeSecp256k1.sign(data, sec);\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( sigString, \"30440220182A108E1448DC8F1FB467D06A0F3BB8EA0533584CB954EF8DA112F1D60E39A202201C66F36DA211C087F3AF88B50EDF4F9BDAA6CF5FD6817E74DCA34DB12390C6E9\" , \"testSignPos\");\n+    }\n+\n+    /**\n+      * This tests sign() for a invalid secretkey\n+      */\n+    public static void testSignNeg() throws AssertFailException{\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"CF80CD8AED482D5D1527D7DC72FCEFF84E6326592848447D2DC0B0E87DFC9A90\".toLowerCase()); //sha256hash of \"testing\"\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\".toLowerCase());\n+\n+        byte[] resultArr = NativeSecp256k1.sign(data, sec);\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( sigString, \"\" , \"testSignNeg\");\n+    }\n+\n+    /**\n+      * This tests private key tweak-add\n+      */\n+    public static void testPrivKeyTweakAdd_1() throws AssertFailException {\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n+\n+        byte[] resultArr = NativeSecp256k1.privKeyTweakAdd( sec , data );\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( sigString , \"A168571E189E6F9A7E2D657A4B53AE99B909F7E712D1C23CED28093CD57C88F3\" , \"testPrivKeyAdd_1\");\n+    }\n+\n+    /**\n+      * This tests private key tweak-mul\n+      */\n+    public static void testPrivKeyTweakMul_1() throws AssertFailException {\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n+\n+        byte[] resultArr = NativeSecp256k1.privKeyTweakMul( sec , data );\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( sigString , \"97F8184235F101550F3C71C927507651BD3F1CDB4A5A33B8986ACF0DEE20FFFC\" , \"testPrivKeyMul_1\");\n+    }\n+\n+    /**\n+      * This tests private key tweak-add uncompressed\n+      */\n+    public static void testPrivKeyTweakAdd_2() throws AssertFailException {\n+        byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n+\n+        byte[] resultArr = NativeSecp256k1.pubKeyTweakAdd( pub , data );\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( sigString , \"0411C6790F4B663CCE607BAAE08C43557EDC1A4D11D88DFCB3D841D0C6A941AF525A268E2A863C148555C48FB5FBA368E88718A46E205FABC3DBA2CCFFAB0796EF\" , \"testPrivKeyAdd_2\");\n+    }\n+\n+    /**\n+      * This tests private key tweak-mul uncompressed\n+      */\n+    public static void testPrivKeyTweakMul_2() throws AssertFailException {\n+        byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n+\n+        byte[] resultArr = NativeSecp256k1.pubKeyTweakMul( pub , data );\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( sigString , \"04E0FE6FE55EBCA626B98A807F6CAF654139E14E5E3698F01A9A658E21DC1D2791EC060D4F412A794D5370F672BC94B722640B5F76914151CFCA6E712CA48CC589\" , \"testPrivKeyMul_2\");\n+    }\n+\n+    /**\n+      * This tests seed randomization\n+      */\n+    public static void testRandomize() throws AssertFailException {\n+        byte[] seed = BaseEncoding.base16().lowerCase().decode(\"A441B15FE9A3CF56661190A0B93B9DEC7D04127288CC87250967CF3B52894D11\".toLowerCase()); //sha256hash of \"random\"\n+        boolean result = NativeSecp256k1.randomize(seed);\n+        assertEquals( result, true, \"testRandomize\");\n+    }\n+\n+    public static void testCreateECDHSecret() throws AssertFailException{\n+\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n+        byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n+\n+        byte[] resultArr = NativeSecp256k1.createECDHSecret(sec, pub);\n+        String ecdhString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( ecdhString, \"2A2A67007A926E6594AF3EB564FC74005B37A9C8AEF2033C4552051B5C87F043\" , \"testCreateECDHSecret\");\n+    }\n+\n+    public static void main(String[] args) throws AssertFailException{\n+\n+\n+        System.out.println(\"\\n libsecp256k1 enabled: \" + Secp256k1Context.isEnabled() + \"\\n\");\n+\n+        assertEquals( Secp256k1Context.isEnabled(), true, \"isEnabled\" );\n+\n+        //Test verify() success/fail\n+        testVerifyPos();\n+        testVerifyNeg();\n+\n+        //Test secKeyVerify() success/fail\n+        testSecKeyVerifyPos();\n+        testSecKeyVerifyNeg();\n+\n+        //Test computePubkey() success/fail\n+        testPubKeyCreatePos();\n+        testPubKeyCreateNeg();\n+\n+        //Test sign() success/fail\n+        testSignPos();\n+        testSignNeg();\n+\n+        //Test privKeyTweakAdd() 1\n+        testPrivKeyTweakAdd_1();\n+\n+        //Test privKeyTweakMul() 2\n+        testPrivKeyTweakMul_1();\n+\n+        //Test privKeyTweakAdd() 3\n+        testPrivKeyTweakAdd_2();\n+\n+        //Test privKeyTweakMul() 4\n+        testPrivKeyTweakMul_2();\n+\n+        //Test randomize()\n+        testRandomize();\n+\n+        //Test ECDH\n+        testCreateECDHSecret();\n+\n+        NativeSecp256k1.cleanup();\n+\n+        System.out.println(\" All tests passed.\" );\n+\n+    }\n+}"
      },
      {
        "sha": "04732ba044363a5dc5c525661a090c1bdf1d077f",
        "filename": "src/java/org/bitcoin/NativeSecp256k1Util.java",
        "status": "added",
        "additions": 45,
        "deletions": 0,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/java/org/bitcoin/NativeSecp256k1Util.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/java/org/bitcoin/NativeSecp256k1Util.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org/bitcoin/NativeSecp256k1Util.java?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2014-2016 the libsecp256k1 contributors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.bitcoin;\n+\n+public class NativeSecp256k1Util{\n+\n+    public static void assertEquals( int val, int val2, String message ) throws AssertFailException{\n+      if( val != val2 )\n+        throw new AssertFailException(\"FAIL: \" + message);\n+    }\n+\n+    public static void assertEquals( boolean val, boolean val2, String message ) throws AssertFailException{\n+      if( val != val2 )\n+        throw new AssertFailException(\"FAIL: \" + message);\n+      else\n+        System.out.println(\"PASS: \" + message);\n+    }\n+\n+    public static void assertEquals( String val, String val2, String message ) throws AssertFailException{\n+      if( !val.equals(val2) )\n+        throw new AssertFailException(\"FAIL: \" + message);\n+      else\n+        System.out.println(\"PASS: \" + message);\n+    }\n+\n+    public static class AssertFailException extends Exception {\n+      public AssertFailException(String message) {\n+        super( message );\n+      }\n+    }\n+}"
      },
      {
        "sha": "216c986a8b564d49b01243d513bdd182339e51b6",
        "filename": "src/java/org/bitcoin/Secp256k1Context.java",
        "status": "added",
        "additions": 51,
        "deletions": 0,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/java/org/bitcoin/Secp256k1Context.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/java/org/bitcoin/Secp256k1Context.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org/bitcoin/Secp256k1Context.java?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2014-2016 the libsecp256k1 contributors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.bitcoin;\n+\n+/**\n+ * This class holds the context reference used in native methods \n+ * to handle ECDSA operations.\n+ */\n+public class Secp256k1Context {\n+  private static final boolean enabled; //true if the library is loaded\n+  private static final long context; //ref to pointer to context obj\n+\n+  static { //static initializer\n+      boolean isEnabled = true;\n+      long contextRef = -1;\n+      try {\n+          System.loadLibrary(\"secp256k1\");\n+          contextRef = secp256k1_init_context();\n+      } catch (UnsatisfiedLinkError e) {\n+          System.out.println(\"UnsatisfiedLinkError: \" + e.toString());\n+          isEnabled = false;\n+      }\n+      enabled = isEnabled;\n+      context = contextRef;\n+  }\n+\n+  public static boolean isEnabled() {\n+     return enabled;\n+  }\n+\n+  public static long getContext() {\n+     if(!enabled) return -1; //sanity check\n+     return context;\n+  }\n+\n+  private static native long secp256k1_init_context();\n+}"
      },
      {
        "sha": "bcef7b32ce3e7fe1587f15dac2e7c56fef998a8a",
        "filename": "src/java/org_bitcoin_NativeSecp256k1.c",
        "status": "modified",
        "additions": 366,
        "deletions": 12,
        "changes": 378,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/java/org_bitcoin_NativeSecp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/java/org_bitcoin_NativeSecp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org_bitcoin_NativeSecp256k1.c?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -1,23 +1,377 @@\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include <string.h>\n #include \"org_bitcoin_NativeSecp256k1.h\"\n #include \"include/secp256k1.h\"\n+#include \"include/secp256k1_ecdh.h\"\n+#include \"include/secp256k1_recovery.h\"\n \n-JNIEXPORT jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1verify\n-  (JNIEnv* env, jclass classObject, jobject byteBufferObject)\n+\n+SECP256K1_API jlong JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ctx_1clone\n+  (JNIEnv* env, jclass classObject, jlong ctx_l)\n+{\n+  const secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+\n+  jlong ctx_clone_l = (uintptr_t) secp256k1_context_clone(ctx);\n+\n+  (void)classObject;(void)env;\n+\n+  return ctx_clone_l;\n+\n+}\n+\n+SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1context_1randomize\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n {\n-\tunsigned char* data = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n-\tint sigLen = *((int*)(data + 32));\n-\tint pubLen = *((int*)(data + 32 + 4));\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+\n+  const unsigned char* seed = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+\n+  (void)classObject;\n+\n+  return secp256k1_context_randomize(ctx, seed);\n \n-\treturn secp256k1_ecdsa_verify(data, 32, data+32+8, sigLen, data+32+8+sigLen, pubLen);\n }\n \n-static void __javasecp256k1_attach(void) __attribute__((constructor));\n-static void __javasecp256k1_detach(void) __attribute__((destructor));\n+SECP256K1_API void JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1destroy_1context\n+  (JNIEnv* env, jclass classObject, jlong ctx_l)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+\n+  secp256k1_context_destroy(ctx);\n \n-static void __javasecp256k1_attach(void) {\n-\tsecp256k1_start(SECP256K1_START_VERIFY);\n+  (void)classObject;(void)env;\n }\n \n-static void __javasecp256k1_detach(void) {\n-\tsecp256k1_stop();\n+SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1verify\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint siglen, jint publen)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+\n+  unsigned char* data = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  const unsigned char* sigdata = {  (unsigned char*) (data + 32) };\n+  const unsigned char* pubdata = { (unsigned char*) (data + siglen + 32) };\n+\n+  secp256k1_ecdsa_signature sig;\n+  secp256k1_pubkey pubkey;\n+\n+  int ret = secp256k1_ecdsa_signature_parse_der(ctx, &sig, sigdata, siglen);\n+\n+  if( ret ) {\n+    ret = secp256k1_ec_pubkey_parse(ctx, &pubkey, pubdata, publen);\n+\n+    if( ret ) {\n+      ret = secp256k1_ecdsa_verify(ctx, &sig, data, &pubkey);\n+    }\n+  }\n+\n+  (void)classObject;\n+\n+  return ret;\n+}\n+\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1sign\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  unsigned char* data = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  unsigned char* secKey = (unsigned char*) (data + 32);\n+\n+  jobjectArray retArray;\n+  jbyteArray sigArray, intsByteArray;\n+  unsigned char intsarray[2];\n+\n+  secp256k1_ecdsa_signature sig[72];\n+\n+  int ret = secp256k1_ecdsa_sign(ctx, sig, data, secKey, NULL, NULL );\n+\n+  unsigned char outputSer[72];\n+  size_t outputLen = 72;\n+\n+  if( ret ) {\n+    int ret2 = secp256k1_ecdsa_signature_serialize_der(ctx,outputSer, &outputLen, sig ); (void)ret2;\n+  }\n+\n+  intsarray[0] = outputLen;\n+  intsarray[1] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  sigArray = (*env)->NewByteArray(env, outputLen);\n+  (*env)->SetByteArrayRegion(env, sigArray, 0, outputLen, (jbyte*)outputSer);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, sigArray);\n+\n+  intsByteArray = (*env)->NewByteArray(env, 2);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n+}\n+\n+SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1seckey_1verify\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  unsigned char* secKey = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+\n+  (void)classObject;\n+\n+  return secp256k1_ec_seckey_verify(ctx, secKey);\n+}\n+\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1pubkey_1create\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  const unsigned char* secKey = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+\n+  secp256k1_pubkey pubkey;\n+\n+  jobjectArray retArray;\n+  jbyteArray pubkeyArray, intsByteArray;\n+  unsigned char intsarray[2];\n+\n+  int ret = secp256k1_ec_pubkey_create(ctx, &pubkey, secKey);\n+\n+  unsigned char outputSer[65];\n+  size_t outputLen = 65;\n+\n+  if( ret ) {\n+    int ret2 = secp256k1_ec_pubkey_serialize(ctx,outputSer, &outputLen, &pubkey,SECP256K1_EC_UNCOMPRESSED );(void)ret2;\n+  }\n+\n+  intsarray[0] = outputLen;\n+  intsarray[1] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  pubkeyArray = (*env)->NewByteArray(env, outputLen);\n+  (*env)->SetByteArrayRegion(env, pubkeyArray, 0, outputLen, (jbyte*)outputSer);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, pubkeyArray);\n+\n+  intsByteArray = (*env)->NewByteArray(env, 2);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n+\n+}\n+\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1privkey_1tweak_1add\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  unsigned char* privkey = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  const unsigned char* tweak = (unsigned char*) (privkey + 32);\n+\n+  jobjectArray retArray;\n+  jbyteArray privArray, intsByteArray;\n+  unsigned char intsarray[2];\n+\n+  int privkeylen = 32;\n+\n+  int ret = secp256k1_ec_privkey_tweak_add(ctx, privkey, tweak);\n+\n+  intsarray[0] = privkeylen;\n+  intsarray[1] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  privArray = (*env)->NewByteArray(env, privkeylen);\n+  (*env)->SetByteArrayRegion(env, privArray, 0, privkeylen, (jbyte*)privkey);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, privArray);\n+\n+  intsByteArray = (*env)->NewByteArray(env, 2);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n+}\n+\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1privkey_1tweak_1mul\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  unsigned char* privkey = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  const unsigned char* tweak = (unsigned char*) (privkey + 32);\n+\n+  jobjectArray retArray;\n+  jbyteArray privArray, intsByteArray;\n+  unsigned char intsarray[2];\n+\n+  int privkeylen = 32;\n+\n+  int ret = secp256k1_ec_privkey_tweak_mul(ctx, privkey, tweak);\n+\n+  intsarray[0] = privkeylen;\n+  intsarray[1] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  privArray = (*env)->NewByteArray(env, privkeylen);\n+  (*env)->SetByteArrayRegion(env, privArray, 0, privkeylen, (jbyte*)privkey);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, privArray);\n+\n+  intsByteArray = (*env)->NewByteArray(env, 2);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n+}\n+\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1pubkey_1tweak_1add\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint publen)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+/*  secp256k1_pubkey* pubkey = (secp256k1_pubkey*) (*env)->GetDirectBufferAddress(env, byteBufferObject);*/\n+  unsigned char* pkey = (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  const unsigned char* tweak = (unsigned char*) (pkey + publen);\n+\n+  jobjectArray retArray;\n+  jbyteArray pubArray, intsByteArray;\n+  unsigned char intsarray[2];\n+  unsigned char outputSer[65];\n+  size_t outputLen = 65;\n+\n+  secp256k1_pubkey pubkey;\n+  int ret = secp256k1_ec_pubkey_parse(ctx, &pubkey, pkey, publen);\n+\n+  if( ret ) {\n+    ret = secp256k1_ec_pubkey_tweak_add(ctx, &pubkey, tweak);\n+  }\n+\n+  if( ret ) {\n+    int ret2 = secp256k1_ec_pubkey_serialize(ctx,outputSer, &outputLen, &pubkey,SECP256K1_EC_UNCOMPRESSED );(void)ret2;\n+  }\n+\n+  intsarray[0] = outputLen;\n+  intsarray[1] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  pubArray = (*env)->NewByteArray(env, outputLen);\n+  (*env)->SetByteArrayRegion(env, pubArray, 0, outputLen, (jbyte*)outputSer);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, pubArray);\n+\n+  intsByteArray = (*env)->NewByteArray(env, 2);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n+}\n+\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1pubkey_1tweak_1mul\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint publen)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  unsigned char* pkey = (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  const unsigned char* tweak = (unsigned char*) (pkey + publen);\n+\n+  jobjectArray retArray;\n+  jbyteArray pubArray, intsByteArray;\n+  unsigned char intsarray[2];\n+  unsigned char outputSer[65];\n+  size_t outputLen = 65;\n+\n+  secp256k1_pubkey pubkey;\n+  int ret = secp256k1_ec_pubkey_parse(ctx, &pubkey, pkey, publen);\n+\n+  if ( ret ) {\n+    ret = secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, tweak);\n+  }\n+\n+  if( ret ) {\n+    int ret2 = secp256k1_ec_pubkey_serialize(ctx,outputSer, &outputLen, &pubkey,SECP256K1_EC_UNCOMPRESSED );(void)ret2;\n+  }\n+\n+  intsarray[0] = outputLen;\n+  intsarray[1] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  pubArray = (*env)->NewByteArray(env, outputLen);\n+  (*env)->SetByteArrayRegion(env, pubArray, 0, outputLen, (jbyte*)outputSer);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, pubArray);\n+\n+  intsByteArray = (*env)->NewByteArray(env, 2);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n+}\n+\n+SECP256K1_API jlong JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1pubkey_1combine\n+  (JNIEnv * env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint numkeys)\n+{\n+  (void)classObject;(void)env;(void)byteBufferObject;(void)ctx_l;(void)numkeys;\n+\n+  return 0;\n+}\n+\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdh\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint publen)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  const unsigned char* secdata = (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  const unsigned char* pubdata = (const unsigned char*) (secdata + 32);\n+\n+  jobjectArray retArray;\n+  jbyteArray outArray, intsByteArray;\n+  unsigned char intsarray[1];\n+  secp256k1_pubkey pubkey;\n+  unsigned char nonce_res[32];\n+  size_t outputLen = 32;\n+\n+  int ret = secp256k1_ec_pubkey_parse(ctx, &pubkey, pubdata, publen);\n+\n+  if (ret) {\n+    ret = secp256k1_ecdh(\n+      ctx,\n+      nonce_res,\n+      &pubkey,\n+      secdata\n+    );\n+  }\n+\n+  intsarray[0] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  outArray = (*env)->NewByteArray(env, outputLen);\n+  (*env)->SetByteArrayRegion(env, outArray, 0, 32, (jbyte*)nonce_res);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, outArray);\n+\n+  intsByteArray = (*env)->NewByteArray(env, 1);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 1, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n }"
      },
      {
        "sha": "fe613c9e9e77eddb18e0b0d8422948678f3408a8",
        "filename": "src/java/org_bitcoin_NativeSecp256k1.h",
        "status": "modified",
        "additions": 101,
        "deletions": 3,
        "changes": 104,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/java/org_bitcoin_NativeSecp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/java/org_bitcoin_NativeSecp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org_bitcoin_NativeSecp256k1.h?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -1,19 +1,117 @@\n /* DO NOT EDIT THIS FILE - it is machine generated */\n #include <jni.h>\n+#include \"include/secp256k1.h\"\n /* Header for class org_bitcoin_NativeSecp256k1 */\n \n #ifndef _Included_org_bitcoin_NativeSecp256k1\n #define _Included_org_bitcoin_NativeSecp256k1\n #ifdef __cplusplus\n extern \"C\" {\n #endif\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_ctx_clone\n+ * Signature: (J)J\n+ */\n+SECP256K1_API jlong JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ctx_1clone\n+  (JNIEnv *, jclass, jlong);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_context_randomize\n+ * Signature: (Ljava/nio/ByteBuffer;J)I\n+ */\n+SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1context_1randomize\n+  (JNIEnv *, jclass, jobject, jlong);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_privkey_tweak_add\n+ * Signature: (Ljava/nio/ByteBuffer;J)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1privkey_1tweak_1add\n+  (JNIEnv *, jclass, jobject, jlong);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_privkey_tweak_mul\n+ * Signature: (Ljava/nio/ByteBuffer;J)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1privkey_1tweak_1mul\n+  (JNIEnv *, jclass, jobject, jlong);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_pubkey_tweak_add\n+ * Signature: (Ljava/nio/ByteBuffer;JI)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1pubkey_1tweak_1add\n+  (JNIEnv *, jclass, jobject, jlong, jint);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_pubkey_tweak_mul\n+ * Signature: (Ljava/nio/ByteBuffer;JI)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1pubkey_1tweak_1mul\n+  (JNIEnv *, jclass, jobject, jlong, jint);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_destroy_context\n+ * Signature: (J)V\n+ */\n+SECP256K1_API void JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1destroy_1context\n+  (JNIEnv *, jclass, jlong);\n+\n /*\n  * Class:     org_bitcoin_NativeSecp256k1\n  * Method:    secp256k1_ecdsa_verify\n- * Signature: (Ljava/nio/ByteBuffer;)I\n+ * Signature: (Ljava/nio/ByteBuffer;JII)I\n+ */\n+SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1verify\n+  (JNIEnv *, jclass, jobject, jlong, jint, jint);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_ecdsa_sign\n+ * Signature: (Ljava/nio/ByteBuffer;J)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1sign\n+  (JNIEnv *, jclass, jobject, jlong);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_ec_seckey_verify\n+ * Signature: (Ljava/nio/ByteBuffer;J)I\n+ */\n+SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1seckey_1verify\n+  (JNIEnv *, jclass, jobject, jlong);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_ec_pubkey_create\n+ * Signature: (Ljava/nio/ByteBuffer;J)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1pubkey_1create\n+  (JNIEnv *, jclass, jobject, jlong);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_ec_pubkey_parse\n+ * Signature: (Ljava/nio/ByteBuffer;JI)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1pubkey_1parse\n+  (JNIEnv *, jclass, jobject, jlong, jint);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_ecdh\n+ * Signature: (Ljava/nio/ByteBuffer;JI)[[B\n  */\n-JNIEXPORT jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1verify\n-  (JNIEnv *, jclass, jobject);\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdh\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint publen);\n+\n \n #ifdef __cplusplus\n }"
      },
      {
        "sha": "a52939e7e7dacda374ec879d69b29ebb9add2dbc",
        "filename": "src/java/org_bitcoin_Secp256k1Context.c",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/java/org_bitcoin_Secp256k1Context.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/java/org_bitcoin_Secp256k1Context.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org_bitcoin_Secp256k1Context.c?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -0,0 +1,15 @@\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include \"org_bitcoin_Secp256k1Context.h\"\n+#include \"include/secp256k1.h\"\n+\n+SECP256K1_API jlong JNICALL Java_org_bitcoin_Secp256k1Context_secp256k1_1init_1context\n+  (JNIEnv* env, jclass classObject)\n+{\n+  secp256k1_context *ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+\n+  (void)classObject;(void)env;\n+\n+  return (uintptr_t)ctx;\n+}\n+"
      },
      {
        "sha": "0d2bc84b7f3fde84f81115a037be6de105f0472b",
        "filename": "src/java/org_bitcoin_Secp256k1Context.h",
        "status": "added",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/java/org_bitcoin_Secp256k1Context.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/java/org_bitcoin_Secp256k1Context.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org_bitcoin_Secp256k1Context.h?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -0,0 +1,22 @@\n+/* DO NOT EDIT THIS FILE - it is machine generated */\n+#include <jni.h>\n+#include \"include/secp256k1.h\"\n+/* Header for class org_bitcoin_Secp256k1Context */\n+\n+#ifndef _Included_org_bitcoin_Secp256k1Context\n+#define _Included_org_bitcoin_Secp256k1Context\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+/*\n+ * Class:     org_bitcoin_Secp256k1Context\n+ * Method:    secp256k1_init_context\n+ * Signature: ()J\n+ */\n+SECP256K1_API jlong JNICALL Java_org_bitcoin_Secp256k1Context_secp256k1_1init_1context\n+  (JNIEnv *, jclass);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+#endif"
      },
      {
        "sha": "e3088b469790bdc14b8982931d5729a7eabde69b",
        "filename": "src/modules/ecdh/Makefile.am.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/modules/ecdh/Makefile.am.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/modules/ecdh/Makefile.am.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/ecdh/Makefile.am.include?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -4,5 +4,5 @@ noinst_HEADERS += src/modules/ecdh/tests_impl.h\n if USE_BENCHMARK\n noinst_PROGRAMS += bench_ecdh\n bench_ecdh_SOURCES = src/bench_ecdh.c\n-bench_ecdh_LDADD = libsecp256k1.la $(SECP_LIBS)\n+bench_ecdh_LDADD = libsecp256k1.la $(SECP_LIBS) $(COMMON_LIB)\n endif"
      },
      {
        "sha": "bf23c26e71c5dd88df965141295bb33144007147",
        "filename": "src/modules/recovery/Makefile.am.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/modules/recovery/Makefile.am.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/modules/recovery/Makefile.am.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/recovery/Makefile.am.include?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -4,5 +4,5 @@ noinst_HEADERS += src/modules/recovery/tests_impl.h\n if USE_BENCHMARK\n noinst_PROGRAMS += bench_recover\n bench_recover_SOURCES = src/bench_recover.c\n-bench_recover_LDADD = libsecp256k1.la $(SECP_LIBS)\n+bench_recover_LDADD = libsecp256k1.la $(SECP_LIBS) $(COMMON_LIB)\n endif"
      },
      {
        "sha": "86f2f0cb2b5334baf4fd34e58abe6f8fc4733e32",
        "filename": "src/modules/recovery/main_impl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/modules/recovery/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/modules/recovery/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/recovery/main_impl.h?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -138,23 +138,23 @@ int secp256k1_ecdsa_sign_recoverable(const secp256k1_context* ctx, secp256k1_ecd\n     secp256k1_scalar_set_b32(&sec, seckey, &overflow);\n     /* Fail if the secret key is invalid. */\n     if (!overflow && !secp256k1_scalar_is_zero(&sec)) {\n+        unsigned char nonce32[32];\n         unsigned int count = 0;\n         secp256k1_scalar_set_b32(&msg, msg32, NULL);\n         while (1) {\n-            unsigned char nonce32[32];\n             ret = noncefp(nonce32, msg32, seckey, NULL, (void*)noncedata, count);\n             if (!ret) {\n                 break;\n             }\n             secp256k1_scalar_set_b32(&non, nonce32, &overflow);\n-            memset(nonce32, 0, 32);\n             if (!secp256k1_scalar_is_zero(&non) && !overflow) {\n                 if (secp256k1_ecdsa_sig_sign(&ctx->ecmult_gen_ctx, &r, &s, &sec, &msg, &non, &recid)) {\n                     break;\n                 }\n             }\n             count++;\n         }\n+        memset(nonce32, 0, 32);\n         secp256k1_scalar_clear(&msg);\n         secp256k1_scalar_clear(&non);\n         secp256k1_scalar_clear(&sec);"
      },
      {
        "sha": "b3bfa7d5cc49eeecd363ff8565953e430e6898d9",
        "filename": "src/modules/schnorr/Makefile.am.include",
        "status": "removed",
        "additions": 0,
        "deletions": 10,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5ad54630935d1f340666de7bc9ffef9b8a1df296/src/modules/schnorr/Makefile.am.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5ad54630935d1f340666de7bc9ffef9b8a1df296/src/modules/schnorr/Makefile.am.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/schnorr/Makefile.am.include?ref=5ad54630935d1f340666de7bc9ffef9b8a1df296",
        "patch": "@@ -1,10 +0,0 @@\n-include_HEADERS += include/secp256k1_schnorr.h\n-noinst_HEADERS += src/modules/schnorr/main_impl.h\n-noinst_HEADERS += src/modules/schnorr/schnorr.h\n-noinst_HEADERS += src/modules/schnorr/schnorr_impl.h\n-noinst_HEADERS += src/modules/schnorr/tests_impl.h\n-if USE_BENCHMARK\n-noinst_PROGRAMS += bench_schnorr_verify\n-bench_schnorr_verify_SOURCES = src/bench_schnorr_verify.c\n-bench_schnorr_verify_LDADD = libsecp256k1.la $(SECP_LIBS)\n-endif"
      },
      {
        "sha": "fa176a1767f5f8388a4960f4eaecabbeb56a4d4a",
        "filename": "src/modules/schnorr/main_impl.h",
        "status": "removed",
        "additions": 0,
        "deletions": 164,
        "changes": 164,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5ad54630935d1f340666de7bc9ffef9b8a1df296/src/modules/schnorr/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5ad54630935d1f340666de7bc9ffef9b8a1df296/src/modules/schnorr/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/schnorr/main_impl.h?ref=5ad54630935d1f340666de7bc9ffef9b8a1df296",
        "patch": "@@ -1,164 +0,0 @@\n-/**********************************************************************\n- * Copyright (c) 2014-2015 Pieter Wuille                              *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n-\n-#ifndef SECP256K1_MODULE_SCHNORR_MAIN\n-#define SECP256K1_MODULE_SCHNORR_MAIN\n-\n-#include \"include/secp256k1_schnorr.h\"\n-#include \"modules/schnorr/schnorr_impl.h\"\n-\n-static void secp256k1_schnorr_msghash_sha256(unsigned char *h32, const unsigned char *r32, const unsigned char *msg32) {\n-    secp256k1_sha256_t sha;\n-    secp256k1_sha256_initialize(&sha);\n-    secp256k1_sha256_write(&sha, r32, 32);\n-    secp256k1_sha256_write(&sha, msg32, 32);\n-    secp256k1_sha256_finalize(&sha, h32);\n-}\n-\n-static const unsigned char secp256k1_schnorr_algo16[17] = \"Schnorr+SHA256  \";\n-\n-int secp256k1_schnorr_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void* noncedata) {\n-    secp256k1_scalar sec, non;\n-    int ret = 0;\n-    int overflow = 0;\n-    unsigned int count = 0;\n-    VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n-    ARG_CHECK(msg32 != NULL);\n-    ARG_CHECK(sig64 != NULL);\n-    ARG_CHECK(seckey != NULL);\n-    if (noncefp == NULL) {\n-        noncefp = secp256k1_nonce_function_default;\n-    }\n-\n-    secp256k1_scalar_set_b32(&sec, seckey, NULL);\n-    while (1) {\n-        unsigned char nonce32[32];\n-        ret = noncefp(nonce32, msg32, seckey, secp256k1_schnorr_algo16, (void*)noncedata, count);\n-        if (!ret) {\n-            break;\n-        }\n-        secp256k1_scalar_set_b32(&non, nonce32, &overflow);\n-        memset(nonce32, 0, 32);\n-        if (!secp256k1_scalar_is_zero(&non) && !overflow) {\n-            if (secp256k1_schnorr_sig_sign(&ctx->ecmult_gen_ctx, sig64, &sec, &non, NULL, secp256k1_schnorr_msghash_sha256, msg32)) {\n-                break;\n-            }\n-        }\n-        count++;\n-    }\n-    if (!ret) {\n-        memset(sig64, 0, 64);\n-    }\n-    secp256k1_scalar_clear(&non);\n-    secp256k1_scalar_clear(&sec);\n-    return ret;\n-}\n-\n-int secp256k1_schnorr_verify(const secp256k1_context* ctx, const unsigned char *sig64, const unsigned char *msg32, const secp256k1_pubkey *pubkey) {\n-    secp256k1_ge q;\n-    VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n-    ARG_CHECK(msg32 != NULL);\n-    ARG_CHECK(sig64 != NULL);\n-    ARG_CHECK(pubkey != NULL);\n-\n-    secp256k1_pubkey_load(ctx, &q, pubkey);\n-    return secp256k1_schnorr_sig_verify(&ctx->ecmult_ctx, sig64, &q, secp256k1_schnorr_msghash_sha256, msg32);\n-}\n-\n-int secp256k1_schnorr_recover(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const unsigned char *sig64, const unsigned char *msg32) {\n-    secp256k1_ge q;\n-\n-    VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n-    ARG_CHECK(msg32 != NULL);\n-    ARG_CHECK(sig64 != NULL);\n-    ARG_CHECK(pubkey != NULL);\n-\n-    if (secp256k1_schnorr_sig_recover(&ctx->ecmult_ctx, sig64, &q, secp256k1_schnorr_msghash_sha256, msg32)) {\n-        secp256k1_pubkey_save(pubkey, &q);\n-        return 1;\n-    } else {\n-        memset(pubkey, 0, sizeof(*pubkey));\n-        return 0;\n-    }\n-}\n-\n-int secp256k1_schnorr_generate_nonce_pair(const secp256k1_context* ctx, secp256k1_pubkey *pubnonce, unsigned char *privnonce32, const unsigned char *sec32, const unsigned char *msg32, secp256k1_nonce_function noncefp, const void* noncedata) {\n-    int count = 0;\n-    int ret = 1;\n-    secp256k1_gej Qj;\n-    secp256k1_ge Q;\n-    secp256k1_scalar sec;\n-\n-    VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n-    ARG_CHECK(msg32 != NULL);\n-    ARG_CHECK(sec32 != NULL);\n-    ARG_CHECK(pubnonce != NULL);\n-    ARG_CHECK(privnonce32 != NULL);\n-\n-    if (noncefp == NULL) {\n-        noncefp = secp256k1_nonce_function_default;\n-    }\n-\n-    do {\n-        int overflow;\n-        ret = noncefp(privnonce32, sec32, msg32, secp256k1_schnorr_algo16, (void*)noncedata, count++);\n-        if (!ret) {\n-            break;\n-        }\n-        secp256k1_scalar_set_b32(&sec, privnonce32, &overflow);\n-        if (overflow || secp256k1_scalar_is_zero(&sec)) {\n-            continue;\n-        }\n-        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &Qj, &sec);\n-        secp256k1_ge_set_gej(&Q, &Qj);\n-\n-        secp256k1_pubkey_save(pubnonce, &Q);\n-        break;\n-    } while(1);\n-\n-    secp256k1_scalar_clear(&sec);\n-    if (!ret) {\n-        memset(pubnonce, 0, sizeof(*pubnonce));\n-    }\n-    return ret;\n-}\n-\n-int secp256k1_schnorr_partial_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const unsigned char *sec32, const secp256k1_pubkey *pubnonce_others, const unsigned char *secnonce32) {\n-    int overflow = 0;\n-    secp256k1_scalar sec, non;\n-    secp256k1_ge pubnon;\n-    VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n-    ARG_CHECK(msg32 != NULL);\n-    ARG_CHECK(sig64 != NULL);\n-    ARG_CHECK(sec32 != NULL);\n-    ARG_CHECK(secnonce32 != NULL);\n-    ARG_CHECK(pubnonce_others != NULL);\n-\n-    secp256k1_scalar_set_b32(&sec, sec32, &overflow);\n-    if (overflow || secp256k1_scalar_is_zero(&sec)) {\n-        return -1;\n-    }\n-    secp256k1_scalar_set_b32(&non, secnonce32, &overflow);\n-    if (overflow || secp256k1_scalar_is_zero(&non)) {\n-        return -1;\n-    }\n-    secp256k1_pubkey_load(ctx, &pubnon, pubnonce_others);\n-    return secp256k1_schnorr_sig_sign(&ctx->ecmult_gen_ctx, sig64, &sec, &non, &pubnon, secp256k1_schnorr_msghash_sha256, msg32);\n-}\n-\n-int secp256k1_schnorr_partial_combine(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char * const *sig64sin, size_t n) {\n-    ARG_CHECK(sig64 != NULL);\n-    ARG_CHECK(n >= 1);\n-    ARG_CHECK(sig64sin != NULL);\n-    return secp256k1_schnorr_sig_combine(sig64, n, sig64sin);\n-}\n-\n-#endif"
      },
      {
        "sha": "de18147bd52ac0f70369114dfcb06947730cbaac",
        "filename": "src/modules/schnorr/schnorr.h",
        "status": "removed",
        "additions": 0,
        "deletions": 20,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5ad54630935d1f340666de7bc9ffef9b8a1df296/src/modules/schnorr/schnorr.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5ad54630935d1f340666de7bc9ffef9b8a1df296/src/modules/schnorr/schnorr.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/schnorr/schnorr.h?ref=5ad54630935d1f340666de7bc9ffef9b8a1df296",
        "patch": "@@ -1,20 +0,0 @@\n-/***********************************************************************\n- * Copyright (c) 2014-2015 Pieter Wuille                               *\n- * Distributed under the MIT software license, see the accompanying    *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php. *\n- ***********************************************************************/\n-\n-#ifndef _SECP256K1_MODULE_SCHNORR_H_\n-#define _SECP256K1_MODULE_SCHNORR_H_\n-\n-#include \"scalar.h\"\n-#include \"group.h\"\n-\n-typedef void (*secp256k1_schnorr_msghash)(unsigned char *h32, const unsigned char *r32, const unsigned char *msg32);\n-\n-static int secp256k1_schnorr_sig_sign(const secp256k1_ecmult_gen_context* ctx, unsigned char *sig64, const secp256k1_scalar *key, const secp256k1_scalar *nonce, const secp256k1_ge *pubnonce, secp256k1_schnorr_msghash hash, const unsigned char *msg32);\n-static int secp256k1_schnorr_sig_verify(const secp256k1_ecmult_context* ctx, const unsigned char *sig64, const secp256k1_ge *pubkey, secp256k1_schnorr_msghash hash, const unsigned char *msg32);\n-static int secp256k1_schnorr_sig_recover(const secp256k1_ecmult_context* ctx, const unsigned char *sig64, secp256k1_ge *pubkey, secp256k1_schnorr_msghash hash, const unsigned char *msg32);\n-static int secp256k1_schnorr_sig_combine(unsigned char *sig64, size_t n, const unsigned char * const *sig64ins);\n-\n-#endif"
      },
      {
        "sha": "e13ab6db7cca1173582c47597d42fb916f43fc22",
        "filename": "src/modules/schnorr/schnorr_impl.h",
        "status": "removed",
        "additions": 0,
        "deletions": 207,
        "changes": 207,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5ad54630935d1f340666de7bc9ffef9b8a1df296/src/modules/schnorr/schnorr_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5ad54630935d1f340666de7bc9ffef9b8a1df296/src/modules/schnorr/schnorr_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/schnorr/schnorr_impl.h?ref=5ad54630935d1f340666de7bc9ffef9b8a1df296",
        "patch": "@@ -1,207 +0,0 @@\n-/***********************************************************************\n- * Copyright (c) 2014-2015 Pieter Wuille                               *\n- * Distributed under the MIT software license, see the accompanying    *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php. *\n- ***********************************************************************/\n-\n-#ifndef _SECP256K1_SCHNORR_IMPL_H_\n-#define _SECP256K1_SCHNORR_IMPL_H_\n-\n-#include <string.h>\n-\n-#include \"schnorr.h\"\n-#include \"num.h\"\n-#include \"field.h\"\n-#include \"group.h\"\n-#include \"ecmult.h\"\n-#include \"ecmult_gen.h\"\n-\n-/**\n- * Custom Schnorr-based signature scheme. They support multiparty signing, public key\n- * recovery and batch validation.\n- *\n- * Rationale for verifying R's y coordinate:\n- * In order to support batch validation and public key recovery, the full R point must\n- * be known to verifiers, rather than just its x coordinate. In order to not risk\n- * being more strict in batch validation than normal validation, validators must be\n- * required to reject signatures with incorrect y coordinate. This is only possible\n- * by including a (relatively slow) field inverse, or a field square root. However,\n- * batch validation offers potentially much higher benefits than this cost.\n- *\n- * Rationale for having an implicit y coordinate oddness:\n- * If we commit to having the full R point known to verifiers, there are two mechanism.\n- * Either include its oddness in the signature, or give it an implicit fixed value.\n- * As the R y coordinate can be flipped by a simple negation of the nonce, we choose the\n- * latter, as it comes with nearly zero impact on signing or validation performance, and\n- * saves a byte in the signature.\n- *\n- * Signing:\n- *   Inputs: 32-byte message m, 32-byte scalar key x (!=0), 32-byte scalar nonce k (!=0)\n- *\n- *   Compute point R = k * G. Reject nonce if R's y coordinate is odd (or negate nonce).\n- *   Compute 32-byte r, the serialization of R's x coordinate.\n- *   Compute scalar h = Hash(r || m). Reject nonce if h == 0 or h >= order.\n- *   Compute scalar s = k - h * x.\n- *   The signature is (r, s).\n- *\n- *\n- * Verification:\n- *   Inputs: 32-byte message m, public key point Q, signature: (32-byte r, scalar s)\n- *\n- *   Signature is invalid if s >= order.\n- *   Signature is invalid if r >= p.\n- *   Compute scalar h = Hash(r || m). Signature is invalid if h == 0 or h >= order.\n- *   Option 1 (faster for single verification):\n- *     Compute point R = h * Q + s * G. Signature is invalid if R is infinity or R's y coordinate is odd.\n- *     Signature is valid if the serialization of R's x coordinate equals r.\n- *   Option 2 (allows batch validation and pubkey recovery):\n- *     Decompress x coordinate r into point R, with odd y coordinate. Fail if R is not on the curve.\n- *     Signature is valid if R + h * Q + s * G == 0.\n- */\n-\n-static int secp256k1_schnorr_sig_sign(const secp256k1_ecmult_gen_context* ctx, unsigned char *sig64, const secp256k1_scalar *key, const secp256k1_scalar *nonce, const secp256k1_ge *pubnonce, secp256k1_schnorr_msghash hash, const unsigned char *msg32) {\n-    secp256k1_gej Rj;\n-    secp256k1_ge Ra;\n-    unsigned char h32[32];\n-    secp256k1_scalar h, s;\n-    int overflow;\n-    secp256k1_scalar n;\n-\n-    if (secp256k1_scalar_is_zero(key) || secp256k1_scalar_is_zero(nonce)) {\n-        return 0;\n-    }\n-    n = *nonce;\n-\n-    secp256k1_ecmult_gen(ctx, &Rj, &n);\n-    if (pubnonce != NULL) {\n-        secp256k1_gej_add_ge(&Rj, &Rj, pubnonce);\n-    }\n-    secp256k1_ge_set_gej(&Ra, &Rj);\n-    secp256k1_fe_normalize(&Ra.y);\n-    if (secp256k1_fe_is_odd(&Ra.y)) {\n-        /* R's y coordinate is odd, which is not allowed (see rationale above).\n-           Force it to be even by negating the nonce. Note that this even works\n-           for multiparty signing, as the R point is known to all participants,\n-           which can all decide to flip the sign in unison, resulting in the\n-           overall R point to be negated too. */\n-        secp256k1_scalar_negate(&n, &n);\n-    }\n-    secp256k1_fe_normalize(&Ra.x);\n-    secp256k1_fe_get_b32(sig64, &Ra.x);\n-    hash(h32, sig64, msg32);\n-    overflow = 0;\n-    secp256k1_scalar_set_b32(&h, h32, &overflow);\n-    if (overflow || secp256k1_scalar_is_zero(&h)) {\n-        secp256k1_scalar_clear(&n);\n-        return 0;\n-    }\n-    secp256k1_scalar_mul(&s, &h, key);\n-    secp256k1_scalar_negate(&s, &s);\n-    secp256k1_scalar_add(&s, &s, &n);\n-    secp256k1_scalar_clear(&n);\n-    secp256k1_scalar_get_b32(sig64 + 32, &s);\n-    return 1;\n-}\n-\n-static int secp256k1_schnorr_sig_verify(const secp256k1_ecmult_context* ctx, const unsigned char *sig64, const secp256k1_ge *pubkey, secp256k1_schnorr_msghash hash, const unsigned char *msg32) {\n-    secp256k1_gej Qj, Rj;\n-    secp256k1_ge Ra;\n-    secp256k1_fe Rx;\n-    secp256k1_scalar h, s;\n-    unsigned char hh[32];\n-    int overflow;\n-\n-    if (secp256k1_ge_is_infinity(pubkey)) {\n-        return 0;\n-    }\n-    hash(hh, sig64, msg32);\n-    overflow = 0;\n-    secp256k1_scalar_set_b32(&h, hh, &overflow);\n-    if (overflow || secp256k1_scalar_is_zero(&h)) {\n-        return 0;\n-    }\n-    overflow = 0;\n-    secp256k1_scalar_set_b32(&s, sig64 + 32, &overflow);\n-    if (overflow) {\n-        return 0;\n-    }\n-    if (!secp256k1_fe_set_b32(&Rx, sig64)) {\n-        return 0;\n-    }\n-    secp256k1_gej_set_ge(&Qj, pubkey);\n-    secp256k1_ecmult(ctx, &Rj, &Qj, &h, &s);\n-    if (secp256k1_gej_is_infinity(&Rj)) {\n-        return 0;\n-    }\n-    secp256k1_ge_set_gej_var(&Ra, &Rj);\n-    secp256k1_fe_normalize_var(&Ra.y);\n-    if (secp256k1_fe_is_odd(&Ra.y)) {\n-        return 0;\n-    }\n-    return secp256k1_fe_equal_var(&Rx, &Ra.x);\n-}\n-\n-static int secp256k1_schnorr_sig_recover(const secp256k1_ecmult_context* ctx, const unsigned char *sig64, secp256k1_ge *pubkey, secp256k1_schnorr_msghash hash, const unsigned char *msg32) {\n-    secp256k1_gej Qj, Rj;\n-    secp256k1_ge Ra;\n-    secp256k1_fe Rx;\n-    secp256k1_scalar h, s;\n-    unsigned char hh[32];\n-    int overflow;\n-\n-    hash(hh, sig64, msg32);\n-    overflow = 0;\n-    secp256k1_scalar_set_b32(&h, hh, &overflow);\n-    if (overflow || secp256k1_scalar_is_zero(&h)) {\n-        return 0;\n-    }\n-    overflow = 0;\n-    secp256k1_scalar_set_b32(&s, sig64 + 32, &overflow);\n-    if (overflow) {\n-        return 0;\n-    }\n-    if (!secp256k1_fe_set_b32(&Rx, sig64)) {\n-        return 0;\n-    }\n-    if (!secp256k1_ge_set_xo_var(&Ra, &Rx, 0)) {\n-        return 0;\n-    }\n-    secp256k1_gej_set_ge(&Rj, &Ra);\n-    secp256k1_scalar_inverse_var(&h, &h);\n-    secp256k1_scalar_negate(&s, &s);\n-    secp256k1_scalar_mul(&s, &s, &h);\n-    secp256k1_ecmult(ctx, &Qj, &Rj, &h, &s);\n-    if (secp256k1_gej_is_infinity(&Qj)) {\n-        return 0;\n-    }\n-    secp256k1_ge_set_gej(pubkey, &Qj);\n-    return 1;\n-}\n-\n-static int secp256k1_schnorr_sig_combine(unsigned char *sig64, size_t n, const unsigned char * const *sig64ins) {\n-    secp256k1_scalar s = SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 0);\n-    size_t i;\n-    for (i = 0; i < n; i++) {\n-        secp256k1_scalar si;\n-        int overflow;\n-        secp256k1_scalar_set_b32(&si, sig64ins[i] + 32, &overflow);\n-        if (overflow) {\n-            return -1;\n-        }\n-        if (i) {\n-            if (memcmp(sig64ins[i - 1], sig64ins[i], 32) != 0) {\n-                return -1;\n-            }\n-        }\n-        secp256k1_scalar_add(&s, &s, &si);\n-    }\n-    if (secp256k1_scalar_is_zero(&s)) {\n-        return 0;\n-    }\n-    memcpy(sig64, sig64ins[0], 32);\n-    secp256k1_scalar_get_b32(sig64 + 32, &s);\n-    secp256k1_scalar_clear(&s);\n-    return 1;\n-}\n-\n-#endif"
      },
      {
        "sha": "5bd14a03e3c65ba99c27e6694352bf9e4d9ab1cd",
        "filename": "src/modules/schnorr/tests_impl.h",
        "status": "removed",
        "additions": 0,
        "deletions": 175,
        "changes": 175,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5ad54630935d1f340666de7bc9ffef9b8a1df296/src/modules/schnorr/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5ad54630935d1f340666de7bc9ffef9b8a1df296/src/modules/schnorr/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/schnorr/tests_impl.h?ref=5ad54630935d1f340666de7bc9ffef9b8a1df296",
        "patch": "@@ -1,175 +0,0 @@\n-/**********************************************************************\n- * Copyright (c) 2014-2015 Pieter Wuille                              *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n-\n-#ifndef SECP256K1_MODULE_SCHNORR_TESTS\n-#define SECP256K1_MODULE_SCHNORR_TESTS\n-\n-#include \"include/secp256k1_schnorr.h\"\n-\n-void test_schnorr_end_to_end(void) {\n-    unsigned char privkey[32];\n-    unsigned char message[32];\n-    unsigned char schnorr_signature[64];\n-    secp256k1_pubkey pubkey, recpubkey;\n-\n-    /* Generate a random key and message. */\n-    {\n-        secp256k1_scalar key;\n-        random_scalar_order_test(&key);\n-        secp256k1_scalar_get_b32(privkey, &key);\n-        secp256k1_rand256_test(message);\n-    }\n-\n-    /* Construct and verify corresponding public key. */\n-    CHECK(secp256k1_ec_seckey_verify(ctx, privkey) == 1);\n-    CHECK(secp256k1_ec_pubkey_create(ctx, &pubkey, privkey) == 1);\n-\n-    /* Schnorr sign. */\n-    CHECK(secp256k1_schnorr_sign(ctx, schnorr_signature, message, privkey, NULL, NULL) == 1);\n-    CHECK(secp256k1_schnorr_verify(ctx, schnorr_signature, message, &pubkey) == 1);\n-    CHECK(secp256k1_schnorr_recover(ctx, &recpubkey, schnorr_signature, message) == 1);\n-    CHECK(memcmp(&pubkey, &recpubkey, sizeof(pubkey)) == 0);\n-    /* Destroy signature and verify again. */\n-    schnorr_signature[secp256k1_rand_bits(6)] += 1 + secp256k1_rand_int(255);\n-    CHECK(secp256k1_schnorr_verify(ctx, schnorr_signature, message, &pubkey) == 0);\n-    CHECK(secp256k1_schnorr_recover(ctx, &recpubkey, schnorr_signature, message) != 1 ||\n-          memcmp(&pubkey, &recpubkey, sizeof(pubkey)) != 0);\n-}\n-\n-/** Horribly broken hash function. Do not use for anything but tests. */\n-void test_schnorr_hash(unsigned char *h32, const unsigned char *r32, const unsigned char *msg32) {\n-    int i;\n-    for (i = 0; i < 32; i++) {\n-        h32[i] = r32[i] ^ msg32[i];\n-    }\n-}\n-\n-void test_schnorr_sign_verify(void) {\n-    unsigned char msg32[32];\n-    unsigned char sig64[3][64];\n-    secp256k1_gej pubkeyj[3];\n-    secp256k1_ge pubkey[3];\n-    secp256k1_scalar nonce[3], key[3];\n-    int i = 0;\n-    int k;\n-\n-    secp256k1_rand256_test(msg32);\n-\n-    for (k = 0; k < 3; k++) {\n-        random_scalar_order_test(&key[k]);\n-\n-        do {\n-            random_scalar_order_test(&nonce[k]);\n-            if (secp256k1_schnorr_sig_sign(&ctx->ecmult_gen_ctx, sig64[k], &key[k], &nonce[k], NULL, &test_schnorr_hash, msg32)) {\n-                break;\n-            }\n-        } while(1);\n-\n-        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pubkeyj[k], &key[k]);\n-        secp256k1_ge_set_gej_var(&pubkey[k], &pubkeyj[k]);\n-        CHECK(secp256k1_schnorr_sig_verify(&ctx->ecmult_ctx, sig64[k], &pubkey[k], &test_schnorr_hash, msg32));\n-\n-        for (i = 0; i < 4; i++) {\n-            int pos = secp256k1_rand_bits(6);\n-            int mod = 1 + secp256k1_rand_int(255);\n-            sig64[k][pos] ^= mod;\n-            CHECK(secp256k1_schnorr_sig_verify(&ctx->ecmult_ctx, sig64[k], &pubkey[k], &test_schnorr_hash, msg32) == 0);\n-            sig64[k][pos] ^= mod;\n-        }\n-    }\n-}\n-\n-void test_schnorr_threshold(void) {\n-    unsigned char msg[32];\n-    unsigned char sec[5][32];\n-    secp256k1_pubkey pub[5];\n-    unsigned char nonce[5][32];\n-    secp256k1_pubkey pubnonce[5];\n-    unsigned char sig[5][64];\n-    const unsigned char* sigs[5];\n-    unsigned char allsig[64];\n-    const secp256k1_pubkey* pubs[5];\n-    secp256k1_pubkey allpub;\n-    int n, i;\n-    int damage;\n-    int ret = 0;\n-\n-    damage = secp256k1_rand_bits(1) ? (1 + secp256k1_rand_int(4)) : 0;\n-    secp256k1_rand256_test(msg);\n-    n = 2 + secp256k1_rand_int(4);\n-    for (i = 0; i < n; i++) {\n-        do {\n-            secp256k1_rand256_test(sec[i]);\n-        } while (!secp256k1_ec_seckey_verify(ctx, sec[i]));\n-        CHECK(secp256k1_ec_pubkey_create(ctx, &pub[i], sec[i]));\n-        CHECK(secp256k1_schnorr_generate_nonce_pair(ctx, &pubnonce[i], nonce[i], msg, sec[i], NULL, NULL));\n-        pubs[i] = &pub[i];\n-    }\n-    if (damage == 1) {\n-        nonce[secp256k1_rand_int(n)][secp256k1_rand_int(32)] ^= 1 + secp256k1_rand_int(255);\n-    } else if (damage == 2) {\n-        sec[secp256k1_rand_int(n)][secp256k1_rand_int(32)] ^= 1 + secp256k1_rand_int(255);\n-    }\n-    for (i = 0; i < n; i++) {\n-        secp256k1_pubkey allpubnonce;\n-        const secp256k1_pubkey *pubnonces[4];\n-        int j;\n-        for (j = 0; j < i; j++) {\n-            pubnonces[j] = &pubnonce[j];\n-        }\n-        for (j = i + 1; j < n; j++) {\n-            pubnonces[j - 1] = &pubnonce[j];\n-        }\n-        CHECK(secp256k1_ec_pubkey_combine(ctx, &allpubnonce, pubnonces, n - 1));\n-        ret |= (secp256k1_schnorr_partial_sign(ctx, sig[i], msg, sec[i], &allpubnonce, nonce[i]) != 1) * 1;\n-        sigs[i] = sig[i];\n-    }\n-    if (damage == 3) {\n-        sig[secp256k1_rand_int(n)][secp256k1_rand_bits(6)] ^= 1 + secp256k1_rand_int(255);\n-    }\n-    ret |= (secp256k1_ec_pubkey_combine(ctx, &allpub, pubs, n) != 1) * 2;\n-    if ((ret & 1) == 0) {\n-        ret |= (secp256k1_schnorr_partial_combine(ctx, allsig, sigs, n) != 1) * 4;\n-    }\n-    if (damage == 4) {\n-        allsig[secp256k1_rand_int(32)] ^= 1 + secp256k1_rand_int(255);\n-    }\n-    if ((ret & 7) == 0) {\n-        ret |= (secp256k1_schnorr_verify(ctx, allsig, msg, &allpub) != 1) * 8;\n-    }\n-    CHECK((ret == 0) == (damage == 0));\n-}\n-\n-void test_schnorr_recovery(void) {\n-    unsigned char msg32[32];\n-    unsigned char sig64[64];\n-    secp256k1_ge Q;\n-\n-    secp256k1_rand256_test(msg32);\n-    secp256k1_rand256_test(sig64);\n-    secp256k1_rand256_test(sig64 + 32);\n-    if (secp256k1_schnorr_sig_recover(&ctx->ecmult_ctx, sig64, &Q, &test_schnorr_hash, msg32) == 1) {\n-        CHECK(secp256k1_schnorr_sig_verify(&ctx->ecmult_ctx, sig64, &Q, &test_schnorr_hash, msg32) == 1);\n-    }\n-}\n-\n-void run_schnorr_tests(void) {\n-    int i;\n-    for (i = 0; i < 32*count; i++) {\n-        test_schnorr_end_to_end();\n-    }\n-    for (i = 0; i < 32 * count; i++) {\n-         test_schnorr_sign_verify();\n-    }\n-    for (i = 0; i < 16 * count; i++) {\n-         test_schnorr_recovery();\n-    }\n-    for (i = 0; i < 10 * count; i++) {\n-         test_schnorr_threshold();\n-    }\n-}\n-\n-#endif"
      },
      {
        "sha": "7bb9c5be8cf5a6d020ef4bfcac1af13902e5d533",
        "filename": "src/num.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/num.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/num.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/num.h?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -32,6 +32,9 @@ static void secp256k1_num_set_bin(secp256k1_num *r, const unsigned char *a, unsi\n /** Compute a modular inverse. The input must be less than the modulus. */\n static void secp256k1_num_mod_inverse(secp256k1_num *r, const secp256k1_num *a, const secp256k1_num *m);\n \n+/** Compute the jacobi symbol (a|b). b must be positive and odd. */\n+static int secp256k1_num_jacobi(const secp256k1_num *a, const secp256k1_num *b);\n+\n /** Compare the absolute value of two numbers. */\n static int secp256k1_num_cmp(const secp256k1_num *a, const secp256k1_num *b);\n \n@@ -57,6 +60,9 @@ static void secp256k1_num_shift(secp256k1_num *r, int bits);\n /** Check whether a number is zero. */\n static int secp256k1_num_is_zero(const secp256k1_num *a);\n \n+/** Check whether a number is one. */\n+static int secp256k1_num_is_one(const secp256k1_num *a);\n+\n /** Check whether a number is strictly negative. */\n static int secp256k1_num_is_neg(const secp256k1_num *a);\n "
      },
      {
        "sha": "3a46495eeac7d979a87871ca20ce30c2010a54ce",
        "filename": "src/num_gmp_impl.h",
        "status": "modified",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/num_gmp_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/num_gmp_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/num_gmp_impl.h?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -144,6 +144,32 @@ static void secp256k1_num_mod_inverse(secp256k1_num *r, const secp256k1_num *a,\n     memset(v, 0, sizeof(v));\n }\n \n+static int secp256k1_num_jacobi(const secp256k1_num *a, const secp256k1_num *b) {\n+    int ret;\n+    mpz_t ga, gb;\n+    secp256k1_num_sanity(a);\n+    secp256k1_num_sanity(b);\n+    VERIFY_CHECK(!b->neg && (b->limbs > 0) && (b->data[0] & 1));\n+\n+    mpz_inits(ga, gb, NULL);\n+\n+    mpz_import(gb, b->limbs, -1, sizeof(mp_limb_t), 0, 0, b->data);\n+    mpz_import(ga, a->limbs, -1, sizeof(mp_limb_t), 0, 0, a->data);\n+    if (a->neg) {\n+        mpz_neg(ga, ga);\n+    }\n+\n+    ret = mpz_jacobi(ga, gb);\n+\n+    mpz_clears(ga, gb, NULL);\n+\n+    return ret;\n+}\n+\n+static int secp256k1_num_is_one(const secp256k1_num *a) {\n+    return (a->limbs == 1 && a->data[0] == 1);\n+}\n+\n static int secp256k1_num_is_zero(const secp256k1_num *a) {\n     return (a->limbs == 1 && a->data[0] == 0);\n }"
      },
      {
        "sha": "27e9d8375e8b0dc9977d8b037fb1b4344d027d4c",
        "filename": "src/scalar.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/scalar.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/scalar.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar.h?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -13,7 +13,9 @@\n #include \"libsecp256k1-config.h\"\n #endif\n \n-#if defined(USE_SCALAR_4X64)\n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+#include \"scalar_low.h\"\n+#elif defined(USE_SCALAR_4X64)\n #include \"scalar_4x64.h\"\n #elif defined(USE_SCALAR_8X32)\n #include \"scalar_8x32.h\""
      },
      {
        "sha": "56e7bd82afd630b107c080b5c96cf50cdbb722f9",
        "filename": "src/scalar_4x64_impl.h",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/scalar_4x64_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/scalar_4x64_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_4x64_impl.h?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -282,16 +282,16 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     \"movq 56(%%rsi), %%r14\\n\"\n     /* Initialize r8,r9,r10 */\n     \"movq 0(%%rsi), %%r8\\n\"\n-    \"movq $0, %%r9\\n\"\n-    \"movq $0, %%r10\\n\"\n+    \"xorq %%r9, %%r9\\n\"\n+    \"xorq %%r10, %%r10\\n\"\n     /* (r8,r9) += n0 * c0 */\n     \"movq %8, %%rax\\n\"\n     \"mulq %%r11\\n\"\n     \"addq %%rax, %%r8\\n\"\n     \"adcq %%rdx, %%r9\\n\"\n     /* extract m0 */\n     \"movq %%r8, %q0\\n\"\n-    \"movq $0, %%r8\\n\"\n+    \"xorq %%r8, %%r8\\n\"\n     /* (r9,r10) += l1 */\n     \"addq 8(%%rsi), %%r9\\n\"\n     \"adcq $0, %%r10\\n\"\n@@ -309,7 +309,7 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     \"adcq $0, %%r8\\n\"\n     /* extract m1 */\n     \"movq %%r9, %q1\\n\"\n-    \"movq $0, %%r9\\n\"\n+    \"xorq %%r9, %%r9\\n\"\n     /* (r10,r8,r9) += l2 */\n     \"addq 16(%%rsi), %%r10\\n\"\n     \"adcq $0, %%r8\\n\"\n@@ -332,7 +332,7 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     \"adcq $0, %%r9\\n\"\n     /* extract m2 */\n     \"movq %%r10, %q2\\n\"\n-    \"movq $0, %%r10\\n\"\n+    \"xorq %%r10, %%r10\\n\"\n     /* (r8,r9,r10) += l3 */\n     \"addq 24(%%rsi), %%r8\\n\"\n     \"adcq $0, %%r9\\n\"\n@@ -355,7 +355,7 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     \"adcq $0, %%r10\\n\"\n     /* extract m3 */\n     \"movq %%r8, %q3\\n\"\n-    \"movq $0, %%r8\\n\"\n+    \"xorq %%r8, %%r8\\n\"\n     /* (r9,r10,r8) += n3 * c1 */\n     \"movq %9, %%rax\\n\"\n     \"mulq %%r14\\n\"\n@@ -387,16 +387,16 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     \"movq %q11, %%r13\\n\"\n     /* Initialize (r8,r9,r10) */\n     \"movq %q5, %%r8\\n\"\n-    \"movq $0, %%r9\\n\"\n-    \"movq $0, %%r10\\n\"\n+    \"xorq %%r9, %%r9\\n\"\n+    \"xorq %%r10, %%r10\\n\"\n     /* (r8,r9) += m4 * c0 */\n     \"movq %12, %%rax\\n\"\n     \"mulq %%r11\\n\"\n     \"addq %%rax, %%r8\\n\"\n     \"adcq %%rdx, %%r9\\n\"\n     /* extract p0 */\n     \"movq %%r8, %q0\\n\"\n-    \"movq $0, %%r8\\n\"\n+    \"xorq %%r8, %%r8\\n\"\n     /* (r9,r10) += m1 */\n     \"addq %q6, %%r9\\n\"\n     \"adcq $0, %%r10\\n\"\n@@ -414,7 +414,7 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     \"adcq $0, %%r8\\n\"\n     /* extract p1 */\n     \"movq %%r9, %q1\\n\"\n-    \"movq $0, %%r9\\n\"\n+    \"xorq %%r9, %%r9\\n\"\n     /* (r10,r8,r9) += m2 */\n     \"addq %q7, %%r10\\n\"\n     \"adcq $0, %%r8\\n\"\n@@ -472,7 +472,7 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     \"movq %%rax, 0(%q6)\\n\"\n     /* Move to (r8,r9) */\n     \"movq %%rdx, %%r8\\n\"\n-    \"movq $0, %%r9\\n\"\n+    \"xorq %%r9, %%r9\\n\"\n     /* (r8,r9) += p1 */\n     \"addq %q2, %%r8\\n\"\n     \"adcq $0, %%r9\\n\"\n@@ -483,7 +483,7 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     \"adcq %%rdx, %%r9\\n\"\n     /* Extract r1 */\n     \"movq %%r8, 8(%q6)\\n\"\n-    \"movq $0, %%r8\\n\"\n+    \"xorq %%r8, %%r8\\n\"\n     /* (r9,r8) += p4 */\n     \"addq %%r10, %%r9\\n\"\n     \"adcq $0, %%r8\\n\"\n@@ -492,7 +492,7 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     \"adcq $0, %%r8\\n\"\n     /* Extract r2 */\n     \"movq %%r9, 16(%q6)\\n\"\n-    \"movq $0, %%r9\\n\"\n+    \"xorq %%r9, %%r9\\n\"\n     /* (r8,r9) += p3 */\n     \"addq %q4, %%r8\\n\"\n     \"adcq $0, %%r9\\n\""
      },
      {
        "sha": "f5b2376407bd3b2338e26b1a0bb84cd3fc91660b",
        "filename": "src/scalar_impl.h",
        "status": "modified",
        "additions": 37,
        "deletions": 4,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/scalar_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/scalar_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_impl.h?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -7,16 +7,16 @@\n #ifndef _SECP256K1_SCALAR_IMPL_H_\n #define _SECP256K1_SCALAR_IMPL_H_\n \n-#include <string.h>\n-\n #include \"group.h\"\n #include \"scalar.h\"\n \n #if defined HAVE_CONFIG_H\n #include \"libsecp256k1-config.h\"\n #endif\n \n-#if defined(USE_SCALAR_4X64)\n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+#include \"scalar_low_impl.h\"\n+#elif defined(USE_SCALAR_4X64)\n #include \"scalar_4x64_impl.h\"\n #elif defined(USE_SCALAR_8X32)\n #include \"scalar_8x32_impl.h\"\n@@ -33,17 +33,37 @@ static void secp256k1_scalar_get_num(secp256k1_num *r, const secp256k1_scalar *a\n \n /** secp256k1 curve order, see secp256k1_ecdsa_const_order_as_fe in ecdsa_impl.h */\n static void secp256k1_scalar_order_get_num(secp256k1_num *r) {\n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+    static const unsigned char order[32] = {\n+        0,0,0,0,0,0,0,0,\n+        0,0,0,0,0,0,0,0,\n+        0,0,0,0,0,0,0,0,\n+        0,0,0,0,0,0,0,EXHAUSTIVE_TEST_ORDER\n+    };\n+#else\n     static const unsigned char order[32] = {\n         0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n         0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,\n         0xBA,0xAE,0xDC,0xE6,0xAF,0x48,0xA0,0x3B,\n         0xBF,0xD2,0x5E,0x8C,0xD0,0x36,0x41,0x41\n     };\n+#endif\n     secp256k1_num_set_bin(r, order, 32);\n }\n #endif\n \n static void secp256k1_scalar_inverse(secp256k1_scalar *r, const secp256k1_scalar *x) {\n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+    int i;\n+    *r = 0;\n+    for (i = 0; i < EXHAUSTIVE_TEST_ORDER; i++)\n+        if ((i * *x) % EXHAUSTIVE_TEST_ORDER == 1)\n+            *r = i;\n+    /* If this VERIFY_CHECK triggers we were given a noninvertible scalar (and thus\n+     * have a composite group order; fix it in exhaustive_tests.c). */\n+    VERIFY_CHECK(*r != 0);\n+}\n+#else\n     secp256k1_scalar *t;\n     int i;\n     /* First compute x ^ (2^N - 1) for some values of N. */\n@@ -235,9 +255,9 @@ static void secp256k1_scalar_inverse(secp256k1_scalar *r, const secp256k1_scalar\n }\n \n SECP256K1_INLINE static int secp256k1_scalar_is_even(const secp256k1_scalar *a) {\n-    /* d[0] is present and is the lowest word for all representations */\n     return !(a->d[0] & 1);\n }\n+#endif\n \n static void secp256k1_scalar_inverse_var(secp256k1_scalar *r, const secp256k1_scalar *x) {\n #if defined(USE_SCALAR_INV_BUILTIN)\n@@ -261,6 +281,18 @@ static void secp256k1_scalar_inverse_var(secp256k1_scalar *r, const secp256k1_sc\n }\n \n #ifdef USE_ENDOMORPHISM\n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/**\n+ * Find k1 and k2 given k, such that k1 + k2 * lambda == k mod n; unlike in the\n+ * full case we don't bother making k1 and k2 be small, we just want them to be\n+ * nontrivial to get full test coverage for the exhaustive tests. We therefore\n+ * (arbitrarily) set k2 = k + 5 and k1 = k - k2 * lambda.\n+ */\n+static void secp256k1_scalar_split_lambda(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *a) {\n+    *r2 = (*a + 5) % EXHAUSTIVE_TEST_ORDER;\n+    *r1 = (*a + (EXHAUSTIVE_TEST_ORDER - *r2) * EXHAUSTIVE_TEST_LAMBDA) % EXHAUSTIVE_TEST_ORDER;\n+}\n+#else\n /**\n  * The Secp256k1 curve has an endomorphism, where lambda * (x, y) = (beta * x, y), where\n  * lambda is {0x53,0x63,0xad,0x4c,0xc0,0x5c,0x30,0xe0,0xa5,0x26,0x1c,0x02,0x88,0x12,0x64,0x5a,\n@@ -333,5 +365,6 @@ static void secp256k1_scalar_split_lambda(secp256k1_scalar *r1, secp256k1_scalar\n     secp256k1_scalar_add(r1, r1, a);\n }\n #endif\n+#endif\n \n #endif"
      },
      {
        "sha": "5574c44c7aeb3c8d41ec626adcb1b6994b6f05ef",
        "filename": "src/scalar_low.h",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/scalar_low.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/scalar_low.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_low.h?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -0,0 +1,15 @@\n+/**********************************************************************\n+ * Copyright (c) 2015 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_SCALAR_REPR_\n+#define _SECP256K1_SCALAR_REPR_\n+\n+#include <stdint.h>\n+\n+/** A scalar modulo the group order of the secp256k1 curve. */\n+typedef uint32_t secp256k1_scalar;\n+\n+#endif"
      },
      {
        "sha": "4f94441f492a8144ebe579435ead2a66712eea17",
        "filename": "src/scalar_low_impl.h",
        "status": "added",
        "additions": 114,
        "deletions": 0,
        "changes": 114,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/scalar_low_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/scalar_low_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_low_impl.h?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -0,0 +1,114 @@\n+/**********************************************************************\n+ * Copyright (c) 2015 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_SCALAR_REPR_IMPL_H_\n+#define _SECP256K1_SCALAR_REPR_IMPL_H_\n+\n+#include \"scalar.h\"\n+\n+#include <string.h>\n+\n+SECP256K1_INLINE static int secp256k1_scalar_is_even(const secp256k1_scalar *a) {\n+    return !(*a & 1);\n+}\n+\n+SECP256K1_INLINE static void secp256k1_scalar_clear(secp256k1_scalar *r) { *r = 0; }\n+SECP256K1_INLINE static void secp256k1_scalar_set_int(secp256k1_scalar *r, unsigned int v) { *r = v; }\n+\n+SECP256K1_INLINE static unsigned int secp256k1_scalar_get_bits(const secp256k1_scalar *a, unsigned int offset, unsigned int count) {\n+    if (offset < 32)\n+        return ((*a >> offset) & ((((uint32_t)1) << count) - 1));\n+    else\n+        return 0;\n+}\n+\n+SECP256K1_INLINE static unsigned int secp256k1_scalar_get_bits_var(const secp256k1_scalar *a, unsigned int offset, unsigned int count) {\n+    return secp256k1_scalar_get_bits(a, offset, count);\n+}\n+\n+SECP256K1_INLINE static int secp256k1_scalar_check_overflow(const secp256k1_scalar *a) { return *a >= EXHAUSTIVE_TEST_ORDER; }\n+\n+static int secp256k1_scalar_add(secp256k1_scalar *r, const secp256k1_scalar *a, const secp256k1_scalar *b) {\n+    *r = (*a + *b) % EXHAUSTIVE_TEST_ORDER;\n+    return *r < *b;\n+}\n+\n+static void secp256k1_scalar_cadd_bit(secp256k1_scalar *r, unsigned int bit, int flag) {\n+    if (flag && bit < 32)\n+        *r += (1 << bit);\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_scalar_check_overflow(r) == 0);\n+#endif\n+}\n+\n+static void secp256k1_scalar_set_b32(secp256k1_scalar *r, const unsigned char *b32, int *overflow) {\n+    const int base = 0x100 % EXHAUSTIVE_TEST_ORDER;\n+    int i;\n+    *r = 0;\n+    for (i = 0; i < 32; i++) {\n+       *r = ((*r * base) + b32[i]) % EXHAUSTIVE_TEST_ORDER;\n+    }\n+    /* just deny overflow, it basically always happens */\n+    if (overflow) *overflow = 0;\n+}\n+\n+static void secp256k1_scalar_get_b32(unsigned char *bin, const secp256k1_scalar* a) {\n+    memset(bin, 0, 32);\n+    bin[28] = *a >> 24; bin[29] = *a >> 16; bin[30] = *a >> 8; bin[31] = *a;\n+}\n+\n+SECP256K1_INLINE static int secp256k1_scalar_is_zero(const secp256k1_scalar *a) {\n+    return *a == 0;\n+}\n+\n+static void secp256k1_scalar_negate(secp256k1_scalar *r, const secp256k1_scalar *a) {\n+    if (*a == 0) {\n+        *r = 0;\n+    } else {\n+        *r = EXHAUSTIVE_TEST_ORDER - *a;\n+    }\n+}\n+\n+SECP256K1_INLINE static int secp256k1_scalar_is_one(const secp256k1_scalar *a) {\n+    return *a == 1;\n+}\n+\n+static int secp256k1_scalar_is_high(const secp256k1_scalar *a) {\n+    return *a > EXHAUSTIVE_TEST_ORDER / 2;\n+}\n+\n+static int secp256k1_scalar_cond_negate(secp256k1_scalar *r, int flag) {\n+    if (flag) secp256k1_scalar_negate(r, r);\n+    return flag ? -1 : 1;\n+}\n+\n+static void secp256k1_scalar_mul(secp256k1_scalar *r, const secp256k1_scalar *a, const secp256k1_scalar *b) {\n+    *r = (*a * *b) % EXHAUSTIVE_TEST_ORDER;\n+}\n+\n+static int secp256k1_scalar_shr_int(secp256k1_scalar *r, int n) {\n+    int ret;\n+    VERIFY_CHECK(n > 0);\n+    VERIFY_CHECK(n < 16);\n+    ret = *r & ((1 << n) - 1);\n+    *r >>= n;\n+    return ret;\n+}\n+\n+static void secp256k1_scalar_sqr(secp256k1_scalar *r, const secp256k1_scalar *a) {\n+    *r = (*a * *a) % EXHAUSTIVE_TEST_ORDER;\n+}\n+\n+static void secp256k1_scalar_split_128(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *a) {\n+    *r1 = *a;\n+    *r2 = 0;\n+}\n+\n+SECP256K1_INLINE static int secp256k1_scalar_eq(const secp256k1_scalar *a, const secp256k1_scalar *b) {\n+    return *a == *b;\n+}\n+\n+#endif"
      },
      {
        "sha": "fb8b882faafd36d8b60476e1df024829b32326e0",
        "filename": "src/secp256k1.c",
        "status": "modified",
        "additions": 6,
        "deletions": 13,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1.c?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -4,8 +4,6 @@\n  * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n  **********************************************************************/\n \n-#define SECP256K1_BUILD (1)\n-\n #include \"include/secp256k1.h\"\n \n #include \"util.h\"\n@@ -152,7 +150,6 @@ static void secp256k1_pubkey_save(secp256k1_pubkey* pubkey, secp256k1_ge* ge) {\n int secp256k1_ec_pubkey_parse(const secp256k1_context* ctx, secp256k1_pubkey* pubkey, const unsigned char *input, size_t inputlen) {\n     secp256k1_ge Q;\n \n-    (void)ctx;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(pubkey != NULL);\n     memset(pubkey, 0, sizeof(*pubkey));\n@@ -170,7 +167,6 @@ int secp256k1_ec_pubkey_serialize(const secp256k1_context* ctx, unsigned char *o\n     size_t len;\n     int ret = 0;\n \n-    (void)ctx;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(outputlen != NULL);\n     ARG_CHECK(*outputlen >= ((flags & SECP256K1_FLAGS_BIT_COMPRESSION) ? 33 : 65));\n@@ -216,7 +212,7 @@ static void secp256k1_ecdsa_signature_save(secp256k1_ecdsa_signature* sig, const\n int secp256k1_ecdsa_signature_parse_der(const secp256k1_context* ctx, secp256k1_ecdsa_signature* sig, const unsigned char *input, size_t inputlen) {\n     secp256k1_scalar r, s;\n \n-    (void)ctx;\n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(sig != NULL);\n     ARG_CHECK(input != NULL);\n \n@@ -234,7 +230,7 @@ int secp256k1_ecdsa_signature_parse_compact(const secp256k1_context* ctx, secp25\n     int ret = 1;\n     int overflow = 0;\n \n-    (void)ctx;\n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(sig != NULL);\n     ARG_CHECK(input64 != NULL);\n \n@@ -253,7 +249,7 @@ int secp256k1_ecdsa_signature_parse_compact(const secp256k1_context* ctx, secp25\n int secp256k1_ecdsa_signature_serialize_der(const secp256k1_context* ctx, unsigned char *output, size_t *outputlen, const secp256k1_ecdsa_signature* sig) {\n     secp256k1_scalar r, s;\n \n-    (void)ctx;\n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(output != NULL);\n     ARG_CHECK(outputlen != NULL);\n     ARG_CHECK(sig != NULL);\n@@ -265,7 +261,7 @@ int secp256k1_ecdsa_signature_serialize_der(const secp256k1_context* ctx, unsign\n int secp256k1_ecdsa_signature_serialize_compact(const secp256k1_context* ctx, unsigned char *output64, const secp256k1_ecdsa_signature* sig) {\n     secp256k1_scalar r, s;\n \n-    (void)ctx;\n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(output64 != NULL);\n     ARG_CHECK(sig != NULL);\n \n@@ -363,23 +359,23 @@ int secp256k1_ecdsa_sign(const secp256k1_context* ctx, secp256k1_ecdsa_signature\n     secp256k1_scalar_set_b32(&sec, seckey, &overflow);\n     /* Fail if the secret key is invalid. */\n     if (!overflow && !secp256k1_scalar_is_zero(&sec)) {\n+        unsigned char nonce32[32];\n         unsigned int count = 0;\n         secp256k1_scalar_set_b32(&msg, msg32, NULL);\n         while (1) {\n-            unsigned char nonce32[32];\n             ret = noncefp(nonce32, msg32, seckey, NULL, (void*)noncedata, count);\n             if (!ret) {\n                 break;\n             }\n             secp256k1_scalar_set_b32(&non, nonce32, &overflow);\n-            memset(nonce32, 0, 32);\n             if (!overflow && !secp256k1_scalar_is_zero(&non)) {\n                 if (secp256k1_ecdsa_sig_sign(&ctx->ecmult_gen_ctx, &r, &s, &sec, &msg, &non, NULL)) {\n                     break;\n                 }\n             }\n             count++;\n         }\n+        memset(nonce32, 0, 32);\n         secp256k1_scalar_clear(&msg);\n         secp256k1_scalar_clear(&non);\n         secp256k1_scalar_clear(&sec);\n@@ -398,7 +394,6 @@ int secp256k1_ec_seckey_verify(const secp256k1_context* ctx, const unsigned char\n     int overflow;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(seckey != NULL);\n-    (void)ctx;\n \n     secp256k1_scalar_set_b32(&sec, seckey, &overflow);\n     ret = !overflow && !secp256k1_scalar_is_zero(&sec);\n@@ -437,7 +432,6 @@ int secp256k1_ec_privkey_tweak_add(const secp256k1_context* ctx, unsigned char *\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(seckey != NULL);\n     ARG_CHECK(tweak != NULL);\n-    (void)ctx;\n \n     secp256k1_scalar_set_b32(&term, tweak, &overflow);\n     secp256k1_scalar_set_b32(&sec, seckey, NULL);\n@@ -485,7 +479,6 @@ int secp256k1_ec_privkey_tweak_mul(const secp256k1_context* ctx, unsigned char *\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(seckey != NULL);\n     ARG_CHECK(tweak != NULL);\n-    (void)ctx;\n \n     secp256k1_scalar_set_b32(&factor, tweak, &overflow);\n     secp256k1_scalar_set_b32(&sec, seckey, NULL);"
      },
      {
        "sha": "9ae7d3028130637ba1159c4c9772cf94267e3711",
        "filename": "src/tests.c",
        "status": "modified",
        "additions": 172,
        "deletions": 30,
        "changes": 202,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tests.c?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -473,6 +473,8 @@ void test_num_negate(void) {\n }\n \n void test_num_add_sub(void) {\n+    int i;\n+    secp256k1_scalar s;\n     secp256k1_num n1;\n     secp256k1_num n2;\n     secp256k1_num n1p2, n2p1, n1m2, n2m1;\n@@ -498,13 +500,119 @@ void test_num_add_sub(void) {\n     CHECK(!secp256k1_num_eq(&n2p1, &n1));\n     secp256k1_num_sub(&n2p1, &n2p1, &n2); /* n2p1 = R2 + R1 - R2 = R1 */\n     CHECK(secp256k1_num_eq(&n2p1, &n1));\n+\n+    /* check is_one */\n+    secp256k1_scalar_set_int(&s, 1);\n+    secp256k1_scalar_get_num(&n1, &s);\n+    CHECK(secp256k1_num_is_one(&n1));\n+    /* check that 2^n + 1 is never 1 */\n+    secp256k1_scalar_get_num(&n2, &s);\n+    for (i = 0; i < 250; ++i) {\n+        secp256k1_num_add(&n1, &n1, &n1);    /* n1 *= 2 */\n+        secp256k1_num_add(&n1p2, &n1, &n2);  /* n1p2 = n1 + 1 */\n+        CHECK(!secp256k1_num_is_one(&n1p2));\n+    }\n+}\n+\n+void test_num_mod(void) {\n+    int i;\n+    secp256k1_scalar s;\n+    secp256k1_num order, n;\n+\n+    /* check that 0 mod anything is 0 */\n+    random_scalar_order_test(&s);\n+    secp256k1_scalar_get_num(&order, &s);\n+    secp256k1_scalar_set_int(&s, 0);\n+    secp256k1_scalar_get_num(&n, &s);\n+    secp256k1_num_mod(&n, &order);\n+    CHECK(secp256k1_num_is_zero(&n));\n+\n+    /* check that anything mod 1 is 0 */\n+    secp256k1_scalar_set_int(&s, 1);\n+    secp256k1_scalar_get_num(&order, &s);\n+    secp256k1_scalar_get_num(&n, &s);\n+    secp256k1_num_mod(&n, &order);\n+    CHECK(secp256k1_num_is_zero(&n));\n+\n+    /* check that increasing the number past 2^256 does not break this */\n+    random_scalar_order_test(&s);\n+    secp256k1_scalar_get_num(&n, &s);\n+    /* multiply by 2^8, which'll test this case with high probability */\n+    for (i = 0; i < 8; ++i) {\n+        secp256k1_num_add(&n, &n, &n);\n+    }\n+    secp256k1_num_mod(&n, &order);\n+    CHECK(secp256k1_num_is_zero(&n));\n+}\n+\n+void test_num_jacobi(void) {\n+    secp256k1_scalar sqr;\n+    secp256k1_scalar small;\n+    secp256k1_scalar five;  /* five is not a quadratic residue */\n+    secp256k1_num order, n;\n+    int i;\n+    /* squares mod 5 are 1, 4 */\n+    const int jacobi5[10] = { 0, 1, -1, -1, 1, 0, 1, -1, -1, 1 };\n+\n+    /* check some small values with 5 as the order */\n+    secp256k1_scalar_set_int(&five, 5);\n+    secp256k1_scalar_get_num(&order, &five);\n+    for (i = 0; i < 10; ++i) {\n+        secp256k1_scalar_set_int(&small, i);\n+        secp256k1_scalar_get_num(&n, &small);\n+        CHECK(secp256k1_num_jacobi(&n, &order) == jacobi5[i]);\n+    }\n+\n+    /** test large values with 5 as group order */\n+    secp256k1_scalar_get_num(&order, &five);\n+    /* we first need a scalar which is not a multiple of 5 */\n+    do {\n+        secp256k1_num fiven;\n+        random_scalar_order_test(&sqr);\n+        secp256k1_scalar_get_num(&fiven, &five);\n+        secp256k1_scalar_get_num(&n, &sqr);\n+        secp256k1_num_mod(&n, &fiven);\n+    } while (secp256k1_num_is_zero(&n));\n+    /* next force it to be a residue. 2 is a nonresidue mod 5 so we can\n+     * just multiply by two, i.e. add the number to itself */\n+    if (secp256k1_num_jacobi(&n, &order) == -1) {\n+        secp256k1_num_add(&n, &n, &n);\n+    }\n+\n+    /* test residue */\n+    CHECK(secp256k1_num_jacobi(&n, &order) == 1);\n+    /* test nonresidue */\n+    secp256k1_num_add(&n, &n, &n);\n+    CHECK(secp256k1_num_jacobi(&n, &order) == -1);\n+\n+    /** test with secp group order as order */\n+    secp256k1_scalar_order_get_num(&order);\n+    random_scalar_order_test(&sqr);\n+    secp256k1_scalar_sqr(&sqr, &sqr);\n+    /* test residue */\n+    secp256k1_scalar_get_num(&n, &sqr);\n+    CHECK(secp256k1_num_jacobi(&n, &order) == 1);\n+    /* test nonresidue */\n+    secp256k1_scalar_mul(&sqr, &sqr, &five);\n+    secp256k1_scalar_get_num(&n, &sqr);\n+    CHECK(secp256k1_num_jacobi(&n, &order) == -1);\n+    /* test multiple of the order*/\n+    CHECK(secp256k1_num_jacobi(&order, &order) == 0);\n+\n+    /* check one less than the order */\n+    secp256k1_scalar_set_int(&small, 1);\n+    secp256k1_scalar_get_num(&n, &small);\n+    secp256k1_num_sub(&n, &order, &n);\n+    CHECK(secp256k1_num_jacobi(&n, &order) == 1);  /* sage confirms this is 1 */\n }\n \n void run_num_smalltests(void) {\n     int i;\n     for (i = 0; i < 100*count; i++) {\n         test_num_negate();\n         test_num_add_sub();\n+        test_num_mod();\n+        test_num_jacobi();\n     }\n }\n #endif\n@@ -689,6 +797,10 @@ void scalar_test(void) {\n             secp256k1_scalar_inverse(&inv, &inv);\n             /* Inverting one must result in one. */\n             CHECK(secp256k1_scalar_is_one(&inv));\n+#ifndef USE_NUM_NONE\n+            secp256k1_scalar_get_num(&invnum, &inv);\n+            CHECK(secp256k1_num_is_one(&invnum));\n+#endif\n         }\n     }\n \n@@ -855,7 +967,7 @@ void run_scalar_tests(void) {\n         secp256k1_scalar zzv;\n #endif\n         int overflow;\n-        unsigned char chal[32][2][32] = {\n+        unsigned char chal[33][2][32] = {\n             {{0xff, 0xff, 0x03, 0x07, 0x00, 0x00, 0x00, 0x00,\n               0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03,\n               0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff,\n@@ -1111,9 +1223,17 @@ void run_scalar_tests(void) {\n              {0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff,\n               0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0x00,\n               0xf8, 0x07, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff,\n-              0xff, 0xc7, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff}}\n+              0xff, 0xc7, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff}},\n+            {{0x82, 0xc9, 0xfa, 0xb0, 0x68, 0x04, 0xa0, 0x00,\n+              0x82, 0xc9, 0xfa, 0xb0, 0x68, 0x04, 0xa0, 0x00,\n+              0xff, 0xff, 0xff, 0xff, 0xff, 0x6f, 0x03, 0xfb,\n+              0xfa, 0x8a, 0x7d, 0xdf, 0x13, 0x86, 0xe2, 0x03},\n+             {0x82, 0xc9, 0xfa, 0xb0, 0x68, 0x04, 0xa0, 0x00,\n+              0x82, 0xc9, 0xfa, 0xb0, 0x68, 0x04, 0xa0, 0x00,\n+              0xff, 0xff, 0xff, 0xff, 0xff, 0x6f, 0x03, 0xfb,\n+              0xfa, 0x8a, 0x7d, 0xdf, 0x13, 0x86, 0xe2, 0x03}}\n         };\n-        unsigned char res[32][2][32] = {\n+        unsigned char res[33][2][32] = {\n             {{0x0c, 0x3b, 0x0a, 0xca, 0x8d, 0x1a, 0x2f, 0xb9,\n               0x8a, 0x7b, 0x53, 0x5a, 0x1f, 0xc5, 0x22, 0xa1,\n               0x07, 0x2a, 0x48, 0xea, 0x02, 0xeb, 0xb3, 0xd6,\n@@ -1369,10 +1489,18 @@ void run_scalar_tests(void) {\n              {0xe4, 0xf1, 0x23, 0x84, 0xe1, 0xb5, 0x9d, 0xf2,\n               0xb8, 0x73, 0x8b, 0x45, 0x2b, 0x35, 0x46, 0x38,\n               0x10, 0x2b, 0x50, 0xf8, 0x8b, 0x35, 0xcd, 0x34,\n-              0xc8, 0x0e, 0xf6, 0xdb, 0x09, 0x35, 0xf0, 0xda}}\n+              0xc8, 0x0e, 0xf6, 0xdb, 0x09, 0x35, 0xf0, 0xda}},\n+            {{0xdb, 0x21, 0x5c, 0x8d, 0x83, 0x1d, 0xb3, 0x34,\n+              0xc7, 0x0e, 0x43, 0xa1, 0x58, 0x79, 0x67, 0x13,\n+              0x1e, 0x86, 0x5d, 0x89, 0x63, 0xe6, 0x0a, 0x46,\n+              0x5c, 0x02, 0x97, 0x1b, 0x62, 0x43, 0x86, 0xf5},\n+             {0xdb, 0x21, 0x5c, 0x8d, 0x83, 0x1d, 0xb3, 0x34,\n+              0xc7, 0x0e, 0x43, 0xa1, 0x58, 0x79, 0x67, 0x13,\n+              0x1e, 0x86, 0x5d, 0x89, 0x63, 0xe6, 0x0a, 0x46,\n+              0x5c, 0x02, 0x97, 0x1b, 0x62, 0x43, 0x86, 0xf5}}\n         };\n         secp256k1_scalar_set_int(&one, 1);\n-        for (i = 0; i < 32; i++) {\n+        for (i = 0; i < 33; i++) {\n             secp256k1_scalar_set_b32(&x, chal[i][0], &overflow);\n             CHECK(!overflow);\n             secp256k1_scalar_set_b32(&y, chal[i][1], &overflow);\n@@ -1446,7 +1574,7 @@ void random_fe_non_zero(secp256k1_fe *nz) {\n void random_fe_non_square(secp256k1_fe *ns) {\n     secp256k1_fe r;\n     random_fe_non_zero(ns);\n-    if (secp256k1_fe_sqrt_var(&r, ns)) {\n+    if (secp256k1_fe_sqrt(&r, ns)) {\n         secp256k1_fe_negate(ns, ns, 1);\n     }\n }\n@@ -1605,18 +1733,18 @@ void run_field_inv_all_var(void) {\n     secp256k1_fe x[16], xi[16], xii[16];\n     int i;\n     /* Check it's safe to call for 0 elements */\n-    secp256k1_fe_inv_all_var(0, xi, x);\n+    secp256k1_fe_inv_all_var(xi, x, 0);\n     for (i = 0; i < count; i++) {\n         size_t j;\n         size_t len = secp256k1_rand_int(15) + 1;\n         for (j = 0; j < len; j++) {\n             random_fe_non_zero(&x[j]);\n         }\n-        secp256k1_fe_inv_all_var(len, xi, x);\n+        secp256k1_fe_inv_all_var(xi, x, len);\n         for (j = 0; j < len; j++) {\n             CHECK(check_fe_inverse(&x[j], &xi[j]));\n         }\n-        secp256k1_fe_inv_all_var(len, xii, xi);\n+        secp256k1_fe_inv_all_var(xii, xi, len);\n         for (j = 0; j < len; j++) {\n             CHECK(check_fe_equal(&x[j], &xii[j]));\n         }\n@@ -1641,7 +1769,7 @@ void run_sqr(void) {\n \n void test_sqrt(const secp256k1_fe *a, const secp256k1_fe *k) {\n     secp256k1_fe r1, r2;\n-    int v = secp256k1_fe_sqrt_var(&r1, a);\n+    int v = secp256k1_fe_sqrt(&r1, a);\n     CHECK((v == 0) == (k == NULL));\n \n     if (k != NULL) {\n@@ -1802,7 +1930,7 @@ void test_ge(void) {\n                 zs[i] = gej[i].z;\n             }\n         }\n-        secp256k1_fe_inv_all_var(4 * runs + 1, zinv, zs);\n+        secp256k1_fe_inv_all_var(zinv, zs, 4 * runs + 1);\n         free(zs);\n     }\n \n@@ -1922,8 +2050,8 @@ void test_ge(void) {\n                 secp256k1_fe_mul(&zr[i + 1], &zinv[i], &gej[i + 1].z);\n             }\n         }\n-        secp256k1_ge_set_table_gej_var(4 * runs + 1, ge_set_table, gej, zr);\n-        secp256k1_ge_set_all_gej_var(4 * runs + 1, ge_set_all, gej, &ctx->error_callback);\n+        secp256k1_ge_set_table_gej_var(ge_set_table, gej, zr, 4 * runs + 1);\n+        secp256k1_ge_set_all_gej_var(ge_set_all, gej, 4 * runs + 1, &ctx->error_callback);\n         for (i = 0; i < 4 * runs + 1; i++) {\n             secp256k1_fe s;\n             random_fe_non_zero(&s);\n@@ -1951,8 +2079,8 @@ void test_add_neg_y_diff_x(void) {\n      * of the sum to be wrong (since infinity has no xy coordinates).\n      * HOWEVER, if the x-coordinates are different, infinity is the\n      * wrong answer, and such degeneracies are exposed. This is the\n-     * root of https://github.com/bitcoin/secp256k1/issues/257 which\n-     * this test is a regression test for.\n+     * root of https://github.com/bitcoin-core/secp256k1/issues/257\n+     * which this test is a regression test for.\n      *\n      * These points were generated in sage as\n      * # secp256k1 params\n@@ -2051,15 +2179,16 @@ void run_ec_combine(void) {\n void test_group_decompress(const secp256k1_fe* x) {\n     /* The input itself, normalized. */\n     secp256k1_fe fex = *x;\n-    secp256k1_fe tmp;\n+    secp256k1_fe fez;\n     /* Results of set_xquad_var, set_xo_var(..., 0), set_xo_var(..., 1). */\n     secp256k1_ge ge_quad, ge_even, ge_odd;\n+    secp256k1_gej gej_quad;\n     /* Return values of the above calls. */\n     int res_quad, res_even, res_odd;\n \n     secp256k1_fe_normalize_var(&fex);\n \n-    res_quad = secp256k1_ge_set_xquad_var(&ge_quad, &fex);\n+    res_quad = secp256k1_ge_set_xquad(&ge_quad, &fex);\n     res_even = secp256k1_ge_set_xo_var(&ge_even, &fex, 0);\n     res_odd = secp256k1_ge_set_xo_var(&ge_odd, &fex, 1);\n \n@@ -2085,13 +2214,29 @@ void test_group_decompress(const secp256k1_fe* x) {\n         CHECK(secp256k1_fe_equal_var(&ge_odd.x, x));\n \n         /* Check that the Y coordinate result in ge_quad is a square. */\n-        CHECK(secp256k1_fe_sqrt_var(&tmp, &ge_quad.y));\n-        secp256k1_fe_sqr(&tmp, &tmp);\n-        CHECK(secp256k1_fe_equal_var(&tmp, &ge_quad.y));\n+        CHECK(secp256k1_fe_is_quad_var(&ge_quad.y));\n \n         /* Check odd/even Y in ge_odd, ge_even. */\n         CHECK(secp256k1_fe_is_odd(&ge_odd.y));\n         CHECK(!secp256k1_fe_is_odd(&ge_even.y));\n+\n+        /* Check secp256k1_gej_has_quad_y_var. */\n+        secp256k1_gej_set_ge(&gej_quad, &ge_quad);\n+        CHECK(secp256k1_gej_has_quad_y_var(&gej_quad));\n+        do {\n+            random_fe_test(&fez);\n+        } while (secp256k1_fe_is_zero(&fez));\n+        secp256k1_gej_rescale(&gej_quad, &fez);\n+        CHECK(secp256k1_gej_has_quad_y_var(&gej_quad));\n+        secp256k1_gej_neg(&gej_quad, &gej_quad);\n+        CHECK(!secp256k1_gej_has_quad_y_var(&gej_quad));\n+        do {\n+            random_fe_test(&fez);\n+        } while (secp256k1_fe_is_zero(&fez));\n+        secp256k1_gej_rescale(&gej_quad, &fez);\n+        CHECK(!secp256k1_gej_has_quad_y_var(&gej_quad));\n+        secp256k1_gej_neg(&gej_quad, &gej_quad);\n+        CHECK(secp256k1_gej_has_quad_y_var(&gej_quad));\n     }\n }\n \n@@ -2383,9 +2528,7 @@ void test_constant_wnaf(const secp256k1_scalar *number, int w) {\n     secp256k1_scalar x, shift;\n     int wnaf[256] = {0};\n     int i;\n-#ifdef USE_ENDOMORPHISM\n     int skew;\n-#endif\n     secp256k1_scalar num = *number;\n \n     secp256k1_scalar_set_int(&x, 0);\n@@ -2395,10 +2538,8 @@ void test_constant_wnaf(const secp256k1_scalar *number, int w) {\n     for (i = 0; i < 16; ++i) {\n         secp256k1_scalar_shr_int(&num, 8);\n     }\n-    skew = secp256k1_wnaf_const(wnaf, num, w);\n-#else\n-    secp256k1_wnaf_const(wnaf, num, w);\n #endif\n+    skew = secp256k1_wnaf_const(wnaf, num, w);\n \n     for (i = WNAF_SIZE(w); i >= 0; --i) {\n         secp256k1_scalar t;\n@@ -2417,10 +2558,8 @@ void test_constant_wnaf(const secp256k1_scalar *number, int w) {\n         }\n         secp256k1_scalar_add(&x, &x, &t);\n     }\n-#ifdef USE_ENDOMORPHISM\n-    /* Skew num because when encoding 128-bit numbers as odd we use an offset */\n+    /* Skew num because when encoding numbers as odd we use an offset */\n     secp256k1_scalar_cadd_bit(&num, skew == 2, 1);\n-#endif\n     CHECK(secp256k1_scalar_eq(&x, &num));\n }\n \n@@ -3484,12 +3623,14 @@ void run_ecdsa_end_to_end(void) {\n \n int test_ecdsa_der_parse(const unsigned char *sig, size_t siglen, int certainly_der, int certainly_not_der) {\n     static const unsigned char zeroes[32] = {0};\n+#ifdef ENABLE_OPENSSL_TESTS\n     static const unsigned char max_scalar[32] = {\n         0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n         0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,\n         0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b,\n         0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x40\n     };\n+#endif\n \n     int ret = 0;\n \n@@ -3607,13 +3748,13 @@ static void assign_big_endian(unsigned char *ptr, size_t ptrlen, uint32_t val) {\n static void damage_array(unsigned char *sig, size_t *len) {\n     int pos;\n     int action = secp256k1_rand_bits(3);\n-    if (action < 1) {\n+    if (action < 1 && *len > 3) {\n         /* Delete a byte. */\n         pos = secp256k1_rand_int(*len);\n         memmove(sig + pos, sig + pos + 1, *len - pos - 1);\n         (*len)--;\n         return;\n-    } else if (action < 2) {\n+    } else if (action < 2 && *len < 2048) {\n         /* Insert a byte. */\n         pos = secp256k1_rand_int(1 + *len);\n         memmove(sig + pos + 1, sig + pos, *len - pos);\n@@ -3785,6 +3926,7 @@ void run_ecdsa_der_parse(void) {\n         int certainly_der = 0;\n         int certainly_not_der = 0;\n         random_ber_signature(buffer, &buflen, &certainly_der, &certainly_not_der);\n+        CHECK(buflen <= 2048);\n         for (j = 0; j < 16; j++) {\n             int ret = 0;\n             if (j > 0) {"
      },
      {
        "sha": "bda6ee475c9c0fb5c85eb4944f0746107cff6b42",
        "filename": "src/tests_exhaustive.c",
        "status": "added",
        "additions": 329,
        "deletions": 0,
        "changes": 329,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/tests_exhaustive.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e/src/tests_exhaustive.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tests_exhaustive.c?ref=64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "patch": "@@ -0,0 +1,329 @@\n+/***********************************************************************\n+ * Copyright (c) 2016 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#if defined HAVE_CONFIG_H\n+#include \"libsecp256k1-config.h\"\n+#endif\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+#include <time.h>\n+\n+#undef USE_ECMULT_STATIC_PRECOMPUTATION\n+\n+#ifndef EXHAUSTIVE_TEST_ORDER\n+/* see group_impl.h for allowable values */\n+#define EXHAUSTIVE_TEST_ORDER 13\n+#define EXHAUSTIVE_TEST_LAMBDA 9   /* cube root of 1 mod 13 */\n+#endif\n+\n+#include \"include/secp256k1.h\"\n+#include \"group.h\"\n+#include \"secp256k1.c\"\n+#include \"testrand_impl.h\"\n+\n+/** stolen from tests.c */\n+void ge_equals_ge(const secp256k1_ge *a, const secp256k1_ge *b) {\n+    CHECK(a->infinity == b->infinity);\n+    if (a->infinity) {\n+        return;\n+    }\n+    CHECK(secp256k1_fe_equal_var(&a->x, &b->x));\n+    CHECK(secp256k1_fe_equal_var(&a->y, &b->y));\n+}\n+\n+void ge_equals_gej(const secp256k1_ge *a, const secp256k1_gej *b) {\n+    secp256k1_fe z2s;\n+    secp256k1_fe u1, u2, s1, s2;\n+    CHECK(a->infinity == b->infinity);\n+    if (a->infinity) {\n+        return;\n+    }\n+    /* Check a.x * b.z^2 == b.x && a.y * b.z^3 == b.y, to avoid inverses. */\n+    secp256k1_fe_sqr(&z2s, &b->z);\n+    secp256k1_fe_mul(&u1, &a->x, &z2s);\n+    u2 = b->x; secp256k1_fe_normalize_weak(&u2);\n+    secp256k1_fe_mul(&s1, &a->y, &z2s); secp256k1_fe_mul(&s1, &s1, &b->z);\n+    s2 = b->y; secp256k1_fe_normalize_weak(&s2);\n+    CHECK(secp256k1_fe_equal_var(&u1, &u2));\n+    CHECK(secp256k1_fe_equal_var(&s1, &s2));\n+}\n+\n+void random_fe(secp256k1_fe *x) {\n+    unsigned char bin[32];\n+    do {\n+        secp256k1_rand256(bin);\n+        if (secp256k1_fe_set_b32(x, bin)) {\n+            return;\n+        }\n+    } while(1);\n+}\n+/** END stolen from tests.c */\n+\n+int secp256k1_nonce_function_smallint(unsigned char *nonce32, const unsigned char *msg32,\n+                                      const unsigned char *key32, const unsigned char *algo16,\n+                                      void *data, unsigned int attempt) {\n+    secp256k1_scalar s;\n+    int *idata = data;\n+    (void)msg32;\n+    (void)key32;\n+    (void)algo16;\n+    /* Some nonces cannot be used because they'd cause s and/or r to be zero.\n+     * The signing function has retry logic here that just re-calls the nonce\n+     * function with an increased `attempt`. So if attempt > 0 this means we\n+     * need to change the nonce to avoid an infinite loop. */\n+    if (attempt > 0) {\n+        (*idata)++;\n+    }\n+    secp256k1_scalar_set_int(&s, *idata);\n+    secp256k1_scalar_get_b32(nonce32, &s);\n+    return 1;\n+}\n+\n+#ifdef USE_ENDOMORPHISM\n+void test_exhaustive_endomorphism(const secp256k1_ge *group, int order) {\n+    int i;\n+    for (i = 0; i < order; i++) {\n+        secp256k1_ge res;\n+        secp256k1_ge_mul_lambda(&res, &group[i]);\n+        ge_equals_ge(&group[i * EXHAUSTIVE_TEST_LAMBDA % EXHAUSTIVE_TEST_ORDER], &res);\n+    }\n+}\n+#endif\n+\n+void test_exhaustive_addition(const secp256k1_ge *group, const secp256k1_gej *groupj, int order) {\n+    int i, j;\n+\n+    /* Sanity-check (and check infinity functions) */\n+    CHECK(secp256k1_ge_is_infinity(&group[0]));\n+    CHECK(secp256k1_gej_is_infinity(&groupj[0]));\n+    for (i = 1; i < order; i++) {\n+        CHECK(!secp256k1_ge_is_infinity(&group[i]));\n+        CHECK(!secp256k1_gej_is_infinity(&groupj[i]));\n+    }\n+\n+    /* Check all addition formulae */\n+    for (j = 0; j < order; j++) {\n+        secp256k1_fe fe_inv;\n+        secp256k1_fe_inv(&fe_inv, &groupj[j].z);\n+        for (i = 0; i < order; i++) {\n+            secp256k1_ge zless_gej;\n+            secp256k1_gej tmp;\n+            /* add_var */\n+            secp256k1_gej_add_var(&tmp, &groupj[i], &groupj[j], NULL);\n+            ge_equals_gej(&group[(i + j) % order], &tmp);\n+            /* add_ge */\n+            if (j > 0) {\n+                secp256k1_gej_add_ge(&tmp, &groupj[i], &group[j]);\n+                ge_equals_gej(&group[(i + j) % order], &tmp);\n+            }\n+            /* add_ge_var */\n+            secp256k1_gej_add_ge_var(&tmp, &groupj[i], &group[j], NULL);\n+            ge_equals_gej(&group[(i + j) % order], &tmp);\n+            /* add_zinv_var */\n+            zless_gej.infinity = groupj[j].infinity;\n+            zless_gej.x = groupj[j].x;\n+            zless_gej.y = groupj[j].y;\n+            secp256k1_gej_add_zinv_var(&tmp, &groupj[i], &zless_gej, &fe_inv);\n+            ge_equals_gej(&group[(i + j) % order], &tmp);\n+        }\n+    }\n+\n+    /* Check doubling */\n+    for (i = 0; i < order; i++) {\n+        secp256k1_gej tmp;\n+        if (i > 0) {\n+            secp256k1_gej_double_nonzero(&tmp, &groupj[i], NULL);\n+            ge_equals_gej(&group[(2 * i) % order], &tmp);\n+        }\n+        secp256k1_gej_double_var(&tmp, &groupj[i], NULL);\n+        ge_equals_gej(&group[(2 * i) % order], &tmp);\n+    }\n+\n+    /* Check negation */\n+    for (i = 1; i < order; i++) {\n+        secp256k1_ge tmp;\n+        secp256k1_gej tmpj;\n+        secp256k1_ge_neg(&tmp, &group[i]);\n+        ge_equals_ge(&group[order - i], &tmp);\n+        secp256k1_gej_neg(&tmpj, &groupj[i]);\n+        ge_equals_gej(&group[order - i], &tmpj);\n+    }\n+}\n+\n+void test_exhaustive_ecmult(const secp256k1_context *ctx, const secp256k1_ge *group, const secp256k1_gej *groupj, int order) {\n+    int i, j, r_log;\n+    for (r_log = 1; r_log < order; r_log++) {\n+        for (j = 0; j < order; j++) {\n+            for (i = 0; i < order; i++) {\n+                secp256k1_gej tmp;\n+                secp256k1_scalar na, ng;\n+                secp256k1_scalar_set_int(&na, i);\n+                secp256k1_scalar_set_int(&ng, j);\n+\n+                secp256k1_ecmult(&ctx->ecmult_ctx, &tmp, &groupj[r_log], &na, &ng);\n+                ge_equals_gej(&group[(i * r_log + j) % order], &tmp);\n+\n+                if (i > 0) {\n+                    secp256k1_ecmult_const(&tmp, &group[i], &ng);\n+                    ge_equals_gej(&group[(i * j) % order], &tmp);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+void r_from_k(secp256k1_scalar *r, const secp256k1_ge *group, int k) {\n+    secp256k1_fe x;\n+    unsigned char x_bin[32];\n+    k %= EXHAUSTIVE_TEST_ORDER;\n+    x = group[k].x;\n+    secp256k1_fe_normalize(&x);\n+    secp256k1_fe_get_b32(x_bin, &x);\n+    secp256k1_scalar_set_b32(r, x_bin, NULL);\n+}\n+\n+void test_exhaustive_verify(const secp256k1_context *ctx, const secp256k1_ge *group, int order) {\n+    int s, r, msg, key;\n+    for (s = 1; s < order; s++) {\n+        for (r = 1; r < order; r++) {\n+            for (msg = 1; msg < order; msg++) {\n+                for (key = 1; key < order; key++) {\n+                    secp256k1_ge nonconst_ge;\n+                    secp256k1_ecdsa_signature sig;\n+                    secp256k1_pubkey pk;\n+                    secp256k1_scalar sk_s, msg_s, r_s, s_s;\n+                    secp256k1_scalar s_times_k_s, msg_plus_r_times_sk_s;\n+                    int k, should_verify;\n+                    unsigned char msg32[32];\n+\n+                    secp256k1_scalar_set_int(&s_s, s);\n+                    secp256k1_scalar_set_int(&r_s, r);\n+                    secp256k1_scalar_set_int(&msg_s, msg);\n+                    secp256k1_scalar_set_int(&sk_s, key);\n+\n+                    /* Verify by hand */\n+                    /* Run through every k value that gives us this r and check that *one* works.\n+                     * Note there could be none, there could be multiple, ECDSA is weird. */\n+                    should_verify = 0;\n+                    for (k = 0; k < order; k++) {\n+                        secp256k1_scalar check_x_s;\n+                        r_from_k(&check_x_s, group, k);\n+                        if (r_s == check_x_s) {\n+                            secp256k1_scalar_set_int(&s_times_k_s, k);\n+                            secp256k1_scalar_mul(&s_times_k_s, &s_times_k_s, &s_s);\n+                            secp256k1_scalar_mul(&msg_plus_r_times_sk_s, &r_s, &sk_s);\n+                            secp256k1_scalar_add(&msg_plus_r_times_sk_s, &msg_plus_r_times_sk_s, &msg_s);\n+                            should_verify |= secp256k1_scalar_eq(&s_times_k_s, &msg_plus_r_times_sk_s);\n+                        }\n+                    }\n+                    /* nb we have a \"high s\" rule */\n+                    should_verify &= !secp256k1_scalar_is_high(&s_s);\n+\n+                    /* Verify by calling verify */\n+                    secp256k1_ecdsa_signature_save(&sig, &r_s, &s_s);\n+                    memcpy(&nonconst_ge, &group[sk_s], sizeof(nonconst_ge));\n+                    secp256k1_pubkey_save(&pk, &nonconst_ge);\n+                    secp256k1_scalar_get_b32(msg32, &msg_s);\n+                    CHECK(should_verify ==\n+                          secp256k1_ecdsa_verify(ctx, &sig, msg32, &pk));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+void test_exhaustive_sign(const secp256k1_context *ctx, const secp256k1_ge *group, int order) {\n+    int i, j, k;\n+\n+    /* Loop */\n+    for (i = 1; i < order; i++) {  /* message */\n+        for (j = 1; j < order; j++) {  /* key */\n+            for (k = 1; k < order; k++) {  /* nonce */\n+                secp256k1_ecdsa_signature sig;\n+                secp256k1_scalar sk, msg, r, s, expected_r;\n+                unsigned char sk32[32], msg32[32];\n+                secp256k1_scalar_set_int(&msg, i);\n+                secp256k1_scalar_set_int(&sk, j);\n+                secp256k1_scalar_get_b32(sk32, &sk);\n+                secp256k1_scalar_get_b32(msg32, &msg);\n+\n+                secp256k1_ecdsa_sign(ctx, &sig, msg32, sk32, secp256k1_nonce_function_smallint, &k);\n+\n+                secp256k1_ecdsa_signature_load(ctx, &r, &s, &sig);\n+                /* Note that we compute expected_r *after* signing -- this is important\n+                 * because our nonce-computing function function might change k during\n+                 * signing. */\n+                r_from_k(&expected_r, group, k);\n+                CHECK(r == expected_r);\n+                CHECK((k * s) % order == (i + r * j) % order ||\n+                      (k * (EXHAUSTIVE_TEST_ORDER - s)) % order == (i + r * j) % order);\n+            }\n+        }\n+    }\n+\n+    /* We would like to verify zero-knowledge here by counting how often every\n+     * possible (s, r) tuple appears, but because the group order is larger\n+     * than the field order, when coercing the x-values to scalar values, some\n+     * appear more often than others, so we are actually not zero-knowledge.\n+     * (This effect also appears in the real code, but the difference is on the\n+     * order of 1/2^128th the field order, so the deviation is not useful to a\n+     * computationally bounded attacker.)\n+     */\n+}\n+\n+int main(void) {\n+    int i;\n+    secp256k1_gej groupj[EXHAUSTIVE_TEST_ORDER];\n+    secp256k1_ge group[EXHAUSTIVE_TEST_ORDER];\n+\n+    /* Build context */\n+    secp256k1_context *ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+\n+    /* TODO set z = 1, then do num_tests runs with random z values */\n+\n+    /* Generate the entire group */\n+    secp256k1_gej_set_infinity(&groupj[0]);\n+    secp256k1_ge_set_gej(&group[0], &groupj[0]);\n+    for (i = 1; i < EXHAUSTIVE_TEST_ORDER; i++) {\n+        /* Set a different random z-value for each Jacobian point */\n+        secp256k1_fe z;\n+        random_fe(&z);\n+\n+        secp256k1_gej_add_ge(&groupj[i], &groupj[i - 1], &secp256k1_ge_const_g);\n+        secp256k1_ge_set_gej(&group[i], &groupj[i]);\n+        secp256k1_gej_rescale(&groupj[i], &z);\n+\n+        /* Verify against ecmult_gen */\n+        {\n+            secp256k1_scalar scalar_i;\n+            secp256k1_gej generatedj;\n+            secp256k1_ge generated;\n+\n+            secp256k1_scalar_set_int(&scalar_i, i);\n+            secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &generatedj, &scalar_i);\n+            secp256k1_ge_set_gej(&generated, &generatedj);\n+\n+            CHECK(group[i].infinity == 0);\n+            CHECK(generated.infinity == 0);\n+            CHECK(secp256k1_fe_equal_var(&generated.x, &group[i].x));\n+            CHECK(secp256k1_fe_equal_var(&generated.y, &group[i].y));\n+        }\n+    }\n+\n+    /* Run the tests */\n+#ifdef USE_ENDOMORPHISM\n+    test_exhaustive_endomorphism(group, EXHAUSTIVE_TEST_ORDER);\n+#endif\n+    test_exhaustive_addition(group, groupj, EXHAUSTIVE_TEST_ORDER);\n+    test_exhaustive_ecmult(ctx, group, groupj, EXHAUSTIVE_TEST_ORDER);\n+    test_exhaustive_sign(ctx, group, EXHAUSTIVE_TEST_ORDER);\n+    test_exhaustive_verify(ctx, group, EXHAUSTIVE_TEST_ORDER);\n+\n+    return 0;\n+}\n+"
      }
    ]
  },
  {
    "sha": "fad80b3a1e531e699af52086cc988c63f15e939d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYWQ4MGIzYTFlNTMxZTY5OWFmNTIwODZjYzk4OGM2M2YxNWU5Mzlk",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2016-12-13T11:43:08Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2016-12-13T11:38:38Z"
      },
      "message": "Merge commit '64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e' into HEAD",
      "tree": {
        "sha": "e0b223204ed49728ec584286f01ae5f886c5e014",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e0b223204ed49728ec584286f01ae5f886c5e014"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fad80b3a1e531e699af52086cc988c63f15e939d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fad80b3a1e531e699af52086cc988c63f15e939d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fad80b3a1e531e699af52086cc988c63f15e939d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fad80b3a1e531e699af52086cc988c63f15e939d/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e591c1049fe5e0256ac14a92f460f374a55ffd4e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e591c1049fe5e0256ac14a92f460f374a55ffd4e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e591c1049fe5e0256ac14a92f460f374a55ffd4e"
      },
      {
        "sha": "64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/64dfdde0aa7f7ef24e6cbf3c57e6d24efc55367e"
      }
    ],
    "stats": {
      "total": 5477,
      "additions": 4463,
      "deletions": 1014
    },
    "files": [
      {
        "sha": "87fea161ba5aea04756cb378d487b703bb2e2ab2",
        "filename": "src/secp256k1/.gitignore",
        "status": "modified",
        "additions": 14,
        "deletions": 6,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.gitignore?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -6,6 +6,7 @@ bench_schnorr_verify\n bench_recover\n bench_internal\n tests\n+exhaustive_tests\n gen_context\n *.exe\n *.so\n@@ -25,17 +26,24 @@ config.status\n libtool\n .deps/\n .dirstamp\n-build-aux/\n *.lo\n *.o\n *~\n src/libsecp256k1-config.h\n src/libsecp256k1-config.h.in\n src/ecmult_static_context.h\n-m4/libtool.m4\n-m4/ltoptions.m4\n-m4/ltsugar.m4\n-m4/ltversion.m4\n-m4/lt~obsolete.m4\n+build-aux/config.guess\n+build-aux/config.sub\n+build-aux/depcomp\n+build-aux/install-sh\n+build-aux/ltmain.sh\n+build-aux/m4/libtool.m4\n+build-aux/m4/lt~obsolete.m4\n+build-aux/m4/ltoptions.m4\n+build-aux/m4/ltsugar.m4\n+build-aux/m4/ltversion.m4\n+build-aux/missing\n+build-aux/compile\n+build-aux/test-driver\n src/stamp-h1\n libsecp256k1.pc"
      },
      {
        "sha": "24395292426d697856f34b0b0d6c8f26d81d6856",
        "filename": "src/secp256k1/.travis.yml",
        "status": "modified",
        "additions": 12,
        "deletions": 6,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.travis.yml?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -6,26 +6,30 @@ addons:\n compiler:\n   - clang\n   - gcc\n+cache:\n+  directories:\n+  - src/java/guava/\n env:\n   global:\n-    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  schnorr=no  RECOVERY=no\n+    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  RECOVERY=no  EXPERIMENTAL=no\n+    - GUAVA_URL=https://search.maven.org/remotecontent?filepath=com/google/guava/guava/18.0/guava-18.0.jar GUAVA_JAR=src/java/guava/guava-18.0.jar\n   matrix:\n     - SCALAR=32bit    RECOVERY=yes\n-    - SCALAR=32bit    FIELD=32bit       ECDH=yes\n+    - SCALAR=32bit    FIELD=32bit       ECDH=yes  EXPERIMENTAL=yes\n     - SCALAR=64bit\n     - FIELD=64bit     RECOVERY=yes\n     - FIELD=64bit     ENDOMORPHISM=yes\n-    - FIELD=64bit     ENDOMORPHISM=yes  ECDH=yes\n+    - FIELD=64bit     ENDOMORPHISM=yes  ECDH=yes EXPERIMENTAL=yes\n     - FIELD=64bit                       ASM=x86_64\n     - FIELD=64bit     ENDOMORPHISM=yes  ASM=x86_64\n-    - FIELD=32bit     SCHNORR=yes\n     - FIELD=32bit     ENDOMORPHISM=yes\n     - BIGNUM=no\n-    - BIGNUM=no       ENDOMORPHISM=yes SCHNORR=yes  RECOVERY=yes\n+    - BIGNUM=no       ENDOMORPHISM=yes RECOVERY=yes EXPERIMENTAL=yes\n     - BIGNUM=no       STATICPRECOMPUTATION=no\n     - BUILD=distcheck\n     - EXTRAFLAGS=CPPFLAGS=-DDETERMINISTIC\n     - EXTRAFLAGS=CFLAGS=-O0\n+    - BUILD=check-java ECDH=yes EXPERIMENTAL=yes\n matrix:\n   fast_finish: true\n   include:\n@@ -55,9 +59,11 @@ matrix:\n           packages:\n             - gcc-multilib\n             - libgmp-dev:i386\n+before_install: mkdir -p `dirname $GUAVA_JAR`\n+install: if [ ! -f $GUAVA_JAR ]; then wget $GUAVA_URL -O $GUAVA_JAR; fi\n before_script: ./autogen.sh\n script:\n  - if [ -n \"$HOST\" ]; then export USE_HOST=\"--host=$HOST\"; fi\n  - if [ \"x$HOST\" = \"xi686-linux-gnu\" ]; then export CC=\"$CC -m32\"; fi\n- - ./configure --enable-endomorphism=$ENDOMORPHISM --with-field=$FIELD --with-bignum=$BIGNUM --with-scalar=$SCALAR --enable-ecmult-static-precomputation=$STATICPRECOMPUTATION --enable-module-ecdh=$ECDH --enable-module-schnorr=$SCHNORR --enable-module-recovery=$RECOVERY $EXTRAFLAGS $USE_HOST && make -j2 $BUILD\n+ - ./configure --enable-experimental=$EXPERIMENTAL --enable-endomorphism=$ENDOMORPHISM --with-field=$FIELD --with-bignum=$BIGNUM --with-scalar=$SCALAR --enable-ecmult-static-precomputation=$STATICPRECOMPUTATION --enable-module-ecdh=$ECDH --enable-module-recovery=$RECOVERY $EXTRAFLAGS $USE_HOST && make -j2 $BUILD\n os: linux"
      },
      {
        "sha": "e5657f7f31307852c4dc90750cabea1e2bf1947f",
        "filename": "src/secp256k1/Makefile.am",
        "status": "modified",
        "additions": 75,
        "deletions": 15,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/Makefile.am?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -1,14 +1,22 @@\n ACLOCAL_AMFLAGS = -I build-aux/m4\n \n lib_LTLIBRARIES = libsecp256k1.la\n+if USE_JNI\n+JNI_LIB = libsecp256k1_jni.la\n+noinst_LTLIBRARIES = $(JNI_LIB)\n+else\n+JNI_LIB =\n+endif\n include_HEADERS = include/secp256k1.h\n noinst_HEADERS =\n noinst_HEADERS += src/scalar.h\n noinst_HEADERS += src/scalar_4x64.h\n noinst_HEADERS += src/scalar_8x32.h\n+noinst_HEADERS += src/scalar_low.h\n noinst_HEADERS += src/scalar_impl.h\n noinst_HEADERS += src/scalar_4x64_impl.h\n noinst_HEADERS += src/scalar_8x32_impl.h\n+noinst_HEADERS += src/scalar_low_impl.h\n noinst_HEADERS += src/group.h\n noinst_HEADERS += src/group_impl.h\n noinst_HEADERS += src/num_gmp.h\n@@ -32,6 +40,7 @@ noinst_HEADERS += src/field_5x52_impl.h\n noinst_HEADERS += src/field_5x52_int128_impl.h\n noinst_HEADERS += src/field_5x52_asm_impl.h\n noinst_HEADERS += src/java/org_bitcoin_NativeSecp256k1.h\n+noinst_HEADERS += src/java/org_bitcoin_Secp256k1Context.h\n noinst_HEADERS += src/util.h\n noinst_HEADERS += src/testrand.h\n noinst_HEADERS += src/testrand_impl.h\n@@ -45,33 +54,88 @@ noinst_HEADERS += contrib/lax_der_parsing.c\n noinst_HEADERS += contrib/lax_der_privatekey_parsing.h\n noinst_HEADERS += contrib/lax_der_privatekey_parsing.c\n \n+if USE_EXTERNAL_ASM\n+COMMON_LIB = libsecp256k1_common.la\n+noinst_LTLIBRARIES = $(COMMON_LIB)\n+else\n+COMMON_LIB =\n+endif\n+\n pkgconfigdir = $(libdir)/pkgconfig\n pkgconfig_DATA = libsecp256k1.pc\n \n+if USE_EXTERNAL_ASM\n+if USE_ASM_ARM\n+libsecp256k1_common_la_SOURCES = src/asm/field_10x26_arm.s\n+endif\n+endif\n+\n libsecp256k1_la_SOURCES = src/secp256k1.c\n-libsecp256k1_la_CPPFLAGS = -I$(top_srcdir)/include -I$(top_srcdir)/src $(SECP_INCLUDES)\n-libsecp256k1_la_LIBADD = $(SECP_LIBS)\n+libsecp256k1_la_CPPFLAGS = -DSECP256K1_BUILD -I$(top_srcdir)/include -I$(top_srcdir)/src $(SECP_INCLUDES)\n+libsecp256k1_la_LIBADD = $(JNI_LIB) $(SECP_LIBS) $(COMMON_LIB)\n \n+libsecp256k1_jni_la_SOURCES  = src/java/org_bitcoin_NativeSecp256k1.c src/java/org_bitcoin_Secp256k1Context.c\n+libsecp256k1_jni_la_CPPFLAGS = -DSECP256K1_BUILD $(JNI_INCLUDES)\n \n noinst_PROGRAMS =\n if USE_BENCHMARK\n noinst_PROGRAMS += bench_verify bench_sign bench_internal\n bench_verify_SOURCES = src/bench_verify.c\n-bench_verify_LDADD = libsecp256k1.la $(SECP_LIBS)\n+bench_verify_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n bench_sign_SOURCES = src/bench_sign.c\n-bench_sign_LDADD = libsecp256k1.la $(SECP_LIBS)\n+bench_sign_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n bench_internal_SOURCES = src/bench_internal.c\n-bench_internal_LDADD = $(SECP_LIBS)\n-bench_internal_CPPFLAGS = $(SECP_INCLUDES)\n+bench_internal_LDADD = $(SECP_LIBS) $(COMMON_LIB)\n+bench_internal_CPPFLAGS = -DSECP256K1_BUILD $(SECP_INCLUDES)\n endif\n \n+TESTS =\n if USE_TESTS\n noinst_PROGRAMS += tests\n tests_SOURCES = src/tests.c\n-tests_CPPFLAGS = -DVERIFY -I$(top_srcdir)/src -I$(top_srcdir)/include $(SECP_INCLUDES) $(SECP_TEST_INCLUDES)\n-tests_LDADD = $(SECP_LIBS) $(SECP_TEST_LIBS)\n+tests_CPPFLAGS = -DSECP256K1_BUILD -DVERIFY -I$(top_srcdir)/src -I$(top_srcdir)/include $(SECP_INCLUDES) $(SECP_TEST_INCLUDES)\n+tests_LDADD = $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n tests_LDFLAGS = -static\n-TESTS = tests\n+TESTS += tests\n+endif\n+\n+if USE_EXHAUSTIVE_TESTS\n+noinst_PROGRAMS += exhaustive_tests\n+exhaustive_tests_SOURCES = src/tests_exhaustive.c\n+exhaustive_tests_CPPFLAGS = -DSECP256K1_BUILD -DVERIFY -I$(top_srcdir)/src $(SECP_INCLUDES)\n+exhaustive_tests_LDADD = $(SECP_LIBS)\n+exhaustive_tests_LDFLAGS = -static\n+TESTS += exhaustive_tests\n+endif\n+\n+JAVAROOT=src/java\n+JAVAORG=org/bitcoin\n+JAVA_GUAVA=$(srcdir)/$(JAVAROOT)/guava/guava-18.0.jar\n+CLASSPATH_ENV=CLASSPATH=$(JAVA_GUAVA)\n+JAVA_FILES= \\\n+  $(JAVAROOT)/$(JAVAORG)/NativeSecp256k1.java \\\n+  $(JAVAROOT)/$(JAVAORG)/NativeSecp256k1Test.java \\\n+  $(JAVAROOT)/$(JAVAORG)/NativeSecp256k1Util.java \\\n+  $(JAVAROOT)/$(JAVAORG)/Secp256k1Context.java\n+\n+if USE_JNI\n+\n+$(JAVA_GUAVA):\n+\t@echo Guava is missing. Fetch it via: \\\n+\twget https://search.maven.org/remotecontent?filepath=com/google/guava/guava/18.0/guava-18.0.jar -O $(@)\n+\t@false\n+\n+.stamp-java: $(JAVA_FILES)\n+\t@echo   Compiling $^\n+\t$(AM_V_at)$(CLASSPATH_ENV) javac $^\n+\t@touch $@\n+\n+if USE_TESTS\n+\n+check-java: libsecp256k1.la $(JAVA_GUAVA) .stamp-java\n+\t$(AM_V_at)java -Djava.library.path=\"./:./src:./src/.libs:.libs/\" -cp \"$(JAVA_GUAVA):$(JAVAROOT)\" $(JAVAORG)/NativeSecp256k1Test\n+\n+endif\n endif\n \n if USE_ECMULT_STATIC_PRECOMPUTATION\n@@ -93,19 +157,15 @@ $(bench_internal_OBJECTS): src/ecmult_static_context.h\n src/ecmult_static_context.h: $(gen_context_BIN)\n \t./$(gen_context_BIN)\n \n-CLEANFILES = $(gen_context_BIN) src/ecmult_static_context.h\n+CLEANFILES = $(gen_context_BIN) src/ecmult_static_context.h $(JAVAROOT)/$(JAVAORG)/*.class .stamp-java\n endif\n \n-EXTRA_DIST = autogen.sh src/gen_context.c src/basic-config.h\n+EXTRA_DIST = autogen.sh src/gen_context.c src/basic-config.h $(JAVA_FILES)\n \n if ENABLE_MODULE_ECDH\n include src/modules/ecdh/Makefile.am.include\n endif\n \n-if ENABLE_MODULE_SCHNORR\n-include src/modules/schnorr/Makefile.am.include\n-endif\n-\n if ENABLE_MODULE_RECOVERY\n include src/modules/recovery/Makefile.am.include\n endif"
      },
      {
        "sha": "8cd344ea81232413cf9004bc50dec4ec2fe112a6",
        "filename": "src/secp256k1/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/README.md?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -1,7 +1,7 @@\n libsecp256k1\n ============\n \n-[![Build Status](https://travis-ci.org/bitcoin/secp256k1.svg?branch=master)](https://travis-ci.org/bitcoin/secp256k1)\n+[![Build Status](https://travis-ci.org/bitcoin-core/secp256k1.svg?branch=master)](https://travis-ci.org/bitcoin-core/secp256k1)\n \n Optimized C library for EC operations on curve secp256k1.\n "
      },
      {
        "sha": "1fc36276144a2fb7740c436bd53f09f42b12daff",
        "filename": "src/secp256k1/build-aux/m4/ax_jni_include_dir.m4",
        "status": "added",
        "additions": 140,
        "deletions": 0,
        "changes": 140,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/build-aux/m4/ax_jni_include_dir.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/build-aux/m4/ax_jni_include_dir.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/build-aux/m4/ax_jni_include_dir.m4?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -0,0 +1,140 @@\n+# ===========================================================================\n+#    http://www.gnu.org/software/autoconf-archive/ax_jni_include_dir.html\n+# ===========================================================================\n+#\n+# SYNOPSIS\n+#\n+#   AX_JNI_INCLUDE_DIR\n+#\n+# DESCRIPTION\n+#\n+#   AX_JNI_INCLUDE_DIR finds include directories needed for compiling\n+#   programs using the JNI interface.\n+#\n+#   JNI include directories are usually in the Java distribution. This is\n+#   deduced from the value of $JAVA_HOME, $JAVAC, or the path to \"javac\", in\n+#   that order. When this macro completes, a list of directories is left in\n+#   the variable JNI_INCLUDE_DIRS.\n+#\n+#   Example usage follows:\n+#\n+#     AX_JNI_INCLUDE_DIR\n+#\n+#     for JNI_INCLUDE_DIR in $JNI_INCLUDE_DIRS\n+#     do\n+#             CPPFLAGS=\"$CPPFLAGS -I$JNI_INCLUDE_DIR\"\n+#     done\n+#\n+#   If you want to force a specific compiler:\n+#\n+#   - at the configure.in level, set JAVAC=yourcompiler before calling\n+#   AX_JNI_INCLUDE_DIR\n+#\n+#   - at the configure level, setenv JAVAC\n+#\n+#   Note: This macro can work with the autoconf M4 macros for Java programs.\n+#   This particular macro is not part of the original set of macros.\n+#\n+# LICENSE\n+#\n+#   Copyright (c) 2008 Don Anderson <dda@sleepycat.com>\n+#\n+#   Copying and distribution of this file, with or without modification, are\n+#   permitted in any medium without royalty provided the copyright notice\n+#   and this notice are preserved. This file is offered as-is, without any\n+#   warranty.\n+\n+#serial 10\n+\n+AU_ALIAS([AC_JNI_INCLUDE_DIR], [AX_JNI_INCLUDE_DIR])\n+AC_DEFUN([AX_JNI_INCLUDE_DIR],[\n+\n+JNI_INCLUDE_DIRS=\"\"\n+\n+if test \"x$JAVA_HOME\" != x; then\n+\t_JTOPDIR=\"$JAVA_HOME\"\n+else\n+\tif test \"x$JAVAC\" = x; then\n+\t\tJAVAC=javac\n+\tfi\n+\tAC_PATH_PROG([_ACJNI_JAVAC], [$JAVAC], [no])\n+\tif test \"x$_ACJNI_JAVAC\" = xno; then\n+\t\tAC_MSG_WARN([cannot find JDK; try setting \\$JAVAC or \\$JAVA_HOME])\n+\tfi\n+\t_ACJNI_FOLLOW_SYMLINKS(\"$_ACJNI_JAVAC\")\n+\t_JTOPDIR=`echo \"$_ACJNI_FOLLOWED\" | sed -e 's://*:/:g' -e 's:/[[^/]]*$::'`\n+fi\n+\n+case \"$host_os\" in\n+        darwin*)        _JTOPDIR=`echo \"$_JTOPDIR\" | sed -e 's:/[[^/]]*$::'`\n+                        _JINC=\"$_JTOPDIR/Headers\";;\n+        *)              _JINC=\"$_JTOPDIR/include\";;\n+esac\n+_AS_ECHO_LOG([_JTOPDIR=$_JTOPDIR])\n+_AS_ECHO_LOG([_JINC=$_JINC])\n+\n+# On Mac OS X 10.6.4, jni.h is a symlink:\n+# /System/Library/Frameworks/JavaVM.framework/Versions/Current/Headers/jni.h\n+# -> ../../CurrentJDK/Headers/jni.h.\n+\n+AC_CACHE_CHECK(jni headers, ac_cv_jni_header_path,\n+[\n+if test -f \"$_JINC/jni.h\"; then\n+  ac_cv_jni_header_path=\"$_JINC\"\n+  JNI_INCLUDE_DIRS=\"$JNI_INCLUDE_DIRS $ac_cv_jni_header_path\"\n+else\n+  _JTOPDIR=`echo \"$_JTOPDIR\" | sed -e 's:/[[^/]]*$::'`\n+  if test -f \"$_JTOPDIR/include/jni.h\"; then\n+    ac_cv_jni_header_path=\"$_JTOPDIR/include\"\n+    JNI_INCLUDE_DIRS=\"$JNI_INCLUDE_DIRS $ac_cv_jni_header_path\"\n+  else\n+    ac_cv_jni_header_path=none\n+  fi\n+fi\n+])\n+\n+\n+\n+# get the likely subdirectories for system specific java includes\n+case \"$host_os\" in\n+bsdi*)          _JNI_INC_SUBDIRS=\"bsdos\";;\n+darwin*)        _JNI_INC_SUBDIRS=\"darwin\";;\n+freebsd*)       _JNI_INC_SUBDIRS=\"freebsd\";;\n+linux*)         _JNI_INC_SUBDIRS=\"linux genunix\";;\n+osf*)           _JNI_INC_SUBDIRS=\"alpha\";;\n+solaris*)       _JNI_INC_SUBDIRS=\"solaris\";;\n+mingw*)\t\t_JNI_INC_SUBDIRS=\"win32\";;\n+cygwin*)\t_JNI_INC_SUBDIRS=\"win32\";;\n+*)              _JNI_INC_SUBDIRS=\"genunix\";;\n+esac\n+\n+if test \"x$ac_cv_jni_header_path\" != \"xnone\"; then\n+  # add any subdirectories that are present\n+  for JINCSUBDIR in $_JNI_INC_SUBDIRS\n+  do\n+      if test -d \"$_JTOPDIR/include/$JINCSUBDIR\"; then\n+           JNI_INCLUDE_DIRS=\"$JNI_INCLUDE_DIRS $_JTOPDIR/include/$JINCSUBDIR\"\n+      fi\n+  done\n+fi\n+])\n+\n+# _ACJNI_FOLLOW_SYMLINKS <path>\n+# Follows symbolic links on <path>,\n+# finally setting variable _ACJNI_FOLLOWED\n+# ----------------------------------------\n+AC_DEFUN([_ACJNI_FOLLOW_SYMLINKS],[\n+# find the include directory relative to the javac executable\n+_cur=\"$1\"\n+while ls -ld \"$_cur\" 2>/dev/null | grep \" -> \" >/dev/null; do\n+        AC_MSG_CHECKING([symlink for $_cur])\n+        _slink=`ls -ld \"$_cur\" | sed 's/.* -> //'`\n+        case \"$_slink\" in\n+        /*) _cur=\"$_slink\";;\n+        # 'X' avoids triggering unwanted echo options.\n+        *) _cur=`echo \"X$_cur\" | sed -e 's/^X//' -e 's:[[^/]]*$::'`\"$_slink\";;\n+        esac\n+        AC_MSG_RESULT([$_cur])\n+done\n+_ACJNI_FOLLOWED=\"$_cur\"\n+])# _ACJNI"
      },
      {
        "sha": "b74acb8c138823c67e7fd0a11d059a90bd2551a9",
        "filename": "src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "status": "modified",
        "additions": 6,
        "deletions": 2,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/build-aux/m4/bitcoin_secp.m4?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -3,13 +3,13 @@ AC_DEFUN([SECP_INT128_CHECK],[\n has_int128=$ac_cv_type___int128\n ])\n \n-dnl \n+dnl escape \"$0x\" below using the m4 quadrigaph @S|@, and escape it again with a \\ for the shell.\n AC_DEFUN([SECP_64BIT_ASM_CHECK],[\n AC_MSG_CHECKING(for x86_64 assembly availability)\n AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n   #include <stdint.h>]],[[\n   uint64_t a = 11, tmp;\n-  __asm__ __volatile__(\"movq $0x100000000,%1; mulq %%rsi\" : \"+a\"(a) : \"S\"(tmp) : \"cc\", \"%rdx\");\n+  __asm__ __volatile__(\"movq \\@S|@0x100000000,%1; mulq %%rsi\" : \"+a\"(a) : \"S\"(tmp) : \"cc\", \"%rdx\");\n   ]])],[has_64bit_asm=yes],[has_64bit_asm=no])\n AC_MSG_RESULT([$has_64bit_asm])\n ])\n@@ -46,6 +46,10 @@ if test x\"$has_libcrypto\" = x\"yes\" && test x\"$has_openssl_ec\" = x; then\n     ECDSA_sign(0, NULL, 0, NULL, NULL, eckey);\n     ECDSA_verify(0, NULL, 0, NULL, 0, eckey);\n     EC_KEY_free(eckey);\n+    ECDSA_SIG *sig_openssl;\n+    sig_openssl = ECDSA_SIG_new();\n+    (void)sig_openssl->r;\n+    ECDSA_SIG_free(sig_openssl);\n   ]])],[has_openssl_ec=yes],[has_openssl_ec=no])\n   AC_MSG_RESULT([$has_openssl_ec])\n fi"
      },
      {
        "sha": "ec50ffe3a251b653cdcd9eb88b887e6374934c0e",
        "filename": "src/secp256k1/configure.ac",
        "status": "modified",
        "additions": 130,
        "deletions": 28,
        "changes": 158,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/configure.ac?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -29,6 +29,7 @@ AC_PROG_CC_C89\n if test x\"$ac_cv_prog_cc_c89\" = x\"no\"; then\n   AC_MSG_ERROR([c89 compiler support required])\n fi\n+AM_PROG_AS\n \n case $host_os in\n   *darwin*)\n@@ -93,31 +94,46 @@ AC_ARG_ENABLE(tests,\n     [use_tests=$enableval],\n     [use_tests=yes])\n \n+AC_ARG_ENABLE(openssl_tests,\n+    AS_HELP_STRING([--enable-openssl-tests],[enable OpenSSL tests, if OpenSSL is available (default is auto)]),\n+    [enable_openssl_tests=$enableval],\n+    [enable_openssl_tests=auto])\n+\n+AC_ARG_ENABLE(experimental,\n+    AS_HELP_STRING([--enable-experimental],[allow experimental configure options (default is no)]),\n+    [use_experimental=$enableval],\n+    [use_experimental=no])\n+\n+AC_ARG_ENABLE(exhaustive_tests,\n+    AS_HELP_STRING([--enable-exhaustive-tests],[compile exhaustive tests (default is yes)]),\n+    [use_exhaustive_tests=$enableval],\n+    [use_exhaustive_tests=yes])\n+\n AC_ARG_ENABLE(endomorphism,\n     AS_HELP_STRING([--enable-endomorphism],[enable endomorphism (default is no)]),\n     [use_endomorphism=$enableval],\n     [use_endomorphism=no])\n-    \n+\n AC_ARG_ENABLE(ecmult_static_precomputation,\n     AS_HELP_STRING([--enable-ecmult-static-precomputation],[enable precomputed ecmult table for signing (default is yes)]),\n     [use_ecmult_static_precomputation=$enableval],\n-    [use_ecmult_static_precomputation=yes])\n+    [use_ecmult_static_precomputation=auto])\n \n AC_ARG_ENABLE(module_ecdh,\n-    AS_HELP_STRING([--enable-module-ecdh],[enable ECDH shared secret computation (default is no)]),\n+    AS_HELP_STRING([--enable-module-ecdh],[enable ECDH shared secret computation (experimental)]),\n     [enable_module_ecdh=$enableval],\n     [enable_module_ecdh=no])\n \n-AC_ARG_ENABLE(module_schnorr,\n-    AS_HELP_STRING([--enable-module-schnorr],[enable Schnorr signature module (default is no)]),\n-    [enable_module_schnorr=$enableval],\n-    [enable_module_schnorr=no])\n-\n AC_ARG_ENABLE(module_recovery,\n     AS_HELP_STRING([--enable-module-recovery],[enable ECDSA pubkey recovery module (default is no)]),\n     [enable_module_recovery=$enableval],\n     [enable_module_recovery=no])\n \n+AC_ARG_ENABLE(jni,\n+    AS_HELP_STRING([--enable-jni],[enable libsecp256k1_jni (default is auto)]),\n+    [use_jni=$enableval],\n+    [use_jni=auto])\n+\n AC_ARG_WITH([field], [AS_HELP_STRING([--with-field=64bit|32bit|auto],\n [Specify Field Implementation. Default is auto])],[req_field=$withval], [req_field=auto])\n \n@@ -127,8 +143,8 @@ AC_ARG_WITH([bignum], [AS_HELP_STRING([--with-bignum=gmp|no|auto],\n AC_ARG_WITH([scalar], [AS_HELP_STRING([--with-scalar=64bit|32bit|auto],\n [Specify scalar implementation. Default is auto])],[req_scalar=$withval], [req_scalar=auto])\n \n-AC_ARG_WITH([asm], [AS_HELP_STRING([--with-asm=x86_64|no|auto]\n-[Specify assembly optimizations to use. Default is auto])],[req_asm=$withval], [req_asm=auto])\n+AC_ARG_WITH([asm], [AS_HELP_STRING([--with-asm=x86_64|arm|no|auto]\n+[Specify assembly optimizations to use. Default is auto (experimental: arm)])],[req_asm=$withval], [req_asm=auto])\n \n AC_CHECK_TYPES([__int128])\n \n@@ -138,6 +154,34 @@ AC_COMPILE_IFELSE([AC_LANG_SOURCE([[void myfunc() {__builtin_expect(0,0);}]])],\n     [ AC_MSG_RESULT([no])\n     ])\n \n+if test x\"$use_ecmult_static_precomputation\" != x\"no\"; then\n+  save_cross_compiling=$cross_compiling\n+  cross_compiling=no\n+  TEMP_CC=\"$CC\"\n+  CC=\"$CC_FOR_BUILD\"\n+  AC_MSG_CHECKING([native compiler: ${CC_FOR_BUILD}])\n+  AC_RUN_IFELSE(\n+    [AC_LANG_PROGRAM([], [return 0])],\n+    [working_native_cc=yes],\n+    [working_native_cc=no],[dnl])\n+  CC=\"$TEMP_CC\"\n+  cross_compiling=$save_cross_compiling\n+\n+  if test x\"$working_native_cc\" = x\"no\"; then\n+    set_precomp=no\n+    if test x\"$use_ecmult_static_precomputation\" = x\"yes\";  then\n+      AC_MSG_ERROR([${CC_FOR_BUILD} does not produce working binaries. Please set CC_FOR_BUILD])\n+    else\n+      AC_MSG_RESULT([${CC_FOR_BUILD} does not produce working binaries. Please set CC_FOR_BUILD])\n+    fi\n+  else\n+    AC_MSG_RESULT([ok])\n+    set_precomp=yes\n+  fi\n+else\n+  set_precomp=no\n+fi\n+\n if test x\"$req_asm\" = x\"auto\"; then\n   SECP_64BIT_ASM_CHECK\n   if test x\"$has_64bit_asm\" = x\"yes\"; then\n@@ -155,6 +199,8 @@ else\n       AC_MSG_ERROR([x86_64 assembly optimization requested but not available])\n     fi\n     ;;\n+  arm)\n+    ;;\n   no)\n     ;;\n   *)\n@@ -247,10 +293,15 @@ else\n fi\n \n # select assembly optimization\n+use_external_asm=no\n+\n case $set_asm in\n x86_64)\n   AC_DEFINE(USE_ASM_X86_64, 1, [Define this symbol to enable x86_64 assembly optimizations])\n   ;;\n+arm)\n+  use_external_asm=yes\n+  ;;\n no)\n   ;;\n *)\n@@ -305,16 +356,48 @@ esac\n if test x\"$use_tests\" = x\"yes\"; then\n   SECP_OPENSSL_CHECK\n   if test x\"$has_openssl_ec\" = x\"yes\"; then\n-    AC_DEFINE(ENABLE_OPENSSL_TESTS, 1, [Define this symbol if OpenSSL EC functions are available])\n-    SECP_TEST_INCLUDES=\"$SSL_CFLAGS $CRYPTO_CFLAGS\"\n-    SECP_TEST_LIBS=\"$CRYPTO_LIBS\"\n-\n-    case $host in\n-    *mingw*)\n-      SECP_TEST_LIBS=\"$SECP_TEST_LIBS -lgdi32\"\n-      ;;\n-    esac\n+    if test x\"$enable_openssl_tests\" != x\"no\"; then\n+      AC_DEFINE(ENABLE_OPENSSL_TESTS, 1, [Define this symbol if OpenSSL EC functions are available])\n+      SECP_TEST_INCLUDES=\"$SSL_CFLAGS $CRYPTO_CFLAGS\"\n+      SECP_TEST_LIBS=\"$CRYPTO_LIBS\"\n+\n+      case $host in\n+      *mingw*)\n+        SECP_TEST_LIBS=\"$SECP_TEST_LIBS -lgdi32\"\n+        ;;\n+      esac\n+    fi\n+  else\n+    if test x\"$enable_openssl_tests\" = x\"yes\"; then\n+      AC_MSG_ERROR([OpenSSL tests requested but OpenSSL with EC support is not available])\n+    fi\n+  fi\n+else\n+  if test x\"$enable_openssl_tests\" = x\"yes\"; then\n+    AC_MSG_ERROR([OpenSSL tests requested but tests are not enabled])\n+  fi\n+fi\n \n+if test x\"$use_jni\" != x\"no\"; then\n+  AX_JNI_INCLUDE_DIR\n+  have_jni_dependencies=yes\n+  if test x\"$enable_module_ecdh\" = x\"no\"; then\n+    have_jni_dependencies=no\n+  fi\n+  if test \"x$JNI_INCLUDE_DIRS\" = \"x\"; then\n+    have_jni_dependencies=no\n+  fi\n+  if test \"x$have_jni_dependencies\" = \"xno\"; then\n+    if test x\"$use_jni\" = x\"yes\"; then\n+      AC_MSG_ERROR([jni support explicitly requested but headers/dependencies were not found. Enable ECDH and try again.])\n+    fi\n+    AC_MSG_WARN([jni headers/dependencies not found. jni support disabled])\n+    use_jni=no\n+  else\n+    use_jni=yes\n+    for JNI_INCLUDE_DIR in $JNI_INCLUDE_DIRS; do\n+      JNI_INCLUDES=\"$JNI_INCLUDES -I$JNI_INCLUDE_DIR\"\n+    done\n   fi\n fi\n \n@@ -327,46 +410,65 @@ if test x\"$use_endomorphism\" = x\"yes\"; then\n   AC_DEFINE(USE_ENDOMORPHISM, 1, [Define this symbol to use endomorphism optimization])\n fi\n \n-if test x\"$use_ecmult_static_precomputation\" = x\"yes\"; then\n+if test x\"$set_precomp\" = x\"yes\"; then\n   AC_DEFINE(USE_ECMULT_STATIC_PRECOMPUTATION, 1, [Define this symbol to use a statically generated ecmult table])\n fi\n \n if test x\"$enable_module_ecdh\" = x\"yes\"; then\n   AC_DEFINE(ENABLE_MODULE_ECDH, 1, [Define this symbol to enable the ECDH module])\n fi\n \n-if test x\"$enable_module_schnorr\" = x\"yes\"; then\n-  AC_DEFINE(ENABLE_MODULE_SCHNORR, 1, [Define this symbol to enable the Schnorr signature module])\n-fi\n-\n if test x\"$enable_module_recovery\" = x\"yes\"; then\n   AC_DEFINE(ENABLE_MODULE_RECOVERY, 1, [Define this symbol to enable the ECDSA pubkey recovery module])\n fi\n \n AC_C_BIGENDIAN()\n \n+if test x\"$use_external_asm\" = x\"yes\"; then\n+  AC_DEFINE(USE_EXTERNAL_ASM, 1, [Define this symbol if an external (non-inline) assembly implementation is used])\n+fi\n+\n+AC_MSG_NOTICE([Using static precomputation: $set_precomp])\n AC_MSG_NOTICE([Using assembly optimizations: $set_asm])\n AC_MSG_NOTICE([Using field implementation: $set_field])\n AC_MSG_NOTICE([Using bignum implementation: $set_bignum])\n AC_MSG_NOTICE([Using scalar implementation: $set_scalar])\n AC_MSG_NOTICE([Using endomorphism optimizations: $use_endomorphism])\n AC_MSG_NOTICE([Building ECDH module: $enable_module_ecdh])\n-\n-AC_MSG_NOTICE([Building Schnorr signatures module: $enable_module_schnorr])\n AC_MSG_NOTICE([Building ECDSA pubkey recovery module: $enable_module_recovery])\n+AC_MSG_NOTICE([Using jni: $use_jni])\n+\n+if test x\"$enable_experimental\" = x\"yes\"; then\n+  AC_MSG_NOTICE([******])\n+  AC_MSG_NOTICE([WARNING: experimental build])\n+  AC_MSG_NOTICE([Experimental features do not have stable APIs or properties, and may not be safe for production use.])\n+  AC_MSG_NOTICE([Building ECDH module: $enable_module_ecdh])\n+  AC_MSG_NOTICE([******])\n+else\n+  if test x\"$enable_module_ecdh\" = x\"yes\"; then\n+    AC_MSG_ERROR([ECDH module is experimental. Use --enable-experimental to allow.])\n+  fi\n+  if test x\"$set_asm\" = x\"arm\"; then\n+    AC_MSG_ERROR([ARM assembly optimization is experimental. Use --enable-experimental to allow.])\n+  fi\n+fi\n \n AC_CONFIG_HEADERS([src/libsecp256k1-config.h])\n AC_CONFIG_FILES([Makefile libsecp256k1.pc])\n+AC_SUBST(JNI_INCLUDES)\n AC_SUBST(SECP_INCLUDES)\n AC_SUBST(SECP_LIBS)\n AC_SUBST(SECP_TEST_LIBS)\n AC_SUBST(SECP_TEST_INCLUDES)\n AM_CONDITIONAL([USE_TESTS], [test x\"$use_tests\" != x\"no\"])\n+AM_CONDITIONAL([USE_EXHAUSTIVE_TESTS], [test x\"$use_exhaustive_tests\" != x\"no\"])\n AM_CONDITIONAL([USE_BENCHMARK], [test x\"$use_benchmark\" = x\"yes\"])\n-AM_CONDITIONAL([USE_ECMULT_STATIC_PRECOMPUTATION], [test x\"$use_ecmult_static_precomputation\" = x\"yes\"])\n+AM_CONDITIONAL([USE_ECMULT_STATIC_PRECOMPUTATION], [test x\"$set_precomp\" = x\"yes\"])\n AM_CONDITIONAL([ENABLE_MODULE_ECDH], [test x\"$enable_module_ecdh\" = x\"yes\"])\n-AM_CONDITIONAL([ENABLE_MODULE_SCHNORR], [test x\"$enable_module_schnorr\" = x\"yes\"])\n AM_CONDITIONAL([ENABLE_MODULE_RECOVERY], [test x\"$enable_module_recovery\" = x\"yes\"])\n+AM_CONDITIONAL([USE_JNI], [test x\"$use_jni\" == x\"yes\"])\n+AM_CONDITIONAL([USE_EXTERNAL_ASM], [test x\"$use_external_asm\" = x\"yes\"])\n+AM_CONDITIONAL([USE_ASM_ARM], [test x\"$set_asm\" = x\"arm\"])\n \n dnl make sure nothing new is exported so that we don't break the cache\n PKGCONFIG_PATH_TEMP=\"$PKG_CONFIG_PATH\""
      },
      {
        "sha": "f268e309d0bf5d0db21bc61224bb798aba14dbf0",
        "filename": "src/secp256k1/include/secp256k1.h",
        "status": "modified",
        "additions": 4,
        "deletions": 10,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/include/secp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/include/secp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1.h?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -47,11 +47,8 @@ typedef struct secp256k1_context_struct secp256k1_context;\n  *  The exact representation of data inside is implementation defined and not\n  *  guaranteed to be portable between different platforms or versions. It is\n  *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n- *  If you need to convert to a format suitable for storage or transmission, use\n- *  secp256k1_ec_pubkey_serialize and secp256k1_ec_pubkey_parse.\n- *\n- *  Furthermore, it is guaranteed that identical public keys (ignoring\n- *  compression) will have identical representation, so they can be memcmp'ed.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use secp256k1_ec_pubkey_serialize and secp256k1_ec_pubkey_parse.\n  */\n typedef struct {\n     unsigned char data[64];\n@@ -62,12 +59,9 @@ typedef struct {\n  *  The exact representation of data inside is implementation defined and not\n  *  guaranteed to be portable between different platforms or versions. It is\n  *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n- *  If you need to convert to a format suitable for storage or transmission, use\n- *  the secp256k1_ecdsa_signature_serialize_* and\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the secp256k1_ecdsa_signature_serialize_* and\n  *  secp256k1_ecdsa_signature_serialize_* functions.\n- *\n- *  Furthermore, it is guaranteed to identical signatures will have identical\n- *  representation, so they can be memcmp'ed.\n  */\n typedef struct {\n     unsigned char data[64];"
      },
      {
        "sha": "dc32fec1eac0380e687399c0cf66e0c44cb2e1a3",
        "filename": "src/secp256k1/include/secp256k1_schnorr.h",
        "status": "removed",
        "additions": 0,
        "deletions": 173,
        "changes": 173,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e591c1049fe5e0256ac14a92f460f374a55ffd4e/src/secp256k1/include/secp256k1_schnorr.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e591c1049fe5e0256ac14a92f460f374a55ffd4e/src/secp256k1/include/secp256k1_schnorr.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1_schnorr.h?ref=e591c1049fe5e0256ac14a92f460f374a55ffd4e",
        "patch": "@@ -1,173 +0,0 @@\n-#ifndef _SECP256K1_SCHNORR_\n-# define _SECP256K1_SCHNORR_\n-\n-# include \"secp256k1.h\"\n-\n-# ifdef __cplusplus\n-extern \"C\" {\n-# endif\n-\n-/** Create a signature using a custom EC-Schnorr-SHA256 construction. It\n- *  produces non-malleable 64-byte signatures which support public key recovery\n- *  batch validation, and multiparty signing.\n- *  Returns: 1: signature created\n- *           0: the nonce generation function failed, or the private key was\n- *              invalid.\n- *  Args:    ctx:    pointer to a context object, initialized for signing\n- *                   (cannot be NULL)\n- *  Out:     sig64:  pointer to a 64-byte array where the signature will be\n- *                   placed (cannot be NULL)\n- *  In:      msg32:  the 32-byte message hash being signed (cannot be NULL)\n- *           seckey: pointer to a 32-byte secret key (cannot be NULL)\n- *           noncefp:pointer to a nonce generation function. If NULL,\n- *                   secp256k1_nonce_function_default is used\n- *           ndata:  pointer to arbitrary data used by the nonce generation\n- *                   function (can be NULL)\n- */\n-SECP256K1_API int secp256k1_schnorr_sign(\n-  const secp256k1_context* ctx,\n-  unsigned char *sig64,\n-  const unsigned char *msg32,\n-  const unsigned char *seckey,\n-  secp256k1_nonce_function noncefp,\n-  const void *ndata\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n-\n-/** Verify a signature created by secp256k1_schnorr_sign.\n- *  Returns: 1: correct signature\n- *           0: incorrect signature\n- *  Args:    ctx:       a secp256k1 context object, initialized for verification.\n- *  In:      sig64:     the 64-byte signature being verified (cannot be NULL)\n- *           msg32:     the 32-byte message hash being verified (cannot be NULL)\n- *           pubkey:    the public key to verify with (cannot be NULL)\n- */\n-SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_schnorr_verify(\n-  const secp256k1_context* ctx,\n-  const unsigned char *sig64,\n-  const unsigned char *msg32,\n-  const secp256k1_pubkey *pubkey\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n-\n-/** Recover an EC public key from a Schnorr signature created using\n- *  secp256k1_schnorr_sign.\n- *  Returns: 1: public key successfully recovered (which guarantees a correct\n- *           signature).\n- *           0: otherwise.\n- *  Args:    ctx:        pointer to a context object, initialized for\n- *                       verification (cannot be NULL)\n- *  Out:     pubkey:     pointer to a pubkey to set to the recovered public key\n- *                       (cannot be NULL).\n- *  In:      sig64:      signature as 64 byte array (cannot be NULL)\n- *           msg32:      the 32-byte message hash assumed to be signed (cannot\n- *                       be NULL)\n- */\n-SECP256K1_API int secp256k1_schnorr_recover(\n-  const secp256k1_context* ctx,\n-  secp256k1_pubkey *pubkey,\n-  const unsigned char *sig64,\n-  const unsigned char *msg32\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n-\n-/** Generate a nonce pair deterministically for use with\n- *  secp256k1_schnorr_partial_sign.\n- *  Returns: 1: valid nonce pair was generated.\n- *           0: otherwise (nonce generation function failed)\n- *  Args:    ctx:         pointer to a context object, initialized for signing\n- *                        (cannot be NULL)\n- *  Out:     pubnonce:    public side of the nonce (cannot be NULL)\n- *           privnonce32: private side of the nonce (32 byte) (cannot be NULL)\n- *  In:      msg32:       the 32-byte message hash assumed to be signed (cannot\n- *                        be NULL)\n- *           sec32:       the 32-byte private key (cannot be NULL)\n- *           noncefp:     pointer to a nonce generation function. If NULL,\n- *                        secp256k1_nonce_function_default is used\n- *           noncedata:   pointer to arbitrary data used by the nonce generation\n- *                        function (can be NULL)\n- *\n- *  Do not use the output as a private/public key pair for signing/validation.\n- */\n-SECP256K1_API int secp256k1_schnorr_generate_nonce_pair(\n-  const secp256k1_context* ctx,\n-  secp256k1_pubkey *pubnonce,\n-  unsigned char *privnonce32,\n-  const unsigned char *msg32,\n-  const unsigned char *sec32,\n-  secp256k1_nonce_function noncefp,\n-  const void* noncedata\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n-\n-/** Produce a partial Schnorr signature, which can be combined using\n- *  secp256k1_schnorr_partial_combine, to end up with a full signature that is\n- *  verifiable using secp256k1_schnorr_verify.\n- *  Returns: 1: signature created successfully.\n- *           0: no valid signature exists with this combination of keys, nonces\n- *              and message (chance around 1 in 2^128)\n- *          -1: invalid private key, nonce, or public nonces.\n- *  Args: ctx:             pointer to context object, initialized for signing (cannot\n- *                         be NULL)\n- *  Out:  sig64:           pointer to 64-byte array to put partial signature in\n- *  In:   msg32:           pointer to 32-byte message to sign\n- *        sec32:           pointer to 32-byte private key\n- *        pubnonce_others: pointer to pubkey containing the sum of the other's\n- *                         nonces (see secp256k1_ec_pubkey_combine)\n- *        secnonce32:      pointer to 32-byte array containing our nonce\n- *\n- * The intended procedure for creating a multiparty signature is:\n- * - Each signer S[i] with private key x[i] and public key Q[i] runs\n- *   secp256k1_schnorr_generate_nonce_pair to produce a pair (k[i],R[i]) of\n- *   private/public nonces.\n- * - All signers communicate their public nonces to each other (revealing your\n- *   private nonce can lead to discovery of your private key, so it should be\n- *   considered secret).\n- * - All signers combine all the public nonces they received (excluding their\n- *   own) using secp256k1_ec_pubkey_combine to obtain an\n- *   Rall[i] = sum(R[0..i-1,i+1..n]).\n- * - All signers produce a partial signature using\n- *   secp256k1_schnorr_partial_sign, passing in their own private key x[i],\n- *   their own private nonce k[i], and the sum of the others' public nonces\n- *   Rall[i].\n- * - All signers communicate their partial signatures to each other.\n- * - Someone combines all partial signatures using\n- *   secp256k1_schnorr_partial_combine, to obtain a full signature.\n- * - The resulting signature is validatable using secp256k1_schnorr_verify, with\n- *   public key equal to the result of secp256k1_ec_pubkey_combine of the\n- *   signers' public keys (sum(Q[0..n])).\n- *\n- *  Note that secp256k1_schnorr_partial_combine and secp256k1_ec_pubkey_combine\n- *  function take their arguments in any order, and it is possible to\n- *  pre-combine several inputs already with one call, and add more inputs later\n- *  by calling the function again (they are commutative and associative).\n- */\n-SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_schnorr_partial_sign(\n-  const secp256k1_context* ctx,\n-  unsigned char *sig64,\n-  const unsigned char *msg32,\n-  const unsigned char *sec32,\n-  const secp256k1_pubkey *pubnonce_others,\n-  const unsigned char *secnonce32\n-) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4) SECP256K1_ARG_NONNULL(5) SECP256K1_ARG_NONNULL(6);\n-\n-/** Combine multiple Schnorr partial signatures.\n- * Returns: 1: the passed signatures were successfully combined.\n- *          0: the resulting signature is not valid (chance of 1 in 2^256)\n- *         -1: some inputs were invalid, or the signatures were not created\n- *             using the same set of nonces\n- * Args:   ctx:      pointer to a context object\n- * Out:    sig64:    pointer to a 64-byte array to place the combined signature\n- *                   (cannot be NULL)\n- * In:     sig64sin: pointer to an array of n pointers to 64-byte input\n- *                   signatures\n- *         n:        the number of signatures to combine (at least 1)\n- */\n-SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_schnorr_partial_combine(\n-  const secp256k1_context* ctx,\n-  unsigned char *sig64,\n-  const unsigned char * const * sig64sin,\n-  size_t n\n-) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n-\n-# ifdef __cplusplus\n-}\n-# endif\n-\n-#endif"
      },
      {
        "sha": "a0d006f1131f47d9bb80de6d425e38912e1258f0",
        "filename": "src/secp256k1/libsecp256k1.pc.in",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/libsecp256k1.pc.in",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/libsecp256k1.pc.in",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/libsecp256k1.pc.in?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -5,7 +5,7 @@ includedir=@includedir@\n \n Name: libsecp256k1\n Description: Optimized C library for EC operations on curve secp256k1\n-URL: https://github.com/bitcoin/secp256k1\n+URL: https://github.com/bitcoin-core/secp256k1\n Version: @PACKAGE_VERSION@\n Cflags: -I${includedir}\n Libs.private: @SECP_LIBS@"
      },
      {
        "sha": "ab580c5b23bbf786f41757b8a3800958db37c7a7",
        "filename": "src/secp256k1/sage/group_prover.sage",
        "status": "added",
        "additions": 322,
        "deletions": 0,
        "changes": 322,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/sage/group_prover.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/sage/group_prover.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/sage/group_prover.sage?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -0,0 +1,322 @@\n+# This code supports verifying group implementations which have branches\n+# or conditional statements (like cmovs), by allowing each execution path\n+# to independently set assumptions on input or intermediary variables.\n+#\n+# The general approach is:\n+# * A constraint is a tuple of two sets of of symbolic expressions:\n+#   the first of which are required to evaluate to zero, the second of which\n+#   are required to evaluate to nonzero.\n+#   - A constraint is said to be conflicting if any of its nonzero expressions\n+#     is in the ideal with basis the zero expressions (in other words: when the\n+#     zero expressions imply that one of the nonzero expressions are zero).\n+# * There is a list of laws that describe the intended behaviour, including\n+#   laws for addition and doubling. Each law is called with the symbolic point\n+#   coordinates as arguments, and returns:\n+#   - A constraint describing the assumptions under which it is applicable,\n+#     called \"assumeLaw\"\n+#   - A constraint describing the requirements of the law, called \"require\"\n+# * Implementations are transliterated into functions that operate as well on\n+#   algebraic input points, and are called once per combination of branches\n+#   exectured. Each execution returns:\n+#   - A constraint describing the assumptions this implementation requires\n+#     (such as Z1=1), called \"assumeFormula\"\n+#   - A constraint describing the assumptions this specific branch requires,\n+#     but which is by construction guaranteed to cover the entire space by\n+#     merging the results from all branches, called \"assumeBranch\"\n+#   - The result of the computation\n+# * All combinations of laws with implementation branches are tried, and:\n+#   - If the combination of assumeLaw, assumeFormula, and assumeBranch results\n+#     in a conflict, it means this law does not apply to this branch, and it is\n+#     skipped.\n+#   - For others, we try to prove the require constraints hold, assuming the\n+#     information in assumeLaw + assumeFormula + assumeBranch, and if this does\n+#     not succeed, we fail.\n+#     + To prove an expression is zero, we check whether it belongs to the\n+#       ideal with the assumed zero expressions as basis. This test is exact.\n+#     + To prove an expression is nonzero, we check whether each of its\n+#       factors is contained in the set of nonzero assumptions' factors.\n+#       This test is not exact, so various combinations of original and\n+#       reduced expressions' factors are tried.\n+#   - If we succeed, we print out the assumptions from assumeFormula that\n+#     weren't implied by assumeLaw already. Those from assumeBranch are skipped,\n+#     as we assume that all constraints in it are complementary with each other.\n+#\n+# Based on the sage verification scripts used in the Explicit-Formulas Database\n+# by Tanja Lange and others, see http://hyperelliptic.org/EFD\n+\n+class fastfrac:\n+  \"\"\"Fractions over rings.\"\"\"\n+\n+  def __init__(self,R,top,bot=1):\n+    \"\"\"Construct a fractional, given a ring, a numerator, and denominator.\"\"\"\n+    self.R = R\n+    if parent(top) == ZZ or parent(top) == R:\n+      self.top = R(top)\n+      self.bot = R(bot)\n+    elif top.__class__ == fastfrac:\n+      self.top = top.top\n+      self.bot = top.bot * bot\n+    else:\n+      self.top = R(numerator(top))\n+      self.bot = R(denominator(top)) * bot\n+\n+  def iszero(self,I):\n+    \"\"\"Return whether this fraction is zero given an ideal.\"\"\"\n+    return self.top in I and self.bot not in I\n+\n+  def reduce(self,assumeZero):\n+    zero = self.R.ideal(map(numerator, assumeZero))\n+    return fastfrac(self.R, zero.reduce(self.top)) / fastfrac(self.R, zero.reduce(self.bot))\n+\n+  def __add__(self,other):\n+    \"\"\"Add two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top + self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot + self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __sub__(self,other):\n+    \"\"\"Subtract two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top - self.bot * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot - self.bot * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __neg__(self):\n+    \"\"\"Return the negation of a fraction.\"\"\"\n+    return fastfrac(self.R,-self.top,self.bot)\n+\n+  def __mul__(self,other):\n+    \"\"\"Multiply two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top * other,self.bot)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.top,self.bot * other.bot)\n+    return NotImplemented\n+\n+  def __rmul__(self,other):\n+    \"\"\"Multiply something else with a fraction.\"\"\"\n+    return self.__mul__(other)\n+\n+  def __div__(self,other):\n+    \"\"\"Divide two fractions.\"\"\"\n+    if parent(other) == ZZ:\n+      return fastfrac(self.R,self.top,self.bot * other)\n+    if other.__class__ == fastfrac:\n+      return fastfrac(self.R,self.top * other.bot,self.bot * other.top)\n+    return NotImplemented\n+\n+  def __pow__(self,other):\n+    \"\"\"Compute a power of a fraction.\"\"\"\n+    if parent(other) == ZZ:\n+      if other < 0:\n+        # Negative powers require flipping top and bottom\n+        return fastfrac(self.R,self.bot ^ (-other),self.top ^ (-other))\n+      else:\n+        return fastfrac(self.R,self.top ^ other,self.bot ^ other)\n+    return NotImplemented\n+\n+  def __str__(self):\n+    return \"fastfrac((\" + str(self.top) + \") / (\" + str(self.bot) + \"))\"\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+  def numerator(self):\n+    return self.top\n+\n+class constraints:\n+  \"\"\"A set of constraints, consisting of zero and nonzero expressions.\n+\n+  Constraints can either be used to express knowledge or a requirement.\n+\n+  Both the fields zero and nonzero are maps from expressions to description\n+  strings. The expressions that are the keys in zero are required to be zero,\n+  and the expressions that are the keys in nonzero are required to be nonzero.\n+\n+  Note that (a != 0) and (b != 0) is the same as (a*b != 0), so all keys in\n+  nonzero could be multiplied into a single key. This is often much less\n+  efficient to work with though, so we keep them separate inside the\n+  constraints. This allows higher-level code to do fast checks on the individual\n+  nonzero elements, or combine them if needed for stronger checks.\n+\n+  We can't multiply the different zero elements, as it would suffice for one of\n+  the factors to be zero, instead of all of them. Instead, the zero elements are\n+  typically combined into an ideal first.\n+  \"\"\"\n+\n+  def __init__(self, **kwargs):\n+    if 'zero' in kwargs:\n+      self.zero = dict(kwargs['zero'])\n+    else:\n+      self.zero = dict()\n+    if 'nonzero' in kwargs:\n+      self.nonzero = dict(kwargs['nonzero'])\n+    else:\n+      self.nonzero = dict()\n+\n+  def negate(self):\n+    return constraints(zero=self.nonzero, nonzero=self.zero)\n+\n+  def __add__(self, other):\n+    zero = self.zero.copy()\n+    zero.update(other.zero)\n+    nonzero = self.nonzero.copy()\n+    nonzero.update(other.nonzero)\n+    return constraints(zero=zero, nonzero=nonzero)\n+\n+  def __str__(self):\n+    return \"constraints(zero=%s,nonzero=%s)\" % (self.zero, self.nonzero)\n+\n+  def __repr__(self):\n+    return \"%s\" % self\n+\n+\n+def conflicts(R, con):\n+  \"\"\"Check whether any of the passed non-zero assumptions is implied by the zero assumptions\"\"\"\n+  zero = R.ideal(map(numerator, con.zero))\n+  if 1 in zero:\n+    return True\n+  # First a cheap check whether any of the individual nonzero terms conflict on\n+  # their own.\n+  for nonzero in con.nonzero:\n+    if nonzero.iszero(zero):\n+      return True\n+  # It can be the case that entries in the nonzero set do not individually\n+  # conflict with the zero set, but their combination does. For example, knowing\n+  # that either x or y is zero is equivalent to having x*y in the zero set.\n+  # Having x or y individually in the nonzero set is not a conflict, but both\n+  # simultaneously is, so that is the right thing to check for.\n+  if reduce(lambda a,b: a * b, con.nonzero, fastfrac(R, 1)).iszero(zero):\n+    return True\n+  return False\n+\n+\n+def get_nonzero_set(R, assume):\n+  \"\"\"Calculate a simple set of nonzero expressions\"\"\"\n+  zero = R.ideal(map(numerator, assume.zero))\n+  nonzero = set()\n+  for nz in map(numerator, assume.nonzero):\n+    for (f,n) in nz.factor():\n+      nonzero.add(f)\n+    rnz = zero.reduce(nz)\n+    for (f,n) in rnz.factor():\n+      nonzero.add(f)\n+  return nonzero\n+\n+\n+def prove_nonzero(R, exprs, assume):\n+  \"\"\"Check whether an expression is provably nonzero, given assumptions\"\"\"\n+  zero = R.ideal(map(numerator, assume.zero))\n+  nonzero = get_nonzero_set(R, assume)\n+  expl = set()\n+  ok = True\n+  for expr in exprs:\n+    if numerator(expr) in zero:\n+      return (False, [exprs[expr]])\n+  allexprs = reduce(lambda a,b: numerator(a)*numerator(b), exprs, 1)\n+  for (f, n) in allexprs.factor():\n+    if f not in nonzero:\n+      ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for (f, n) in zero.reduce(numerator(allexprs)).factor():\n+    if f not in nonzero:\n+      ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for expr in exprs:\n+    for (f,n) in numerator(expr).factor():\n+      if f not in nonzero:\n+        ok = False\n+  if ok:\n+    return (True, None)\n+  ok = True\n+  for expr in exprs:\n+    for (f,n) in zero.reduce(numerator(expr)).factor():\n+      if f not in nonzero:\n+        expl.add(exprs[expr])\n+  if expl:\n+    return (False, list(expl))\n+  else:\n+    return (True, None)\n+\n+\n+def prove_zero(R, exprs, assume):\n+  \"\"\"Check whether all of the passed expressions are provably zero, given assumptions\"\"\"\n+  r, e = prove_nonzero(R, dict(map(lambda x: (fastfrac(R, x.bot, 1), exprs[x]), exprs)), assume)\n+  if not r:\n+    return (False, map(lambda x: \"Possibly zero denominator: %s\" % x, e))\n+  zero = R.ideal(map(numerator, assume.zero))\n+  nonzero = prod(x for x in assume.nonzero)\n+  expl = []\n+  for expr in exprs:\n+    if not expr.iszero(zero):\n+      expl.append(exprs[expr])\n+  if not expl:\n+    return (True, None)\n+  return (False, expl)\n+\n+\n+def describe_extra(R, assume, assumeExtra):\n+  \"\"\"Describe what assumptions are added, given existing assumptions\"\"\"\n+  zerox = assume.zero.copy()\n+  zerox.update(assumeExtra.zero)\n+  zero = R.ideal(map(numerator, assume.zero))\n+  zeroextra = R.ideal(map(numerator, zerox))\n+  nonzero = get_nonzero_set(R, assume)\n+  ret = set()\n+  # Iterate over the extra zero expressions\n+  for base in assumeExtra.zero:\n+    if base not in zero:\n+      add = []\n+      for (f, n) in numerator(base).factor():\n+        if f not in nonzero:\n+          add += [\"%s\" % f]\n+      if add:\n+        ret.add((\" * \".join(add)) + \" = 0 [%s]\" % assumeExtra.zero[base])\n+  # Iterate over the extra nonzero expressions\n+  for nz in assumeExtra.nonzero:\n+    nzr = zeroextra.reduce(numerator(nz))\n+    if nzr not in zeroextra:\n+      for (f,n) in nzr.factor():\n+        if zeroextra.reduce(f) not in nonzero:\n+          ret.add(\"%s != 0\" % zeroextra.reduce(f))\n+  return \", \".join(x for x in ret)\n+\n+\n+def check_symbolic(R, assumeLaw, assumeAssert, assumeBranch, require):\n+  \"\"\"Check a set of zero and nonzero requirements, given a set of zero and nonzero assumptions\"\"\"\n+  assume = assumeLaw + assumeAssert + assumeBranch\n+\n+  if conflicts(R, assume):\n+    # This formula does not apply\n+    return None\n+\n+  describe = describe_extra(R, assumeLaw + assumeBranch, assumeAssert)\n+\n+  ok, msg = prove_zero(R, require.zero, assume)\n+  if not ok:\n+    return \"FAIL, %s fails (assuming %s)\" % (str(msg), describe)\n+\n+  res, expl = prove_nonzero(R, require.nonzero, assume)\n+  if not res:\n+    return \"FAIL, %s fails (assuming %s)\" % (str(expl), describe)\n+\n+  if describe != \"\":\n+    return \"OK (assuming %s)\" % describe\n+  else:\n+    return \"OK\"\n+\n+\n+def concrete_verify(c):\n+  for k in c.zero:\n+    if k != 0:\n+      return (False, c.zero[k])\n+  for k in c.nonzero:\n+    if k == 0:\n+      return (False, c.nonzero[k])\n+  return (True, None)"
      },
      {
        "sha": "a97e732f7fa3ab681a63070eda20455cda3a6c32",
        "filename": "src/secp256k1/sage/secp256k1.sage",
        "status": "added",
        "additions": 306,
        "deletions": 0,
        "changes": 306,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/sage/secp256k1.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/sage/secp256k1.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/sage/secp256k1.sage?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -0,0 +1,306 @@\n+# Test libsecp256k1' group operation implementations using prover.sage\n+\n+import sys\n+\n+load(\"group_prover.sage\")\n+load(\"weierstrass_prover.sage\")\n+\n+def formula_secp256k1_gej_double_var(a):\n+  \"\"\"libsecp256k1's secp256k1_gej_double_var, used by various addition functions\"\"\"\n+  rz = a.Z * a.Y\n+  rz = rz * 2\n+  t1 = a.X^2\n+  t1 = t1 * 3\n+  t2 = t1^2\n+  t3 = a.Y^2\n+  t3 = t3 * 2\n+  t4 = t3^2\n+  t4 = t4 * 2\n+  t3 = t3 * a.X\n+  rx = t3\n+  rx = rx * 4\n+  rx = -rx\n+  rx = rx + t2\n+  t2 = -t2\n+  t3 = t3 * 6\n+  t3 = t3 + t2\n+  ry = t1 * t3\n+  t2 = -t4\n+  ry = ry + t2\n+  return jacobianpoint(rx, ry, rz)\n+\n+def formula_secp256k1_gej_add_var(branch, a, b):\n+  \"\"\"libsecp256k1's secp256k1_gej_add_var\"\"\"\n+  if branch == 0:\n+    return (constraints(), constraints(nonzero={a.Infinity : 'a_infinite'}), b)\n+  if branch == 1:\n+    return (constraints(), constraints(zero={a.Infinity : 'a_finite'}, nonzero={b.Infinity : 'b_infinite'}), a)\n+  z22 = b.Z^2\n+  z12 = a.Z^2\n+  u1 = a.X * z22\n+  u2 = b.X * z12\n+  s1 = a.Y * z22\n+  s1 = s1 * b.Z\n+  s2 = b.Y * z12\n+  s2 = s2 * a.Z\n+  h = -u1\n+  h = h + u2\n+  i = -s1\n+  i = i + s2\n+  if branch == 2:\n+    r = formula_secp256k1_gej_double_var(a)\n+    return (constraints(), constraints(zero={h : 'h=0', i : 'i=0', a.Infinity : 'a_finite', b.Infinity : 'b_finite'}), r)\n+  if branch == 3:\n+    return (constraints(), constraints(zero={h : 'h=0', a.Infinity : 'a_finite', b.Infinity : 'b_finite'}, nonzero={i : 'i!=0'}), point_at_infinity())\n+  i2 = i^2\n+  h2 = h^2\n+  h3 = h2 * h\n+  h = h * b.Z\n+  rz = a.Z * h\n+  t = u1 * h2\n+  rx = t\n+  rx = rx * 2\n+  rx = rx + h3\n+  rx = -rx\n+  rx = rx + i2\n+  ry = -rx\n+  ry = ry + t\n+  ry = ry * i\n+  h3 = h3 * s1\n+  h3 = -h3\n+  ry = ry + h3\n+  return (constraints(), constraints(zero={a.Infinity : 'a_finite', b.Infinity : 'b_finite'}, nonzero={h : 'h!=0'}), jacobianpoint(rx, ry, rz))\n+\n+def formula_secp256k1_gej_add_ge_var(branch, a, b):\n+  \"\"\"libsecp256k1's secp256k1_gej_add_ge_var, which assume bz==1\"\"\"\n+  if branch == 0:\n+    return (constraints(zero={b.Z - 1 : 'b.z=1'}), constraints(nonzero={a.Infinity : 'a_infinite'}), b)\n+  if branch == 1:\n+    return (constraints(zero={b.Z - 1 : 'b.z=1'}), constraints(zero={a.Infinity : 'a_finite'}, nonzero={b.Infinity : 'b_infinite'}), a)\n+  z12 = a.Z^2\n+  u1 = a.X\n+  u2 = b.X * z12\n+  s1 = a.Y\n+  s2 = b.Y * z12\n+  s2 = s2 * a.Z\n+  h = -u1\n+  h = h + u2\n+  i = -s1\n+  i = i + s2\n+  if (branch == 2):\n+    r = formula_secp256k1_gej_double_var(a)\n+    return (constraints(zero={b.Z - 1 : 'b.z=1'}), constraints(zero={a.Infinity : 'a_finite', b.Infinity : 'b_finite', h : 'h=0', i : 'i=0'}), r)\n+  if (branch == 3):\n+    return (constraints(zero={b.Z - 1 : 'b.z=1'}), constraints(zero={a.Infinity : 'a_finite', b.Infinity : 'b_finite', h : 'h=0'}, nonzero={i : 'i!=0'}), point_at_infinity())\n+  i2 = i^2\n+  h2 = h^2\n+  h3 = h * h2\n+  rz = a.Z * h\n+  t = u1 * h2\n+  rx = t\n+  rx = rx * 2\n+  rx = rx + h3\n+  rx = -rx\n+  rx = rx + i2\n+  ry = -rx\n+  ry = ry + t\n+  ry = ry * i\n+  h3 = h3 * s1\n+  h3 = -h3\n+  ry = ry + h3\n+  return (constraints(zero={b.Z - 1 : 'b.z=1'}), constraints(zero={a.Infinity : 'a_finite', b.Infinity : 'b_finite'}, nonzero={h : 'h!=0'}), jacobianpoint(rx, ry, rz))\n+\n+def formula_secp256k1_gej_add_zinv_var(branch, a, b):\n+  \"\"\"libsecp256k1's secp256k1_gej_add_zinv_var\"\"\"\n+  bzinv = b.Z^(-1)\n+  if branch == 0:\n+    return (constraints(), constraints(nonzero={b.Infinity : 'b_infinite'}), a)\n+  if branch == 1:\n+    bzinv2 = bzinv^2\n+    bzinv3 = bzinv2 * bzinv\n+    rx = b.X * bzinv2\n+    ry = b.Y * bzinv3\n+    rz = 1\n+    return (constraints(), constraints(zero={b.Infinity : 'b_finite'}, nonzero={a.Infinity : 'a_infinite'}), jacobianpoint(rx, ry, rz))\n+  azz = a.Z * bzinv\n+  z12 = azz^2\n+  u1 = a.X\n+  u2 = b.X * z12\n+  s1 = a.Y\n+  s2 = b.Y * z12\n+  s2 = s2 * azz\n+  h = -u1\n+  h = h + u2\n+  i = -s1\n+  i = i + s2\n+  if branch == 2:\n+    r = formula_secp256k1_gej_double_var(a)\n+    return (constraints(), constraints(zero={a.Infinity : 'a_finite', b.Infinity : 'b_finite', h : 'h=0', i : 'i=0'}), r)\n+  if branch == 3:\n+    return (constraints(), constraints(zero={a.Infinity : 'a_finite', b.Infinity : 'b_finite', h : 'h=0'}, nonzero={i : 'i!=0'}), point_at_infinity())\n+  i2 = i^2\n+  h2 = h^2\n+  h3 = h * h2\n+  rz = a.Z\n+  rz = rz * h\n+  t = u1 * h2\n+  rx = t\n+  rx = rx * 2\n+  rx = rx + h3\n+  rx = -rx\n+  rx = rx + i2\n+  ry = -rx\n+  ry = ry + t\n+  ry = ry * i\n+  h3 = h3 * s1\n+  h3 = -h3\n+  ry = ry + h3\n+  return (constraints(), constraints(zero={a.Infinity : 'a_finite', b.Infinity : 'b_finite'}, nonzero={h : 'h!=0'}), jacobianpoint(rx, ry, rz))\n+\n+def formula_secp256k1_gej_add_ge(branch, a, b):\n+  \"\"\"libsecp256k1's secp256k1_gej_add_ge\"\"\"\n+  zeroes = {}\n+  nonzeroes = {}\n+  a_infinity = False\n+  if (branch & 4) != 0:\n+    nonzeroes.update({a.Infinity : 'a_infinite'})\n+    a_infinity = True\n+  else:\n+    zeroes.update({a.Infinity : 'a_finite'})\n+  zz = a.Z^2\n+  u1 = a.X\n+  u2 = b.X * zz\n+  s1 = a.Y\n+  s2 = b.Y * zz\n+  s2 = s2 * a.Z\n+  t = u1\n+  t = t + u2\n+  m = s1\n+  m = m + s2\n+  rr = t^2\n+  m_alt = -u2\n+  tt = u1 * m_alt\n+  rr = rr + tt\n+  degenerate = (branch & 3) == 3\n+  if (branch & 1) != 0:\n+    zeroes.update({m : 'm_zero'})\n+  else:\n+    nonzeroes.update({m : 'm_nonzero'})\n+  if (branch & 2) != 0:\n+    zeroes.update({rr : 'rr_zero'})\n+  else:\n+    nonzeroes.update({rr : 'rr_nonzero'})\n+  rr_alt = s1\n+  rr_alt = rr_alt * 2\n+  m_alt = m_alt + u1\n+  if not degenerate:\n+    rr_alt = rr\n+    m_alt = m\n+  n = m_alt^2\n+  q = n * t\n+  n = n^2\n+  if degenerate:\n+    n = m\n+  t = rr_alt^2\n+  rz = a.Z * m_alt\n+  infinity = False\n+  if (branch & 8) != 0:\n+    if not a_infinity:\n+      infinity = True\n+    zeroes.update({rz : 'r.z=0'})\n+  else:\n+    nonzeroes.update({rz : 'r.z!=0'})\n+  rz = rz * 2\n+  q = -q\n+  t = t + q\n+  rx = t\n+  t = t * 2\n+  t = t + q\n+  t = t * rr_alt\n+  t = t + n\n+  ry = -t\n+  rx = rx * 4\n+  ry = ry * 4\n+  if a_infinity:\n+    rx = b.X\n+    ry = b.Y\n+    rz = 1\n+  if infinity:\n+    return (constraints(zero={b.Z - 1 : 'b.z=1', b.Infinity : 'b_finite'}), constraints(zero=zeroes, nonzero=nonzeroes), point_at_infinity())\n+  return (constraints(zero={b.Z - 1 : 'b.z=1', b.Infinity : 'b_finite'}), constraints(zero=zeroes, nonzero=nonzeroes), jacobianpoint(rx, ry, rz))\n+\n+def formula_secp256k1_gej_add_ge_old(branch, a, b):\n+  \"\"\"libsecp256k1's old secp256k1_gej_add_ge, which fails when ay+by=0 but ax!=bx\"\"\"\n+  a_infinity = (branch & 1) != 0\n+  zero = {}\n+  nonzero = {}\n+  if a_infinity:\n+    nonzero.update({a.Infinity : 'a_infinite'})\n+  else:\n+    zero.update({a.Infinity : 'a_finite'})\n+  zz = a.Z^2\n+  u1 = a.X\n+  u2 = b.X * zz\n+  s1 = a.Y\n+  s2 = b.Y * zz\n+  s2 = s2 * a.Z\n+  z = a.Z\n+  t = u1\n+  t = t + u2\n+  m = s1\n+  m = m + s2\n+  n = m^2\n+  q = n * t\n+  n = n^2\n+  rr = t^2\n+  t = u1 * u2\n+  t = -t\n+  rr = rr + t\n+  t = rr^2\n+  rz = m * z\n+  infinity = False\n+  if (branch & 2) != 0:\n+    if not a_infinity:\n+      infinity = True\n+    else:\n+      return (constraints(zero={b.Z - 1 : 'b.z=1', b.Infinity : 'b_finite'}), constraints(nonzero={z : 'conflict_a'}, zero={z : 'conflict_b'}), point_at_infinity())\n+    zero.update({rz : 'r.z=0'})\n+  else:\n+    nonzero.update({rz : 'r.z!=0'})\n+  rz = rz * (0 if a_infinity else 2)\n+  rx = t\n+  q = -q\n+  rx = rx + q\n+  q = q * 3\n+  t = t * 2\n+  t = t + q\n+  t = t * rr\n+  t = t + n\n+  ry = -t\n+  rx = rx * (0 if a_infinity else 4)\n+  ry = ry * (0 if a_infinity else 4)\n+  t = b.X\n+  t = t * (1 if a_infinity else 0)\n+  rx = rx + t\n+  t = b.Y\n+  t = t * (1 if a_infinity else 0)\n+  ry = ry + t\n+  t = (1 if a_infinity else 0)\n+  rz = rz + t\n+  if infinity:\n+    return (constraints(zero={b.Z - 1 : 'b.z=1', b.Infinity : 'b_finite'}), constraints(zero=zero, nonzero=nonzero), point_at_infinity())\n+  return (constraints(zero={b.Z - 1 : 'b.z=1', b.Infinity : 'b_finite'}), constraints(zero=zero, nonzero=nonzero), jacobianpoint(rx, ry, rz))\n+\n+if __name__ == \"__main__\":\n+  check_symbolic_jacobian_weierstrass(\"secp256k1_gej_add_var\", 0, 7, 5, formula_secp256k1_gej_add_var)\n+  check_symbolic_jacobian_weierstrass(\"secp256k1_gej_add_ge_var\", 0, 7, 5, formula_secp256k1_gej_add_ge_var)\n+  check_symbolic_jacobian_weierstrass(\"secp256k1_gej_add_zinv_var\", 0, 7, 5, formula_secp256k1_gej_add_zinv_var)\n+  check_symbolic_jacobian_weierstrass(\"secp256k1_gej_add_ge\", 0, 7, 16, formula_secp256k1_gej_add_ge)\n+  check_symbolic_jacobian_weierstrass(\"secp256k1_gej_add_ge_old [should fail]\", 0, 7, 4, formula_secp256k1_gej_add_ge_old)\n+\n+  if len(sys.argv) >= 2 and sys.argv[1] == \"--exhaustive\":\n+    check_exhaustive_jacobian_weierstrass(\"secp256k1_gej_add_var\", 0, 7, 5, formula_secp256k1_gej_add_var, 43)\n+    check_exhaustive_jacobian_weierstrass(\"secp256k1_gej_add_ge_var\", 0, 7, 5, formula_secp256k1_gej_add_ge_var, 43)\n+    check_exhaustive_jacobian_weierstrass(\"secp256k1_gej_add_zinv_var\", 0, 7, 5, formula_secp256k1_gej_add_zinv_var, 43)\n+    check_exhaustive_jacobian_weierstrass(\"secp256k1_gej_add_ge\", 0, 7, 16, formula_secp256k1_gej_add_ge, 43)\n+    check_exhaustive_jacobian_weierstrass(\"secp256k1_gej_add_ge_old [should fail]\", 0, 7, 4, formula_secp256k1_gej_add_ge_old, 43)"
      },
      {
        "sha": "03ef2ec901ea9cafa47b4ccdce7bbba61279930f",
        "filename": "src/secp256k1/sage/weierstrass_prover.sage",
        "status": "added",
        "additions": 264,
        "deletions": 0,
        "changes": 264,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/sage/weierstrass_prover.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/sage/weierstrass_prover.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/sage/weierstrass_prover.sage?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -0,0 +1,264 @@\n+# Prover implementation for Weierstrass curves of the form\n+# y^2 = x^3 + A * x + B, specifically with a = 0 and b = 7, with group laws\n+# operating on affine and Jacobian coordinates, including the point at infinity\n+# represented by a 4th variable in coordinates.\n+\n+load(\"group_prover.sage\")\n+\n+\n+class affinepoint:\n+  def __init__(self, x, y, infinity=0):\n+    self.x = x\n+    self.y = y\n+    self.infinity = infinity\n+  def __str__(self):\n+    return \"affinepoint(x=%s,y=%s,inf=%s)\" % (self.x, self.y, self.infinity)\n+\n+\n+class jacobianpoint:\n+  def __init__(self, x, y, z, infinity=0):\n+    self.X = x\n+    self.Y = y\n+    self.Z = z\n+    self.Infinity = infinity\n+  def __str__(self):\n+    return \"jacobianpoint(X=%s,Y=%s,Z=%s,inf=%s)\" % (self.X, self.Y, self.Z, self.Infinity)\n+\n+\n+def point_at_infinity():\n+  return jacobianpoint(1, 1, 1, 1)\n+\n+\n+def negate(p):\n+  if p.__class__ == affinepoint:\n+    return affinepoint(p.x, -p.y)\n+  if p.__class__ == jacobianpoint:\n+    return jacobianpoint(p.X, -p.Y, p.Z)\n+  assert(False)\n+\n+\n+def on_weierstrass_curve(A, B, p):\n+  \"\"\"Return a set of zero-expressions for an affine point to be on the curve\"\"\"\n+  return constraints(zero={p.x^3 + A*p.x + B - p.y^2: 'on_curve'})\n+\n+\n+def tangential_to_weierstrass_curve(A, B, p12, p3):\n+  \"\"\"Return a set of zero-expressions for ((x12,y12),(x3,y3)) to be a line that is tangential to the curve at (x12,y12)\"\"\"\n+  return constraints(zero={\n+    (p12.y - p3.y) * (p12.y * 2) - (p12.x^2 * 3 + A) * (p12.x - p3.x): 'tangential_to_curve'\n+  })\n+\n+\n+def colinear(p1, p2, p3):\n+  \"\"\"Return a set of zero-expressions for ((x1,y1),(x2,y2),(x3,y3)) to be collinear\"\"\"\n+  return constraints(zero={\n+    (p1.y - p2.y) * (p1.x - p3.x) - (p1.y - p3.y) * (p1.x - p2.x): 'colinear_1',\n+    (p2.y - p3.y) * (p2.x - p1.x) - (p2.y - p1.y) * (p2.x - p3.x): 'colinear_2',\n+    (p3.y - p1.y) * (p3.x - p2.x) - (p3.y - p2.y) * (p3.x - p1.x): 'colinear_3'\n+  })\n+\n+\n+def good_affine_point(p):\n+  return constraints(nonzero={p.x : 'nonzero_x', p.y : 'nonzero_y'})\n+\n+\n+def good_jacobian_point(p):\n+  return constraints(nonzero={p.X : 'nonzero_X', p.Y : 'nonzero_Y', p.Z^6 : 'nonzero_Z'})\n+\n+\n+def good_point(p):\n+  return constraints(nonzero={p.Z^6 : 'nonzero_X'})\n+\n+\n+def finite(p, *affine_fns):\n+  con = good_point(p) + constraints(zero={p.Infinity : 'finite_point'})\n+  if p.Z != 0:\n+    return con + reduce(lambda a, b: a + b, (f(affinepoint(p.X / p.Z^2, p.Y / p.Z^3)) for f in affine_fns), con)\n+  else:\n+    return con\n+\n+def infinite(p):\n+  return constraints(nonzero={p.Infinity : 'infinite_point'})\n+\n+\n+def law_jacobian_weierstrass_add(A, B, pa, pb, pA, pB, pC):\n+  \"\"\"Check whether the passed set of coordinates is a valid Jacobian add, given assumptions\"\"\"\n+  assumeLaw = (good_affine_point(pa) +\n+               good_affine_point(pb) +\n+               good_jacobian_point(pA) +\n+               good_jacobian_point(pB) +\n+               on_weierstrass_curve(A, B, pa) +\n+               on_weierstrass_curve(A, B, pb) +\n+               finite(pA) +\n+               finite(pB) +\n+               constraints(nonzero={pa.x - pb.x : 'different_x'}))\n+  require = (finite(pC, lambda pc: on_weierstrass_curve(A, B, pc) +\n+             colinear(pa, pb, negate(pc))))\n+  return (assumeLaw, require)\n+\n+\n+def law_jacobian_weierstrass_double(A, B, pa, pb, pA, pB, pC):\n+  \"\"\"Check whether the passed set of coordinates is a valid Jacobian doubling, given assumptions\"\"\"\n+  assumeLaw = (good_affine_point(pa) +\n+               good_affine_point(pb) +\n+               good_jacobian_point(pA) +\n+               good_jacobian_point(pB) +\n+               on_weierstrass_curve(A, B, pa) +\n+               on_weierstrass_curve(A, B, pb) +\n+               finite(pA) +\n+               finite(pB) +\n+               constraints(zero={pa.x - pb.x : 'equal_x', pa.y - pb.y : 'equal_y'}))\n+  require = (finite(pC, lambda pc: on_weierstrass_curve(A, B, pc) +\n+             tangential_to_weierstrass_curve(A, B, pa, negate(pc))))\n+  return (assumeLaw, require)\n+\n+\n+def law_jacobian_weierstrass_add_opposites(A, B, pa, pb, pA, pB, pC):\n+  assumeLaw = (good_affine_point(pa) +\n+               good_affine_point(pb) +\n+               good_jacobian_point(pA) +\n+               good_jacobian_point(pB) +\n+               on_weierstrass_curve(A, B, pa) +\n+               on_weierstrass_curve(A, B, pb) +\n+               finite(pA) +\n+               finite(pB) +\n+               constraints(zero={pa.x - pb.x : 'equal_x', pa.y + pb.y : 'opposite_y'}))\n+  require = infinite(pC)\n+  return (assumeLaw, require)\n+\n+\n+def law_jacobian_weierstrass_add_infinite_a(A, B, pa, pb, pA, pB, pC):\n+  assumeLaw = (good_affine_point(pa) +\n+               good_affine_point(pb) +\n+               good_jacobian_point(pA) +\n+               good_jacobian_point(pB) +\n+               on_weierstrass_curve(A, B, pb) +\n+               infinite(pA) +\n+               finite(pB))\n+  require = finite(pC, lambda pc: constraints(zero={pc.x - pb.x : 'c.x=b.x', pc.y - pb.y : 'c.y=b.y'}))\n+  return (assumeLaw, require)\n+\n+\n+def law_jacobian_weierstrass_add_infinite_b(A, B, pa, pb, pA, pB, pC):\n+  assumeLaw = (good_affine_point(pa) +\n+               good_affine_point(pb) +\n+               good_jacobian_point(pA) +\n+               good_jacobian_point(pB) +\n+               on_weierstrass_curve(A, B, pa) +\n+               infinite(pB) +\n+               finite(pA))\n+  require = finite(pC, lambda pc: constraints(zero={pc.x - pa.x : 'c.x=a.x', pc.y - pa.y : 'c.y=a.y'}))\n+  return (assumeLaw, require)\n+\n+\n+def law_jacobian_weierstrass_add_infinite_ab(A, B, pa, pb, pA, pB, pC):\n+  assumeLaw = (good_affine_point(pa) +\n+               good_affine_point(pb) +\n+               good_jacobian_point(pA) +\n+               good_jacobian_point(pB) +\n+               infinite(pA) +\n+               infinite(pB))\n+  require = infinite(pC)\n+  return (assumeLaw, require)\n+\n+\n+laws_jacobian_weierstrass = {\n+  'add': law_jacobian_weierstrass_add,\n+  'double': law_jacobian_weierstrass_double,\n+  'add_opposite': law_jacobian_weierstrass_add_opposites,\n+  'add_infinite_a': law_jacobian_weierstrass_add_infinite_a,\n+  'add_infinite_b': law_jacobian_weierstrass_add_infinite_b,\n+  'add_infinite_ab': law_jacobian_weierstrass_add_infinite_ab\n+}\n+\n+\n+def check_exhaustive_jacobian_weierstrass(name, A, B, branches, formula, p):\n+  \"\"\"Verify an implementation of addition of Jacobian points on a Weierstrass curve, by executing and validating the result for every possible addition in a prime field\"\"\"\n+  F = Integers(p)\n+  print \"Formula %s on Z%i:\" % (name, p)\n+  points = []\n+  for x in xrange(0, p):\n+    for y in xrange(0, p):\n+      point = affinepoint(F(x), F(y))\n+      r, e = concrete_verify(on_weierstrass_curve(A, B, point))\n+      if r:\n+        points.append(point)\n+\n+  for za in xrange(1, p):\n+    for zb in xrange(1, p):\n+      for pa in points:\n+        for pb in points:\n+          for ia in xrange(2):\n+            for ib in xrange(2):\n+              pA = jacobianpoint(pa.x * F(za)^2, pa.y * F(za)^3, F(za), ia)\n+              pB = jacobianpoint(pb.x * F(zb)^2, pb.y * F(zb)^3, F(zb), ib)\n+              for branch in xrange(0, branches):\n+                assumeAssert, assumeBranch, pC = formula(branch, pA, pB)\n+                pC.X = F(pC.X)\n+                pC.Y = F(pC.Y)\n+                pC.Z = F(pC.Z)\n+                pC.Infinity = F(pC.Infinity)\n+                r, e = concrete_verify(assumeAssert + assumeBranch)\n+                if r:\n+                  match = False\n+                  for key in laws_jacobian_weierstrass:\n+                    assumeLaw, require = laws_jacobian_weierstrass[key](A, B, pa, pb, pA, pB, pC)\n+                    r, e = concrete_verify(assumeLaw)\n+                    if r:\n+                      if match:\n+                        print \"  multiple branches for (%s,%s,%s,%s) + (%s,%s,%s,%s)\" % (pA.X, pA.Y, pA.Z, pA.Infinity, pB.X, pB.Y, pB.Z, pB.Infinity)\n+                      else:\n+                        match = True\n+                      r, e = concrete_verify(require)\n+                      if not r:\n+                        print \"  failure in branch %i for (%s,%s,%s,%s) + (%s,%s,%s,%s) = (%s,%s,%s,%s): %s\" % (branch, pA.X, pA.Y, pA.Z, pA.Infinity, pB.X, pB.Y, pB.Z, pB.Infinity, pC.X, pC.Y, pC.Z, pC.Infinity, e)\n+  print\n+\n+\n+def check_symbolic_function(R, assumeAssert, assumeBranch, f, A, B, pa, pb, pA, pB, pC):\n+  assumeLaw, require = f(A, B, pa, pb, pA, pB, pC)\n+  return check_symbolic(R, assumeLaw, assumeAssert, assumeBranch, require)\n+\n+def check_symbolic_jacobian_weierstrass(name, A, B, branches, formula):\n+  \"\"\"Verify an implementation of addition of Jacobian points on a Weierstrass curve symbolically\"\"\"\n+  R.<ax,bx,ay,by,Az,Bz,Ai,Bi> = PolynomialRing(QQ,8,order='invlex')\n+  lift = lambda x: fastfrac(R,x)\n+  ax = lift(ax)\n+  ay = lift(ay)\n+  Az = lift(Az)\n+  bx = lift(bx)\n+  by = lift(by)\n+  Bz = lift(Bz)\n+  Ai = lift(Ai)\n+  Bi = lift(Bi)\n+\n+  pa = affinepoint(ax, ay, Ai)\n+  pb = affinepoint(bx, by, Bi)\n+  pA = jacobianpoint(ax * Az^2, ay * Az^3, Az, Ai)\n+  pB = jacobianpoint(bx * Bz^2, by * Bz^3, Bz, Bi)\n+\n+  res = {}\n+\n+  for key in laws_jacobian_weierstrass:\n+    res[key] = []\n+\n+  print (\"Formula \" + name + \":\")\n+  count = 0\n+  for branch in xrange(branches):\n+    assumeFormula, assumeBranch, pC = formula(branch, pA, pB)\n+    pC.X = lift(pC.X)\n+    pC.Y = lift(pC.Y)\n+    pC.Z = lift(pC.Z)\n+    pC.Infinity = lift(pC.Infinity)\n+\n+    for key in laws_jacobian_weierstrass:\n+      res[key].append((check_symbolic_function(R, assumeFormula, assumeBranch, laws_jacobian_weierstrass[key], A, B, pa, pb, pA, pB, pC), branch))\n+\n+  for key in res:\n+    print \"  %s:\" % key\n+    val = res[key]\n+    for x in val:\n+      if x[0] is not None:\n+        print \"    branch %i: %s\" % (x[1], x[0])\n+\n+  print"
      },
      {
        "sha": "5df561f2fc939e332dae7137345a18fdef9906eb",
        "filename": "src/secp256k1/src/asm/field_10x26_arm.s",
        "status": "added",
        "additions": 919,
        "deletions": 0,
        "changes": 919,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/asm/field_10x26_arm.s",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/asm/field_10x26_arm.s",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/asm/field_10x26_arm.s?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -0,0 +1,919 @@\n+@ vim: set tabstop=8 softtabstop=8 shiftwidth=8 noexpandtab syntax=armasm:\n+/**********************************************************************\n+ * Copyright (c) 2014 Wladimir J. van der Laan                        *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+/*\n+ARM implementation of field_10x26 inner loops.\n+\n+Note:\n+\n+- To avoid unnecessary loads and make use of available registers, two\n+  'passes' have every time been interleaved, with the odd passes accumulating c' and d' \n+  which will be added to c and d respectively in the the even passes\n+\n+*/\n+\n+\t.syntax unified\n+\t.arch armv7-a\n+\t@ eabi attributes - see readelf -A\n+\t.eabi_attribute 8, 1  @ Tag_ARM_ISA_use = yes\n+\t.eabi_attribute 9, 0  @ Tag_Thumb_ISA_use = no\n+\t.eabi_attribute 10, 0 @ Tag_FP_arch = none\n+\t.eabi_attribute 24, 1 @ Tag_ABI_align_needed = 8-byte\n+\t.eabi_attribute 25, 1 @ Tag_ABI_align_preserved = 8-byte, except leaf SP\n+\t.eabi_attribute 30, 2 @ Tag_ABI_optimization_goals = Agressive Speed\n+\t.eabi_attribute 34, 1 @ Tag_CPU_unaligned_access = v6\n+\t.text\n+\n+\t@ Field constants\n+\t.set field_R0, 0x3d10\n+\t.set field_R1, 0x400\n+\t.set field_not_M, 0xfc000000\t@ ~M = ~0x3ffffff\n+\n+\t.align\t2\n+\t.global secp256k1_fe_mul_inner\n+\t.type\tsecp256k1_fe_mul_inner, %function\n+\t@ Arguments:\n+\t@  r0  r      Restrict: can overlap with a, not with b\n+\t@  r1  a\n+\t@  r2  b\n+\t@ Stack (total 4+10*4 = 44)\n+\t@  sp + #0        saved 'r' pointer\n+\t@  sp + #4 + 4*X  t0,t1,t2,t3,t4,t5,t6,t7,u8,t9\n+secp256k1_fe_mul_inner:\n+\tstmfd\tsp!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}\n+\tsub\tsp, sp, #48\t\t\t@ frame=44 + alignment\n+\tstr     r0, [sp, #0]\t\t\t@ save result address, we need it only at the end\n+\n+\t/******************************************\n+\t * Main computation code.\n+\t ******************************************\n+\n+\tAllocation:\n+\t    r0,r14,r7,r8   scratch\n+\t    r1       a (pointer)\n+\t    r2       b (pointer)\n+\t    r3:r4    c\n+\t    r5:r6    d\n+\t    r11:r12  c'\n+\t    r9:r10   d'\n+\n+\tNote: do not write to r[] here, it may overlap with a[]\n+\t*/\n+\n+\t/* A - interleaved with B */\n+\tldr\tr7, [r1, #0*4]\t\t\t@ a[0]\n+\tldr\tr8, [r2, #9*4]\t\t\t@ b[9]\n+\tldr\tr0, [r1, #1*4]\t\t\t@ a[1]\n+\tumull\tr5, r6, r7, r8\t\t\t@ d = a[0] * b[9]\n+\tldr\tr14, [r2, #8*4]\t\t\t@ b[8]\n+\tumull\tr9, r10, r0, r8\t\t\t@ d' = a[1] * b[9]\n+\tldr\tr7, [r1, #2*4]\t\t\t@ a[2]\n+\tumlal\tr5, r6, r0, r14\t\t\t@ d += a[1] * b[8]\n+\tldr\tr8, [r2, #7*4] \t\t\t@ b[7]\n+\tumlal\tr9, r10, r7, r14\t\t@ d' += a[2] * b[8]\n+\tldr\tr0, [r1, #3*4]   \t\t@ a[3]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[2] * b[7]\n+\tldr\tr14, [r2, #6*4]   \t\t@ b[6]\n+\tumlal\tr9, r10, r0, r8  \t\t@ d' += a[3] * b[7]\n+\tldr\tr7, [r1, #4*4]   \t\t@ a[4]\n+\tumlal\tr5, r6, r0, r14   \t\t@ d += a[3] * b[6]\n+\tldr\tr8, [r2, #5*4]   \t\t@ b[5]\n+\tumlal\tr9, r10, r7, r14  \t\t@ d' += a[4] * b[6]\n+\tldr\tr0, [r1, #5*4]   \t\t@ a[5]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[4] * b[5]\n+\tldr\tr14, [r2, #4*4]   \t\t@ b[4]\n+\tumlal\tr9, r10, r0, r8  \t\t@ d' += a[5] * b[5]\n+\tldr\tr7, [r1, #6*4]   \t\t@ a[6]\n+\tumlal\tr5, r6, r0, r14   \t\t@ d += a[5] * b[4]\n+\tldr\tr8, [r2, #3*4]   \t\t@ b[3]\n+\tumlal\tr9, r10, r7, r14  \t\t@ d' += a[6] * b[4]\n+\tldr\tr0, [r1, #7*4]   \t\t@ a[7]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[6] * b[3]\n+\tldr\tr14, [r2, #2*4]   \t\t@ b[2]\n+\tumlal\tr9, r10, r0, r8  \t\t@ d' += a[7] * b[3]\n+\tldr\tr7, [r1, #8*4]   \t\t@ a[8]\n+\tumlal\tr5, r6, r0, r14   \t\t@ d += a[7] * b[2]\n+\tldr\tr8, [r2, #1*4]   \t\t@ b[1]\n+\tumlal\tr9, r10, r7, r14  \t\t@ d' += a[8] * b[2]\n+\tldr\tr0, [r1, #9*4]   \t\t@ a[9]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[8] * b[1]\n+\tldr\tr14, [r2, #0*4]   \t\t@ b[0]\n+\tumlal\tr9, r10, r0, r8  \t\t@ d' += a[9] * b[1]\n+\tldr\tr7, [r1, #0*4]   \t\t@ a[0]\n+\tumlal\tr5, r6, r0, r14   \t\t@ d += a[9] * b[0]\n+\t@ r7,r14 used in B\n+\n+\tbic\tr0, r5, field_not_M \t\t@ t9 = d & M\n+\tstr     r0, [sp, #4 + 4*9]\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26 \n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\n+\t/* B */\n+\tumull\tr3, r4, r7, r14   \t\t@ c = a[0] * b[0]\n+\tadds\tr5, r5, r9       \t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u0 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u0 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t0 = c & M\n+\tstr\tr14, [sp, #4 + 0*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u0 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* C - interleaved with D */\n+\tldr\tr7, [r1, #0*4]   \t\t@ a[0]\n+\tldr\tr8, [r2, #2*4]   \t\t@ b[2]\n+\tldr\tr14, [r2, #1*4]   \t\t@ b[1]\n+\tumull\tr11, r12, r7, r8   \t\t@ c' = a[0] * b[2]\n+\tldr\tr0, [r1, #1*4]   \t\t@ a[1]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[0] * b[1]\n+\tldr\tr8, [r2, #0*4]   \t\t@ b[0]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[1] * b[1]\n+\tldr\tr7, [r1, #2*4]   \t\t@ a[2]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[1] * b[0]\n+\tldr\tr14, [r2, #9*4]   \t\t@ b[9]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[2] * b[0]\n+\tldr\tr0, [r1, #3*4]   \t\t@ a[3]\n+\tumlal\tr5, r6, r7, r14   \t\t@ d += a[2] * b[9]\n+\tldr\tr8, [r2, #8*4]   \t\t@ b[8]\n+\tumull\tr9, r10, r0, r14   \t\t@ d' = a[3] * b[9]\n+\tldr\tr7, [r1, #4*4]   \t\t@ a[4]\n+\tumlal\tr5, r6, r0, r8   \t\t@ d += a[3] * b[8]\n+\tldr\tr14, [r2, #7*4]   \t\t@ b[7]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[4] * b[8]\n+\tldr\tr0, [r1, #5*4]   \t\t@ a[5]\n+\tumlal\tr5, r6, r7, r14   \t\t@ d += a[4] * b[7]\n+\tldr\tr8, [r2, #6*4]   \t\t@ b[6]\n+\tumlal\tr9, r10, r0, r14   \t\t@ d' += a[5] * b[7]\n+\tldr\tr7, [r1, #6*4]   \t\t@ a[6]\n+\tumlal\tr5, r6, r0, r8   \t\t@ d += a[5] * b[6]\n+\tldr\tr14, [r2, #5*4]   \t\t@ b[5]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[6] * b[6]\n+\tldr\tr0, [r1, #7*4]   \t\t@ a[7]\n+\tumlal\tr5, r6, r7, r14   \t\t@ d += a[6] * b[5]\n+\tldr\tr8, [r2, #4*4]   \t\t@ b[4]\n+\tumlal\tr9, r10, r0, r14   \t\t@ d' += a[7] * b[5]\n+\tldr\tr7, [r1, #8*4]   \t\t@ a[8]\n+\tumlal\tr5, r6, r0, r8   \t\t@ d += a[7] * b[4]\n+\tldr\tr14, [r2, #3*4]   \t\t@ b[3]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[8] * b[4]\n+\tldr\tr0, [r1, #9*4]   \t\t@ a[9]\n+\tumlal\tr5, r6, r7, r14   \t\t@ d += a[8] * b[3]\n+\tldr\tr8, [r2, #2*4]   \t\t@ b[2]\n+\tumlal\tr9, r10, r0, r14   \t\t@ d' += a[9] * b[3]\n+\tumlal\tr5, r6, r0, r8   \t\t@ d += a[9] * b[2]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u1 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u1 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t1 = c & M\n+\tstr\tr14, [sp, #4 + 1*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u1 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* D */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u2 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u2 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t2 = c & M\n+\tstr\tr14, [sp, #4 + 2*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u2 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* E - interleaved with F */\n+\tldr\tr7, [r1, #0*4]   \t\t@ a[0]\n+\tldr\tr8, [r2, #4*4]   \t\t@ b[4]\n+\tumull\tr11, r12, r7, r8   \t\t@ c' = a[0] * b[4]\n+\tldr\tr8, [r2, #3*4]   \t\t@ b[3]\n+\tumlal   r3, r4, r7, r8   \t\t@ c += a[0] * b[3]\n+\tldr\tr7, [r1, #1*4]   \t\t@ a[1]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[1] * b[3]\n+\tldr\tr8, [r2, #2*4]   \t\t@ b[2]\n+\tumlal   r3, r4, r7, r8   \t\t@ c += a[1] * b[2]\n+\tldr\tr7, [r1, #2*4]   \t\t@ a[2]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[2] * b[2]\n+\tldr\tr8, [r2, #1*4]   \t\t@ b[1]\n+\tumlal   r3, r4, r7, r8   \t\t@ c += a[2] * b[1]\n+\tldr\tr7, [r1, #3*4]   \t\t@ a[3]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[3] * b[1]\n+\tldr\tr8, [r2, #0*4]   \t\t@ b[0]\n+\tumlal   r3, r4, r7, r8   \t\t@ c += a[3] * b[0]\n+\tldr\tr7, [r1, #4*4]   \t\t@ a[4]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[4] * b[0]\n+\tldr\tr8, [r2, #9*4]   \t\t@ b[9]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[4] * b[9]\n+\tldr\tr7, [r1, #5*4]   \t\t@ a[5]\n+\tumull\tr9, r10, r7, r8   \t\t@ d' = a[5] * b[9]\n+\tldr\tr8, [r2, #8*4]   \t\t@ b[8]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[5] * b[8]\n+\tldr\tr7, [r1, #6*4]   \t\t@ a[6]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[6] * b[8]\n+\tldr\tr8, [r2, #7*4]   \t\t@ b[7]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[6] * b[7]\n+\tldr\tr7, [r1, #7*4]   \t\t@ a[7]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[7] * b[7]\n+\tldr\tr8, [r2, #6*4]   \t\t@ b[6]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[7] * b[6]\n+\tldr\tr7, [r1, #8*4]   \t\t@ a[8]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[8] * b[6]\n+\tldr\tr8, [r2, #5*4]   \t\t@ b[5]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[8] * b[5]\n+\tldr\tr7, [r1, #9*4]   \t\t@ a[9]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[9] * b[5]\n+\tldr\tr8, [r2, #4*4]   \t\t@ b[4]\n+\tumlal\tr5, r6, r7, r8   \t\t@ d += a[9] * b[4]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u3 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u3 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t3 = c & M\n+\tstr\tr14, [sp, #4 + 3*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u3 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* F */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u4 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u4 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t4 = c & M\n+\tstr\tr14, [sp, #4 + 4*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u4 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* G - interleaved with H */\n+\tldr\tr7, [r1, #0*4]   \t\t@ a[0]\n+\tldr\tr8, [r2, #6*4]   \t\t@ b[6]\n+\tldr\tr14, [r2, #5*4]   \t\t@ b[5]\n+\tumull\tr11, r12, r7, r8   \t\t@ c' = a[0] * b[6]\n+\tldr\tr0, [r1, #1*4]   \t\t@ a[1]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[0] * b[5]\n+\tldr\tr8, [r2, #4*4]   \t\t@ b[4]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[1] * b[5]\n+\tldr\tr7, [r1, #2*4]   \t\t@ a[2]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[1] * b[4]\n+\tldr\tr14, [r2, #3*4]   \t\t@ b[3]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[2] * b[4]\n+\tldr\tr0, [r1, #3*4]   \t\t@ a[3]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[2] * b[3]\n+\tldr\tr8, [r2, #2*4]   \t\t@ b[2]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[3] * b[3]\n+\tldr\tr7, [r1, #4*4]   \t\t@ a[4]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[3] * b[2]\n+\tldr\tr14, [r2, #1*4]   \t\t@ b[1]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[4] * b[2]\n+\tldr\tr0, [r1, #5*4]   \t\t@ a[5]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[4] * b[1]\n+\tldr\tr8, [r2, #0*4]   \t\t@ b[0]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[5] * b[1]\n+\tldr\tr7, [r1, #6*4]   \t\t@ a[6]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[5] * b[0]\n+\tldr\tr14, [r2, #9*4]   \t\t@ b[9]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[6] * b[0]\n+\tldr\tr0, [r1, #7*4]   \t\t@ a[7]\n+\tumlal\tr5, r6, r7, r14   \t\t@ d += a[6] * b[9]\n+\tldr\tr8, [r2, #8*4]   \t\t@ b[8]\n+\tumull\tr9, r10, r0, r14   \t\t@ d' = a[7] * b[9]\n+\tldr\tr7, [r1, #8*4]   \t\t@ a[8]\n+\tumlal\tr5, r6, r0, r8   \t\t@ d += a[7] * b[8]\n+\tldr\tr14, [r2, #7*4]   \t\t@ b[7]\n+\tumlal\tr9, r10, r7, r8   \t\t@ d' += a[8] * b[8]\n+\tldr\tr0, [r1, #9*4]   \t\t@ a[9]\n+\tumlal\tr5, r6, r7, r14   \t\t@ d += a[8] * b[7]\n+\tldr\tr8, [r2, #6*4]   \t\t@ b[6]\n+\tumlal\tr9, r10, r0, r14   \t\t@ d' += a[9] * b[7]\n+\tumlal\tr5, r6, r0, r8   \t\t@ d += a[9] * b[6]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u5 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u5 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t5 = c & M\n+\tstr\tr14, [sp, #4 + 5*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u5 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* H */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u6 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u6 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t6 = c & M\n+\tstr\tr14, [sp, #4 + 6*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u6 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* I - interleaved with J */\n+\tldr\tr8, [r2, #8*4]   \t\t@ b[8]\n+\tldr\tr7, [r1, #0*4]   \t\t@ a[0]\n+\tldr\tr14, [r2, #7*4]   \t\t@ b[7]\n+\tumull   r11, r12, r7, r8   \t\t@ c' = a[0] * b[8]\n+\tldr\tr0, [r1, #1*4]   \t\t@ a[1]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[0] * b[7]\n+\tldr\tr8, [r2, #6*4]   \t\t@ b[6]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[1] * b[7]\n+\tldr\tr7, [r1, #2*4]   \t\t@ a[2]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[1] * b[6]\n+\tldr\tr14, [r2, #5*4]   \t\t@ b[5]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[2] * b[6]\n+\tldr\tr0, [r1, #3*4]   \t\t@ a[3]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[2] * b[5]\n+\tldr\tr8, [r2, #4*4]   \t\t@ b[4]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[3] * b[5]\n+\tldr\tr7, [r1, #4*4]   \t\t@ a[4]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[3] * b[4]\n+\tldr\tr14, [r2, #3*4]   \t\t@ b[3]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[4] * b[4]\n+\tldr\tr0, [r1, #5*4]   \t\t@ a[5]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[4] * b[3]\n+\tldr\tr8, [r2, #2*4]   \t\t@ b[2]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[5] * b[3]\n+\tldr\tr7, [r1, #6*4]   \t\t@ a[6]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[5] * b[2]\n+\tldr\tr14, [r2, #1*4]   \t\t@ b[1]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[6] * b[2]\n+\tldr\tr0, [r1, #7*4]   \t\t@ a[7]\n+\tumlal   r3, r4, r7, r14   \t\t@ c += a[6] * b[1]\n+\tldr\tr8, [r2, #0*4]   \t\t@ b[0]\n+\tumlal   r11, r12, r0, r14   \t\t@ c' += a[7] * b[1]\n+\tldr\tr7, [r1, #8*4]   \t\t@ a[8]\n+\tumlal   r3, r4, r0, r8   \t\t@ c += a[7] * b[0]\n+\tldr\tr14, [r2, #9*4]   \t\t@ b[9]\n+\tumlal   r11, r12, r7, r8   \t\t@ c' += a[8] * b[0]\n+\tldr\tr0, [r1, #9*4]   \t\t@ a[9]\n+\tumlal\tr5, r6, r7, r14   \t\t@ d += a[8] * b[9]\n+\tldr\tr8, [r2, #8*4]   \t\t@ b[8]\n+\tumull\tr9, r10, r0, r14  \t\t@ d' = a[9] * b[9]\n+\tumlal\tr5, r6, r0, r8   \t\t@ d += a[9] * b[8]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u7 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u7 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\tbic\tr14, r3, field_not_M \t\t@ t7 = c & M\n+\tstr\tr14, [sp, #4 + 7*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u7 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* J */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u8 = d & M\n+\tstr\tr0, [sp, #4 + 8*4]\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u8 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\t/******************************************\n+\t * compute and write back result\n+\t ******************************************\n+\tAllocation:\n+\t    r0    r\n+\t    r3:r4 c\n+\t    r5:r6 d\n+\t    r7    t0\n+\t    r8    t1\n+\t    r9    t2\n+\t    r11   u8\n+\t    r12   t9\n+\t    r1,r2,r10,r14 scratch\n+\n+\tNote: do not read from a[] after here, it may overlap with r[]\n+\t*/\n+\tldr\tr0, [sp, #0]\n+\tadd\tr1, sp, #4 + 3*4\t\t@ r[3..7] = t3..7, r11=u8, r12=t9\n+\tldmia\tr1, {r2,r7,r8,r9,r10,r11,r12}\n+\tadd\tr1, r0, #3*4\n+\tstmia\tr1, {r2,r7,r8,r9,r10}\n+\n+\tbic\tr2, r3, field_not_M \t\t@ r[8] = c & M\n+\tstr\tr2, [r0, #8*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u8 * R1\n+\tumlal   r3, r4, r11, r14\n+\tmovw    r14, field_R0\t\t\t@ c += d * R0\n+\tumlal   r3, r4, r5, r14\n+\tadds\tr3, r3, r12\t\t\t@ c += t9\n+\tadc\tr4, r4, #0\n+\n+\tadd\tr1, sp, #4 + 0*4\t\t@ r7,r8,r9 = t0,t1,t2\n+\tldmia\tr1, {r7,r8,r9}\n+\n+\tubfx\tr2, r3, #0, #22     \t\t@ r[9] = c & (M >> 4)\n+\tstr\tr2, [r0, #9*4]\n+\tmov\tr3, r3, lsr #22     \t\t@ c >>= 22\n+\torr\tr3, r3, r4, asl #10\n+\tmov     r4, r4, lsr #22\n+\tmovw    r14, field_R1 << 4   \t\t@ c += d * (R1 << 4)\n+\tumlal   r3, r4, r5, r14\n+\n+\tmovw    r14, field_R0 >> 4   \t\t@ d = c * (R0 >> 4) + t0 (64x64 multiply+add)\n+\tumull\tr5, r6, r3, r14\t\t\t@ d = c.lo * (R0 >> 4)\n+\tadds\tr5, r5, r7\t    \t\t@ d.lo += t0\n+\tmla\tr6, r14, r4, r6\t\t\t@ d.hi += c.hi * (R0 >> 4)\n+\tadc\tr6, r6, 0\t     \t\t@ d.hi += carry\n+\n+\tbic\tr2, r5, field_not_M \t\t@ r[0] = d & M\n+\tstr\tr2, [r0, #0*4]\n+\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\t\n+\tmovw    r14, field_R1 >> 4   \t\t@ d += c * (R1 >> 4) + t1 (64x64 multiply+add)\n+\tumull\tr1, r2, r3, r14       \t\t@ tmp = c.lo * (R1 >> 4)\n+\tadds\tr5, r5, r8\t    \t\t@ d.lo += t1\n+\tadc\tr6, r6, #0\t    \t\t@ d.hi += carry\n+\tadds\tr5, r5, r1\t    \t\t@ d.lo += tmp.lo\n+\tmla\tr2, r14, r4, r2      \t\t@ tmp.hi += c.hi * (R1 >> 4)\n+\tadc\tr6, r6, r2\t   \t\t@ d.hi += carry + tmp.hi\n+\n+\tbic\tr2, r5, field_not_M \t\t@ r[1] = d & M\n+\tstr\tr2, [r0, #1*4]\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26 (ignore hi)\n+\torr\tr5, r5, r6, asl #6\n+\n+\tadd\tr5, r5, r9\t  \t\t@ d += t2\n+\tstr\tr5, [r0, #2*4]      \t\t@ r[2] = d\n+\n+\tadd\tsp, sp, #48\n+\tldmfd\tsp!, {r4, r5, r6, r7, r8, r9, r10, r11, pc}\n+\t.size\tsecp256k1_fe_mul_inner, .-secp256k1_fe_mul_inner\n+\n+\t.align\t2\n+\t.global secp256k1_fe_sqr_inner\n+\t.type\tsecp256k1_fe_sqr_inner, %function\n+\t@ Arguments:\n+\t@  r0  r\t Can overlap with a\n+\t@  r1  a\n+\t@ Stack (total 4+10*4 = 44)\n+\t@  sp + #0        saved 'r' pointer\n+\t@  sp + #4 + 4*X  t0,t1,t2,t3,t4,t5,t6,t7,u8,t9\n+secp256k1_fe_sqr_inner:\n+\tstmfd\tsp!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}\n+\tsub\tsp, sp, #48\t\t\t@ frame=44 + alignment\n+\tstr     r0, [sp, #0]\t\t\t@ save result address, we need it only at the end\n+\t/******************************************\n+\t * Main computation code.\n+\t ******************************************\n+\n+\tAllocation:\n+\t    r0,r14,r2,r7,r8   scratch\n+\t    r1       a (pointer)\n+\t    r3:r4    c\n+\t    r5:r6    d\n+\t    r11:r12  c'\n+\t    r9:r10   d'\n+\n+\tNote: do not write to r[] here, it may overlap with a[]\n+\t*/\n+\t/* A interleaved with B */\n+\tldr\tr0, [r1, #1*4]\t\t\t@ a[1]*2\n+\tldr\tr7, [r1, #0*4]\t\t\t@ a[0]\n+\tmov\tr0, r0, asl #1\n+\tldr\tr14, [r1, #9*4]\t\t\t@ a[9]\n+\tumull\tr3, r4, r7, r7\t\t\t@ c = a[0] * a[0]\n+\tldr\tr8, [r1, #8*4]\t\t\t@ a[8]\n+\tmov\tr7, r7, asl #1\n+\tumull\tr5, r6, r7, r14\t\t\t@ d = a[0]*2 * a[9]\n+\tldr\tr7, [r1, #2*4]\t\t\t@ a[2]*2\n+\tumull\tr9, r10, r0, r14\t\t@ d' = a[1]*2 * a[9]\n+\tldr\tr14, [r1, #7*4]\t\t\t@ a[7]\n+\tumlal\tr5, r6, r0, r8\t\t\t@ d += a[1]*2 * a[8]\n+\tmov\tr7, r7, asl #1\n+\tldr\tr0, [r1, #3*4]\t\t\t@ a[3]*2\n+\tumlal\tr9, r10, r7, r8\t\t\t@ d' += a[2]*2 * a[8]\n+\tldr\tr8, [r1, #6*4]\t\t\t@ a[6]\n+\tumlal\tr5, r6, r7, r14\t\t\t@ d += a[2]*2 * a[7]\n+\tmov\tr0, r0, asl #1\n+\tldr\tr7, [r1, #4*4]\t\t\t@ a[4]*2\n+\tumlal\tr9, r10, r0, r14\t\t@ d' += a[3]*2 * a[7]\n+\tldr\tr14, [r1, #5*4]\t\t\t@ a[5]\n+\tmov\tr7, r7, asl #1\n+\tumlal\tr5, r6, r0, r8\t\t\t@ d += a[3]*2 * a[6]\n+\tumlal\tr9, r10, r7, r8\t\t\t@ d' += a[4]*2 * a[6]\n+\tumlal\tr5, r6, r7, r14\t\t\t@ d += a[4]*2 * a[5]\n+\tumlal\tr9, r10, r14, r14\t\t@ d' += a[5] * a[5]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ t9 = d & M\n+\tstr     r0, [sp, #4 + 9*4]\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26 \n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\n+\t/* B */\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u0 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u0 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t0 = c & M\n+\tstr\tr14, [sp, #4 + 0*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u0 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* C interleaved with D */\n+\tldr\tr0, [r1, #0*4]\t\t\t@ a[0]*2\n+\tldr\tr14, [r1, #1*4]\t\t\t@ a[1]\n+\tmov\tr0, r0, asl #1\n+\tldr\tr8, [r1, #2*4]\t\t\t@ a[2]\n+\tumlal\tr3, r4, r0, r14\t\t\t@ c += a[0]*2 * a[1]\n+\tmov\tr7, r8, asl #1                  @ a[2]*2\n+\tumull\tr11, r12, r14, r14\t\t@ c' = a[1] * a[1]\n+\tldr\tr14, [r1, #9*4]\t\t\t@ a[9]\n+\tumlal\tr11, r12, r0, r8\t\t@ c' += a[0]*2 * a[2]\n+\tldr\tr0, [r1, #3*4]\t\t\t@ a[3]*2\n+\tldr\tr8, [r1, #8*4]\t\t\t@ a[8]\n+\tumlal\tr5, r6, r7, r14\t\t\t@ d += a[2]*2 * a[9]\n+\tmov\tr0, r0, asl #1\n+\tldr\tr7, [r1, #4*4]\t\t\t@ a[4]*2\n+\tumull\tr9, r10, r0, r14\t\t@ d' = a[3]*2 * a[9]\n+\tldr\tr14, [r1, #7*4]\t\t\t@ a[7]\n+\tumlal\tr5, r6, r0, r8\t\t\t@ d += a[3]*2 * a[8]\n+\tmov\tr7, r7, asl #1\n+\tldr\tr0, [r1, #5*4]\t\t\t@ a[5]*2\n+\tumlal\tr9, r10, r7, r8\t\t\t@ d' += a[4]*2 * a[8]\n+\tldr\tr8, [r1, #6*4]\t\t\t@ a[6]\n+\tmov\tr0, r0, asl #1\n+\tumlal\tr5, r6, r7, r14\t\t\t@ d += a[4]*2 * a[7]\n+\tumlal\tr9, r10, r0, r14\t\t@ d' += a[5]*2 * a[7]\n+\tumlal\tr5, r6, r0, r8\t\t\t@ d += a[5]*2 * a[6]\n+\tumlal\tr9, r10, r8, r8\t\t\t@ d' += a[6] * a[6]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u1 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u1 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t1 = c & M\n+\tstr\tr14, [sp, #4 + 1*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u1 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* D */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u2 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u2 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t2 = c & M\n+\tstr\tr14, [sp, #4 + 2*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u2 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* E interleaved with F */\n+\tldr\tr7, [r1, #0*4]\t\t\t@ a[0]*2\n+\tldr\tr0, [r1, #1*4]\t\t\t@ a[1]*2\n+\tldr\tr14, [r1, #2*4]\t\t\t@ a[2]\n+\tmov\tr7, r7, asl #1\n+\tldr\tr8, [r1, #3*4]\t\t\t@ a[3]\n+\tldr\tr2, [r1, #4*4]\n+\tumlal\tr3, r4, r7, r8\t\t\t@ c += a[0]*2 * a[3]\n+\tmov\tr0, r0, asl #1\n+\tumull\tr11, r12, r7, r2\t\t@ c' = a[0]*2 * a[4]\n+\tmov\tr2, r2, asl #1\t\t\t@ a[4]*2\n+\tumlal\tr11, r12, r0, r8\t\t@ c' += a[1]*2 * a[3]\n+\tldr\tr8, [r1, #9*4]\t\t\t@ a[9]\n+\tumlal\tr3, r4, r0, r14\t\t\t@ c += a[1]*2 * a[2]\n+\tldr\tr0, [r1, #5*4]\t\t\t@ a[5]*2\n+\tumlal\tr11, r12, r14, r14\t\t@ c' += a[2] * a[2]\n+\tldr\tr14, [r1, #8*4]\t\t\t@ a[8]\n+\tmov\tr0, r0, asl #1\n+\tumlal\tr5, r6, r2, r8\t\t\t@ d += a[4]*2 * a[9]\n+\tldr\tr7, [r1, #6*4]\t\t\t@ a[6]*2\n+\tumull\tr9, r10, r0, r8\t\t\t@ d' = a[5]*2 * a[9]\n+\tmov\tr7, r7, asl #1\n+\tldr\tr8, [r1, #7*4]\t\t\t@ a[7]\n+\tumlal\tr5, r6, r0, r14\t\t\t@ d += a[5]*2 * a[8]\n+\tumlal\tr9, r10, r7, r14\t\t@ d' += a[6]*2 * a[8]\n+\tumlal\tr5, r6, r7, r8\t\t\t@ d += a[6]*2 * a[7]\n+\tumlal\tr9, r10, r8, r8\t\t\t@ d' += a[7] * a[7]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u3 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u3 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t3 = c & M\n+\tstr\tr14, [sp, #4 + 3*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u3 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* F */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u4 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u4 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t4 = c & M\n+\tstr\tr14, [sp, #4 + 4*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u4 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* G interleaved with H */\n+\tldr\tr7, [r1, #0*4]\t\t\t@ a[0]*2\n+\tldr\tr0, [r1, #1*4]\t\t\t@ a[1]*2\n+\tmov\tr7, r7, asl #1\n+\tldr\tr8, [r1, #5*4]\t\t\t@ a[5]\n+\tldr\tr2, [r1, #6*4]\t\t\t@ a[6]\n+\tumlal\tr3, r4, r7, r8\t\t\t@ c += a[0]*2 * a[5]\n+\tldr\tr14, [r1, #4*4]\t\t\t@ a[4]\n+\tmov\tr0, r0, asl #1\n+\tumull\tr11, r12, r7, r2\t\t@ c' = a[0]*2 * a[6]\n+\tldr\tr7, [r1, #2*4]\t\t\t@ a[2]*2\n+\tumlal\tr11, r12, r0, r8\t\t@ c' += a[1]*2 * a[5]\n+\tmov\tr7, r7, asl #1\n+\tldr\tr8, [r1, #3*4]\t\t\t@ a[3]\n+\tumlal\tr3, r4, r0, r14\t\t\t@ c += a[1]*2 * a[4]\n+\tmov\tr0, r2, asl #1\t\t\t@ a[6]*2\n+\tumlal\tr11, r12, r7, r14\t\t@ c' += a[2]*2 * a[4]\n+\tldr\tr14, [r1, #9*4]\t\t\t@ a[9]\n+\tumlal\tr3, r4, r7, r8\t\t\t@ c += a[2]*2 * a[3]\n+\tldr\tr7, [r1, #7*4]\t\t\t@ a[7]*2\n+\tumlal\tr11, r12, r8, r8\t\t@ c' += a[3] * a[3]\n+\tmov\tr7, r7, asl #1\n+\tldr\tr8, [r1, #8*4]\t\t\t@ a[8]\n+\tumlal\tr5, r6, r0, r14\t\t\t@ d += a[6]*2 * a[9]\n+\tumull\tr9, r10, r7, r14\t\t@ d' = a[7]*2 * a[9]\n+\tumlal\tr5, r6, r7, r8\t\t\t@ d += a[7]*2 * a[8]\n+\tumlal\tr9, r10, r8, r8\t\t\t@ d' += a[8] * a[8]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u5 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u5 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t5 = c & M\n+\tstr\tr14, [sp, #4 + 5*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u5 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* H */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tadds\tr5, r5, r9\t\t\t@ d += d'\n+\tadc\tr6, r6, r10\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u6 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u6 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t6 = c & M\n+\tstr\tr14, [sp, #4 + 6*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u6 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* I interleaved with J */\n+\tldr\tr7, [r1, #0*4]\t\t\t@ a[0]*2\n+\tldr\tr0, [r1, #1*4]\t\t\t@ a[1]*2\n+\tmov\tr7, r7, asl #1\n+\tldr\tr8, [r1, #7*4]\t\t\t@ a[7]\n+\tldr\tr2, [r1, #8*4]\t\t\t@ a[8]\n+\tumlal\tr3, r4, r7, r8\t\t\t@ c += a[0]*2 * a[7]\n+\tldr\tr14, [r1, #6*4]\t\t\t@ a[6]\n+\tmov\tr0, r0, asl #1\n+\tumull\tr11, r12, r7, r2\t\t@ c' = a[0]*2 * a[8]\n+\tldr\tr7, [r1, #2*4]\t\t\t@ a[2]*2\n+\tumlal\tr11, r12, r0, r8\t\t@ c' += a[1]*2 * a[7]\n+\tldr\tr8, [r1, #5*4]\t\t\t@ a[5]\n+\tumlal\tr3, r4, r0, r14\t\t\t@ c += a[1]*2 * a[6]\n+\tldr\tr0, [r1, #3*4]\t\t\t@ a[3]*2\n+\tmov\tr7, r7, asl #1\n+\tumlal\tr11, r12, r7, r14\t\t@ c' += a[2]*2 * a[6]\n+\tldr\tr14, [r1, #4*4]\t\t\t@ a[4]\n+\tmov\tr0, r0, asl #1\n+\tumlal\tr3, r4, r7, r8\t\t\t@ c += a[2]*2 * a[5]\n+\tmov\tr2, r2, asl #1\t\t\t@ a[8]*2\n+\tumlal\tr11, r12, r0, r8\t\t@ c' += a[3]*2 * a[5]\n+\tumlal\tr3, r4, r0, r14\t\t\t@ c += a[3]*2 * a[4]\n+\tumlal\tr11, r12, r14, r14\t\t@ c' += a[4] * a[4]\n+\tldr\tr8, [r1, #9*4]\t\t\t@ a[9]\n+\tumlal\tr5, r6, r2, r8\t\t\t@ d += a[8]*2 * a[9]\n+\t@ r8 will be used in J\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u7 = d & M\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u7 * R0\n+\tumlal   r3, r4, r0, r14\n+\tbic\tr14, r3, field_not_M \t\t@ t7 = c & M\n+\tstr\tr14, [sp, #4 + 7*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u7 * R1\n+\tumlal   r3, r4, r0, r14\n+\n+\t/* J */\n+\tadds\tr3, r3, r11\t\t\t@ c += c'\n+\tadc\tr4, r4, r12\n+\tumlal\tr5, r6, r8, r8\t\t\t@ d += a[9] * a[9]\n+\n+\tbic\tr0, r5, field_not_M \t\t@ u8 = d & M\n+\tstr\tr0, [sp, #4 + 8*4]\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\tmovw    r14, field_R0\t\t\t@ c += u8 * R0\n+\tumlal   r3, r4, r0, r14\n+\n+\t/******************************************\n+\t * compute and write back result\n+\t ******************************************\n+\tAllocation:\n+\t    r0    r\n+\t    r3:r4 c\n+\t    r5:r6 d\n+\t    r7    t0\n+\t    r8    t1\n+\t    r9    t2\n+\t    r11   u8\n+\t    r12   t9\n+\t    r1,r2,r10,r14 scratch\n+\n+\tNote: do not read from a[] after here, it may overlap with r[]\n+\t*/\n+\tldr\tr0, [sp, #0]\n+\tadd\tr1, sp, #4 + 3*4\t\t@ r[3..7] = t3..7, r11=u8, r12=t9\n+\tldmia\tr1, {r2,r7,r8,r9,r10,r11,r12}\n+\tadd\tr1, r0, #3*4\n+\tstmia\tr1, {r2,r7,r8,r9,r10}\n+\n+\tbic\tr2, r3, field_not_M \t\t@ r[8] = c & M\n+\tstr\tr2, [r0, #8*4]\n+\tmov\tr3, r3, lsr #26     \t\t@ c >>= 26\n+\torr\tr3, r3, r4, asl #6\n+\tmov     r4, r4, lsr #26\n+\tmov     r14, field_R1\t\t\t@ c += u8 * R1\n+\tumlal   r3, r4, r11, r14\n+\tmovw    r14, field_R0\t\t\t@ c += d * R0\n+\tumlal   r3, r4, r5, r14\n+\tadds\tr3, r3, r12\t\t\t@ c += t9\n+\tadc\tr4, r4, #0\n+\n+\tadd\tr1, sp, #4 + 0*4\t\t@ r7,r8,r9 = t0,t1,t2\n+\tldmia\tr1, {r7,r8,r9}\n+\n+\tubfx\tr2, r3, #0, #22     \t\t@ r[9] = c & (M >> 4)\n+\tstr\tr2, [r0, #9*4]\n+\tmov\tr3, r3, lsr #22     \t\t@ c >>= 22\n+\torr\tr3, r3, r4, asl #10\n+\tmov     r4, r4, lsr #22\n+\tmovw    r14, field_R1 << 4   \t\t@ c += d * (R1 << 4)\n+\tumlal   r3, r4, r5, r14\n+\n+\tmovw    r14, field_R0 >> 4   \t\t@ d = c * (R0 >> 4) + t0 (64x64 multiply+add)\n+\tumull\tr5, r6, r3, r14\t\t\t@ d = c.lo * (R0 >> 4)\n+\tadds\tr5, r5, r7\t    \t\t@ d.lo += t0\n+\tmla\tr6, r14, r4, r6\t\t\t@ d.hi += c.hi * (R0 >> 4)\n+\tadc\tr6, r6, 0\t     \t\t@ d.hi += carry\n+\n+\tbic\tr2, r5, field_not_M \t\t@ r[0] = d & M\n+\tstr\tr2, [r0, #0*4]\n+\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26\n+\torr\tr5, r5, r6, asl #6\n+\tmov     r6, r6, lsr #26\n+\t\n+\tmovw    r14, field_R1 >> 4   \t\t@ d += c * (R1 >> 4) + t1 (64x64 multiply+add)\n+\tumull\tr1, r2, r3, r14       \t\t@ tmp = c.lo * (R1 >> 4)\n+\tadds\tr5, r5, r8\t    \t\t@ d.lo += t1\n+\tadc\tr6, r6, #0\t    \t\t@ d.hi += carry\n+\tadds\tr5, r5, r1\t    \t\t@ d.lo += tmp.lo\n+\tmla\tr2, r14, r4, r2      \t\t@ tmp.hi += c.hi * (R1 >> 4)\n+\tadc\tr6, r6, r2\t   \t\t@ d.hi += carry + tmp.hi\n+\n+\tbic\tr2, r5, field_not_M \t\t@ r[1] = d & M\n+\tstr\tr2, [r0, #1*4]\n+\tmov\tr5, r5, lsr #26     \t\t@ d >>= 26 (ignore hi)\n+\torr\tr5, r5, r6, asl #6\n+\n+\tadd\tr5, r5, r9\t  \t\t@ d += t2\n+\tstr\tr5, [r0, #2*4]      \t\t@ r[2] = d\n+\n+\tadd\tsp, sp, #48\n+\tldmfd\tsp!, {r4, r5, r6, r7, r8, r9, r10, r11, pc}\n+\t.size\tsecp256k1_fe_sqr_inner, .-secp256k1_fe_sqr_inner\n+"
      },
      {
        "sha": "cde5e2dbb4e4ea1bd4fedced7ba1fecea7de8aa1",
        "filename": "src/secp256k1/src/bench_ecdh.c",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/bench_ecdh.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/bench_ecdh.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_ecdh.c?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -28,7 +28,8 @@ static void bench_ecdh_setup(void* arg) {\n         0xa2, 0xba, 0xd1, 0x84, 0xf8, 0x83, 0xc6, 0x9f\n     };\n \n-    data->ctx = secp256k1_context_create(0);\n+    /* create a context with no capabilities */\n+    data->ctx = secp256k1_context_create(SECP256K1_FLAGS_TYPE_CONTEXT);\n     for (i = 0; i < 32; i++) {\n         data->scalar[i] = i + 1;\n     }"
      },
      {
        "sha": "0809f77bda108dacd5a9a2c6208827c985f00f54",
        "filename": "src/secp256k1/src/bench_internal.c",
        "status": "modified",
        "additions": 31,
        "deletions": 3,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/bench_internal.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/bench_internal.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_internal.c?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -181,12 +181,12 @@ void bench_field_inverse_var(void* arg) {\n     }\n }\n \n-void bench_field_sqrt_var(void* arg) {\n+void bench_field_sqrt(void* arg) {\n     int i;\n     bench_inv_t *data = (bench_inv_t*)arg;\n \n     for (i = 0; i < 20000; i++) {\n-        secp256k1_fe_sqrt_var(&data->fe_x, &data->fe_x);\n+        secp256k1_fe_sqrt(&data->fe_x, &data->fe_x);\n         secp256k1_fe_add(&data->fe_x, &data->fe_y);\n     }\n }\n@@ -227,6 +227,15 @@ void bench_group_add_affine_var(void* arg) {\n     }\n }\n \n+void bench_group_jacobi_var(void* arg) {\n+    int i;\n+    bench_inv_t *data = (bench_inv_t*)arg;\n+\n+    for (i = 0; i < 20000; i++) {\n+        secp256k1_gej_has_quad_y_var(&data->gej_x);\n+    }\n+}\n+\n void bench_ecmult_wnaf(void* arg) {\n     int i;\n     bench_inv_t *data = (bench_inv_t*)arg;\n@@ -299,6 +308,21 @@ void bench_context_sign(void* arg) {\n     }\n }\n \n+#ifndef USE_NUM_NONE\n+void bench_num_jacobi(void* arg) {\n+    int i;\n+    bench_inv_t *data = (bench_inv_t*)arg;\n+    secp256k1_num nx, norder;\n+\n+    secp256k1_scalar_get_num(&nx, &data->scalar_x);\n+    secp256k1_scalar_order_get_num(&norder);\n+    secp256k1_scalar_get_num(&norder, &data->scalar_y);\n+\n+    for (i = 0; i < 200000; i++) {\n+        secp256k1_num_jacobi(&nx, &norder);\n+    }\n+}\n+#endif\n \n int have_flag(int argc, char** argv, char *flag) {\n     char** argm = argv + argc;\n@@ -333,12 +357,13 @@ int main(int argc, char **argv) {\n     if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"mul\")) run_benchmark(\"field_mul\", bench_field_mul, bench_setup, NULL, &data, 10, 200000);\n     if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"field_inverse\", bench_field_inverse, bench_setup, NULL, &data, 10, 20000);\n     if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"field_inverse_var\", bench_field_inverse_var, bench_setup, NULL, &data, 10, 20000);\n-    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"sqrt\")) run_benchmark(\"field_sqrt_var\", bench_field_sqrt_var, bench_setup, NULL, &data, 10, 20000);\n+    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"sqrt\")) run_benchmark(\"field_sqrt\", bench_field_sqrt, bench_setup, NULL, &data, 10, 20000);\n \n     if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"double\")) run_benchmark(\"group_double_var\", bench_group_double_var, bench_setup, NULL, &data, 10, 200000);\n     if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_var\", bench_group_add_var, bench_setup, NULL, &data, 10, 200000);\n     if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_affine\", bench_group_add_affine, bench_setup, NULL, &data, 10, 200000);\n     if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_affine_var\", bench_group_add_affine_var, bench_setup, NULL, &data, 10, 200000);\n+    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"jacobi\")) run_benchmark(\"group_jacobi_var\", bench_group_jacobi_var, bench_setup, NULL, &data, 10, 20000);\n \n     if (have_flag(argc, argv, \"ecmult\") || have_flag(argc, argv, \"wnaf\")) run_benchmark(\"wnaf_const\", bench_wnaf_const, bench_setup, NULL, &data, 10, 20000);\n     if (have_flag(argc, argv, \"ecmult\") || have_flag(argc, argv, \"wnaf\")) run_benchmark(\"ecmult_wnaf\", bench_ecmult_wnaf, bench_setup, NULL, &data, 10, 20000);\n@@ -350,5 +375,8 @@ int main(int argc, char **argv) {\n     if (have_flag(argc, argv, \"context\") || have_flag(argc, argv, \"verify\")) run_benchmark(\"context_verify\", bench_context_verify, bench_setup, NULL, &data, 10, 20);\n     if (have_flag(argc, argv, \"context\") || have_flag(argc, argv, \"sign\")) run_benchmark(\"context_sign\", bench_context_sign, bench_setup, NULL, &data, 10, 200);\n \n+#ifndef USE_NUM_NONE\n+    if (have_flag(argc, argv, \"num\") || have_flag(argc, argv, \"jacobi\")) run_benchmark(\"num_jacobi\", bench_num_jacobi, bench_setup, NULL, &data, 10, 200000);\n+#endif\n     return 0;\n }"
      },
      {
        "sha": "418defa0aa22a06dff07d3f1567e205235706976",
        "filename": "src/secp256k1/src/bench_verify.c",
        "status": "modified",
        "additions": 44,
        "deletions": 0,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/bench_verify.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/bench_verify.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_verify.c?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -11,6 +11,12 @@\n #include \"util.h\"\n #include \"bench.h\"\n \n+#ifdef ENABLE_OPENSSL_TESTS\n+#include <openssl/bn.h>\n+#include <openssl/ecdsa.h>\n+#include <openssl/obj_mac.h>\n+#endif\n+\n typedef struct {\n     secp256k1_context *ctx;\n     unsigned char msg[32];\n@@ -19,6 +25,9 @@ typedef struct {\n     size_t siglen;\n     unsigned char pubkey[33];\n     size_t pubkeylen;\n+#ifdef ENABLE_OPENSSL_TESTS\n+    EC_GROUP* ec_group;\n+#endif\n } benchmark_verify_t;\n \n static void benchmark_verify(void* arg) {\n@@ -40,6 +49,36 @@ static void benchmark_verify(void* arg) {\n     }\n }\n \n+#ifdef ENABLE_OPENSSL_TESTS\n+static void benchmark_verify_openssl(void* arg) {\n+    int i;\n+    benchmark_verify_t* data = (benchmark_verify_t*)arg;\n+\n+    for (i = 0; i < 20000; i++) {\n+        data->sig[data->siglen - 1] ^= (i & 0xFF);\n+        data->sig[data->siglen - 2] ^= ((i >> 8) & 0xFF);\n+        data->sig[data->siglen - 3] ^= ((i >> 16) & 0xFF);\n+        {\n+            EC_KEY *pkey = EC_KEY_new();\n+            const unsigned char *pubkey = &data->pubkey[0];\n+            int result;\n+\n+            CHECK(pkey != NULL);\n+            result = EC_KEY_set_group(pkey, data->ec_group);\n+            CHECK(result);\n+            result = (o2i_ECPublicKey(&pkey, &pubkey, data->pubkeylen)) != NULL;\n+            CHECK(result);\n+            result = ECDSA_verify(0, &data->msg[0], sizeof(data->msg), &data->sig[0], data->siglen, pkey) == (i == 0);\n+            CHECK(result);\n+            EC_KEY_free(pkey);\n+        }\n+        data->sig[data->siglen - 1] ^= (i & 0xFF);\n+        data->sig[data->siglen - 2] ^= ((i >> 8) & 0xFF);\n+        data->sig[data->siglen - 3] ^= ((i >> 16) & 0xFF);\n+    }\n+}\n+#endif\n+\n int main(void) {\n     int i;\n     secp256k1_pubkey pubkey;\n@@ -62,6 +101,11 @@ int main(void) {\n     CHECK(secp256k1_ec_pubkey_serialize(data.ctx, data.pubkey, &data.pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED) == 1);\n \n     run_benchmark(\"ecdsa_verify\", benchmark_verify, NULL, NULL, &data, 10, 20000);\n+#ifdef ENABLE_OPENSSL_TESTS\n+    data.ec_group = EC_GROUP_new_by_curve_name(NID_secp256k1);\n+    run_benchmark(\"ecdsa_verify_openssl\", benchmark_verify_openssl, NULL, NULL, &data, 10, 20000);\n+    EC_GROUP_free(data.ec_group);\n+#endif\n \n     secp256k1_context_destroy(data.ctx);\n     return 0;"
      },
      {
        "sha": "9a42e519bd580c6f505d66deec88bbed6dabecf8",
        "filename": "src/secp256k1/src/ecdsa_impl.h",
        "status": "modified",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/ecdsa_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/ecdsa_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecdsa_impl.h?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -203,7 +203,9 @@ static int secp256k1_ecdsa_sig_serialize(unsigned char *sig, size_t *size, const\n static int secp256k1_ecdsa_sig_verify(const secp256k1_ecmult_context *ctx, const secp256k1_scalar *sigr, const secp256k1_scalar *sigs, const secp256k1_ge *pubkey, const secp256k1_scalar *message) {\n     unsigned char c[32];\n     secp256k1_scalar sn, u1, u2;\n+#if !defined(EXHAUSTIVE_TEST_ORDER)\n     secp256k1_fe xr;\n+#endif\n     secp256k1_gej pubkeyj;\n     secp256k1_gej pr;\n \n@@ -219,6 +221,21 @@ static int secp256k1_ecdsa_sig_verify(const secp256k1_ecmult_context *ctx, const\n     if (secp256k1_gej_is_infinity(&pr)) {\n         return 0;\n     }\n+\n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+{\n+    secp256k1_scalar computed_r;\n+    int overflow = 0;\n+    secp256k1_ge pr_ge;\n+    secp256k1_ge_set_gej(&pr_ge, &pr);\n+    secp256k1_fe_normalize(&pr_ge.x);\n+\n+    secp256k1_fe_get_b32(c, &pr_ge.x);\n+    secp256k1_scalar_set_b32(&computed_r, c, &overflow);\n+    /* we fully expect overflow */\n+    return secp256k1_scalar_eq(sigr, &computed_r);\n+}\n+#else\n     secp256k1_scalar_get_b32(c, sigr);\n     secp256k1_fe_set_b32(&xr, c);\n \n@@ -252,6 +269,7 @@ static int secp256k1_ecdsa_sig_verify(const secp256k1_ecmult_context *ctx, const\n         return 1;\n     }\n     return 0;\n+#endif\n }\n \n static int secp256k1_ecdsa_sig_sign(const secp256k1_ecmult_gen_context *ctx, secp256k1_scalar *sigr, secp256k1_scalar *sigs, const secp256k1_scalar *seckey, const secp256k1_scalar *message, const secp256k1_scalar *nonce, int *recid) {"
      },
      {
        "sha": "0db314c48e0cdc844a89cb4a6d5b4ce4c9352578",
        "filename": "src/secp256k1/src/ecmult_const_impl.h",
        "status": "modified",
        "additions": 24,
        "deletions": 45,
        "changes": 69,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/ecmult_const_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/ecmult_const_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_const_impl.h?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -58,25 +58,27 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w) {\n     int global_sign;\n     int skew = 0;\n     int word = 0;\n+\n     /* 1 2 3 */\n     int u_last;\n     int u;\n \n-#ifdef USE_ENDOMORPHISM\n     int flip;\n     int bit;\n     secp256k1_scalar neg_s;\n     int not_neg_one;\n-    /* If we are using the endomorphism, we cannot handle even numbers by negating\n-     * them, since we are working with 128-bit numbers whose negations would be 256\n-     * bits, eliminating the performance advantage. Instead we use a technique from\n+    /* Note that we cannot handle even numbers by negating them to be odd, as is\n+     * done in other implementations, since if our scalars were specified to have\n+     * width < 256 for performance reasons, their negations would have width 256\n+     * and we'd lose any performance benefit. Instead, we use a technique from\n      * Section 4.2 of the Okeya/Tagaki paper, which is to add either 1 (for even)\n-     * or 2 (for odd) to the number we are encoding, then compensating after the\n-     * multiplication. */\n-    /* Negative 128-bit numbers will be negated, since otherwise they are 256-bit */\n+     * or 2 (for odd) to the number we are encoding, returning a skew value indicating\n+     * this, and having the caller compensate after doing the multiplication. */\n+\n+    /* Negative numbers will be negated to keep their bit representation below the maximum width */\n     flip = secp256k1_scalar_is_high(&s);\n     /* We add 1 to even numbers, 2 to odd ones, noting that negation flips parity */\n-    bit = flip ^ (s.d[0] & 1);\n+    bit = flip ^ !secp256k1_scalar_is_even(&s);\n     /* We check for negative one, since adding 2 to it will cause an overflow */\n     secp256k1_scalar_negate(&neg_s, &s);\n     not_neg_one = !secp256k1_scalar_is_one(&neg_s);\n@@ -89,11 +91,6 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w) {\n     global_sign = secp256k1_scalar_cond_negate(&s, flip);\n     global_sign *= not_neg_one * 2 - 1;\n     skew = 1 << bit;\n-#else\n-    /* Otherwise, we just negate to force oddness */\n-    int is_even = secp256k1_scalar_is_even(&s);\n-    global_sign = secp256k1_scalar_cond_negate(&s, is_even);\n-#endif\n \n     /* 4 */\n     u_last = secp256k1_scalar_shr_int(&s, w);\n@@ -127,15 +124,13 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n     secp256k1_ge tmpa;\n     secp256k1_fe Z;\n \n+    int skew_1;\n+    int wnaf_1[1 + WNAF_SIZE(WINDOW_A - 1)];\n #ifdef USE_ENDOMORPHISM\n     secp256k1_ge pre_a_lam[ECMULT_TABLE_SIZE(WINDOW_A)];\n-    int wnaf_1[1 + WNAF_SIZE(WINDOW_A - 1)];\n     int wnaf_lam[1 + WNAF_SIZE(WINDOW_A - 1)];\n-    int skew_1;\n     int skew_lam;\n     secp256k1_scalar q_1, q_lam;\n-#else\n-    int wnaf[1 + WNAF_SIZE(WINDOW_A - 1)];\n #endif\n \n     int i;\n@@ -145,18 +140,10 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n #ifdef USE_ENDOMORPHISM\n     /* split q into q_1 and q_lam (where q = q_1 + q_lam*lambda, and q_1 and q_lam are ~128 bit) */\n     secp256k1_scalar_split_lambda(&q_1, &q_lam, &sc);\n-    /* no need for zero correction when using endomorphism since even\n-     * numbers have one added to them anyway */\n     skew_1   = secp256k1_wnaf_const(wnaf_1,   q_1,   WINDOW_A - 1);\n     skew_lam = secp256k1_wnaf_const(wnaf_lam, q_lam, WINDOW_A - 1);\n #else\n-    int is_zero = secp256k1_scalar_is_zero(scalar);\n-    /* the wNAF ladder cannot handle zero, so bump this to one .. we will\n-     * correct the result after the fact */\n-    sc.d[0] += is_zero;\n-    VERIFY_CHECK(!secp256k1_scalar_is_zero(&sc));\n-\n-    secp256k1_wnaf_const(wnaf, sc, WINDOW_A - 1);\n+    skew_1   = secp256k1_wnaf_const(wnaf_1, sc, WINDOW_A - 1);\n #endif\n \n     /* Calculate odd multiples of a.\n@@ -179,21 +166,15 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n     /* first loop iteration (separated out so we can directly set r, rather\n      * than having it start at infinity, get doubled several times, then have\n      * its new value added to it) */\n-#ifdef USE_ENDOMORPHISM\n     i = wnaf_1[WNAF_SIZE(WINDOW_A - 1)];\n     VERIFY_CHECK(i != 0);\n     ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a, i, WINDOW_A);\n     secp256k1_gej_set_ge(r, &tmpa);\n-\n+#ifdef USE_ENDOMORPHISM\n     i = wnaf_lam[WNAF_SIZE(WINDOW_A - 1)];\n     VERIFY_CHECK(i != 0);\n     ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a_lam, i, WINDOW_A);\n     secp256k1_gej_add_ge(r, r, &tmpa);\n-#else\n-    i = wnaf[WNAF_SIZE(WINDOW_A - 1)];\n-    VERIFY_CHECK(i != 0);\n-    ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a, i, WINDOW_A);\n-    secp256k1_gej_set_ge(r, &tmpa);\n #endif\n     /* remaining loop iterations */\n     for (i = WNAF_SIZE(WINDOW_A - 1) - 1; i >= 0; i--) {\n@@ -202,59 +183,57 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n         for (j = 0; j < WINDOW_A - 1; ++j) {\n             secp256k1_gej_double_nonzero(r, r, NULL);\n         }\n-#ifdef USE_ENDOMORPHISM\n+\n         n = wnaf_1[i];\n         ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a, n, WINDOW_A);\n         VERIFY_CHECK(n != 0);\n         secp256k1_gej_add_ge(r, r, &tmpa);\n-\n+#ifdef USE_ENDOMORPHISM\n         n = wnaf_lam[i];\n         ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a_lam, n, WINDOW_A);\n         VERIFY_CHECK(n != 0);\n         secp256k1_gej_add_ge(r, r, &tmpa);\n-#else\n-        n = wnaf[i];\n-        VERIFY_CHECK(n != 0);\n-        ECMULT_CONST_TABLE_GET_GE(&tmpa, pre_a, n, WINDOW_A);\n-        secp256k1_gej_add_ge(r, r, &tmpa);\n #endif\n     }\n \n     secp256k1_fe_mul(&r->z, &r->z, &Z);\n \n-#ifdef USE_ENDOMORPHISM\n     {\n         /* Correct for wNAF skew */\n         secp256k1_ge correction = *a;\n         secp256k1_ge_storage correction_1_stor;\n+#ifdef USE_ENDOMORPHISM\n         secp256k1_ge_storage correction_lam_stor;\n+#endif\n         secp256k1_ge_storage a2_stor;\n         secp256k1_gej tmpj;\n         secp256k1_gej_set_ge(&tmpj, &correction);\n         secp256k1_gej_double_var(&tmpj, &tmpj, NULL);\n         secp256k1_ge_set_gej(&correction, &tmpj);\n         secp256k1_ge_to_storage(&correction_1_stor, a);\n+#ifdef USE_ENDOMORPHISM\n         secp256k1_ge_to_storage(&correction_lam_stor, a);\n+#endif\n         secp256k1_ge_to_storage(&a2_stor, &correction);\n \n         /* For odd numbers this is 2a (so replace it), for even ones a (so no-op) */\n         secp256k1_ge_storage_cmov(&correction_1_stor, &a2_stor, skew_1 == 2);\n+#ifdef USE_ENDOMORPHISM\n         secp256k1_ge_storage_cmov(&correction_lam_stor, &a2_stor, skew_lam == 2);\n+#endif\n \n         /* Apply the correction */\n         secp256k1_ge_from_storage(&correction, &correction_1_stor);\n         secp256k1_ge_neg(&correction, &correction);\n         secp256k1_gej_add_ge(r, r, &correction);\n \n+#ifdef USE_ENDOMORPHISM\n         secp256k1_ge_from_storage(&correction, &correction_lam_stor);\n         secp256k1_ge_neg(&correction, &correction);\n         secp256k1_ge_mul_lambda(&correction, &correction);\n         secp256k1_gej_add_ge(r, r, &correction);\n-    }\n-#else\n-    /* correct for zero */\n-    r->infinity |= is_zero;\n #endif\n+    }\n }\n \n #endif"
      },
      {
        "sha": "35f25460773f3ab1819beb6a1633ef264c83408d",
        "filename": "src/secp256k1/src/ecmult_gen_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/ecmult_gen_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/ecmult_gen_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_gen_impl.h?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -77,7 +77,7 @@ static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context *ctx\n                 secp256k1_gej_add_var(&numsbase, &numsbase, &nums_gej, NULL);\n             }\n         }\n-        secp256k1_ge_set_all_gej_var(1024, prec, precj, cb);\n+        secp256k1_ge_set_all_gej_var(prec, precj, 1024, cb);\n     }\n     for (j = 0; j < 64; j++) {\n         for (i = 0; i < 16; i++) {"
      },
      {
        "sha": "4e40104ad43ceb12845b79994c5bd5d28f3b31a0",
        "filename": "src/secp256k1/src/ecmult_impl.h",
        "status": "modified",
        "additions": 19,
        "deletions": 2,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/ecmult_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/ecmult_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_impl.h?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -7,13 +7,29 @@\n #ifndef _SECP256K1_ECMULT_IMPL_H_\n #define _SECP256K1_ECMULT_IMPL_H_\n \n+#include <string.h>\n+\n #include \"group.h\"\n #include \"scalar.h\"\n #include \"ecmult.h\"\n \n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/* We need to lower these values for exhaustive tests because\n+ * the tables cannot have infinities in them (this breaks the\n+ * affine-isomorphism stuff which tracks z-ratios) */\n+#  if EXHAUSTIVE_TEST_ORDER > 128\n+#    define WINDOW_A 5\n+#    define WINDOW_G 8\n+#  elif EXHAUSTIVE_TEST_ORDER > 8\n+#    define WINDOW_A 4\n+#    define WINDOW_G 4\n+#  else\n+#    define WINDOW_A 2\n+#    define WINDOW_G 2\n+#  endif\n+#else\n /* optimal for 128-bit and 256-bit exponents. */\n #define WINDOW_A 5\n-\n /** larger numbers may result in slightly better performance, at the cost of\n     exponentially larger precomputed tables. */\n #ifdef USE_ENDOMORPHISM\n@@ -23,6 +39,7 @@\n /** One table for window size 16: 1.375 MiB. */\n #define WINDOW_G 16\n #endif\n+#endif\n \n /** The number of entries a table with precomputed multiples needs to have. */\n #define ECMULT_TABLE_SIZE(w) (1 << ((w)-2))\n@@ -101,7 +118,7 @@ static void secp256k1_ecmult_odd_multiples_table_storage_var(int n, secp256k1_ge\n     /* Compute the odd multiples in Jacobian form. */\n     secp256k1_ecmult_odd_multiples_table(n, prej, zr, a);\n     /* Convert them in batch to affine coordinates. */\n-    secp256k1_ge_set_table_gej_var(n, prea, prej, zr);\n+    secp256k1_ge_set_table_gej_var(prea, prej, zr, n);\n     /* Convert them to compact storage form. */\n     for (i = 0; i < n; i++) {\n         secp256k1_ge_to_storage(&pre[i], &prea[i]);"
      },
      {
        "sha": "bbb1ee866cc427108f03a4f94fc1da27981c29fa",
        "filename": "src/secp256k1/src/field.h",
        "status": "modified",
        "additions": 13,
        "deletions": 2,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/field.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/field.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field.h?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -30,6 +30,8 @@\n #error \"Please select field implementation\"\n #endif\n \n+#include \"util.h\"\n+\n /** Normalize a field element. */\n static void secp256k1_fe_normalize(secp256k1_fe *r);\n \n@@ -50,13 +52,19 @@ static int secp256k1_fe_normalizes_to_zero_var(secp256k1_fe *r);\n /** Set a field element equal to a small integer. Resulting field element is normalized. */\n static void secp256k1_fe_set_int(secp256k1_fe *r, int a);\n \n+/** Sets a field element equal to zero, initializing all fields. */\n+static void secp256k1_fe_clear(secp256k1_fe *a);\n+\n /** Verify whether a field element is zero. Requires the input to be normalized. */\n static int secp256k1_fe_is_zero(const secp256k1_fe *a);\n \n /** Check the \"oddness\" of a field element. Requires the input to be normalized. */\n static int secp256k1_fe_is_odd(const secp256k1_fe *a);\n \n /** Compare two field elements. Requires magnitude-1 inputs. */\n+static int secp256k1_fe_equal(const secp256k1_fe *a, const secp256k1_fe *b);\n+\n+/** Same as secp256k1_fe_equal, but may be variable time. */\n static int secp256k1_fe_equal_var(const secp256k1_fe *a, const secp256k1_fe *b);\n \n /** Compare two field elements. Requires both inputs to be normalized */\n@@ -92,7 +100,10 @@ static void secp256k1_fe_sqr(secp256k1_fe *r, const secp256k1_fe *a);\n  *  The input's magnitude can be at most 8. The output magnitude is 1 (but not\n  *  guaranteed to be normalized). The result in r will always be a square\n  *  itself. */\n-static int secp256k1_fe_sqrt_var(secp256k1_fe *r, const secp256k1_fe *a);\n+static int secp256k1_fe_sqrt(secp256k1_fe *r, const secp256k1_fe *a);\n+\n+/** Checks whether a field element is a quadratic residue. */\n+static int secp256k1_fe_is_quad_var(const secp256k1_fe *a);\n \n /** Sets a field element to be the (modular) inverse of another. Requires the input's magnitude to be\n  *  at most 8. The output magnitude is 1 (but not guaranteed to be normalized). */\n@@ -104,7 +115,7 @@ static void secp256k1_fe_inv_var(secp256k1_fe *r, const secp256k1_fe *a);\n /** Calculate the (modular) inverses of a batch of field elements. Requires the inputs' magnitudes to be\n  *  at most 8. The output magnitudes are 1 (but not guaranteed to be normalized). The inputs and\n  *  outputs must not overlap in memory. */\n-static void secp256k1_fe_inv_all_var(size_t len, secp256k1_fe *r, const secp256k1_fe *a);\n+static void secp256k1_fe_inv_all_var(secp256k1_fe *r, const secp256k1_fe *a, size_t len);\n \n /** Convert a field element to the storage type. */\n static void secp256k1_fe_to_storage(secp256k1_fe_storage *r, const secp256k1_fe *a);"
      },
      {
        "sha": "7b8c07960847ebe8a4dfde401bc6596795b83b15",
        "filename": "src/secp256k1/src/field_10x26_impl.h",
        "status": "modified",
        "additions": 9,
        "deletions": 3,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/field_10x26_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/field_10x26_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_10x26_impl.h?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -7,8 +7,6 @@\n #ifndef _SECP256K1_FIELD_REPR_IMPL_H_\n #define _SECP256K1_FIELD_REPR_IMPL_H_\n \n-#include <stdio.h>\n-#include <string.h>\n #include \"util.h\"\n #include \"num.h\"\n #include \"field.h\"\n@@ -429,6 +427,14 @@ SECP256K1_INLINE static void secp256k1_fe_add(secp256k1_fe *r, const secp256k1_f\n #endif\n }\n \n+#if defined(USE_EXTERNAL_ASM)\n+\n+/* External assembler implementation */\n+void secp256k1_fe_mul_inner(uint32_t *r, const uint32_t *a, const uint32_t * SECP256K1_RESTRICT b);\n+void secp256k1_fe_sqr_inner(uint32_t *r, const uint32_t *a);\n+\n+#else\n+\n #ifdef VERIFY\n #define VERIFY_BITS(x, n) VERIFY_CHECK(((x) >> (n)) == 0)\n #else\n@@ -1037,7 +1043,7 @@ SECP256K1_INLINE static void secp256k1_fe_sqr_inner(uint32_t *r, const uint32_t\n     VERIFY_BITS(r[2], 27);\n     /* [r9 r8 r7 r6 r5 r4 r3 r2 r1 r0] = [p18 p17 p16 p15 p14 p13 p12 p11 p10 p9 p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n }\n-\n+#endif\n \n static void secp256k1_fe_mul(secp256k1_fe *r, const secp256k1_fe *a, const secp256k1_fe * SECP256K1_RESTRICT b) {\n #ifdef VERIFY"
      },
      {
        "sha": "7a99eb21eccc6bcea99d6d015bf0a7307d26db21",
        "filename": "src/secp256k1/src/field_5x52_impl.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/field_5x52_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/field_5x52_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_5x52_impl.h?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -11,7 +11,6 @@\n #include \"libsecp256k1-config.h\"\n #endif\n \n-#include <string.h>\n #include \"util.h\"\n #include \"num.h\"\n #include \"field.h\""
      },
      {
        "sha": "0bf22bdd3ec887251346dac826291fd1432c13ce",
        "filename": "src/secp256k1/src/field_5x52_int128_impl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/field_5x52_int128_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/field_5x52_int128_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_5x52_int128_impl.h?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -137,7 +137,7 @@ SECP256K1_INLINE static void secp256k1_fe_mul_inner(uint64_t *r, const uint64_t\n     VERIFY_BITS(r[2], 52);\n     VERIFY_BITS(c, 63);\n     /* [d 0 0 0 t4 t3+c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n-    c   += d * R + t3;;\n+    c   += d * R + t3;\n     VERIFY_BITS(c, 100);\n     /* [t4 c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n     r[3] = c & M; c >>= 52;\n@@ -259,7 +259,7 @@ SECP256K1_INLINE static void secp256k1_fe_sqr_inner(uint64_t *r, const uint64_t\n     VERIFY_BITS(c, 63);\n     /* [d 0 0 0 t4 t3+c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n \n-    c   += d * R + t3;;\n+    c   += d * R + t3;\n     VERIFY_BITS(c, 100);\n     /* [t4 c r2 r1 r0] = [p8 p7 p6 p5 p4 p3 p2 p1 p0] */\n     r[3] = c & M; c >>= 52;"
      },
      {
        "sha": "5127b279bc7f56b621042d9f79bfc200dd7086c7",
        "filename": "src/secp256k1/src/field_impl.h",
        "status": "modified",
        "additions": 35,
        "deletions": 3,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/field_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/field_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_impl.h?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -21,14 +21,21 @@\n #error \"Please select field implementation\"\n #endif\n \n+SECP256K1_INLINE static int secp256k1_fe_equal(const secp256k1_fe *a, const secp256k1_fe *b) {\n+    secp256k1_fe na;\n+    secp256k1_fe_negate(&na, a, 1);\n+    secp256k1_fe_add(&na, b);\n+    return secp256k1_fe_normalizes_to_zero(&na);\n+}\n+\n SECP256K1_INLINE static int secp256k1_fe_equal_var(const secp256k1_fe *a, const secp256k1_fe *b) {\n     secp256k1_fe na;\n     secp256k1_fe_negate(&na, a, 1);\n     secp256k1_fe_add(&na, b);\n     return secp256k1_fe_normalizes_to_zero_var(&na);\n }\n \n-static int secp256k1_fe_sqrt_var(secp256k1_fe *r, const secp256k1_fe *a) {\n+static int secp256k1_fe_sqrt(secp256k1_fe *r, const secp256k1_fe *a) {\n     /** Given that p is congruent to 3 mod 4, we can compute the square root of\n      *  a mod p as the (p+1)/4'th power of a.\n      *\n@@ -123,7 +130,7 @@ static int secp256k1_fe_sqrt_var(secp256k1_fe *r, const secp256k1_fe *a) {\n     /* Check that a square root was actually calculated */\n \n     secp256k1_fe_sqr(&t1, r);\n-    return secp256k1_fe_equal_var(&t1, a);\n+    return secp256k1_fe_equal(&t1, a);\n }\n \n static void secp256k1_fe_inv(secp256k1_fe *r, const secp256k1_fe *a) {\n@@ -253,7 +260,7 @@ static void secp256k1_fe_inv_var(secp256k1_fe *r, const secp256k1_fe *a) {\n #endif\n }\n \n-static void secp256k1_fe_inv_all_var(size_t len, secp256k1_fe *r, const secp256k1_fe *a) {\n+static void secp256k1_fe_inv_all_var(secp256k1_fe *r, const secp256k1_fe *a, size_t len) {\n     secp256k1_fe u;\n     size_t i;\n     if (len < 1) {\n@@ -280,4 +287,29 @@ static void secp256k1_fe_inv_all_var(size_t len, secp256k1_fe *r, const secp256k\n     r[0] = u;\n }\n \n+static int secp256k1_fe_is_quad_var(const secp256k1_fe *a) {\n+#ifndef USE_NUM_NONE\n+    unsigned char b[32];\n+    secp256k1_num n;\n+    secp256k1_num m;\n+    /* secp256k1 field prime, value p defined in \"Standards for Efficient Cryptography\" (SEC2) 2.7.1. */\n+    static const unsigned char prime[32] = {\n+        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n+        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n+        0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n+        0xFF,0xFF,0xFF,0xFE,0xFF,0xFF,0xFC,0x2F\n+    };\n+\n+    secp256k1_fe c = *a;\n+    secp256k1_fe_normalize_var(&c);\n+    secp256k1_fe_get_b32(b, &c);\n+    secp256k1_num_set_bin(&n, b, 32);\n+    secp256k1_num_set_bin(&m, prime, 32);\n+    return secp256k1_num_jacobi(&n, &m) >= 0;\n+#else\n+    secp256k1_fe r;\n+    return secp256k1_fe_sqrt(&r, a);\n+#endif\n+}\n+\n #endif"
      },
      {
        "sha": "4957b248fe6a608b8ae825b9b200b263415f36c4",
        "filename": "src/secp256k1/src/group.h",
        "status": "modified",
        "additions": 6,
        "deletions": 3,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/group.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/group.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/group.h?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -47,7 +47,7 @@ static void secp256k1_ge_set_xy(secp256k1_ge *r, const secp256k1_fe *x, const se\n  *  and a Y coordinate that is a quadratic residue modulo p. The return value\n  *  is true iff a coordinate with the given X coordinate exists.\n  */\n-static int secp256k1_ge_set_xquad_var(secp256k1_ge *r, const secp256k1_fe *x);\n+static int secp256k1_ge_set_xquad(secp256k1_ge *r, const secp256k1_fe *x);\n \n /** Set a group element (affine) equal to the point with the given X coordinate, and given oddness\n  *  for Y. Return value indicates whether the result is valid. */\n@@ -65,12 +65,12 @@ static void secp256k1_ge_neg(secp256k1_ge *r, const secp256k1_ge *a);\n static void secp256k1_ge_set_gej(secp256k1_ge *r, secp256k1_gej *a);\n \n /** Set a batch of group elements equal to the inputs given in jacobian coordinates */\n-static void secp256k1_ge_set_all_gej_var(size_t len, secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_callback *cb);\n+static void secp256k1_ge_set_all_gej_var(secp256k1_ge *r, const secp256k1_gej *a, size_t len, const secp256k1_callback *cb);\n \n /** Set a batch of group elements equal to the inputs given in jacobian\n  *  coordinates (with known z-ratios). zr must contain the known z-ratios such\n  *  that mul(a[i].z, zr[i+1]) == a[i+1].z. zr[0] is ignored. */\n-static void secp256k1_ge_set_table_gej_var(size_t len, secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_fe *zr);\n+static void secp256k1_ge_set_table_gej_var(secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_fe *zr, size_t len);\n \n /** Bring a batch inputs given in jacobian coordinates (with known z-ratios) to\n  *  the same global z \"denominator\". zr must contain the known z-ratios such\n@@ -94,6 +94,9 @@ static void secp256k1_gej_neg(secp256k1_gej *r, const secp256k1_gej *a);\n /** Check whether a group element is the point at infinity. */\n static int secp256k1_gej_is_infinity(const secp256k1_gej *a);\n \n+/** Check whether a group element's y coordinate is a quadratic residue. */\n+static int secp256k1_gej_has_quad_y_var(const secp256k1_gej *a);\n+\n /** Set r equal to the double of a. If rzr is not-NULL, r->z = a->z * *rzr (where infinity means an implicit z = 0).\n  * a may not be zero. Constant time. */\n static void secp256k1_gej_double_nonzero(secp256k1_gej *r, const secp256k1_gej *a, secp256k1_fe *rzr);"
      },
      {
        "sha": "2e192b62fd2ce7fa83f0b3d1876c0fbc6876f60e",
        "filename": "src/secp256k1/src/group_impl.h",
        "status": "modified",
        "additions": 96,
        "deletions": 16,
        "changes": 112,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/group_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/group_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/group_impl.h?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -7,12 +7,57 @@\n #ifndef _SECP256K1_GROUP_IMPL_H_\n #define _SECP256K1_GROUP_IMPL_H_\n \n-#include <string.h>\n-\n #include \"num.h\"\n #include \"field.h\"\n #include \"group.h\"\n \n+/* These points can be generated in sage as follows:\n+ *\n+ * 0. Setup a worksheet with the following parameters.\n+ *   b = 4  # whatever CURVE_B will be set to\n+ *   F = FiniteField (0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F)\n+ *   C = EllipticCurve ([F (0), F (b)])\n+ *\n+ * 1. Determine all the small orders available to you. (If there are\n+ *    no satisfactory ones, go back and change b.)\n+ *   print C.order().factor(limit=1000)\n+ *\n+ * 2. Choose an order as one of the prime factors listed in the above step.\n+ *    (You can also multiply some to get a composite order, though the\n+ *    tests will crash trying to invert scalars during signing.) We take a\n+ *    random point and scale it to drop its order to the desired value.\n+ *    There is some probability this won't work; just try again.\n+ *   order = 199\n+ *   P = C.random_point()\n+ *   P = (int(P.order()) / int(order)) * P\n+ *   assert(P.order() == order)\n+ *\n+ * 3. Print the values. You'll need to use a vim macro or something to\n+ *    split the hex output into 4-byte chunks.\n+ *   print \"%x %x\" % P.xy()\n+ */\n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+#  if EXHAUSTIVE_TEST_ORDER == 199\n+const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n+    0xFA7CC9A7, 0x0737F2DB, 0xA749DD39, 0x2B4FB069,\n+    0x3B017A7D, 0xA808C2F1, 0xFB12940C, 0x9EA66C18,\n+    0x78AC123A, 0x5ED8AEF3, 0x8732BC91, 0x1F3A2868,\n+    0x48DF246C, 0x808DAE72, 0xCFE52572, 0x7F0501ED\n+);\n+\n+const int CURVE_B = 4;\n+#  elif EXHAUSTIVE_TEST_ORDER == 13\n+const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n+    0xedc60018, 0xa51a786b, 0x2ea91f4d, 0x4c9416c0,\n+    0x9de54c3b, 0xa1316554, 0x6cf4345c, 0x7277ef15,\n+    0x54cb1b6b, 0xdc8c1273, 0x087844ea, 0x43f4603e,\n+    0x0eaf9a43, 0xf6effe55, 0x939f806d, 0x37adf8ac\n+);\n+const int CURVE_B = 2;\n+#  else\n+#    error No known generator for the specified exhaustive test group order.\n+#  endif\n+#else\n /** Generator for secp256k1, value 'g' defined in\n  *  \"Standards for Efficient Cryptography\" (SEC2) 2.7.1.\n  */\n@@ -23,8 +68,11 @@ static const secp256k1_ge secp256k1_ge_const_g = SECP256K1_GE_CONST(\n     0xFD17B448UL, 0xA6855419UL, 0x9C47D08FUL, 0xFB10D4B8UL\n );\n \n+const int CURVE_B = 7;\n+#endif\n+\n static void secp256k1_ge_set_gej_zinv(secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_fe *zi) {\n-    secp256k1_fe zi2; \n+    secp256k1_fe zi2;\n     secp256k1_fe zi3;\n     secp256k1_fe_sqr(&zi2, zi);\n     secp256k1_fe_mul(&zi3, &zi2, zi);\n@@ -78,7 +126,7 @@ static void secp256k1_ge_set_gej_var(secp256k1_ge *r, secp256k1_gej *a) {\n     r->y = a->y;\n }\n \n-static void secp256k1_ge_set_all_gej_var(size_t len, secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_callback *cb) {\n+static void secp256k1_ge_set_all_gej_var(secp256k1_ge *r, const secp256k1_gej *a, size_t len, const secp256k1_callback *cb) {\n     secp256k1_fe *az;\n     secp256k1_fe *azi;\n     size_t i;\n@@ -91,7 +139,7 @@ static void secp256k1_ge_set_all_gej_var(size_t len, secp256k1_ge *r, const secp\n     }\n \n     azi = (secp256k1_fe *)checked_malloc(cb, sizeof(secp256k1_fe) * count);\n-    secp256k1_fe_inv_all_var(count, azi, az);\n+    secp256k1_fe_inv_all_var(azi, az, count);\n     free(az);\n \n     count = 0;\n@@ -104,7 +152,7 @@ static void secp256k1_ge_set_all_gej_var(size_t len, secp256k1_ge *r, const secp\n     free(azi);\n }\n \n-static void secp256k1_ge_set_table_gej_var(size_t len, secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_fe *zr) {\n+static void secp256k1_ge_set_table_gej_var(secp256k1_ge *r, const secp256k1_gej *a, const secp256k1_fe *zr, size_t len) {\n     size_t i = len - 1;\n     secp256k1_fe zi;\n \n@@ -147,9 +195,15 @@ static void secp256k1_ge_globalz_set_table_gej(size_t len, secp256k1_ge *r, secp\n \n static void secp256k1_gej_set_infinity(secp256k1_gej *r) {\n     r->infinity = 1;\n-    secp256k1_fe_set_int(&r->x, 0);\n-    secp256k1_fe_set_int(&r->y, 0);\n-    secp256k1_fe_set_int(&r->z, 0);\n+    secp256k1_fe_clear(&r->x);\n+    secp256k1_fe_clear(&r->y);\n+    secp256k1_fe_clear(&r->z);\n+}\n+\n+static void secp256k1_ge_set_infinity(secp256k1_ge *r) {\n+    r->infinity = 1;\n+    secp256k1_fe_clear(&r->x);\n+    secp256k1_fe_clear(&r->y);\n }\n \n static void secp256k1_gej_clear(secp256k1_gej *r) {\n@@ -165,19 +219,19 @@ static void secp256k1_ge_clear(secp256k1_ge *r) {\n     secp256k1_fe_clear(&r->y);\n }\n \n-static int secp256k1_ge_set_xquad_var(secp256k1_ge *r, const secp256k1_fe *x) {\n+static int secp256k1_ge_set_xquad(secp256k1_ge *r, const secp256k1_fe *x) {\n     secp256k1_fe x2, x3, c;\n     r->x = *x;\n     secp256k1_fe_sqr(&x2, x);\n     secp256k1_fe_mul(&x3, x, &x2);\n     r->infinity = 0;\n-    secp256k1_fe_set_int(&c, 7);\n+    secp256k1_fe_set_int(&c, CURVE_B);\n     secp256k1_fe_add(&c, &x3);\n-    return secp256k1_fe_sqrt_var(&r->y, &c);\n+    return secp256k1_fe_sqrt(&r->y, &c);\n }\n \n static int secp256k1_ge_set_xo_var(secp256k1_ge *r, const secp256k1_fe *x, int odd) {\n-    if (!secp256k1_ge_set_xquad_var(r, x)) {\n+    if (!secp256k1_ge_set_xquad(r, x)) {\n         return 0;\n     }\n     secp256k1_fe_normalize_var(&r->y);\n@@ -230,7 +284,7 @@ static int secp256k1_gej_is_valid_var(const secp256k1_gej *a) {\n     secp256k1_fe_sqr(&x3, &a->x); secp256k1_fe_mul(&x3, &x3, &a->x);\n     secp256k1_fe_sqr(&z2, &a->z);\n     secp256k1_fe_sqr(&z6, &z2); secp256k1_fe_mul(&z6, &z6, &z2);\n-    secp256k1_fe_mul_int(&z6, 7);\n+    secp256k1_fe_mul_int(&z6, CURVE_B);\n     secp256k1_fe_add(&x3, &z6);\n     secp256k1_fe_normalize_weak(&x3);\n     return secp256k1_fe_equal_var(&y2, &x3);\n@@ -244,18 +298,30 @@ static int secp256k1_ge_is_valid_var(const secp256k1_ge *a) {\n     /* y^2 = x^3 + 7 */\n     secp256k1_fe_sqr(&y2, &a->y);\n     secp256k1_fe_sqr(&x3, &a->x); secp256k1_fe_mul(&x3, &x3, &a->x);\n-    secp256k1_fe_set_int(&c, 7);\n+    secp256k1_fe_set_int(&c, CURVE_B);\n     secp256k1_fe_add(&x3, &c);\n     secp256k1_fe_normalize_weak(&x3);\n     return secp256k1_fe_equal_var(&y2, &x3);\n }\n \n static void secp256k1_gej_double_var(secp256k1_gej *r, const secp256k1_gej *a, secp256k1_fe *rzr) {\n-    /* Operations: 3 mul, 4 sqr, 0 normalize, 12 mul_int/add/negate */\n+    /* Operations: 3 mul, 4 sqr, 0 normalize, 12 mul_int/add/negate.\n+     *\n+     * Note that there is an implementation described at\n+     *     https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-dbl-2009-l\n+     * which trades a multiply for a square, but in practice this is actually slower,\n+     * mainly because it requires more normalizations.\n+     */\n     secp256k1_fe t1,t2,t3,t4;\n     /** For secp256k1, 2Q is infinity if and only if Q is infinity. This is because if 2Q = infinity,\n      *  Q must equal -Q, or that Q.y == -(Q.y), or Q.y is 0. For a point on y^2 = x^3 + 7 to have\n      *  y=0, x^3 must be -7 mod p. However, -7 has no cube root mod p.\n+     *\n+     *  Having said this, if this function receives a point on a sextic twist, e.g. by\n+     *  a fault attack, it is possible for y to be 0. This happens for y^2 = x^3 + 6,\n+     *  since -6 does have a cube root mod p. For this point, this function will not set\n+     *  the infinity flag even though the point doubles to infinity, and the result\n+     *  point will be gibberish (z = 0 but infinity = 0).\n      */\n     r->infinity = a->infinity;\n     if (r->infinity) {\n@@ -623,4 +689,18 @@ static void secp256k1_ge_mul_lambda(secp256k1_ge *r, const secp256k1_ge *a) {\n }\n #endif\n \n+static int secp256k1_gej_has_quad_y_var(const secp256k1_gej *a) {\n+    secp256k1_fe yz;\n+\n+    if (a->infinity) {\n+        return 0;\n+    }\n+\n+    /* We rely on the fact that the Jacobi symbol of 1 / a->z^3 is the same as\n+     * that of a->z. Thus a->y / a->z^3 is a quadratic residue iff a->y * a->z\n+       is */\n+    secp256k1_fe_mul(&yz, &a->y, &a->z);\n+    return secp256k1_fe_is_quad_var(&yz);\n+}\n+\n #endif"
      },
      {
        "sha": "fca98cab9f8315bd4fa5c165d9f8e2f16dc2a493",
        "filename": "src/secp256k1/src/hash.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/hash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/hash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/hash.h?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -11,7 +11,7 @@\n #include <stdint.h>\n \n typedef struct {\n-    uint32_t s[32];\n+    uint32_t s[8];\n     uint32_t buf[16]; /* In big endian */\n     size_t bytes;\n } secp256k1_sha256_t;"
      },
      {
        "sha": "b47e65f830a906fc0eb9ff7939d62966823202b1",
        "filename": "src/secp256k1/src/hash_impl.h",
        "status": "modified",
        "additions": 4,
        "deletions": 6,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/hash_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/hash_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/hash_impl.h?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -269,15 +269,13 @@ static void secp256k1_rfc6979_hmac_sha256_finalize(secp256k1_rfc6979_hmac_sha256\n     rng->retry = 0;\n }\n \n-\n+#undef BE32\n #undef Round\n-#undef sigma0\n #undef sigma1\n-#undef Sigma0\n+#undef sigma0\n #undef Sigma1\n-#undef Ch\n+#undef Sigma0\n #undef Maj\n-#undef ReadBE32\n-#undef WriteBE32\n+#undef Ch\n \n #endif"
      },
      {
        "sha": "1c67802fba82e60498c560473e9966c161939ffb",
        "filename": "src/secp256k1/src/java/org/bitcoin/NativeSecp256k1.java",
        "status": "modified",
        "additions": 413,
        "deletions": 27,
        "changes": 440,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1.java?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -1,60 +1,446 @@\n+/*\n+ * Copyright 2013 Google Inc.\n+ * Copyright 2014-2016 the libsecp256k1 contributors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n package org.bitcoin;\n \n import java.nio.ByteBuffer;\n import java.nio.ByteOrder;\n \n+import java.math.BigInteger;\n import com.google.common.base.Preconditions;\n-\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import static org.bitcoin.NativeSecp256k1Util.*;\n \n /**\n- * This class holds native methods to handle ECDSA verification.\n- * You can find an example library that can be used for this at\n- * https://github.com/sipa/secp256k1\n+ * <p>This class holds native methods to handle ECDSA verification.</p>\n+ *\n+ * <p>You can find an example library that can be used for this at https://github.com/bitcoin/secp256k1</p>\n+ *\n+ * <p>To build secp256k1 for use with bitcoinj, run\n+ * `./configure --enable-jni --enable-experimental --enable-module-ecdh`\n+ * and `make` then copy `.libs/libsecp256k1.so` to your system library path\n+ * or point the JVM to the folder containing it with -Djava.library.path\n+ * </p>\n  */\n public class NativeSecp256k1 {\n-    public static final boolean enabled;\n-    static {\n-        boolean isEnabled = true;\n-        try {\n-            System.loadLibrary(\"javasecp256k1\");\n-        } catch (UnsatisfiedLinkError e) {\n-            isEnabled = false;\n-        }\n-        enabled = isEnabled;\n-    }\n-    \n+\n+    private static final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n+    private static final Lock r = rwl.readLock();\n+    private static final Lock w = rwl.writeLock();\n     private static ThreadLocal<ByteBuffer> nativeECDSABuffer = new ThreadLocal<ByteBuffer>();\n     /**\n      * Verifies the given secp256k1 signature in native code.\n      * Calling when enabled == false is undefined (probably library not loaded)\n-     * \n+     *\n      * @param data The data which was signed, must be exactly 32 bytes\n      * @param signature The signature\n      * @param pub The public key which did the signing\n      */\n-    public static boolean verify(byte[] data, byte[] signature, byte[] pub) {\n+    public static boolean verify(byte[] data, byte[] signature, byte[] pub) throws AssertFailException{\n         Preconditions.checkArgument(data.length == 32 && signature.length <= 520 && pub.length <= 520);\n \n         ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null) {\n-            byteBuff = ByteBuffer.allocateDirect(32 + 8 + 520 + 520);\n+        if (byteBuff == null || byteBuff.capacity() < 520) {\n+            byteBuff = ByteBuffer.allocateDirect(520);\n             byteBuff.order(ByteOrder.nativeOrder());\n             nativeECDSABuffer.set(byteBuff);\n         }\n         byteBuff.rewind();\n         byteBuff.put(data);\n-        byteBuff.putInt(signature.length);\n-        byteBuff.putInt(pub.length);\n         byteBuff.put(signature);\n         byteBuff.put(pub);\n-        return secp256k1_ecdsa_verify(byteBuff) == 1;\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          return secp256k1_ecdsa_verify(byteBuff, Secp256k1Context.getContext(), signature.length, pub.length) == 1;\n+        } finally {\n+          r.unlock();\n+        }\n+    }\n+\n+    /**\n+     * libsecp256k1 Create an ECDSA signature.\n+     *\n+     * @param data Message hash, 32 bytes\n+     * @param key Secret key, 32 bytes\n+     *\n+     * Return values\n+     * @param sig byte array of signature\n+     */\n+    public static byte[] sign(byte[] data, byte[] sec) throws AssertFailException{\n+        Preconditions.checkArgument(data.length == 32 && sec.length <= 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < 32 + 32) {\n+            byteBuff = ByteBuffer.allocateDirect(32 + 32);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(data);\n+        byteBuff.put(sec);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ecdsa_sign(byteBuff, Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] sigArr = retByteArray[0];\n+        int sigLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(sigArr.length, sigLen, \"Got bad signature length.\");\n+\n+        return retVal == 0 ? new byte[0] : sigArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Seckey Verify - returns 1 if valid, 0 if invalid\n+     *\n+     * @param seckey ECDSA Secret key, 32 bytes\n+     */\n+    public static boolean secKeyVerify(byte[] seckey) {\n+        Preconditions.checkArgument(seckey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+\n+        r.lock();\n+        try {\n+          return secp256k1_ec_seckey_verify(byteBuff,Secp256k1Context.getContext()) == 1;\n+        } finally {\n+          r.unlock();\n+        }\n+    }\n+\n+\n+    /**\n+     * libsecp256k1 Compute Pubkey - computes public key from secret key\n+     *\n+     * @param seckey ECDSA Secret key, 32 bytes\n+     *\n+     * Return values\n+     * @param pubkey ECDSA Public key, 33 or 65 bytes\n+     */\n+    //TODO add a 'compressed' arg\n+    public static byte[] computePubkey(byte[] seckey) throws AssertFailException{\n+        Preconditions.checkArgument(seckey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+\n+        byte[][] retByteArray;\n+\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ec_pubkey_create(byteBuff, Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] pubArr = retByteArray[0];\n+        int pubLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n+\n+        return retVal == 0 ? new byte[0]: pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 Cleanup - This destroys the secp256k1 context object\n+     * This should be called at the end of the program for proper cleanup of the context.\n+     */\n+    public static synchronized void cleanup() {\n+        w.lock();\n+        try {\n+          secp256k1_destroy_context(Secp256k1Context.getContext());\n+        } finally {\n+          w.unlock();\n+        }\n+    }\n+\n+    public static long cloneContext() {\n+       r.lock();\n+       try {\n+        return secp256k1_ctx_clone(Secp256k1Context.getContext());\n+       } finally { r.unlock(); }\n+    }\n+\n+    /**\n+     * libsecp256k1 PrivKey Tweak-Mul - Tweak privkey by multiplying to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param seckey 32-byte seckey\n+     */\n+    public static byte[] privKeyTweakMul(byte[] privkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(privkey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < privkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(privkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(privkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_privkey_tweak_mul(byteBuff,Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, privLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 PrivKey Tweak-Add - Tweak privkey by adding to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param seckey 32-byte seckey\n+     */\n+    public static byte[] privKeyTweakAdd(byte[] privkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(privkey.length == 32);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < privkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(privkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(privkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_privkey_tweak_add(byteBuff,Secp256k1Context.getContext());\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] privArr = retByteArray[0];\n+\n+        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(privArr.length, privLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return privArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 PubKey Tweak-Add - Tweak pubkey by adding to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param pubkey 32-byte seckey\n+     */\n+    public static byte[] pubKeyTweakAdd(byte[] pubkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(pubkey.length == 33 || pubkey.length == 65);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < pubkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(pubkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(pubkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_pubkey_tweak_add(byteBuff,Secp256k1Context.getContext(), pubkey.length);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] pubArr = retByteArray[0];\n+\n+        int pubLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return pubArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 PubKey Tweak-Mul - Tweak pubkey by multiplying to it\n+     *\n+     * @param tweak some bytes to tweak with\n+     * @param pubkey 32-byte seckey\n+     */\n+    public static byte[] pubKeyTweakMul(byte[] pubkey, byte[] tweak) throws AssertFailException{\n+        Preconditions.checkArgument(pubkey.length == 33 || pubkey.length == 65);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < pubkey.length + tweak.length) {\n+            byteBuff = ByteBuffer.allocateDirect(pubkey.length + tweak.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(pubkey);\n+        byteBuff.put(tweak);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_pubkey_tweak_mul(byteBuff,Secp256k1Context.getContext(), pubkey.length);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] pubArr = retByteArray[0];\n+\n+        int pubLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n+\n+        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n+\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return pubArr;\n     }\n \n     /**\n-     * @param byteBuff signature format is byte[32] data,\n-     *        native-endian int signatureLength, native-endian int pubkeyLength,\n-     *        byte[signatureLength] signature, byte[pubkeyLength] pub\n-     * @returns 1 for valid signature, anything else for invalid\n+     * libsecp256k1 create ECDH secret - constant time ECDH calculation\n+     *\n+     * @param seckey byte array of secret key used in exponentiaion\n+     * @param pubkey byte array of public key used in exponentiaion\n      */\n-    private static native int secp256k1_ecdsa_verify(ByteBuffer byteBuff);\n+    public static byte[] createECDHSecret(byte[] seckey, byte[] pubkey) throws AssertFailException{\n+        Preconditions.checkArgument(seckey.length <= 32 && pubkey.length <= 65);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < 32 + pubkey.length) {\n+            byteBuff = ByteBuffer.allocateDirect(32 + pubkey.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seckey);\n+        byteBuff.put(pubkey);\n+\n+        byte[][] retByteArray;\n+        r.lock();\n+        try {\n+          retByteArray = secp256k1_ecdh(byteBuff, Secp256k1Context.getContext(), pubkey.length);\n+        } finally {\n+          r.unlock();\n+        }\n+\n+        byte[] resArr = retByteArray[0];\n+        int retVal = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n+\n+        assertEquals(resArr.length, 32, \"Got bad result length.\");\n+        assertEquals(retVal, 1, \"Failed return value check.\");\n+\n+        return resArr;\n+    }\n+\n+    /**\n+     * libsecp256k1 randomize - updates the context randomization\n+     *\n+     * @param seed 32-byte random seed\n+     */\n+    public static synchronized boolean randomize(byte[] seed) throws AssertFailException{\n+        Preconditions.checkArgument(seed.length == 32 || seed == null);\n+\n+        ByteBuffer byteBuff = nativeECDSABuffer.get();\n+        if (byteBuff == null || byteBuff.capacity() < seed.length) {\n+            byteBuff = ByteBuffer.allocateDirect(seed.length);\n+            byteBuff.order(ByteOrder.nativeOrder());\n+            nativeECDSABuffer.set(byteBuff);\n+        }\n+        byteBuff.rewind();\n+        byteBuff.put(seed);\n+\n+        w.lock();\n+        try {\n+          return secp256k1_context_randomize(byteBuff, Secp256k1Context.getContext()) == 1;\n+        } finally {\n+          w.unlock();\n+        }\n+    }\n+\n+    private static native long secp256k1_ctx_clone(long context);\n+\n+    private static native int secp256k1_context_randomize(ByteBuffer byteBuff, long context);\n+\n+    private static native byte[][] secp256k1_privkey_tweak_add(ByteBuffer byteBuff, long context);\n+\n+    private static native byte[][] secp256k1_privkey_tweak_mul(ByteBuffer byteBuff, long context);\n+\n+    private static native byte[][] secp256k1_pubkey_tweak_add(ByteBuffer byteBuff, long context, int pubLen);\n+\n+    private static native byte[][] secp256k1_pubkey_tweak_mul(ByteBuffer byteBuff, long context, int pubLen);\n+\n+    private static native void secp256k1_destroy_context(long context);\n+\n+    private static native int secp256k1_ecdsa_verify(ByteBuffer byteBuff, long context, int sigLen, int pubLen);\n+\n+    private static native byte[][] secp256k1_ecdsa_sign(ByteBuffer byteBuff, long context);\n+\n+    private static native int secp256k1_ec_seckey_verify(ByteBuffer byteBuff, long context);\n+\n+    private static native byte[][] secp256k1_ec_pubkey_create(ByteBuffer byteBuff, long context);\n+\n+    private static native byte[][] secp256k1_ec_pubkey_parse(ByteBuffer byteBuff, long context, int inputLen);\n+\n+    private static native byte[][] secp256k1_ecdh(ByteBuffer byteBuff, long context, int inputLen);\n+\n }"
      },
      {
        "sha": "c00d08899b9b004af75a4e98569c460ad83395a1",
        "filename": "src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "status": "added",
        "additions": 226,
        "deletions": 0,
        "changes": 226,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Test.java?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -0,0 +1,226 @@\n+package org.bitcoin;\n+\n+import com.google.common.io.BaseEncoding;\n+import java.util.Arrays;\n+import java.math.BigInteger;\n+import javax.xml.bind.DatatypeConverter;\n+import static org.bitcoin.NativeSecp256k1Util.*;\n+\n+/**\n+ * This class holds test cases defined for testing this library.\n+ */\n+public class NativeSecp256k1Test {\n+\n+    //TODO improve comments/add more tests\n+    /**\n+      * This tests verify() for a valid signature\n+      */\n+    public static void testVerifyPos() throws AssertFailException{\n+        boolean result = false;\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"CF80CD8AED482D5D1527D7DC72FCEFF84E6326592848447D2DC0B0E87DFC9A90\".toLowerCase()); //sha256hash of \"testing\"\n+        byte[] sig = BaseEncoding.base16().lowerCase().decode(\"3044022079BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F817980220294F14E883B3F525B5367756C2A11EF6CF84B730B36C17CB0C56F0AAB2C98589\".toLowerCase());\n+        byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n+\n+        result = NativeSecp256k1.verify( data, sig, pub);\n+        assertEquals( result, true , \"testVerifyPos\");\n+    }\n+\n+    /**\n+      * This tests verify() for a non-valid signature\n+      */\n+    public static void testVerifyNeg() throws AssertFailException{\n+        boolean result = false;\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"CF80CD8AED482D5D1527D7DC72FCEFF84E6326592848447D2DC0B0E87DFC9A91\".toLowerCase()); //sha256hash of \"testing\"\n+        byte[] sig = BaseEncoding.base16().lowerCase().decode(\"3044022079BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F817980220294F14E883B3F525B5367756C2A11EF6CF84B730B36C17CB0C56F0AAB2C98589\".toLowerCase());\n+        byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n+\n+        result = NativeSecp256k1.verify( data, sig, pub);\n+        //System.out.println(\" TEST \" + new BigInteger(1, resultbytes).toString(16));\n+        assertEquals( result, false , \"testVerifyNeg\");\n+    }\n+\n+    /**\n+      * This tests secret key verify() for a valid secretkey\n+      */\n+    public static void testSecKeyVerifyPos() throws AssertFailException{\n+        boolean result = false;\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n+\n+        result = NativeSecp256k1.secKeyVerify( sec );\n+        //System.out.println(\" TEST \" + new BigInteger(1, resultbytes).toString(16));\n+        assertEquals( result, true , \"testSecKeyVerifyPos\");\n+    }\n+\n+    /**\n+      * This tests secret key verify() for a invalid secretkey\n+      */\n+    public static void testSecKeyVerifyNeg() throws AssertFailException{\n+        boolean result = false;\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\".toLowerCase());\n+\n+        result = NativeSecp256k1.secKeyVerify( sec );\n+        //System.out.println(\" TEST \" + new BigInteger(1, resultbytes).toString(16));\n+        assertEquals( result, false , \"testSecKeyVerifyNeg\");\n+    }\n+\n+    /**\n+      * This tests public key create() for a valid secretkey\n+      */\n+    public static void testPubKeyCreatePos() throws AssertFailException{\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n+\n+        byte[] resultArr = NativeSecp256k1.computePubkey( sec);\n+        String pubkeyString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( pubkeyString , \"04C591A8FF19AC9C4E4E5793673B83123437E975285E7B442F4EE2654DFFCA5E2D2103ED494718C697AC9AEBCFD19612E224DB46661011863ED2FC54E71861E2A6\" , \"testPubKeyCreatePos\");\n+    }\n+\n+    /**\n+      * This tests public key create() for a invalid secretkey\n+      */\n+    public static void testPubKeyCreateNeg() throws AssertFailException{\n+       byte[] sec = BaseEncoding.base16().lowerCase().decode(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\".toLowerCase());\n+\n+       byte[] resultArr = NativeSecp256k1.computePubkey( sec);\n+       String pubkeyString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+       assertEquals( pubkeyString, \"\" , \"testPubKeyCreateNeg\");\n+    }\n+\n+    /**\n+      * This tests sign() for a valid secretkey\n+      */\n+    public static void testSignPos() throws AssertFailException{\n+\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"CF80CD8AED482D5D1527D7DC72FCEFF84E6326592848447D2DC0B0E87DFC9A90\".toLowerCase()); //sha256hash of \"testing\"\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n+\n+        byte[] resultArr = NativeSecp256k1.sign(data, sec);\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( sigString, \"30440220182A108E1448DC8F1FB467D06A0F3BB8EA0533584CB954EF8DA112F1D60E39A202201C66F36DA211C087F3AF88B50EDF4F9BDAA6CF5FD6817E74DCA34DB12390C6E9\" , \"testSignPos\");\n+    }\n+\n+    /**\n+      * This tests sign() for a invalid secretkey\n+      */\n+    public static void testSignNeg() throws AssertFailException{\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"CF80CD8AED482D5D1527D7DC72FCEFF84E6326592848447D2DC0B0E87DFC9A90\".toLowerCase()); //sha256hash of \"testing\"\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\".toLowerCase());\n+\n+        byte[] resultArr = NativeSecp256k1.sign(data, sec);\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( sigString, \"\" , \"testSignNeg\");\n+    }\n+\n+    /**\n+      * This tests private key tweak-add\n+      */\n+    public static void testPrivKeyTweakAdd_1() throws AssertFailException {\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n+\n+        byte[] resultArr = NativeSecp256k1.privKeyTweakAdd( sec , data );\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( sigString , \"A168571E189E6F9A7E2D657A4B53AE99B909F7E712D1C23CED28093CD57C88F3\" , \"testPrivKeyAdd_1\");\n+    }\n+\n+    /**\n+      * This tests private key tweak-mul\n+      */\n+    public static void testPrivKeyTweakMul_1() throws AssertFailException {\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n+\n+        byte[] resultArr = NativeSecp256k1.privKeyTweakMul( sec , data );\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( sigString , \"97F8184235F101550F3C71C927507651BD3F1CDB4A5A33B8986ACF0DEE20FFFC\" , \"testPrivKeyMul_1\");\n+    }\n+\n+    /**\n+      * This tests private key tweak-add uncompressed\n+      */\n+    public static void testPrivKeyTweakAdd_2() throws AssertFailException {\n+        byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n+\n+        byte[] resultArr = NativeSecp256k1.pubKeyTweakAdd( pub , data );\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( sigString , \"0411C6790F4B663CCE607BAAE08C43557EDC1A4D11D88DFCB3D841D0C6A941AF525A268E2A863C148555C48FB5FBA368E88718A46E205FABC3DBA2CCFFAB0796EF\" , \"testPrivKeyAdd_2\");\n+    }\n+\n+    /**\n+      * This tests private key tweak-mul uncompressed\n+      */\n+    public static void testPrivKeyTweakMul_2() throws AssertFailException {\n+        byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n+        byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n+\n+        byte[] resultArr = NativeSecp256k1.pubKeyTweakMul( pub , data );\n+        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( sigString , \"04E0FE6FE55EBCA626B98A807F6CAF654139E14E5E3698F01A9A658E21DC1D2791EC060D4F412A794D5370F672BC94B722640B5F76914151CFCA6E712CA48CC589\" , \"testPrivKeyMul_2\");\n+    }\n+\n+    /**\n+      * This tests seed randomization\n+      */\n+    public static void testRandomize() throws AssertFailException {\n+        byte[] seed = BaseEncoding.base16().lowerCase().decode(\"A441B15FE9A3CF56661190A0B93B9DEC7D04127288CC87250967CF3B52894D11\".toLowerCase()); //sha256hash of \"random\"\n+        boolean result = NativeSecp256k1.randomize(seed);\n+        assertEquals( result, true, \"testRandomize\");\n+    }\n+\n+    public static void testCreateECDHSecret() throws AssertFailException{\n+\n+        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n+        byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n+\n+        byte[] resultArr = NativeSecp256k1.createECDHSecret(sec, pub);\n+        String ecdhString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        assertEquals( ecdhString, \"2A2A67007A926E6594AF3EB564FC74005B37A9C8AEF2033C4552051B5C87F043\" , \"testCreateECDHSecret\");\n+    }\n+\n+    public static void main(String[] args) throws AssertFailException{\n+\n+\n+        System.out.println(\"\\n libsecp256k1 enabled: \" + Secp256k1Context.isEnabled() + \"\\n\");\n+\n+        assertEquals( Secp256k1Context.isEnabled(), true, \"isEnabled\" );\n+\n+        //Test verify() success/fail\n+        testVerifyPos();\n+        testVerifyNeg();\n+\n+        //Test secKeyVerify() success/fail\n+        testSecKeyVerifyPos();\n+        testSecKeyVerifyNeg();\n+\n+        //Test computePubkey() success/fail\n+        testPubKeyCreatePos();\n+        testPubKeyCreateNeg();\n+\n+        //Test sign() success/fail\n+        testSignPos();\n+        testSignNeg();\n+\n+        //Test privKeyTweakAdd() 1\n+        testPrivKeyTweakAdd_1();\n+\n+        //Test privKeyTweakMul() 2\n+        testPrivKeyTweakMul_1();\n+\n+        //Test privKeyTweakAdd() 3\n+        testPrivKeyTweakAdd_2();\n+\n+        //Test privKeyTweakMul() 4\n+        testPrivKeyTweakMul_2();\n+\n+        //Test randomize()\n+        testRandomize();\n+\n+        //Test ECDH\n+        testCreateECDHSecret();\n+\n+        NativeSecp256k1.cleanup();\n+\n+        System.out.println(\" All tests passed.\" );\n+\n+    }\n+}"
      },
      {
        "sha": "04732ba044363a5dc5c525661a090c1bdf1d077f",
        "filename": "src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Util.java",
        "status": "added",
        "additions": 45,
        "deletions": 0,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Util.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Util.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Util.java?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2014-2016 the libsecp256k1 contributors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.bitcoin;\n+\n+public class NativeSecp256k1Util{\n+\n+    public static void assertEquals( int val, int val2, String message ) throws AssertFailException{\n+      if( val != val2 )\n+        throw new AssertFailException(\"FAIL: \" + message);\n+    }\n+\n+    public static void assertEquals( boolean val, boolean val2, String message ) throws AssertFailException{\n+      if( val != val2 )\n+        throw new AssertFailException(\"FAIL: \" + message);\n+      else\n+        System.out.println(\"PASS: \" + message);\n+    }\n+\n+    public static void assertEquals( String val, String val2, String message ) throws AssertFailException{\n+      if( !val.equals(val2) )\n+        throw new AssertFailException(\"FAIL: \" + message);\n+      else\n+        System.out.println(\"PASS: \" + message);\n+    }\n+\n+    public static class AssertFailException extends Exception {\n+      public AssertFailException(String message) {\n+        super( message );\n+      }\n+    }\n+}"
      },
      {
        "sha": "216c986a8b564d49b01243d513bdd182339e51b6",
        "filename": "src/secp256k1/src/java/org/bitcoin/Secp256k1Context.java",
        "status": "added",
        "additions": 51,
        "deletions": 0,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/java/org/bitcoin/Secp256k1Context.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/java/org/bitcoin/Secp256k1Context.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org/bitcoin/Secp256k1Context.java?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2014-2016 the libsecp256k1 contributors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.bitcoin;\n+\n+/**\n+ * This class holds the context reference used in native methods \n+ * to handle ECDSA operations.\n+ */\n+public class Secp256k1Context {\n+  private static final boolean enabled; //true if the library is loaded\n+  private static final long context; //ref to pointer to context obj\n+\n+  static { //static initializer\n+      boolean isEnabled = true;\n+      long contextRef = -1;\n+      try {\n+          System.loadLibrary(\"secp256k1\");\n+          contextRef = secp256k1_init_context();\n+      } catch (UnsatisfiedLinkError e) {\n+          System.out.println(\"UnsatisfiedLinkError: \" + e.toString());\n+          isEnabled = false;\n+      }\n+      enabled = isEnabled;\n+      context = contextRef;\n+  }\n+\n+  public static boolean isEnabled() {\n+     return enabled;\n+  }\n+\n+  public static long getContext() {\n+     if(!enabled) return -1; //sanity check\n+     return context;\n+  }\n+\n+  private static native long secp256k1_init_context();\n+}"
      },
      {
        "sha": "bcef7b32ce3e7fe1587f15dac2e7c56fef998a8a",
        "filename": "src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c",
        "status": "modified",
        "additions": 366,
        "deletions": 12,
        "changes": 378,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -1,23 +1,377 @@\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include <string.h>\n #include \"org_bitcoin_NativeSecp256k1.h\"\n #include \"include/secp256k1.h\"\n+#include \"include/secp256k1_ecdh.h\"\n+#include \"include/secp256k1_recovery.h\"\n \n-JNIEXPORT jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1verify\n-  (JNIEnv* env, jclass classObject, jobject byteBufferObject)\n+\n+SECP256K1_API jlong JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ctx_1clone\n+  (JNIEnv* env, jclass classObject, jlong ctx_l)\n+{\n+  const secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+\n+  jlong ctx_clone_l = (uintptr_t) secp256k1_context_clone(ctx);\n+\n+  (void)classObject;(void)env;\n+\n+  return ctx_clone_l;\n+\n+}\n+\n+SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1context_1randomize\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n {\n-\tunsigned char* data = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n-\tint sigLen = *((int*)(data + 32));\n-\tint pubLen = *((int*)(data + 32 + 4));\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+\n+  const unsigned char* seed = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+\n+  (void)classObject;\n+\n+  return secp256k1_context_randomize(ctx, seed);\n \n-\treturn secp256k1_ecdsa_verify(data, 32, data+32+8, sigLen, data+32+8+sigLen, pubLen);\n }\n \n-static void __javasecp256k1_attach(void) __attribute__((constructor));\n-static void __javasecp256k1_detach(void) __attribute__((destructor));\n+SECP256K1_API void JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1destroy_1context\n+  (JNIEnv* env, jclass classObject, jlong ctx_l)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+\n+  secp256k1_context_destroy(ctx);\n \n-static void __javasecp256k1_attach(void) {\n-\tsecp256k1_start(SECP256K1_START_VERIFY);\n+  (void)classObject;(void)env;\n }\n \n-static void __javasecp256k1_detach(void) {\n-\tsecp256k1_stop();\n+SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1verify\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint siglen, jint publen)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+\n+  unsigned char* data = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  const unsigned char* sigdata = {  (unsigned char*) (data + 32) };\n+  const unsigned char* pubdata = { (unsigned char*) (data + siglen + 32) };\n+\n+  secp256k1_ecdsa_signature sig;\n+  secp256k1_pubkey pubkey;\n+\n+  int ret = secp256k1_ecdsa_signature_parse_der(ctx, &sig, sigdata, siglen);\n+\n+  if( ret ) {\n+    ret = secp256k1_ec_pubkey_parse(ctx, &pubkey, pubdata, publen);\n+\n+    if( ret ) {\n+      ret = secp256k1_ecdsa_verify(ctx, &sig, data, &pubkey);\n+    }\n+  }\n+\n+  (void)classObject;\n+\n+  return ret;\n+}\n+\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1sign\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  unsigned char* data = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  unsigned char* secKey = (unsigned char*) (data + 32);\n+\n+  jobjectArray retArray;\n+  jbyteArray sigArray, intsByteArray;\n+  unsigned char intsarray[2];\n+\n+  secp256k1_ecdsa_signature sig[72];\n+\n+  int ret = secp256k1_ecdsa_sign(ctx, sig, data, secKey, NULL, NULL );\n+\n+  unsigned char outputSer[72];\n+  size_t outputLen = 72;\n+\n+  if( ret ) {\n+    int ret2 = secp256k1_ecdsa_signature_serialize_der(ctx,outputSer, &outputLen, sig ); (void)ret2;\n+  }\n+\n+  intsarray[0] = outputLen;\n+  intsarray[1] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  sigArray = (*env)->NewByteArray(env, outputLen);\n+  (*env)->SetByteArrayRegion(env, sigArray, 0, outputLen, (jbyte*)outputSer);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, sigArray);\n+\n+  intsByteArray = (*env)->NewByteArray(env, 2);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n+}\n+\n+SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1seckey_1verify\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  unsigned char* secKey = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+\n+  (void)classObject;\n+\n+  return secp256k1_ec_seckey_verify(ctx, secKey);\n+}\n+\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1pubkey_1create\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  const unsigned char* secKey = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+\n+  secp256k1_pubkey pubkey;\n+\n+  jobjectArray retArray;\n+  jbyteArray pubkeyArray, intsByteArray;\n+  unsigned char intsarray[2];\n+\n+  int ret = secp256k1_ec_pubkey_create(ctx, &pubkey, secKey);\n+\n+  unsigned char outputSer[65];\n+  size_t outputLen = 65;\n+\n+  if( ret ) {\n+    int ret2 = secp256k1_ec_pubkey_serialize(ctx,outputSer, &outputLen, &pubkey,SECP256K1_EC_UNCOMPRESSED );(void)ret2;\n+  }\n+\n+  intsarray[0] = outputLen;\n+  intsarray[1] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  pubkeyArray = (*env)->NewByteArray(env, outputLen);\n+  (*env)->SetByteArrayRegion(env, pubkeyArray, 0, outputLen, (jbyte*)outputSer);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, pubkeyArray);\n+\n+  intsByteArray = (*env)->NewByteArray(env, 2);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n+\n+}\n+\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1privkey_1tweak_1add\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  unsigned char* privkey = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  const unsigned char* tweak = (unsigned char*) (privkey + 32);\n+\n+  jobjectArray retArray;\n+  jbyteArray privArray, intsByteArray;\n+  unsigned char intsarray[2];\n+\n+  int privkeylen = 32;\n+\n+  int ret = secp256k1_ec_privkey_tweak_add(ctx, privkey, tweak);\n+\n+  intsarray[0] = privkeylen;\n+  intsarray[1] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  privArray = (*env)->NewByteArray(env, privkeylen);\n+  (*env)->SetByteArrayRegion(env, privArray, 0, privkeylen, (jbyte*)privkey);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, privArray);\n+\n+  intsByteArray = (*env)->NewByteArray(env, 2);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n+}\n+\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1privkey_1tweak_1mul\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  unsigned char* privkey = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  const unsigned char* tweak = (unsigned char*) (privkey + 32);\n+\n+  jobjectArray retArray;\n+  jbyteArray privArray, intsByteArray;\n+  unsigned char intsarray[2];\n+\n+  int privkeylen = 32;\n+\n+  int ret = secp256k1_ec_privkey_tweak_mul(ctx, privkey, tweak);\n+\n+  intsarray[0] = privkeylen;\n+  intsarray[1] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  privArray = (*env)->NewByteArray(env, privkeylen);\n+  (*env)->SetByteArrayRegion(env, privArray, 0, privkeylen, (jbyte*)privkey);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, privArray);\n+\n+  intsByteArray = (*env)->NewByteArray(env, 2);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n+}\n+\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1pubkey_1tweak_1add\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint publen)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+/*  secp256k1_pubkey* pubkey = (secp256k1_pubkey*) (*env)->GetDirectBufferAddress(env, byteBufferObject);*/\n+  unsigned char* pkey = (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  const unsigned char* tweak = (unsigned char*) (pkey + publen);\n+\n+  jobjectArray retArray;\n+  jbyteArray pubArray, intsByteArray;\n+  unsigned char intsarray[2];\n+  unsigned char outputSer[65];\n+  size_t outputLen = 65;\n+\n+  secp256k1_pubkey pubkey;\n+  int ret = secp256k1_ec_pubkey_parse(ctx, &pubkey, pkey, publen);\n+\n+  if( ret ) {\n+    ret = secp256k1_ec_pubkey_tweak_add(ctx, &pubkey, tweak);\n+  }\n+\n+  if( ret ) {\n+    int ret2 = secp256k1_ec_pubkey_serialize(ctx,outputSer, &outputLen, &pubkey,SECP256K1_EC_UNCOMPRESSED );(void)ret2;\n+  }\n+\n+  intsarray[0] = outputLen;\n+  intsarray[1] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  pubArray = (*env)->NewByteArray(env, outputLen);\n+  (*env)->SetByteArrayRegion(env, pubArray, 0, outputLen, (jbyte*)outputSer);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, pubArray);\n+\n+  intsByteArray = (*env)->NewByteArray(env, 2);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n+}\n+\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1pubkey_1tweak_1mul\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint publen)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  unsigned char* pkey = (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  const unsigned char* tweak = (unsigned char*) (pkey + publen);\n+\n+  jobjectArray retArray;\n+  jbyteArray pubArray, intsByteArray;\n+  unsigned char intsarray[2];\n+  unsigned char outputSer[65];\n+  size_t outputLen = 65;\n+\n+  secp256k1_pubkey pubkey;\n+  int ret = secp256k1_ec_pubkey_parse(ctx, &pubkey, pkey, publen);\n+\n+  if ( ret ) {\n+    ret = secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, tweak);\n+  }\n+\n+  if( ret ) {\n+    int ret2 = secp256k1_ec_pubkey_serialize(ctx,outputSer, &outputLen, &pubkey,SECP256K1_EC_UNCOMPRESSED );(void)ret2;\n+  }\n+\n+  intsarray[0] = outputLen;\n+  intsarray[1] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  pubArray = (*env)->NewByteArray(env, outputLen);\n+  (*env)->SetByteArrayRegion(env, pubArray, 0, outputLen, (jbyte*)outputSer);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, pubArray);\n+\n+  intsByteArray = (*env)->NewByteArray(env, 2);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n+}\n+\n+SECP256K1_API jlong JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1pubkey_1combine\n+  (JNIEnv * env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint numkeys)\n+{\n+  (void)classObject;(void)env;(void)byteBufferObject;(void)ctx_l;(void)numkeys;\n+\n+  return 0;\n+}\n+\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdh\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint publen)\n+{\n+  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n+  const unsigned char* secdata = (*env)->GetDirectBufferAddress(env, byteBufferObject);\n+  const unsigned char* pubdata = (const unsigned char*) (secdata + 32);\n+\n+  jobjectArray retArray;\n+  jbyteArray outArray, intsByteArray;\n+  unsigned char intsarray[1];\n+  secp256k1_pubkey pubkey;\n+  unsigned char nonce_res[32];\n+  size_t outputLen = 32;\n+\n+  int ret = secp256k1_ec_pubkey_parse(ctx, &pubkey, pubdata, publen);\n+\n+  if (ret) {\n+    ret = secp256k1_ecdh(\n+      ctx,\n+      nonce_res,\n+      &pubkey,\n+      secdata\n+    );\n+  }\n+\n+  intsarray[0] = ret;\n+\n+  retArray = (*env)->NewObjectArray(env, 2,\n+    (*env)->FindClass(env, \"[B\"),\n+    (*env)->NewByteArray(env, 1));\n+\n+  outArray = (*env)->NewByteArray(env, outputLen);\n+  (*env)->SetByteArrayRegion(env, outArray, 0, 32, (jbyte*)nonce_res);\n+  (*env)->SetObjectArrayElement(env, retArray, 0, outArray);\n+\n+  intsByteArray = (*env)->NewByteArray(env, 1);\n+  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 1, (jbyte*)intsarray);\n+  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n+\n+  (void)classObject;\n+\n+  return retArray;\n }"
      },
      {
        "sha": "fe613c9e9e77eddb18e0b0d8422948678f3408a8",
        "filename": "src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.h",
        "status": "modified",
        "additions": 101,
        "deletions": 3,
        "changes": 104,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.h?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -1,19 +1,117 @@\n /* DO NOT EDIT THIS FILE - it is machine generated */\n #include <jni.h>\n+#include \"include/secp256k1.h\"\n /* Header for class org_bitcoin_NativeSecp256k1 */\n \n #ifndef _Included_org_bitcoin_NativeSecp256k1\n #define _Included_org_bitcoin_NativeSecp256k1\n #ifdef __cplusplus\n extern \"C\" {\n #endif\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_ctx_clone\n+ * Signature: (J)J\n+ */\n+SECP256K1_API jlong JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ctx_1clone\n+  (JNIEnv *, jclass, jlong);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_context_randomize\n+ * Signature: (Ljava/nio/ByteBuffer;J)I\n+ */\n+SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1context_1randomize\n+  (JNIEnv *, jclass, jobject, jlong);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_privkey_tweak_add\n+ * Signature: (Ljava/nio/ByteBuffer;J)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1privkey_1tweak_1add\n+  (JNIEnv *, jclass, jobject, jlong);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_privkey_tweak_mul\n+ * Signature: (Ljava/nio/ByteBuffer;J)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1privkey_1tweak_1mul\n+  (JNIEnv *, jclass, jobject, jlong);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_pubkey_tweak_add\n+ * Signature: (Ljava/nio/ByteBuffer;JI)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1pubkey_1tweak_1add\n+  (JNIEnv *, jclass, jobject, jlong, jint);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_pubkey_tweak_mul\n+ * Signature: (Ljava/nio/ByteBuffer;JI)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1pubkey_1tweak_1mul\n+  (JNIEnv *, jclass, jobject, jlong, jint);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_destroy_context\n+ * Signature: (J)V\n+ */\n+SECP256K1_API void JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1destroy_1context\n+  (JNIEnv *, jclass, jlong);\n+\n /*\n  * Class:     org_bitcoin_NativeSecp256k1\n  * Method:    secp256k1_ecdsa_verify\n- * Signature: (Ljava/nio/ByteBuffer;)I\n+ * Signature: (Ljava/nio/ByteBuffer;JII)I\n+ */\n+SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1verify\n+  (JNIEnv *, jclass, jobject, jlong, jint, jint);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_ecdsa_sign\n+ * Signature: (Ljava/nio/ByteBuffer;J)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1sign\n+  (JNIEnv *, jclass, jobject, jlong);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_ec_seckey_verify\n+ * Signature: (Ljava/nio/ByteBuffer;J)I\n+ */\n+SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1seckey_1verify\n+  (JNIEnv *, jclass, jobject, jlong);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_ec_pubkey_create\n+ * Signature: (Ljava/nio/ByteBuffer;J)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1pubkey_1create\n+  (JNIEnv *, jclass, jobject, jlong);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_ec_pubkey_parse\n+ * Signature: (Ljava/nio/ByteBuffer;JI)[[B\n+ */\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1pubkey_1parse\n+  (JNIEnv *, jclass, jobject, jlong, jint);\n+\n+/*\n+ * Class:     org_bitcoin_NativeSecp256k1\n+ * Method:    secp256k1_ecdh\n+ * Signature: (Ljava/nio/ByteBuffer;JI)[[B\n  */\n-JNIEXPORT jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1verify\n-  (JNIEnv *, jclass, jobject);\n+SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdh\n+  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint publen);\n+\n \n #ifdef __cplusplus\n }"
      },
      {
        "sha": "a52939e7e7dacda374ec879d69b29ebb9add2dbc",
        "filename": "src/secp256k1/src/java/org_bitcoin_Secp256k1Context.c",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/java/org_bitcoin_Secp256k1Context.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/java/org_bitcoin_Secp256k1Context.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org_bitcoin_Secp256k1Context.c?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -0,0 +1,15 @@\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include \"org_bitcoin_Secp256k1Context.h\"\n+#include \"include/secp256k1.h\"\n+\n+SECP256K1_API jlong JNICALL Java_org_bitcoin_Secp256k1Context_secp256k1_1init_1context\n+  (JNIEnv* env, jclass classObject)\n+{\n+  secp256k1_context *ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+\n+  (void)classObject;(void)env;\n+\n+  return (uintptr_t)ctx;\n+}\n+"
      },
      {
        "sha": "0d2bc84b7f3fde84f81115a037be6de105f0472b",
        "filename": "src/secp256k1/src/java/org_bitcoin_Secp256k1Context.h",
        "status": "added",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/java/org_bitcoin_Secp256k1Context.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/java/org_bitcoin_Secp256k1Context.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org_bitcoin_Secp256k1Context.h?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -0,0 +1,22 @@\n+/* DO NOT EDIT THIS FILE - it is machine generated */\n+#include <jni.h>\n+#include \"include/secp256k1.h\"\n+/* Header for class org_bitcoin_Secp256k1Context */\n+\n+#ifndef _Included_org_bitcoin_Secp256k1Context\n+#define _Included_org_bitcoin_Secp256k1Context\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+/*\n+ * Class:     org_bitcoin_Secp256k1Context\n+ * Method:    secp256k1_init_context\n+ * Signature: ()J\n+ */\n+SECP256K1_API jlong JNICALL Java_org_bitcoin_Secp256k1Context_secp256k1_1init_1context\n+  (JNIEnv *, jclass);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+#endif"
      },
      {
        "sha": "e3088b469790bdc14b8982931d5729a7eabde69b",
        "filename": "src/secp256k1/src/modules/ecdh/Makefile.am.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/modules/ecdh/Makefile.am.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/modules/ecdh/Makefile.am.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/ecdh/Makefile.am.include?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -4,5 +4,5 @@ noinst_HEADERS += src/modules/ecdh/tests_impl.h\n if USE_BENCHMARK\n noinst_PROGRAMS += bench_ecdh\n bench_ecdh_SOURCES = src/bench_ecdh.c\n-bench_ecdh_LDADD = libsecp256k1.la $(SECP_LIBS)\n+bench_ecdh_LDADD = libsecp256k1.la $(SECP_LIBS) $(COMMON_LIB)\n endif"
      },
      {
        "sha": "bf23c26e71c5dd88df965141295bb33144007147",
        "filename": "src/secp256k1/src/modules/recovery/Makefile.am.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/modules/recovery/Makefile.am.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/modules/recovery/Makefile.am.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/recovery/Makefile.am.include?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -4,5 +4,5 @@ noinst_HEADERS += src/modules/recovery/tests_impl.h\n if USE_BENCHMARK\n noinst_PROGRAMS += bench_recover\n bench_recover_SOURCES = src/bench_recover.c\n-bench_recover_LDADD = libsecp256k1.la $(SECP_LIBS)\n+bench_recover_LDADD = libsecp256k1.la $(SECP_LIBS) $(COMMON_LIB)\n endif"
      },
      {
        "sha": "86f2f0cb2b5334baf4fd34e58abe6f8fc4733e32",
        "filename": "src/secp256k1/src/modules/recovery/main_impl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/modules/recovery/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/modules/recovery/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/recovery/main_impl.h?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -138,23 +138,23 @@ int secp256k1_ecdsa_sign_recoverable(const secp256k1_context* ctx, secp256k1_ecd\n     secp256k1_scalar_set_b32(&sec, seckey, &overflow);\n     /* Fail if the secret key is invalid. */\n     if (!overflow && !secp256k1_scalar_is_zero(&sec)) {\n+        unsigned char nonce32[32];\n         unsigned int count = 0;\n         secp256k1_scalar_set_b32(&msg, msg32, NULL);\n         while (1) {\n-            unsigned char nonce32[32];\n             ret = noncefp(nonce32, msg32, seckey, NULL, (void*)noncedata, count);\n             if (!ret) {\n                 break;\n             }\n             secp256k1_scalar_set_b32(&non, nonce32, &overflow);\n-            memset(nonce32, 0, 32);\n             if (!secp256k1_scalar_is_zero(&non) && !overflow) {\n                 if (secp256k1_ecdsa_sig_sign(&ctx->ecmult_gen_ctx, &r, &s, &sec, &msg, &non, &recid)) {\n                     break;\n                 }\n             }\n             count++;\n         }\n+        memset(nonce32, 0, 32);\n         secp256k1_scalar_clear(&msg);\n         secp256k1_scalar_clear(&non);\n         secp256k1_scalar_clear(&sec);"
      },
      {
        "sha": "b3bfa7d5cc49eeecd363ff8565953e430e6898d9",
        "filename": "src/secp256k1/src/modules/schnorr/Makefile.am.include",
        "status": "removed",
        "additions": 0,
        "deletions": 10,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e591c1049fe5e0256ac14a92f460f374a55ffd4e/src/secp256k1/src/modules/schnorr/Makefile.am.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e591c1049fe5e0256ac14a92f460f374a55ffd4e/src/secp256k1/src/modules/schnorr/Makefile.am.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/schnorr/Makefile.am.include?ref=e591c1049fe5e0256ac14a92f460f374a55ffd4e",
        "patch": "@@ -1,10 +0,0 @@\n-include_HEADERS += include/secp256k1_schnorr.h\n-noinst_HEADERS += src/modules/schnorr/main_impl.h\n-noinst_HEADERS += src/modules/schnorr/schnorr.h\n-noinst_HEADERS += src/modules/schnorr/schnorr_impl.h\n-noinst_HEADERS += src/modules/schnorr/tests_impl.h\n-if USE_BENCHMARK\n-noinst_PROGRAMS += bench_schnorr_verify\n-bench_schnorr_verify_SOURCES = src/bench_schnorr_verify.c\n-bench_schnorr_verify_LDADD = libsecp256k1.la $(SECP_LIBS)\n-endif"
      },
      {
        "sha": "fa176a1767f5f8388a4960f4eaecabbeb56a4d4a",
        "filename": "src/secp256k1/src/modules/schnorr/main_impl.h",
        "status": "removed",
        "additions": 0,
        "deletions": 164,
        "changes": 164,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e591c1049fe5e0256ac14a92f460f374a55ffd4e/src/secp256k1/src/modules/schnorr/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e591c1049fe5e0256ac14a92f460f374a55ffd4e/src/secp256k1/src/modules/schnorr/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/schnorr/main_impl.h?ref=e591c1049fe5e0256ac14a92f460f374a55ffd4e",
        "patch": "@@ -1,164 +0,0 @@\n-/**********************************************************************\n- * Copyright (c) 2014-2015 Pieter Wuille                              *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n-\n-#ifndef SECP256K1_MODULE_SCHNORR_MAIN\n-#define SECP256K1_MODULE_SCHNORR_MAIN\n-\n-#include \"include/secp256k1_schnorr.h\"\n-#include \"modules/schnorr/schnorr_impl.h\"\n-\n-static void secp256k1_schnorr_msghash_sha256(unsigned char *h32, const unsigned char *r32, const unsigned char *msg32) {\n-    secp256k1_sha256_t sha;\n-    secp256k1_sha256_initialize(&sha);\n-    secp256k1_sha256_write(&sha, r32, 32);\n-    secp256k1_sha256_write(&sha, msg32, 32);\n-    secp256k1_sha256_finalize(&sha, h32);\n-}\n-\n-static const unsigned char secp256k1_schnorr_algo16[17] = \"Schnorr+SHA256  \";\n-\n-int secp256k1_schnorr_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void* noncedata) {\n-    secp256k1_scalar sec, non;\n-    int ret = 0;\n-    int overflow = 0;\n-    unsigned int count = 0;\n-    VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n-    ARG_CHECK(msg32 != NULL);\n-    ARG_CHECK(sig64 != NULL);\n-    ARG_CHECK(seckey != NULL);\n-    if (noncefp == NULL) {\n-        noncefp = secp256k1_nonce_function_default;\n-    }\n-\n-    secp256k1_scalar_set_b32(&sec, seckey, NULL);\n-    while (1) {\n-        unsigned char nonce32[32];\n-        ret = noncefp(nonce32, msg32, seckey, secp256k1_schnorr_algo16, (void*)noncedata, count);\n-        if (!ret) {\n-            break;\n-        }\n-        secp256k1_scalar_set_b32(&non, nonce32, &overflow);\n-        memset(nonce32, 0, 32);\n-        if (!secp256k1_scalar_is_zero(&non) && !overflow) {\n-            if (secp256k1_schnorr_sig_sign(&ctx->ecmult_gen_ctx, sig64, &sec, &non, NULL, secp256k1_schnorr_msghash_sha256, msg32)) {\n-                break;\n-            }\n-        }\n-        count++;\n-    }\n-    if (!ret) {\n-        memset(sig64, 0, 64);\n-    }\n-    secp256k1_scalar_clear(&non);\n-    secp256k1_scalar_clear(&sec);\n-    return ret;\n-}\n-\n-int secp256k1_schnorr_verify(const secp256k1_context* ctx, const unsigned char *sig64, const unsigned char *msg32, const secp256k1_pubkey *pubkey) {\n-    secp256k1_ge q;\n-    VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n-    ARG_CHECK(msg32 != NULL);\n-    ARG_CHECK(sig64 != NULL);\n-    ARG_CHECK(pubkey != NULL);\n-\n-    secp256k1_pubkey_load(ctx, &q, pubkey);\n-    return secp256k1_schnorr_sig_verify(&ctx->ecmult_ctx, sig64, &q, secp256k1_schnorr_msghash_sha256, msg32);\n-}\n-\n-int secp256k1_schnorr_recover(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const unsigned char *sig64, const unsigned char *msg32) {\n-    secp256k1_ge q;\n-\n-    VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx));\n-    ARG_CHECK(msg32 != NULL);\n-    ARG_CHECK(sig64 != NULL);\n-    ARG_CHECK(pubkey != NULL);\n-\n-    if (secp256k1_schnorr_sig_recover(&ctx->ecmult_ctx, sig64, &q, secp256k1_schnorr_msghash_sha256, msg32)) {\n-        secp256k1_pubkey_save(pubkey, &q);\n-        return 1;\n-    } else {\n-        memset(pubkey, 0, sizeof(*pubkey));\n-        return 0;\n-    }\n-}\n-\n-int secp256k1_schnorr_generate_nonce_pair(const secp256k1_context* ctx, secp256k1_pubkey *pubnonce, unsigned char *privnonce32, const unsigned char *sec32, const unsigned char *msg32, secp256k1_nonce_function noncefp, const void* noncedata) {\n-    int count = 0;\n-    int ret = 1;\n-    secp256k1_gej Qj;\n-    secp256k1_ge Q;\n-    secp256k1_scalar sec;\n-\n-    VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n-    ARG_CHECK(msg32 != NULL);\n-    ARG_CHECK(sec32 != NULL);\n-    ARG_CHECK(pubnonce != NULL);\n-    ARG_CHECK(privnonce32 != NULL);\n-\n-    if (noncefp == NULL) {\n-        noncefp = secp256k1_nonce_function_default;\n-    }\n-\n-    do {\n-        int overflow;\n-        ret = noncefp(privnonce32, sec32, msg32, secp256k1_schnorr_algo16, (void*)noncedata, count++);\n-        if (!ret) {\n-            break;\n-        }\n-        secp256k1_scalar_set_b32(&sec, privnonce32, &overflow);\n-        if (overflow || secp256k1_scalar_is_zero(&sec)) {\n-            continue;\n-        }\n-        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &Qj, &sec);\n-        secp256k1_ge_set_gej(&Q, &Qj);\n-\n-        secp256k1_pubkey_save(pubnonce, &Q);\n-        break;\n-    } while(1);\n-\n-    secp256k1_scalar_clear(&sec);\n-    if (!ret) {\n-        memset(pubnonce, 0, sizeof(*pubnonce));\n-    }\n-    return ret;\n-}\n-\n-int secp256k1_schnorr_partial_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const unsigned char *sec32, const secp256k1_pubkey *pubnonce_others, const unsigned char *secnonce32) {\n-    int overflow = 0;\n-    secp256k1_scalar sec, non;\n-    secp256k1_ge pubnon;\n-    VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n-    ARG_CHECK(msg32 != NULL);\n-    ARG_CHECK(sig64 != NULL);\n-    ARG_CHECK(sec32 != NULL);\n-    ARG_CHECK(secnonce32 != NULL);\n-    ARG_CHECK(pubnonce_others != NULL);\n-\n-    secp256k1_scalar_set_b32(&sec, sec32, &overflow);\n-    if (overflow || secp256k1_scalar_is_zero(&sec)) {\n-        return -1;\n-    }\n-    secp256k1_scalar_set_b32(&non, secnonce32, &overflow);\n-    if (overflow || secp256k1_scalar_is_zero(&non)) {\n-        return -1;\n-    }\n-    secp256k1_pubkey_load(ctx, &pubnon, pubnonce_others);\n-    return secp256k1_schnorr_sig_sign(&ctx->ecmult_gen_ctx, sig64, &sec, &non, &pubnon, secp256k1_schnorr_msghash_sha256, msg32);\n-}\n-\n-int secp256k1_schnorr_partial_combine(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char * const *sig64sin, size_t n) {\n-    ARG_CHECK(sig64 != NULL);\n-    ARG_CHECK(n >= 1);\n-    ARG_CHECK(sig64sin != NULL);\n-    return secp256k1_schnorr_sig_combine(sig64, n, sig64sin);\n-}\n-\n-#endif"
      },
      {
        "sha": "de18147bd52ac0f70369114dfcb06947730cbaac",
        "filename": "src/secp256k1/src/modules/schnorr/schnorr.h",
        "status": "removed",
        "additions": 0,
        "deletions": 20,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e591c1049fe5e0256ac14a92f460f374a55ffd4e/src/secp256k1/src/modules/schnorr/schnorr.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e591c1049fe5e0256ac14a92f460f374a55ffd4e/src/secp256k1/src/modules/schnorr/schnorr.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/schnorr/schnorr.h?ref=e591c1049fe5e0256ac14a92f460f374a55ffd4e",
        "patch": "@@ -1,20 +0,0 @@\n-/***********************************************************************\n- * Copyright (c) 2014-2015 Pieter Wuille                               *\n- * Distributed under the MIT software license, see the accompanying    *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php. *\n- ***********************************************************************/\n-\n-#ifndef _SECP256K1_MODULE_SCHNORR_H_\n-#define _SECP256K1_MODULE_SCHNORR_H_\n-\n-#include \"scalar.h\"\n-#include \"group.h\"\n-\n-typedef void (*secp256k1_schnorr_msghash)(unsigned char *h32, const unsigned char *r32, const unsigned char *msg32);\n-\n-static int secp256k1_schnorr_sig_sign(const secp256k1_ecmult_gen_context* ctx, unsigned char *sig64, const secp256k1_scalar *key, const secp256k1_scalar *nonce, const secp256k1_ge *pubnonce, secp256k1_schnorr_msghash hash, const unsigned char *msg32);\n-static int secp256k1_schnorr_sig_verify(const secp256k1_ecmult_context* ctx, const unsigned char *sig64, const secp256k1_ge *pubkey, secp256k1_schnorr_msghash hash, const unsigned char *msg32);\n-static int secp256k1_schnorr_sig_recover(const secp256k1_ecmult_context* ctx, const unsigned char *sig64, secp256k1_ge *pubkey, secp256k1_schnorr_msghash hash, const unsigned char *msg32);\n-static int secp256k1_schnorr_sig_combine(unsigned char *sig64, size_t n, const unsigned char * const *sig64ins);\n-\n-#endif"
      },
      {
        "sha": "e13ab6db7cca1173582c47597d42fb916f43fc22",
        "filename": "src/secp256k1/src/modules/schnorr/schnorr_impl.h",
        "status": "removed",
        "additions": 0,
        "deletions": 207,
        "changes": 207,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e591c1049fe5e0256ac14a92f460f374a55ffd4e/src/secp256k1/src/modules/schnorr/schnorr_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e591c1049fe5e0256ac14a92f460f374a55ffd4e/src/secp256k1/src/modules/schnorr/schnorr_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/schnorr/schnorr_impl.h?ref=e591c1049fe5e0256ac14a92f460f374a55ffd4e",
        "patch": "@@ -1,207 +0,0 @@\n-/***********************************************************************\n- * Copyright (c) 2014-2015 Pieter Wuille                               *\n- * Distributed under the MIT software license, see the accompanying    *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php. *\n- ***********************************************************************/\n-\n-#ifndef _SECP256K1_SCHNORR_IMPL_H_\n-#define _SECP256K1_SCHNORR_IMPL_H_\n-\n-#include <string.h>\n-\n-#include \"schnorr.h\"\n-#include \"num.h\"\n-#include \"field.h\"\n-#include \"group.h\"\n-#include \"ecmult.h\"\n-#include \"ecmult_gen.h\"\n-\n-/**\n- * Custom Schnorr-based signature scheme. They support multiparty signing, public key\n- * recovery and batch validation.\n- *\n- * Rationale for verifying R's y coordinate:\n- * In order to support batch validation and public key recovery, the full R point must\n- * be known to verifiers, rather than just its x coordinate. In order to not risk\n- * being more strict in batch validation than normal validation, validators must be\n- * required to reject signatures with incorrect y coordinate. This is only possible\n- * by including a (relatively slow) field inverse, or a field square root. However,\n- * batch validation offers potentially much higher benefits than this cost.\n- *\n- * Rationale for having an implicit y coordinate oddness:\n- * If we commit to having the full R point known to verifiers, there are two mechanism.\n- * Either include its oddness in the signature, or give it an implicit fixed value.\n- * As the R y coordinate can be flipped by a simple negation of the nonce, we choose the\n- * latter, as it comes with nearly zero impact on signing or validation performance, and\n- * saves a byte in the signature.\n- *\n- * Signing:\n- *   Inputs: 32-byte message m, 32-byte scalar key x (!=0), 32-byte scalar nonce k (!=0)\n- *\n- *   Compute point R = k * G. Reject nonce if R's y coordinate is odd (or negate nonce).\n- *   Compute 32-byte r, the serialization of R's x coordinate.\n- *   Compute scalar h = Hash(r || m). Reject nonce if h == 0 or h >= order.\n- *   Compute scalar s = k - h * x.\n- *   The signature is (r, s).\n- *\n- *\n- * Verification:\n- *   Inputs: 32-byte message m, public key point Q, signature: (32-byte r, scalar s)\n- *\n- *   Signature is invalid if s >= order.\n- *   Signature is invalid if r >= p.\n- *   Compute scalar h = Hash(r || m). Signature is invalid if h == 0 or h >= order.\n- *   Option 1 (faster for single verification):\n- *     Compute point R = h * Q + s * G. Signature is invalid if R is infinity or R's y coordinate is odd.\n- *     Signature is valid if the serialization of R's x coordinate equals r.\n- *   Option 2 (allows batch validation and pubkey recovery):\n- *     Decompress x coordinate r into point R, with odd y coordinate. Fail if R is not on the curve.\n- *     Signature is valid if R + h * Q + s * G == 0.\n- */\n-\n-static int secp256k1_schnorr_sig_sign(const secp256k1_ecmult_gen_context* ctx, unsigned char *sig64, const secp256k1_scalar *key, const secp256k1_scalar *nonce, const secp256k1_ge *pubnonce, secp256k1_schnorr_msghash hash, const unsigned char *msg32) {\n-    secp256k1_gej Rj;\n-    secp256k1_ge Ra;\n-    unsigned char h32[32];\n-    secp256k1_scalar h, s;\n-    int overflow;\n-    secp256k1_scalar n;\n-\n-    if (secp256k1_scalar_is_zero(key) || secp256k1_scalar_is_zero(nonce)) {\n-        return 0;\n-    }\n-    n = *nonce;\n-\n-    secp256k1_ecmult_gen(ctx, &Rj, &n);\n-    if (pubnonce != NULL) {\n-        secp256k1_gej_add_ge(&Rj, &Rj, pubnonce);\n-    }\n-    secp256k1_ge_set_gej(&Ra, &Rj);\n-    secp256k1_fe_normalize(&Ra.y);\n-    if (secp256k1_fe_is_odd(&Ra.y)) {\n-        /* R's y coordinate is odd, which is not allowed (see rationale above).\n-           Force it to be even by negating the nonce. Note that this even works\n-           for multiparty signing, as the R point is known to all participants,\n-           which can all decide to flip the sign in unison, resulting in the\n-           overall R point to be negated too. */\n-        secp256k1_scalar_negate(&n, &n);\n-    }\n-    secp256k1_fe_normalize(&Ra.x);\n-    secp256k1_fe_get_b32(sig64, &Ra.x);\n-    hash(h32, sig64, msg32);\n-    overflow = 0;\n-    secp256k1_scalar_set_b32(&h, h32, &overflow);\n-    if (overflow || secp256k1_scalar_is_zero(&h)) {\n-        secp256k1_scalar_clear(&n);\n-        return 0;\n-    }\n-    secp256k1_scalar_mul(&s, &h, key);\n-    secp256k1_scalar_negate(&s, &s);\n-    secp256k1_scalar_add(&s, &s, &n);\n-    secp256k1_scalar_clear(&n);\n-    secp256k1_scalar_get_b32(sig64 + 32, &s);\n-    return 1;\n-}\n-\n-static int secp256k1_schnorr_sig_verify(const secp256k1_ecmult_context* ctx, const unsigned char *sig64, const secp256k1_ge *pubkey, secp256k1_schnorr_msghash hash, const unsigned char *msg32) {\n-    secp256k1_gej Qj, Rj;\n-    secp256k1_ge Ra;\n-    secp256k1_fe Rx;\n-    secp256k1_scalar h, s;\n-    unsigned char hh[32];\n-    int overflow;\n-\n-    if (secp256k1_ge_is_infinity(pubkey)) {\n-        return 0;\n-    }\n-    hash(hh, sig64, msg32);\n-    overflow = 0;\n-    secp256k1_scalar_set_b32(&h, hh, &overflow);\n-    if (overflow || secp256k1_scalar_is_zero(&h)) {\n-        return 0;\n-    }\n-    overflow = 0;\n-    secp256k1_scalar_set_b32(&s, sig64 + 32, &overflow);\n-    if (overflow) {\n-        return 0;\n-    }\n-    if (!secp256k1_fe_set_b32(&Rx, sig64)) {\n-        return 0;\n-    }\n-    secp256k1_gej_set_ge(&Qj, pubkey);\n-    secp256k1_ecmult(ctx, &Rj, &Qj, &h, &s);\n-    if (secp256k1_gej_is_infinity(&Rj)) {\n-        return 0;\n-    }\n-    secp256k1_ge_set_gej_var(&Ra, &Rj);\n-    secp256k1_fe_normalize_var(&Ra.y);\n-    if (secp256k1_fe_is_odd(&Ra.y)) {\n-        return 0;\n-    }\n-    return secp256k1_fe_equal_var(&Rx, &Ra.x);\n-}\n-\n-static int secp256k1_schnorr_sig_recover(const secp256k1_ecmult_context* ctx, const unsigned char *sig64, secp256k1_ge *pubkey, secp256k1_schnorr_msghash hash, const unsigned char *msg32) {\n-    secp256k1_gej Qj, Rj;\n-    secp256k1_ge Ra;\n-    secp256k1_fe Rx;\n-    secp256k1_scalar h, s;\n-    unsigned char hh[32];\n-    int overflow;\n-\n-    hash(hh, sig64, msg32);\n-    overflow = 0;\n-    secp256k1_scalar_set_b32(&h, hh, &overflow);\n-    if (overflow || secp256k1_scalar_is_zero(&h)) {\n-        return 0;\n-    }\n-    overflow = 0;\n-    secp256k1_scalar_set_b32(&s, sig64 + 32, &overflow);\n-    if (overflow) {\n-        return 0;\n-    }\n-    if (!secp256k1_fe_set_b32(&Rx, sig64)) {\n-        return 0;\n-    }\n-    if (!secp256k1_ge_set_xo_var(&Ra, &Rx, 0)) {\n-        return 0;\n-    }\n-    secp256k1_gej_set_ge(&Rj, &Ra);\n-    secp256k1_scalar_inverse_var(&h, &h);\n-    secp256k1_scalar_negate(&s, &s);\n-    secp256k1_scalar_mul(&s, &s, &h);\n-    secp256k1_ecmult(ctx, &Qj, &Rj, &h, &s);\n-    if (secp256k1_gej_is_infinity(&Qj)) {\n-        return 0;\n-    }\n-    secp256k1_ge_set_gej(pubkey, &Qj);\n-    return 1;\n-}\n-\n-static int secp256k1_schnorr_sig_combine(unsigned char *sig64, size_t n, const unsigned char * const *sig64ins) {\n-    secp256k1_scalar s = SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 0);\n-    size_t i;\n-    for (i = 0; i < n; i++) {\n-        secp256k1_scalar si;\n-        int overflow;\n-        secp256k1_scalar_set_b32(&si, sig64ins[i] + 32, &overflow);\n-        if (overflow) {\n-            return -1;\n-        }\n-        if (i) {\n-            if (memcmp(sig64ins[i - 1], sig64ins[i], 32) != 0) {\n-                return -1;\n-            }\n-        }\n-        secp256k1_scalar_add(&s, &s, &si);\n-    }\n-    if (secp256k1_scalar_is_zero(&s)) {\n-        return 0;\n-    }\n-    memcpy(sig64, sig64ins[0], 32);\n-    secp256k1_scalar_get_b32(sig64 + 32, &s);\n-    secp256k1_scalar_clear(&s);\n-    return 1;\n-}\n-\n-#endif"
      },
      {
        "sha": "5bd14a03e3c65ba99c27e6694352bf9e4d9ab1cd",
        "filename": "src/secp256k1/src/modules/schnorr/tests_impl.h",
        "status": "removed",
        "additions": 0,
        "deletions": 175,
        "changes": 175,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e591c1049fe5e0256ac14a92f460f374a55ffd4e/src/secp256k1/src/modules/schnorr/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e591c1049fe5e0256ac14a92f460f374a55ffd4e/src/secp256k1/src/modules/schnorr/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/schnorr/tests_impl.h?ref=e591c1049fe5e0256ac14a92f460f374a55ffd4e",
        "patch": "@@ -1,175 +0,0 @@\n-/**********************************************************************\n- * Copyright (c) 2014-2015 Pieter Wuille                              *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n-\n-#ifndef SECP256K1_MODULE_SCHNORR_TESTS\n-#define SECP256K1_MODULE_SCHNORR_TESTS\n-\n-#include \"include/secp256k1_schnorr.h\"\n-\n-void test_schnorr_end_to_end(void) {\n-    unsigned char privkey[32];\n-    unsigned char message[32];\n-    unsigned char schnorr_signature[64];\n-    secp256k1_pubkey pubkey, recpubkey;\n-\n-    /* Generate a random key and message. */\n-    {\n-        secp256k1_scalar key;\n-        random_scalar_order_test(&key);\n-        secp256k1_scalar_get_b32(privkey, &key);\n-        secp256k1_rand256_test(message);\n-    }\n-\n-    /* Construct and verify corresponding public key. */\n-    CHECK(secp256k1_ec_seckey_verify(ctx, privkey) == 1);\n-    CHECK(secp256k1_ec_pubkey_create(ctx, &pubkey, privkey) == 1);\n-\n-    /* Schnorr sign. */\n-    CHECK(secp256k1_schnorr_sign(ctx, schnorr_signature, message, privkey, NULL, NULL) == 1);\n-    CHECK(secp256k1_schnorr_verify(ctx, schnorr_signature, message, &pubkey) == 1);\n-    CHECK(secp256k1_schnorr_recover(ctx, &recpubkey, schnorr_signature, message) == 1);\n-    CHECK(memcmp(&pubkey, &recpubkey, sizeof(pubkey)) == 0);\n-    /* Destroy signature and verify again. */\n-    schnorr_signature[secp256k1_rand_bits(6)] += 1 + secp256k1_rand_int(255);\n-    CHECK(secp256k1_schnorr_verify(ctx, schnorr_signature, message, &pubkey) == 0);\n-    CHECK(secp256k1_schnorr_recover(ctx, &recpubkey, schnorr_signature, message) != 1 ||\n-          memcmp(&pubkey, &recpubkey, sizeof(pubkey)) != 0);\n-}\n-\n-/** Horribly broken hash function. Do not use for anything but tests. */\n-void test_schnorr_hash(unsigned char *h32, const unsigned char *r32, const unsigned char *msg32) {\n-    int i;\n-    for (i = 0; i < 32; i++) {\n-        h32[i] = r32[i] ^ msg32[i];\n-    }\n-}\n-\n-void test_schnorr_sign_verify(void) {\n-    unsigned char msg32[32];\n-    unsigned char sig64[3][64];\n-    secp256k1_gej pubkeyj[3];\n-    secp256k1_ge pubkey[3];\n-    secp256k1_scalar nonce[3], key[3];\n-    int i = 0;\n-    int k;\n-\n-    secp256k1_rand256_test(msg32);\n-\n-    for (k = 0; k < 3; k++) {\n-        random_scalar_order_test(&key[k]);\n-\n-        do {\n-            random_scalar_order_test(&nonce[k]);\n-            if (secp256k1_schnorr_sig_sign(&ctx->ecmult_gen_ctx, sig64[k], &key[k], &nonce[k], NULL, &test_schnorr_hash, msg32)) {\n-                break;\n-            }\n-        } while(1);\n-\n-        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pubkeyj[k], &key[k]);\n-        secp256k1_ge_set_gej_var(&pubkey[k], &pubkeyj[k]);\n-        CHECK(secp256k1_schnorr_sig_verify(&ctx->ecmult_ctx, sig64[k], &pubkey[k], &test_schnorr_hash, msg32));\n-\n-        for (i = 0; i < 4; i++) {\n-            int pos = secp256k1_rand_bits(6);\n-            int mod = 1 + secp256k1_rand_int(255);\n-            sig64[k][pos] ^= mod;\n-            CHECK(secp256k1_schnorr_sig_verify(&ctx->ecmult_ctx, sig64[k], &pubkey[k], &test_schnorr_hash, msg32) == 0);\n-            sig64[k][pos] ^= mod;\n-        }\n-    }\n-}\n-\n-void test_schnorr_threshold(void) {\n-    unsigned char msg[32];\n-    unsigned char sec[5][32];\n-    secp256k1_pubkey pub[5];\n-    unsigned char nonce[5][32];\n-    secp256k1_pubkey pubnonce[5];\n-    unsigned char sig[5][64];\n-    const unsigned char* sigs[5];\n-    unsigned char allsig[64];\n-    const secp256k1_pubkey* pubs[5];\n-    secp256k1_pubkey allpub;\n-    int n, i;\n-    int damage;\n-    int ret = 0;\n-\n-    damage = secp256k1_rand_bits(1) ? (1 + secp256k1_rand_int(4)) : 0;\n-    secp256k1_rand256_test(msg);\n-    n = 2 + secp256k1_rand_int(4);\n-    for (i = 0; i < n; i++) {\n-        do {\n-            secp256k1_rand256_test(sec[i]);\n-        } while (!secp256k1_ec_seckey_verify(ctx, sec[i]));\n-        CHECK(secp256k1_ec_pubkey_create(ctx, &pub[i], sec[i]));\n-        CHECK(secp256k1_schnorr_generate_nonce_pair(ctx, &pubnonce[i], nonce[i], msg, sec[i], NULL, NULL));\n-        pubs[i] = &pub[i];\n-    }\n-    if (damage == 1) {\n-        nonce[secp256k1_rand_int(n)][secp256k1_rand_int(32)] ^= 1 + secp256k1_rand_int(255);\n-    } else if (damage == 2) {\n-        sec[secp256k1_rand_int(n)][secp256k1_rand_int(32)] ^= 1 + secp256k1_rand_int(255);\n-    }\n-    for (i = 0; i < n; i++) {\n-        secp256k1_pubkey allpubnonce;\n-        const secp256k1_pubkey *pubnonces[4];\n-        int j;\n-        for (j = 0; j < i; j++) {\n-            pubnonces[j] = &pubnonce[j];\n-        }\n-        for (j = i + 1; j < n; j++) {\n-            pubnonces[j - 1] = &pubnonce[j];\n-        }\n-        CHECK(secp256k1_ec_pubkey_combine(ctx, &allpubnonce, pubnonces, n - 1));\n-        ret |= (secp256k1_schnorr_partial_sign(ctx, sig[i], msg, sec[i], &allpubnonce, nonce[i]) != 1) * 1;\n-        sigs[i] = sig[i];\n-    }\n-    if (damage == 3) {\n-        sig[secp256k1_rand_int(n)][secp256k1_rand_bits(6)] ^= 1 + secp256k1_rand_int(255);\n-    }\n-    ret |= (secp256k1_ec_pubkey_combine(ctx, &allpub, pubs, n) != 1) * 2;\n-    if ((ret & 1) == 0) {\n-        ret |= (secp256k1_schnorr_partial_combine(ctx, allsig, sigs, n) != 1) * 4;\n-    }\n-    if (damage == 4) {\n-        allsig[secp256k1_rand_int(32)] ^= 1 + secp256k1_rand_int(255);\n-    }\n-    if ((ret & 7) == 0) {\n-        ret |= (secp256k1_schnorr_verify(ctx, allsig, msg, &allpub) != 1) * 8;\n-    }\n-    CHECK((ret == 0) == (damage == 0));\n-}\n-\n-void test_schnorr_recovery(void) {\n-    unsigned char msg32[32];\n-    unsigned char sig64[64];\n-    secp256k1_ge Q;\n-\n-    secp256k1_rand256_test(msg32);\n-    secp256k1_rand256_test(sig64);\n-    secp256k1_rand256_test(sig64 + 32);\n-    if (secp256k1_schnorr_sig_recover(&ctx->ecmult_ctx, sig64, &Q, &test_schnorr_hash, msg32) == 1) {\n-        CHECK(secp256k1_schnorr_sig_verify(&ctx->ecmult_ctx, sig64, &Q, &test_schnorr_hash, msg32) == 1);\n-    }\n-}\n-\n-void run_schnorr_tests(void) {\n-    int i;\n-    for (i = 0; i < 32*count; i++) {\n-        test_schnorr_end_to_end();\n-    }\n-    for (i = 0; i < 32 * count; i++) {\n-         test_schnorr_sign_verify();\n-    }\n-    for (i = 0; i < 16 * count; i++) {\n-         test_schnorr_recovery();\n-    }\n-    for (i = 0; i < 10 * count; i++) {\n-         test_schnorr_threshold();\n-    }\n-}\n-\n-#endif"
      },
      {
        "sha": "7bb9c5be8cf5a6d020ef4bfcac1af13902e5d533",
        "filename": "src/secp256k1/src/num.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/num.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/num.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/num.h?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -32,6 +32,9 @@ static void secp256k1_num_set_bin(secp256k1_num *r, const unsigned char *a, unsi\n /** Compute a modular inverse. The input must be less than the modulus. */\n static void secp256k1_num_mod_inverse(secp256k1_num *r, const secp256k1_num *a, const secp256k1_num *m);\n \n+/** Compute the jacobi symbol (a|b). b must be positive and odd. */\n+static int secp256k1_num_jacobi(const secp256k1_num *a, const secp256k1_num *b);\n+\n /** Compare the absolute value of two numbers. */\n static int secp256k1_num_cmp(const secp256k1_num *a, const secp256k1_num *b);\n \n@@ -57,6 +60,9 @@ static void secp256k1_num_shift(secp256k1_num *r, int bits);\n /** Check whether a number is zero. */\n static int secp256k1_num_is_zero(const secp256k1_num *a);\n \n+/** Check whether a number is one. */\n+static int secp256k1_num_is_one(const secp256k1_num *a);\n+\n /** Check whether a number is strictly negative. */\n static int secp256k1_num_is_neg(const secp256k1_num *a);\n "
      },
      {
        "sha": "3a46495eeac7d979a87871ca20ce30c2010a54ce",
        "filename": "src/secp256k1/src/num_gmp_impl.h",
        "status": "modified",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/num_gmp_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/num_gmp_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/num_gmp_impl.h?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -144,6 +144,32 @@ static void secp256k1_num_mod_inverse(secp256k1_num *r, const secp256k1_num *a,\n     memset(v, 0, sizeof(v));\n }\n \n+static int secp256k1_num_jacobi(const secp256k1_num *a, const secp256k1_num *b) {\n+    int ret;\n+    mpz_t ga, gb;\n+    secp256k1_num_sanity(a);\n+    secp256k1_num_sanity(b);\n+    VERIFY_CHECK(!b->neg && (b->limbs > 0) && (b->data[0] & 1));\n+\n+    mpz_inits(ga, gb, NULL);\n+\n+    mpz_import(gb, b->limbs, -1, sizeof(mp_limb_t), 0, 0, b->data);\n+    mpz_import(ga, a->limbs, -1, sizeof(mp_limb_t), 0, 0, a->data);\n+    if (a->neg) {\n+        mpz_neg(ga, ga);\n+    }\n+\n+    ret = mpz_jacobi(ga, gb);\n+\n+    mpz_clears(ga, gb, NULL);\n+\n+    return ret;\n+}\n+\n+static int secp256k1_num_is_one(const secp256k1_num *a) {\n+    return (a->limbs == 1 && a->data[0] == 1);\n+}\n+\n static int secp256k1_num_is_zero(const secp256k1_num *a) {\n     return (a->limbs == 1 && a->data[0] == 0);\n }"
      },
      {
        "sha": "27e9d8375e8b0dc9977d8b037fb1b4344d027d4c",
        "filename": "src/secp256k1/src/scalar.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/scalar.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/scalar.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar.h?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -13,7 +13,9 @@\n #include \"libsecp256k1-config.h\"\n #endif\n \n-#if defined(USE_SCALAR_4X64)\n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+#include \"scalar_low.h\"\n+#elif defined(USE_SCALAR_4X64)\n #include \"scalar_4x64.h\"\n #elif defined(USE_SCALAR_8X32)\n #include \"scalar_8x32.h\""
      },
      {
        "sha": "56e7bd82afd630b107c080b5c96cf50cdbb722f9",
        "filename": "src/secp256k1/src/scalar_4x64_impl.h",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/scalar_4x64_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/scalar_4x64_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_4x64_impl.h?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -282,16 +282,16 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     \"movq 56(%%rsi), %%r14\\n\"\n     /* Initialize r8,r9,r10 */\n     \"movq 0(%%rsi), %%r8\\n\"\n-    \"movq $0, %%r9\\n\"\n-    \"movq $0, %%r10\\n\"\n+    \"xorq %%r9, %%r9\\n\"\n+    \"xorq %%r10, %%r10\\n\"\n     /* (r8,r9) += n0 * c0 */\n     \"movq %8, %%rax\\n\"\n     \"mulq %%r11\\n\"\n     \"addq %%rax, %%r8\\n\"\n     \"adcq %%rdx, %%r9\\n\"\n     /* extract m0 */\n     \"movq %%r8, %q0\\n\"\n-    \"movq $0, %%r8\\n\"\n+    \"xorq %%r8, %%r8\\n\"\n     /* (r9,r10) += l1 */\n     \"addq 8(%%rsi), %%r9\\n\"\n     \"adcq $0, %%r10\\n\"\n@@ -309,7 +309,7 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     \"adcq $0, %%r8\\n\"\n     /* extract m1 */\n     \"movq %%r9, %q1\\n\"\n-    \"movq $0, %%r9\\n\"\n+    \"xorq %%r9, %%r9\\n\"\n     /* (r10,r8,r9) += l2 */\n     \"addq 16(%%rsi), %%r10\\n\"\n     \"adcq $0, %%r8\\n\"\n@@ -332,7 +332,7 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     \"adcq $0, %%r9\\n\"\n     /* extract m2 */\n     \"movq %%r10, %q2\\n\"\n-    \"movq $0, %%r10\\n\"\n+    \"xorq %%r10, %%r10\\n\"\n     /* (r8,r9,r10) += l3 */\n     \"addq 24(%%rsi), %%r8\\n\"\n     \"adcq $0, %%r9\\n\"\n@@ -355,7 +355,7 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     \"adcq $0, %%r10\\n\"\n     /* extract m3 */\n     \"movq %%r8, %q3\\n\"\n-    \"movq $0, %%r8\\n\"\n+    \"xorq %%r8, %%r8\\n\"\n     /* (r9,r10,r8) += n3 * c1 */\n     \"movq %9, %%rax\\n\"\n     \"mulq %%r14\\n\"\n@@ -387,16 +387,16 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     \"movq %q11, %%r13\\n\"\n     /* Initialize (r8,r9,r10) */\n     \"movq %q5, %%r8\\n\"\n-    \"movq $0, %%r9\\n\"\n-    \"movq $0, %%r10\\n\"\n+    \"xorq %%r9, %%r9\\n\"\n+    \"xorq %%r10, %%r10\\n\"\n     /* (r8,r9) += m4 * c0 */\n     \"movq %12, %%rax\\n\"\n     \"mulq %%r11\\n\"\n     \"addq %%rax, %%r8\\n\"\n     \"adcq %%rdx, %%r9\\n\"\n     /* extract p0 */\n     \"movq %%r8, %q0\\n\"\n-    \"movq $0, %%r8\\n\"\n+    \"xorq %%r8, %%r8\\n\"\n     /* (r9,r10) += m1 */\n     \"addq %q6, %%r9\\n\"\n     \"adcq $0, %%r10\\n\"\n@@ -414,7 +414,7 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     \"adcq $0, %%r8\\n\"\n     /* extract p1 */\n     \"movq %%r9, %q1\\n\"\n-    \"movq $0, %%r9\\n\"\n+    \"xorq %%r9, %%r9\\n\"\n     /* (r10,r8,r9) += m2 */\n     \"addq %q7, %%r10\\n\"\n     \"adcq $0, %%r8\\n\"\n@@ -472,7 +472,7 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     \"movq %%rax, 0(%q6)\\n\"\n     /* Move to (r8,r9) */\n     \"movq %%rdx, %%r8\\n\"\n-    \"movq $0, %%r9\\n\"\n+    \"xorq %%r9, %%r9\\n\"\n     /* (r8,r9) += p1 */\n     \"addq %q2, %%r8\\n\"\n     \"adcq $0, %%r9\\n\"\n@@ -483,7 +483,7 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     \"adcq %%rdx, %%r9\\n\"\n     /* Extract r1 */\n     \"movq %%r8, 8(%q6)\\n\"\n-    \"movq $0, %%r8\\n\"\n+    \"xorq %%r8, %%r8\\n\"\n     /* (r9,r8) += p4 */\n     \"addq %%r10, %%r9\\n\"\n     \"adcq $0, %%r8\\n\"\n@@ -492,7 +492,7 @@ static void secp256k1_scalar_reduce_512(secp256k1_scalar *r, const uint64_t *l)\n     \"adcq $0, %%r8\\n\"\n     /* Extract r2 */\n     \"movq %%r9, 16(%q6)\\n\"\n-    \"movq $0, %%r9\\n\"\n+    \"xorq %%r9, %%r9\\n\"\n     /* (r8,r9) += p3 */\n     \"addq %q4, %%r8\\n\"\n     \"adcq $0, %%r9\\n\""
      },
      {
        "sha": "f5b2376407bd3b2338e26b1a0bb84cd3fc91660b",
        "filename": "src/secp256k1/src/scalar_impl.h",
        "status": "modified",
        "additions": 37,
        "deletions": 4,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/scalar_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/scalar_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_impl.h?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -7,16 +7,16 @@\n #ifndef _SECP256K1_SCALAR_IMPL_H_\n #define _SECP256K1_SCALAR_IMPL_H_\n \n-#include <string.h>\n-\n #include \"group.h\"\n #include \"scalar.h\"\n \n #if defined HAVE_CONFIG_H\n #include \"libsecp256k1-config.h\"\n #endif\n \n-#if defined(USE_SCALAR_4X64)\n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+#include \"scalar_low_impl.h\"\n+#elif defined(USE_SCALAR_4X64)\n #include \"scalar_4x64_impl.h\"\n #elif defined(USE_SCALAR_8X32)\n #include \"scalar_8x32_impl.h\"\n@@ -33,17 +33,37 @@ static void secp256k1_scalar_get_num(secp256k1_num *r, const secp256k1_scalar *a\n \n /** secp256k1 curve order, see secp256k1_ecdsa_const_order_as_fe in ecdsa_impl.h */\n static void secp256k1_scalar_order_get_num(secp256k1_num *r) {\n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+    static const unsigned char order[32] = {\n+        0,0,0,0,0,0,0,0,\n+        0,0,0,0,0,0,0,0,\n+        0,0,0,0,0,0,0,0,\n+        0,0,0,0,0,0,0,EXHAUSTIVE_TEST_ORDER\n+    };\n+#else\n     static const unsigned char order[32] = {\n         0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n         0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,\n         0xBA,0xAE,0xDC,0xE6,0xAF,0x48,0xA0,0x3B,\n         0xBF,0xD2,0x5E,0x8C,0xD0,0x36,0x41,0x41\n     };\n+#endif\n     secp256k1_num_set_bin(r, order, 32);\n }\n #endif\n \n static void secp256k1_scalar_inverse(secp256k1_scalar *r, const secp256k1_scalar *x) {\n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+    int i;\n+    *r = 0;\n+    for (i = 0; i < EXHAUSTIVE_TEST_ORDER; i++)\n+        if ((i * *x) % EXHAUSTIVE_TEST_ORDER == 1)\n+            *r = i;\n+    /* If this VERIFY_CHECK triggers we were given a noninvertible scalar (and thus\n+     * have a composite group order; fix it in exhaustive_tests.c). */\n+    VERIFY_CHECK(*r != 0);\n+}\n+#else\n     secp256k1_scalar *t;\n     int i;\n     /* First compute x ^ (2^N - 1) for some values of N. */\n@@ -235,9 +255,9 @@ static void secp256k1_scalar_inverse(secp256k1_scalar *r, const secp256k1_scalar\n }\n \n SECP256K1_INLINE static int secp256k1_scalar_is_even(const secp256k1_scalar *a) {\n-    /* d[0] is present and is the lowest word for all representations */\n     return !(a->d[0] & 1);\n }\n+#endif\n \n static void secp256k1_scalar_inverse_var(secp256k1_scalar *r, const secp256k1_scalar *x) {\n #if defined(USE_SCALAR_INV_BUILTIN)\n@@ -261,6 +281,18 @@ static void secp256k1_scalar_inverse_var(secp256k1_scalar *r, const secp256k1_sc\n }\n \n #ifdef USE_ENDOMORPHISM\n+#if defined(EXHAUSTIVE_TEST_ORDER)\n+/**\n+ * Find k1 and k2 given k, such that k1 + k2 * lambda == k mod n; unlike in the\n+ * full case we don't bother making k1 and k2 be small, we just want them to be\n+ * nontrivial to get full test coverage for the exhaustive tests. We therefore\n+ * (arbitrarily) set k2 = k + 5 and k1 = k - k2 * lambda.\n+ */\n+static void secp256k1_scalar_split_lambda(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *a) {\n+    *r2 = (*a + 5) % EXHAUSTIVE_TEST_ORDER;\n+    *r1 = (*a + (EXHAUSTIVE_TEST_ORDER - *r2) * EXHAUSTIVE_TEST_LAMBDA) % EXHAUSTIVE_TEST_ORDER;\n+}\n+#else\n /**\n  * The Secp256k1 curve has an endomorphism, where lambda * (x, y) = (beta * x, y), where\n  * lambda is {0x53,0x63,0xad,0x4c,0xc0,0x5c,0x30,0xe0,0xa5,0x26,0x1c,0x02,0x88,0x12,0x64,0x5a,\n@@ -333,5 +365,6 @@ static void secp256k1_scalar_split_lambda(secp256k1_scalar *r1, secp256k1_scalar\n     secp256k1_scalar_add(r1, r1, a);\n }\n #endif\n+#endif\n \n #endif"
      },
      {
        "sha": "5574c44c7aeb3c8d41ec626adcb1b6994b6f05ef",
        "filename": "src/secp256k1/src/scalar_low.h",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/scalar_low.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/scalar_low.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_low.h?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -0,0 +1,15 @@\n+/**********************************************************************\n+ * Copyright (c) 2015 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_SCALAR_REPR_\n+#define _SECP256K1_SCALAR_REPR_\n+\n+#include <stdint.h>\n+\n+/** A scalar modulo the group order of the secp256k1 curve. */\n+typedef uint32_t secp256k1_scalar;\n+\n+#endif"
      },
      {
        "sha": "4f94441f492a8144ebe579435ead2a66712eea17",
        "filename": "src/secp256k1/src/scalar_low_impl.h",
        "status": "added",
        "additions": 114,
        "deletions": 0,
        "changes": 114,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/scalar_low_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/scalar_low_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_low_impl.h?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -0,0 +1,114 @@\n+/**********************************************************************\n+ * Copyright (c) 2015 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_SCALAR_REPR_IMPL_H_\n+#define _SECP256K1_SCALAR_REPR_IMPL_H_\n+\n+#include \"scalar.h\"\n+\n+#include <string.h>\n+\n+SECP256K1_INLINE static int secp256k1_scalar_is_even(const secp256k1_scalar *a) {\n+    return !(*a & 1);\n+}\n+\n+SECP256K1_INLINE static void secp256k1_scalar_clear(secp256k1_scalar *r) { *r = 0; }\n+SECP256K1_INLINE static void secp256k1_scalar_set_int(secp256k1_scalar *r, unsigned int v) { *r = v; }\n+\n+SECP256K1_INLINE static unsigned int secp256k1_scalar_get_bits(const secp256k1_scalar *a, unsigned int offset, unsigned int count) {\n+    if (offset < 32)\n+        return ((*a >> offset) & ((((uint32_t)1) << count) - 1));\n+    else\n+        return 0;\n+}\n+\n+SECP256K1_INLINE static unsigned int secp256k1_scalar_get_bits_var(const secp256k1_scalar *a, unsigned int offset, unsigned int count) {\n+    return secp256k1_scalar_get_bits(a, offset, count);\n+}\n+\n+SECP256K1_INLINE static int secp256k1_scalar_check_overflow(const secp256k1_scalar *a) { return *a >= EXHAUSTIVE_TEST_ORDER; }\n+\n+static int secp256k1_scalar_add(secp256k1_scalar *r, const secp256k1_scalar *a, const secp256k1_scalar *b) {\n+    *r = (*a + *b) % EXHAUSTIVE_TEST_ORDER;\n+    return *r < *b;\n+}\n+\n+static void secp256k1_scalar_cadd_bit(secp256k1_scalar *r, unsigned int bit, int flag) {\n+    if (flag && bit < 32)\n+        *r += (1 << bit);\n+#ifdef VERIFY\n+    VERIFY_CHECK(secp256k1_scalar_check_overflow(r) == 0);\n+#endif\n+}\n+\n+static void secp256k1_scalar_set_b32(secp256k1_scalar *r, const unsigned char *b32, int *overflow) {\n+    const int base = 0x100 % EXHAUSTIVE_TEST_ORDER;\n+    int i;\n+    *r = 0;\n+    for (i = 0; i < 32; i++) {\n+       *r = ((*r * base) + b32[i]) % EXHAUSTIVE_TEST_ORDER;\n+    }\n+    /* just deny overflow, it basically always happens */\n+    if (overflow) *overflow = 0;\n+}\n+\n+static void secp256k1_scalar_get_b32(unsigned char *bin, const secp256k1_scalar* a) {\n+    memset(bin, 0, 32);\n+    bin[28] = *a >> 24; bin[29] = *a >> 16; bin[30] = *a >> 8; bin[31] = *a;\n+}\n+\n+SECP256K1_INLINE static int secp256k1_scalar_is_zero(const secp256k1_scalar *a) {\n+    return *a == 0;\n+}\n+\n+static void secp256k1_scalar_negate(secp256k1_scalar *r, const secp256k1_scalar *a) {\n+    if (*a == 0) {\n+        *r = 0;\n+    } else {\n+        *r = EXHAUSTIVE_TEST_ORDER - *a;\n+    }\n+}\n+\n+SECP256K1_INLINE static int secp256k1_scalar_is_one(const secp256k1_scalar *a) {\n+    return *a == 1;\n+}\n+\n+static int secp256k1_scalar_is_high(const secp256k1_scalar *a) {\n+    return *a > EXHAUSTIVE_TEST_ORDER / 2;\n+}\n+\n+static int secp256k1_scalar_cond_negate(secp256k1_scalar *r, int flag) {\n+    if (flag) secp256k1_scalar_negate(r, r);\n+    return flag ? -1 : 1;\n+}\n+\n+static void secp256k1_scalar_mul(secp256k1_scalar *r, const secp256k1_scalar *a, const secp256k1_scalar *b) {\n+    *r = (*a * *b) % EXHAUSTIVE_TEST_ORDER;\n+}\n+\n+static int secp256k1_scalar_shr_int(secp256k1_scalar *r, int n) {\n+    int ret;\n+    VERIFY_CHECK(n > 0);\n+    VERIFY_CHECK(n < 16);\n+    ret = *r & ((1 << n) - 1);\n+    *r >>= n;\n+    return ret;\n+}\n+\n+static void secp256k1_scalar_sqr(secp256k1_scalar *r, const secp256k1_scalar *a) {\n+    *r = (*a * *a) % EXHAUSTIVE_TEST_ORDER;\n+}\n+\n+static void secp256k1_scalar_split_128(secp256k1_scalar *r1, secp256k1_scalar *r2, const secp256k1_scalar *a) {\n+    *r1 = *a;\n+    *r2 = 0;\n+}\n+\n+SECP256K1_INLINE static int secp256k1_scalar_eq(const secp256k1_scalar *a, const secp256k1_scalar *b) {\n+    return *a == *b;\n+}\n+\n+#endif"
      },
      {
        "sha": "fb8b882faafd36d8b60476e1df024829b32326e0",
        "filename": "src/secp256k1/src/secp256k1.c",
        "status": "modified",
        "additions": 6,
        "deletions": 13,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/secp256k1.c?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -4,8 +4,6 @@\n  * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n  **********************************************************************/\n \n-#define SECP256K1_BUILD (1)\n-\n #include \"include/secp256k1.h\"\n \n #include \"util.h\"\n@@ -152,7 +150,6 @@ static void secp256k1_pubkey_save(secp256k1_pubkey* pubkey, secp256k1_ge* ge) {\n int secp256k1_ec_pubkey_parse(const secp256k1_context* ctx, secp256k1_pubkey* pubkey, const unsigned char *input, size_t inputlen) {\n     secp256k1_ge Q;\n \n-    (void)ctx;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(pubkey != NULL);\n     memset(pubkey, 0, sizeof(*pubkey));\n@@ -170,7 +167,6 @@ int secp256k1_ec_pubkey_serialize(const secp256k1_context* ctx, unsigned char *o\n     size_t len;\n     int ret = 0;\n \n-    (void)ctx;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(outputlen != NULL);\n     ARG_CHECK(*outputlen >= ((flags & SECP256K1_FLAGS_BIT_COMPRESSION) ? 33 : 65));\n@@ -216,7 +212,7 @@ static void secp256k1_ecdsa_signature_save(secp256k1_ecdsa_signature* sig, const\n int secp256k1_ecdsa_signature_parse_der(const secp256k1_context* ctx, secp256k1_ecdsa_signature* sig, const unsigned char *input, size_t inputlen) {\n     secp256k1_scalar r, s;\n \n-    (void)ctx;\n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(sig != NULL);\n     ARG_CHECK(input != NULL);\n \n@@ -234,7 +230,7 @@ int secp256k1_ecdsa_signature_parse_compact(const secp256k1_context* ctx, secp25\n     int ret = 1;\n     int overflow = 0;\n \n-    (void)ctx;\n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(sig != NULL);\n     ARG_CHECK(input64 != NULL);\n \n@@ -253,7 +249,7 @@ int secp256k1_ecdsa_signature_parse_compact(const secp256k1_context* ctx, secp25\n int secp256k1_ecdsa_signature_serialize_der(const secp256k1_context* ctx, unsigned char *output, size_t *outputlen, const secp256k1_ecdsa_signature* sig) {\n     secp256k1_scalar r, s;\n \n-    (void)ctx;\n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(output != NULL);\n     ARG_CHECK(outputlen != NULL);\n     ARG_CHECK(sig != NULL);\n@@ -265,7 +261,7 @@ int secp256k1_ecdsa_signature_serialize_der(const secp256k1_context* ctx, unsign\n int secp256k1_ecdsa_signature_serialize_compact(const secp256k1_context* ctx, unsigned char *output64, const secp256k1_ecdsa_signature* sig) {\n     secp256k1_scalar r, s;\n \n-    (void)ctx;\n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(output64 != NULL);\n     ARG_CHECK(sig != NULL);\n \n@@ -363,23 +359,23 @@ int secp256k1_ecdsa_sign(const secp256k1_context* ctx, secp256k1_ecdsa_signature\n     secp256k1_scalar_set_b32(&sec, seckey, &overflow);\n     /* Fail if the secret key is invalid. */\n     if (!overflow && !secp256k1_scalar_is_zero(&sec)) {\n+        unsigned char nonce32[32];\n         unsigned int count = 0;\n         secp256k1_scalar_set_b32(&msg, msg32, NULL);\n         while (1) {\n-            unsigned char nonce32[32];\n             ret = noncefp(nonce32, msg32, seckey, NULL, (void*)noncedata, count);\n             if (!ret) {\n                 break;\n             }\n             secp256k1_scalar_set_b32(&non, nonce32, &overflow);\n-            memset(nonce32, 0, 32);\n             if (!overflow && !secp256k1_scalar_is_zero(&non)) {\n                 if (secp256k1_ecdsa_sig_sign(&ctx->ecmult_gen_ctx, &r, &s, &sec, &msg, &non, NULL)) {\n                     break;\n                 }\n             }\n             count++;\n         }\n+        memset(nonce32, 0, 32);\n         secp256k1_scalar_clear(&msg);\n         secp256k1_scalar_clear(&non);\n         secp256k1_scalar_clear(&sec);\n@@ -398,7 +394,6 @@ int secp256k1_ec_seckey_verify(const secp256k1_context* ctx, const unsigned char\n     int overflow;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(seckey != NULL);\n-    (void)ctx;\n \n     secp256k1_scalar_set_b32(&sec, seckey, &overflow);\n     ret = !overflow && !secp256k1_scalar_is_zero(&sec);\n@@ -437,7 +432,6 @@ int secp256k1_ec_privkey_tweak_add(const secp256k1_context* ctx, unsigned char *\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(seckey != NULL);\n     ARG_CHECK(tweak != NULL);\n-    (void)ctx;\n \n     secp256k1_scalar_set_b32(&term, tweak, &overflow);\n     secp256k1_scalar_set_b32(&sec, seckey, NULL);\n@@ -485,7 +479,6 @@ int secp256k1_ec_privkey_tweak_mul(const secp256k1_context* ctx, unsigned char *\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(seckey != NULL);\n     ARG_CHECK(tweak != NULL);\n-    (void)ctx;\n \n     secp256k1_scalar_set_b32(&factor, tweak, &overflow);\n     secp256k1_scalar_set_b32(&sec, seckey, NULL);"
      },
      {
        "sha": "9ae7d3028130637ba1159c4c9772cf94267e3711",
        "filename": "src/secp256k1/src/tests.c",
        "status": "modified",
        "additions": 172,
        "deletions": 30,
        "changes": 202,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests.c?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -473,6 +473,8 @@ void test_num_negate(void) {\n }\n \n void test_num_add_sub(void) {\n+    int i;\n+    secp256k1_scalar s;\n     secp256k1_num n1;\n     secp256k1_num n2;\n     secp256k1_num n1p2, n2p1, n1m2, n2m1;\n@@ -498,13 +500,119 @@ void test_num_add_sub(void) {\n     CHECK(!secp256k1_num_eq(&n2p1, &n1));\n     secp256k1_num_sub(&n2p1, &n2p1, &n2); /* n2p1 = R2 + R1 - R2 = R1 */\n     CHECK(secp256k1_num_eq(&n2p1, &n1));\n+\n+    /* check is_one */\n+    secp256k1_scalar_set_int(&s, 1);\n+    secp256k1_scalar_get_num(&n1, &s);\n+    CHECK(secp256k1_num_is_one(&n1));\n+    /* check that 2^n + 1 is never 1 */\n+    secp256k1_scalar_get_num(&n2, &s);\n+    for (i = 0; i < 250; ++i) {\n+        secp256k1_num_add(&n1, &n1, &n1);    /* n1 *= 2 */\n+        secp256k1_num_add(&n1p2, &n1, &n2);  /* n1p2 = n1 + 1 */\n+        CHECK(!secp256k1_num_is_one(&n1p2));\n+    }\n+}\n+\n+void test_num_mod(void) {\n+    int i;\n+    secp256k1_scalar s;\n+    secp256k1_num order, n;\n+\n+    /* check that 0 mod anything is 0 */\n+    random_scalar_order_test(&s);\n+    secp256k1_scalar_get_num(&order, &s);\n+    secp256k1_scalar_set_int(&s, 0);\n+    secp256k1_scalar_get_num(&n, &s);\n+    secp256k1_num_mod(&n, &order);\n+    CHECK(secp256k1_num_is_zero(&n));\n+\n+    /* check that anything mod 1 is 0 */\n+    secp256k1_scalar_set_int(&s, 1);\n+    secp256k1_scalar_get_num(&order, &s);\n+    secp256k1_scalar_get_num(&n, &s);\n+    secp256k1_num_mod(&n, &order);\n+    CHECK(secp256k1_num_is_zero(&n));\n+\n+    /* check that increasing the number past 2^256 does not break this */\n+    random_scalar_order_test(&s);\n+    secp256k1_scalar_get_num(&n, &s);\n+    /* multiply by 2^8, which'll test this case with high probability */\n+    for (i = 0; i < 8; ++i) {\n+        secp256k1_num_add(&n, &n, &n);\n+    }\n+    secp256k1_num_mod(&n, &order);\n+    CHECK(secp256k1_num_is_zero(&n));\n+}\n+\n+void test_num_jacobi(void) {\n+    secp256k1_scalar sqr;\n+    secp256k1_scalar small;\n+    secp256k1_scalar five;  /* five is not a quadratic residue */\n+    secp256k1_num order, n;\n+    int i;\n+    /* squares mod 5 are 1, 4 */\n+    const int jacobi5[10] = { 0, 1, -1, -1, 1, 0, 1, -1, -1, 1 };\n+\n+    /* check some small values with 5 as the order */\n+    secp256k1_scalar_set_int(&five, 5);\n+    secp256k1_scalar_get_num(&order, &five);\n+    for (i = 0; i < 10; ++i) {\n+        secp256k1_scalar_set_int(&small, i);\n+        secp256k1_scalar_get_num(&n, &small);\n+        CHECK(secp256k1_num_jacobi(&n, &order) == jacobi5[i]);\n+    }\n+\n+    /** test large values with 5 as group order */\n+    secp256k1_scalar_get_num(&order, &five);\n+    /* we first need a scalar which is not a multiple of 5 */\n+    do {\n+        secp256k1_num fiven;\n+        random_scalar_order_test(&sqr);\n+        secp256k1_scalar_get_num(&fiven, &five);\n+        secp256k1_scalar_get_num(&n, &sqr);\n+        secp256k1_num_mod(&n, &fiven);\n+    } while (secp256k1_num_is_zero(&n));\n+    /* next force it to be a residue. 2 is a nonresidue mod 5 so we can\n+     * just multiply by two, i.e. add the number to itself */\n+    if (secp256k1_num_jacobi(&n, &order) == -1) {\n+        secp256k1_num_add(&n, &n, &n);\n+    }\n+\n+    /* test residue */\n+    CHECK(secp256k1_num_jacobi(&n, &order) == 1);\n+    /* test nonresidue */\n+    secp256k1_num_add(&n, &n, &n);\n+    CHECK(secp256k1_num_jacobi(&n, &order) == -1);\n+\n+    /** test with secp group order as order */\n+    secp256k1_scalar_order_get_num(&order);\n+    random_scalar_order_test(&sqr);\n+    secp256k1_scalar_sqr(&sqr, &sqr);\n+    /* test residue */\n+    secp256k1_scalar_get_num(&n, &sqr);\n+    CHECK(secp256k1_num_jacobi(&n, &order) == 1);\n+    /* test nonresidue */\n+    secp256k1_scalar_mul(&sqr, &sqr, &five);\n+    secp256k1_scalar_get_num(&n, &sqr);\n+    CHECK(secp256k1_num_jacobi(&n, &order) == -1);\n+    /* test multiple of the order*/\n+    CHECK(secp256k1_num_jacobi(&order, &order) == 0);\n+\n+    /* check one less than the order */\n+    secp256k1_scalar_set_int(&small, 1);\n+    secp256k1_scalar_get_num(&n, &small);\n+    secp256k1_num_sub(&n, &order, &n);\n+    CHECK(secp256k1_num_jacobi(&n, &order) == 1);  /* sage confirms this is 1 */\n }\n \n void run_num_smalltests(void) {\n     int i;\n     for (i = 0; i < 100*count; i++) {\n         test_num_negate();\n         test_num_add_sub();\n+        test_num_mod();\n+        test_num_jacobi();\n     }\n }\n #endif\n@@ -689,6 +797,10 @@ void scalar_test(void) {\n             secp256k1_scalar_inverse(&inv, &inv);\n             /* Inverting one must result in one. */\n             CHECK(secp256k1_scalar_is_one(&inv));\n+#ifndef USE_NUM_NONE\n+            secp256k1_scalar_get_num(&invnum, &inv);\n+            CHECK(secp256k1_num_is_one(&invnum));\n+#endif\n         }\n     }\n \n@@ -855,7 +967,7 @@ void run_scalar_tests(void) {\n         secp256k1_scalar zzv;\n #endif\n         int overflow;\n-        unsigned char chal[32][2][32] = {\n+        unsigned char chal[33][2][32] = {\n             {{0xff, 0xff, 0x03, 0x07, 0x00, 0x00, 0x00, 0x00,\n               0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03,\n               0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff,\n@@ -1111,9 +1223,17 @@ void run_scalar_tests(void) {\n              {0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff,\n               0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0x00,\n               0xf8, 0x07, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff,\n-              0xff, 0xc7, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff}}\n+              0xff, 0xc7, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff}},\n+            {{0x82, 0xc9, 0xfa, 0xb0, 0x68, 0x04, 0xa0, 0x00,\n+              0x82, 0xc9, 0xfa, 0xb0, 0x68, 0x04, 0xa0, 0x00,\n+              0xff, 0xff, 0xff, 0xff, 0xff, 0x6f, 0x03, 0xfb,\n+              0xfa, 0x8a, 0x7d, 0xdf, 0x13, 0x86, 0xe2, 0x03},\n+             {0x82, 0xc9, 0xfa, 0xb0, 0x68, 0x04, 0xa0, 0x00,\n+              0x82, 0xc9, 0xfa, 0xb0, 0x68, 0x04, 0xa0, 0x00,\n+              0xff, 0xff, 0xff, 0xff, 0xff, 0x6f, 0x03, 0xfb,\n+              0xfa, 0x8a, 0x7d, 0xdf, 0x13, 0x86, 0xe2, 0x03}}\n         };\n-        unsigned char res[32][2][32] = {\n+        unsigned char res[33][2][32] = {\n             {{0x0c, 0x3b, 0x0a, 0xca, 0x8d, 0x1a, 0x2f, 0xb9,\n               0x8a, 0x7b, 0x53, 0x5a, 0x1f, 0xc5, 0x22, 0xa1,\n               0x07, 0x2a, 0x48, 0xea, 0x02, 0xeb, 0xb3, 0xd6,\n@@ -1369,10 +1489,18 @@ void run_scalar_tests(void) {\n              {0xe4, 0xf1, 0x23, 0x84, 0xe1, 0xb5, 0x9d, 0xf2,\n               0xb8, 0x73, 0x8b, 0x45, 0x2b, 0x35, 0x46, 0x38,\n               0x10, 0x2b, 0x50, 0xf8, 0x8b, 0x35, 0xcd, 0x34,\n-              0xc8, 0x0e, 0xf6, 0xdb, 0x09, 0x35, 0xf0, 0xda}}\n+              0xc8, 0x0e, 0xf6, 0xdb, 0x09, 0x35, 0xf0, 0xda}},\n+            {{0xdb, 0x21, 0x5c, 0x8d, 0x83, 0x1d, 0xb3, 0x34,\n+              0xc7, 0x0e, 0x43, 0xa1, 0x58, 0x79, 0x67, 0x13,\n+              0x1e, 0x86, 0x5d, 0x89, 0x63, 0xe6, 0x0a, 0x46,\n+              0x5c, 0x02, 0x97, 0x1b, 0x62, 0x43, 0x86, 0xf5},\n+             {0xdb, 0x21, 0x5c, 0x8d, 0x83, 0x1d, 0xb3, 0x34,\n+              0xc7, 0x0e, 0x43, 0xa1, 0x58, 0x79, 0x67, 0x13,\n+              0x1e, 0x86, 0x5d, 0x89, 0x63, 0xe6, 0x0a, 0x46,\n+              0x5c, 0x02, 0x97, 0x1b, 0x62, 0x43, 0x86, 0xf5}}\n         };\n         secp256k1_scalar_set_int(&one, 1);\n-        for (i = 0; i < 32; i++) {\n+        for (i = 0; i < 33; i++) {\n             secp256k1_scalar_set_b32(&x, chal[i][0], &overflow);\n             CHECK(!overflow);\n             secp256k1_scalar_set_b32(&y, chal[i][1], &overflow);\n@@ -1446,7 +1574,7 @@ void random_fe_non_zero(secp256k1_fe *nz) {\n void random_fe_non_square(secp256k1_fe *ns) {\n     secp256k1_fe r;\n     random_fe_non_zero(ns);\n-    if (secp256k1_fe_sqrt_var(&r, ns)) {\n+    if (secp256k1_fe_sqrt(&r, ns)) {\n         secp256k1_fe_negate(ns, ns, 1);\n     }\n }\n@@ -1605,18 +1733,18 @@ void run_field_inv_all_var(void) {\n     secp256k1_fe x[16], xi[16], xii[16];\n     int i;\n     /* Check it's safe to call for 0 elements */\n-    secp256k1_fe_inv_all_var(0, xi, x);\n+    secp256k1_fe_inv_all_var(xi, x, 0);\n     for (i = 0; i < count; i++) {\n         size_t j;\n         size_t len = secp256k1_rand_int(15) + 1;\n         for (j = 0; j < len; j++) {\n             random_fe_non_zero(&x[j]);\n         }\n-        secp256k1_fe_inv_all_var(len, xi, x);\n+        secp256k1_fe_inv_all_var(xi, x, len);\n         for (j = 0; j < len; j++) {\n             CHECK(check_fe_inverse(&x[j], &xi[j]));\n         }\n-        secp256k1_fe_inv_all_var(len, xii, xi);\n+        secp256k1_fe_inv_all_var(xii, xi, len);\n         for (j = 0; j < len; j++) {\n             CHECK(check_fe_equal(&x[j], &xii[j]));\n         }\n@@ -1641,7 +1769,7 @@ void run_sqr(void) {\n \n void test_sqrt(const secp256k1_fe *a, const secp256k1_fe *k) {\n     secp256k1_fe r1, r2;\n-    int v = secp256k1_fe_sqrt_var(&r1, a);\n+    int v = secp256k1_fe_sqrt(&r1, a);\n     CHECK((v == 0) == (k == NULL));\n \n     if (k != NULL) {\n@@ -1802,7 +1930,7 @@ void test_ge(void) {\n                 zs[i] = gej[i].z;\n             }\n         }\n-        secp256k1_fe_inv_all_var(4 * runs + 1, zinv, zs);\n+        secp256k1_fe_inv_all_var(zinv, zs, 4 * runs + 1);\n         free(zs);\n     }\n \n@@ -1922,8 +2050,8 @@ void test_ge(void) {\n                 secp256k1_fe_mul(&zr[i + 1], &zinv[i], &gej[i + 1].z);\n             }\n         }\n-        secp256k1_ge_set_table_gej_var(4 * runs + 1, ge_set_table, gej, zr);\n-        secp256k1_ge_set_all_gej_var(4 * runs + 1, ge_set_all, gej, &ctx->error_callback);\n+        secp256k1_ge_set_table_gej_var(ge_set_table, gej, zr, 4 * runs + 1);\n+        secp256k1_ge_set_all_gej_var(ge_set_all, gej, 4 * runs + 1, &ctx->error_callback);\n         for (i = 0; i < 4 * runs + 1; i++) {\n             secp256k1_fe s;\n             random_fe_non_zero(&s);\n@@ -1951,8 +2079,8 @@ void test_add_neg_y_diff_x(void) {\n      * of the sum to be wrong (since infinity has no xy coordinates).\n      * HOWEVER, if the x-coordinates are different, infinity is the\n      * wrong answer, and such degeneracies are exposed. This is the\n-     * root of https://github.com/bitcoin/secp256k1/issues/257 which\n-     * this test is a regression test for.\n+     * root of https://github.com/bitcoin-core/secp256k1/issues/257\n+     * which this test is a regression test for.\n      *\n      * These points were generated in sage as\n      * # secp256k1 params\n@@ -2051,15 +2179,16 @@ void run_ec_combine(void) {\n void test_group_decompress(const secp256k1_fe* x) {\n     /* The input itself, normalized. */\n     secp256k1_fe fex = *x;\n-    secp256k1_fe tmp;\n+    secp256k1_fe fez;\n     /* Results of set_xquad_var, set_xo_var(..., 0), set_xo_var(..., 1). */\n     secp256k1_ge ge_quad, ge_even, ge_odd;\n+    secp256k1_gej gej_quad;\n     /* Return values of the above calls. */\n     int res_quad, res_even, res_odd;\n \n     secp256k1_fe_normalize_var(&fex);\n \n-    res_quad = secp256k1_ge_set_xquad_var(&ge_quad, &fex);\n+    res_quad = secp256k1_ge_set_xquad(&ge_quad, &fex);\n     res_even = secp256k1_ge_set_xo_var(&ge_even, &fex, 0);\n     res_odd = secp256k1_ge_set_xo_var(&ge_odd, &fex, 1);\n \n@@ -2085,13 +2214,29 @@ void test_group_decompress(const secp256k1_fe* x) {\n         CHECK(secp256k1_fe_equal_var(&ge_odd.x, x));\n \n         /* Check that the Y coordinate result in ge_quad is a square. */\n-        CHECK(secp256k1_fe_sqrt_var(&tmp, &ge_quad.y));\n-        secp256k1_fe_sqr(&tmp, &tmp);\n-        CHECK(secp256k1_fe_equal_var(&tmp, &ge_quad.y));\n+        CHECK(secp256k1_fe_is_quad_var(&ge_quad.y));\n \n         /* Check odd/even Y in ge_odd, ge_even. */\n         CHECK(secp256k1_fe_is_odd(&ge_odd.y));\n         CHECK(!secp256k1_fe_is_odd(&ge_even.y));\n+\n+        /* Check secp256k1_gej_has_quad_y_var. */\n+        secp256k1_gej_set_ge(&gej_quad, &ge_quad);\n+        CHECK(secp256k1_gej_has_quad_y_var(&gej_quad));\n+        do {\n+            random_fe_test(&fez);\n+        } while (secp256k1_fe_is_zero(&fez));\n+        secp256k1_gej_rescale(&gej_quad, &fez);\n+        CHECK(secp256k1_gej_has_quad_y_var(&gej_quad));\n+        secp256k1_gej_neg(&gej_quad, &gej_quad);\n+        CHECK(!secp256k1_gej_has_quad_y_var(&gej_quad));\n+        do {\n+            random_fe_test(&fez);\n+        } while (secp256k1_fe_is_zero(&fez));\n+        secp256k1_gej_rescale(&gej_quad, &fez);\n+        CHECK(!secp256k1_gej_has_quad_y_var(&gej_quad));\n+        secp256k1_gej_neg(&gej_quad, &gej_quad);\n+        CHECK(secp256k1_gej_has_quad_y_var(&gej_quad));\n     }\n }\n \n@@ -2383,9 +2528,7 @@ void test_constant_wnaf(const secp256k1_scalar *number, int w) {\n     secp256k1_scalar x, shift;\n     int wnaf[256] = {0};\n     int i;\n-#ifdef USE_ENDOMORPHISM\n     int skew;\n-#endif\n     secp256k1_scalar num = *number;\n \n     secp256k1_scalar_set_int(&x, 0);\n@@ -2395,10 +2538,8 @@ void test_constant_wnaf(const secp256k1_scalar *number, int w) {\n     for (i = 0; i < 16; ++i) {\n         secp256k1_scalar_shr_int(&num, 8);\n     }\n-    skew = secp256k1_wnaf_const(wnaf, num, w);\n-#else\n-    secp256k1_wnaf_const(wnaf, num, w);\n #endif\n+    skew = secp256k1_wnaf_const(wnaf, num, w);\n \n     for (i = WNAF_SIZE(w); i >= 0; --i) {\n         secp256k1_scalar t;\n@@ -2417,10 +2558,8 @@ void test_constant_wnaf(const secp256k1_scalar *number, int w) {\n         }\n         secp256k1_scalar_add(&x, &x, &t);\n     }\n-#ifdef USE_ENDOMORPHISM\n-    /* Skew num because when encoding 128-bit numbers as odd we use an offset */\n+    /* Skew num because when encoding numbers as odd we use an offset */\n     secp256k1_scalar_cadd_bit(&num, skew == 2, 1);\n-#endif\n     CHECK(secp256k1_scalar_eq(&x, &num));\n }\n \n@@ -3484,12 +3623,14 @@ void run_ecdsa_end_to_end(void) {\n \n int test_ecdsa_der_parse(const unsigned char *sig, size_t siglen, int certainly_der, int certainly_not_der) {\n     static const unsigned char zeroes[32] = {0};\n+#ifdef ENABLE_OPENSSL_TESTS\n     static const unsigned char max_scalar[32] = {\n         0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n         0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,\n         0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b,\n         0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x40\n     };\n+#endif\n \n     int ret = 0;\n \n@@ -3607,13 +3748,13 @@ static void assign_big_endian(unsigned char *ptr, size_t ptrlen, uint32_t val) {\n static void damage_array(unsigned char *sig, size_t *len) {\n     int pos;\n     int action = secp256k1_rand_bits(3);\n-    if (action < 1) {\n+    if (action < 1 && *len > 3) {\n         /* Delete a byte. */\n         pos = secp256k1_rand_int(*len);\n         memmove(sig + pos, sig + pos + 1, *len - pos - 1);\n         (*len)--;\n         return;\n-    } else if (action < 2) {\n+    } else if (action < 2 && *len < 2048) {\n         /* Insert a byte. */\n         pos = secp256k1_rand_int(1 + *len);\n         memmove(sig + pos + 1, sig + pos, *len - pos);\n@@ -3785,6 +3926,7 @@ void run_ecdsa_der_parse(void) {\n         int certainly_der = 0;\n         int certainly_not_der = 0;\n         random_ber_signature(buffer, &buflen, &certainly_der, &certainly_not_der);\n+        CHECK(buflen <= 2048);\n         for (j = 0; j < 16; j++) {\n             int ret = 0;\n             if (j > 0) {"
      },
      {
        "sha": "bda6ee475c9c0fb5c85eb4944f0746107cff6b42",
        "filename": "src/secp256k1/src/tests_exhaustive.c",
        "status": "added",
        "additions": 329,
        "deletions": 0,
        "changes": 329,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/tests_exhaustive.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fad80b3a1e531e699af52086cc988c63f15e939d/src/secp256k1/src/tests_exhaustive.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests_exhaustive.c?ref=fad80b3a1e531e699af52086cc988c63f15e939d",
        "patch": "@@ -0,0 +1,329 @@\n+/***********************************************************************\n+ * Copyright (c) 2016 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#if defined HAVE_CONFIG_H\n+#include \"libsecp256k1-config.h\"\n+#endif\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+#include <time.h>\n+\n+#undef USE_ECMULT_STATIC_PRECOMPUTATION\n+\n+#ifndef EXHAUSTIVE_TEST_ORDER\n+/* see group_impl.h for allowable values */\n+#define EXHAUSTIVE_TEST_ORDER 13\n+#define EXHAUSTIVE_TEST_LAMBDA 9   /* cube root of 1 mod 13 */\n+#endif\n+\n+#include \"include/secp256k1.h\"\n+#include \"group.h\"\n+#include \"secp256k1.c\"\n+#include \"testrand_impl.h\"\n+\n+/** stolen from tests.c */\n+void ge_equals_ge(const secp256k1_ge *a, const secp256k1_ge *b) {\n+    CHECK(a->infinity == b->infinity);\n+    if (a->infinity) {\n+        return;\n+    }\n+    CHECK(secp256k1_fe_equal_var(&a->x, &b->x));\n+    CHECK(secp256k1_fe_equal_var(&a->y, &b->y));\n+}\n+\n+void ge_equals_gej(const secp256k1_ge *a, const secp256k1_gej *b) {\n+    secp256k1_fe z2s;\n+    secp256k1_fe u1, u2, s1, s2;\n+    CHECK(a->infinity == b->infinity);\n+    if (a->infinity) {\n+        return;\n+    }\n+    /* Check a.x * b.z^2 == b.x && a.y * b.z^3 == b.y, to avoid inverses. */\n+    secp256k1_fe_sqr(&z2s, &b->z);\n+    secp256k1_fe_mul(&u1, &a->x, &z2s);\n+    u2 = b->x; secp256k1_fe_normalize_weak(&u2);\n+    secp256k1_fe_mul(&s1, &a->y, &z2s); secp256k1_fe_mul(&s1, &s1, &b->z);\n+    s2 = b->y; secp256k1_fe_normalize_weak(&s2);\n+    CHECK(secp256k1_fe_equal_var(&u1, &u2));\n+    CHECK(secp256k1_fe_equal_var(&s1, &s2));\n+}\n+\n+void random_fe(secp256k1_fe *x) {\n+    unsigned char bin[32];\n+    do {\n+        secp256k1_rand256(bin);\n+        if (secp256k1_fe_set_b32(x, bin)) {\n+            return;\n+        }\n+    } while(1);\n+}\n+/** END stolen from tests.c */\n+\n+int secp256k1_nonce_function_smallint(unsigned char *nonce32, const unsigned char *msg32,\n+                                      const unsigned char *key32, const unsigned char *algo16,\n+                                      void *data, unsigned int attempt) {\n+    secp256k1_scalar s;\n+    int *idata = data;\n+    (void)msg32;\n+    (void)key32;\n+    (void)algo16;\n+    /* Some nonces cannot be used because they'd cause s and/or r to be zero.\n+     * The signing function has retry logic here that just re-calls the nonce\n+     * function with an increased `attempt`. So if attempt > 0 this means we\n+     * need to change the nonce to avoid an infinite loop. */\n+    if (attempt > 0) {\n+        (*idata)++;\n+    }\n+    secp256k1_scalar_set_int(&s, *idata);\n+    secp256k1_scalar_get_b32(nonce32, &s);\n+    return 1;\n+}\n+\n+#ifdef USE_ENDOMORPHISM\n+void test_exhaustive_endomorphism(const secp256k1_ge *group, int order) {\n+    int i;\n+    for (i = 0; i < order; i++) {\n+        secp256k1_ge res;\n+        secp256k1_ge_mul_lambda(&res, &group[i]);\n+        ge_equals_ge(&group[i * EXHAUSTIVE_TEST_LAMBDA % EXHAUSTIVE_TEST_ORDER], &res);\n+    }\n+}\n+#endif\n+\n+void test_exhaustive_addition(const secp256k1_ge *group, const secp256k1_gej *groupj, int order) {\n+    int i, j;\n+\n+    /* Sanity-check (and check infinity functions) */\n+    CHECK(secp256k1_ge_is_infinity(&group[0]));\n+    CHECK(secp256k1_gej_is_infinity(&groupj[0]));\n+    for (i = 1; i < order; i++) {\n+        CHECK(!secp256k1_ge_is_infinity(&group[i]));\n+        CHECK(!secp256k1_gej_is_infinity(&groupj[i]));\n+    }\n+\n+    /* Check all addition formulae */\n+    for (j = 0; j < order; j++) {\n+        secp256k1_fe fe_inv;\n+        secp256k1_fe_inv(&fe_inv, &groupj[j].z);\n+        for (i = 0; i < order; i++) {\n+            secp256k1_ge zless_gej;\n+            secp256k1_gej tmp;\n+            /* add_var */\n+            secp256k1_gej_add_var(&tmp, &groupj[i], &groupj[j], NULL);\n+            ge_equals_gej(&group[(i + j) % order], &tmp);\n+            /* add_ge */\n+            if (j > 0) {\n+                secp256k1_gej_add_ge(&tmp, &groupj[i], &group[j]);\n+                ge_equals_gej(&group[(i + j) % order], &tmp);\n+            }\n+            /* add_ge_var */\n+            secp256k1_gej_add_ge_var(&tmp, &groupj[i], &group[j], NULL);\n+            ge_equals_gej(&group[(i + j) % order], &tmp);\n+            /* add_zinv_var */\n+            zless_gej.infinity = groupj[j].infinity;\n+            zless_gej.x = groupj[j].x;\n+            zless_gej.y = groupj[j].y;\n+            secp256k1_gej_add_zinv_var(&tmp, &groupj[i], &zless_gej, &fe_inv);\n+            ge_equals_gej(&group[(i + j) % order], &tmp);\n+        }\n+    }\n+\n+    /* Check doubling */\n+    for (i = 0; i < order; i++) {\n+        secp256k1_gej tmp;\n+        if (i > 0) {\n+            secp256k1_gej_double_nonzero(&tmp, &groupj[i], NULL);\n+            ge_equals_gej(&group[(2 * i) % order], &tmp);\n+        }\n+        secp256k1_gej_double_var(&tmp, &groupj[i], NULL);\n+        ge_equals_gej(&group[(2 * i) % order], &tmp);\n+    }\n+\n+    /* Check negation */\n+    for (i = 1; i < order; i++) {\n+        secp256k1_ge tmp;\n+        secp256k1_gej tmpj;\n+        secp256k1_ge_neg(&tmp, &group[i]);\n+        ge_equals_ge(&group[order - i], &tmp);\n+        secp256k1_gej_neg(&tmpj, &groupj[i]);\n+        ge_equals_gej(&group[order - i], &tmpj);\n+    }\n+}\n+\n+void test_exhaustive_ecmult(const secp256k1_context *ctx, const secp256k1_ge *group, const secp256k1_gej *groupj, int order) {\n+    int i, j, r_log;\n+    for (r_log = 1; r_log < order; r_log++) {\n+        for (j = 0; j < order; j++) {\n+            for (i = 0; i < order; i++) {\n+                secp256k1_gej tmp;\n+                secp256k1_scalar na, ng;\n+                secp256k1_scalar_set_int(&na, i);\n+                secp256k1_scalar_set_int(&ng, j);\n+\n+                secp256k1_ecmult(&ctx->ecmult_ctx, &tmp, &groupj[r_log], &na, &ng);\n+                ge_equals_gej(&group[(i * r_log + j) % order], &tmp);\n+\n+                if (i > 0) {\n+                    secp256k1_ecmult_const(&tmp, &group[i], &ng);\n+                    ge_equals_gej(&group[(i * j) % order], &tmp);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+void r_from_k(secp256k1_scalar *r, const secp256k1_ge *group, int k) {\n+    secp256k1_fe x;\n+    unsigned char x_bin[32];\n+    k %= EXHAUSTIVE_TEST_ORDER;\n+    x = group[k].x;\n+    secp256k1_fe_normalize(&x);\n+    secp256k1_fe_get_b32(x_bin, &x);\n+    secp256k1_scalar_set_b32(r, x_bin, NULL);\n+}\n+\n+void test_exhaustive_verify(const secp256k1_context *ctx, const secp256k1_ge *group, int order) {\n+    int s, r, msg, key;\n+    for (s = 1; s < order; s++) {\n+        for (r = 1; r < order; r++) {\n+            for (msg = 1; msg < order; msg++) {\n+                for (key = 1; key < order; key++) {\n+                    secp256k1_ge nonconst_ge;\n+                    secp256k1_ecdsa_signature sig;\n+                    secp256k1_pubkey pk;\n+                    secp256k1_scalar sk_s, msg_s, r_s, s_s;\n+                    secp256k1_scalar s_times_k_s, msg_plus_r_times_sk_s;\n+                    int k, should_verify;\n+                    unsigned char msg32[32];\n+\n+                    secp256k1_scalar_set_int(&s_s, s);\n+                    secp256k1_scalar_set_int(&r_s, r);\n+                    secp256k1_scalar_set_int(&msg_s, msg);\n+                    secp256k1_scalar_set_int(&sk_s, key);\n+\n+                    /* Verify by hand */\n+                    /* Run through every k value that gives us this r and check that *one* works.\n+                     * Note there could be none, there could be multiple, ECDSA is weird. */\n+                    should_verify = 0;\n+                    for (k = 0; k < order; k++) {\n+                        secp256k1_scalar check_x_s;\n+                        r_from_k(&check_x_s, group, k);\n+                        if (r_s == check_x_s) {\n+                            secp256k1_scalar_set_int(&s_times_k_s, k);\n+                            secp256k1_scalar_mul(&s_times_k_s, &s_times_k_s, &s_s);\n+                            secp256k1_scalar_mul(&msg_plus_r_times_sk_s, &r_s, &sk_s);\n+                            secp256k1_scalar_add(&msg_plus_r_times_sk_s, &msg_plus_r_times_sk_s, &msg_s);\n+                            should_verify |= secp256k1_scalar_eq(&s_times_k_s, &msg_plus_r_times_sk_s);\n+                        }\n+                    }\n+                    /* nb we have a \"high s\" rule */\n+                    should_verify &= !secp256k1_scalar_is_high(&s_s);\n+\n+                    /* Verify by calling verify */\n+                    secp256k1_ecdsa_signature_save(&sig, &r_s, &s_s);\n+                    memcpy(&nonconst_ge, &group[sk_s], sizeof(nonconst_ge));\n+                    secp256k1_pubkey_save(&pk, &nonconst_ge);\n+                    secp256k1_scalar_get_b32(msg32, &msg_s);\n+                    CHECK(should_verify ==\n+                          secp256k1_ecdsa_verify(ctx, &sig, msg32, &pk));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+void test_exhaustive_sign(const secp256k1_context *ctx, const secp256k1_ge *group, int order) {\n+    int i, j, k;\n+\n+    /* Loop */\n+    for (i = 1; i < order; i++) {  /* message */\n+        for (j = 1; j < order; j++) {  /* key */\n+            for (k = 1; k < order; k++) {  /* nonce */\n+                secp256k1_ecdsa_signature sig;\n+                secp256k1_scalar sk, msg, r, s, expected_r;\n+                unsigned char sk32[32], msg32[32];\n+                secp256k1_scalar_set_int(&msg, i);\n+                secp256k1_scalar_set_int(&sk, j);\n+                secp256k1_scalar_get_b32(sk32, &sk);\n+                secp256k1_scalar_get_b32(msg32, &msg);\n+\n+                secp256k1_ecdsa_sign(ctx, &sig, msg32, sk32, secp256k1_nonce_function_smallint, &k);\n+\n+                secp256k1_ecdsa_signature_load(ctx, &r, &s, &sig);\n+                /* Note that we compute expected_r *after* signing -- this is important\n+                 * because our nonce-computing function function might change k during\n+                 * signing. */\n+                r_from_k(&expected_r, group, k);\n+                CHECK(r == expected_r);\n+                CHECK((k * s) % order == (i + r * j) % order ||\n+                      (k * (EXHAUSTIVE_TEST_ORDER - s)) % order == (i + r * j) % order);\n+            }\n+        }\n+    }\n+\n+    /* We would like to verify zero-knowledge here by counting how often every\n+     * possible (s, r) tuple appears, but because the group order is larger\n+     * than the field order, when coercing the x-values to scalar values, some\n+     * appear more often than others, so we are actually not zero-knowledge.\n+     * (This effect also appears in the real code, but the difference is on the\n+     * order of 1/2^128th the field order, so the deviation is not useful to a\n+     * computationally bounded attacker.)\n+     */\n+}\n+\n+int main(void) {\n+    int i;\n+    secp256k1_gej groupj[EXHAUSTIVE_TEST_ORDER];\n+    secp256k1_ge group[EXHAUSTIVE_TEST_ORDER];\n+\n+    /* Build context */\n+    secp256k1_context *ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+\n+    /* TODO set z = 1, then do num_tests runs with random z values */\n+\n+    /* Generate the entire group */\n+    secp256k1_gej_set_infinity(&groupj[0]);\n+    secp256k1_ge_set_gej(&group[0], &groupj[0]);\n+    for (i = 1; i < EXHAUSTIVE_TEST_ORDER; i++) {\n+        /* Set a different random z-value for each Jacobian point */\n+        secp256k1_fe z;\n+        random_fe(&z);\n+\n+        secp256k1_gej_add_ge(&groupj[i], &groupj[i - 1], &secp256k1_ge_const_g);\n+        secp256k1_ge_set_gej(&group[i], &groupj[i]);\n+        secp256k1_gej_rescale(&groupj[i], &z);\n+\n+        /* Verify against ecmult_gen */\n+        {\n+            secp256k1_scalar scalar_i;\n+            secp256k1_gej generatedj;\n+            secp256k1_ge generated;\n+\n+            secp256k1_scalar_set_int(&scalar_i, i);\n+            secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &generatedj, &scalar_i);\n+            secp256k1_ge_set_gej(&generated, &generatedj);\n+\n+            CHECK(group[i].infinity == 0);\n+            CHECK(generated.infinity == 0);\n+            CHECK(secp256k1_fe_equal_var(&generated.x, &group[i].x));\n+            CHECK(secp256k1_fe_equal_var(&generated.y, &group[i].y));\n+        }\n+    }\n+\n+    /* Run the tests */\n+#ifdef USE_ENDOMORPHISM\n+    test_exhaustive_endomorphism(group, EXHAUSTIVE_TEST_ORDER);\n+#endif\n+    test_exhaustive_addition(group, groupj, EXHAUSTIVE_TEST_ORDER);\n+    test_exhaustive_ecmult(ctx, group, groupj, EXHAUSTIVE_TEST_ORDER);\n+    test_exhaustive_sign(ctx, group, EXHAUSTIVE_TEST_ORDER);\n+    test_exhaustive_verify(ctx, group, EXHAUSTIVE_TEST_ORDER);\n+\n+    return 0;\n+}\n+"
      }
    ]
  }
]