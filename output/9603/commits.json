[
  {
    "sha": "ee6c3c60f19a0da7729254bc065ae536f360b32d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplZTZjM2M2MGYxOWEwZGE3NzI5MjU0YmMwNjVhZTUzNmYzNjBiMzJk",
    "commit": {
      "author": {
        "name": "isle2983",
        "email": "isle2983@yahoo.com",
        "date": "2017-01-20T17:21:03Z"
      },
      "committer": {
        "name": "isle2983",
        "email": "isle2983@yahoo.com",
        "date": "2017-01-20T17:21:03Z"
      },
      "message": "Implement basic_style.py\n\nA script for finding and fixing basic code style violations.",
      "tree": {
        "sha": "66f3015053447bf90ac11bb8667bf5a307a32564",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/66f3015053447bf90ac11bb8667bf5a307a32564"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ee6c3c60f19a0da7729254bc065ae536f360b32d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ee6c3c60f19a0da7729254bc065ae536f360b32d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ee6c3c60f19a0da7729254bc065ae536f360b32d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ee6c3c60f19a0da7729254bc065ae536f360b32d/comments",
    "author": {
      "login": "isle2983",
      "id": 20916903,
      "node_id": "MDQ6VXNlcjIwOTE2OTAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/20916903?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/isle2983",
      "html_url": "https://github.com/isle2983",
      "followers_url": "https://api.github.com/users/isle2983/followers",
      "following_url": "https://api.github.com/users/isle2983/following{/other_user}",
      "gists_url": "https://api.github.com/users/isle2983/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/isle2983/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/isle2983/subscriptions",
      "organizations_url": "https://api.github.com/users/isle2983/orgs",
      "repos_url": "https://api.github.com/users/isle2983/repos",
      "events_url": "https://api.github.com/users/isle2983/events{/privacy}",
      "received_events_url": "https://api.github.com/users/isle2983/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "isle2983",
      "id": 20916903,
      "node_id": "MDQ6VXNlcjIwOTE2OTAz",
      "avatar_url": "https://avatars.githubusercontent.com/u/20916903?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/isle2983",
      "html_url": "https://github.com/isle2983",
      "followers_url": "https://api.github.com/users/isle2983/followers",
      "following_url": "https://api.github.com/users/isle2983/following{/other_user}",
      "gists_url": "https://api.github.com/users/isle2983/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/isle2983/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/isle2983/subscriptions",
      "organizations_url": "https://api.github.com/users/isle2983/orgs",
      "repos_url": "https://api.github.com/users/isle2983/repos",
      "events_url": "https://api.github.com/users/isle2983/events{/privacy}",
      "received_events_url": "https://api.github.com/users/isle2983/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "82274c02ed2d82537dc55f008a29edb1bc09bbc4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/82274c02ed2d82537dc55f008a29edb1bc09bbc4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/82274c02ed2d82537dc55f008a29edb1bc09bbc4"
      }
    ],
    "stats": {
      "total": 508,
      "additions": 508,
      "deletions": 0
    },
    "files": [
      {
        "sha": "d42591b137a07097293516c96142c2cdb5056240",
        "filename": "contrib/devtools/README.md",
        "status": "modified",
        "additions": 36,
        "deletions": 0,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ee6c3c60f19a0da7729254bc065ae536f360b32d/contrib/devtools/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ee6c3c60f19a0da7729254bc065ae536f360b32d/contrib/devtools/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/README.md?ref=ee6c3c60f19a0da7729254bc065ae536f360b32d",
        "patch": "@@ -2,6 +2,42 @@ Contents\n ========\n This directory contains tools for developers working on this repository.\n \n+basic\\_style.py\n+===============\n+\n+Provides utilities for identifying and fixing basic coding style issues in the\n+repository. It has three subcommands:\n+\n+```\n+$ ./basic_style.py report <base_directory>\n+$ ./basic_style.py check <base_directory>\n+$ ./basic_style.py fix <base_directory>\n+```\n+Running these subcommands without arguments displays a usage string.\n+\n+basic\\_style.py report \\<base\\_directory\\>\n+---------------------------------------------------------\n+\n+Produces a report of basic style issues found inside the source files of a\n+repository. The basic style rules are defined inside the script as regular\n+expressions. Each rule is listed in the report along with the summary of the\n+check for that specific rule.\n+\n+basic\\_style.py check \\<base\\_directory\\>\n+---------------------------------------------------------\n+\n+Similar to the `report` command, but is for a more straightforward check meant\n+to accept or reject the state of the repository. If no issues are found, it\n+returns a zero status. If issues are found it returns a non-zero status and\n+also lists the specific files in violation as well as pointing out which\n+line(s) and character(s) are the cause.\n+\n+basic\\_style.py fix \\<base\\_directory\\>\n+---------------------------------------------------------\n+\n+Edits the files in the repository with a simple search-and-replace to fix the\n+violations according to the substitution string defined in the script.\n+\n check-doc.py\n ============\n "
      },
      {
        "sha": "f30cf85c937d4fed7dc2e2a16da10e0f855ebf2b",
        "filename": "contrib/devtools/basic_style.py",
        "status": "added",
        "additions": 472,
        "deletions": 0,
        "changes": 472,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ee6c3c60f19a0da7729254bc065ae536f360b32d/contrib/devtools/basic_style.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ee6c3c60f19a0da7729254bc065ae536f360b32d/contrib/devtools/basic_style.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/basic_style.py?ref=ee6c3c60f19a0da7729254bc065ae536f360b32d",
        "patch": "@@ -0,0 +1,472 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import re\n+import fnmatch\n+import sys\n+import subprocess\n+import datetime\n+import os\n+import itertools\n+\n+###############################################################################\n+# style rules\n+###############################################################################\n+\n+\n+STYLE_RULES = [\n+    {'title':   'No tabstops',\n+     'applies': ['*.c', '*.cpp', '*.h', '*.py', '*.sh'],\n+     'regex':   '\\t',\n+     'fix':     '    '},\n+    {'title':   'No trailing whitespace on a line',\n+     'applies': ['*.c', '*.cpp', '*.h', '*.py', '*.sh'],\n+     'regex':   ' \\n',\n+     'fix':     '\\n'},\n+    {'title':   'No more than three consecutive newlines',\n+     'applies': ['*.c', '*.cpp', '*.h', '*.py', '*.sh'],\n+     'regex':   '\\n\\n\\n\\n',\n+     'fix':     '\\n\\n\\n'},\n+    {'title':   'Do not end a line with a semicolon',\n+     'applies': ['*.py'],\n+     'regex':   ';\\n',\n+     'fix':     '\\n'},\n+    {'title':   'Do not end a line with two semicolons',\n+     'applies': ['*.c', '*.cpp', '*.h'],\n+     'regex':   ';;\\n',\n+     'fix':     ';\\n'},\n+]\n+\n+for rule in STYLE_RULES:\n+    rule['regex_compiled'] = re.compile(rule['regex'])\n+    rule['applies_compiled'] = re.compile('|'.join([fnmatch.translate(f) for f\n+                                                    in rule['applies']]))\n+\n+\n+###############################################################################\n+# files we want exempt from these rules\n+###############################################################################\n+\n+\n+ALWAYS_IGNORE = [\n+    # files in subtrees:\n+    'src/secp256k1/*',\n+    'src/leveldb/*',\n+    'src/univalue/*',\n+    'src/crypto/ctaes/*',\n+]\n+\n+ALWAYS_IGNORE_COMPILED = re.compile('|'.join([fnmatch.translate(match)\n+                                              for match in ALWAYS_IGNORE]))\n+\n+\n+###############################################################################\n+# obtain list of files in repo to check that match extensions\n+###############################################################################\n+\n+\n+GIT_LS_CMD = 'git ls-files'\n+\n+\n+def git_ls():\n+    out = subprocess.check_output(GIT_LS_CMD.split(' '))\n+    return [f for f in out.decode(\"utf-8\").split('\\n') if f != '']\n+\n+\n+APPLIES_FILTER = set(itertools.chain(*[r['applies'] for r in STYLE_RULES]))\n+APPLIES_FILTER_COMPILED = re.compile('|'.join([fnmatch.translate(a) for a in\n+                                               APPLIES_FILTER]))\n+\n+\n+def filename_is_to_be_examined(filename):\n+    return (APPLIES_FILTER_COMPILED.match(filename) and not\n+            ALWAYS_IGNORE_COMPILED.match(filename))\n+\n+\n+def get_filenames_to_examine(full_file_list):\n+    return sorted([filename for filename in full_file_list if\n+                   filename_is_to_be_examined(filename)])\n+\n+\n+###############################################################################\n+# file IO\n+###############################################################################\n+\n+\n+def read_file(filename):\n+    file = open(os.path.abspath(filename), 'r')\n+    contents = file.read()\n+    file.close()\n+    return contents\n+\n+\n+def write_file(filename, contents):\n+    file = open(os.path.abspath(filename), 'w')\n+    file.write(contents)\n+    file.close()\n+\n+\n+###############################################################################\n+# gather file info\n+###############################################################################\n+\n+\n+def find_line_of_match(contents, match):\n+    line = {}\n+    contents_before_match = contents[:match.start()]\n+    contents_after_match = contents[match.end() - 1:]\n+    line_start_char = contents_before_match.rfind('\\n') + 1\n+    line_end_char = match.end() + contents_after_match.find('\\n')\n+    line['contents'] = contents[line_start_char:line_end_char]\n+    line['number'] = contents_before_match.count('\\n') + 1\n+    line['character'] = match.start() - line_start_char + 1\n+    return line\n+\n+\n+def find_failures_for_rule(file_info, rule):\n+    matches = [match for match in\n+               rule['regex_compiled'].finditer(file_info['contents']) if\n+               match is not None]\n+    lines = [find_line_of_match(file_info['contents'], match) for match in\n+             matches]\n+    if len(lines) > 0:\n+        yield {'filename': file_info['filename'],\n+               'contents': file_info['contents'],\n+               'title':    rule['title'],\n+               'lines':    lines,\n+               'rule':     rule}\n+\n+\n+def find_failures(file_info):\n+    return list(itertools.chain(*[find_failures_for_rule(file_info, rule)\n+                                  for rule in file_info['rules']]))\n+\n+\n+def gather_file_info(filename):\n+    file_info = {}\n+    file_info['filename'] = filename\n+    file_info['contents'] = read_file(filename)\n+    file_info['rules'] = [r for r in STYLE_RULES if\n+                          r['applies_compiled'].match(filename)]\n+    file_info['rules_not_covering'] = [r for r in STYLE_RULES if not\n+                                       r['applies_compiled'].match(filename)]\n+    file_info['failures'] = find_failures(file_info)\n+    return file_info\n+\n+\n+###############################################################################\n+# report helpers\n+###############################################################################\n+\n+\n+SEPARATOR = '-' * 80 + '\\n'\n+REPORT = []\n+\n+\n+def report(string):\n+    REPORT.append(string)\n+\n+\n+GREEN = '\\033[92m'\n+RED = '\\033[91m'\n+ENDC = '\\033[0m'\n+\n+\n+def red_report(string):\n+    report(RED + string + ENDC)\n+\n+\n+def green_report(string):\n+    report(GREEN + string + ENDC)\n+\n+\n+def flush_report():\n+    print(''.join(REPORT), end=\"\")\n+\n+\n+###############################################################################\n+# report execution\n+###############################################################################\n+\n+\n+def report_filenames(file_infos):\n+    if len(file_infos) == 0:\n+        return\n+    report('\\t')\n+    report('\\n\\t'.join([file_info['filename'] for file_info in file_infos]))\n+    report('\\n')\n+\n+\n+def report_summary(file_infos, full_file_list):\n+    report(\"%4d files tracked according to '%s'\\n\" %\n+           (len(full_file_list), GIT_LS_CMD))\n+    report(\"%4d files examined according to STYLE_RULES and ALWAYS_IGNORE \"\n+           \"settings\\n\" % len(file_infos))\n+\n+\n+def file_fails_rule(file_info, rule):\n+    return len([failure for failure in file_info['failures'] if\n+                failure['rule'] is rule]) > 0\n+\n+\n+def report_rule(rule, file_infos):\n+    covered = [file_info for file_info in file_infos if\n+               rule in file_info['rules']]\n+    not_covered = [file_info for file_info in file_infos if\n+                   rule in file_info['rules_not_covering']]\n+\n+    passed = [file_info for file_info in file_infos if not\n+              file_fails_rule(file_info, rule)]\n+    failed = [file_info for file_info in file_infos if\n+              file_fails_rule(file_info, rule)]\n+\n+    report('Rule title: \"%s\"\\n' % rule['title'])\n+    report('File extensions covered by rule:    %s\\n' % rule['applies'])\n+    report(\"Files covered by rule:             %4d\\n\" % len(covered))\n+    report(\"Files not covered by rule:         %4d\\n\" % len(not_covered))\n+    report(\"Files passed:                      %4d\\n\" % len(passed))\n+    report(\"Files failed:                      %4d\\n\" % len(failed))\n+    report_filenames(failed)\n+\n+\n+def print_report(file_infos, full_file_list):\n+    report(SEPARATOR)\n+    report_summary(file_infos, full_file_list)\n+    for rule in STYLE_RULES:\n+        report(SEPARATOR)\n+        report_rule(rule, file_infos)\n+    report(SEPARATOR)\n+    flush_report()\n+\n+\n+def exec_report(base_directory):\n+    original_cwd = os.getcwd()\n+    os.chdir(base_directory)\n+    full_file_list = git_ls()\n+    file_infos = [gather_file_info(filename) for filename in\n+                  get_filenames_to_examine(full_file_list)]\n+    print_report(file_infos, full_file_list)\n+    os.chdir(original_cwd)\n+\n+\n+###############################################################################\n+# report cmd\n+###############################################################################\n+\n+\n+REPORT_USAGE = \"\"\"\n+Produces a summary report of all basic style issues found in the repository\n+according to the rules of the script.\n+\n+Usage:\n+    $ ./basic_style.py report <base_directory>\n+\n+Arguments:\n+    <base_directory> - The base directory of a bitcoin core source code\n+    repository.\n+\"\"\"\n+\n+\n+def report_cmd(argv):\n+    if len(argv) != 3:\n+        sys.exit(REPORT_USAGE)\n+\n+    base_directory = argv[2]\n+    if not os.path.exists(base_directory):\n+        sys.exit(\"*** bad <base_directory>: %s\" % base_directory)\n+\n+    exec_report(base_directory)\n+\n+\n+###############################################################################\n+# check execution\n+###############################################################################\n+\n+\n+def get_all_failures(file_infos):\n+    return list(itertools.chain(*[file_info['failures'] for file_info in\n+                file_infos]))\n+\n+\n+def report_failure(failure):\n+    report(\"An issue was found with \")\n+    red_report(\"%s\\n\" % failure['filename'])\n+    report('Rule: \"%s\"\\n\\n' % failure['title'])\n+    for line in failure['lines']:\n+        report('line %d:\\n' % line['number'])\n+        report(\"%s\" % line['contents'])\n+        report(' ' * (line['character'] - 1))\n+        red_report(\"^\\n\")\n+\n+\n+def print_check_report(file_infos, full_file_list, failures):\n+    report(SEPARATOR)\n+    report_summary(file_infos, full_file_list)\n+\n+    for failure in failures:\n+        report(SEPARATOR)\n+        report_failure(failure)\n+\n+    report(SEPARATOR)\n+    if len(failures) == 0:\n+        green_report(\"No style issues found!\\n\")\n+    else:\n+        red_report(\"These issues can be fixed automatically by running:\\n\")\n+        report(\"$ contrib/devtools/basic_style.py fix <base_directory>\\n\")\n+    report(SEPARATOR)\n+    flush_report()\n+\n+\n+def exec_check(base_directory):\n+    original_cwd = os.getcwd()\n+    os.chdir(base_directory)\n+    full_file_list = git_ls()\n+    file_infos = [gather_file_info(filename) for filename in\n+                  get_filenames_to_examine(full_file_list)]\n+    failures = get_all_failures(file_infos)\n+    print_check_report(file_infos, full_file_list, failures)\n+    os.chdir(original_cwd)\n+    if len(failures) > 0:\n+        sys.exit(\"*** Style issues found!\")\n+\n+\n+###############################################################################\n+# check cmd\n+###############################################################################\n+\n+\n+CHECK_USAGE = \"\"\"\n+Checks over the repository for any basic code style issues as defined by the\n+rules of this script. Returns a non-zero status if there are any issues found.\n+Also, a report is printed specifically identifying which file and lines are\n+problematic so that the can be fixed.\n+\n+Usage:\n+    $ ./basic_style.py check <base_directory>\n+\n+Arguments:\n+    <base_directory> - The base directory of a bitcoin core source code\n+    repository.\n+\"\"\"\n+\n+\n+def check_cmd(argv):\n+    if len(argv) != 3:\n+        sys.exit(CHECK_USAGE)\n+\n+    base_directory = argv[2]\n+    if not os.path.exists(base_directory):\n+        sys.exit(\"*** bad <base_directory>: %s\" % base_directory)\n+\n+    exec_check(base_directory)\n+\n+\n+###############################################################################\n+# fix execution\n+###############################################################################\n+\n+\n+def fix_contents(contents, regex, fix):\n+    # Multiple instances of a particular issue could be present. For example,\n+    # multiple spaces at the end of a line. So, we repeat the\n+    # search-and-replace until search matches are exhausted.\n+    while True:\n+        contents, subs = regex.subn(fix, contents)\n+        if subs == 0:\n+            break\n+    return contents\n+\n+\n+def fix_failures(failures):\n+    for failure in failures:\n+        contents = fix_contents(failure['contents'],\n+                                failure['rule']['regex_compiled'],\n+                                failure['rule']['fix'])\n+        write_file(failure['filename'], contents)\n+\n+\n+def fix_loop():\n+    full_file_list = git_ls()\n+    # Multiple types of issues could be overlapping. For example, a tabstop at\n+    # the end of a line so the fix then creates whitespace at the end. We\n+    # repeat fix-up cycles until everything is cleared.\n+    while True:\n+        file_infos = [gather_file_info(filename) for filename in\n+                      get_filenames_to_examine(full_file_list)]\n+        failures = get_all_failures(file_infos)\n+        if len(failures) == 0:\n+            break\n+        fix_failures(failures)\n+\n+\n+def exec_fix(base_directory):\n+    original_cwd = os.getcwd()\n+    os.chdir(base_directory)\n+    fix_loop()\n+    os.chdir(original_cwd)\n+\n+\n+###############################################################################\n+# fix cmd\n+###############################################################################\n+\n+\n+FIX_USAGE = \"\"\"\n+Automatically edits files in the repository to fix up any basic style issues\n+found with simple search-and-replace logic.\n+\n+Usage:\n+    $ ./basic_style.py fix <base_directory>\n+\n+Arguments:\n+    <base_directory> - The base directory of a bitcoin core source code\n+    repository.\n+\"\"\"\n+\n+\n+def fix_cmd(argv):\n+    if len(argv) != 3:\n+        sys.exit(FIX_USAGE)\n+\n+    base_directory = argv[2]\n+    if not os.path.exists(base_directory):\n+        sys.exit(\"*** bad <base_directory>: %s\" % base_directory)\n+\n+    exec_fix(base_directory)\n+\n+\n+###############################################################################\n+# UI\n+###############################################################################\n+\n+\n+USAGE = \"\"\"\n+basic_style.py - utilities for checking basic style in source code files.\n+\n+Usage:\n+    $ ./basic_style.py <subcommand>\n+\n+Subcommands:\n+    report\n+    check\n+    fix\n+\n+To see subcommand usage, run them without arguments.\n+\"\"\"\n+\n+SUBCOMMANDS = ['report', 'check', 'fix']\n+\n+\n+if __name__ == \"__main__\":\n+    if len(sys.argv) == 1:\n+        sys.exit(USAGE)\n+    if sys.argv[1] not in SUBCOMMANDS:\n+        sys.exit(USAGE)\n+    if sys.argv[1] == 'report':\n+        report_cmd(sys.argv)\n+    elif sys.argv[1] == 'check':\n+        check_cmd(sys.argv)\n+    elif sys.argv[1] == 'fix':\n+        fix_cmd(sys.argv)"
      }
    ]
  }
]