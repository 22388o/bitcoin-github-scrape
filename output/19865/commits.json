[
  {
    "sha": "2cc908d20128044c098707ec08b368026e862194",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyY2M5MDhkMjAxMjgwNDRjMDk4NzA3ZWMwOGIzNjgwMjZlODYyMTk0",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2020-09-03T23:42:03Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2020-09-14T08:30:17Z"
      },
      "message": "scripted-diff: Restore AssertLockHeld after #19668, remove LockAssertion\n\n-BEGIN VERIFY SCRIPT-\ngit grep -l AssertLockHeldInternal | xargs sed -i /AssertLockHeldInternal/s/EXCLUSIVE_LOCKS_REQUIRED/ASSERT_EXCLUSIVE_LOCK/\ngit grep -l AssertLockHeld ':!src/sync.h' | xargs sed -i '/^ *AssertLockHeld(.*);/d'\ngit grep -l LockAssertion | xargs sed -i 's/LockAssertion lock(\\(.*\\));/AssertLockHeld(\\1);/g'\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "99eefebbb3961d00162d5d978d3da1b4ba8f6059",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/99eefebbb3961d00162d5d978d3da1b4ba8f6059"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2cc908d20128044c098707ec08b368026e862194",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2cc908d20128044c098707ec08b368026e862194",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2cc908d20128044c098707ec08b368026e862194",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2cc908d20128044c098707ec08b368026e862194/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "06dbbe76dd027e924eb95ffc4b409daffaefe61b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/06dbbe76dd027e924eb95ffc4b409daffaefe61b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/06dbbe76dd027e924eb95ffc4b409daffaefe61b"
      }
    ],
    "stats": {
      "total": 119,
      "additions": 8,
      "deletions": 111
    },
    "files": [
      {
        "sha": "9dfe33478623ac7ce9d3fc91d80dbbf6f5d3c058",
        "filename": "doc/developer-notes.md",
        "status": "modified",
        "additions": 1,
        "deletions": 4,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cc908d20128044c098707ec08b368026e862194/doc/developer-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cc908d20128044c098707ec08b368026e862194/doc/developer-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/developer-notes.md?ref=2cc908d20128044c098707ec08b368026e862194",
        "patch": "@@ -767,8 +767,6 @@ public:\n // txmempool.cpp\n void CTxMemPool::UpdateTransactionsFromBlock(...)\n {\n-    AssertLockHeld(::cs_main);\n-    AssertLockHeld(cs);\n     ...\n }\n ```\n@@ -802,10 +800,9 @@ void RelayTransaction(...) EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n // net_processing.cpp\n void RelayTransaction(...)\n {\n-    AssertLockHeld(::cs_main);\n \n     connman.ForEachNode([&txid, &wtxid](CNode* pnode) {\n-        LockAssertion lock(::cs_main);\n+        AssertLockHeld(::cs_main);\n         ...\n     });\n }"
      },
      {
        "sha": "3e004f2ab86fd331bb84d29cc1b8596e26c824c6",
        "filename": "src/index/base.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cc908d20128044c098707ec08b368026e862194/src/index/base.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cc908d20128044c098707ec08b368026e862194/src/index/base.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/base.cpp?ref=2cc908d20128044c098707ec08b368026e862194",
        "patch": "@@ -70,7 +70,6 @@ bool BaseIndex::Init()\n \n static const CBlockIndex* NextSyncBlock(const CBlockIndex* pindex_prev) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    AssertLockHeld(cs_main);\n \n     if (!pindex_prev) {\n         return ::ChainActive().Genesis();"
      },
      {
        "sha": "5930fa32b19912047bfb792fc5cc5a0bd001ee9e",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 11,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cc908d20128044c098707ec08b368026e862194/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cc908d20128044c098707ec08b368026e862194/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=2cc908d20128044c098707ec08b368026e862194",
        "patch": "@@ -648,7 +648,6 @@ static void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) EXCLUSIV\n  */\n static void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman& connman) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    AssertLockHeld(cs_main);\n     CNodeState* nodestate = State(nodeid);\n     if (!nodestate || !nodestate->fSupportsDesiredCmpctVersion) {\n         // Never ask from peers who can't provide witnesses.\n@@ -663,7 +662,7 @@ static void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman& connma\n             }\n         }\n         connman.ForNode(nodeid, [&connman](CNode* pfrom){\n-            LockAssertion lock(::cs_main);\n+            AssertLockHeld(::cs_main);\n             uint64_t nCMPCTBLOCKVersion = (pfrom->GetLocalServices() & NODE_WITNESS) ? 2 : 1;\n             if (lNodesAnnouncingHeaderAndIDs.size() >= 3) {\n                 // As per BIP152, we only get 3 of our peers to announce\n@@ -683,7 +682,6 @@ static void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman& connma\n \n static bool TipMayBeStale(const Consensus::Params &consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    AssertLockHeld(cs_main);\n     if (g_last_tip_update == 0) {\n         g_last_tip_update = GetTime();\n     }\n@@ -1217,7 +1215,6 @@ bool PeerManager::MaybePunishNodeForTx(NodeId nodeid, const TxValidationState& s\n // we fully-validated them at some point.\n static bool BlockRequestAllowed(const CBlockIndex* pindex, const Consensus::Params& consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    AssertLockHeld(cs_main);\n     if (::ChainActive().Contains(pindex)) return true;\n     return pindex->IsValid(BLOCK_VALID_SCRIPTS) && (pindexBestHeader != nullptr) &&\n         (pindexBestHeader->GetBlockTime() - pindex->GetBlockTime() < STALE_RELAY_AGE_LIMIT) &&\n@@ -1355,7 +1352,7 @@ void PeerManager::NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_\n     }\n \n     m_connman.ForEachNode([this, &pcmpctblock, pindex, &msgMaker, fWitnessEnabled, &hashBlock](CNode* pnode) {\n-        LockAssertion lock(::cs_main);\n+        AssertLockHeld(::cs_main);\n \n         // TODO: Avoid the repeated-serialization here\n         if (pnode->nVersion < INVALID_CB_NO_BAN_VERSION || pnode->fDisconnect)\n@@ -1490,7 +1487,7 @@ void RelayTransaction(const uint256& txid, const uint256& wtxid, const CConnman&\n {\n     connman.ForEachNode([&txid, &wtxid](CNode* pnode)\n     {\n-        LockAssertion lock(::cs_main);\n+        AssertLockHeld(::cs_main);\n \n         CNodeState &state = *State(pnode->GetId());\n         if (state.m_wtxid_relay) {\n@@ -2022,8 +2019,6 @@ void PeerManager::ProcessHeadersMessage(CNode& pfrom, const std::vector<CBlockHe\n \n void PeerManager::ProcessOrphanTx(std::set<uint256>& orphan_work_set, std::list<CTransactionRef>& removed_txn)\n {\n-    AssertLockHeld(cs_main);\n-    AssertLockHeld(g_cs_orphans);\n     std::set<NodeId> setMisbehaving;\n     bool done = false;\n     while (!done && !orphan_work_set.empty()) {\n@@ -3916,7 +3911,6 @@ bool PeerManager::ProcessMessages(CNode* pfrom, std::atomic<bool>& interruptMsgP\n \n void PeerManager::ConsiderEviction(CNode& pto, int64_t time_in_seconds)\n {\n-    AssertLockHeld(cs_main);\n \n     CNodeState &state = *State(pto.GetId());\n     const CNetMsgMaker msgMaker(pto.GetSendVersion());\n@@ -3980,7 +3974,7 @@ void PeerManager::EvictExtraOutboundPeers(int64_t time_in_seconds)\n         int64_t oldest_block_announcement = std::numeric_limits<int64_t>::max();\n \n         m_connman.ForEachNode([&](CNode* pnode) {\n-            LockAssertion lock(::cs_main);\n+            AssertLockHeld(::cs_main);\n \n             // Ignore non-outbound peers, or nodes marked for disconnect already\n             if (!pnode->IsOutboundOrBlockRelayConn() || pnode->fDisconnect) return;\n@@ -3997,7 +3991,7 @@ void PeerManager::EvictExtraOutboundPeers(int64_t time_in_seconds)\n         });\n         if (worst_peer != -1) {\n             bool disconnected = m_connman.ForNode(worst_peer, [&](CNode *pnode) {\n-                LockAssertion lock(::cs_main);\n+                AssertLockHeld(::cs_main);\n \n                 // Only disconnect a peer that has been connected to us for\n                 // some reasonable fraction of our check-frequency, to give"
      },
      {
        "sha": "6362e93b126541ddf36024fc1d66c58bea39ddf0",
        "filename": "src/policy/rbf.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cc908d20128044c098707ec08b368026e862194/src/policy/rbf.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cc908d20128044c098707ec08b368026e862194/src/policy/rbf.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/rbf.cpp?ref=2cc908d20128044c098707ec08b368026e862194",
        "patch": "@@ -7,7 +7,6 @@\n \n RBFTransactionState IsRBFOptIn(const CTransaction& tx, const CTxMemPool& pool)\n {\n-    AssertLockHeld(pool.cs);\n \n     CTxMemPool::setEntries setAncestors;\n "
      },
      {
        "sha": "64506bbab3c5c0b3ecad6a764618bda9662a8fdb",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cc908d20128044c098707ec08b368026e862194/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cc908d20128044c098707ec08b368026e862194/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=2cc908d20128044c098707ec08b368026e862194",
        "patch": "@@ -423,7 +423,6 @@ static std::vector<RPCResult> MempoolEntryDescription() { return {\n \n static void entryToJSON(const CTxMemPool& pool, UniValue& info, const CTxMemPoolEntry& e) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n {\n-    AssertLockHeld(pool.cs);\n \n     UniValue fees(UniValue::VOBJ);\n     fees.pushKV(\"base\", ValueFromAmount(e.GetFee()));"
      },
      {
        "sha": "7cd27379aeae3902856cd8f3ba754f1cc36ce244",
        "filename": "src/script/signingprovider.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cc908d20128044c098707ec08b368026e862194/src/script/signingprovider.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cc908d20128044c098707ec08b368026e862194/src/script/signingprovider.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/signingprovider.cpp?ref=2cc908d20128044c098707ec08b368026e862194",
        "patch": "@@ -71,7 +71,6 @@ FlatSigningProvider Merge(const FlatSigningProvider& a, const FlatSigningProvide\n \n void FillableSigningProvider::ImplicitlyLearnRelatedKeyScripts(const CPubKey& pubkey)\n {\n-    AssertLockHeld(cs_KeyStore);\n     CKeyID key_id = pubkey.GetID();\n     // This adds the redeemscripts necessary to detect P2WPKH and P2SH-P2WPKH\n     // outputs. Technically P2WPKH outputs don't have a redeemscript to be"
      },
      {
        "sha": "842702601c3dcb8ee5881a597670243b7216f729",
        "filename": "src/sync.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cc908d20128044c098707ec08b368026e862194/src/sync.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cc908d20128044c098707ec08b368026e862194/src/sync.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sync.h?ref=2cc908d20128044c098707ec08b368026e862194",
        "patch": "@@ -53,7 +53,7 @@ void LeaveCritical();\n void CheckLastCritical(void* cs, std::string& lockname, const char* guardname, const char* file, int line);\n std::string LocksHeld();\n template <typename MutexType>\n-void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) ASSERT_EXCLUSIVE_LOCK(cs);\n template <typename MutexType>\n void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(!cs);\n void DeleteLock(void* cs);\n@@ -70,7 +70,7 @@ inline void EnterCritical(const char* pszName, const char* pszFile, int nLine, v\n inline void LeaveCritical() {}\n inline void CheckLastCritical(void* cs, std::string& lockname, const char* guardname, const char* file, int line) {}\n template <typename MutexType>\n-inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(cs) {}\n+inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) ASSERT_EXCLUSIVE_LOCK(cs) {}\n template <typename MutexType>\n void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(!cs) {}\n inline void DeleteLock(void* cs) {}"
      },
      {
        "sha": "32f515d19b00aa26b37a75d4c73355f950913ac7",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 14,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cc908d20128044c098707ec08b368026e862194/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cc908d20128044c098707ec08b368026e862194/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=2cc908d20128044c098707ec08b368026e862194",
        "patch": "@@ -106,7 +106,6 @@ void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendan\n // for each such descendant, also update the ancestor state to include the parent.\n void CTxMemPool::UpdateTransactionsFromBlock(const std::vector<uint256> &vHashesToUpdate)\n {\n-    AssertLockHeld(cs);\n     // For each entry in vHashesToUpdate, store the set of in-mempool, but not\n     // in-vHashesToUpdate transactions, so that we don't have to recalculate\n     // descendants when we come across a previously seen entry.\n@@ -473,7 +472,6 @@ void CTxMemPool::CalculateDescendants(txiter entryit, setEntries& setDescendants\n void CTxMemPool::removeRecursive(const CTransaction &origTx, MemPoolRemovalReason reason)\n {\n     // Remove transaction from memory pool\n-    AssertLockHeld(cs);\n         setEntries txToRemove;\n         txiter origit = mapTx.find(origTx.GetHash());\n         if (origit != mapTx.end()) {\n@@ -503,7 +501,6 @@ void CTxMemPool::removeRecursive(const CTransaction &origTx, MemPoolRemovalReaso\n void CTxMemPool::removeForReorg(const CCoinsViewCache *pcoins, unsigned int nMemPoolHeight, int flags)\n {\n     // Remove transactions spending a coinbase which are now immature and no-longer-final transactions\n-    AssertLockHeld(cs);\n     setEntries txToRemove;\n     for (indexed_transaction_set::const_iterator it = mapTx.begin(); it != mapTx.end(); it++) {\n         const CTransaction& tx = it->GetTx();\n@@ -540,7 +537,6 @@ void CTxMemPool::removeForReorg(const CCoinsViewCache *pcoins, unsigned int nMem\n void CTxMemPool::removeConflicts(const CTransaction &tx)\n {\n     // Remove transactions which depend on inputs of tx, recursively\n-    AssertLockHeld(cs);\n     for (const CTxIn &txin : tx.vin) {\n         auto it = mapNextTx.find(txin.prevout);\n         if (it != mapNextTx.end()) {\n@@ -559,7 +555,6 @@ void CTxMemPool::removeConflicts(const CTransaction &tx)\n  */\n void CTxMemPool::removeForBlock(const std::vector<CTransactionRef>& vtx, unsigned int nBlockHeight)\n {\n-    AssertLockHeld(cs);\n     std::vector<const CTxMemPoolEntry*> entries;\n     for (const auto& tx : vtx)\n     {\n@@ -765,7 +760,6 @@ class DepthAndScoreComparator\n std::vector<CTxMemPool::indexed_transaction_set::const_iterator> CTxMemPool::GetSortedDepthAndScore() const\n {\n     std::vector<indexed_transaction_set::const_iterator> iters;\n-    AssertLockHeld(cs);\n \n     iters.reserve(mapTx.size());\n \n@@ -859,7 +853,6 @@ void CTxMemPool::PrioritiseTransaction(const uint256& hash, const CAmount& nFeeD\n \n void CTxMemPool::ApplyDelta(const uint256& hash, CAmount &nFeeDelta) const\n {\n-    AssertLockHeld(cs);\n     std::map<uint256, CAmount>::const_iterator pos = mapDeltas.find(hash);\n     if (pos == mapDeltas.end())\n         return;\n@@ -869,7 +862,6 @@ void CTxMemPool::ApplyDelta(const uint256& hash, CAmount &nFeeDelta) const\n \n void CTxMemPool::ClearPrioritisation(const uint256& hash)\n {\n-    AssertLockHeld(cs);\n     mapDeltas.erase(hash);\n }\n \n@@ -938,7 +930,6 @@ void CTxMemPool::RemoveUnbroadcastTx(const uint256& txid, const bool unchecked)\n }\n \n void CTxMemPool::RemoveStaged(setEntries &stage, bool updateDescendants, MemPoolRemovalReason reason) {\n-    AssertLockHeld(cs);\n     UpdateForRemoveFromMempool(stage, updateDescendants);\n     for (txiter it : stage) {\n         removeUnchecked(it, reason);\n@@ -947,7 +938,6 @@ void CTxMemPool::RemoveStaged(setEntries &stage, bool updateDescendants, MemPool\n \n int CTxMemPool::Expire(std::chrono::seconds time)\n {\n-    AssertLockHeld(cs);\n     indexed_transaction_set::index<entry_time>::type::iterator it = mapTx.get<entry_time>().begin();\n     setEntries toremove;\n     while (it != mapTx.get<entry_time>().end() && it->GetTime() < time) {\n@@ -973,7 +963,6 @@ void CTxMemPool::addUnchecked(const CTxMemPoolEntry &entry, bool validFeeEstimat\n \n void CTxMemPool::UpdateChild(txiter entry, txiter child, bool add)\n {\n-    AssertLockHeld(cs);\n     CTxMemPoolEntry::Children s;\n     if (add && entry->GetMemPoolChildren().insert(*child).second) {\n         cachedInnerUsage += memusage::IncrementalDynamicUsage(s);\n@@ -984,7 +973,6 @@ void CTxMemPool::UpdateChild(txiter entry, txiter child, bool add)\n \n void CTxMemPool::UpdateParent(txiter entry, txiter parent, bool add)\n {\n-    AssertLockHeld(cs);\n     CTxMemPoolEntry::Parents s;\n     if (add && entry->GetMemPoolParents().insert(*parent).second) {\n         cachedInnerUsage += memusage::IncrementalDynamicUsage(s);\n@@ -1018,15 +1006,13 @@ CFeeRate CTxMemPool::GetMinFee(size_t sizelimit) const {\n }\n \n void CTxMemPool::trackPackageRemoved(const CFeeRate& rate) {\n-    AssertLockHeld(cs);\n     if (rate.GetFeePerK() > rollingMinimumFeeRate) {\n         rollingMinimumFeeRate = rate.GetFeePerK();\n         blockSinceLastRollingFeeBump = false;\n     }\n }\n \n void CTxMemPool::TrimToSize(size_t sizelimit, std::vector<COutPoint>* pvNoSpendsRemaining) {\n-    AssertLockHeld(cs);\n \n     unsigned nTxnRemoved = 0;\n     CFeeRate maxFeeRateRemoved(0);"
      },
      {
        "sha": "f7407782e2c11e32065fc9f57407050a5d6862e0",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cc908d20128044c098707ec08b368026e862194/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cc908d20128044c098707ec08b368026e862194/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=2cc908d20128044c098707ec08b368026e862194",
        "patch": "@@ -725,7 +725,6 @@ class CTxMemPool\n \n     uint64_t GetTotalTxSize() const EXCLUSIVE_LOCKS_REQUIRED(cs)\n     {\n-        AssertLockHeld(cs);\n         return totalTxSize;\n     }\n \n@@ -742,7 +741,6 @@ class CTxMemPool\n     CTransactionRef get(const uint256& hash) const;\n     txiter get_iter_from_wtxid(const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(cs)\n     {\n-        AssertLockHeld(cs);\n         return mapTx.project<0>(mapTx.get<index_by_wtxid>().find(wtxid));\n     }\n     TxMempoolInfo info(const uint256& hash) const;\n@@ -772,7 +770,6 @@ class CTxMemPool\n     /** Returns whether a txid is in the unbroadcast set */\n     bool IsUnbroadcastTx(const uint256& txid) const EXCLUSIVE_LOCKS_REQUIRED(cs)\n     {\n-        AssertLockHeld(cs);\n         return m_unbroadcast_txids.count(txid) != 0;\n     }\n "
      },
      {
        "sha": "bd7ecdfee6ad3090a4ff19f38bc36c5b20afb08e",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 32,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cc908d20128044c098707ec08b368026e862194/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cc908d20128044c098707ec08b368026e862194/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=2cc908d20128044c098707ec08b368026e862194",
        "patch": "@@ -171,14 +171,12 @@ namespace {\n \n CBlockIndex* LookupBlockIndex(const uint256& hash)\n {\n-    AssertLockHeld(cs_main);\n     BlockMap::const_iterator it = g_chainman.BlockIndex().find(hash);\n     return it == g_chainman.BlockIndex().end() ? nullptr : it->second;\n }\n \n CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& locator)\n {\n-    AssertLockHeld(cs_main);\n \n     // Find the latest block common to locator and chain - we expect that\n     // locator.vHave is sorted descending by height.\n@@ -207,7 +205,6 @@ static FlatFileSeq UndoFileSeq();\n \n bool CheckFinalTx(const CTransaction &tx, int flags)\n {\n-    AssertLockHeld(cs_main);\n \n     // By convention a negative value for flags indicates that the\n     // current network-enforced consensus rules should be used. In\n@@ -239,7 +236,6 @@ bool CheckFinalTx(const CTransaction &tx, int flags)\n \n bool TestLockPointValidity(const LockPoints* lp)\n {\n-    AssertLockHeld(cs_main);\n     assert(lp);\n     // If there are relative lock times then the maxInputBlock will be set\n     // If there are no relative lock times, the LockPoints don't depend on the chain\n@@ -257,8 +253,6 @@ bool TestLockPointValidity(const LockPoints* lp)\n \n bool CheckSequenceLocks(const CTxMemPool& pool, const CTransaction& tx, int flags, LockPoints* lp, bool useExistingLockPoints)\n {\n-    AssertLockHeld(cs_main);\n-    AssertLockHeld(pool.cs);\n \n     CBlockIndex* tip = ::ChainActive().Tip();\n     assert(tip != nullptr);\n@@ -346,7 +340,6 @@ static void LimitMempoolSize(CTxMemPool& pool, size_t limit, std::chrono::second\n \n static bool IsCurrentForFeeEstimation() EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    AssertLockHeld(cs_main);\n     if (::ChainstateActive().IsInitialBlockDownload())\n         return false;\n     if (::ChainActive().Tip()->GetBlockTime() < count_seconds(GetTime<std::chrono::seconds>() - MAX_FEE_ESTIMATION_TIP_AGE))\n@@ -371,8 +364,6 @@ static bool IsCurrentForFeeEstimation() EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n \n static void UpdateMempoolForReorg(CTxMemPool& mempool, DisconnectedBlockTransactions& disconnectpool, bool fAddToMempool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, mempool.cs)\n {\n-    AssertLockHeld(cs_main);\n-    AssertLockHeld(mempool.cs);\n     std::vector<uint256> vHashUpdate;\n     // disconnectpool's insertion_order index sorts the entries from\n     // oldest to newest, but the oldest entry will be the last tx from the\n@@ -413,7 +404,6 @@ static void UpdateMempoolForReorg(CTxMemPool& mempool, DisconnectedBlockTransact\n // were somehow broken and returning the wrong scriptPubKeys\n static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, TxValidationState& state, const CCoinsViewCache& view, const CTxMemPool& pool,\n                  unsigned int flags, PrecomputedTransactionData& txdata) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n-    AssertLockHeld(cs_main);\n \n     // pool.cs should be locked already, but go ahead and re-take the lock here\n     // to enforce that mempool doesn't change between when we check the view\n@@ -1029,7 +1019,6 @@ bool MemPoolAccept::Finalize(ATMPArgs& args, Workspace& ws)\n \n bool MemPoolAccept::AcceptSingleTransaction(const CTransactionRef& ptx, ATMPArgs& args)\n {\n-    AssertLockHeld(cs_main);\n     LOCK(m_pool.cs); // mempool \"read lock\" (held through GetMainSignals().TransactionAddedToMempool())\n \n     Workspace workspace(ptx);\n@@ -1331,7 +1320,6 @@ static void AlertNotify(const std::string& strMessage)\n \n static void CheckForkWarningConditions() EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    AssertLockHeld(cs_main);\n     // Before we get past initial download, we cannot reliably alert about forks\n     // (we assume we don't get stuck on a fork before finishing our initial sync)\n     if (::ChainstateActive().IsInitialBlockDownload())\n@@ -1372,7 +1360,6 @@ static void CheckForkWarningConditions() EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n \n static void CheckForkWarningConditionsOnNewFork(CBlockIndex* pindexNewForkTip) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    AssertLockHeld(cs_main);\n     // If we are on a fork that is sufficiently large, set a warning flag\n     CBlockIndex* pfork = pindexNewForkTip;\n     CBlockIndex* plonger = ::ChainActive().Tip();\n@@ -1524,7 +1511,6 @@ bool CheckInputScripts(const CTransaction& tx, TxValidationState &state, const C\n     uint256 hashCacheEntry;\n     CSHA256 hasher = g_scriptExecutionCacheHasher;\n     hasher.Write(tx.GetWitnessHash().begin(), 32).Write((unsigned char*)&flags, sizeof(flags)).Finalize(hashCacheEntry.begin());\n-    AssertLockHeld(cs_main); //TODO: Remove this requirement by making CuckooCache not require external locks\n     if (g_scriptExecutionCache.contains(hashCacheEntry, !cacheFullScriptStore)) {\n         return true;\n     }\n@@ -1867,7 +1853,6 @@ static bool IsScriptWitnessEnabled(const Consensus::Params& params)\n }\n \n static unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consensus::Params& consensusparams) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n-    AssertLockHeld(cs_main);\n \n     unsigned int flags = SCRIPT_VERIFY_NONE;\n \n@@ -1929,7 +1914,6 @@ static int64_t nBlocksTotal = 0;\n bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state, CBlockIndex* pindex,\n                   CCoinsViewCache& view, const CChainParams& chainparams, bool fJustCheck)\n {\n-    AssertLockHeld(cs_main);\n     assert(pindex);\n     assert(*pindex->phashBlock == block.GetHash());\n     int64_t nTimeStart = GetTimeMicros();\n@@ -2487,8 +2471,6 @@ static void UpdateTip(CTxMemPool& mempool, const CBlockIndex* pindexNew, const C\n   */\n bool CChainState::DisconnectTip(BlockValidationState& state, const CChainParams& chainparams, DisconnectedBlockTransactions* disconnectpool)\n {\n-    AssertLockHeld(cs_main);\n-    AssertLockHeld(m_mempool.cs);\n \n     CBlockIndex *pindexDelete = m_chain.Tip();\n     assert(pindexDelete);\n@@ -2588,8 +2570,6 @@ class ConnectTrace {\n  */\n bool CChainState::ConnectTip(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace, DisconnectedBlockTransactions &disconnectpool)\n {\n-    AssertLockHeld(cs_main);\n-    AssertLockHeld(m_mempool.cs);\n \n     assert(pindexNew->pprev == m_chain.Tip());\n     // Read block from disk.\n@@ -2724,8 +2704,6 @@ void CChainState::PruneBlockIndexCandidates() {\n  */\n bool CChainState::ActivateBestChainStep(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexMostWork, const std::shared_ptr<const CBlock>& pblock, bool& fInvalidFound, ConnectTrace& connectTrace)\n {\n-    AssertLockHeld(cs_main);\n-    AssertLockHeld(m_mempool.cs);\n \n     const CBlockIndex *pindexOldTip = m_chain.Tip();\n     const CBlockIndex *pindexFork = m_chain.FindFork(pindexMostWork);\n@@ -3123,7 +3101,6 @@ bool InvalidateBlock(BlockValidationState& state, const CChainParams& chainparam\n }\n \n void CChainState::ResetBlockFailureFlags(CBlockIndex *pindex) {\n-    AssertLockHeld(cs_main);\n \n     int nHeight = pindex->nHeight;\n \n@@ -3162,7 +3139,6 @@ void ResetBlockFailureFlags(CBlockIndex *pindex) {\n \n CBlockIndex* BlockManager::AddToBlockIndex(const CBlockHeader& block)\n {\n-    AssertLockHeld(cs_main);\n \n     // Check for duplicate\n     uint256 hash = block.GetHash();\n@@ -3620,7 +3596,6 @@ static bool ContextualCheckBlock(const CBlock& block, BlockValidationState& stat\n \n bool BlockManager::AcceptBlockHeader(const CBlockHeader& block, BlockValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex)\n {\n-    AssertLockHeld(cs_main);\n     // Check for duplicate\n     uint256 hash = block.GetHash();\n     BlockMap::iterator miSelf = m_block_index.find(hash);\n@@ -3759,7 +3734,6 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, Block\n     const CBlock& block = *pblock;\n \n     if (fNewBlock) *fNewBlock = false;\n-    AssertLockHeld(cs_main);\n \n     CBlockIndex *pindexDummy = nullptr;\n     CBlockIndex *&pindex = ppindex ? *ppindex : pindexDummy;\n@@ -3873,7 +3847,6 @@ bool ChainstateManager::ProcessNewBlock(const CChainParams& chainparams, const s\n \n bool TestBlockValidity(BlockValidationState& state, const CChainParams& chainparams, const CBlock& block, CBlockIndex* pindexPrev, bool fCheckPOW, bool fCheckMerkleRoot)\n {\n-    AssertLockHeld(cs_main);\n     assert(pindexPrev && pindexPrev == ::ChainActive().Tip());\n     CCoinsViewCache viewNew(&::ChainstateActive().CoinsTip());\n     uint256 block_hash(block.GetHash());\n@@ -3914,7 +3887,6 @@ uint64_t CalculateCurrentUsage()\n \n void ChainstateManager::PruneOneBlockFile(const int fileNumber)\n {\n-    AssertLockHeld(cs_main);\n     LOCK(cs_LastBlockFile);\n \n     for (const auto& entry : m_blockman.m_block_index) {\n@@ -4087,7 +4059,6 @@ fs::path GetBlockPosFilename(const FlatFilePos &pos)\n \n CBlockIndex * BlockManager::InsertBlockIndex(const uint256& hash)\n {\n-    AssertLockHeld(cs_main);\n \n     if (hash.IsNull())\n         return nullptr;\n@@ -4236,7 +4207,6 @@ void CChainState::LoadMempool(const ArgsManager& args)\n \n bool CChainState::LoadChainTip(const CChainParams& chainparams)\n {\n-    AssertLockHeld(cs_main);\n     const CCoinsViewCache& coins_cache = CoinsTip();\n     assert(!coins_cache.GetBestBlock().IsNull()); // Never called when the coins view is empty\n     const CBlockIndex* tip = m_chain.Tip();\n@@ -4461,7 +4431,6 @@ bool CChainState::ReplayBlocks(const CChainParams& params)\n //! Helper for CChainState::RewindBlockIndex\n void CChainState::EraseBlockData(CBlockIndex* index)\n {\n-    AssertLockHeld(cs_main);\n     assert(!m_chain.Contains(index)); // Make sure this block isn't active\n \n     // Reduce validity\n@@ -4625,7 +4594,6 @@ void UnloadBlockIndex(CTxMemPool* mempool)\n \n bool ChainstateManager::LoadBlockIndex(const CChainParams& chainparams)\n {\n-    AssertLockHeld(cs_main);\n     // Load block index from databases\n     bool needs_init = fReindex;\n     if (!fReindex) {"
      },
      {
        "sha": "f9d18f701af5c098ff62e843ed334ebea3e7d711",
        "filename": "src/wallet/scriptpubkeyman.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 7,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cc908d20128044c098707ec08b368026e862194/src/wallet/scriptpubkeyman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cc908d20128044c098707ec08b368026e862194/src/wallet/scriptpubkeyman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/scriptpubkeyman.cpp?ref=2cc908d20128044c098707ec08b368026e862194",
        "patch": "@@ -664,7 +664,6 @@ uint256 LegacyScriptPubKeyMan::GetID() const\n  */\n void LegacyScriptPubKeyMan::UpdateTimeFirstKey(int64_t nCreateTime)\n {\n-    AssertLockHeld(cs_KeyStore);\n     if (nCreateTime <= 1) {\n         // Cannot determine birthday information, so set the wallet birthday to\n         // the beginning of time.\n@@ -688,7 +687,6 @@ bool LegacyScriptPubKeyMan::AddKeyPubKey(const CKey& secret, const CPubKey &pubk\n \n bool LegacyScriptPubKeyMan::AddKeyPubKeyWithDB(WalletBatch& batch, const CKey& secret, const CPubKey& pubkey)\n {\n-    AssertLockHeld(cs_KeyStore);\n \n     // Make sure we aren't adding private keys to private key disabled wallets\n     assert(!m_storage.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS));\n@@ -1013,7 +1011,6 @@ CPubKey LegacyScriptPubKeyMan::GenerateNewKey(WalletBatch &batch, CHDChain& hd_c\n {\n     assert(!m_storage.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS));\n     assert(!m_storage.IsWalletFlagSet(WALLET_FLAG_BLANK_WALLET));\n-    AssertLockHeld(cs_KeyStore);\n     bool fCompressed = m_storage.CanSupportFeature(FEATURE_COMPRPUBKEY); // default to compressed public keys if we want 0.6.0 wallets\n \n     CKey secret;\n@@ -1400,7 +1397,6 @@ void LegacyScriptPubKeyMan::LearnAllRelatedScripts(const CPubKey& key)\n \n void LegacyScriptPubKeyMan::MarkReserveKeysAsUsed(int64_t keypool_id)\n {\n-    AssertLockHeld(cs_KeyStore);\n     bool internal = setInternalKeyPool.count(keypool_id);\n     if (!internal) assert(setExternalKeyPool.count(keypool_id) || set_pre_split_keypool.count(keypool_id));\n     std::set<int64_t> *setKeyPool = internal ? &setInternalKeyPool : (set_pre_split_keypool.empty() ? &setExternalKeyPool : &set_pre_split_keypool);\n@@ -1716,7 +1712,6 @@ void DescriptorScriptPubKeyMan::ReturnDestination(int64_t index, bool internal,\n \n std::map<CKeyID, CKey> DescriptorScriptPubKeyMan::GetKeys() const\n {\n-    AssertLockHeld(cs_desc_man);\n     if (m_storage.HasEncryptionKeys() && !m_storage.IsLocked()) {\n         KeyMap keys;\n         for (auto key_pair : m_map_crypted_keys) {\n@@ -1844,7 +1839,6 @@ void DescriptorScriptPubKeyMan::AddDescriptorKey(const CKey& key, const CPubKey\n \n bool DescriptorScriptPubKeyMan::AddDescriptorKeyWithDB(WalletBatch& batch, const CKey& key, const CPubKey &pubkey)\n {\n-    AssertLockHeld(cs_desc_man);\n     assert(!m_storage.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS));\n \n     if (m_storage.HasEncryptionKeys()) {\n@@ -2013,7 +2007,6 @@ std::unique_ptr<FlatSigningProvider> DescriptorScriptPubKeyMan::GetSigningProvid\n \n std::unique_ptr<FlatSigningProvider> DescriptorScriptPubKeyMan::GetSigningProvider(int32_t index, bool include_private) const\n {\n-    AssertLockHeld(cs_desc_man);\n     // Get the scripts, keys, and key origins for this script\n     std::unique_ptr<FlatSigningProvider> out_keys = MakeUnique<FlatSigningProvider>();\n     std::vector<CScript> scripts_temp;"
      },
      {
        "sha": "81cc7acfd7b0c0efe6622eeb5812bc166ed1781c",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 31,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cc908d20128044c098707ec08b368026e862194/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cc908d20128044c098707ec08b368026e862194/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=2cc908d20128044c098707ec08b368026e862194",
        "patch": "@@ -338,7 +338,6 @@ std::string COutput::ToString() const\n \n const CWalletTx* CWallet::GetWalletTx(const uint256& hash) const\n {\n-    AssertLockHeld(cs_wallet);\n     std::map<uint256, CWalletTx>::const_iterator it = mapWallet.find(hash);\n     if (it == mapWallet.end())\n         return nullptr;\n@@ -474,7 +473,6 @@ bool CWallet::SetMaxVersion(int nVersion)\n std::set<uint256> CWallet::GetConflicts(const uint256& txid) const\n {\n     std::set<uint256> result;\n-    AssertLockHeld(cs_wallet);\n \n     std::map<uint256, CWalletTx>::const_iterator it = mapWallet.find(txid);\n     if (it == mapWallet.end())\n@@ -496,7 +494,6 @@ std::set<uint256> CWallet::GetConflicts(const uint256& txid) const\n \n bool CWallet::HasWalletSpend(const uint256& txid) const\n {\n-    AssertLockHeld(cs_wallet);\n     auto iter = mapTxSpends.lower_bound(COutPoint(txid, 0));\n     return (iter != mapTxSpends.end() && iter->first.hash == txid);\n }\n@@ -758,7 +755,6 @@ DBErrors CWallet::ReorderTransactions()\n \n int64_t CWallet::IncOrderPosNext(WalletBatch* batch)\n {\n-    AssertLockHeld(cs_wallet);\n     int64_t nRet = nOrderPosNext++;\n     if (batch) {\n         batch->WriteOrderPosNext(nOrderPosNext);\n@@ -808,7 +804,6 @@ bool CWallet::MarkReplaced(const uint256& originalHash, const uint256& newHash)\n \n void CWallet::SetSpentKeyState(WalletBatch& batch, const uint256& hash, unsigned int n, bool used, std::set<CTxDestination>& tx_destinations)\n {\n-    AssertLockHeld(cs_wallet);\n     const CWalletTx* srctx = GetWalletTx(hash);\n     if (!srctx) return;\n \n@@ -828,7 +823,6 @@ void CWallet::SetSpentKeyState(WalletBatch& batch, const uint256& hash, unsigned\n \n bool CWallet::IsSpentKey(const uint256& hash, unsigned int n) const\n {\n-    AssertLockHeld(cs_wallet);\n     const CWalletTx* srctx = GetWalletTx(hash);\n     if (srctx) {\n         assert(srctx->tx->vout.size() > n);\n@@ -1003,7 +997,6 @@ bool CWallet::AddToWalletIfInvolvingMe(const CTransactionRef& ptx, CWalletTx::Co\n {\n     const CTransaction& tx = *ptx;\n     {\n-        AssertLockHeld(cs_wallet);\n \n         if (!confirm.hashBlock.IsNull()) {\n             for (const CTxIn& txin : tx.vin) {\n@@ -1272,7 +1265,6 @@ void CWallet::BlockUntilSyncedToCurrentChain() const {\n \n isminetype CWallet::IsMine(const CTxIn &txin) const\n {\n-    AssertLockHeld(cs_wallet);\n     std::map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n     if (mi != mapWallet.end())\n     {\n@@ -1303,19 +1295,16 @@ CAmount CWallet::GetDebit(const CTxIn &txin, const isminefilter& filter) const\n \n isminetype CWallet::IsMine(const CTxOut& txout) const\n {\n-    AssertLockHeld(cs_wallet);\n     return IsMine(txout.scriptPubKey);\n }\n \n isminetype CWallet::IsMine(const CTxDestination& dest) const\n {\n-    AssertLockHeld(cs_wallet);\n     return IsMine(GetScriptForDestination(dest));\n }\n \n isminetype CWallet::IsMine(const CScript& script) const\n {\n-    AssertLockHeld(cs_wallet);\n     isminetype result = ISMINE_NO;\n     for (const auto& spk_man_pair : m_spk_managers) {\n         result = std::max(result, spk_man_pair.second->IsMine(script));\n@@ -1345,7 +1334,6 @@ bool CWallet::IsChange(const CScript& script) const\n     // a better way of identifying which outputs are 'the send' and which are\n     // 'the change' will need to be implemented (maybe extend CWalletTx to remember\n     // which output, if any, was change).\n-    AssertLockHeld(cs_wallet);\n     if (IsMine(script))\n     {\n         CTxDestination address;\n@@ -1360,15 +1348,13 @@ bool CWallet::IsChange(const CScript& script) const\n \n CAmount CWallet::GetChange(const CTxOut& txout) const\n {\n-    AssertLockHeld(cs_wallet);\n     if (!MoneyRange(txout.nValue))\n         throw std::runtime_error(std::string(__func__) + \": value out of range\");\n     return (IsChange(txout) ? txout.nValue : 0);\n }\n \n bool CWallet::IsMine(const CTransaction& tx) const\n {\n-    AssertLockHeld(cs_wallet);\n     for (const CTxOut& txout : tx.vout)\n         if (IsMine(txout))\n             return true;\n@@ -2039,7 +2025,6 @@ bool CWalletTx::IsTrusted() const\n \n bool CWallet::IsTrusted(const CWalletTx& wtx, std::set<uint256>& trusted_parents) const\n {\n-    AssertLockHeld(cs_wallet);\n     // Quick answer in most cases\n     if (!chain().checkFinalTx(*wtx.tx)) return false;\n     int nDepth = wtx.GetDepthInMainChain();\n@@ -2185,7 +2170,6 @@ CAmount CWallet::GetAvailableBalance(const CCoinControl* coinControl) const\n \n void CWallet::AvailableCoins(std::vector<COutput>& vCoins, bool fOnlySafe, const CCoinControl* coinControl, const CAmount& nMinimumAmount, const CAmount& nMaximumAmount, const CAmount& nMinimumSumAmount, const uint64_t nMaximumCount) const\n {\n-    AssertLockHeld(cs_wallet);\n \n     vCoins.clear();\n     CAmount nTotal = 0;\n@@ -2312,7 +2296,6 @@ void CWallet::AvailableCoins(std::vector<COutput>& vCoins, bool fOnlySafe, const\n \n std::map<CTxDestination, std::vector<COutput>> CWallet::ListCoins() const\n {\n-    AssertLockHeld(cs_wallet);\n \n     std::map<CTxDestination, std::vector<COutput>> result;\n     std::vector<COutput> availableCoins;\n@@ -2353,7 +2336,6 @@ std::map<CTxDestination, std::vector<COutput>> CWallet::ListCoins() const\n \n const CTxOut& CWallet::FindNonChangeParentOutput(const CTransaction& tx, int output) const\n {\n-    AssertLockHeld(cs_wallet);\n     const CTransaction* ptx = &tx;\n     int n = output;\n     while (IsChange(ptx->vout[n]) && ptx->vin.size() > 0) {\n@@ -2516,7 +2498,6 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n \n bool CWallet::SignTransaction(CMutableTransaction& tx) const\n {\n-    AssertLockHeld(cs_wallet);\n \n     // Build coins map\n     std::map<COutPoint, Coin> coins;\n@@ -3214,7 +3195,6 @@ DBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n \n DBErrors CWallet::ZapSelectTx(std::vector<uint256>& vHashIn, std::vector<uint256>& vHashOut)\n {\n-    AssertLockHeld(cs_wallet);\n     DBErrors nZapSelectTxRet = WalletBatch(*database, \"cr+\").ZapSelectTx(vHashIn, vHashOut);\n     for (const uint256& hash : vHashOut) {\n         const auto& it = mapWallet.find(hash);\n@@ -3300,7 +3280,6 @@ bool CWallet::DelAddressBook(const CTxDestination& address)\n \n size_t CWallet::KeypoolCountExternalKeys() const\n {\n-    AssertLockHeld(cs_wallet);\n \n     unsigned int count = 0;\n     for (auto spk_man : GetActiveScriptPubKeyMans()) {\n@@ -3312,7 +3291,6 @@ size_t CWallet::KeypoolCountExternalKeys() const\n \n unsigned int CWallet::GetKeyPoolSize() const\n {\n-    AssertLockHeld(cs_wallet);\n \n     unsigned int count = 0;\n     for (auto spk_man : GetActiveScriptPubKeyMans()) {\n@@ -3429,7 +3407,6 @@ std::map<CTxDestination, CAmount> CWallet::GetAddressBalances() const\n \n std::set< std::set<CTxDestination> > CWallet::GetAddressGroupings() const\n {\n-    AssertLockHeld(cs_wallet);\n     std::set< std::set<CTxDestination> > groupings;\n     std::set<CTxDestination> grouping;\n \n@@ -3577,33 +3554,28 @@ void ReserveDestination::ReturnDestination()\n \n void CWallet::LockCoin(const COutPoint& output)\n {\n-    AssertLockHeld(cs_wallet);\n     setLockedCoins.insert(output);\n }\n \n void CWallet::UnlockCoin(const COutPoint& output)\n {\n-    AssertLockHeld(cs_wallet);\n     setLockedCoins.erase(output);\n }\n \n void CWallet::UnlockAllCoins()\n {\n-    AssertLockHeld(cs_wallet);\n     setLockedCoins.clear();\n }\n \n bool CWallet::IsLockedCoin(uint256 hash, unsigned int n) const\n {\n-    AssertLockHeld(cs_wallet);\n     COutPoint outpt(hash, n);\n \n     return (setLockedCoins.count(outpt) > 0);\n }\n \n void CWallet::ListLockedCoins(std::vector<COutPoint>& vOutpts) const\n {\n-    AssertLockHeld(cs_wallet);\n     for (std::set<COutPoint>::iterator it = setLockedCoins.begin();\n          it != setLockedCoins.end(); it++) {\n         COutPoint outpt = (*it);\n@@ -3614,7 +3586,6 @@ void CWallet::ListLockedCoins(std::vector<COutPoint>& vOutpts) const\n /** @} */ // end of Actions\n \n void CWallet::GetKeyBirthTimes(std::map<CKeyID, int64_t>& mapKeyBirth) const {\n-    AssertLockHeld(cs_wallet);\n     mapKeyBirth.clear();\n \n     LegacyScriptPubKeyMan* spk_man = GetLegacyScriptPubKeyMan();\n@@ -4184,7 +4155,6 @@ CKeyPool::CKeyPool(const CPubKey& vchPubKeyIn, bool internalIn)\n int CWalletTx::GetDepthInMainChain() const\n {\n     assert(pwallet != nullptr);\n-    AssertLockHeld(pwallet->cs_wallet);\n     if (isUnconfirmed() || isAbandoned()) return 0;\n \n     return (pwallet->GetLastBlockHeight() - m_confirm.block_height + 1) * (isConflicted() ? -1 : 1);\n@@ -4433,7 +4403,6 @@ void CWallet::LoadDescriptorScriptPubKeyMan(uint256 id, WalletDescriptor& desc)\n \n void CWallet::SetupDescriptorScriptPubKeyMans()\n {\n-    AssertLockHeld(cs_wallet);\n \n     // Make a seed\n     CKey seed_key;"
      },
      {
        "sha": "b14e7896c8af55c653e9b11a46d6948b95d769d3",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2cc908d20128044c098707ec08b368026e862194/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2cc908d20128044c098707ec08b368026e862194/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=2cc908d20128044c098707ec08b368026e862194",
        "patch": "@@ -1237,20 +1237,17 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     /** Get last block processed height */\n     int GetLastBlockHeight() const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet)\n     {\n-        AssertLockHeld(cs_wallet);\n         assert(m_last_block_processed_height >= 0);\n         return m_last_block_processed_height;\n     };\n     uint256 GetLastBlockHash() const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet)\n     {\n-        AssertLockHeld(cs_wallet);\n         assert(m_last_block_processed_height >= 0);\n         return m_last_block_processed;\n     }\n     /** Set last block processed height, currently only use in unit test */\n     void SetLastBlockProcessed(int block_height, uint256 block_hash) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet)\n     {\n-        AssertLockHeld(cs_wallet);\n         m_last_block_processed_height = block_height;\n         m_last_block_processed = block_hash;\n     };"
      }
    ]
  },
  {
    "sha": "0c53f3d5c453da0019f9b3e4924c124d9b6d21ce",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowYzUzZjNkNWM0NTNkYTAwMTlmOWIzZTQ5MjRjMTI0ZDliNmQyMWNl",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2020-09-03T23:42:03Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2020-09-14T08:30:17Z"
      },
      "message": "Clean up documentation and header after AssertLockHeld script-diff",
      "tree": {
        "sha": "a5697e4355c7d780f050d302d93de495ddcddee1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a5697e4355c7d780f050d302d93de495ddcddee1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0c53f3d5c453da0019f9b3e4924c124d9b6d21ce",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0c53f3d5c453da0019f9b3e4924c124d9b6d21ce",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0c53f3d5c453da0019f9b3e4924c124d9b6d21ce",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0c53f3d5c453da0019f9b3e4924c124d9b6d21ce/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2cc908d20128044c098707ec08b368026e862194",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2cc908d20128044c098707ec08b368026e862194",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2cc908d20128044c098707ec08b368026e862194"
      }
    ],
    "stats": {
      "total": 48,
      "additions": 3,
      "deletions": 45
    },
    "files": [
      {
        "sha": "47aa8887014a93e8858b27b2635ca3df0bc326e7",
        "filename": "doc/developer-notes.md",
        "status": "modified",
        "additions": 3,
        "deletions": 31,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0c53f3d5c453da0019f9b3e4924c124d9b6d21ce/doc/developer-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0c53f3d5c453da0019f9b3e4924c124d9b6d21ce/doc/developer-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/developer-notes.md?ref=0c53f3d5c453da0019f9b3e4924c124d9b6d21ce",
        "patch": "@@ -748,10 +748,8 @@ Threads and synchronization\n \n - Prefer `Mutex` type to `RecursiveMutex` one\n \n-- Consistently use [Clang Thread Safety Analysis](https://clang.llvm.org/docs/ThreadSafetyAnalysis.html) annotations to\n-  get compile-time warnings about potential race conditions in code. Combine annotations in function declarations with\n-  run-time asserts in function definitions:\n-\n+- Use [Clang Thread Safety Analysis](https://clang.llvm.org/docs/ThreadSafetyAnalysis.html) annotations\n+  to enable compile-time checks for race conditions and deadlocks:\n ```C++\n // txmempool.h\n class CTxMemPool\n@@ -763,35 +761,9 @@ public:\n     void UpdateTransactionsFromBlock(...) EXCLUSIVE_LOCKS_REQUIRED(::cs_main, cs);\n     ...\n }\n-\n-// txmempool.cpp\n-void CTxMemPool::UpdateTransactionsFromBlock(...)\n-{\n-    ...\n-}\n-```\n-\n-```C++\n-// validation.h\n-class ChainstateManager\n-{\n-public:\n-    ...\n-    bool ProcessNewBlock(...) EXCLUSIVE_LOCKS_REQUIRED(!::cs_main);\n-    ...\n-}\n-\n-// validation.cpp\n-bool ChainstateManager::ProcessNewBlock(...)\n-{\n-    AssertLockNotHeld(::cs_main);\n-    ...\n-    LOCK(::cs_main);\n-    ...\n-}\n ```\n \n-- When Clang Thread Safety Analysis is unable to determine if a mutex is locked, use `LockAssertion` class instances:\n+- When Clang Thread Safety Analysis is unable to determine if a mutex is locked, use `AssertLockHeld`:\n \n ```C++\n // net_processing.h"
      },
      {
        "sha": "bbfaf273094cfc020c2387db77faa8eb865d78f9",
        "filename": "src/sync.h",
        "status": "modified",
        "additions": 0,
        "deletions": 14,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0c53f3d5c453da0019f9b3e4924c124d9b6d21ce/src/sync.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0c53f3d5c453da0019f9b3e4924c124d9b6d21ce/src/sync.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sync.h?ref=0c53f3d5c453da0019f9b3e4924c124d9b6d21ce",
        "patch": "@@ -352,18 +352,4 @@ class CSemaphoreGrant\n     }\n };\n \n-// Utility class for indicating to compiler thread analysis that a mutex is\n-// locked (when it couldn't be determined otherwise).\n-struct SCOPED_LOCKABLE LockAssertion\n-{\n-    template <typename Mutex>\n-    explicit LockAssertion(Mutex& mutex) EXCLUSIVE_LOCK_FUNCTION(mutex)\n-    {\n-#ifdef DEBUG_LOCKORDER\n-        AssertLockHeld(mutex);\n-#endif\n-    }\n-    ~LockAssertion() UNLOCK_FUNCTION() {}\n-};\n-\n #endif // BITCOIN_SYNC_H"
      }
    ]
  }
]