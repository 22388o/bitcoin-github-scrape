[
  {
    "sha": "5293339e4dddc84ca5a219e9b8ca4130b00ef1d8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1MjkzMzM5ZTRkZGRjODRjYTVhMjE5ZTliOGNhNDEzMGIwMGVmMWQ4",
    "commit": {
      "author": {
        "name": "shivendra_mishra@live.com",
        "email": "shivendra_mishra@live.com",
        "date": "2019-04-12T14:55:33Z"
      },
      "committer": {
        "name": "shivendra_mishra@live.com",
        "email": "shivendra_mishra@live.com",
        "date": "2019-04-12T14:55:33Z"
      },
      "message": "Issue #11902\n* Pulls core NAT-PMP files from https://github.com/miniupnp/libnatpmp.git\n* Above codes are ported/filtered for easier integration.",
      "tree": {
        "sha": "275c1e528bde0387374f3343b18588b44ac1ca59",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/275c1e528bde0387374f3343b18588b44ac1ca59"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5293339e4dddc84ca5a219e9b8ca4130b00ef1d8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5293339e4dddc84ca5a219e9b8ca4130b00ef1d8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5293339e4dddc84ca5a219e9b8ca4130b00ef1d8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5293339e4dddc84ca5a219e9b8ca4130b00ef1d8/comments",
    "author": {
      "login": "MishraShivendra",
      "id": 8533116,
      "node_id": "MDQ6VXNlcjg1MzMxMTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8533116?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MishraShivendra",
      "html_url": "https://github.com/MishraShivendra",
      "followers_url": "https://api.github.com/users/MishraShivendra/followers",
      "following_url": "https://api.github.com/users/MishraShivendra/following{/other_user}",
      "gists_url": "https://api.github.com/users/MishraShivendra/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MishraShivendra/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MishraShivendra/subscriptions",
      "organizations_url": "https://api.github.com/users/MishraShivendra/orgs",
      "repos_url": "https://api.github.com/users/MishraShivendra/repos",
      "events_url": "https://api.github.com/users/MishraShivendra/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MishraShivendra/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MishraShivendra",
      "id": 8533116,
      "node_id": "MDQ6VXNlcjg1MzMxMTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8533116?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MishraShivendra",
      "html_url": "https://github.com/MishraShivendra",
      "followers_url": "https://api.github.com/users/MishraShivendra/followers",
      "following_url": "https://api.github.com/users/MishraShivendra/following{/other_user}",
      "gists_url": "https://api.github.com/users/MishraShivendra/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MishraShivendra/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MishraShivendra/subscriptions",
      "organizations_url": "https://api.github.com/users/MishraShivendra/orgs",
      "repos_url": "https://api.github.com/users/MishraShivendra/repos",
      "events_url": "https://api.github.com/users/MishraShivendra/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MishraShivendra/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "79c345a0114c9a83fd40e01150519373c017b130",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/79c345a0114c9a83fd40e01150519373c017b130",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/79c345a0114c9a83fd40e01150519373c017b130"
      }
    ],
    "stats": {
      "total": 1159,
      "additions": 1159,
      "deletions": 0
    },
    "files": [
      {
        "sha": "9f20c72fca278af846a2f2ffa8c8779a40add7d2",
        "filename": "contrib/debian/copyright",
        "status": "modified",
        "additions": 31,
        "deletions": 0,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5293339e4dddc84ca5a219e9b8ca4130b00ef1d8/contrib/debian/copyright",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5293339e4dddc84ca5a219e9b8ca4130b00ef1d8/contrib/debian/copyright",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/copyright?ref=5293339e4dddc84ca5a219e9b8ca4130b00ef1d8",
        "patch": "@@ -155,3 +155,34 @@ Comment:\n \n License: public-domain\n  This work is in the public domain.\n+\n+Files: src/natpmp/gateway.cpp \n+       src/natpmp/include/gateway.h\n+       src/natpmp/natpmp.cpp\n+       src/natpmp/include/natpmp.h\n+Copyright: 2007-2011, Thomas BERNARD\n+License:\n+All rights reserved.\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are met:\n+\n+    * Redistributions of source code must retain the above copyright notice,\n+      this list of conditions and the following disclaimer.\n+    * Redistributions in binary form must reproduce the above copyright notice,\n+      this list of conditions and the following disclaimer in the documentation\n+      and/or other materials provided with the distribution.\n+    * The name of the author may not be used to endorse or promote products\n+\t  derived from this software without specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.\n+"
      },
      {
        "sha": "be1e4967335e007540730734599f9d5b9d55e41d",
        "filename": "src/natpmp/gateway.cpp",
        "status": "added",
        "additions": 548,
        "deletions": 0,
        "changes": 548,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5293339e4dddc84ca5a219e9b8ca4130b00ef1d8/src/natpmp/gateway.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5293339e4dddc84ca5a219e9b8ca4130b00ef1d8/src/natpmp/gateway.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/natpmp/gateway.cpp?ref=5293339e4dddc84ca5a219e9b8ca4130b00ef1d8",
        "patch": "@@ -0,0 +1,548 @@\n+#include <stdio.h>\n+#include <ctype.h>\n+#ifndef WIN32\n+#include <netinet/in.h>\n+#endif\n+#if !defined(_MSC_VER)\n+#include <sys/param.h>\n+#endif\n+#ifdef __linux__\n+#define USE_PROC_NET_ROUTE\n+#undef USE_SOCKET_ROUTE\n+#undef USE_SYSCTL_NET_ROUTE\n+#endif\n+\n+#if defined(BSD) || defined(__FreeBSD_kernel__)\n+#undef USE_PROC_NET_ROUTE\n+#define USE_SOCKET_ROUTE\n+#undef USE_SYSCTL_NET_ROUTE\n+#endif\n+\n+#ifdef __APPLE__\n+#undef USE_PROC_NET_ROUTE\n+#undef USE_SOCKET_ROUTE\n+#define USE_SYSCTL_NET_ROUTE\n+#endif\n+\n+#if (defined(sun) && defined(__SVR4))\n+#undef USE_PROC_NET_ROUTE\n+#define USE_SOCKET_ROUTE\n+#undef USE_SYSCTL_NET_ROUTE\n+#endif\n+\n+#ifdef WIN32\n+#undef USE_PROC_NET_ROUTE\n+#undef USE_SOCKET_ROUTE\n+#undef USE_SYSCTL_NET_ROUTE\n+//#define USE_WIN32_CODE\n+#define USE_WIN32_CODE_2\n+#endif\n+\n+#ifdef __CYGWIN__\n+#undef USE_PROC_NET_ROUTE\n+#undef USE_SOCKET_ROUTE\n+#undef USE_SYSCTL_NET_ROUTE\n+#define USE_WIN32_CODE\n+#include <stdarg.h>\n+#include <w32api/windef.h>\n+#include <w32api/winbase.h>\n+#include <w32api/winreg.h>\n+#endif\n+\n+#ifdef __HAIKU__\n+#include <sys/sockio.h>\n+#define USE_HAIKU_CODE\n+#endif\n+\n+#ifdef USE_SYSCTL_NET_ROUTE\n+#include <sys/sysctl.h>\n+#endif\n+\n+#ifdef USE_SOCKET_ROUTE\n+#include <string.h>\n+#endif\n+\n+#if defined(USE_SOCKET_ROUTE) || defined(__HAIKU__)\n+#include <unistd.h>\n+#include <net/if.h>\n+#endif\n+\n+#if defined(USE_SYSCTL_NET_ROUTE) || defined(__HAIKU__)\n+#include <stdlib.h>\n+#endif\n+\n+#if defined(USE_SOCKET_ROUTE) || defined(USE_SYSCTL_NET_ROUTE)\n+#include <sys/socket.h>\n+#include <net/route.h>\n+#endif\n+\n+#ifdef USE_WIN32_CODE\n+#include <unknwn.h>\n+#include <winreg.h>\n+#define MAX_KEY_LENGTH 255\n+#define MAX_VALUE_LENGTH 16383\n+#endif\n+\n+#ifdef USE_WIN32_CODE_2\n+#include <windows.h>\n+#include <iphlpapi.h>\n+#endif\n+#include <gateway.h>\n+#ifndef WIN32\n+#define SUCCESS (0)\n+#define FAILED  (-1)\n+#endif\n+#ifdef USE_PROC_NET_ROUTE\n+#include <sstream>\n+#include <list>\n+#include <algorithm>\n+/*\n+ * There is no portable method to get the default route gateway.\n+ * So below are four (or five ?) different functions implementing this.\n+ * Parsing /proc/net/route is for Linux.\n+ * sysctl is the way to access such information on BSD systems.\n+ * Many systems should provide route information through raw PF_ROUTE\n+ * sockets.\n+ * In MS Windows, default gateway is found by looking into the registry\n+ * or by using GetBestRoute().\n+ *\n+ */\n+\n+/*\n+ parse /proc/net/route which is as follow :\n+\n+Iface   Destination     Gateway         Flags   RefCnt  Use     Metric  Mask            MTU     Window  IRTT\n+wlan0   0001A8C0        00000000        0001    0       0       0       00FFFFFF        0       0       0\n+eth0    0000FEA9        00000000        0001    0       0       0       0000FFFF        0       0       0\n+wlan0   00000000        0101A8C0        0003    0       0       0       00000000        0       0       0\n+eth0    00000000        00000000        0001    0       0       1000    00000000        0       0       0\n+\n+ One header line, and then one line by route by route table entry.\n+*/\n+\n+int TestIfWhiteSpace(char character)\n+{\n+    std::list<char> whiteSpaces = {'\\f', '\\n', '\\r', '\\t', '\\v'};\n+    return std::count(whiteSpaces.begin(), whiteSpaces.end(), character);\n+}\n+\n+int GetDefaultGateway(in_addr_t * addr)\n+{\n+        int64_t d = 0;\n+        int64_t g = 0;\n+        char buf[256] = {0};\n+        int line = 0;\n+        char * p = nullptr;\n+        FILE* f = fopen(\"/proc/net/route\", \"r\");\n+        if(!f)\n+                return FAILED;\n+        while(fgets(buf, sizeof(buf), f)) {\n+                if(line > 0) {  /* skip the first line */\n+                        p = buf;\n+                        /* skip the interface name */\n+                        while(*p && !TestIfWhiteSpace(*p))\n+                                p++;\n+                        while(*p && TestIfWhiteSpace(*p))\n+                                p++;\n+            // Want just the gateway column\n+                        std::string data(p);\n+            data = data.substr(data.find('\\t')+1);\n+            data = data.substr(0, data.find('\\t'));\n+\n+                        std::stringstream dataParser;\n+            dataParser<<std::hex<<data;\n+                        dataParser >> g >> d;\n+            if(d == 0 && g != 0) {\n+                                *addr = (in_addr_t)g;\n+                                fclose(f);\n+                                return SUCCESS;\n+                        }\n+                }\n+                line++;\n+        }\n+        /* default route not found ! */\n+        if(f)\n+                fclose(f);\n+        return FAILED;\n+}\n+#endif /* #ifdef USE_PROC_NET_ROUTE */\n+\n+\n+#ifdef USE_SYSCTL_NET_ROUTE\n+\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))\n+\n+int GetDefaultGateway(in_addr_t * addr)\n+{\n+    /* net.route.0.inet.flags.gateway */\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, AF_INET,\n+                 NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    char* buf = nullptr;\n+    char* p = nullptr;\n+    struct rt_msghdr * rt = {0};\n+    struct sockaddr * sa = {0};\n+    struct sockaddr * sa_tab[RTAX_MAX];\n+    int i = 0;\n+    int r = FAILED;\n+    if(sysctl(mib, sizeof(mib)/sizeof(int), 0, &l, 0, 0) < 0) {\n+        return FAILED;\n+    }\n+    if(l>0) {\n+        buf = (char*)malloc(l);\n+        if(sysctl(mib, sizeof(mib)/sizeof(int), buf, &l, 0, 0) < 0) {\n+            free(buf);\n+            return FAILED;\n+        }\n+        for(p=buf; p<buf+l; p+=rt->rtm_msglen) {\n+            rt = (struct rt_msghdr *)p;\n+            sa = (struct sockaddr *)(rt + 1);\n+            for(i=0; i<RTAX_MAX; i++) {\n+                if(rt->rtm_addrs & (1 << i)) {\n+                    sa_tab[i] = sa;\n+                    sa = (struct sockaddr *)((char *)sa + ROUNDUP(sa->sa_len));\n+                } else {\n+                    sa_tab[i] = nullptr;\n+                }\n+            }\n+            if( ((rt->rtm_addrs & (RTA_DST|RTA_GATEWAY)) == (RTA_DST|RTA_GATEWAY))\n+              && sa_tab[RTAX_DST]->sa_family == AF_INET\n+              && sa_tab[RTAX_GATEWAY]->sa_family == AF_INET) {\n+                if(((struct sockaddr_in *)sa_tab[RTAX_DST])->sin_addr.s_addr == 0) {\n+                    *addr = ((struct sockaddr_in *)(sa_tab[RTAX_GATEWAY]))->sin_addr.s_addr;\n+                    r = SUCCESS;\n+                }\n+            }\n+        }\n+        free(buf);\n+    }\n+    return r;\n+}\n+#endif\n+\n+\n+#ifdef USE_SOCKET_ROUTE\n+/* Thanks to Darren Kenny for this code */\n+#define NEXTADDR(w, u) \\\n+        if (rtm_addrs & (w)) {\\\n+            l = sizeof(struct sockaddr); memmove(cp, &(u), l); cp += l;\\\n+        }\n+\n+#define rtm m_rtmsg.m_rtm\n+\n+struct {\n+  struct rt_msghdr m_rtm;\n+  char       m_space[512];\n+} m_rtmsg;\n+\n+int GetDefaultGateway(in_addr_t *addr)\n+{\n+  int s = 0, seq = 0, l = 0, rtm_addrs = 0, i = 0;\n+  pid_t pid = {0};\n+  struct sockaddr so_dst = {0}, so_mask = {0};\n+  char *cp = m_rtmsg.m_space;\n+  struct sockaddr *gate = nullptr, *sa = nullptr;\n+  struct rt_msghdr *msg_hdr = nullptr;\n+\n+  pid = getpid();\n+  seq = 0;\n+  rtm_addrs = RTA_DST | RTA_NETMASK;\n+\n+  memset(&so_dst, 0, sizeof(so_dst));\n+  memset(&so_mask, 0, sizeof(so_mask));\n+  memset(&rtm, 0, sizeof(struct rt_msghdr));\n+\n+  rtm.rtm_type = RTM_GET;\n+  rtm.rtm_flags = RTF_UP | RTF_GATEWAY;\n+  rtm.rtm_version = RTM_VERSION;\n+  rtm.rtm_seq = ++seq;\n+  rtm.rtm_addrs = rtm_addrs;\n+\n+  so_dst.sa_family = AF_INET;\n+  so_mask.sa_family = AF_INET;\n+\n+  NEXTADDR(RTA_DST, so_dst);\n+  NEXTADDR(RTA_NETMASK, so_mask);\n+\n+  rtm.rtm_msglen = l = cp - (char *)&m_rtmsg;\n+\n+  s = socket(PF_ROUTE, SOCK_RAW, 0);\n+\n+  if (write(s, (char *)&m_rtmsg, l) < 0) {\n+      close(s);\n+      return FAILED;\n+  }\n+\n+  do {\n+    l = read(s, (char *)&m_rtmsg, sizeof(m_rtmsg));\n+  } while (l > 0 && (rtm.rtm_seq != seq || rtm.rtm_pid != pid));\n+\n+  close(s);\n+\n+  msg_hdr = &rtm;\n+\n+  cp = ((char *)(msg_hdr + 1));\n+  if (msg_hdr->rtm_addrs) {\n+    for (i = 1; i; i <<= 1)\n+      if (i & msg_hdr->rtm_addrs) {\n+        sa = (struct sockaddr *)cp;\n+        if (i == RTA_GATEWAY )\n+          gate = sa;\n+\n+        cp += sizeof(struct sockaddr);\n+      }\n+  } else {\n+      return FAILED;\n+  }\n+\n+\n+  if (gate != nullptr ) {\n+      *addr = ((struct sockaddr_in *)gate)->sin_addr.s_addr;\n+      return SUCCESS;\n+  } else {\n+      return FAILED;\n+  }\n+}\n+#endif /* #ifdef USE_SOCKET_ROUTE */\n+\n+#ifdef USE_WIN32_CODE\n+LIBSPEC int GetDefaultGateway(in_addr_t * addr)\n+{\n+    HKEY networkCardsKey;\n+    HKEY networkCardKey;\n+    HKEY interfacesKey;\n+    HKEY interfaceKey;\n+    DWORD i = 0;\n+    DWORD numSubKeys = 0;\n+    TCHAR keyName[MAX_KEY_LENGTH];\n+    DWORD keyNameLength = MAX_KEY_LENGTH;\n+    TCHAR keyValue[MAX_VALUE_LENGTH];\n+    DWORD keyValueLength = MAX_VALUE_LENGTH;\n+    DWORD keyValueType = REG_SZ;\n+    TCHAR gatewayValue[MAX_VALUE_LENGTH];\n+    DWORD gatewayValueLength = MAX_VALUE_LENGTH;\n+    DWORD gatewayValueType = REG_MULTI_SZ;\n+    int done = 0;\n+\n+#ifdef UNICODE\n+    LPCTSTR networkCardsPath = L\"SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\NetworkCards\";\n+    LPCTSTR interfacesPath = L\"SYSTEM\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters\\\\Interfaces\";\n+#define STR_SERVICENAME     L\"ServiceName\"\n+#define STR_DHCPDEFAULTGATEWAY L\"DhcpDefaultGateway\"\n+#define STR_DEFAULTGATEWAY    L\"DefaultGateway\"\n+#else\n+    LPCTSTR networkCardsPath = \"SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\NetworkCards\";\n+    LPCTSTR interfacesPath = \"SYSTEM\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters\\\\Interfaces\";\n+#define STR_SERVICENAME     \"ServiceName\"\n+#define STR_DHCPDEFAULTGATEWAY \"DhcpDefaultGateway\"\n+#define STR_DEFAULTGATEWAY    \"DefaultGateway\"\n+#endif\n+    // The windows registry lists its primary network devices in the following location:\n+    // HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\NetworkCards\n+    //\n+    // Each network device has its own subfolder, named with an index, with various properties:\n+    // -NetworkCards\n+    //   -5\n+    //     -Description = Broadcom 802.11n Network Adapter\n+    //     -ServiceName = {E35A72F8-5065-4097-8DFE-C7790774EE4D}\n+    //   -8\n+    //     -Description = Marvell Yukon 88E8058 PCI-E Gigabit Ethernet Controller\n+    //     -ServiceName = {86226414-5545-4335-A9D1-5BD7120119AD}\n+    //\n+    // The above service name is the name of a subfolder within:\n+    // HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\n+    //\n+    // There may be more subfolders in this interfaces path than listed in the network cards path above:\n+    // -Interfaces\n+    //   -{3a539854-6a70-11db-887c-806e6f6e6963}\n+    //     -DhcpIPAddress = 0.0.0.0\n+    //     -[more]\n+    //   -{E35A72F8-5065-4097-8DFE-C7790774EE4D}\n+    //     -DhcpIPAddress = 10.0.1.4\n+    //     -DhcpDefaultGateway = 10.0.1.1\n+    //     -[more]\n+    //   -{86226414-5545-4335-A9D1-5BD7120119AD}\n+    //     -DhcpIpAddress = 10.0.1.5\n+    //     -DhcpDefaultGateay = 10.0.1.1\n+    //     -[more]\n+    //\n+    // In order to extract this information, we enumerate each network card, and extract the ServiceName value.\n+    // This is then used to open the interface subfolder, and attempt to extract a DhcpDefaultGateway value.\n+    // Once one is found, we're done.\n+    //\n+    // It may be possible to simply enumerate the interface folders until we find one with a DhcpDefaultGateway value.\n+    // However, the technique used is the technique most cited on the web, and we assume it to be more correct.\n+\n+    if(ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, // Open registry key or predefined key\n+                                     networkCardsPath,   // Name of registry subkey to open\n+                                     0,                  // Reserved - must be zero\n+                                     KEY_READ,           // Mask - desired access rights\n+                                     &networkCardsKey))  // Pointer to output key\n+    {\n+        // Unable to open network cards keys\n+        return -1;\n+    }\n+\n+    if(ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, // Open registry key or predefined key\n+                                     interfacesPath,     // Name of registry subkey to open\n+                                     0,                  // Reserved - must be zero\n+                                     KEY_READ,           // Mask - desired access rights\n+                                     &interfacesKey))    // Pointer to output key\n+    {\n+        // Unable to open interfaces key\n+        RegCloseKey(networkCardsKey);\n+        return -1;\n+    }\n+\n+    // Figure out how many subfolders are within the Network Cards folder\n+    RegQueryInfoKey(networkCardsKey, nullptr, nullptr, nullptr, &numSubKeys, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr);\n+\n+    // Enumerate through each subfolder within the Network Cards folder\n+    for(i = 0; i < numSubKeys && !done; i++)\n+    {\n+        keyNameLength = MAX_KEY_LENGTH;\n+        if(ERROR_SUCCESS == RegEnumKeyEx(networkCardsKey, // Open registry key\n+                                         i,               // Index of sub key to retrieve\n+                                         keyName,         // Buffer that receives the name of the sub key\n+                                         &keyNameLength,  // Variable that receives the size of the above buffer\n+                                         nullptr,            // Reserved - must be nullptr\n+                                         nullptr,            // Buffer that receives the class string\n+                                         nullptr,            // Variable that receives the size of the above buffer\n+                                         nullptr))           // Variable that receives the last write time of sub key\n+        {\n+            if(RegOpenKeyEx(networkCardsKey,  keyName, 0, KEY_READ, &networkCardKey) == ERROR_SUCCESS)\n+            {\n+                keyValueLength = MAX_VALUE_LENGTH;\n+                if(ERROR_SUCCESS == RegQueryValueEx(networkCardKey,   // Open registry key\n+                                                    STR_SERVICENAME,    // Name of key to query\n+                                                    nullptr,             // Reserved - must be nullptr\n+                                                    &keyValueType,    // Receives value type\n+                                                    (LPBYTE)keyValue, // Receives value\n+                                                    &keyValueLength)) // Receives value length in bytes\n+                {\n+                    if(RegOpenKeyEx(interfacesKey, keyValue, 0, KEY_READ, &interfaceKey) == ERROR_SUCCESS)\n+                    {\n+                        gatewayValueLength = MAX_VALUE_LENGTH;\n+                        if(ERROR_SUCCESS == RegQueryValueEx(interfaceKey,         // Open registry key\n+                                                            STR_DHCPDEFAULTGATEWAY, // Name of key to query\n+                                                            nullptr,                 // Reserved - must be nullptr\n+                                                            &gatewayValueType,    // Receives value type\n+                                                            (LPBYTE)gatewayValue, // Receives value\n+                                                            &gatewayValueLength)) // Receives value length in bytes\n+                        {\n+                            // Check to make sure it's a string\n+                            if((gatewayValueType == REG_MULTI_SZ || gatewayValueType == REG_SZ) && (gatewayValueLength > 1))\n+                            {\n+                                done = 1;\n+                            }\n+                        }\n+                        else if(ERROR_SUCCESS == RegQueryValueEx(interfaceKey,         // Open registry key\n+                                                            STR_DEFAULTGATEWAY, // Name of key to query\n+                                                            nullptr,                 // Reserved - must be nullptr\n+                                                            &gatewayValueType,    // Receives value type\n+                                                            (LPBYTE)gatewayValue,// Receives value\n+                                                            &gatewayValueLength)) // Receives value length in bytes\n+                        {\n+                            // Check to make sure it's a string\n+                            if((gatewayValueType == REG_MULTI_SZ || gatewayValueType == REG_SZ) && (gatewayValueLength > 1))\n+                            {\n+                                done = 1;\n+                            }\n+                        }\n+                        RegCloseKey(interfaceKey);\n+                    }\n+                }\n+                RegCloseKey(networkCardKey);\n+            }\n+        }\n+    }\n+\n+    RegCloseKey(interfacesKey);\n+    RegCloseKey(networkCardsKey);\n+\n+    if(done)\n+    {\n+#if UNICODE\n+        char tmp[32] = {0};\n+        for(i = 0; i < 32; i++) {\n+            tmp[i] = (char)gatewayValue[i];\n+            if(!tmp[i])\n+                break;\n+        }\n+        tmp[31] = '\\0';\n+        *addr = inet_addr(tmp);\n+#else\n+        *addr = inet_addr(gatewayValue);\n+#endif\n+        return 0;\n+    }\n+\n+    return -1;\n+}\n+#endif /* #ifdef USE_WIN32_CODE */\n+\n+#ifdef USE_WIN32_CODE_2\n+int GetDefaultGateway(in_addr_t *addr)\n+{\n+    MIB_IPFORWARDROW ip_forward;\n+    memset(&ip_forward, 0, sizeof(ip_forward));\n+    if(GetBestRoute(inet_addr(\"0.0.0.0\"), 0, &ip_forward) != NO_ERROR)\n+        return -1;\n+    *addr = ip_forward.dwForwardNextHop;\n+    return 0;\n+}\n+#endif /* #ifdef USE_WIN32_CODE_2 */\n+\n+#ifdef USE_HAIKU_CODE\n+int GetDefaultGateway(in_addr_t *addr)\n+{\n+    int fd, ret = -1;\n+    struct ifconf config = {0};\n+    void *buffer = nullptr;\n+    struct ifreq *interface = nullptr;\n+\n+    if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {\n+        return -1;\n+    }\n+    if (ioctl(fd, SIOCGRTSIZE, &config, sizeof(config)) != 0) {\n+        goto fail;\n+    }\n+    if (config.ifc_value < 1) {\n+        goto fail; /* No routes */\n+    }\n+    if ((buffer = malloc(config.ifc_value)) == nullptr) {\n+        goto fail;\n+    }\n+    config.ifc_len = config.ifc_value;\n+    config.ifc_buf = buffer;\n+    if (ioctl(fd, SIOCGRTTABLE, &config, sizeof(config)) != 0) {\n+        goto fail;\n+    }\n+    for (interface = buffer;\n+      (uint8_t *)interface < (uint8_t *)buffer + config.ifc_len; ) {\n+        struct route_entry route = interface->ifr_route;\n+        int intfSize;\n+        if (route.flags & (RTF_GATEWAY | RTF_DEFAULT)) {\n+            *addr = ((struct sockaddr_in *)route.gateway)->sin_addr.s_addr;\n+            ret = 0;\n+            break;\n+        }\n+        intfSize = sizeof(route) + IF_NAMESIZE;\n+        if (route.destination != nullptr) {\n+            intfSize += route.destination->sa_len;\n+        }\n+        if (route.mask != nullptr) {\n+            intfSize += route.mask->sa_len;\n+        }\n+        if (route.gateway != nullptr) {\n+            intfSize += route.gateway->sa_len;\n+        }\n+        interface = (struct ifreq *)((uint8_t *)interface + intfSize);\n+    }\n+fail:\n+    free(buffer);\n+    close(fd);\n+    return ret;\n+}\n+#endif /* #ifdef USE_HAIKU_CODE */"
      },
      {
        "sha": "9c8201136163e3db83ad0be3816cde472379ab55",
        "filename": "src/natpmp/include/gateway.h",
        "status": "added",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5293339e4dddc84ca5a219e9b8ca4130b00ef1d8/src/natpmp/include/gateway.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5293339e4dddc84ca5a219e9b8ca4130b00ef1d8/src/natpmp/include/gateway.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/natpmp/include/gateway.h?ref=5293339e4dddc84ca5a219e9b8ca4130b00ef1d8",
        "patch": "@@ -0,0 +1,18 @@\n+#ifndef BITCOIN_NATPMP_INCLUDE_GATEWAY_H\n+#define BITCOIN_NATPMP_INCLUDE_GATEWAY_H\n+\n+#ifdef WIN32\n+#if !defined(_MSC_VER)\n+#include <stdint.h>\n+#endif\n+#endif\n+#define in_addr_t uint32_t\n+#include <cstdint>\n+\n+/// @brief Get default gateway\n+///\n+/// @param addr Address\n+///\n+/// @return 0 Success, -1 Error\n+int GetDefaultGateway(in_addr_t * addr);\n+#endif // BITCOIN_NATPMP_INCLUDE_GATEWAY_H"
      },
      {
        "sha": "6a11319078448207a2f9209d99e0e29173cd6b06",
        "filename": "src/natpmp/include/natpmp.h",
        "status": "added",
        "additions": 198,
        "deletions": 0,
        "changes": 198,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5293339e4dddc84ca5a219e9b8ca4130b00ef1d8/src/natpmp/include/natpmp.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5293339e4dddc84ca5a219e9b8ca4130b00ef1d8/src/natpmp/include/natpmp.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/natpmp/include/natpmp.h?ref=5293339e4dddc84ca5a219e9b8ca4130b00ef1d8",
        "patch": "@@ -0,0 +1,198 @@\n+#ifndef BITCOIN_NATPMP_INCLUDE_NATPMP_H\n+#define BITCOIN_NATPMP_INCLUDE_NATPMP_H\n+\n+/* NAT-PMP Port as defined by the NAT-PMP draft */\n+#define NATPMP_PORT (5351)\n+\n+#include <time.h>\n+#if !defined(_MSC_VER)\n+#include <sys/time.h>\n+#endif\n+#ifdef WIN32\n+#include <winsock2.h>\n+#if !defined(_MSC_VER)\n+#include <stdint.h>\n+#endif\n+#define in_addr_t uint32_t\n+#else\n+#define LIBSPEC\n+#include <netinet/in.h>\n+#endif\n+#include <cstdint>\n+\n+typedef struct {\n+    int s;    /* socket */\n+    in_addr_t gateway;    /* default gateway (IPv4) */\n+    int has_pending_request;\n+    unsigned char pending_request[12];\n+    int pending_request_len;\n+    int try_number;\n+    struct timeval retry_time;\n+} natpmp_t;\n+\n+typedef struct {\n+    int16_t type;    /* NATPMP_RESPTYPE_* */\n+    int16_t resultcode;    /* NAT-PMP response code */\n+    int64_t epoch;    /* Seconds since start of epoch */\n+    union {\n+        struct {\n+            struct in_addr addr;\n+        } publicaddress;\n+        struct {\n+            int16_t privateport;\n+            int16_t mappedpublicport;\n+            int64_t lifetime;\n+        } newportmapping;\n+    } pnu;\n+} natpmpresp_t;\n+\n+/* possible values for type field of natpmpresp_t */\n+#define NATPMP_RESPTYPE_PUBLICADDRESS (0)\n+#define NATPMP_RESPTYPE_UDPPORTMAPPING (1)\n+#define NATPMP_RESPTYPE_TCPPORTMAPPING (2)\n+\n+/* Values to pass to SendNewPortMappingRequest() */\n+#define NATPMP_PROTOCOL_UDP (1)\n+#define NATPMP_PROTOCOL_TCP (2)\n+\n+/* return values */\n+/* NATPMP_ERR_INVALIDARGS : invalid arguments passed to the function */\n+#define NATPMP_ERR_INVALIDARGS (-1)\n+/* NATPMP_ERR_SOCKETERROR : socket() failed. Check errno for details */\n+#define NATPMP_ERR_SOCKETERROR (-2)\n+/* NATPMP_ERR_CANNOTGETGATEWAY : can't get default gateway IP */\n+#define NATPMP_ERR_CANNOTGETGATEWAY (-3)\n+/* NATPMP_ERR_CLOSEERR : close() failed. Check errno for details */\n+#define NATPMP_ERR_CLOSEERR (-4)\n+/* NATPMP_ERR_RECVFROM : recvfrom() failed. Check errno for details */\n+#define NATPMP_ERR_RECVFROM (-5)\n+/* NATPMP_ERR_NOPENDINGREQ : ReadNatPmpResponseOrRetry() called while\n+ * no NAT-PMP request was pending */\n+#define NATPMP_ERR_NOPENDINGREQ (-6)\n+/* NATPMP_ERR_NOGATEWAYSUPPORT : the gateway does not support NAT-PMP */\n+#define NATPMP_ERR_NOGATEWAYSUPPORT (-7)\n+/* NATPMP_ERR_CONNECTERR : connect() failed. Check errno for details */\n+#define NATPMP_ERR_CONNECTERR (-8)\n+/* NATPMP_ERR_WRONGPACKETSOURCE : packet not received from the network gateway */\n+#define NATPMP_ERR_WRONGPACKETSOURCE (-9)\n+/* NATPMP_ERR_SENDERR : send() failed. Check errno for details */\n+#define NATPMP_ERR_SENDERR (-10)\n+/* NATPMP_ERR_FCNTLERROR : fcntl() failed. Check errno for details */\n+#define NATPMP_ERR_FCNTLERROR (-11)\n+/* NATPMP_ERR_GETTIMEOFDAYERR : gettimeofday() failed. Check errno for details */\n+#define NATPMP_ERR_GETTIMEOFDAYERR (-12)\n+\n+#define NATPMP_ERR_UNSUPPORTEDVERSION (-14)\n+#define NATPMP_ERR_UNSUPPORTEDOPCODE (-15)\n+\n+/* Errors from the server : */\n+#define NATPMP_ERR_UNDEFINEDERROR (-49)\n+#define NATPMP_ERR_NOTAUTHORIZED (-51)\n+#define NATPMP_ERR_NETWORKFAILURE (-52)\n+#define NATPMP_ERR_OUTOFRESOURCES (-53)\n+\n+/* NATPMP_TRYAGAIN : no data available for the moment. Try again later */\n+#define NATPMP_TRYAGAIN (-100)\n+/* Failure in select() */\n+#define NATMAP_ERR_SELECT (-101)\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/*\n+ * InitNatPmp()\n+ * Initialize a natpmp_t object\n+ * With forcegw=1 the gateway is not detected automatically.\n+ * Return values :\n+ * 0 = OK\n+ * NATPMP_ERR_INVALIDARGS\n+ * NATPMP_ERR_SOCKETERROR\n+ * NATPMP_ERR_FCNTLERROR\n+ * NATPMP_ERR_CANNOTGETGATEWAY\n+ * NATPMP_ERR_CONNECTERR\n+ *\n+ */\n+int InitNatPmp(natpmp_t * p, int forcegw, in_addr_t forcedgw);\n+\n+/*\n+ * CloseNatPmp()\n+ * Close resources associated with a natpmp_t object\n+ * Return values :\n+ * 0 = OK\n+ * NATPMP_ERR_INVALIDARGS\n+ * NATPMP_ERR_CLOSEERR\n+ *\n+ */\n+int CloseNatPmp(natpmp_t * p);\n+\n+/*\n+ * SendPublicAddressRequest()\n+ * Send a public address NAT-PMP request to the network gateway\n+ * Return values :\n+ * 2 = OK (size of the request)\n+ * NATPMP_ERR_INVALIDARGS\n+ * NATPMP_ERR_SENDERR\n+ *\n+ */\n+int SendPublicAddressRequest(natpmp_t * p);\n+\n+/*\n+ * SendNewPortMappingRequest()\n+ * Send a new port mapping NAT-PMP request to the network gateway\n+ * Arguments :\n+ * protocol is either NATPMP_PROTOCOL_TCP or NATPMP_PROTOCOL_UDP,\n+ * lifetime is in seconds.\n+ * To remove a port mapping, set lifetime to zero.\n+ * To remove all port mappings to the host, set lifetime and both ports\n+ * to zero.\n+ * Return values :\n+ * 12 = OK (size of the request)\n+ * NATPMP_ERR_INVALIDARGS\n+ * NATPMP_ERR_SENDERR\n+ *\n+ */\n+int SendNewPortMappingRequest(natpmp_t * p, int protocol, int16_t privateport,\n+                              int16_t publicport, int64_t lifetime);\n+\n+/*\n+ * GetNatPmpRequestTimeout()\n+ * Fills the timeval structure with the timeout duration of the\n+ * currently pending NAT-PMP request.\n+ * Return values :\n+ * 0 = OK\n+ * NATPMP_ERR_INVALIDARGS\n+ * NATPMP_ERR_GETTIMEOFDAYERR\n+ * NATPMP_ERR_NOPENDINGREQ\n+ *\n+ */\n+int GetNatPmpRequestTimeout(natpmp_t * p, struct timeval * timeout);\n+\n+/*\n+ * ReadNatPmpResponseOrRetry()\n+ * Fills the natpmpresp_t structure if possible\n+ * Return values :\n+ * 0 = OK\n+ * NATPMP_TRYAGAIN\n+ * NATPMP_ERR_INVALIDARGS\n+ * NATPMP_ERR_NOPENDINGREQ\n+ * NATPMP_ERR_NOGATEWAYSUPPORT\n+ * NATPMP_ERR_RECVFROM\n+ * NATPMP_ERR_WRONGPACKETSOURCE\n+ * NATPMP_ERR_UNSUPPORTEDVERSION\n+ * NATPMP_ERR_UNSUPPORTEDOPCODE\n+ * NATPMP_ERR_NOTAUTHORIZED\n+ * NATPMP_ERR_NETWORKFAILURE\n+ * NATPMP_ERR_OUTOFRESOURCES\n+ * NATPMP_ERR_UNSUPPORTEDOPCODE\n+ * NATPMP_ERR_UNDEFINEDERROR\n+ *\n+ */\n+int ReadNatPmpResponseOrRetry(natpmp_t * p, natpmpresp_t * response);\n+\n+const char * StrNatPmpErr(int t);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+#endif // BITCOIN_NATPMP_INCLUDE_NATPMP_H"
      },
      {
        "sha": "5bde7d0b4a0a46c146f14c827663fc5474a233aa",
        "filename": "src/natpmp/natpmp.cpp",
        "status": "added",
        "additions": 364,
        "deletions": 0,
        "changes": 364,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5293339e4dddc84ca5a219e9b8ca4130b00ef1d8/src/natpmp/natpmp.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5293339e4dddc84ca5a219e9b8ca4130b00ef1d8/src/natpmp/natpmp.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/natpmp/natpmp.cpp?ref=5293339e4dddc84ca5a219e9b8ca4130b00ef1d8",
        "patch": "@@ -0,0 +1,364 @@\n+#ifdef __linux__\n+#define _BSD_SOURCE 1\n+#endif\n+#include <string.h>\n+\n+#include <errno.h>\n+\n+#ifdef WIN32\n+#include <winsock2.h>\n+#include <ws2tcpip.h>\n+#include <io.h>\n+#ifndef EWOULDBLOCK\n+#define EWOULDBLOCK WSAEWOULDBLOCK\n+#endif\n+#ifndef ECONNREFUSED\n+#define ECONNREFUSED WSAECONNREFUSED\n+#endif\n+#ifdef WIN32\n+#if defined(_MSC_VER)\n+#include <time.h>\n+#else\n+#include <sys/time.h>\n+#endif\n+int gettimeofday(struct timeval* p, void* tz /* IGNORED */);\n+#endif\n+#else\n+#include <unistd.h>\n+#include <fcntl.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#define closesocket close\n+#endif\n+#include <natpmp.h>\n+#include <gateway.h>\n+#include <stdio.h>\n+\n+#ifdef _MSC_VER\n+int gettimeofday(struct timeval* p, void* tz)\n+{\n+    union {\n+        long long ns100; /*time since 1 Jan 1601 in 100ns units */\n+        FILETIME ft;\n+    } _now;\n+\n+    if(!p)\n+        return -1;\n+    GetSystemTimeAsFileTime( &(_now.ft) );\n+    p->tv_usec =(long)((_now.ns100 / 10LL) % 1000000LL );\n+    p->tv_sec = (long)((_now.ns100-(116444736000000000LL))/10000000LL);\n+    return 0;\n+}\n+#endif\n+\n+int InitNatPmp(natpmp_t * p, int forcegw, in_addr_t forcedgw)\n+{\n+#ifdef WIN32\n+    u_long ioctlArg = 1;\n+#else\n+    int flags;\n+#endif\n+    if(!p)\n+        return NATPMP_ERR_INVALIDARGS;\n+    struct sockaddr_in addr;\n+    memset(p, 0, sizeof(natpmp_t));\n+    p->s = socket(PF_INET, SOCK_DGRAM, 0);\n+    if(p->s < 0)\n+        return NATPMP_ERR_SOCKETERROR;\n+#ifdef WIN32\n+    if(ioctlsocket(p->s, FIONBIO, &ioctlArg) == SOCKET_ERROR)\n+        return NATPMP_ERR_FCNTLERROR;\n+#else\n+    if((flags = fcntl(p->s, F_GETFL, 0)) < 0)\n+        return NATPMP_ERR_FCNTLERROR;\n+    if(fcntl(p->s, F_SETFL, flags | O_NONBLOCK) < 0)\n+        return NATPMP_ERR_FCNTLERROR;\n+#endif\n+\n+    if(forcegw) {\n+        p->gateway = forcedgw;\n+    } else {\n+        if(GetDefaultGateway(&(p->gateway)) < 0)\n+            return NATPMP_ERR_CANNOTGETGATEWAY;\n+    }\n+\n+    memset(&addr, 0, sizeof(addr));\n+    addr.sin_family = AF_INET;\n+    addr.sin_port = htons(NATPMP_PORT);\n+    addr.sin_addr.s_addr = p->gateway;\n+    if(connect(p->s, (struct sockaddr *)&addr, sizeof(addr)) < 0)\n+        return NATPMP_ERR_CONNECTERR;\n+    return 0;\n+}\n+\n+int CloseNatPmp(natpmp_t * p)\n+{\n+    if(!p)\n+        return NATPMP_ERR_INVALIDARGS;\n+    if(closesocket(p->s) < 0)\n+        return NATPMP_ERR_CLOSEERR;\n+    return 0;\n+}\n+\n+int sendpendingrequest(natpmp_t * p)\n+{\n+    if(!p)\n+        return NATPMP_ERR_INVALIDARGS;\n+#ifdef __linux__\n+    int r = (int)send(p->s, p->pending_request, p->pending_request_len, 0);\n+#else\n+    int r = (int)send(p->s, (const char*)p->pending_request, p->pending_request_len, 0);\n+#endif\n+\n+    return (r<0) ? NATPMP_ERR_SENDERR : r;\n+}\n+\n+int SendNatPmpRequest(natpmp_t * p)\n+{\n+    if(!p)\n+        return NATPMP_ERR_INVALIDARGS;\n+    p->has_pending_request = 1;\n+    p->try_number = 1;\n+    int n = sendpendingrequest(p);\n+    gettimeofday(&p->retry_time, nullptr);\n+    p->retry_time.tv_usec += 250000;\n+    if(p->retry_time.tv_usec >= 1000000) {\n+        p->retry_time.tv_usec -= 1000000;\n+        p->retry_time.tv_sec++;\n+    }\n+    return n;\n+}\n+\n+int GetNatPmpRequestTimeout(natpmp_t * p, struct timeval * timeout)\n+{\n+    if(!p || !timeout)\n+        return NATPMP_ERR_INVALIDARGS;\n+    if(!p->has_pending_request)\n+        return NATPMP_ERR_NOPENDINGREQ;\n+    struct timeval now;\n+    memset(&now, 0, sizeof(now));\n+    if(gettimeofday(&now, nullptr) < 0)\n+        return NATPMP_ERR_GETTIMEOFDAYERR;\n+    timeout->tv_sec = p->retry_time.tv_sec - now.tv_sec;\n+    timeout->tv_usec = p->retry_time.tv_usec - now.tv_usec;\n+    if(timeout->tv_usec < 0) {\n+        timeout->tv_usec += 1000000;\n+        timeout->tv_sec--;\n+    }\n+    return 0;\n+}\n+\n+int SendPublicAddressRequest(natpmp_t * p)\n+{\n+    if(!p)\n+        return NATPMP_ERR_INVALIDARGS;\n+    p->pending_request[0] = 0;\n+    p->pending_request[1] = 0;\n+    p->pending_request_len = 2;\n+    return SendNatPmpRequest(p);\n+}\n+\n+int SendNewPortMappingRequest(natpmp_t * p, int protocol, int16_t privateport,\n+                  int16_t publicport, int64_t lifetime)\n+{\n+    if(!p || (protocol!=NATPMP_PROTOCOL_TCP && protocol!=NATPMP_PROTOCOL_UDP))\n+        return NATPMP_ERR_INVALIDARGS;\n+    p->pending_request[0] = 0;\n+    p->pending_request[1] = protocol;\n+    p->pending_request[2] = 0;\n+    p->pending_request[3] = 0;\n+    p->pending_request[4] = (privateport >> 8) & 0xff;\n+    p->pending_request[5] = privateport & 0xff;\n+    p->pending_request[6] = (publicport >> 8) & 0xff;\n+    p->pending_request[7] = publicport & 0xff;\n+    p->pending_request[8] = (lifetime >> 24) & 0xff;\n+    p->pending_request[9] = (lifetime >> 16) & 0xff;\n+    p->pending_request[10] = (lifetime >> 8) & 0xff;\n+    p->pending_request[11] = lifetime & 0xff;\n+    p->pending_request_len = 12;\n+    return SendNatPmpRequest(p);\n+}\n+\n+int ReadNatPmpResponse(natpmp_t * p, natpmpresp_t * response)\n+{\n+    unsigned char buf[16] = {0};\n+    struct sockaddr_in addr;\n+    memset(&addr, 0, sizeof(addr));\n+    socklen_t addrlen = sizeof(addr);\n+    int n;\n+    if(!p)\n+        return NATPMP_ERR_INVALIDARGS;\n+#ifdef __linux__\n+    n = recvfrom(p->s, buf, sizeof(buf), 0,\n+                 (struct sockaddr *)&addr, &addrlen);\n+#else\n+    n = recvfrom(p->s, (char*)buf, sizeof(buf), 0,\n+                 (struct sockaddr *)&addr, &addrlen);\n+#endif\n+\n+    if(n<0) {\n+#ifdef WIN32\n+        switch(WSAGetLastError()) {\n+#else\n+        switch(errno) {\n+#endif\n+            /*case EAGAIN:*/\n+            case EWOULDBLOCK:\n+                n = NATPMP_TRYAGAIN;\n+                break;\n+            case ECONNREFUSED:\n+                n = NATPMP_ERR_NOGATEWAYSUPPORT;\n+                break;\n+            default:\n+                n = NATPMP_ERR_RECVFROM;\n+        }\n+    /* check that addr is correct (= gateway) */\n+    }else if(addr.sin_addr.s_addr != p->gateway) {\n+        n = NATPMP_ERR_WRONGPACKETSOURCE;\n+    }else {\n+        response->resultcode = ntohs(*((int16_t *)(buf + 2)));\n+        response->epoch = ntohl(*((int64_t *)(buf + 4)));\n+        if(buf[0] != 0)\n+            n = NATPMP_ERR_UNSUPPORTEDVERSION;\n+        else if(buf[1] < 128 || buf[1] > 130)\n+            n = NATPMP_ERR_UNSUPPORTEDOPCODE;\n+        else if(response->resultcode != 0) {\n+            switch(response->resultcode) {\n+            case 1:\n+                n = NATPMP_ERR_UNSUPPORTEDVERSION;\n+                break;\n+            case 2:\n+                n = NATPMP_ERR_NOTAUTHORIZED;\n+                break;\n+            case 3:\n+                n = NATPMP_ERR_NETWORKFAILURE;\n+                break;\n+            case 4:\n+                n = NATPMP_ERR_OUTOFRESOURCES;\n+                break;\n+            case 5:\n+                n = NATPMP_ERR_UNSUPPORTEDOPCODE;\n+                break;\n+            default:\n+                n = NATPMP_ERR_UNDEFINEDERROR;\n+            }\n+        } else {\n+            response->type = buf[1] & 0x7f;\n+            if(buf[1] == 128) {\n+                response->pnu.publicaddress.addr.s_addr = *((int64_t *)(buf + 8));\n+            }else {\n+                response->pnu.newportmapping.privateport = ntohs(*((int16_t *)(buf + 8)));\n+                response->pnu.newportmapping.mappedpublicport = ntohs(*((int16_t *)(buf + 10)));\n+                response->pnu.newportmapping.lifetime = ntohl(*((int64_t *)(buf + 12)));\n+            }\n+            n = 0;\n+        }\n+    }\n+    return n;\n+}\n+\n+int ReadNatPmpResponseOrRetry(natpmp_t * p, natpmpresp_t * response)\n+{\n+    if(!p || !response)\n+        return NATPMP_ERR_INVALIDARGS;\n+    if(!p->has_pending_request)\n+        return NATPMP_ERR_NOPENDINGREQ;\n+    int n = ReadNatPmpResponse(p, response);\n+    if(n<0) {\n+        if(n==NATPMP_TRYAGAIN) {\n+            struct timeval now;\n+            gettimeofday(&now, nullptr);\n+            if(timercmp(&now, &p->retry_time, >=)) {\n+                int delay, r;\n+                if(p->try_number >= 9) {\n+                    return NATPMP_ERR_NOGATEWAYSUPPORT;\n+                }\n+                delay = 250 * (1<<p->try_number);\n+                p->retry_time.tv_sec += (delay / 1000);\n+                p->retry_time.tv_usec += (delay % 1000) * 1000;\n+                if(p->retry_time.tv_usec >= 1000000) {\n+                    p->retry_time.tv_usec -= 1000000;\n+                    p->retry_time.tv_sec++;\n+                }\n+                p->try_number++;\n+                r = sendpendingrequest(p);\n+                if(r<0)\n+                    return r;\n+            }\n+        }\n+    } else {\n+        p->has_pending_request = 0;\n+    }\n+    return n;\n+}\n+\n+const char * StrNatPmpErr(int r)\n+{\n+    const char *s = nullptr;\n+    switch(r) {\n+    case 0:\n+        s = \"No Error\";\n+        break;\n+    case NATPMP_ERR_INVALIDARGS:\n+        s = \"Invalid arguments\";\n+        break;\n+    case NATPMP_ERR_SOCKETERROR:\n+        s = \"Socket() failed\";\n+        break;\n+    case NATPMP_ERR_CANNOTGETGATEWAY:\n+        s = \"Cannot get default gateway IP address\";\n+        break;\n+    case NATPMP_ERR_CLOSEERR:\n+#ifdef WIN32\n+        s = \"closesocket() failed\";\n+#else\n+        s = \"close() failed\";\n+#endif\n+        break;\n+    case NATPMP_ERR_RECVFROM:\n+        s = \"recvfrom() failed\";\n+        break;\n+    case NATPMP_ERR_NOPENDINGREQ:\n+        s = \"No pending request\";\n+        break;\n+    case NATPMP_ERR_NOGATEWAYSUPPORT:\n+        s = \"The gateway does not support NAT-PMP\";\n+        break;\n+    case NATPMP_ERR_CONNECTERR:\n+        s = \"connect() failed\";\n+        break;\n+    case NATPMP_ERR_WRONGPACKETSOURCE:\n+        s = \"Packet not received from the default gateway\";\n+        break;\n+    case NATPMP_ERR_SENDERR:\n+        s = \"send() failed\";\n+        break;\n+    case NATPMP_ERR_FCNTLERROR:\n+        s = \"fcntl() failed\";\n+        break;\n+    case NATPMP_ERR_GETTIMEOFDAYERR:\n+        s = \"gettimeofday() failed\";\n+        break;\n+    case NATPMP_ERR_UNSUPPORTEDVERSION:\n+        s = \"Unsupported NAT-PMP version error from server\";\n+        break;\n+    case NATPMP_ERR_UNSUPPORTEDOPCODE:\n+        s = \"Unsupported NAT-PMP opcode error from server\";\n+        break;\n+    case NATPMP_ERR_UNDEFINEDERROR:\n+        s = \"Undefined NAT-PMP server error\";\n+        break;\n+    case NATPMP_ERR_NOTAUTHORIZED:\n+        s = \"Not authorized\";\n+        break;\n+    case NATPMP_ERR_NETWORKFAILURE:\n+        s = \"Network failure\";\n+        break;\n+    case NATPMP_ERR_OUTOFRESOURCES:\n+        s = \"NAT-PMP server out of resources\";\n+        break;\n+    default:\n+        s = \"Unknown error\";\n+    }\n+    return s;\n+}"
      }
    ]
  },
  {
    "sha": "ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjZTFlZjhhOWZkNzdiNmU3MTZiZjU4ZjU2Y2IzYWQwYmNkNWZlZTI2",
    "commit": {
      "author": {
        "name": "shivendra_mishra@live.com",
        "email": "shivendra_mishra@live.com",
        "date": "2019-04-12T15:29:00Z"
      },
      "committer": {
        "name": "shivendra_mishra@live.com",
        "email": "shivendra_mishra@live.com",
        "date": "2019-04-19T15:19:49Z"
      },
      "message": "Issue #11902\n* Changes to support NAT-PMP based on libnatpmp\n* Introduces wrapper over libnatpmp for easier integration\n* Changes to disable upnp by default and use NAT-PMP\n  as explained in #11902 (Introducing -portmap switch)\n* Integration of above in build system",
      "tree": {
        "sha": "ab6bbba34fc2debbec9c2ab8861ab30692b71dbe",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ab6bbba34fc2debbec9c2ab8861ab30692b71dbe"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26/comments",
    "author": {
      "login": "MishraShivendra",
      "id": 8533116,
      "node_id": "MDQ6VXNlcjg1MzMxMTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8533116?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MishraShivendra",
      "html_url": "https://github.com/MishraShivendra",
      "followers_url": "https://api.github.com/users/MishraShivendra/followers",
      "following_url": "https://api.github.com/users/MishraShivendra/following{/other_user}",
      "gists_url": "https://api.github.com/users/MishraShivendra/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MishraShivendra/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MishraShivendra/subscriptions",
      "organizations_url": "https://api.github.com/users/MishraShivendra/orgs",
      "repos_url": "https://api.github.com/users/MishraShivendra/repos",
      "events_url": "https://api.github.com/users/MishraShivendra/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MishraShivendra/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MishraShivendra",
      "id": 8533116,
      "node_id": "MDQ6VXNlcjg1MzMxMTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8533116?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MishraShivendra",
      "html_url": "https://github.com/MishraShivendra",
      "followers_url": "https://api.github.com/users/MishraShivendra/followers",
      "following_url": "https://api.github.com/users/MishraShivendra/following{/other_user}",
      "gists_url": "https://api.github.com/users/MishraShivendra/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MishraShivendra/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MishraShivendra/subscriptions",
      "organizations_url": "https://api.github.com/users/MishraShivendra/orgs",
      "repos_url": "https://api.github.com/users/MishraShivendra/repos",
      "events_url": "https://api.github.com/users/MishraShivendra/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MishraShivendra/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5293339e4dddc84ca5a219e9b8ca4130b00ef1d8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5293339e4dddc84ca5a219e9b8ca4130b00ef1d8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5293339e4dddc84ca5a219e9b8ca4130b00ef1d8"
      }
    ],
    "stats": {
      "total": 935,
      "additions": 607,
      "deletions": 328
    },
    "files": [
      {
        "sha": "201eabfe15a1d2552ad877263b5be0a4c9d979db",
        "filename": "build_msvc/common.vcxproj",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26/build_msvc/common.vcxproj",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26/build_msvc/common.vcxproj",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/common.vcxproj?ref=ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26",
        "patch": "@@ -24,7 +24,7 @@\n       <DisableSpecificWarnings>4018;4244;4267;4715;4805;</DisableSpecificWarnings>\n       <TreatWarningAsError>true</TreatWarningAsError>\n       <PreprocessorDefinitions>_WIN32_WINNT=0x0601;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n-      <AdditionalIncludeDirectories>..\\..\\src;..\\..\\src\\univalue\\include;..\\..\\src\\secp256k1\\include;..\\..\\src\\leveldb\\include;..\\..\\src\\leveldb\\helpers\\memenv;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n+      <AdditionalIncludeDirectories>..\\..\\src;..\\..\\src\\univalue\\include;..\\..\\src\\natpmp\\include;..\\..\\src\\secp256k1\\include;..\\..\\src\\leveldb\\include;..\\..\\src\\leveldb\\helpers\\memenv;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n     </ClCompile>\n   </ItemDefinitionGroup>\n </Project>"
      },
      {
        "sha": "9413b69e4840f494d0f834f27628cfb7d4f6ee64",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26",
        "patch": "@@ -113,7 +113,7 @@ AC_ARG_WITH([miniupnpc],\n   [AS_HELP_STRING([--with-miniupnpc],\n   [enable UPNP (default is yes if libminiupnpc is found)])],\n   [use_upnp=$withval],\n-  [use_upnp=auto])\n+  [use_upnp=no])\n \n AC_ARG_ENABLE([upnp-default],\n   [AS_HELP_STRING([--enable-upnp-default],"
      },
      {
        "sha": "1a2bc6a3dba1439185520512dd3601b3b49af8bb",
        "filename": "contrib/debian/copyright",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26/contrib/debian/copyright",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26/contrib/debian/copyright",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/copyright?ref=ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26",
        "patch": "@@ -156,7 +156,7 @@ Comment:\n License: public-domain\n  This work is in the public domain.\n \n-Files: src/natpmp/gateway.cpp \n+Files: src/natpmp/gateway.cpp\n        src/natpmp/include/gateway.h\n        src/natpmp/natpmp.cpp\n        src/natpmp/include/natpmp.h"
      },
      {
        "sha": "b3649a1fb81c8c45d1f3f59a057b04d385f4d88f",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 8,
        "deletions": 1,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26",
        "patch": "@@ -22,6 +22,7 @@ endif\n BITCOIN_INCLUDES=-I$(builddir) $(BDB_CPPFLAGS) $(BOOST_CPPFLAGS) $(LEVELDB_CPPFLAGS) $(CRYPTO_CFLAGS) $(SSL_CFLAGS)\n \n BITCOIN_INCLUDES += -I$(srcdir)/secp256k1/include\n+BITCOIN_INCLUDES += -I$(srcdir)/natpmp/include\n BITCOIN_INCLUDES += $(UNIVALUE_CFLAGS)\n \n LIBBITCOIN_SERVER=libbitcoin_server.a\n@@ -149,6 +150,9 @@ BITCOIN_CORE_H = \\\n   memusage.h \\\n   merkleblock.h \\\n   miner.h \\\n+  natpmp/include/gateway.h \\\n+  natpmp/include/natpmp.h \\\n+  natpmp/include/natmap_wrapper.h \\\n   net.h \\\n   net_processing.h \\\n   netaddress.h \\\n@@ -261,6 +265,9 @@ libbitcoin_server_a_SOURCES = \\\n   dbwrapper.cpp \\\n   merkleblock.cpp \\\n   miner.cpp \\\n+  natpmp/gateway.cpp \\\n+  natpmp/natpmp.cpp \\\n+  natpmp/natmap_wrapper.cpp \\\n   net.cpp \\\n   net_processing.cpp \\\n   node/coin.cpp \\\n@@ -595,7 +602,7 @@ endif\n \n libbitcoinconsensus_la_LDFLAGS = $(AM_LDFLAGS) -no-undefined $(RELDFLAGS)\n libbitcoinconsensus_la_LIBADD = $(LIBSECP256K1)\n-libbitcoinconsensus_la_CPPFLAGS = $(AM_CPPFLAGS) -I$(builddir)/obj -I$(srcdir)/secp256k1/include -DBUILD_BITCOIN_INTERNAL\n+libbitcoinconsensus_la_CPPFLAGS = $(AM_CPPFLAGS) -I$(builddir)/obj -I$(srcdir)/secp256k1/include -I$(srcdir)/natpmp/include -DBUILD_BITCOIN_INTERNAL\n libbitcoinconsensus_la_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n \n endif"
      },
      {
        "sha": "e6cfeb264a831b495a53937ab06ef14133d75459",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 9,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26",
        "patch": "@@ -437,16 +437,17 @@ void SetupServerArgs()\n     gArgs.AddArg(\"-torpassword=<pass>\", \"Tor control port password (default: empty)\", false, OptionsCategory::CONNECTION);\n #ifdef USE_UPNP\n #if USE_UPNP\n-    gArgs.AddArg(\"-upnp\", \"Use UPnP to map the listening port (default: 1 when listening and no -proxy)\", false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-portmap\", \"Use UPnP to map the listening port (default: 1 when listening and no -proxy)\", false, OptionsCategory::CONNECTION);\n #else\n-    gArgs.AddArg(\"-upnp\", strprintf(\"Use UPnP to map the listening port (default: %u)\", 0), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-portmap\", strprintf(\"Use NAT-PMP to map the listening port (default: %u)\", 0), false, OptionsCategory::CONNECTION);\n #endif\n #else\n-    hidden_args.emplace_back(\"-upnp\");\n+    hidden_args.emplace_back(\"-portmap\");\n #endif\n     gArgs.AddArg(\"-whitebind=<addr>\", \"Bind to given address and whitelist peers connecting to it. Use [host]:port notation for IPv6\", false, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-whitelist=<IP address or network>\", \"Whitelist peers connecting from the given IP address (e.g. 1.2.3.4) or CIDR notated network (e.g. 1.2.3.0/24). Can be specified multiple times.\"\n-        \" Whitelisted peers cannot be DoS banned and their transactions are always relayed, even if they are already in the mempool, useful e.g. for a gateway\", false, OptionsCategory::CONNECTION);\n+                                                       \" Whitelisted peers cannot be DoS banned and their transactions are always relayed, even if they are already in the mempool, useful e.g. for a gateway\",\n+        false, OptionsCategory::CONNECTION);\n \n     g_wallet_init_interface.AddWalletOptions();\n \n@@ -794,17 +795,17 @@ void InitParameterInteraction()\n             LogPrintf(\"%s: parameter interaction: -proxy set -> setting -listen=0\\n\", __func__);\n         // to protect privacy, do not use UPNP when a proxy is set. The user may still specify -listen=1\n         // to listen locally, so don't rely on this happening through -listen below.\n-        if (gArgs.SoftSetBoolArg(\"-upnp\", false))\n-            LogPrintf(\"%s: parameter interaction: -proxy set -> setting -upnp=0\\n\", __func__);\n+        if (gArgs.SoftSetBoolArg(\"-portmap\", false))\n+            LogPrintf(\"%s: parameter interaction: -proxy set -> setting -portmap=0\\n\", __func__);\n         // to protect privacy, do not discover addresses by default\n         if (gArgs.SoftSetBoolArg(\"-discover\", false))\n             LogPrintf(\"%s: parameter interaction: -proxy set -> setting -discover=0\\n\", __func__);\n     }\n \n     if (!gArgs.GetBoolArg(\"-listen\", DEFAULT_LISTEN)) {\n         // do not map ports or try to retrieve public IP when not listening (pointless)\n-        if (gArgs.SoftSetBoolArg(\"-upnp\", false))\n-            LogPrintf(\"%s: parameter interaction: -listen=0 -> setting -upnp=0\\n\", __func__);\n+        if (gArgs.SoftSetBoolArg(\"-portmap\", false))\n+            LogPrintf(\"%s: parameter interaction: -listen=0 -> setting -portmap=0\\n\", __func__);\n         if (gArgs.SoftSetBoolArg(\"-discover\", false))\n             LogPrintf(\"%s: parameter interaction: -listen=0 -> setting -discover=0\\n\", __func__);\n         if (gArgs.SoftSetBoolArg(\"-listenonion\", false))\n@@ -1737,7 +1738,7 @@ bool AppInitMain(InitInterfaces& interfaces)\n     Discover();\n \n     // Map ports with UPnP\n-    if (gArgs.GetBoolArg(\"-upnp\", DEFAULT_UPNP)) {\n+    if (gArgs.GetBoolArg(\"-portmap\", DEFAULT_UPNP)) {\n         StartMapPort();\n     }\n "
      },
      {
        "sha": "ff794174cb465f8ec23fea9c050b90389a464534",
        "filename": "src/natpmp/gateway.cpp",
        "status": "modified",
        "additions": 189,
        "deletions": 195,
        "changes": 384,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26/src/natpmp/gateway.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26/src/natpmp/gateway.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/natpmp/gateway.cpp?ref=ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26",
        "patch": "@@ -90,7 +90,7 @@\n #include <gateway.h>\n #ifndef WIN32\n #define SUCCESS (0)\n-#define FAILED  (-1)\n+#define FAILED (-1)\n #endif\n #ifdef USE_PROC_NET_ROUTE\n #include <sstream>\n@@ -120,97 +120,94 @@ eth0    00000000        00000000        0001    0       0       1000    00000000\n  One header line, and then one line by route by route table entry.\n */\n \n-int TestIfWhiteSpace(char character)\n+int TestIfWhiteSpace(char c)\n {\n-    std::list<char> whiteSpaces = {'\\f', '\\n', '\\r', '\\t', '\\v'};\n-    return std::count(whiteSpaces.begin(), whiteSpaces.end(), character);\n+    return c == ' ' || c == '\\f' || c == '\\n' || c == '\\r' || c == '\\t' || c == '\\v';\n }\n \n-int GetDefaultGateway(in_addr_t * addr)\n+int GetDefaultGateway(in_addr_t* addr)\n {\n-        int64_t d = 0;\n-        int64_t g = 0;\n-        char buf[256] = {0};\n-        int line = 0;\n-        char * p = nullptr;\n-        FILE* f = fopen(\"/proc/net/route\", \"r\");\n-        if(!f)\n-                return FAILED;\n-        while(fgets(buf, sizeof(buf), f)) {\n-                if(line > 0) {  /* skip the first line */\n-                        p = buf;\n-                        /* skip the interface name */\n-                        while(*p && !TestIfWhiteSpace(*p))\n-                                p++;\n-                        while(*p && TestIfWhiteSpace(*p))\n-                                p++;\n+    int64_t d = 0;\n+    int64_t g = 0;\n+    char buf[256] = {0};\n+    int line = 0;\n+    char* p = nullptr;\n+    FILE* f = fopen(\"/proc/net/route\", \"r\");\n+    if (!f)\n+        return FAILED;\n+    while (fgets(buf, sizeof(buf), f)) {\n+        if (line > 0) { /* skip the first line */\n+            p = buf;\n+            /* skip the interface name */\n+            while (*p && !TestIfWhiteSpace(*p))\n+                p++;\n+            while (*p && TestIfWhiteSpace(*p))\n+                p++;\n             // Want just the gateway column\n-                        std::string data(p);\n-            data = data.substr(data.find('\\t')+1);\n+            std::string data(p);\n+            data = data.substr(data.find('\\t') + 1);\n             data = data.substr(0, data.find('\\t'));\n \n-                        std::stringstream dataParser;\n-            dataParser<<std::hex<<data;\n-                        dataParser >> g >> d;\n-            if(d == 0 && g != 0) {\n-                                *addr = (in_addr_t)g;\n-                                fclose(f);\n-                                return SUCCESS;\n-                        }\n-                }\n-                line++;\n-        }\n-        /* default route not found ! */\n-        if(f)\n+            std::stringstream dataParser;\n+            dataParser << std::hex << data;\n+            dataParser >> g >> d;\n+            if (d == 0 && g != 0) {\n+                *addr = (in_addr_t)g;\n                 fclose(f);\n-        return FAILED;\n+                return SUCCESS;\n+            }\n+        }\n+        line++;\n+    }\n+    /* default route not found ! */\n+    if (f)\n+        fclose(f);\n+    return FAILED;\n }\n #endif /* #ifdef USE_PROC_NET_ROUTE */\n \n \n #ifdef USE_SYSCTL_NET_ROUTE\n \n #define ROUNDUP(a) \\\n-    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))\n+    ((a) > 0 ? (1 + (((a)-1) | (sizeof(long) - 1))) : sizeof(long))\n \n-int GetDefaultGateway(in_addr_t * addr)\n+int GetDefaultGateway(in_addr_t* addr)\n {\n     /* net.route.0.inet.flags.gateway */\n     int mib[] = {CTL_NET, PF_ROUTE, 0, AF_INET,\n-                 NET_RT_FLAGS, RTF_GATEWAY};\n+        NET_RT_FLAGS, RTF_GATEWAY};\n     size_t l = 0;\n     char* buf = nullptr;\n     char* p = nullptr;\n-    struct rt_msghdr * rt = {0};\n-    struct sockaddr * sa = {0};\n-    struct sockaddr * sa_tab[RTAX_MAX];\n+    struct rt_msghdr* rt = {0};\n+    struct sockaddr* sa = {0};\n+    struct sockaddr* sa_tab[RTAX_MAX];\n     int i = 0;\n     int r = FAILED;\n-    if(sysctl(mib, sizeof(mib)/sizeof(int), 0, &l, 0, 0) < 0) {\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n         return FAILED;\n     }\n-    if(l>0) {\n+    if (l > 0) {\n         buf = (char*)malloc(l);\n-        if(sysctl(mib, sizeof(mib)/sizeof(int), buf, &l, 0, 0) < 0) {\n+        if (sysctl(mib, sizeof(mib) / sizeof(int), buf, &l, 0, 0) < 0) {\n             free(buf);\n             return FAILED;\n         }\n-        for(p=buf; p<buf+l; p+=rt->rtm_msglen) {\n-            rt = (struct rt_msghdr *)p;\n-            sa = (struct sockaddr *)(rt + 1);\n-            for(i=0; i<RTAX_MAX; i++) {\n-                if(rt->rtm_addrs & (1 << i)) {\n+        for (p = buf; p < buf + l; p += rt->rtm_msglen) {\n+            rt = (struct rt_msghdr*)p;\n+            sa = (struct sockaddr*)(rt + 1);\n+            for (i = 0; i < RTAX_MAX; i++) {\n+                if (rt->rtm_addrs & (1 << i)) {\n                     sa_tab[i] = sa;\n-                    sa = (struct sockaddr *)((char *)sa + ROUNDUP(sa->sa_len));\n+                    sa = (struct sockaddr*)((char*)sa + ROUNDUP(sa->sa_len));\n                 } else {\n                     sa_tab[i] = nullptr;\n                 }\n             }\n-            if( ((rt->rtm_addrs & (RTA_DST|RTA_GATEWAY)) == (RTA_DST|RTA_GATEWAY))\n-              && sa_tab[RTAX_DST]->sa_family == AF_INET\n-              && sa_tab[RTAX_GATEWAY]->sa_family == AF_INET) {\n-                if(((struct sockaddr_in *)sa_tab[RTAX_DST])->sin_addr.s_addr == 0) {\n-                    *addr = ((struct sockaddr_in *)(sa_tab[RTAX_GATEWAY]))->sin_addr.s_addr;\n+            if (((rt->rtm_addrs & (RTA_DST | RTA_GATEWAY)) == (RTA_DST | RTA_GATEWAY)) && sa_tab[RTAX_DST]->sa_family == AF_INET && sa_tab[RTAX_GATEWAY]->sa_family == AF_INET) {\n+                if (((struct sockaddr_in*)sa_tab[RTAX_DST])->sin_addr.s_addr == 0) {\n+                    *addr = ((struct sockaddr_in*)(sa_tab[RTAX_GATEWAY]))->sin_addr.s_addr;\n                     r = SUCCESS;\n                 }\n             }\n@@ -224,90 +221,92 @@ int GetDefaultGateway(in_addr_t * addr)\n \n #ifdef USE_SOCKET_ROUTE\n /* Thanks to Darren Kenny for this code */\n-#define NEXTADDR(w, u) \\\n-        if (rtm_addrs & (w)) {\\\n-            l = sizeof(struct sockaddr); memmove(cp, &(u), l); cp += l;\\\n-        }\n+#define NEXTADDR(w, u)               \\\n+    if (rtm_addrs & (w)) {           \\\n+        l = sizeof(struct sockaddr); \\\n+        memmove(cp, &(u), l);        \\\n+        cp += l;                     \\\n+    }\n \n #define rtm m_rtmsg.m_rtm\n \n struct {\n-  struct rt_msghdr m_rtm;\n-  char       m_space[512];\n+    struct rt_msghdr m_rtm;\n+    char m_space[512];\n } m_rtmsg;\n \n-int GetDefaultGateway(in_addr_t *addr)\n+int GetDefaultGateway(in_addr_t* addr)\n {\n-  int s = 0, seq = 0, l = 0, rtm_addrs = 0, i = 0;\n-  pid_t pid = {0};\n-  struct sockaddr so_dst = {0}, so_mask = {0};\n-  char *cp = m_rtmsg.m_space;\n-  struct sockaddr *gate = nullptr, *sa = nullptr;\n-  struct rt_msghdr *msg_hdr = nullptr;\n-\n-  pid = getpid();\n-  seq = 0;\n-  rtm_addrs = RTA_DST | RTA_NETMASK;\n-\n-  memset(&so_dst, 0, sizeof(so_dst));\n-  memset(&so_mask, 0, sizeof(so_mask));\n-  memset(&rtm, 0, sizeof(struct rt_msghdr));\n-\n-  rtm.rtm_type = RTM_GET;\n-  rtm.rtm_flags = RTF_UP | RTF_GATEWAY;\n-  rtm.rtm_version = RTM_VERSION;\n-  rtm.rtm_seq = ++seq;\n-  rtm.rtm_addrs = rtm_addrs;\n-\n-  so_dst.sa_family = AF_INET;\n-  so_mask.sa_family = AF_INET;\n-\n-  NEXTADDR(RTA_DST, so_dst);\n-  NEXTADDR(RTA_NETMASK, so_mask);\n-\n-  rtm.rtm_msglen = l = cp - (char *)&m_rtmsg;\n-\n-  s = socket(PF_ROUTE, SOCK_RAW, 0);\n-\n-  if (write(s, (char *)&m_rtmsg, l) < 0) {\n-      close(s);\n-      return FAILED;\n-  }\n-\n-  do {\n-    l = read(s, (char *)&m_rtmsg, sizeof(m_rtmsg));\n-  } while (l > 0 && (rtm.rtm_seq != seq || rtm.rtm_pid != pid));\n-\n-  close(s);\n-\n-  msg_hdr = &rtm;\n-\n-  cp = ((char *)(msg_hdr + 1));\n-  if (msg_hdr->rtm_addrs) {\n-    for (i = 1; i; i <<= 1)\n-      if (i & msg_hdr->rtm_addrs) {\n-        sa = (struct sockaddr *)cp;\n-        if (i == RTA_GATEWAY )\n-          gate = sa;\n-\n-        cp += sizeof(struct sockaddr);\n-      }\n-  } else {\n-      return FAILED;\n-  }\n-\n-\n-  if (gate != nullptr ) {\n-      *addr = ((struct sockaddr_in *)gate)->sin_addr.s_addr;\n-      return SUCCESS;\n-  } else {\n-      return FAILED;\n-  }\n+    int s = 0, seq = 0, l = 0, rtm_addrs = 0, i = 0;\n+    pid_t pid = {0};\n+    struct sockaddr so_dst = {0}, so_mask = {0};\n+    char* cp = m_rtmsg.m_space;\n+    struct sockaddr *gate = nullptr, *sa = nullptr;\n+    struct rt_msghdr* msg_hdr = nullptr;\n+\n+    pid = getpid();\n+    seq = 0;\n+    rtm_addrs = RTA_DST | RTA_NETMASK;\n+\n+    memset(&so_dst, 0, sizeof(so_dst));\n+    memset(&so_mask, 0, sizeof(so_mask));\n+    memset(&rtm, 0, sizeof(struct rt_msghdr));\n+\n+    rtm.rtm_type = RTM_GET;\n+    rtm.rtm_flags = RTF_UP | RTF_GATEWAY;\n+    rtm.rtm_version = RTM_VERSION;\n+    rtm.rtm_seq = ++seq;\n+    rtm.rtm_addrs = rtm_addrs;\n+\n+    so_dst.sa_family = AF_INET;\n+    so_mask.sa_family = AF_INET;\n+\n+    NEXTADDR(RTA_DST, so_dst);\n+    NEXTADDR(RTA_NETMASK, so_mask);\n+\n+    rtm.rtm_msglen = l = cp - (char*)&m_rtmsg;\n+\n+    s = socket(PF_ROUTE, SOCK_RAW, 0);\n+\n+    if (write(s, (char*)&m_rtmsg, l) < 0) {\n+        close(s);\n+        return FAILED;\n+    }\n+\n+    do {\n+        l = read(s, (char*)&m_rtmsg, sizeof(m_rtmsg));\n+    } while (l > 0 && (rtm.rtm_seq != seq || rtm.rtm_pid != pid));\n+\n+    close(s);\n+\n+    msg_hdr = &rtm;\n+\n+    cp = ((char*)(msg_hdr + 1));\n+    if (msg_hdr->rtm_addrs) {\n+        for (i = 1; i; i <<= 1)\n+            if (i & msg_hdr->rtm_addrs) {\n+                sa = (struct sockaddr*)cp;\n+                if (i == RTA_GATEWAY)\n+                    gate = sa;\n+\n+                cp += sizeof(struct sockaddr);\n+            }\n+    } else {\n+        return FAILED;\n+    }\n+\n+\n+    if (gate != nullptr) {\n+        *addr = ((struct sockaddr_in*)gate)->sin_addr.s_addr;\n+        return SUCCESS;\n+    } else {\n+        return FAILED;\n+    }\n }\n #endif /* #ifdef USE_SOCKET_ROUTE */\n \n #ifdef USE_WIN32_CODE\n-LIBSPEC int GetDefaultGateway(in_addr_t * addr)\n+LIBSPEC int GetDefaultGateway(in_addr_t* addr)\n {\n     HKEY networkCardsKey;\n     HKEY networkCardKey;\n@@ -328,15 +327,15 @@ LIBSPEC int GetDefaultGateway(in_addr_t * addr)\n #ifdef UNICODE\n     LPCTSTR networkCardsPath = L\"SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\NetworkCards\";\n     LPCTSTR interfacesPath = L\"SYSTEM\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters\\\\Interfaces\";\n-#define STR_SERVICENAME     L\"ServiceName\"\n+#define STR_SERVICENAME L\"ServiceName\"\n #define STR_DHCPDEFAULTGATEWAY L\"DhcpDefaultGateway\"\n-#define STR_DEFAULTGATEWAY    L\"DefaultGateway\"\n+#define STR_DEFAULTGATEWAY L\"DefaultGateway\"\n #else\n     LPCTSTR networkCardsPath = \"SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\NetworkCards\";\n     LPCTSTR interfacesPath = \"SYSTEM\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters\\\\Interfaces\";\n-#define STR_SERVICENAME     \"ServiceName\"\n+#define STR_SERVICENAME \"ServiceName\"\n #define STR_DHCPDEFAULTGATEWAY \"DhcpDefaultGateway\"\n-#define STR_DEFAULTGATEWAY    \"DefaultGateway\"\n+#define STR_DEFAULTGATEWAY \"DefaultGateway\"\n #endif\n     // The windows registry lists its primary network devices in the following location:\n     // HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\NetworkCards\n@@ -364,7 +363,7 @@ LIBSPEC int GetDefaultGateway(in_addr_t * addr)\n     //     -[more]\n     //   -{86226414-5545-4335-A9D1-5BD7120119AD}\n     //     -DhcpIpAddress = 10.0.1.5\n-    //     -DhcpDefaultGateay = 10.0.1.1\n+    //     -DhcpDefaultGateway = 10.0.1.1\n     //     -[more]\n     //\n     // In order to extract this information, we enumerate each network card, and extract the ServiceName value.\n@@ -374,79 +373,75 @@ LIBSPEC int GetDefaultGateway(in_addr_t * addr)\n     // It may be possible to simply enumerate the interface folders until we find one with a DhcpDefaultGateway value.\n     // However, the technique used is the technique most cited on the web, and we assume it to be more correct.\n \n-    if(ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, // Open registry key or predefined key\n-                                     networkCardsPath,   // Name of registry subkey to open\n-                                     0,                  // Reserved - must be zero\n-                                     KEY_READ,           // Mask - desired access rights\n-                                     &networkCardsKey))  // Pointer to output key\n+    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, // Open registry key or predefined key\n+                             networkCardsPath,            // Name of registry subkey to open\n+                             0,                           // Reserved - must be zero\n+                             KEY_READ,                    // Mask - desired access rights\n+                             &networkCardsKey))           // Pointer to output key\n     {\n         // Unable to open network cards keys\n         return -1;\n     }\n \n-    if(ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, // Open registry key or predefined key\n-                                     interfacesPath,     // Name of registry subkey to open\n-                                     0,                  // Reserved - must be zero\n-                                     KEY_READ,           // Mask - desired access rights\n-                                     &interfacesKey))    // Pointer to output key\n+    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, // Open registry key or predefined key\n+                             interfacesPath,              // Name of registry subkey to open\n+                             0,                           // Reserved - must be zero\n+                             KEY_READ,                    // Mask - desired access rights\n+                             &interfacesKey))             // Pointer to output key\n     {\n         // Unable to open interfaces key\n         RegCloseKey(networkCardsKey);\n         return -1;\n     }\n \n     // Figure out how many subfolders are within the Network Cards folder\n-    RegQueryInfoKey(networkCardsKey, nullptr, nullptr, nullptr, &numSubKeys, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr);\n+    RegQueryInfoKey(networkCardsKey, nullptr, nullptr, nullptr, &numSubKeys,\n+        nullptr, nullptr, nullptr, nullptr, nullptr, nullptr,\n+        nullptr);\n \n     // Enumerate through each subfolder within the Network Cards folder\n-    for(i = 0; i < numSubKeys && !done; i++)\n-    {\n+    for (i = 0; i < numSubKeys && !done; i++) {\n         keyNameLength = MAX_KEY_LENGTH;\n-        if(ERROR_SUCCESS == RegEnumKeyEx(networkCardsKey, // Open registry key\n-                                         i,               // Index of sub key to retrieve\n-                                         keyName,         // Buffer that receives the name of the sub key\n-                                         &keyNameLength,  // Variable that receives the size of the above buffer\n-                                         nullptr,            // Reserved - must be nullptr\n-                                         nullptr,            // Buffer that receives the class string\n-                                         nullptr,            // Variable that receives the size of the above buffer\n-                                         nullptr))           // Variable that receives the last write time of sub key\n+        if (ERROR_SUCCESS == RegEnumKeyEx(networkCardsKey, // Open registry key\n+                                 i,                        // Index of sub key to retrieve\n+                                 keyName,                  // Buffer that receives the name of the sub key\n+                                 &keyNameLength,           // Variable that receives the size of the above buffer\n+                                 nullptr,                  // Reserved - must be nullptr\n+                                 nullptr,                  // Buffer that receives the class string\n+                                 nullptr,                  // Variable that receives the size of the above buffer\n+                                 nullptr))                 // Variable that receives the last write time of sub key\n         {\n-            if(RegOpenKeyEx(networkCardsKey,  keyName, 0, KEY_READ, &networkCardKey) == ERROR_SUCCESS)\n-            {\n+            if (RegOpenKeyEx(networkCardsKey, keyName, 0, KEY_READ, &networkCardKey) == ERROR_SUCCESS) {\n                 keyValueLength = MAX_VALUE_LENGTH;\n-                if(ERROR_SUCCESS == RegQueryValueEx(networkCardKey,   // Open registry key\n-                                                    STR_SERVICENAME,    // Name of key to query\n-                                                    nullptr,             // Reserved - must be nullptr\n-                                                    &keyValueType,    // Receives value type\n-                                                    (LPBYTE)keyValue, // Receives value\n-                                                    &keyValueLength)) // Receives value length in bytes\n+                if (ERROR_SUCCESS == RegQueryValueEx(networkCardKey, // Open registry key\n+                                         STR_SERVICENAME,            // Name of key to query\n+                                         nullptr,                    // Reserved - must be nullptr\n+                                         &keyValueType,              // Receives value type\n+                                         (LPBYTE)keyValue,           // Receives value\n+                                         &keyValueLength))           // Receives value length in bytes\n                 {\n-                    if(RegOpenKeyEx(interfacesKey, keyValue, 0, KEY_READ, &interfaceKey) == ERROR_SUCCESS)\n-                    {\n+                    if (RegOpenKeyEx(interfacesKey, keyValue, 0, KEY_READ, &interfaceKey) == ERROR_SUCCESS) {\n                         gatewayValueLength = MAX_VALUE_LENGTH;\n-                        if(ERROR_SUCCESS == RegQueryValueEx(interfaceKey,         // Open registry key\n-                                                            STR_DHCPDEFAULTGATEWAY, // Name of key to query\n-                                                            nullptr,                 // Reserved - must be nullptr\n-                                                            &gatewayValueType,    // Receives value type\n-                                                            (LPBYTE)gatewayValue, // Receives value\n-                                                            &gatewayValueLength)) // Receives value length in bytes\n+                        if (ERROR_SUCCESS == RegQueryValueEx(interfaceKey, // Open registry key\n+                                                 STR_DHCPDEFAULTGATEWAY,   // Name of key to query\n+                                                 nullptr,                  // Reserved - must be nullptr\n+                                                 &gatewayValueType,        // Receives value type\n+                                                 (LPBYTE)gatewayValue,     // Receives value\n+                                                 &gatewayValueLength))     // Receives value length in bytes\n                         {\n                             // Check to make sure it's a string\n-                            if((gatewayValueType == REG_MULTI_SZ || gatewayValueType == REG_SZ) && (gatewayValueLength > 1))\n-                            {\n+                            if ((gatewayValueType == REG_MULTI_SZ || gatewayValueType == REG_SZ) && (gatewayValueLength > 1)) {\n                                 done = 1;\n                             }\n-                        }\n-                        else if(ERROR_SUCCESS == RegQueryValueEx(interfaceKey,         // Open registry key\n-                                                            STR_DEFAULTGATEWAY, // Name of key to query\n-                                                            nullptr,                 // Reserved - must be nullptr\n-                                                            &gatewayValueType,    // Receives value type\n-                                                            (LPBYTE)gatewayValue,// Receives value\n-                                                            &gatewayValueLength)) // Receives value length in bytes\n+                        } else if (ERROR_SUCCESS == RegQueryValueEx(interfaceKey, // Open registry key\n+                                                        STR_DEFAULTGATEWAY,       // Name of key to query\n+                                                        nullptr,                  // Reserved - must be nullptr\n+                                                        &gatewayValueType,        // Receives value type\n+                                                        (LPBYTE)gatewayValue,     // Receives value\n+                                                        &gatewayValueLength))     // Receives value length in bytes\n                         {\n                             // Check to make sure it's a string\n-                            if((gatewayValueType == REG_MULTI_SZ || gatewayValueType == REG_SZ) && (gatewayValueLength > 1))\n-                            {\n+                            if ((gatewayValueType == REG_MULTI_SZ || gatewayValueType == REG_SZ) && (gatewayValueLength > 1)) {\n                                 done = 1;\n                             }\n                         }\n@@ -461,13 +456,12 @@ LIBSPEC int GetDefaultGateway(in_addr_t * addr)\n     RegCloseKey(interfacesKey);\n     RegCloseKey(networkCardsKey);\n \n-    if(done)\n-    {\n+    if (done) {\n #if UNICODE\n         char tmp[32] = {0};\n-        for(i = 0; i < 32; i++) {\n+        for (i = 0; i < 32; i++) {\n             tmp[i] = (char)gatewayValue[i];\n-            if(!tmp[i])\n+            if (!tmp[i])\n                 break;\n         }\n         tmp[31] = '\\0';\n@@ -483,24 +477,24 @@ LIBSPEC int GetDefaultGateway(in_addr_t * addr)\n #endif /* #ifdef USE_WIN32_CODE */\n \n #ifdef USE_WIN32_CODE_2\n-int GetDefaultGateway(in_addr_t *addr)\n+int GetDefaultGateway(in_addr_t* addr)\n {\n     MIB_IPFORWARDROW ip_forward;\n     memset(&ip_forward, 0, sizeof(ip_forward));\n-    if(GetBestRoute(inet_addr(\"0.0.0.0\"), 0, &ip_forward) != NO_ERROR)\n+    if (GetBestRoute(inet_addr(\"0.0.0.0\"), 0, &ip_forward) != NO_ERROR)\n         return -1;\n     *addr = ip_forward.dwForwardNextHop;\n     return 0;\n }\n #endif /* #ifdef USE_WIN32_CODE_2 */\n \n #ifdef USE_HAIKU_CODE\n-int GetDefaultGateway(in_addr_t *addr)\n+int GetDefaultGateway(in_addr_t* addr)\n {\n     int fd, ret = -1;\n     struct ifconf config = {0};\n-    void *buffer = nullptr;\n-    struct ifreq *interface = nullptr;\n+    void* buffer = nullptr;\n+    struct ifreq* interface = nullptr;\n \n     if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {\n         return -1;\n@@ -520,11 +514,11 @@ int GetDefaultGateway(in_addr_t *addr)\n         goto fail;\n     }\n     for (interface = buffer;\n-      (uint8_t *)interface < (uint8_t *)buffer + config.ifc_len; ) {\n+         (uint8_t*)interface < (uint8_t*)buffer + config.ifc_len;) {\n         struct route_entry route = interface->ifr_route;\n         int intfSize;\n         if (route.flags & (RTF_GATEWAY | RTF_DEFAULT)) {\n-            *addr = ((struct sockaddr_in *)route.gateway)->sin_addr.s_addr;\n+            *addr = ((struct sockaddr_in*)route.gateway)->sin_addr.s_addr;\n             ret = 0;\n             break;\n         }\n@@ -538,7 +532,7 @@ int GetDefaultGateway(in_addr_t *addr)\n         if (route.gateway != nullptr) {\n             intfSize += route.gateway->sa_len;\n         }\n-        interface = (struct ifreq *)((uint8_t *)interface + intfSize);\n+        interface = (struct ifreq*)((uint8_t*)interface + intfSize);\n     }\n fail:\n     free(buffer);"
      },
      {
        "sha": "6356250aeab17750f44c25f32183cb230149ffee",
        "filename": "src/natpmp/include/gateway.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26/src/natpmp/include/gateway.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26/src/natpmp/include/gateway.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/natpmp/include/gateway.h?ref=ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26",
        "patch": "@@ -14,5 +14,5 @@\n /// @param addr Address\n ///\n /// @return 0 Success, -1 Error\n-int GetDefaultGateway(in_addr_t * addr);\n+int GetDefaultGateway(in_addr_t* addr);\n #endif // BITCOIN_NATPMP_INCLUDE_GATEWAY_H"
      },
      {
        "sha": "f89013daeb973d938a655e126716a3799ce68d98",
        "filename": "src/natpmp/include/natmap_wrapper.h",
        "status": "added",
        "additions": 85,
        "deletions": 0,
        "changes": 85,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26/src/natpmp/include/natmap_wrapper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26/src/natpmp/include/natmap_wrapper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/natpmp/include/natmap_wrapper.h?ref=ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26",
        "patch": "@@ -0,0 +1,85 @@\n+#ifndef BITCOIN_NATPMP_INCLUDE_NATMAP_WRAPPER_H\n+#define BITCOIN_NATPMP_INCLUDE_NATMAP_WRAPPER_H\n+\n+#include <stdio.h>\n+#include <errno.h>\n+#include <string.h>\n+#if !defined(_MSC_VER)\n+#include <unistd.h>\n+#endif\n+#ifdef WIN32\n+#include <winsock2.h>\n+#else\n+#include <netinet/in.h>\n+#include <arpa/inet.h>\n+#endif\n+#include <natpmp.h>\n+#include <string>\n+#include <iostream>\n+#include <logging.h>\n+#if defined(_WIN32) || defined(_WIN64)\n+#include <ws2ipdef.h>\n+#include <ws2tcpip.h>\n+#endif\n+#include <array>\n+\n+enum class Protocol {\n+    UDP = 1,\n+    TCP\n+};\n+using TimeValType = struct timeval;\n+\n+/// @brief Wrapper over libnatpmp functions\n+class NatMap\n+{\n+private:\n+    natpmp_t m_NatPmpObj;\n+    int m_State;\n+\n+public:\n+    /// @brief Constructor\n+    ///\n+    /// @param alternateGWAddr Pass a known gateway if default not to be used.\n+    explicit NatMap(in_addr_t* alternateGWAddr = nullptr);\n+    ~NatMap();\n+\n+    /// @brief Expected to be called immediately after object construction.\n+    ///\n+    /// @return Zero or error code.\n+    int IsGood() const;\n+\n+    /// @brief Ask gateway his public (internet facing) address. Does about\n+    ///        9 re-tries before giving up. So expect it to be a bit time consuming.\n+    ///\n+    /// @param publicAddressOut You would receive address in this\n+    ///\n+    /// @return Error code or success\n+    int GetPublicAddress(std::string& publicAddressOut);\n+\n+    /// @brief Ask gateway to map your m/c port on the internet.\n+    ///        Pass same data to renew and zero life time to discontinue.\n+    ///\n+    /// @param protocol TCP/UDP\n+    /// @param privatePort your m/c port\n+    /// @param publicPortOut port on public IP, IN/Out Param ( Don't\n+    ///                      always expect to get what you wish ;))\n+    /// @param lifeTimeOut Lifetime of mapping, IN/Out Parameter\n+    ///\n+    /// @return Error code or success\n+    int SendMapReq(Protocol protocol, uint16_t privatePort, uint16_t& publicPortOut, uint32_t& lifeTimeOut);\n+    /// @brief Convert your error into meaningful message.\n+    ///\n+    /// @param err your error code\n+    ///\n+    /// @return Readable message\n+    std::string GetErrMsg(int err);\n+\n+    /// @brief Get the default gateway\n+    ///\n+    /// @param addrOut Out parameter\n+    ///\n+    /// @return yes/no\n+    int GetDefaultGateway(std::string& addrOut) const;\n+};\n+\n+#endif // BITCOIN_NATPMP_INCLUDE_NATMAP_WRAPPER_H"
      },
      {
        "sha": "d8fa3d5c9818548fb47324d3fa76b94e1831f624",
        "filename": "src/natpmp/include/natpmp.h",
        "status": "modified",
        "additions": 18,
        "deletions": 17,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26/src/natpmp/include/natpmp.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26/src/natpmp/include/natpmp.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/natpmp/include/natpmp.h?ref=ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26",
        "patch": "@@ -20,20 +20,21 @@\n #endif\n #include <cstdint>\n \n-typedef struct {\n-    int s;    /* socket */\n-    in_addr_t gateway;    /* default gateway (IPv4) */\n+struct natpmp {\n+    int s;             /* socket */\n+    in_addr_t gateway; /* default gateway (IPv4) */\n     int has_pending_request;\n     unsigned char pending_request[12];\n     int pending_request_len;\n     int try_number;\n     struct timeval retry_time;\n-} natpmp_t;\n+};\n+using natpmp_t = struct natpmp;\n \n-typedef struct {\n-    int16_t type;    /* NATPMP_RESPTYPE_* */\n-    int16_t resultcode;    /* NAT-PMP response code */\n-    int64_t epoch;    /* Seconds since start of epoch */\n+struct natpmpresp {\n+    int16_t type;       /* NATPMP_RESPTYPE_* */\n+    int16_t resultcode; /* NAT-PMP response code */\n+    int64_t epoch;      /* Seconds since start of epoch */\n     union {\n         struct {\n             struct in_addr addr;\n@@ -44,7 +45,8 @@ typedef struct {\n             int64_t lifetime;\n         } newportmapping;\n     } pnu;\n-} natpmpresp_t;\n+};\n+using natpmpresp_t = struct natpmpresp;\n \n /* possible values for type field of natpmpresp_t */\n #define NATPMP_RESPTYPE_PUBLICADDRESS (0)\n@@ -113,7 +115,7 @@ extern \"C\" {\n  * NATPMP_ERR_CONNECTERR\n  *\n  */\n-int InitNatPmp(natpmp_t * p, int forcegw, in_addr_t forcedgw);\n+int InitNatPmp(natpmp_t* p, int forcegw, in_addr_t forcedgw);\n \n /*\n  * CloseNatPmp()\n@@ -124,7 +126,7 @@ int InitNatPmp(natpmp_t * p, int forcegw, in_addr_t forcedgw);\n  * NATPMP_ERR_CLOSEERR\n  *\n  */\n-int CloseNatPmp(natpmp_t * p);\n+int CloseNatPmp(natpmp_t* p);\n \n /*\n  * SendPublicAddressRequest()\n@@ -135,7 +137,7 @@ int CloseNatPmp(natpmp_t * p);\n  * NATPMP_ERR_SENDERR\n  *\n  */\n-int SendPublicAddressRequest(natpmp_t * p);\n+int SendPublicAddressRequest(natpmp_t* p);\n \n /*\n  * SendNewPortMappingRequest()\n@@ -152,8 +154,7 @@ int SendPublicAddressRequest(natpmp_t * p);\n  * NATPMP_ERR_SENDERR\n  *\n  */\n-int SendNewPortMappingRequest(natpmp_t * p, int protocol, int16_t privateport,\n-                              int16_t publicport, int64_t lifetime);\n+int SendNewPortMappingRequest(natpmp_t* p, int protocol, int16_t privateport, int16_t publicport, int64_t lifetime);\n \n /*\n  * GetNatPmpRequestTimeout()\n@@ -166,7 +167,7 @@ int SendNewPortMappingRequest(natpmp_t * p, int protocol, int16_t privateport,\n  * NATPMP_ERR_NOPENDINGREQ\n  *\n  */\n-int GetNatPmpRequestTimeout(natpmp_t * p, struct timeval * timeout);\n+int GetNatPmpRequestTimeout(natpmp_t* p, struct timeval* timeout);\n \n /*\n  * ReadNatPmpResponseOrRetry()\n@@ -188,9 +189,9 @@ int GetNatPmpRequestTimeout(natpmp_t * p, struct timeval * timeout);\n  * NATPMP_ERR_UNDEFINEDERROR\n  *\n  */\n-int ReadNatPmpResponseOrRetry(natpmp_t * p, natpmpresp_t * response);\n+int ReadNatPmpResponseOrRetry(natpmp_t* p, natpmpresp_t* response);\n \n-const char * StrNatPmpErr(int t);\n+const char* StrNatPmpErr(int err);\n \n #ifdef __cplusplus\n }"
      },
      {
        "sha": "c07605954f0aeed70416d4d74dbc7cbfba8cfb1b",
        "filename": "src/natpmp/natmap_wrapper.cpp",
        "status": "added",
        "additions": 106,
        "deletions": 0,
        "changes": 106,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26/src/natpmp/natmap_wrapper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26/src/natpmp/natmap_wrapper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/natpmp/natmap_wrapper.cpp?ref=ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26",
        "patch": "@@ -0,0 +1,106 @@\n+#include <natmap_wrapper.h>\n+\n+NatMap::NatMap(in_addr_t* alternateGWAddr)\n+{\n+    memset(&m_NatPmpObj, 0, sizeof(m_NatPmpObj));\n+    in_addr_t gateway = {0};\n+    if (alternateGWAddr) {\n+        memcpy(&gateway, alternateGWAddr, sizeof(gateway));\n+    }\n+    m_State = InitNatPmp(&m_NatPmpObj,\n+        alternateGWAddr ? 1 : 0,\n+        gateway);\n+}\n+\n+int NatMap::IsGood() const\n+{\n+    return m_State;\n+}\n+\n+NatMap::~NatMap()\n+{\n+    int returnCode = CloseNatPmp(&m_NatPmpObj);\n+    LogPrint(BCLog::NET, \"NAT-PMP: Closed Connection to gateway [%s]\\n\", GetErrMsg(returnCode));\n+}\n+\n+int NatMap::GetPublicAddress(std::string& publicAddressOut)\n+{\n+    int returnCode = SendPublicAddressRequest(&m_NatPmpObj);\n+    if (returnCode < 0) {\n+        return returnCode;\n+    }\n+    fd_set fds;\n+    natpmpresp_t response;\n+    TimeValType timeout;\n+    memset(&response, 0, sizeof(response));\n+    memset(&timeout, 0, sizeof(timeout));\n+    do {\n+        FD_ZERO(&fds);\n+        FD_SET(m_NatPmpObj.s, &fds);\n+        GetNatPmpRequestTimeout(&m_NatPmpObj, &timeout);\n+        returnCode = select(FD_SETSIZE, &fds, nullptr, nullptr, &timeout);\n+        if (returnCode < 0) {\n+            return returnCode;\n+        }\n+        returnCode = ReadNatPmpResponseOrRetry(&m_NatPmpObj, &response);\n+    } while (returnCode == NATPMP_TRYAGAIN);\n+\n+    if (returnCode < 0) {\n+        return returnCode;\n+    }\n+    std::array<char, INET_ADDRSTRLEN> address;\n+    address.fill('\\0');\n+    inet_ntop(AF_INET, &(response.pnu.publicaddress.addr), address.data(), INET_ADDRSTRLEN);\n+    publicAddressOut = std::string(address.data());\n+    return 0;\n+}\n+\n+int NatMap::SendMapReq(Protocol protocol, uint16_t privatePort, uint16_t& publicPortOut, uint32_t& lifeTimeOut)\n+{\n+    int baseProtocol = (protocol == Protocol::TCP) ? NATPMP_PROTOCOL_TCP : NATPMP_PROTOCOL_UDP;\n+    int returnCode = SendNewPortMappingRequest(&m_NatPmpObj, baseProtocol,\n+        privatePort, publicPortOut,\n+        lifeTimeOut);\n+    if (returnCode < 0) {\n+        return returnCode;\n+    }\n+\n+    fd_set fds;\n+    TimeValType timeout;\n+    natpmpresp_t response;\n+    memset(&response, 0, sizeof(response));\n+    memset(&timeout, 0, sizeof(timeout));\n+    do {\n+        FD_ZERO(&fds);\n+        FD_SET(m_NatPmpObj.s, &fds);\n+        GetNatPmpRequestTimeout(&m_NatPmpObj, &timeout);\n+        returnCode = select(FD_SETSIZE, &fds, nullptr, nullptr, &timeout);\n+        if (returnCode < 0) {\n+            return NATMAP_ERR_SELECT;\n+        }\n+        returnCode = ReadNatPmpResponseOrRetry(&m_NatPmpObj, &response);\n+    } while (returnCode == NATPMP_TRYAGAIN);\n+    if (returnCode < 0) {\n+        return returnCode;\n+    }\n+\n+    publicPortOut = response.pnu.newportmapping.mappedpublicport;\n+    lifeTimeOut = response.pnu.newportmapping.lifetime;\n+    return 0;\n+}\n+\n+std::string NatMap::GetErrMsg(int err)\n+{\n+    return std::string(StrNatPmpErr(err));\n+}\n+\n+int NatMap::GetDefaultGateway(std::string& addrOut) const\n+{\n+    struct in_addr gateway = {0};\n+    gateway.s_addr = m_NatPmpObj.gateway;\n+    std::array<char, INET_ADDRSTRLEN> address;\n+    address.fill('\\0');\n+    inet_ntop(AF_INET, &(gateway), address.data(), INET_ADDRSTRLEN);\n+    addrOut = std::string(address.data());\n+    return 0;\n+}"
      },
      {
        "sha": "01bb4a952cf04816e97469a6a25129a28dfb00da",
        "filename": "src/natpmp/natpmp.cpp",
        "status": "modified",
        "additions": 87,
        "deletions": 85,
        "changes": 172,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26/src/natpmp/natpmp.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26/src/natpmp/natpmp.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/natpmp/natpmp.cpp?ref=ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26",
        "patch": "@@ -42,126 +42,126 @@ int gettimeofday(struct timeval* p, void* tz)\n         FILETIME ft;\n     } _now;\n \n-    if(!p)\n+    if (!p)\n         return -1;\n-    GetSystemTimeAsFileTime( &(_now.ft) );\n-    p->tv_usec =(long)((_now.ns100 / 10LL) % 1000000LL );\n-    p->tv_sec = (long)((_now.ns100-(116444736000000000LL))/10000000LL);\n+    GetSystemTimeAsFileTime(&(_now.ft));\n+    p->tv_usec = (long)((_now.ns100 / 10LL) % 1000000LL);\n+    p->tv_sec = (long)((_now.ns100 - (116444736000000000LL)) / 10000000LL);\n     return 0;\n }\n #endif\n \n-int InitNatPmp(natpmp_t * p, int forcegw, in_addr_t forcedgw)\n+int InitNatPmp(natpmp_t* p, int forcegw, in_addr_t forcedgw)\n {\n #ifdef WIN32\n     u_long ioctlArg = 1;\n #else\n-    int flags;\n+    int flags = 0;\n #endif\n-    if(!p)\n+    if (!p)\n         return NATPMP_ERR_INVALIDARGS;\n-    struct sockaddr_in addr;\n-    memset(p, 0, sizeof(natpmp_t));\n     p->s = socket(PF_INET, SOCK_DGRAM, 0);\n-    if(p->s < 0)\n+    if (p->s < 0)\n         return NATPMP_ERR_SOCKETERROR;\n #ifdef WIN32\n-    if(ioctlsocket(p->s, FIONBIO, &ioctlArg) == SOCKET_ERROR)\n+    if (ioctlsocket(p->s, FIONBIO, &ioctlArg) == SOCKET_ERROR)\n         return NATPMP_ERR_FCNTLERROR;\n #else\n-    if((flags = fcntl(p->s, F_GETFL, 0)) < 0)\n+    if ((flags = fcntl(p->s, F_GETFL, 0)) < 0)\n         return NATPMP_ERR_FCNTLERROR;\n-    if(fcntl(p->s, F_SETFL, flags | O_NONBLOCK) < 0)\n+    if (fcntl(p->s, F_SETFL, flags | O_NONBLOCK) < 0)\n         return NATPMP_ERR_FCNTLERROR;\n #endif\n \n-    if(forcegw) {\n+    if (forcegw) {\n         p->gateway = forcedgw;\n     } else {\n-        if(GetDefaultGateway(&(p->gateway)) < 0)\n+        if (GetDefaultGateway(&(p->gateway)) < 0)\n             return NATPMP_ERR_CANNOTGETGATEWAY;\n     }\n \n+    struct sockaddr_in addr;\n     memset(&addr, 0, sizeof(addr));\n     addr.sin_family = AF_INET;\n     addr.sin_port = htons(NATPMP_PORT);\n     addr.sin_addr.s_addr = p->gateway;\n-    if(connect(p->s, (struct sockaddr *)&addr, sizeof(addr)) < 0)\n+    if (connect(p->s, (struct sockaddr*)&addr, sizeof(addr)) < 0)\n         return NATPMP_ERR_CONNECTERR;\n     return 0;\n }\n \n-int CloseNatPmp(natpmp_t * p)\n+int CloseNatPmp(natpmp_t* p)\n {\n-    if(!p)\n+    if (!p)\n         return NATPMP_ERR_INVALIDARGS;\n-    if(closesocket(p->s) < 0)\n+    if (closesocket(p->s) < 0)\n         return NATPMP_ERR_CLOSEERR;\n     return 0;\n }\n \n-int sendpendingrequest(natpmp_t * p)\n+int sendpendingrequest(natpmp_t* p)\n {\n-    if(!p)\n+    if (!p)\n         return NATPMP_ERR_INVALIDARGS;\n #ifdef __linux__\n     int r = (int)send(p->s, p->pending_request, p->pending_request_len, 0);\n #else\n     int r = (int)send(p->s, (const char*)p->pending_request, p->pending_request_len, 0);\n #endif\n \n-    return (r<0) ? NATPMP_ERR_SENDERR : r;\n+    return (r < 0) ? NATPMP_ERR_SENDERR : r;\n }\n \n-int SendNatPmpRequest(natpmp_t * p)\n+int SendNatPmpRequest(natpmp_t* p)\n {\n-    if(!p)\n+    if (!p)\n         return NATPMP_ERR_INVALIDARGS;\n     p->has_pending_request = 1;\n     p->try_number = 1;\n     int n = sendpendingrequest(p);\n-    gettimeofday(&p->retry_time, nullptr);\n+    if (gettimeofday(&p->retry_time, nullptr) < 0) {\n+        return NATPMP_ERR_GETTIMEOFDAYERR;\n+    }\n     p->retry_time.tv_usec += 250000;\n-    if(p->retry_time.tv_usec >= 1000000) {\n+    if (p->retry_time.tv_usec >= 1000000) {\n         p->retry_time.tv_usec -= 1000000;\n         p->retry_time.tv_sec++;\n     }\n     return n;\n }\n \n-int GetNatPmpRequestTimeout(natpmp_t * p, struct timeval * timeout)\n+int GetNatPmpRequestTimeout(natpmp_t* p, struct timeval* timeout)\n {\n-    if(!p || !timeout)\n+    if (!p || !timeout)\n         return NATPMP_ERR_INVALIDARGS;\n-    if(!p->has_pending_request)\n+    if (!p->has_pending_request)\n         return NATPMP_ERR_NOPENDINGREQ;\n     struct timeval now;\n     memset(&now, 0, sizeof(now));\n-    if(gettimeofday(&now, nullptr) < 0)\n+    if (gettimeofday(&now, nullptr) < 0)\n         return NATPMP_ERR_GETTIMEOFDAYERR;\n     timeout->tv_sec = p->retry_time.tv_sec - now.tv_sec;\n     timeout->tv_usec = p->retry_time.tv_usec - now.tv_usec;\n-    if(timeout->tv_usec < 0) {\n+    if (timeout->tv_usec < 0) {\n         timeout->tv_usec += 1000000;\n         timeout->tv_sec--;\n     }\n     return 0;\n }\n \n-int SendPublicAddressRequest(natpmp_t * p)\n+int SendPublicAddressRequest(natpmp_t* p)\n {\n-    if(!p)\n+    if (!p)\n         return NATPMP_ERR_INVALIDARGS;\n     p->pending_request[0] = 0;\n     p->pending_request[1] = 0;\n     p->pending_request_len = 2;\n     return SendNatPmpRequest(p);\n }\n \n-int SendNewPortMappingRequest(natpmp_t * p, int protocol, int16_t privateport,\n-                  int16_t publicport, int64_t lifetime)\n+int SendNewPortMappingRequest(natpmp_t* p, int protocol, int16_t privateport, int16_t publicport, int64_t lifetime)\n {\n-    if(!p || (protocol!=NATPMP_PROTOCOL_TCP && protocol!=NATPMP_PROTOCOL_UDP))\n+    if (!p || (protocol != NATPMP_PROTOCOL_TCP && protocol != NATPMP_PROTOCOL_UDP))\n         return NATPMP_ERR_INVALIDARGS;\n     p->pending_request[0] = 0;\n     p->pending_request[1] = protocol;\n@@ -179,51 +179,50 @@ int SendNewPortMappingRequest(natpmp_t * p, int protocol, int16_t privateport,\n     return SendNatPmpRequest(p);\n }\n \n-int ReadNatPmpResponse(natpmp_t * p, natpmpresp_t * response)\n+int ReadNatPmpResponse(natpmp_t* p, natpmpresp_t* response)\n {\n     unsigned char buf[16] = {0};\n     struct sockaddr_in addr;\n     memset(&addr, 0, sizeof(addr));\n     socklen_t addrlen = sizeof(addr);\n-    int n;\n-    if(!p)\n+    if (!p)\n         return NATPMP_ERR_INVALIDARGS;\n #ifdef __linux__\n-    n = recvfrom(p->s, buf, sizeof(buf), 0,\n-                 (struct sockaddr *)&addr, &addrlen);\n+    int n = recvfrom(p->s, buf, sizeof(buf), 0,\n+        (struct sockaddr*)&addr, &addrlen);\n #else\n-    n = recvfrom(p->s, (char*)buf, sizeof(buf), 0,\n-                 (struct sockaddr *)&addr, &addrlen);\n+    int n = recvfrom(p->s, (char*)buf, sizeof(buf), 0,\n+        (struct sockaddr*)&addr, &addrlen);\n #endif\n \n-    if(n<0) {\n+    if (n < 0) {\n #ifdef WIN32\n-        switch(WSAGetLastError()) {\n+        switch (WSAGetLastError()) {\n #else\n-        switch(errno) {\n+        switch (errno) {\n #endif\n-            /*case EAGAIN:*/\n-            case EWOULDBLOCK:\n-                n = NATPMP_TRYAGAIN;\n-                break;\n-            case ECONNREFUSED:\n-                n = NATPMP_ERR_NOGATEWAYSUPPORT;\n-                break;\n-            default:\n-                n = NATPMP_ERR_RECVFROM;\n+        /*case EAGAIN:*/\n+        case EWOULDBLOCK:\n+            n = NATPMP_TRYAGAIN;\n+            break;\n+        case ECONNREFUSED:\n+            n = NATPMP_ERR_NOGATEWAYSUPPORT;\n+            break;\n+        default:\n+            n = NATPMP_ERR_RECVFROM;\n         }\n-    /* check that addr is correct (= gateway) */\n-    }else if(addr.sin_addr.s_addr != p->gateway) {\n+        /* check that addr is correct (= gateway) */\n+    } else if (addr.sin_addr.s_addr != p->gateway) {\n         n = NATPMP_ERR_WRONGPACKETSOURCE;\n-    }else {\n-        response->resultcode = ntohs(*((int16_t *)(buf + 2)));\n-        response->epoch = ntohl(*((int64_t *)(buf + 4)));\n-        if(buf[0] != 0)\n+    } else {\n+        response->resultcode = ntohs(*((int16_t*)(buf + 2)));\n+        response->epoch = ntohl(*((int64_t*)(buf + 4)));\n+        if (buf[0] != 0)\n             n = NATPMP_ERR_UNSUPPORTEDVERSION;\n-        else if(buf[1] < 128 || buf[1] > 130)\n+        else if (buf[1] < 128 || buf[1] > 130)\n             n = NATPMP_ERR_UNSUPPORTEDOPCODE;\n-        else if(response->resultcode != 0) {\n-            switch(response->resultcode) {\n+        else if (response->resultcode != 0) {\n+            switch (response->resultcode) {\n             case 1:\n                 n = NATPMP_ERR_UNSUPPORTEDVERSION;\n                 break;\n@@ -244,45 +243,48 @@ int ReadNatPmpResponse(natpmp_t * p, natpmpresp_t * response)\n             }\n         } else {\n             response->type = buf[1] & 0x7f;\n-            if(buf[1] == 128) {\n-                response->pnu.publicaddress.addr.s_addr = *((int64_t *)(buf + 8));\n-            }else {\n-                response->pnu.newportmapping.privateport = ntohs(*((int16_t *)(buf + 8)));\n-                response->pnu.newportmapping.mappedpublicport = ntohs(*((int16_t *)(buf + 10)));\n-                response->pnu.newportmapping.lifetime = ntohl(*((int64_t *)(buf + 12)));\n+            if (buf[1] == 128) {\n+                response->pnu.publicaddress.addr.s_addr = *((int64_t*)(buf + 8));\n+            } else {\n+                response->pnu.newportmapping.privateport = ntohs(*((int16_t*)(buf + 8)));\n+                response->pnu.newportmapping.mappedpublicport = ntohs(*((int16_t*)(buf + 10)));\n+                response->pnu.newportmapping.lifetime = ntohl(*((int64_t*)(buf + 12)));\n             }\n             n = 0;\n         }\n     }\n     return n;\n }\n \n-int ReadNatPmpResponseOrRetry(natpmp_t * p, natpmpresp_t * response)\n+int ReadNatPmpResponseOrRetry(natpmp_t* p, natpmpresp_t* response)\n {\n-    if(!p || !response)\n+    if (!p || !response)\n         return NATPMP_ERR_INVALIDARGS;\n-    if(!p->has_pending_request)\n+    if (!p->has_pending_request)\n         return NATPMP_ERR_NOPENDINGREQ;\n     int n = ReadNatPmpResponse(p, response);\n-    if(n<0) {\n-        if(n==NATPMP_TRYAGAIN) {\n+    if (n < 0) {\n+        if (n == NATPMP_TRYAGAIN) {\n             struct timeval now;\n-            gettimeofday(&now, nullptr);\n-            if(timercmp(&now, &p->retry_time, >=)) {\n-                int delay, r;\n-                if(p->try_number >= 9) {\n+            memset(&now, 0, sizeof(now));\n+            if (gettimeofday(&now, nullptr) < 0) {\n+                return NATPMP_ERR_GETTIMEOFDAYERR;\n+            }\n+            if (timercmp(&now, &p->retry_time, >=)) {\n+                int delay = 0, r = 0;\n+                if (p->try_number >= 9) {\n                     return NATPMP_ERR_NOGATEWAYSUPPORT;\n                 }\n-                delay = 250 * (1<<p->try_number);\n+                delay = 250 * (1 << p->try_number);\n                 p->retry_time.tv_sec += (delay / 1000);\n                 p->retry_time.tv_usec += (delay % 1000) * 1000;\n-                if(p->retry_time.tv_usec >= 1000000) {\n+                if (p->retry_time.tv_usec >= 1000000) {\n                     p->retry_time.tv_usec -= 1000000;\n                     p->retry_time.tv_sec++;\n                 }\n                 p->try_number++;\n                 r = sendpendingrequest(p);\n-                if(r<0)\n+                if (r < 0)\n                     return r;\n             }\n         }\n@@ -292,10 +294,10 @@ int ReadNatPmpResponseOrRetry(natpmp_t * p, natpmpresp_t * response)\n     return n;\n }\n \n-const char * StrNatPmpErr(int r)\n+const char* StrNatPmpErr(int err)\n {\n-    const char *s = nullptr;\n-    switch(r) {\n+    const char* s = nullptr;\n+    switch (err) {\n     case 0:\n         s = \"No Error\";\n         break;"
      },
      {
        "sha": "a676f036e2f9b29bd9362cde4447a07ad5b19663",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 100,
        "deletions": 17,
        "changes": 117,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=ce1ef8a9fd77b6e716bf58f56cb3ad0bcd5fee26",
        "patch": "@@ -9,6 +9,9 @@\n \n #include <net.h>\n \n+#include <atomic>\n+#include <condition_variable>\n+#include <chrono>\n #include <banman.h>\n #include <chainparams.h>\n #include <clientversion.h>\n@@ -20,6 +23,8 @@\n #include <scheduler.h>\n #include <ui_interface.h>\n #include <util/strencodings.h>\n+#include <thread>\n+#include <logging.h>\n \n #ifdef WIN32\n #include <string.h>\n@@ -39,7 +44,7 @@\n #endif\n \n #include <unordered_map>\n-\n+#include <natmap_wrapper.h>\n #include <math.h>\n \n // Dump addresses to peers.dat every 15 minutes (900s)\n@@ -60,11 +65,22 @@ static constexpr int DUMP_PEERS_INTERVAL = 15 * 60;\n \n /** Used to pass flags to the Bind() function */\n enum BindFlags {\n-    BF_NONE         = 0,\n-    BF_EXPLICIT     = (1U << 0),\n+    BF_NONE = 0,\n+    BF_EXPLICIT = (1U << 0),\n     BF_REPORT_ERROR = (1U << 1),\n-    BF_WHITELIST    = (1U << 2),\n+    BF_WHITELIST = (1U << 2),\n+};\n+\n+// NAT-PMP State\n+enum class NatPmpState {\n+    NONE,\n+    INITIALIZED,\n+    RECEIVED_PUBLIC_IP,\n+    MAPPED_PORT\n };\n+NatPmpState g_NatPmpStatus = NatPmpState::NONE;\n+std::condition_variable g_StateCondVar;\n+std::mutex g_StateMutex;\n \n // The set of sockets cannot be modified while waiting\n // The sleep time needs to be small to avoid new sockets stalling\n@@ -1387,11 +1403,6 @@ void CConnman::WakeMessageHandler()\n     condMsgProc.notify_one();\n }\n \n-\n-\n-\n-\n-\n #ifdef USE_UPNP\n static CThreadInterrupt g_upnp_interrupt;\n static std::thread g_upnp_thread;\n@@ -1500,25 +1511,97 @@ void StopMapPort()\n }\n \n #else\n+\n+void RenewPortMapping(NatMap& mapper, const unsigned short& localPort, unsigned short& publicPort, uint32_t lifeTime)\n+{\n+    while (true) {\n+        int state = mapper.SendMapReq(Protocol::TCP, localPort,\n+            publicPort, lifeTime);\n+        if (state != 0) {\n+            LogPrintf(\"Failed to renew mapping of public port %d to local port %d : %s\\n\",\n+                publicPort, localPort, mapper.GetErrMsg(state).c_str());\n+            return;\n+        }\n+        uint32_t sleepPeriod = ((int)lifeTime - 30) < 0 ? 0 : (lifeTime - 30);\n+        std::unique_lock<std::mutex> stateLock(g_StateMutex);\n+        g_StateCondVar.wait_for(stateLock,\n+            std::chrono::seconds(sleepPeriod),\n+            [] { return g_NatPmpStatus == NatPmpState::MAPPED_PORT; });\n+        if (g_NatPmpStatus == NatPmpState::MAPPED_PORT) break;\n+    }\n+}\n+\n void StartMapPort()\n {\n-    // Intentionally left blank.\n+    NatMap mapper;\n+    int state = mapper.IsGood();\n+    std::string defaultGateway;\n+    mapper.GetDefaultGateway(defaultGateway);\n+    if (state != 0) {\n+        LogPrintf(\"Failed to initialize NAT-PMP through default gateway %s: %s\\n\",\n+            defaultGateway.c_str(), mapper.GetErrMsg(state).c_str());\n+        return;\n+    }\n+    g_NatPmpStatus = NatPmpState::INITIALIZED;\n+    std::string publicAddr;\n+    LogPrintf(\"Trying to get public address of gateway for NAT-PMP, might take a while.\\n\");\n+    state = mapper.GetPublicAddress(publicAddr);\n+    if (state != 0) {\n+        LogPrintf(\"Failed to get public address of gateway [%s] with error [%s]\\n\",\n+            defaultGateway.c_str(), mapper.GetErrMsg(state).c_str());\n+        return;\n+    }\n+    g_NatPmpStatus = NatPmpState::RECEIVED_PUBLIC_IP;\n+    LogPrintf(\"Public address of gateway is [%s]\\n\", publicAddr.c_str());\n+\n+    uint32_t life = 10000;\n+    unsigned short localPort = GetListenPort();\n+    unsigned short publicPort = localPort;\n+    state = mapper.SendMapReq(Protocol::TCP, localPort,\n+        publicPort, life);\n+    if (state != 0) {\n+        LogPrintf(\"Failed to map public port %d to local port %d with error [%s]\\n\",\n+            publicPort, localPort, mapper.GetErrMsg(state).c_str());\n+        return;\n+    }\n+    std::thread natMapperReNewer(RenewPortMapping, std::ref(mapper), std::ref(localPort), std::ref(publicPort), std::ref(life));\n+    natMapperReNewer.detach();\n+    g_NatPmpStatus = NatPmpState::MAPPED_PORT;\n+    LogPrintf(\"Successfully mapped local port %d to %s:%d\\n\",\n+        localPort, publicAddr.c_str(), publicPort);\n }\n+\n void InterruptMapPort()\n {\n-    // Intentionally left blank.\n+    StopMapPort();\n }\n void StopMapPort()\n {\n-    // Intentionally left blank.\n+    if (g_NatPmpStatus != NatPmpState::MAPPED_PORT) {\n+        return;\n+    }\n+    {\n+        std::lock_guard<std::mutex> statusLock(g_StateMutex);\n+        g_NatPmpStatus = NatPmpState::NONE;\n+    }\n+    g_StateCondVar.notify_one();\n+    uint32_t life = 0;\n+    unsigned short localPort = GetListenPort();\n+    unsigned short publicPort = localPort;\n+    NatMap mapper;\n+    int state = mapper.SendMapReq(Protocol::TCP, localPort,\n+        publicPort, life);\n+    if (state != 0) {\n+        LogPrintf(\"Failed to remove map between public port %d and local port %d with error [%s]\\n\",\n+            publicPort, localPort, mapper.GetErrMsg(state).c_str());\n+        return;\n+    }\n+\n+    LogPrintf(\"Successfully removed map between public port %d and local port %d \\n\", publicPort, localPort);\n+    g_NatPmpStatus = NatPmpState::NONE;\n }\n #endif\n \n-\n-\n-\n-\n-\n void CConnman::ThreadDNSAddressSeed()\n {\n     // goal: only query DNS seeds if address need is acute"
      }
    ]
  }
]