[
  {
    "sha": "100ce28f5a313afa772178fbe8970556c17605ec",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMDBjZTI4ZjVhMzEzYWZhNzcyMTc4ZmJlODk3MDU1NmMxNzYwNWVj",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "j@rubin.io",
        "date": "2019-03-29T21:48:20Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "message": "Adds a rust library to bitcoin to demonstrate linking and building rust code.\n\nThe demonstration library compiles a rust hello world example and auto-generates\na header which can be included in C++ code.\n\nCo-Authored-By: Jeremy Rubin <j@rubin.io>\nCo-Authored-By: Cory Fields <cory-nospam-@coryfields.com>\nVarious changes by: Matt Corallo <git@bluematt.me>",
      "tree": {
        "sha": "74e6aa3e04612ee44767f5261babd73c432de486",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/74e6aa3e04612ee44767f5261babd73c432de486"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/100ce28f5a313afa772178fbe8970556c17605ec",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/100ce28f5a313afa772178fbe8970556c17605ec",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/100ce28f5a313afa772178fbe8970556c17605ec",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/100ce28f5a313afa772178fbe8970556c17605ec/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6fff333c9f00cf379562ed38c2599997f9821cfb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6fff333c9f00cf379562ed38c2599997f9821cfb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6fff333c9f00cf379562ed38c2599997f9821cfb"
      }
    ],
    "stats": {
      "total": 145,
      "additions": 137,
      "deletions": 8
    },
    "files": [
      {
        "sha": "359524ee76be5f22dfa444e48941a4120a9915bf",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 42,
        "deletions": 0,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/100ce28f5a313afa772178fbe8970556c17605ec/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/100ce28f5a313afa772178fbe8970556c17605ec/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=100ce28f5a313afa772178fbe8970556c17605ec",
        "patch": "@@ -211,6 +211,12 @@ AC_ARG_ENABLE([asm],\n   [use_asm=$enableval],\n   [use_asm=yes])\n \n+AC_ARG_ENABLE([rust],\n+  [AS_HELP_STRING([--enable-rust],\n+  [Enable rust code (default is no)])],\n+  [use_rust=$enableval],\n+  [use_rust=no])\n+\n if test \"x$use_asm\" = xyes; then\n   AC_DEFINE(USE_ASM, 1, [Define this symbol to build in assembly routines])\n fi\n@@ -478,6 +484,39 @@ AC_ARG_WITH([daemon],\n   [build_bitcoind=$withval],\n   [build_bitcoind=yes])\n \n+if test \"x$use_rust\" = xyes; then\n+  AC_PATH_PROG(RUSTC,rustc,none)\n+  if test x$RUSTC = xnone; then\n+    AC_MSG_ERROR(\"rustc required to enable rust support.\")\n+  fi\n+\n+  AC_DEFINE(ENABLE_RUSTY, 1, [Define this symbol to build in rust modules])\n+\n+  dnl Find the additional lib (if any) responsible for handling\n+  dnl dlopen/dlsym/etc.\n+  TEMP_LIBS=\"$LIBS\"\n+  LIBS=\n+  AC_SEARCH_LIBS([dlsym],[dl])\n+  DL_LIBS=\"$LIBS\"\n+  LIBS=\"$TEMP_LIBS\"\n+\n+  RUST_FLAGS=\"\"\n+  if test \"x$enable_debug\" = xyes; then\n+    RUST_FLAGS=\"$RUST_FLAGS -g\"\n+  else\n+    RUST_FLAGS=\"$RUST_FLAGS -O\"\n+  fi\n+\n+  case $host in\n+    ${host_cpu}-w64-mingw*) RUST_FLAGS=\"$RUST_FLAGS --target=${host_cpu}-pc-windows-gnu\" ;;\n+    ${host_cpu}-pc-linux*) RUST_FLAGS=\"$RUST_FLAGS --target=${host_cpu}-unknown-${host_os}\" ;;\n+    ${host_cpu}-apple-darwin*) RUST_FLAGS=\"$RUST_FLAGS --target=${host_cpu}-apple-darwin\" ;;\n+    *) RUST_FLAGS=\"$RUST_FLAGS --target=${host}\" ;;\n+  esac\n+\n+  dnl TODO: create a rust test project and check host_alias as well as host.\n+fi\n+\n use_pkgconfig=yes\n case $host in\n   *mingw*)\n@@ -1535,6 +1574,7 @@ AM_CONDITIONAL([ENABLE_SSE41],[test x$enable_sse41 = xyes])\n AM_CONDITIONAL([ENABLE_AVX2],[test x$enable_avx2 = xyes])\n AM_CONDITIONAL([ENABLE_SHANI],[test x$enable_shani = xyes])\n AM_CONDITIONAL([USE_ASM],[test x$use_asm = xyes])\n+AM_CONDITIONAL([ENABLE_RUSTY], [test x$use_rust = xyes])\n \n AC_DEFINE(CLIENT_VERSION_MAJOR, _CLIENT_VERSION_MAJOR, [Major version])\n AC_DEFINE(CLIENT_VERSION_MINOR, _CLIENT_VERSION_MINOR, [Minor version])\n@@ -1593,6 +1633,8 @@ AC_SUBST(EVENT_LIBS)\n AC_SUBST(EVENT_PTHREADS_LIBS)\n AC_SUBST(ZMQ_LIBS)\n AC_SUBST(QR_LIBS)\n+AC_SUBST(DL_LIBS)\n+AC_SUBST(RUST_FLAGS)\n AC_CONFIG_FILES([Makefile src/Makefile doc/man/Makefile share/setup.nsi share/qt/Info.plist test/config.ini])\n AC_CONFIG_FILES([contrib/devtools/split-debug.sh],[chmod +x contrib/devtools/split-debug.sh])\n AM_COND_IF([HAVE_DOXYGEN], [AC_CONFIG_FILES([doc/Doxyfile])])"
      },
      {
        "sha": "bcf69bab35073dbaf15f4b08625f4c75c1906c7d",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 41,
        "deletions": 3,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/100ce28f5a313afa772178fbe8970556c17605ec/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/100ce28f5a313afa772178fbe8970556c17605ec/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=100ce28f5a313afa772178fbe8970556c17605ec",
        "patch": "@@ -9,6 +9,8 @@ AM_CXXFLAGS = $(DEBUG_CXXFLAGS) $(HARDENED_CXXFLAGS) $(WARN_CXXFLAGS) $(NOWARN_C\n AM_CPPFLAGS = $(DEBUG_CPPFLAGS) $(HARDENED_CPPFLAGS)\n AM_LIBTOOLFLAGS = --preserve-dup-deps\n EXTRA_LIBRARIES =\n+CLEANFILES =\n+LIBBITCOIN_RUST_LIBS =\n \n if EMBEDDED_UNIVALUE\n LIBUNIVALUE = univalue/libunivalue.la\n@@ -33,6 +35,9 @@ LIBBITCOIN_CRYPTO_BASE=crypto/libbitcoin_crypto_base.a\n LIBBITCOINQT=qt/libbitcoinqt.a\n LIBSECP256K1=secp256k1/libsecp256k1.la\n \n+if ENABLE_RUSTY\n+LIBBITCOIN_RUSTY = rusty/librusty.a\n+endif\n if ENABLE_ZMQ\n LIBBITCOIN_ZMQ=libbitcoin_zmq.a\n endif\n@@ -365,6 +370,22 @@ libbitcoin_wallet_tool_a_SOURCES = \\\n   wallet/wallettool.cpp \\\n   $(BITCOIN_CORE_H)\n \n+# rustc only reqires the main .rs file as input, but rustc must also be invoked\n+# if any of the other files change. List the main file first, then targets can\n+# depend on $(LIBBITCOIN_RUSTY_SRCS), but only build the first source file ($<).\n+LIBBITCOIN_RUSTY_SRCS= \\\n+  rusty/src/lib.rs\n+\n+# We force overflow checks on so that any integer overflows result in a panic\n+# instead of, eg, attempting to alloc 4GB of memory (though we will catch such\n+# an alloc and refuse it, generating a panic instead).\n+# Also force panics to unwind (instead of calling abort()) as we want to catch\n+# panics in the Rust threads and simply close the thread, instead of bringing\n+# down the rest of Bitcoin Core.\n+$(LIBBITCOIN_RUSTY): $(LIBBITCOIN_RUSTY_SRCS)\n+\t$(RUSTC) --crate-name rusty $< --crate-type=staticlib --emit=link $(RUST_FLAGS) -C overflow-checks=on -C panic=unwind --out-dir $(@D)\n+\ttouch $@\n+\n # crypto primitives library\n crypto_libbitcoin_crypto_base_a_CPPFLAGS = $(AM_CPPFLAGS)\n crypto_libbitcoin_crypto_base_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n@@ -571,7 +592,7 @@ bitcoind_LDADD = \\\n   $(LIBMEMENV) \\\n   $(LIBSECP256K1)\n \n-bitcoind_LDADD += $(BOOST_LIBS) $(BDB_LIBS) $(MINIUPNPC_LIBS) $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(ZMQ_LIBS)\n+bitcoind_LDADD += $(BOOST_LIBS) $(BDB_LIBS) $(MINIUPNPC_LIBS) $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(ZMQ_LIBS) $(LIBBITCOIN_RUST_LIBS) $(DL_LIBS)\n \n # bitcoin-cli binary #\n bitcoin_cli_SOURCES = bitcoin-cli.cpp\n@@ -663,7 +684,23 @@ CTAES_DIST += crypto/ctaes/ctaes.h\n CTAES_DIST += crypto/ctaes/README.md\n CTAES_DIST += crypto/ctaes/test.c\n \n-CLEANFILES = $(EXTRA_LIBRARIES)\n+BITCOIN_CORE_H += rusty/src/rust_bridge.h\n+\n+if ENABLE_RUSTY\n+LIBBITCOIN_RUST_LIBS += $(LIBBITCOIN_RUSTY)\n+\n+RUSTY_TEST_BIN=rusty/test_rusty\n+$(RUSTY_TEST_BIN): $(LIBBITCOIN_RUSTY_SRCS)\n+\t$(RUSTC) --crate-name test_rusty $< --emit=link --test $(RUST_FLAGS) low-checks=on --out-dir $(@D)\n+\n+## FIXME: always build RUSTY_TEST_BIN the same as we do test_bitcoin\n+RUSTY_CHECK=rusty-check\n+$(RUSTY_CHECK): $(RUSTY_TEST_BIN)\n+\t$(RUSTY_TEST_BIN)\n+\n+CLEANFILES += $(LIBBITCOIN_RUSTY)\n+endif\n+CLEANFILES += $(EXTRA_LIBRARIES)\n \n CLEANFILES += *.gcda *.gcno\n CLEANFILES += compat/*.gcda compat/*.gcno\n@@ -679,7 +716,7 @@ CLEANFILES += wallet/test/*.gcda wallet/test/*.gcno\n CLEANFILES += zmq/*.gcda zmq/*.gcno\n CLEANFILES += obj/build.h\n \n-EXTRA_DIST = $(CTAES_DIST)\n+EXTRA_DIST = $(CTAES_DIST) $(LIBBITCOIN_RUSTY_SRCS)\n \n \n config/bitcoin-config.h: config/stamp-h1\n@@ -692,6 +729,7 @@ $(top_srcdir)/$(subdir)/config/bitcoin-config.h.in:  $(am__configure_deps)\n clean-local:\n \t-$(MAKE) -C secp256k1 clean\n \t-$(MAKE) -C univalue clean\n+\t-rm -rf rusty/test_rusty rusty/test_rusty.dSYM\n \t-rm -f leveldb/*/*.gcda leveldb/*/*.gcno leveldb/helpers/memenv/*.gcda leveldb/helpers/memenv/*.gcno\n \t-rm -f config.h\n \t-rm -rf test/__pycache__"
      },
      {
        "sha": "72bb0f71f5c15dc37a13365896ea600a41a56870",
        "filename": "src/Makefile.bench.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/100ce28f5a313afa772178fbe8970556c17605ec/src/Makefile.bench.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/100ce28f5a313afa772178fbe8970556c17605ec/src/Makefile.bench.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.bench.include?ref=100ce28f5a313afa772178fbe8970556c17605ec",
        "patch": "@@ -73,7 +73,7 @@ bench_bench_bitcoin_SOURCES += bench/coin_selection.cpp\n bench_bench_bitcoin_SOURCES += bench/wallet_balance.cpp\n endif\n \n-bench_bench_bitcoin_LDADD += $(BOOST_LIBS) $(BDB_LIBS) $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(MINIUPNPC_LIBS)\n+bench_bench_bitcoin_LDADD += $(BOOST_LIBS) $(BDB_LIBS) $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(MINIUPNPC_LIBS) $(LIBBITCOIN_RUST_LIBS) $(DL_LIBS)\n bench_bench_bitcoin_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n \n CLEAN_BITCOIN_BENCH = bench/*.gcda bench/*.gcno $(GENERATED_BENCH_FILES)"
      },
      {
        "sha": "3c9759efab57f5dfd9b114d33a2f6fed42a76382",
        "filename": "src/Makefile.qt.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/100ce28f5a313afa772178fbe8970556c17605ec/src/Makefile.qt.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/100ce28f5a313afa772178fbe8970556c17605ec/src/Makefile.qt.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qt.include?ref=100ce28f5a313afa772178fbe8970556c17605ec",
        "patch": "@@ -314,7 +314,7 @@ qt_bitcoin_qt_LDADD += $(LIBBITCOIN_ZMQ) $(ZMQ_LIBS)\n endif\n qt_bitcoin_qt_LDADD += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CONSENSUS) $(LIBBITCOIN_CRYPTO) $(LIBUNIVALUE) $(LIBLEVELDB) $(LIBLEVELDB_SSE42) $(LIBMEMENV) \\\n   $(BOOST_LIBS) $(QT_LIBS) $(QT_DBUS_LIBS) $(QR_LIBS) $(BDB_LIBS) $(MINIUPNPC_LIBS) $(LIBSECP256K1) \\\n-  $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS)\n+  $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(LIBBITCOIN_RUST_LIBS) $(DL_LIBS)\n qt_bitcoin_qt_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(QT_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n qt_bitcoin_qt_LIBTOOLFLAGS = $(AM_LIBTOOLFLAGS) --tag CXX\n "
      },
      {
        "sha": "6f88f70e4aadcb6980beb9f59b5eb303256130a8",
        "filename": "src/Makefile.qttest.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/100ce28f5a313afa772178fbe8970556c17605ec/src/Makefile.qttest.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/100ce28f5a313afa772178fbe8970556c17605ec/src/Makefile.qttest.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qttest.include?ref=100ce28f5a313afa772178fbe8970556c17605ec",
        "patch": "@@ -56,7 +56,7 @@ endif\n qt_test_test_bitcoin_qt_LDADD += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CONSENSUS) $(LIBBITCOIN_CRYPTO) $(LIBUNIVALUE) $(LIBLEVELDB) \\\n   $(LIBLEVELDB_SSE42) $(LIBMEMENV) $(BOOST_LIBS) $(QT_DBUS_LIBS) $(QT_TEST_LIBS) $(QT_LIBS) \\\n   $(QR_LIBS) $(BDB_LIBS) $(MINIUPNPC_LIBS) $(LIBSECP256K1) \\\n-  $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS)\n+  $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(LIBBITCOIN_RUST_LIBS) $(DL_LIBS)\n qt_test_test_bitcoin_qt_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(QT_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n qt_test_test_bitcoin_qt_CXXFLAGS = $(AM_CXXFLAGS) $(QT_PIE_FLAGS)\n "
      },
      {
        "sha": "dc8375390768e8eff87a0b9512c04b83fbaa7707",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/100ce28f5a313afa772178fbe8970556c17605ec/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/100ce28f5a313afa772178fbe8970556c17605ec/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=100ce28f5a313afa772178fbe8970556c17605ec",
        "patch": "@@ -195,7 +195,7 @@ test_test_bitcoin_LDADD += $(LIBBITCOIN_SERVER) $(LIBBITCOIN_CLI) $(LIBBITCOIN_C\n   $(LIBLEVELDB) $(LIBLEVELDB_SSE42) $(LIBMEMENV) $(BOOST_LIBS) $(BOOST_UNIT_TEST_FRAMEWORK_LIB) $(LIBSECP256K1) $(EVENT_LIBS) $(EVENT_PTHREADS_LIBS)\n test_test_bitcoin_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n \n-test_test_bitcoin_LDADD += $(BDB_LIBS) $(MINIUPNPC_LIBS) $(RAPIDCHECK_LIBS)\n+test_test_bitcoin_LDADD += $(BDB_LIBS) $(MINIUPNPC_LIBS) $(RAPIDCHECK_LIBS) $(LIBBITCOIN_RUST_LIBS) $(DL_LIBS)\n test_test_bitcoin_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS) -static\n \n if ENABLE_ZMQ\n@@ -397,7 +397,7 @@ bitcoin_test_check: $(TEST_BINARY) FORCE\n bitcoin_test_clean : FORCE\n \trm -f $(CLEAN_BITCOIN_TEST) $(test_test_bitcoin_OBJECTS) $(TEST_BINARY)\n \n-check-local: $(BITCOIN_TESTS:.cpp=.cpp.test)\n+check-local: $(RUSTY_CHECK) $(BITCOIN_TESTS:.cpp=.cpp.test)\n if BUILD_BITCOIN_TX\n \t@echo \"Running test/util/bitcoin-util-test.py...\"\n \t$(PYTHON) $(top_builddir)/test/util/bitcoin-util-test.py"
      },
      {
        "sha": "7a0cfea89e36e8d26f6771b29b39473dd007c7ac",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/100ce28f5a313afa772178fbe8970556c17605ec/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/100ce28f5a313afa772178fbe8970556c17605ec/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=100ce28f5a313afa772178fbe8970556c17605ec",
        "patch": "@@ -336,8 +336,16 @@ static void OnRPCStopped()\n     LogPrint(BCLog::RPC, \"RPC stopped.\\n\");\n }\n \n+#if ENABLE_RUSTY\n+#include <rusty/src/rust_bridge.h>\n+#endif\n+\n void SetupServerArgs()\n {\n+#if ENABLE_RUSTY\n+    assert(rust_hello_world_example::RUST_CONSTANT == 43);\n+    rust_hello_world_example::hello_world();\n+#endif\n     SetupHelpOptions(gArgs);\n     gArgs.AddArg(\"-help-debug\", \"Print help message with debugging options and exit\", ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST); // server-only for now\n "
      },
      {
        "sha": "855c7706ae1d8a5ec2367dee76c3550eb48b7ad1",
        "filename": "src/rusty/src/lib.rs",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/100ce28f5a313afa772178fbe8970556c17605ec/src/rusty/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/100ce28f5a313afa772178fbe8970556c17605ec/src/rusty/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/lib.rs?ref=100ce28f5a313afa772178fbe8970556c17605ec",
        "patch": "@@ -0,0 +1,15 @@\n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    fn it_works() {\n+        assert_eq!(2 + 2, 4);\n+    }\n+}\n+\n+#[no_mangle]\n+pub static RUST_CONSTANT: i32 = 43;\n+\n+#[no_mangle]\n+pub extern \"C\" fn hello_world() {\n+    println!(\"Hello World!\");\n+}"
      },
      {
        "sha": "a26f97cc783ea5b3cf52ea228d9fcb21f0346585",
        "filename": "src/rusty/src/rust_bridge.h",
        "status": "added",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/100ce28f5a313afa772178fbe8970556c17605ec/src/rusty/src/rust_bridge.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/100ce28f5a313afa772178fbe8970556c17605ec/src/rusty/src/rust_bridge.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/rust_bridge.h?ref=100ce28f5a313afa772178fbe8970556c17605ec",
        "patch": "@@ -0,0 +1,26 @@\n+// Rust functions which are exposed to C++ (ie are #[no_mangle] pub extern \"C\")\n+// Copyright (c) 2009-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_RUSTY_H\n+#define BITCOIN_RUSTY_H\n+\n+#include <cstdarg>\n+#include <cstdint>\n+#include <cstdlib>\n+#include <new>\n+\n+namespace rust_hello_world_example {\n+\n+extern \"C\" {\n+\n+extern int32_t RUST_CONSTANT;\n+\n+void hello_world();\n+\n+} // extern \"C\"\n+\n+} // namespace rust_hello_world_example\n+\n+#endif // BITCOIN_RUSTY_H"
      }
    ]
  },
  {
    "sha": "4830d9e0c8d60fa3d19dcd98d693afd655f9accb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ODMwZDllMGM4ZDYwZmEzZDE5ZGNkOThkNjkzYWZkNjU1ZjlhY2Ni",
    "commit": {
      "author": {
        "name": "fanquake",
        "email": "fanquake@gmail.com",
        "date": "2019-06-15T10:44:20Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "message": "build: show rust enabled in configure output",
      "tree": {
        "sha": "15379f2040f943f35335fe4d333e86454335bbfb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/15379f2040f943f35335fe4d333e86454335bbfb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4830d9e0c8d60fa3d19dcd98d693afd655f9accb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4830d9e0c8d60fa3d19dcd98d693afd655f9accb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4830d9e0c8d60fa3d19dcd98d693afd655f9accb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4830d9e0c8d60fa3d19dcd98d693afd655f9accb/comments",
    "author": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "100ce28f5a313afa772178fbe8970556c17605ec",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/100ce28f5a313afa772178fbe8970556c17605ec",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/100ce28f5a313afa772178fbe8970556c17605ec"
      }
    ],
    "stats": {
      "total": 1,
      "additions": 1,
      "deletions": 0
    },
    "files": [
      {
        "sha": "404bb904a25922080f8cdea95ba0e6a9c4db163b",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4830d9e0c8d60fa3d19dcd98d693afd655f9accb/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4830d9e0c8d60fa3d19dcd98d693afd655f9accb/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=4830d9e0c8d60fa3d19dcd98d693afd655f9accb",
        "patch": "@@ -1703,6 +1703,7 @@ echo \"  sanitizers    = $use_sanitizers\"\n echo \"  debug enabled = $enable_debug\"\n echo \"  gprof enabled = $enable_gprof\"\n echo \"  werror        = $enable_werror\"\n+echo \"  rust enabled  = $use_rust\"\n echo\n echo \"  target os     = $TARGET_OS\"\n echo \"  build os      = $BUILD_OS\""
      }
    ]
  },
  {
    "sha": "828a9822a00d0f9f7502ce23bd6276bae30681cf",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4MjhhOTgyMmEwMGQwZjlmNzUwMmNlMjNiZDYyNzZiYWUzMDY4MWNm",
    "commit": {
      "author": {
        "name": "fanquake",
        "email": "fanquake@gmail.com",
        "date": "2019-06-15T10:44:58Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "message": "build: gitignore src/rusty_test",
      "tree": {
        "sha": "903433080f7ea84a5f95b3de8bf055b2fb258ae2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/903433080f7ea84a5f95b3de8bf055b2fb258ae2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/828a9822a00d0f9f7502ce23bd6276bae30681cf",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/828a9822a00d0f9f7502ce23bd6276bae30681cf",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/828a9822a00d0f9f7502ce23bd6276bae30681cf",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/828a9822a00d0f9f7502ce23bd6276bae30681cf/comments",
    "author": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4830d9e0c8d60fa3d19dcd98d693afd655f9accb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4830d9e0c8d60fa3d19dcd98d693afd655f9accb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4830d9e0c8d60fa3d19dcd98d693afd655f9accb"
      }
    ],
    "stats": {
      "total": 1,
      "additions": 1,
      "deletions": 0
    },
    "files": [
      {
        "sha": "7b20a3fb37236fa5bc7dbe242a81eb5506c98e80",
        "filename": ".gitignore",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/828a9822a00d0f9f7502ce23bd6276bae30681cf/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/828a9822a00d0f9f7502ce23bd6276bae30681cf/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.gitignore?ref=828a9822a00d0f9f7502ce23bd6276bae30681cf",
        "patch": "@@ -7,6 +7,7 @@ src/bitcoind\n src/bitcoin-cli\n src/bitcoin-tx\n src/bitcoin-wallet\n+src/rusty_test\n src/test/test_bitcoin\n src/test/test_bitcoin_fuzzy\n src/qt/test/test_bitcoin-qt"
      }
    ]
  },
  {
    "sha": "9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5YmQ1ZjZmYmEwYjU3ZTZmYzI4NzY0M2RkNWYxYTk3ZDZjMDViOTAx",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2019-09-30T20:31:47Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "message": "Add basic ffi bindings for Rust header download\n\nAlso, break circular dependency with a new helper lib courtesy of\nCory Fields <cory-nospam-@coryfields.com>.",
      "tree": {
        "sha": "597d14d253ba45f068963a50e300d8a75125fc46",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/597d14d253ba45f068963a50e300d8a75125fc46"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "828a9822a00d0f9f7502ce23bd6276bae30681cf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/828a9822a00d0f9f7502ce23bd6276bae30681cf",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/828a9822a00d0f9f7502ce23bd6276bae30681cf"
      }
    ],
    "stats": {
      "total": 227,
      "additions": 199,
      "deletions": 28
    },
    "files": [
      {
        "sha": "a43da50e7003608bfe08f6462656e8018715fe65",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 15,
        "deletions": 4,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901",
        "patch": "@@ -37,6 +37,7 @@ LIBSECP256K1=secp256k1/libsecp256k1.la\n \n if ENABLE_RUSTY\n LIBBITCOIN_RUSTY = rusty/librusty.a\n+LIBBITCOIN_RUSTY_BRIDGE = libbitcoin_rustybridge.a\n endif\n if ENABLE_ZMQ\n LIBBITCOIN_ZMQ=libbitcoin_zmq.a\n@@ -77,6 +78,7 @@ EXTRA_LIBRARIES += \\\n   $(LIBBITCOIN_CLI) \\\n   $(LIBBITCOIN_WALLET) \\\n   $(LIBBITCOIN_WALLET_TOOL) \\\n+  $(LIBBITCOIN_RUSTY_BRIDGE) \\\n   $(LIBBITCOIN_ZMQ)\n \n lib_LTLIBRARIES = $(LIBBITCOINCONSENSUS)\n@@ -268,6 +270,10 @@ obj/build.h: FORCE\n \t  \"$(abs_top_srcdir)\"\n libbitcoin_util_a-clientversion.$(OBJEXT): obj/build.h\n \n+# libbitcoin_rustybridge should not need headers other than Core's internal ones.\n+libbitcoin_rustybridge_a_CPPFLAGS = $(AM_CPPFLAGS) -I$(builddir) $(LEVELDB_CPPFLAGS)\n+libbitcoin_rustybridge_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n+libbitcoin_rustybridge_a_SOURCES = rusty/src/cpp_bridge.cpp\n # server: shared between bitcoind and bitcoin-qt\n # Contains code accessing mempool and chain state that is meant to be separated\n # from wallet and gui code (see node/README.md). Shared code should go in\n@@ -374,7 +380,11 @@ libbitcoin_wallet_tool_a_SOURCES = \\\n # if any of the other files change. List the main file first, then targets can\n # depend on $(LIBBITCOIN_RUSTY_SRCS), but only build the first source file ($<).\n LIBBITCOIN_RUSTY_SRCS= \\\n-  rusty/src/lib.rs\n+  rusty/src/lib.rs \\\n+  rusty/src/bridge.rs\n+\n+LIBBITCOIN_RUSTY_TEST_SRCS= \\\n+  rusty/src/test_bridge.rs\n \n # We force overflow checks on so that any integer overflows result in a panic\n # instead of, eg, attempting to alloc 4GB of memory (though we will catch such\n@@ -688,10 +698,11 @@ BITCOIN_CORE_H += rusty/src/rust_bridge.h\n \n if ENABLE_RUSTY\n LIBBITCOIN_RUST_LIBS += $(LIBBITCOIN_RUSTY)\n+LIBBITCOIN_RUST_LIBS += $(LIBBITCOIN_RUSTY_BRIDGE)\n \n RUSTY_TEST_BIN=rusty/test_rusty\n-$(RUSTY_TEST_BIN): $(LIBBITCOIN_RUSTY_SRCS)\n-\t$(RUSTC) --crate-name test_rusty $< --emit=link --test $(RUST_FLAGS) low-checks=on --out-dir $(@D)\n+$(RUSTY_TEST_BIN): $(LIBBITCOIN_RUSTY_SRCS) $(LIBBITCOIN_RUSTY_TEST_SRCS)\n+\t$(RUSTC) --crate-name test_rusty $< --emit=link --test $(RUST_FLAGS) -C overflow-checks=on --out-dir $(@D)\n \n ## FIXME: always build RUSTY_TEST_BIN the same as we do test_bitcoin\n RUSTY_CHECK=rusty-check\n@@ -716,7 +727,7 @@ CLEANFILES += wallet/test/*.gcda wallet/test/*.gcno\n CLEANFILES += zmq/*.gcda zmq/*.gcno\n CLEANFILES += obj/build.h\n \n-EXTRA_DIST = $(CTAES_DIST) $(LIBBITCOIN_RUSTY_SRCS)\n+EXTRA_DIST = $(CTAES_DIST) $(LIBBITCOIN_RUSTY_SRCS) $(LIBBITCOIN_RUSTY_TEST_SRCS)\n \n \n config/bitcoin-config.h: config/stamp-h1"
      },
      {
        "sha": "a4a2b39438007153d916a9e6bb4f6d769918a7d1",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901",
        "patch": "@@ -342,10 +342,6 @@ static void OnRPCStopped()\n \n void SetupServerArgs()\n {\n-#if ENABLE_RUSTY\n-    assert(rust_hello_world_example::RUST_CONSTANT == 43);\n-    rust_hello_world_example::hello_world();\n-#endif\n     SetupHelpOptions(gArgs);\n     gArgs.AddArg(\"-help-debug\", \"Print help message with debugging options and exit\", ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST); // server-only for now\n "
      },
      {
        "sha": "ac46d409adb9db82178b33cc369663080eb5994c",
        "filename": "src/rusty/src/bridge.rs",
        "status": "added",
        "additions": 44,
        "deletions": 0,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901/src/rusty/src/bridge.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901/src/rusty/src/bridge.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/bridge.rs?ref=9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901",
        "patch": "@@ -0,0 +1,44 @@\n+use std::ffi::c_void;\n+extern \"C\" {\n+    pub fn rusty_IsInitialBlockDownload() -> bool;\n+    pub fn rusty_ShutdownRequested() -> bool;\n+\n+    /// Connects count headers serialized in a block of memory, each stride bytes from each other.\n+    /// Returns the last header which was connected, if any (or NULL).\n+    fn rusty_ConnectHeaders(headers: *const u8, stride: usize, count: usize) -> *const c_void;\n+\n+    // Utilities to work with CBlockIndex pointers. Wrapped in a safe wrapper below.\n+\n+    /// Gets a CBlockIndex* pointer (casted to a c_void) representing the current tip.\n+    /// Guaranteed to never be NULL (but may be genesis)\n+    fn rusty_GetChainTip() -> *const c_void;\n+\n+    /// Gets the height of a given CBlockIndex* pointer\n+    fn rusty_IndexToHeight(index: *const c_void) -> i32;\n+}\n+\n+/// Connects the given array of (sorted, in chain order) headers (in serialized, 80-byte form).\n+/// Returns the last header which was connected, if any.\n+pub fn connect_headers_flat_bytes(headers: &[u8]) -> Option<BlockIndex> {\n+    if headers.len() % 80 != 0 { return None; }\n+    if headers.is_empty() { return None; }\n+    let index = unsafe { rusty_ConnectHeaders(headers.as_ptr(), 80, headers.len() / 80) };\n+    if index.is_null() { None } else { Some(BlockIndex { index }) }\n+}\n+\n+#[derive(PartialEq, Clone, Copy)]\n+pub struct BlockIndex {\n+    index: *const c_void,\n+}\n+\n+impl BlockIndex {\n+    pub fn tip() -> Self {\n+        Self {\n+            index: unsafe { rusty_GetChainTip() },\n+        }\n+    }\n+\n+    pub fn height(&self) -> i32 {\n+        unsafe { rusty_IndexToHeight(self.index) }\n+    }\n+}"
      },
      {
        "sha": "6d36eeea6342e6b1d28352f04b093fdfb1175838",
        "filename": "src/rusty/src/cpp_bridge.cpp",
        "status": "added",
        "additions": 88,
        "deletions": 0,
        "changes": 88,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901/src/rusty/src/cpp_bridge.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901/src/rusty/src/cpp_bridge.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/cpp_bridge.cpp?ref=9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901",
        "patch": "@@ -0,0 +1,88 @@\n+#include <chainparams.h>\n+#include <validation.h>\n+#include <shutdown.h>\n+#include <serialize.h>\n+#include <consensus/validation.h>\n+\n+/** A class that deserializes a single thing one time. */\n+class InputStream\n+{\n+public:\n+    InputStream(int nTypeIn, int nVersionIn, const unsigned char *data, size_t datalen) :\n+    m_type(nTypeIn),\n+    m_version(nVersionIn),\n+    m_data(data),\n+    m_remaining(datalen)\n+    {}\n+\n+    void read(char* pch, size_t nSize)\n+    {\n+        if (nSize > m_remaining)\n+            throw std::ios_base::failure(std::string(__func__) + \": end of data\");\n+\n+        if (pch == nullptr)\n+            throw std::ios_base::failure(std::string(__func__) + \": bad destination buffer\");\n+\n+        if (m_data == nullptr)\n+            throw std::ios_base::failure(std::string(__func__) + \": bad source buffer\");\n+\n+        memcpy(pch, m_data, nSize);\n+        m_remaining -= nSize;\n+        m_data += nSize;\n+    }\n+\n+    template<typename T>\n+    InputStream& operator>>(T&& obj)\n+    {\n+        ::Unserialize(*this, obj);\n+        return *this;\n+    }\n+\n+    int GetVersion() const { return m_version; }\n+    int GetType() const { return m_type; }\n+private:\n+    const int m_type;\n+    const int m_version;\n+    const unsigned char* m_data;\n+    size_t m_remaining;\n+};\n+\n+extern \"C\" {\n+\n+bool rusty_IsInitialBlockDownload() {\n+    return ::ChainstateActive().IsInitialBlockDownload();\n+}\n+\n+bool rusty_ShutdownRequested() {\n+    return ShutdownRequested();\n+}\n+\n+const void* rusty_ConnectHeaders(const uint8_t* headers_data, size_t stride, size_t count) {\n+    std::vector<CBlockHeader> headers;\n+    for(size_t i = 0; i < count; i++) {\n+        CBlockHeader header;\n+        try {\n+            InputStream(SER_NETWORK, PROTOCOL_VERSION, headers_data + (stride * i), 80) >> header;\n+        } catch (...) {}\n+        headers.push_back(header);\n+    }\n+    BlockValidationState state_dummy;\n+    const CBlockIndex* last_index = nullptr;\n+    ProcessNewBlockHeaders(headers, state_dummy, ::Params(), &last_index);\n+    return last_index;\n+}\n+\n+const void* rusty_GetChainTip() {\n+    LOCK(cs_main);\n+    const CBlockIndex* tip = ::ChainActive().Tip();\n+    assert(tip != nullptr);\n+    return tip;\n+}\n+\n+int32_t rusty_IndexToHeight(const void* pindexvoid) {\n+    const CBlockIndex *pindex = (const CBlockIndex*) pindexvoid;\n+    assert(pindex != nullptr);\n+    return pindex->nHeight;\n+}\n+\n+}"
      },
      {
        "sha": "a43b2b707487282e14baca4c29e10810e97c61f0",
        "filename": "src/rusty/src/lib.rs",
        "status": "modified",
        "additions": 23,
        "deletions": 12,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901/src/rusty/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901/src/rusty/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/lib.rs?ref=9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901",
        "patch": "@@ -1,15 +1,26 @@\n-#[cfg(test)]\n-mod tests {\n-    #[test]\n-    fn it_works() {\n-        assert_eq!(2 + 2, 4);\n-    }\n-}\n+#[cfg(not(test))] mod bridge;\n+#[cfg(test)] pub mod test_bridge;\n+#[cfg(test)] pub use test_bridge as bridge;\n+use bridge::*;\n \n-#[no_mangle]\n-pub static RUST_CONSTANT: i32 = 43;\n+use std::time::{Duration, Instant};\n \n-#[no_mangle]\n-pub extern \"C\" fn hello_world() {\n-    println!(\"Hello World!\");\n+/// Waits for IBD to complete, to get stuck, or shutdown to be initiated. This should be called\n+/// prior to any background block fetchers initiating connections.\n+pub fn await_ibd_complete_or_stalled() {\n+    // Wait until we have finished IBD or aren't making any progress before kicking off\n+    // redundant sync.\n+    let mut last_tip = BlockIndex::tip();\n+    let mut last_tip_change = Instant::now();\n+    while unsafe { !rusty_ShutdownRequested() } {\n+        std::thread::sleep(Duration::from_millis(500));\n+        if unsafe { !rusty_IsInitialBlockDownload() } { break; }\n+        let new_tip = BlockIndex::tip();\n+        if new_tip != last_tip {\n+            last_tip = new_tip;\n+            last_tip_change = Instant::now();\n+        } else if (Instant::now() - last_tip_change) > Duration::from_secs(600) {\n+            break;\n+        }\n+    }\n }"
      },
      {
        "sha": "6c12a35813798ea5d4a480b11c77548f7e9460f0",
        "filename": "src/rusty/src/rust_bridge.h",
        "status": "modified",
        "additions": 5,
        "deletions": 8,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901/src/rusty/src/rust_bridge.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901/src/rusty/src/rust_bridge.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/rust_bridge.h?ref=9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901",
        "patch": "@@ -3,24 +3,21 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#ifndef BITCOIN_RUSTY_H\n-#define BITCOIN_RUSTY_H\n+#ifndef BITCOIN_RUSTY_SRC_RUST_BRIDGE_H\n+#define BITCOIN_RUSTY_SRC_RUST_BRIDGE_H\n \n #include <cstdarg>\n #include <cstdint>\n #include <cstdlib>\n #include <new>\n \n-namespace rust_hello_world_example {\n+namespace rust_block_fetch {\n \n extern \"C\" {\n \n-extern int32_t RUST_CONSTANT;\n-\n-void hello_world();\n \n } // extern \"C\"\n \n-} // namespace rust_hello_world_example\n+} // namespace rust_block_fetch\n \n-#endif // BITCOIN_RUSTY_H\n+#endif // BITCOIN_RUSTY_SRC_RUST_BRIDGE_H"
      },
      {
        "sha": "9553353a18fc294647a0622eb0ae30a5329d872d",
        "filename": "src/rusty/src/test_bridge.rs",
        "status": "added",
        "additions": 24,
        "deletions": 0,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901/src/rusty/src/test_bridge.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901/src/rusty/src/test_bridge.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/test_bridge.rs?ref=9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901",
        "patch": "@@ -0,0 +1,24 @@\n+///! \"bridge\" to C++ code without any backing C++ code. Used for shimming in dummies for testing.\n+\n+#[no_mangle]\n+pub unsafe extern \"C\" fn rusty_IsInitialBlockDownload() -> bool { unimplemented!(); }\n+\n+#[no_mangle]\n+pub unsafe extern \"C\" fn rusty_ShutdownRequested() -> bool { unimplemented!(); }\n+\n+pub fn connect_headers_flat_bytes(_headers: &[u8]) -> Option<BlockIndex> {\n+    unimplemented!();\n+}\n+\n+#[derive(PartialEq, Clone, Copy)]\n+pub struct BlockIndex { }\n+\n+impl BlockIndex {\n+    pub fn tip() -> Self {\n+        unimplemented!();\n+    }\n+\n+    pub fn height(&self) -> i32 {\n+        unimplemented!();\n+    }\n+}"
      }
    ]
  },
  {
    "sha": "f0763b28ea1aa2cbd8055e7ebc454e82ebd1798f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmMDc2M2IyOGVhMWFhMmNiZDgwNTVlN2ViYzQ1NGU4MmViZDE3OThm",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-10-10T21:58:42Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "message": "Add headers-over-DNS fetcher in Rust",
      "tree": {
        "sha": "b4f5cd77a7e270a93ffa08938b4b979f03cdb95d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b4f5cd77a7e270a93ffa08938b4b979f03cdb95d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f0763b28ea1aa2cbd8055e7ebc454e82ebd1798f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f0763b28ea1aa2cbd8055e7ebc454e82ebd1798f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f0763b28ea1aa2cbd8055e7ebc454e82ebd1798f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f0763b28ea1aa2cbd8055e7ebc454e82ebd1798f/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901"
      }
    ],
    "stats": {
      "total": 159,
      "additions": 154,
      "deletions": 5
    },
    "files": [
      {
        "sha": "92c7ee7d90ff318d1614d0a0e165d9e734a08e93",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f0763b28ea1aa2cbd8055e7ebc454e82ebd1798f/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f0763b28ea1aa2cbd8055e7ebc454e82ebd1798f/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=f0763b28ea1aa2cbd8055e7ebc454e82ebd1798f",
        "patch": "@@ -381,7 +381,8 @@ libbitcoin_wallet_tool_a_SOURCES = \\\n # depend on $(LIBBITCOIN_RUSTY_SRCS), but only build the first source file ($<).\n LIBBITCOIN_RUSTY_SRCS= \\\n   rusty/src/lib.rs \\\n-  rusty/src/bridge.rs\n+  rusty/src/bridge.rs \\\n+  rusty/src/dns_headers.rs\n \n LIBBITCOIN_RUSTY_TEST_SRCS= \\\n   rusty/src/test_bridge.rs"
      },
      {
        "sha": "48d3b61aa20b195fdad6dc6949117484bd710f2f",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 4,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f0763b28ea1aa2cbd8055e7ebc454e82ebd1798f/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f0763b28ea1aa2cbd8055e7ebc454e82ebd1798f/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=f0763b28ea1aa2cbd8055e7ebc454e82ebd1798f",
        "patch": "@@ -77,6 +77,10 @@\n #include <zmq/zmqrpc.h>\n #endif\n \n+#if ENABLE_RUSTY\n+#include <rusty/src/rust_bridge.h>\n+#endif\n+\n static bool fFeeEstimatesInitialized = false;\n static const bool DEFAULT_PROXYRANDOMIZE = true;\n static const bool DEFAULT_REST_ENABLE = false;\n@@ -183,6 +187,10 @@ void Shutdown(NodeContext& node)\n     util::ThreadRename(\"shutoff\");\n     mempool.AddTransactionsUpdated(1);\n \n+#if ENABLE_RUSTY\n+    rust_block_fetch::stop_fetch_dns_headers();\n+#endif\n+\n     StopHTTPRPC();\n     StopREST();\n     StopRPC();\n@@ -336,10 +344,6 @@ static void OnRPCStopped()\n     LogPrint(BCLog::RPC, \"RPC stopped.\\n\");\n }\n \n-#if ENABLE_RUSTY\n-#include <rusty/src/rust_bridge.h>\n-#endif\n-\n void SetupServerArgs()\n {\n     SetupHelpOptions(gArgs);\n@@ -401,6 +405,9 @@ void SetupServerArgs()\n                  \" If <type> is not supplied or if <type> = 1, indexes for all known types are enabled.\",\n                  ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n \n+#if ENABLE_RUSTY\n+    gArgs.AddArg(\"-headersfetchdns=<domain>\", \"A domain name from which to fetch headers. eg bitcoinheaders.net\", ArgsManager::ALLOW_ANY | ArgsManager::NETWORK_ONLY, OptionsCategory::CONNECTION);\n+#endif\n     gArgs.AddArg(\"-addnode=<ip>\", \"Add a node to connect to and attempt to keep the connection open (see the `addnode` RPC command help for more info). This option can be specified multiple times to add multiple nodes.\", ArgsManager::ALLOW_ANY | ArgsManager::NETWORK_ONLY, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-banscore=<n>\", strprintf(\"Threshold for disconnecting misbehaving peers (default: %u)\", DEFAULT_BANSCORE_THRESHOLD), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-bantime=<n>\", strprintf(\"Number of seconds to keep misbehaving peers from reconnecting (default: %u)\", DEFAULT_MISBEHAVING_BANTIME), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n@@ -1825,5 +1832,13 @@ bool AppInitMain(NodeContext& node)\n         banman->DumpBanlist();\n     }, DUMP_BANS_INTERVAL * 1000);\n \n+    // ********************************************************* Step 14: kick off backup block downloaders\n+\n+#if ENABLE_RUSTY\n+    for (const std::string& domain : gArgs.GetArgs(\"-headersfetchdns\")) {\n+        rust_block_fetch::init_fetch_dns_headers(domain.c_str());\n+    }\n+#endif\n+\n     return true;\n }"
      },
      {
        "sha": "6e2ac53dd96419f5e0b3452647f82edcc198f4a2",
        "filename": "src/rusty/src/dns_headers.rs",
        "status": "added",
        "additions": 129,
        "deletions": 0,
        "changes": 129,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f0763b28ea1aa2cbd8055e7ebc454e82ebd1798f/src/rusty/src/dns_headers.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f0763b28ea1aa2cbd8055e7ebc454e82ebd1798f/src/rusty/src/dns_headers.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/dns_headers.rs?ref=f0763b28ea1aa2cbd8055e7ebc454e82ebd1798f",
        "patch": "@@ -0,0 +1,129 @@\n+use std::net::{IpAddr, Ipv6Addr, ToSocketAddrs};\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use std::ffi::CStr;\n+use std::os::raw::c_char;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+/// Maps a set of six IPv6 addresses to an 80-byte Bitcoin header.\n+/// The first two bytes of each address are ignored.\n+/// The next 4 bits in each address indicate the ordering of the addresses\n+/// (as DNS resolvers/servers often shuffle the addresses)\n+/// The first 8 bits (ie the second half of the 3rd byte and first half of the 4th)\n+/// of the first address are interpreted as a version and must currently be 0.\n+/// The remaining bits are placed into the 80 byte result in order.\n+fn map_addrs_to_header(ips: &mut [Ipv6Addr]) -> [u8; 80] {\n+    let mut header = [0u8; 80];\n+    if ips.len() != 6 { return header; }\n+    ips.sort_unstable_by(|a, b| {\n+        // Sort based on the first 4 bits in the 3rd byte...\n+        (&(a.octets()[2] & 0xf0)).cmp(&(b.octets()[2] & 0xf0))\n+    });\n+    if ips.len() != 6 { unreachable!(); }\n+    let version = (ips[0].octets()[2] & 0x0f) | (ips[0].octets()[3] & 0xf0);\n+    if version != 0 { return header; }\n+\n+    let mut offs = 0; // in bytes * 2\n+    for (idx, ip) in ips.iter().enumerate() {\n+        for i in if idx == 0 { 3..14*2 } else { 1..14*2 } {\n+            if i % 2 == 1 {\n+                header[offs/2] |= (ip.octets()[i/2 + 2] & 0x0f) >> 0;\n+            } else {\n+                header[offs/2] |= (ip.octets()[i/2 + 2] & 0xf0) >> 4;\n+            }\n+            if offs % 2 == 0 {\n+                header[offs/2] <<= 4;\n+            }\n+            offs += 1;\n+        }\n+    }\n+    header\n+}\n+\n+#[cfg(test)]\n+#[test]\n+fn test_map_addrs() {\n+    use std::str::FromStr;\n+\n+    let mut ips = Vec::new();\n+    // The genesis header:\n+    ips.push(Ipv6Addr::from_str(\"2001:0000:1000:0000:0000:0000:0000:0000\").unwrap());\n+    ips.push(Ipv6Addr::from_str(\"2001:1000:0000:0000:0000:0000:0000:0000\").unwrap());\n+    ips.push(Ipv6Addr::from_str(\"2001:2000:0000:0000:0000:0000:03ba:3edf\").unwrap());\n+    ips.push(Ipv6Addr::from_str(\"2001:3d7a:7b12:b27a:c72c:3e67:768f:617f\").unwrap());\n+    ips.push(Ipv6Addr::from_str(\"2001:4c81:bc38:88a5:1323:a9fb:8aa4:b1e5\").unwrap());\n+    ips.push(Ipv6Addr::from_str(\"2001:5e4a:29ab:5f49:ffff:001d:1dac:2b7c\").unwrap());\n+\n+    assert_eq!(&map_addrs_to_header(&mut ips)[..],\n+        &[0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3b, 0xa3, 0xed, 0xfd, 0x7a, 0x7b, 0x12, 0xb2, 0x7a, 0xc7, 0x2c, 0x3e, 0x67, 0x76, 0x8f, 0x61, 0x7f, 0xc8, 0x1b, 0xc3, 0x88, 0x8a, 0x51, 0x32, 0x3a, 0x9f, 0xb8, 0xaa, 0x4b, 0x1e, 0x5e, 0x4a, 0x29, 0xab, 0x5f, 0x49, 0xff, 0xff, 0x0, 0x1d, 0x1d, 0xac, 0x2b, 0x7c][..]);\n+}\n+\n+static THREAD_COUNT: AtomicUsize = AtomicUsize::new(0);\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_dns_headers(domain: *const c_char) -> bool {\n+    if let Err(_) = catch_unwind(move || {\n+        let domain_str: String = match unsafe { CStr::from_ptr(domain) }.to_str() {\n+            Ok(r) => r.to_string(),\n+            Err(_) => return false,\n+        };\n+        std::thread::spawn(move || {\n+            // Always catch panics so that even if we have some bug in our parser we don't take the\n+            // rest of Bitcoin Core down with us:\n+            THREAD_COUNT.fetch_add(1, Ordering::AcqRel);\n+            let _ = catch_unwind(move || {\n+                await_ibd_complete_or_stalled();\n+                let mut height = BlockIndex::tip().height();\n+                'dns_lookup: while unsafe { !rusty_ShutdownRequested() } {\n+                    let mut ips: Vec<_> = match (format!(\"{}.{}.{}\", height, height / 10000, domain_str).as_str(), 0u16).to_socket_addrs() {\n+                        Ok(ips) => ips,\n+                        Err(_) => {\n+                            std::thread::sleep(Duration::from_secs(5));\n+                            continue 'dns_lookup;\n+                        },\n+                    }.filter_map(|a| match a.ip() {\n+                        IpAddr::V6(a) => Some(a),\n+                        _ => None,\n+                    }).collect();\n+                    if ips.len() != 6 {\n+                        std::thread::sleep(Duration::from_secs(5));\n+                        continue 'dns_lookup;\n+                    }\n+\n+                    if unsafe { !rusty_ShutdownRequested() } {\n+                        match connect_headers_flat_bytes(&map_addrs_to_header(&mut ips)) {\n+                            Some(_) => {\n+                                height += 1;\n+                            },\n+                            None => {\n+                                // We couldn't connect the header, step back and try again\n+                                if height > 0 {\n+                                    height -= 1;\n+                                } else {\n+                                    std::thread::sleep(Duration::from_secs(5));\n+                                }\n+                            },\n+                        }\n+                    }\n+                }\n+            });\n+            THREAD_COUNT.fetch_sub(1, Ordering::AcqRel);\n+        });\n+        true\n+    }) {\n+        false\n+    } else {\n+        true\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn stop_fetch_dns_headers() {\n+    while THREAD_COUNT.load(Ordering::Acquire) != 0 {\n+        std::thread::sleep(Duration::from_millis(10));\n+    }\n+}"
      },
      {
        "sha": "535fecfa479b4e3c190ae3e3ed273fd95e0138af",
        "filename": "src/rusty/src/lib.rs",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f0763b28ea1aa2cbd8055e7ebc454e82ebd1798f/src/rusty/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f0763b28ea1aa2cbd8055e7ebc454e82ebd1798f/src/rusty/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/lib.rs?ref=f0763b28ea1aa2cbd8055e7ebc454e82ebd1798f",
        "patch": "@@ -3,6 +3,8 @@\n #[cfg(test)] pub use test_bridge as bridge;\n use bridge::*;\n \n+mod dns_headers;\n+\n use std::time::{Duration, Instant};\n \n /// Waits for IBD to complete, to get stuck, or shutdown to be initiated. This should be called"
      },
      {
        "sha": "f4548ae59083e61f6294640e7f66e78c2ff2886d",
        "filename": "src/rusty/src/rust_bridge.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f0763b28ea1aa2cbd8055e7ebc454e82ebd1798f/src/rusty/src/rust_bridge.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f0763b28ea1aa2cbd8055e7ebc454e82ebd1798f/src/rusty/src/rust_bridge.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/rust_bridge.h?ref=f0763b28ea1aa2cbd8055e7ebc454e82ebd1798f",
        "patch": "@@ -15,6 +15,8 @@ namespace rust_block_fetch {\n \n extern \"C\" {\n \n+bool init_fetch_dns_headers(const char *domain);\n+bool stop_fetch_dns_headers();\n \n } // extern \"C\"\n "
      }
    ]
  },
  {
    "sha": "eb21b69810c6c70ce7d16c5c0fc19bf12927dc6e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplYjIxYjY5ODEwYzZjNzBjZTdkMTZjNWMwZmMxOWJmMTI5MjdkYzZl",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-10-06T16:16:14Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "message": "Limit total memory allocated by all Rust code to 128MB",
      "tree": {
        "sha": "ef285217f45acd5e6c7732e34ed53f5f8f2ea4d2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ef285217f45acd5e6c7732e34ed53f5f8f2ea4d2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/eb21b69810c6c70ce7d16c5c0fc19bf12927dc6e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eb21b69810c6c70ce7d16c5c0fc19bf12927dc6e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/eb21b69810c6c70ce7d16c5c0fc19bf12927dc6e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eb21b69810c6c70ce7d16c5c0fc19bf12927dc6e/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f0763b28ea1aa2cbd8055e7ebc454e82ebd1798f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f0763b28ea1aa2cbd8055e7ebc454e82ebd1798f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f0763b28ea1aa2cbd8055e7ebc454e82ebd1798f"
      }
    ],
    "stats": {
      "total": 39,
      "additions": 39,
      "deletions": 0
    },
    "files": [
      {
        "sha": "097a39c0b54f5a25a20069fa083b80baad03fbad",
        "filename": "src/rusty/src/lib.rs",
        "status": "modified",
        "additions": 39,
        "deletions": 0,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eb21b69810c6c70ce7d16c5c0fc19bf12927dc6e/src/rusty/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eb21b69810c6c70ce7d16c5c0fc19bf12927dc6e/src/rusty/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/lib.rs?ref=eb21b69810c6c70ce7d16c5c0fc19bf12927dc6e",
        "patch": "@@ -5,8 +5,47 @@ use bridge::*;\n \n mod dns_headers;\n \n+use std::alloc::{GlobalAlloc, Layout, System};\n+use std::ptr;\n+use std::sync::atomic::{AtomicUsize, Ordering};\n use std::time::{Duration, Instant};\n \n+// We keep track of all memory allocated by Rust code, refusing new allocations if it exceeds\n+// 128MB.\n+//\n+// Note that while Rust's std, in general, should panic in response to a null allocation, it\n+// is totally conceivable that some code will instead dereference this null pointer, which\n+// would violate our guarantees that Rust modules should never crash the entire application.\n+//\n+// In the future, as upstream Rust explores a safer allocation API (eg the Alloc API which\n+// returns Results instead of raw pointers, or redefining the GlobalAlloc API to allow\n+// panic!()s inside of alloc calls), we should switch to those, however these APIs are\n+// currently unstable.\n+const TOTAL_MEM_LIMIT_BYTES: usize = 128 * 1024 * 1024;\n+static TOTAL_MEM_ALLOCD: AtomicUsize = AtomicUsize::new(0);\n+struct MemoryLimitingAllocator;\n+unsafe impl GlobalAlloc for MemoryLimitingAllocator {\n+    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+        let len = layout.size();\n+        if len > TOTAL_MEM_LIMIT_BYTES {\n+            return ptr::null_mut();\n+        }\n+        if TOTAL_MEM_ALLOCD.fetch_add(len, Ordering::AcqRel) + len > TOTAL_MEM_LIMIT_BYTES {\n+            TOTAL_MEM_ALLOCD.fetch_sub(len, Ordering::AcqRel);\n+            return ptr::null_mut();\n+        }\n+        System.alloc(layout)\n+    }\n+\n+    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n+        System.dealloc(ptr, layout);\n+        TOTAL_MEM_ALLOCD.fetch_sub(layout.size(), Ordering::AcqRel);\n+    }\n+}\n+\n+#[global_allocator]\n+static ALLOC: MemoryLimitingAllocator = MemoryLimitingAllocator;\n+\n /// Waits for IBD to complete, to get stuck, or shutdown to be initiated. This should be called\n /// prior to any background block fetchers initiating connections.\n pub fn await_ibd_complete_or_stalled() {"
      }
    ]
  },
  {
    "sha": "94051addd99c933338d40a488cf8e810d9cfdd34",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NDA1MWFkZGQ5OWM5MzMzMzhkNDBhNDg4Y2Y4ZTgxMGQ5Y2ZkZDM0",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-10-10T22:28:27Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "message": "Enable rustc building + testing on xenial Tsan Travis job",
      "tree": {
        "sha": "1fb764403fdeb8e4d18f1fa141741562ae495674",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1fb764403fdeb8e4d18f1fa141741562ae495674"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/94051addd99c933338d40a488cf8e810d9cfdd34",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/94051addd99c933338d40a488cf8e810d9cfdd34",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/94051addd99c933338d40a488cf8e810d9cfdd34",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/94051addd99c933338d40a488cf8e810d9cfdd34/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "eb21b69810c6c70ce7d16c5c0fc19bf12927dc6e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eb21b69810c6c70ce7d16c5c0fc19bf12927dc6e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/eb21b69810c6c70ce7d16c5c0fc19bf12927dc6e"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 3,
      "deletions": 3
    },
    "files": [
      {
        "sha": "f0db29fda9bb92a1a9e06414ae5740f6f31f5971",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/94051addd99c933338d40a488cf8e810d9cfdd34/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/94051addd99c933338d40a488cf8e810d9cfdd34/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=94051addd99c933338d40a488cf8e810d9cfdd34",
        "patch": "@@ -115,7 +115,7 @@ jobs:\n         FILE_ENV=\"./ci/test/00_setup_env_native_trusty.sh\"\n \n     - stage: test\n-      name: 'x86_64 Linux  [GOAL: install]  [xenial]  [no depends, only system libs, sanitizers: thread (TSan), no wallet]'\n+      name: 'x86_64 Linux  [GOAL: install]  [xenial]  [no depends, only system libs, rust, sanitizers: thread (TSan), no wallet]'\n       env: >-\n         FILE_ENV=\"./ci/test/00_setup_env_native_tsan.sh\"\n         TEST_RUNNER_EXTRA=\"--exclude feature_block\"  # Not enough memory on travis machines"
      },
      {
        "sha": "2d3c91f13030720a6665d1a6af82bf645636a52f",
        "filename": "ci/test/00_setup_env_native_tsan.sh",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/94051addd99c933338d40a488cf8e810d9cfdd34/ci/test/00_setup_env_native_tsan.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/94051addd99c933338d40a488cf8e810d9cfdd34/ci/test/00_setup_env_native_tsan.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/00_setup_env_native_tsan.sh?ref=94051addd99c933338d40a488cf8e810d9cfdd34",
        "patch": "@@ -7,10 +7,10 @@\n export LC_ALL=C.UTF-8\n \n export DOCKER_NAME_TAG=ubuntu:16.04\n-export PACKAGES=\"clang llvm python3-zmq qtbase5-dev qttools5-dev-tools libevent-dev bsdmainutils libboost-system-dev libboost-filesystem-dev libboost-chrono-dev libboost-test-dev libboost-thread-dev libdb5.3++-dev libminiupnpc-dev libzmq3-dev libqrencode-dev\"\n+export PACKAGES=\"clang llvm python3-zmq qtbase5-dev qttools5-dev-tools libevent-dev bsdmainutils libboost-system-dev libboost-filesystem-dev libboost-chrono-dev libboost-test-dev libboost-thread-dev libdb5.3++-dev libminiupnpc-dev libzmq3-dev libqrencode-dev rustc\"\n export NO_DEPENDS=1\n export GOAL=\"install\"\n-export BITCOIN_CONFIG=\"--enable-zmq --disable-wallet --with-gui=qt5 CPPFLAGS='-DARENA_DEBUG -DDEBUG_LOCKORDER' --with-sanitizers=thread --disable-hardening --disable-asm CC=clang CXX=clang++\"\n+export BITCOIN_CONFIG=\"--enable-zmq --disable-wallet --with-gui=qt5 CPPFLAGS='-DARENA_DEBUG -DDEBUG_LOCKORDER' --with-sanitizers=thread --disable-hardening --disable-asm --enable-rust CC=clang CXX=clang++\"\n \n # xenial comes with old clang versions that can not parse the sanitizer suppressions files\n # Remove unparseable lines as a hacky workaround"
      }
    ]
  },
  {
    "sha": "ccbd928cf51f2ebfe0fd7827d0e632c22fcfd419",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjY2JkOTI4Y2Y1MWYyZWJmZTBmZDc4MjdkMGU2MzJjMjJmY2ZkNDE5",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-08-21T20:25:04Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "message": "Move CNode's FindNextBlocksToDownload state into its own strut\n\nThis starts the process of moving the last bits of\nvalidation-critical logic out of net_processing - the fallback\nlogic of which blocks to download is incredibly critical to\nvalidation and would likely also be used for any parallel block\nsync systems. Further, assumeutxo will require additional ability\nto select blocks for download, which is a validation-specific\nconcept and shouldn't really live in net_processing.\n\nThis moves a few responsibilities to the FindNextBlocksToDownload\ncallsite instead of passing in a CNodeId, but otherwise has no\nfunctional changes.",
      "tree": {
        "sha": "25146882ed9d538226686038415b6a018f5d5f40",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/25146882ed9d538226686038415b6a018f5d5f40"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ccbd928cf51f2ebfe0fd7827d0e632c22fcfd419",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ccbd928cf51f2ebfe0fd7827d0e632c22fcfd419",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ccbd928cf51f2ebfe0fd7827d0e632c22fcfd419",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ccbd928cf51f2ebfe0fd7827d0e632c22fcfd419/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "94051addd99c933338d40a488cf8e810d9cfdd34",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/94051addd99c933338d40a488cf8e810d9cfdd34",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/94051addd99c933338d40a488cf8e810d9cfdd34"
      }
    ],
    "stats": {
      "total": 96,
      "additions": 54,
      "deletions": 42
    },
    "files": [
      {
        "sha": "eea771424a5271af1c90c6da5577e9b0de7058f1",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 54,
        "deletions": 42,
        "changes": 96,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ccbd928cf51f2ebfe0fd7827d0e632c22fcfd419/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ccbd928cf51f2ebfe0fd7827d0e632c22fcfd419/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=ccbd928cf51f2ebfe0fd7827d0e632c22fcfd419",
        "patch": "@@ -194,6 +194,23 @@ namespace {\n } // namespace\n \n namespace {\n+/**\n+ * Information about a peer's available blocks, for the purpose of figuring out\n+ * what block(s) we may want to download from them.\n+ */\n+struct BlockProviderState {\n+    //! The best known block we know this peer has announced.\n+    const CBlockIndex *m_best_known_block;\n+    //! The last full block we both have.\n+    const CBlockIndex *m_last_common_block;\n+\n+    BlockProviderState() : m_best_known_block(nullptr), m_last_common_block(nullptr) {}\n+\n+    int GetLastCommonHeight() const {\n+        return m_last_common_block ? m_last_common_block->nHeight : -1;\n+    }\n+};\n+\n /**\n  * Maintain validation-specific state about nodes, protected by cs_main, instead\n  * by CNode's own locks. This simplifies asynchronous operation, where\n@@ -211,12 +228,11 @@ struct CNodeState {\n     bool fShouldBan;\n     //! String name of this peer (debugging/logging purposes).\n     const std::string name;\n-    //! The best known block we know this peer has announced.\n-    const CBlockIndex *pindexBestKnownBlock;\n     //! The hash of the last unknown block this peer has announced.\n     uint256 hashLastUnknownBlock;\n-    //! The last full block we both have.\n-    const CBlockIndex *pindexLastCommonBlock;\n+    //! The CBlockIndex*s representing which blocks this peer has available for\n+    //! us to download.\n+    BlockProviderState m_blocks_avail;\n     //! The best header we have sent our peer.\n     const CBlockIndex *pindexBestHeaderSent;\n     //! Length of current-streak of unconnecting headers announcements\n@@ -360,9 +376,7 @@ struct CNodeState {\n         fCurrentlyConnected = false;\n         nMisbehavior = 0;\n         fShouldBan = false;\n-        pindexBestKnownBlock = nullptr;\n         hashLastUnknownBlock.SetNull();\n-        pindexLastCommonBlock = nullptr;\n         pindexBestHeaderSent = nullptr;\n         nUnconnectingHeaders = 0;\n         fSyncStarted = false;\n@@ -498,8 +512,8 @@ static void ProcessBlockAvailability(NodeId nodeid) EXCLUSIVE_LOCKS_REQUIRED(cs_\n     if (!state->hashLastUnknownBlock.IsNull()) {\n         const CBlockIndex* pindex = LookupBlockIndex(state->hashLastUnknownBlock);\n         if (pindex && pindex->nChainWork > 0) {\n-            if (state->pindexBestKnownBlock == nullptr || pindex->nChainWork >= state->pindexBestKnownBlock->nChainWork) {\n-                state->pindexBestKnownBlock = pindex;\n+            if (state->m_blocks_avail.m_best_known_block == nullptr || pindex->nChainWork >= state->m_blocks_avail.m_best_known_block->nChainWork) {\n+                state->m_blocks_avail.m_best_known_block = pindex;\n             }\n             state->hashLastUnknownBlock.SetNull();\n         }\n@@ -516,8 +530,8 @@ static void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) EXCLUSIV\n     const CBlockIndex* pindex = LookupBlockIndex(hash);\n     if (pindex && pindex->nChainWork > 0) {\n         // An actually better block was announced.\n-        if (state->pindexBestKnownBlock == nullptr || pindex->nChainWork >= state->pindexBestKnownBlock->nChainWork) {\n-            state->pindexBestKnownBlock = pindex;\n+        if (state->m_blocks_avail.m_best_known_block == nullptr || pindex->nChainWork >= state->m_blocks_avail.m_best_known_block->nChainWork) {\n+            state->m_blocks_avail.m_best_known_block = pindex;\n         }\n     } else {\n         // An unknown block was announced; just assume that the latest one is the best one.\n@@ -583,7 +597,7 @@ static bool CanDirectFetch(const Consensus::Params &consensusParams) EXCLUSIVE_L\n \n static bool PeerHasHeader(CNodeState *state, const CBlockIndex *pindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    if (state->pindexBestKnownBlock && pindex == state->pindexBestKnownBlock->GetAncestor(pindex->nHeight))\n+    if (state->m_blocks_avail.m_best_known_block && pindex == state->m_blocks_avail.m_best_known_block->GetAncestor(pindex->nHeight))\n         return true;\n     if (state->pindexBestHeaderSent && pindex == state->pindexBestHeaderSent->GetAncestor(pindex->nHeight))\n         return true;\n@@ -592,50 +606,45 @@ static bool PeerHasHeader(CNodeState *state, const CBlockIndex *pindex) EXCLUSIV\n \n /** Update pindexLastCommonBlock and add not-in-flight missing successors to vBlocks, until it has\n  *  at most count entries. */\n-static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, NodeId& nodeStaller, const Consensus::Params& consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+static void FindNextBlocksToDownload(BlockProviderState& state, bool provider_has_witness, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, NodeId& nodeStaller, const Consensus::Params& consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     if (count == 0)\n         return;\n \n     vBlocks.reserve(vBlocks.size() + count);\n-    CNodeState *state = State(nodeid);\n-    assert(state != nullptr);\n-\n-    // Make sure pindexBestKnownBlock is up to date, we'll need it.\n-    ProcessBlockAvailability(nodeid);\n \n-    if (state->pindexBestKnownBlock == nullptr || state->pindexBestKnownBlock->nChainWork < ::ChainActive().Tip()->nChainWork || state->pindexBestKnownBlock->nChainWork < nMinimumChainWork) {\n+    if (state.m_best_known_block == nullptr || state.m_best_known_block->nChainWork < ::ChainActive().Tip()->nChainWork || state.m_best_known_block->nChainWork < nMinimumChainWork) {\n         // This peer has nothing interesting.\n         return;\n     }\n \n-    if (state->pindexLastCommonBlock == nullptr) {\n+    if (state.m_last_common_block == nullptr) {\n         // Bootstrap quickly by guessing a parent of our best tip is the forking point.\n         // Guessing wrong in either direction is not a problem.\n-        state->pindexLastCommonBlock = ::ChainActive()[std::min(state->pindexBestKnownBlock->nHeight, ::ChainActive().Height())];\n+        state.m_last_common_block = ::ChainActive()[std::min(state.m_best_known_block->nHeight, ::ChainActive().Height())];\n     }\n \n     // If the peer reorganized, our previous pindexLastCommonBlock may not be an ancestor\n     // of its current tip anymore. Go back enough to fix that.\n-    state->pindexLastCommonBlock = LastCommonAncestor(state->pindexLastCommonBlock, state->pindexBestKnownBlock);\n-    if (state->pindexLastCommonBlock == state->pindexBestKnownBlock)\n+    state.m_last_common_block = LastCommonAncestor(state.m_last_common_block, state.m_best_known_block);\n+    if (state.m_last_common_block == state.m_best_known_block)\n         return;\n \n     std::vector<const CBlockIndex*> vToFetch;\n-    const CBlockIndex *pindexWalk = state->pindexLastCommonBlock;\n+    const CBlockIndex *pindexWalk = state.m_last_common_block;\n     // Never fetch further than the best block we know the peer has, or more than BLOCK_DOWNLOAD_WINDOW + 1 beyond the last\n     // linked block we have in common with this peer. The +1 is so we can detect stalling, namely if we would be able to\n     // download that next block if the window were 1 larger.\n-    int nWindowEnd = state->pindexLastCommonBlock->nHeight + BLOCK_DOWNLOAD_WINDOW;\n-    int nMaxHeight = std::min<int>(state->pindexBestKnownBlock->nHeight, nWindowEnd + 1);\n+    int nWindowEnd = state.m_last_common_block->nHeight + BLOCK_DOWNLOAD_WINDOW;\n+    int nMaxHeight = std::min<int>(state.m_best_known_block->nHeight, nWindowEnd + 1);\n     NodeId waitingfor = -1;\n     while (pindexWalk->nHeight < nMaxHeight) {\n         // Read up to 128 (or more, if more blocks than that are needed) successors of pindexWalk (towards\n         // pindexBestKnownBlock) into vToFetch. We fetch 128, because CBlockIndex::GetAncestor may be as expensive\n         // as iterating over ~100 CBlockIndex* entries anyway.\n         int nToFetch = std::min(nMaxHeight - pindexWalk->nHeight, std::max<int>(count - vBlocks.size(), 128));\n         vToFetch.resize(nToFetch);\n-        pindexWalk = state->pindexBestKnownBlock->GetAncestor(pindexWalk->nHeight + nToFetch);\n+        pindexWalk = state.m_best_known_block->GetAncestor(pindexWalk->nHeight + nToFetch);\n         vToFetch[nToFetch - 1] = pindexWalk;\n         for (unsigned int i = nToFetch - 1; i > 0; i--) {\n             vToFetch[i - 1] = vToFetch[i]->pprev;\n@@ -650,18 +659,18 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n                 // We consider the chain that this peer is on invalid.\n                 return;\n             }\n-            if (!State(nodeid)->fHaveWitness && IsWitnessEnabled(pindex->pprev, consensusParams)) {\n+            if (!provider_has_witness && IsWitnessEnabled(pindex->pprev, consensusParams)) {\n                 // We wouldn't download this block or its descendants from this peer.\n                 return;\n             }\n             if (pindex->nStatus & BLOCK_HAVE_DATA || ::ChainActive().Contains(pindex)) {\n                 if (pindex->HaveTxsDownloaded())\n-                    state->pindexLastCommonBlock = pindex;\n+                    state.m_last_common_block = pindex;\n             } else if (mapBlocksInFlight.count(pindex->GetBlockHash()) == 0) {\n                 // The block is not already downloaded, and not yet in flight.\n                 if (pindex->nHeight > nWindowEnd) {\n                     // We reached the end of the window.\n-                    if (vBlocks.size() == 0 && waitingfor != nodeid) {\n+                    if (vBlocks.size() == 0) {\n                         // We aren't able to fetch anything, but we would be if the download window was one larger.\n                         nodeStaller = waitingfor;\n                     }\n@@ -812,8 +821,8 @@ bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats) {\n     if (state == nullptr)\n         return false;\n     stats.nMisbehavior = state->nMisbehavior;\n-    stats.nSyncHeight = state->pindexBestKnownBlock ? state->pindexBestKnownBlock->nHeight : -1;\n-    stats.nCommonHeight = state->pindexLastCommonBlock ? state->pindexLastCommonBlock->nHeight : -1;\n+    stats.nSyncHeight = state->m_blocks_avail.m_best_known_block ? state->m_blocks_avail.m_best_known_block->nHeight : -1;\n+    stats.nCommonHeight = state->m_blocks_avail.GetLastCommonHeight();\n     for (const QueuedBlock& queue : state->vBlocksInFlight) {\n         if (queue.pindex)\n             stats.vHeightInFlight.push_back(queue.pindex->nHeight);\n@@ -1788,7 +1797,7 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n         if (::ChainstateActive().IsInitialBlockDownload() && nCount != MAX_HEADERS_RESULTS) {\n             // When nCount < MAX_HEADERS_RESULTS, we know we have no more\n             // headers to fetch from this peer.\n-            if (nodestate->pindexBestKnownBlock && nodestate->pindexBestKnownBlock->nChainWork < nMinimumChainWork) {\n+            if (nodestate->m_blocks_avail.m_best_known_block && nodestate->m_blocks_avail.m_best_known_block->nChainWork < nMinimumChainWork) {\n                 // This peer has too little work on their headers chain to help\n                 // us sync -- disconnect if using an outbound slot (unless\n                 // whitelisted or addnode).\n@@ -1804,12 +1813,12 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n             }\n         }\n \n-        if (!pfrom->fDisconnect && IsOutboundDisconnectionCandidate(pfrom) && nodestate->pindexBestKnownBlock != nullptr && pfrom->m_tx_relay != nullptr) {\n+        if (!pfrom->fDisconnect && IsOutboundDisconnectionCandidate(pfrom) && nodestate->m_blocks_avail.m_best_known_block != nullptr && pfrom->m_tx_relay != nullptr) {\n             // If this is an outbound full-relay peer, check to see if we should protect\n             // it from the bad/lagging chain logic.\n             // Note that block-relay-only peers are already implicitly protected, so we\n             // only consider setting m_protect for the full-relay peers.\n-            if (g_outbound_peers_with_protect_from_disconnect < MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT && nodestate->pindexBestKnownBlock->nChainWork >= ::ChainActive().Tip()->nChainWork && !nodestate->m_chain_sync.m_protect) {\n+            if (g_outbound_peers_with_protect_from_disconnect < MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT && nodestate->m_blocks_avail.m_best_known_block->nChainWork >= ::ChainActive().Tip()->nChainWork && !nodestate->m_chain_sync.m_protect) {\n                 LogPrint(BCLog::NET, \"Protecting outbound peer=%d from eviction\\n\", pfrom->GetId());\n                 nodestate->m_chain_sync.m_protect = true;\n                 ++g_outbound_peers_with_protect_from_disconnect;\n@@ -3385,13 +3394,13 @@ void PeerLogicValidation::ConsiderEviction(CNode *pto, int64_t time_in_seconds)\n         // their chain has more work than ours, we should sync to it,\n         // unless it's invalid, in which case we should find that out and\n         // disconnect from them elsewhere).\n-        if (state.pindexBestKnownBlock != nullptr && state.pindexBestKnownBlock->nChainWork >= ::ChainActive().Tip()->nChainWork) {\n+        if (state.m_blocks_avail.m_best_known_block != nullptr && state.m_blocks_avail.m_best_known_block->nChainWork >= ::ChainActive().Tip()->nChainWork) {\n             if (state.m_chain_sync.m_timeout != 0) {\n                 state.m_chain_sync.m_timeout = 0;\n                 state.m_chain_sync.m_work_header = nullptr;\n                 state.m_chain_sync.m_sent_getheaders = false;\n             }\n-        } else if (state.m_chain_sync.m_timeout == 0 || (state.m_chain_sync.m_work_header != nullptr && state.pindexBestKnownBlock != nullptr && state.pindexBestKnownBlock->nChainWork >= state.m_chain_sync.m_work_header->nChainWork)) {\n+        } else if (state.m_chain_sync.m_timeout == 0 || (state.m_chain_sync.m_work_header != nullptr && state.m_blocks_avail.m_best_known_block != nullptr && state.m_blocks_avail.m_best_known_block->nChainWork >= state.m_chain_sync.m_work_header->nChainWork)) {\n             // Our best block known by this peer is behind our tip, and we're either noticing\n             // that for the first time, OR this peer was able to catch up to some earlier point\n             // where we checked against our tip.\n@@ -3405,18 +3414,18 @@ void PeerLogicValidation::ConsiderEviction(CNode *pto, int64_t time_in_seconds)\n             // message to give the peer a chance to update us.\n             if (state.m_chain_sync.m_sent_getheaders) {\n                 // They've run out of time to catch up!\n-                LogPrintf(\"Disconnecting outbound peer %d for old chain, best known block = %s\\n\", pto->GetId(), state.pindexBestKnownBlock != nullptr ? state.pindexBestKnownBlock->GetBlockHash().ToString() : \"<none>\");\n+                LogPrintf(\"Disconnecting outbound peer %d for old chain, best known block = %s\\n\", pto->GetId(), state.m_blocks_avail.m_best_known_block != nullptr ? state.m_blocks_avail.m_best_known_block->GetBlockHash().ToString() : \"<none>\");\n                 pto->fDisconnect = true;\n             } else {\n                 assert(state.m_chain_sync.m_work_header);\n-                LogPrint(BCLog::NET, \"sending getheaders to outbound peer=%d to verify chain work (current best known block:%s, benchmark blockhash: %s)\\n\", pto->GetId(), state.pindexBestKnownBlock != nullptr ? state.pindexBestKnownBlock->GetBlockHash().ToString() : \"<none>\", state.m_chain_sync.m_work_header->GetBlockHash().ToString());\n+                LogPrint(BCLog::NET, \"sending getheaders to outbound peer=%d to verify chain work (current best known block:%s, benchmark blockhash: %s)\\n\", pto->GetId(), state.m_blocks_avail.m_best_known_block != nullptr ? state.m_blocks_avail.m_best_known_block->GetBlockHash().ToString() : \"<none>\", state.m_chain_sync.m_work_header->GetBlockHash().ToString());\n                 connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(state.m_chain_sync.m_work_header->pprev), uint256()));\n                 state.m_chain_sync.m_sent_getheaders = true;\n                 constexpr int64_t HEADERS_RESPONSE_TIME = 120; // 2 minutes\n                 // Bump the timeout to allow a response, which could clear the timeout\n                 // (if the response shows the peer has synced), reset the timeout (if\n                 // the peer syncs to the required work but not to our tip), or result\n-                // in disconnect (if we advance to the timeout and pindexBestKnownBlock\n+                // in disconnect (if we advance to the timeout and m_blocks_avail.m_best_known_block\n                 // has not sufficiently progressed)\n                 state.m_chain_sync.m_timeout = time_in_seconds + HEADERS_RESPONSE_TIME;\n             }\n@@ -3654,7 +3663,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                                  (!state.fPreferHeaderAndIDs || pto->vBlockHashesToAnnounce.size() > 1)) ||\n                                 pto->vBlockHashesToAnnounce.size() > MAX_BLOCKS_TO_ANNOUNCE);\n             const CBlockIndex *pBestIndex = nullptr; // last header queued for delivery\n-            ProcessBlockAvailability(pto->GetId()); // ensure pindexBestKnownBlock is up-to-date\n+            ProcessBlockAvailability(pto->GetId()); // ensure m_blocks_avail.m_best_known_block is up-to-date\n \n             if (!fRevertToInv) {\n                 bool fFoundStartingHeader = false;\n@@ -3987,17 +3996,20 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n         //\n         std::vector<CInv> vGetData;\n         if (!pto->fClient && ((fFetch && !pto->m_limited_node) || !::ChainstateActive().IsInitialBlockDownload()) && state.nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n+            // Make sure pindexBestKnownBlock is up to date, we'll need it.\n+            ProcessBlockAvailability(pto->GetId());\n+\n             std::vector<const CBlockIndex*> vToDownload;\n             NodeId staller = -1;\n-            FindNextBlocksToDownload(pto->GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller, consensusParams);\n+            FindNextBlocksToDownload(state.m_blocks_avail, state.fHaveWitness, MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller, consensusParams);\n             for (const CBlockIndex *pindex : vToDownload) {\n                 uint32_t nFetchFlags = GetFetchFlags(pto);\n                 vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n                 MarkBlockAsInFlight(pto->GetId(), pindex->GetBlockHash(), pindex);\n                 LogPrint(BCLog::NET, \"Requesting block %s (%d) peer=%d\\n\", pindex->GetBlockHash().ToString(),\n                     pindex->nHeight, pto->GetId());\n             }\n-            if (state.nBlocksInFlight == 0 && staller != -1) {\n+            if (state.nBlocksInFlight == 0 && staller != -1 && staller != pto->GetId()) {\n                 if (State(staller)->nStallingSince == 0) {\n                     State(staller)->nStallingSince = nNow;\n                     LogPrint(BCLog::NET, \"Stall started peer=%d\\n\", staller);"
      }
    ]
  },
  {
    "sha": "0696ab1bab28b1c9c2f0cccca27590fd53d96865",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowNjk2YWIxYmFiMjhiMWM5YzJmMGNjY2NhMjc1OTBmZDUzZDk2ODY1",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-08-23T21:28:57Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "message": "Make FindNextBlocksToDownload a member func on BlockProviderState",
      "tree": {
        "sha": "82bc403b88b0f892e7337397fce5a9aae921d27b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/82bc403b88b0f892e7337397fce5a9aae921d27b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0696ab1bab28b1c9c2f0cccca27590fd53d96865",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0696ab1bab28b1c9c2f0cccca27590fd53d96865",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0696ab1bab28b1c9c2f0cccca27590fd53d96865",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0696ab1bab28b1c9c2f0cccca27590fd53d96865/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ccbd928cf51f2ebfe0fd7827d0e632c22fcfd419",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ccbd928cf51f2ebfe0fd7827d0e632c22fcfd419",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ccbd928cf51f2ebfe0fd7827d0e632c22fcfd419"
      }
    ],
    "stats": {
      "total": 34,
      "additions": 19,
      "deletions": 15
    },
    "files": [
      {
        "sha": "141708e2bcb9b063f9b7b74f21067415fc23c589",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 15,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0696ab1bab28b1c9c2f0cccca27590fd53d96865/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0696ab1bab28b1c9c2f0cccca27590fd53d96865/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=0696ab1bab28b1c9c2f0cccca27590fd53d96865",
        "patch": "@@ -199,16 +199,20 @@ namespace {\n  * what block(s) we may want to download from them.\n  */\n struct BlockProviderState {\n-    //! The best known block we know this peer has announced.\n-    const CBlockIndex *m_best_known_block;\n+private:\n     //! The last full block we both have.\n     const CBlockIndex *m_last_common_block;\n+public:\n+    //! The best known block we know this peer has announced.\n+    const CBlockIndex *m_best_known_block;\n \n-    BlockProviderState() : m_best_known_block(nullptr), m_last_common_block(nullptr) {}\n+    BlockProviderState() : m_last_common_block(nullptr), m_best_known_block(nullptr) {}\n \n     int GetLastCommonHeight() const {\n         return m_last_common_block ? m_last_common_block->nHeight : -1;\n     }\n+\n+    void FindNextBlocksToDownload(bool provider_has_witness, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, NodeId& nodeStaller, const Consensus::Params& consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n };\n \n /**\n@@ -606,45 +610,45 @@ static bool PeerHasHeader(CNodeState *state, const CBlockIndex *pindex) EXCLUSIV\n \n /** Update pindexLastCommonBlock and add not-in-flight missing successors to vBlocks, until it has\n  *  at most count entries. */\n-static void FindNextBlocksToDownload(BlockProviderState& state, bool provider_has_witness, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, NodeId& nodeStaller, const Consensus::Params& consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void BlockProviderState::FindNextBlocksToDownload(bool provider_has_witness, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, NodeId& nodeStaller, const Consensus::Params& consensusParams)\n {\n     if (count == 0)\n         return;\n \n     vBlocks.reserve(vBlocks.size() + count);\n \n-    if (state.m_best_known_block == nullptr || state.m_best_known_block->nChainWork < ::ChainActive().Tip()->nChainWork || state.m_best_known_block->nChainWork < nMinimumChainWork) {\n+    if (m_best_known_block == nullptr || m_best_known_block->nChainWork < ::ChainActive().Tip()->nChainWork || m_best_known_block->nChainWork < nMinimumChainWork) {\n         // This peer has nothing interesting.\n         return;\n     }\n \n-    if (state.m_last_common_block == nullptr) {\n+    if (m_last_common_block == nullptr) {\n         // Bootstrap quickly by guessing a parent of our best tip is the forking point.\n         // Guessing wrong in either direction is not a problem.\n-        state.m_last_common_block = ::ChainActive()[std::min(state.m_best_known_block->nHeight, ::ChainActive().Height())];\n+        m_last_common_block = ::ChainActive()[std::min(m_best_known_block->nHeight, ::ChainActive().Height())];\n     }\n \n     // If the peer reorganized, our previous pindexLastCommonBlock may not be an ancestor\n     // of its current tip anymore. Go back enough to fix that.\n-    state.m_last_common_block = LastCommonAncestor(state.m_last_common_block, state.m_best_known_block);\n-    if (state.m_last_common_block == state.m_best_known_block)\n+    m_last_common_block = LastCommonAncestor(m_last_common_block, m_best_known_block);\n+    if (m_last_common_block == m_best_known_block)\n         return;\n \n     std::vector<const CBlockIndex*> vToFetch;\n-    const CBlockIndex *pindexWalk = state.m_last_common_block;\n+    const CBlockIndex *pindexWalk = m_last_common_block;\n     // Never fetch further than the best block we know the peer has, or more than BLOCK_DOWNLOAD_WINDOW + 1 beyond the last\n     // linked block we have in common with this peer. The +1 is so we can detect stalling, namely if we would be able to\n     // download that next block if the window were 1 larger.\n-    int nWindowEnd = state.m_last_common_block->nHeight + BLOCK_DOWNLOAD_WINDOW;\n-    int nMaxHeight = std::min<int>(state.m_best_known_block->nHeight, nWindowEnd + 1);\n+    int nWindowEnd = m_last_common_block->nHeight + BLOCK_DOWNLOAD_WINDOW;\n+    int nMaxHeight = std::min<int>(m_best_known_block->nHeight, nWindowEnd + 1);\n     NodeId waitingfor = -1;\n     while (pindexWalk->nHeight < nMaxHeight) {\n         // Read up to 128 (or more, if more blocks than that are needed) successors of pindexWalk (towards\n         // pindexBestKnownBlock) into vToFetch. We fetch 128, because CBlockIndex::GetAncestor may be as expensive\n         // as iterating over ~100 CBlockIndex* entries anyway.\n         int nToFetch = std::min(nMaxHeight - pindexWalk->nHeight, std::max<int>(count - vBlocks.size(), 128));\n         vToFetch.resize(nToFetch);\n-        pindexWalk = state.m_best_known_block->GetAncestor(pindexWalk->nHeight + nToFetch);\n+        pindexWalk = m_best_known_block->GetAncestor(pindexWalk->nHeight + nToFetch);\n         vToFetch[nToFetch - 1] = pindexWalk;\n         for (unsigned int i = nToFetch - 1; i > 0; i--) {\n             vToFetch[i - 1] = vToFetch[i]->pprev;\n@@ -665,7 +669,7 @@ static void FindNextBlocksToDownload(BlockProviderState& state, bool provider_ha\n             }\n             if (pindex->nStatus & BLOCK_HAVE_DATA || ::ChainActive().Contains(pindex)) {\n                 if (pindex->HaveTxsDownloaded())\n-                    state.m_last_common_block = pindex;\n+                    m_last_common_block = pindex;\n             } else if (mapBlocksInFlight.count(pindex->GetBlockHash()) == 0) {\n                 // The block is not already downloaded, and not yet in flight.\n                 if (pindex->nHeight > nWindowEnd) {\n@@ -4001,7 +4005,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n \n             std::vector<const CBlockIndex*> vToDownload;\n             NodeId staller = -1;\n-            FindNextBlocksToDownload(state.m_blocks_avail, state.fHaveWitness, MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller, consensusParams);\n+            state.m_blocks_avail.FindNextBlocksToDownload(state.fHaveWitness, MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller, consensusParams);\n             for (const CBlockIndex *pindex : vToDownload) {\n                 uint32_t nFetchFlags = GetFetchFlags(pto);\n                 vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));"
      }
    ]
  },
  {
    "sha": "6fc556d1f86bb271e5b08a1ca15da88fc194e9ab",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2ZmM1NTZkMWY4NmJiMjcxZTViMDhhMWNhMTVkYTg4ZmMxOTRlOWFi",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-08-23T22:00:36Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "message": "Make FindNextBlocksToDownload not use mapBlockIndex for in-progress\n\nThis makes it more general than just net_processing",
      "tree": {
        "sha": "414f9343dbe73be48dcec7fe5d629d2fb8293de9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/414f9343dbe73be48dcec7fe5d629d2fb8293de9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6fc556d1f86bb271e5b08a1ca15da88fc194e9ab",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6fc556d1f86bb271e5b08a1ca15da88fc194e9ab",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6fc556d1f86bb271e5b08a1ca15da88fc194e9ab",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6fc556d1f86bb271e5b08a1ca15da88fc194e9ab/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0696ab1bab28b1c9c2f0cccca27590fd53d96865",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0696ab1bab28b1c9c2f0cccca27590fd53d96865",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0696ab1bab28b1c9c2f0cccca27590fd53d96865"
      }
    ],
    "stats": {
      "total": 33,
      "additions": 18,
      "deletions": 15
    },
    "files": [
      {
        "sha": "558943ecdd0124fe2e99986202bee34f2e5faeb1",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 15,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6fc556d1f86bb271e5b08a1ca15da88fc194e9ab/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6fc556d1f86bb271e5b08a1ca15da88fc194e9ab/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=6fc556d1f86bb271e5b08a1ca15da88fc194e9ab",
        "patch": "@@ -212,7 +212,13 @@ struct BlockProviderState {\n         return m_last_common_block ? m_last_common_block->nHeight : -1;\n     }\n \n-    void FindNextBlocksToDownload(bool provider_has_witness, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, NodeId& nodeStaller, const Consensus::Params& consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    /** Update last common height/block and add not-in-flight missing successors to vBlocks, until it has\n+     *  at most count entries.\n+\t *  Before being added to vBlocks, is_block_in_flight is called, and if it returns true, the block is\n+\t *  not added. Note that it is guaranteed to be called in the same order as the blocks appear in the\n+\t *  chain, ie the first call is the next block which is expected to be connected.\n+\t */\n+    void FindNextBlocksToDownload(bool provider_has_witness, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, const Consensus::Params& consensusParams, const std::function<bool (const uint256& block_hash)>& is_block_in_flight) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n };\n \n /**\n@@ -608,9 +614,7 @@ static bool PeerHasHeader(CNodeState *state, const CBlockIndex *pindex) EXCLUSIV\n     return false;\n }\n \n-/** Update pindexLastCommonBlock and add not-in-flight missing successors to vBlocks, until it has\n- *  at most count entries. */\n-void BlockProviderState::FindNextBlocksToDownload(bool provider_has_witness, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, NodeId& nodeStaller, const Consensus::Params& consensusParams)\n+void BlockProviderState::FindNextBlocksToDownload(bool provider_has_witness, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, const Consensus::Params& consensusParams, const std::function<bool (const uint256& block_hash)>& is_block_in_flight)\n {\n     if (count == 0)\n         return;\n@@ -641,7 +645,6 @@ void BlockProviderState::FindNextBlocksToDownload(bool provider_has_witness, uns\n     // download that next block if the window were 1 larger.\n     int nWindowEnd = m_last_common_block->nHeight + BLOCK_DOWNLOAD_WINDOW;\n     int nMaxHeight = std::min<int>(m_best_known_block->nHeight, nWindowEnd + 1);\n-    NodeId waitingfor = -1;\n     while (pindexWalk->nHeight < nMaxHeight) {\n         // Read up to 128 (or more, if more blocks than that are needed) successors of pindexWalk (towards\n         // pindexBestKnownBlock) into vToFetch. We fetch 128, because CBlockIndex::GetAncestor may be as expensive\n@@ -670,23 +673,16 @@ void BlockProviderState::FindNextBlocksToDownload(bool provider_has_witness, uns\n             if (pindex->nStatus & BLOCK_HAVE_DATA || ::ChainActive().Contains(pindex)) {\n                 if (pindex->HaveTxsDownloaded())\n                     m_last_common_block = pindex;\n-            } else if (mapBlocksInFlight.count(pindex->GetBlockHash()) == 0) {\n+            } else if (!is_block_in_flight(pindex->GetBlockHash())) {\n                 // The block is not already downloaded, and not yet in flight.\n                 if (pindex->nHeight > nWindowEnd) {\n                     // We reached the end of the window.\n-                    if (vBlocks.size() == 0) {\n-                        // We aren't able to fetch anything, but we would be if the download window was one larger.\n-                        nodeStaller = waitingfor;\n-                    }\n                     return;\n                 }\n                 vBlocks.push_back(pindex);\n                 if (vBlocks.size() == count) {\n                     return;\n                 }\n-            } else if (waitingfor == -1) {\n-                // This is the first already-in-flight block.\n-                waitingfor = mapBlocksInFlight[pindex->GetBlockHash()].first;\n             }\n         }\n     }\n@@ -4005,15 +4001,22 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n \n             std::vector<const CBlockIndex*> vToDownload;\n             NodeId staller = -1;\n-            state.m_blocks_avail.FindNextBlocksToDownload(state.fHaveWitness, MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller, consensusParams);\n+            state.m_blocks_avail.FindNextBlocksToDownload(state.fHaveWitness, MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, consensusParams,\n+                [&staller] (const uint256& block_hash) NO_THREAD_SAFETY_ANALYSIS { // We're holding cs_main outside, so this is fine\n+                    auto in_flight_it = mapBlocksInFlight.find(block_hash);\n+                    if (in_flight_it != mapBlocksInFlight.end()) {\n+                        staller = in_flight_it->second.first;\n+                    }\n+                    return in_flight_it != mapBlocksInFlight.end();\n+                });\n             for (const CBlockIndex *pindex : vToDownload) {\n                 uint32_t nFetchFlags = GetFetchFlags(pto);\n                 vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n                 MarkBlockAsInFlight(pto->GetId(), pindex->GetBlockHash(), pindex);\n                 LogPrint(BCLog::NET, \"Requesting block %s (%d) peer=%d\\n\", pindex->GetBlockHash().ToString(),\n                     pindex->nHeight, pto->GetId());\n             }\n-            if (state.nBlocksInFlight == 0 && staller != -1 && staller != pto->GetId()) {\n+            if (state.nBlocksInFlight == 0 && staller != -1 && staller != pto->GetId() && vToDownload.empty()) {\n                 if (State(staller)->nStallingSince == 0) {\n                     State(staller)->nStallingSince = nNow;\n                     LogPrint(BCLog::NET, \"Stall started peer=%d\\n\", staller);"
      }
    ]
  },
  {
    "sha": "e513835e201065cad22fdc7a7830b51d81a93410",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNTEzODM1ZTIwMTA2NWNhZDIyZmRjN2E3ODMwYjUxZDgxYTkzNDEw",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-08-23T22:07:19Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "message": "Move BlockProvider to validation.{h,cpp} from net_processing",
      "tree": {
        "sha": "ba60797a2dfcd6ebb2139cd0e7df008919efc989",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ba60797a2dfcd6ebb2139cd0e7df008919efc989"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e513835e201065cad22fdc7a7830b51d81a93410",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e513835e201065cad22fdc7a7830b51d81a93410",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e513835e201065cad22fdc7a7830b51d81a93410",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e513835e201065cad22fdc7a7830b51d81a93410/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6fc556d1f86bb271e5b08a1ca15da88fc194e9ab",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6fc556d1f86bb271e5b08a1ca15da88fc194e9ab",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6fc556d1f86bb271e5b08a1ca15da88fc194e9ab"
      }
    ],
    "stats": {
      "total": 202,
      "additions": 101,
      "deletions": 101
    },
    "files": [
      {
        "sha": "d2e3a44fb3a311ac69c1b68e8d382daeb1be088d",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 101,
        "changes": 101,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e513835e201065cad22fdc7a7830b51d81a93410/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e513835e201065cad22fdc7a7830b51d81a93410/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=e513835e201065cad22fdc7a7830b51d81a93410",
        "patch": "@@ -194,33 +194,6 @@ namespace {\n } // namespace\n \n namespace {\n-/**\n- * Information about a peer's available blocks, for the purpose of figuring out\n- * what block(s) we may want to download from them.\n- */\n-struct BlockProviderState {\n-private:\n-    //! The last full block we both have.\n-    const CBlockIndex *m_last_common_block;\n-public:\n-    //! The best known block we know this peer has announced.\n-    const CBlockIndex *m_best_known_block;\n-\n-    BlockProviderState() : m_last_common_block(nullptr), m_best_known_block(nullptr) {}\n-\n-    int GetLastCommonHeight() const {\n-        return m_last_common_block ? m_last_common_block->nHeight : -1;\n-    }\n-\n-    /** Update last common height/block and add not-in-flight missing successors to vBlocks, until it has\n-     *  at most count entries.\n-\t *  Before being added to vBlocks, is_block_in_flight is called, and if it returns true, the block is\n-\t *  not added. Note that it is guaranteed to be called in the same order as the blocks appear in the\n-\t *  chain, ie the first call is the next block which is expected to be connected.\n-\t */\n-    void FindNextBlocksToDownload(bool provider_has_witness, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, const Consensus::Params& consensusParams, const std::function<bool (const uint256& block_hash)>& is_block_in_flight) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-};\n-\n /**\n  * Maintain validation-specific state about nodes, protected by cs_main, instead\n  * by CNode's own locks. This simplifies asynchronous operation, where\n@@ -614,80 +587,6 @@ static bool PeerHasHeader(CNodeState *state, const CBlockIndex *pindex) EXCLUSIV\n     return false;\n }\n \n-void BlockProviderState::FindNextBlocksToDownload(bool provider_has_witness, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, const Consensus::Params& consensusParams, const std::function<bool (const uint256& block_hash)>& is_block_in_flight)\n-{\n-    if (count == 0)\n-        return;\n-\n-    vBlocks.reserve(vBlocks.size() + count);\n-\n-    if (m_best_known_block == nullptr || m_best_known_block->nChainWork < ::ChainActive().Tip()->nChainWork || m_best_known_block->nChainWork < nMinimumChainWork) {\n-        // This peer has nothing interesting.\n-        return;\n-    }\n-\n-    if (m_last_common_block == nullptr) {\n-        // Bootstrap quickly by guessing a parent of our best tip is the forking point.\n-        // Guessing wrong in either direction is not a problem.\n-        m_last_common_block = ::ChainActive()[std::min(m_best_known_block->nHeight, ::ChainActive().Height())];\n-    }\n-\n-    // If the peer reorganized, our previous pindexLastCommonBlock may not be an ancestor\n-    // of its current tip anymore. Go back enough to fix that.\n-    m_last_common_block = LastCommonAncestor(m_last_common_block, m_best_known_block);\n-    if (m_last_common_block == m_best_known_block)\n-        return;\n-\n-    std::vector<const CBlockIndex*> vToFetch;\n-    const CBlockIndex *pindexWalk = m_last_common_block;\n-    // Never fetch further than the best block we know the peer has, or more than BLOCK_DOWNLOAD_WINDOW + 1 beyond the last\n-    // linked block we have in common with this peer. The +1 is so we can detect stalling, namely if we would be able to\n-    // download that next block if the window were 1 larger.\n-    int nWindowEnd = m_last_common_block->nHeight + BLOCK_DOWNLOAD_WINDOW;\n-    int nMaxHeight = std::min<int>(m_best_known_block->nHeight, nWindowEnd + 1);\n-    while (pindexWalk->nHeight < nMaxHeight) {\n-        // Read up to 128 (or more, if more blocks than that are needed) successors of pindexWalk (towards\n-        // pindexBestKnownBlock) into vToFetch. We fetch 128, because CBlockIndex::GetAncestor may be as expensive\n-        // as iterating over ~100 CBlockIndex* entries anyway.\n-        int nToFetch = std::min(nMaxHeight - pindexWalk->nHeight, std::max<int>(count - vBlocks.size(), 128));\n-        vToFetch.resize(nToFetch);\n-        pindexWalk = m_best_known_block->GetAncestor(pindexWalk->nHeight + nToFetch);\n-        vToFetch[nToFetch - 1] = pindexWalk;\n-        for (unsigned int i = nToFetch - 1; i > 0; i--) {\n-            vToFetch[i - 1] = vToFetch[i]->pprev;\n-        }\n-\n-        // Iterate over those blocks in vToFetch (in forward direction), adding the ones that\n-        // are not yet downloaded and not in flight to vBlocks. In the meantime, update\n-        // pindexLastCommonBlock as long as all ancestors are already downloaded, or if it's\n-        // already part of our chain (and therefore don't need it even if pruned).\n-        for (const CBlockIndex* pindex : vToFetch) {\n-            if (!pindex->IsValid(BLOCK_VALID_TREE)) {\n-                // We consider the chain that this peer is on invalid.\n-                return;\n-            }\n-            if (!provider_has_witness && IsWitnessEnabled(pindex->pprev, consensusParams)) {\n-                // We wouldn't download this block or its descendants from this peer.\n-                return;\n-            }\n-            if (pindex->nStatus & BLOCK_HAVE_DATA || ::ChainActive().Contains(pindex)) {\n-                if (pindex->HaveTxsDownloaded())\n-                    m_last_common_block = pindex;\n-            } else if (!is_block_in_flight(pindex->GetBlockHash())) {\n-                // The block is not already downloaded, and not yet in flight.\n-                if (pindex->nHeight > nWindowEnd) {\n-                    // We reached the end of the window.\n-                    return;\n-                }\n-                vBlocks.push_back(pindex);\n-                if (vBlocks.size() == count) {\n-                    return;\n-                }\n-            }\n-        }\n-    }\n-}\n-\n void EraseTxRequest(const uint256& txid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     g_already_asked_for.erase(txid);"
      },
      {
        "sha": "f8425fab2a9d7ccafc7999dd00bbf879043706d2",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 74,
        "deletions": 0,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e513835e201065cad22fdc7a7830b51d81a93410/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e513835e201065cad22fdc7a7830b51d81a93410/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=e513835e201065cad22fdc7a7830b51d81a93410",
        "patch": "@@ -1110,6 +1110,80 @@ bool GetTransaction(const uint256& hash, CTransactionRef& txOut, const Consensus\n // CBlock and CBlockIndex\n //\n \n+void BlockProviderState::FindNextBlocksToDownload(bool provider_has_witness, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, const Consensus::Params& consensusParams, const std::function<bool (const uint256& block_hash)>& is_block_in_flight)\n+{\n+    if (count == 0)\n+        return;\n+\n+    vBlocks.reserve(vBlocks.size() + count);\n+\n+    if (m_best_known_block == nullptr || m_best_known_block->nChainWork < ::ChainActive().Tip()->nChainWork || m_best_known_block->nChainWork < nMinimumChainWork) {\n+        // This peer has nothing interesting.\n+        return;\n+    }\n+\n+    if (m_last_common_block == nullptr) {\n+        // Bootstrap quickly by guessing a parent of our best tip is the forking point.\n+        // Guessing wrong in either direction is not a problem.\n+        m_last_common_block = ::ChainActive()[std::min(m_best_known_block->nHeight, ::ChainActive().Height())];\n+    }\n+\n+    // If the peer reorganized, our previous pindexLastCommonBlock may not be an ancestor\n+    // of its current tip anymore. Go back enough to fix that.\n+    m_last_common_block = LastCommonAncestor(m_last_common_block, m_best_known_block);\n+    if (m_last_common_block == m_best_known_block)\n+        return;\n+\n+    std::vector<const CBlockIndex*> vToFetch;\n+    const CBlockIndex *pindexWalk = m_last_common_block;\n+    // Never fetch further than the best block we know the peer has, or more than BLOCK_DOWNLOAD_WINDOW + 1 beyond the last\n+    // linked block we have in common with this peer. The +1 is so we can detect stalling, namely if we would be able to\n+    // download that next block if the window were 1 larger.\n+    int nWindowEnd = m_last_common_block->nHeight + BLOCK_DOWNLOAD_WINDOW;\n+    int nMaxHeight = std::min<int>(m_best_known_block->nHeight, nWindowEnd + 1);\n+    while (pindexWalk->nHeight < nMaxHeight) {\n+        // Read up to 128 (or more, if more blocks than that are needed) successors of pindexWalk (towards\n+        // pindexBestKnownBlock) into vToFetch. We fetch 128, because CBlockIndex::GetAncestor may be as expensive\n+        // as iterating over ~100 CBlockIndex* entries anyway.\n+        int nToFetch = std::min(nMaxHeight - pindexWalk->nHeight, std::max<int>(count - vBlocks.size(), 128));\n+        vToFetch.resize(nToFetch);\n+        pindexWalk = m_best_known_block->GetAncestor(pindexWalk->nHeight + nToFetch);\n+        vToFetch[nToFetch - 1] = pindexWalk;\n+        for (unsigned int i = nToFetch - 1; i > 0; i--) {\n+            vToFetch[i - 1] = vToFetch[i]->pprev;\n+        }\n+\n+        // Iterate over those blocks in vToFetch (in forward direction), adding the ones that\n+        // are not yet downloaded and not in flight to vBlocks. In the meantime, update\n+        // pindexLastCommonBlock as long as all ancestors are already downloaded, or if it's\n+        // already part of our chain (and therefore don't need it even if pruned).\n+        for (const CBlockIndex* pindex : vToFetch) {\n+            if (!pindex->IsValid(BLOCK_VALID_TREE)) {\n+                // We consider the chain that this peer is on invalid.\n+                return;\n+            }\n+            if (!provider_has_witness && IsWitnessEnabled(pindex->pprev, consensusParams)) {\n+                // We wouldn't download this block or its descendants from this peer.\n+                return;\n+            }\n+            if (pindex->nStatus & BLOCK_HAVE_DATA || ::ChainActive().Contains(pindex)) {\n+                if (pindex->HaveTxsDownloaded())\n+                    m_last_common_block = pindex;\n+            } else if (!is_block_in_flight(pindex->GetBlockHash())) {\n+                // The block is not already downloaded, and not yet in flight.\n+                if (pindex->nHeight > nWindowEnd) {\n+                    // We reached the end of the window.\n+                    return;\n+                }\n+                vBlocks.push_back(pindex);\n+                if (vBlocks.size() == count) {\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n static bool WriteBlockToDisk(const CBlock& block, FlatFilePos& pos, const CMessageHeader::MessageStartChars& messageStart)\n {\n     // Open history file to append"
      },
      {
        "sha": "2232a9c7a2af7bed69e516959e1cf71b3c979248",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 27,
        "deletions": 0,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e513835e201065cad22fdc7a7830b51d81a93410/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e513835e201065cad22fdc7a7830b51d81a93410/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=e513835e201065cad22fdc7a7830b51d81a93410",
        "patch": "@@ -735,6 +735,33 @@ class CChainState {\n     void EraseBlockData(CBlockIndex* index) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n };\n \n+/**\n+ * Information about a peer's available blocks, for the purpose of figuring out\n+ * what block(s) we may want to download from them.\n+ */\n+struct BlockProviderState {\n+private:\n+    //! The last full block we both have.\n+    const CBlockIndex *m_last_common_block;\n+public:\n+    //! The best known block we know this peer has announced.\n+    const CBlockIndex *m_best_known_block;\n+\n+    BlockProviderState() : m_last_common_block(nullptr), m_best_known_block(nullptr) {}\n+\n+    int GetLastCommonHeight() const {\n+        return m_last_common_block ? m_last_common_block->nHeight : -1;\n+    }\n+\n+    /** Update last common height/block and add not-in-flight missing successors to vBlocks, until it has\n+     *  at most count entries.\n+     *  Before being added to vBlocks, is_block_in_flight is called, and if it returns true, the block is\n+     *  not added. Note that it is guaranteed to be called in the same order as the blocks appear in the\n+     *  chain, ie the first call is the next block which is expected to be connected.\n+     */\n+    void FindNextBlocksToDownload(bool provider_has_witness, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, const Consensus::Params& consensusParams, const std::function<bool (const uint256& block_hash)>& is_block_in_flight) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+};\n+\n /** Mark a block as precious and reorganize.\n  *\n  * May not be called in a"
      }
    ]
  },
  {
    "sha": "1361107c89d9581a95763866a39d954197f71e70",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMzYxMTA3Yzg5ZDk1ODFhOTU3NjM4NjZhMzlkOTU0MTk3ZjcxZTcw",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-10-12T04:53:41Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "message": "Add ffis to access BlockProviderState and hand blocks to C++",
      "tree": {
        "sha": "13d9921413636f153dc0faf956a948775c8b306e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/13d9921413636f153dc0faf956a948775c8b306e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1361107c89d9581a95763866a39d954197f71e70",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1361107c89d9581a95763866a39d954197f71e70",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1361107c89d9581a95763866a39d954197f71e70",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1361107c89d9581a95763866a39d954197f71e70/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e513835e201065cad22fdc7a7830b51d81a93410",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e513835e201065cad22fdc7a7830b51d81a93410",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e513835e201065cad22fdc7a7830b51d81a93410"
      }
    ],
    "stats": {
      "total": 191,
      "additions": 191,
      "deletions": 0
    },
    "files": [
      {
        "sha": "480e6204d3c9389803f6645f721505e19ecb378f",
        "filename": "src/rusty/src/bridge.rs",
        "status": "modified",
        "additions": 103,
        "deletions": 0,
        "changes": 103,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1361107c89d9581a95763866a39d954197f71e70/src/rusty/src/bridge.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1361107c89d9581a95763866a39d954197f71e70/src/rusty/src/bridge.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/bridge.rs?ref=1361107c89d9581a95763866a39d954197f71e70",
        "patch": "@@ -3,6 +3,8 @@ extern \"C\" {\n     pub fn rusty_IsInitialBlockDownload() -> bool;\n     pub fn rusty_ShutdownRequested() -> bool;\n \n+    fn rusty_ProcessNewBlock(blockdata: *const u8, blockdatalen: usize, blockindex_requested: *const c_void);\n+\n     /// Connects count headers serialized in a block of memory, each stride bytes from each other.\n     /// Returns the last header which was connected, if any (or NULL).\n     fn rusty_ConnectHeaders(headers: *const u8, stride: usize, count: usize) -> *const c_void;\n@@ -13,8 +15,15 @@ extern \"C\" {\n     /// Guaranteed to never be NULL (but may be genesis)\n     fn rusty_GetChainTip() -> *const c_void;\n \n+    /// Gets a CBlockIndex* pointer (casted to a c_void) representing the genesis block.\n+    /// Guaranteed to never be NULL\n+    fn rusty_GetGenesisIndex() -> *const c_void;\n+\n     /// Gets the height of a given CBlockIndex* pointer\n     fn rusty_IndexToHeight(index: *const c_void) -> i32;\n+\n+    /// Gets the hash of a given CBlockIndex* pointer\n+    fn rusty_IndexToHash(index: *const c_void) -> *const u8;\n }\n \n /// Connects the given array of (sorted, in chain order) headers (in serialized, 80-byte form).\n@@ -26,6 +35,16 @@ pub fn connect_headers_flat_bytes(headers: &[u8]) -> Option<BlockIndex> {\n     if index.is_null() { None } else { Some(BlockIndex { index }) }\n }\n \n+/// Processes a new block, in serialized form.\n+/// blockindex_requested_by_state should be set *only* if the given BlockIndex was provided by\n+/// BlockProviderState::get_next_block_to_download(), and may be set to None always.\n+pub fn connect_block(blockdata: &[u8], blockindex_requested_by_state: Option<BlockIndex>) {\n+    let blockindex = match blockindex_requested_by_state { Some(index) => index.index, None => std::ptr::null(), };\n+    unsafe {\n+        rusty_ProcessNewBlock(blockdata.as_ptr(), blockdata.len(), blockindex);\n+    }\n+}\n+\n #[derive(PartialEq, Clone, Copy)]\n pub struct BlockIndex {\n     index: *const c_void,\n@@ -38,7 +57,91 @@ impl BlockIndex {\n         }\n     }\n \n+    pub fn genesis() -> Self {\n+        Self {\n+            index: unsafe { rusty_GetGenesisIndex() },\n+        }\n+    }\n+\n     pub fn height(&self) -> i32 {\n         unsafe { rusty_IndexToHeight(self.index) }\n     }\n+\n+    pub fn hash(&self) -> [u8; 32] {\n+        let hashptr = unsafe { rusty_IndexToHash(self.index) };\n+        if hashptr.is_null() { unreachable!(); }\n+        let mut res = [0u8; 32];\n+        unsafe { std::ptr::copy(hashptr, res.as_mut_ptr(), 32) };\n+        res\n+    }\n+\n+    /// Gets the hex formatted hash of this block, in byte-revered order (ie starting with the PoW\n+    /// 0s, as is commonly used in Bitcoin APIs).\n+    pub fn hash_hex(&self) -> String {\n+        let hash_bytes = self.hash();\n+        let mut res = String::with_capacity(64);\n+        for b in hash_bytes.iter().rev() {\n+            res.push(std::char::from_digit((b >> 4) as u32, 16).unwrap());\n+            res.push(std::char::from_digit((b & 0x0f) as u32, 16).unwrap());\n+        }\n+        res\n+    }\n+}\n+\n+extern \"C\" {\n+    // Utilities to work with BlockProviderState objects. Wrapped in a safe wrapper below.\n+\n+    /// Creates a new BlockProviderState with a given current best CBlockIndex*.\n+    /// Don't forget to de-allocate!\n+    fn rusty_ProviderStateInit(blockindex: *const c_void) -> *mut c_void;\n+    /// De-allocates a BlockProviderState.\n+    fn rusty_ProviderStateFree(provider_state: *mut c_void);\n+\n+    /// Sets the current best available CBlockIndex* for the given provider state.\n+    fn rusty_ProviderStateSetBest(provider_state: *mut c_void, blockindex: *const c_void);\n+\n+    /// Gets the next CBlockIndex* a given provider should download, or NULL\n+    fn rusty_ProviderStateGetNextDownloads(providerindexvoid: *mut c_void, has_witness: bool) -> *const c_void;\n+}\n+\n+pub struct BlockProviderState {\n+    // TODO: We should be smarter than to keep a copy of the current best pointer twice, but\n+    // crossing the FFI boundary just to look it up again sucks.\n+    current_best: BlockIndex,\n+    state: *mut c_void,\n+}\n+impl BlockProviderState {\n+    /// Initializes block provider state with a given current best header.\n+    /// Note that you can use a guess on the current best that moves backwards as you discover the\n+    /// providers' true chain state, though for efficiency you should try to avoid calling\n+    /// get_next_block_to_download in such a state.\n+    pub fn new_with_current_best(blockindex: BlockIndex) -> Self {\n+        Self {\n+            current_best: blockindex,\n+            state: unsafe { rusty_ProviderStateInit(blockindex.index) }\n+        }\n+    }\n+\n+    /// Sets the current best available blockindex to the given one on this state.\n+    pub fn set_current_best(&mut self, blockindex: BlockIndex) {\n+        self.current_best = blockindex;\n+        unsafe { rusty_ProviderStateSetBest(self.state, blockindex.index) };\n+    }\n+\n+    /// Gets the current best available blockindex as provided previously by set_current_best or\n+    /// new_with_current_best.\n+    pub fn get_current_best(&self) -> BlockIndex {\n+        self.current_best\n+    }\n+\n+    /// Gets the BlockIndex representing the next block which should be downloaded, if any.\n+    pub fn get_next_block_to_download(&mut self, has_witness: bool) -> Option<BlockIndex> {\n+        let index = unsafe { rusty_ProviderStateGetNextDownloads(self.state, has_witness) };\n+        if index.is_null() { None } else { Some(BlockIndex { index }) }\n+    }\n+}\n+impl Drop for BlockProviderState {\n+    fn drop(&mut self) {\n+        unsafe { rusty_ProviderStateFree(self.state) };\n+    }\n }"
      },
      {
        "sha": "e3a1501d5955c0f6b8bdbf241c21d4f859f52db8",
        "filename": "src/rusty/src/cpp_bridge.cpp",
        "status": "modified",
        "additions": 52,
        "deletions": 0,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1361107c89d9581a95763866a39d954197f71e70/src/rusty/src/cpp_bridge.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1361107c89d9581a95763866a39d954197f71e70/src/rusty/src/cpp_bridge.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/cpp_bridge.cpp?ref=1361107c89d9581a95763866a39d954197f71e70",
        "patch": "@@ -57,6 +57,19 @@ bool rusty_ShutdownRequested() {\n     return ShutdownRequested();\n }\n \n+void rusty_ProcessNewBlock(const uint8_t* blockdata, size_t blocklen, const void* pindexvoid) {\n+    const CBlockIndex *pindex = (const CBlockIndex*) pindexvoid;\n+    CBlock block;\n+    try {\n+        InputStream(SER_NETWORK, PROTOCOL_VERSION, blockdata, blocklen) >> block;\n+    } catch (...) {}\n+    if (pindex && block.GetHash() == pindex->GetBlockHash()) {\n+        ProcessNewBlock(::Params(), std::make_shared<const CBlock>(block), true, nullptr);\n+    } else {\n+        ProcessNewBlock(::Params(), std::make_shared<const CBlock>(block), false, nullptr);\n+    }\n+}\n+\n const void* rusty_ConnectHeaders(const uint8_t* headers_data, size_t stride, size_t count) {\n     std::vector<CBlockHeader> headers;\n     for(size_t i = 0; i < count; i++) {\n@@ -79,10 +92,49 @@ const void* rusty_GetChainTip() {\n     return tip;\n }\n \n+const void* rusty_GetGenesisIndex() {\n+    LOCK(cs_main);\n+    const CBlockIndex* genesis = ::ChainActive().Genesis();\n+    assert(genesis != nullptr);\n+    return genesis;\n+}\n+\n int32_t rusty_IndexToHeight(const void* pindexvoid) {\n     const CBlockIndex *pindex = (const CBlockIndex*) pindexvoid;\n     assert(pindex != nullptr);\n     return pindex->nHeight;\n }\n \n+const uint8_t* rusty_IndexToHash(const void* pindexvoid) {\n+    const CBlockIndex *pindex = (const CBlockIndex*) pindexvoid;\n+    assert(pindex != nullptr);\n+    return pindex->phashBlock->begin();\n+}\n+\n+void* rusty_ProviderStateInit(const void* pindexvoid) {\n+    const CBlockIndex *pindex = (const CBlockIndex*) pindexvoid;\n+    BlockProviderState* state = new BlockProviderState;\n+    state->m_best_known_block = pindex;\n+    return state;\n+}\n+\n+void rusty_ProviderStateFree(void* providerindexvoid) {\n+    BlockProviderState* state = (BlockProviderState*) providerindexvoid;\n+    delete state;\n+}\n+\n+void rusty_ProviderStateSetBest(void* providerindexvoid, const void* pindexvoid) {\n+    BlockProviderState* state = (BlockProviderState*) providerindexvoid;\n+    const CBlockIndex *pindex = (const CBlockIndex*) pindexvoid;\n+    state->m_best_known_block = pindex;\n+}\n+\n+const void* rusty_ProviderStateGetNextDownloads(void* providerindexvoid, bool has_witness) {\n+    BlockProviderState* state = (BlockProviderState*) providerindexvoid;\n+    std::vector<const CBlockIndex*> blocks;\n+    LOCK(cs_main);\n+    state->FindNextBlocksToDownload(has_witness, 1, blocks, ::Params().GetConsensus(), [] (const uint256& block_hash) { return false; });\n+    return blocks.empty() ? nullptr : blocks[0];\n+}\n+\n }"
      },
      {
        "sha": "27e862c91d5bda426d839b23af9a7e5952befc37",
        "filename": "src/rusty/src/test_bridge.rs",
        "status": "modified",
        "additions": 36,
        "deletions": 0,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1361107c89d9581a95763866a39d954197f71e70/src/rusty/src/test_bridge.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1361107c89d9581a95763866a39d954197f71e70/src/rusty/src/test_bridge.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/test_bridge.rs?ref=1361107c89d9581a95763866a39d954197f71e70",
        "patch": "@@ -10,6 +10,10 @@ pub fn connect_headers_flat_bytes(_headers: &[u8]) -> Option<BlockIndex> {\n     unimplemented!();\n }\n \n+pub fn connect_block(_blockdata: &[u8], _blockindex_requested_by_state: Option<BlockIndex>) {\n+    unimplemented!();\n+}\n+\n #[derive(PartialEq, Clone, Copy)]\n pub struct BlockIndex { }\n \n@@ -18,7 +22,39 @@ impl BlockIndex {\n         unimplemented!();\n     }\n \n+    pub fn genesis() -> Self {\n+        unimplemented!();\n+    }\n+\n     pub fn height(&self) -> i32 {\n         unimplemented!();\n     }\n+\n+    pub fn hash(&self) -> [u8; 32] {\n+        unimplemented!();\n+    }\n+\n+    pub fn hash_hex(&self) -> String {\n+        unimplemented!();\n+    }\n+}\n+\n+pub struct BlockProviderState { }\n+\n+impl BlockProviderState {\n+    pub fn new_with_current_best(_blockindex: BlockIndex) -> Self {\n+        unimplemented!();\n+    }\n+\n+    pub fn set_current_best(&mut self, _blockindex: BlockIndex) {\n+        unimplemented!();\n+    }\n+\n+    pub fn get_current_best(&self) -> BlockIndex {\n+        unimplemented!();\n+    }\n+\n+    pub fn get_next_block_to_download(&mut self, _has_witness: bool) -> Option<BlockIndex> {\n+        unimplemented!();\n+    }\n }"
      }
    ]
  },
  {
    "sha": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyYzBkZGEzM2M1MTMyNDY4NmJjMTQzZDhiZWQ4OWViYmEwODhhYjhh",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-10-18T19:30:52Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "message": "Add a rust-based backup over-REST block downloader",
      "tree": {
        "sha": "84dfd0322bad2df6531242b58489123328c05e34",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/84dfd0322bad2df6531242b58489123328c05e34"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2c0dda33c51324686bc143d8bed89ebba088ab8a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2c0dda33c51324686bc143d8bed89ebba088ab8a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2c0dda33c51324686bc143d8bed89ebba088ab8a/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1361107c89d9581a95763866a39d954197f71e70",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1361107c89d9581a95763866a39d954197f71e70",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1361107c89d9581a95763866a39d954197f71e70"
      }
    ],
    "stats": {
      "total": 367,
      "additions": 366,
      "deletions": 1
    },
    "files": [
      {
        "sha": "5467bb96492b2251c69ad1dc79e08fce97661528",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2c0dda33c51324686bc143d8bed89ebba088ab8a/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2c0dda33c51324686bc143d8bed89ebba088ab8a/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=2c0dda33c51324686bc143d8bed89ebba088ab8a",
        "patch": "@@ -382,7 +382,8 @@ libbitcoin_wallet_tool_a_SOURCES = \\\n LIBBITCOIN_RUSTY_SRCS= \\\n   rusty/src/lib.rs \\\n   rusty/src/bridge.rs \\\n-  rusty/src/dns_headers.rs\n+  rusty/src/dns_headers.rs \\\n+  rusty/src/rest_downloader.rs\n \n LIBBITCOIN_RUSTY_TEST_SRCS= \\\n   rusty/src/test_bridge.rs"
      },
      {
        "sha": "b5a5ba55a836eefb1ad8adfd1d4cdd83ebadf723",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2c0dda33c51324686bc143d8bed89ebba088ab8a/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2c0dda33c51324686bc143d8bed89ebba088ab8a/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=2c0dda33c51324686bc143d8bed89ebba088ab8a",
        "patch": "@@ -189,6 +189,7 @@ void Shutdown(NodeContext& node)\n \n #if ENABLE_RUSTY\n     rust_block_fetch::stop_fetch_dns_headers();\n+    rust_block_fetch::stop_fetch_rest_blocks();\n #endif\n \n     StopHTTPRPC();\n@@ -406,6 +407,7 @@ void SetupServerArgs()\n                  ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n \n #if ENABLE_RUSTY\n+    gArgs.AddArg(\"-blockfetchrest=<uri>\", \"A REST endpoint from which to fetch blocks. Acts as a redundant backup for P2P connectivity. eg http://cloudflare.deanonymizingseed.com/rest/\", ArgsManager::ALLOW_ANY | ArgsManager::NETWORK_ONLY, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-headersfetchdns=<domain>\", \"A domain name from which to fetch headers. eg bitcoinheaders.net\", ArgsManager::ALLOW_ANY | ArgsManager::NETWORK_ONLY, OptionsCategory::CONNECTION);\n #endif\n     gArgs.AddArg(\"-addnode=<ip>\", \"Add a node to connect to and attempt to keep the connection open (see the `addnode` RPC command help for more info). This option can be specified multiple times to add multiple nodes.\", ArgsManager::ALLOW_ANY | ArgsManager::NETWORK_ONLY, OptionsCategory::CONNECTION);\n@@ -1838,6 +1840,9 @@ bool AppInitMain(NodeContext& node)\n     for (const std::string& domain : gArgs.GetArgs(\"-headersfetchdns\")) {\n         rust_block_fetch::init_fetch_dns_headers(domain.c_str());\n     }\n+    for (const std::string& uri : gArgs.GetArgs(\"-blockfetchrest\")) {\n+        rust_block_fetch::init_fetch_rest_blocks(uri.c_str());\n+    }\n #endif\n \n     return true;"
      },
      {
        "sha": "891e4fd8678ce9d8378a6db374dab5cda7c09648",
        "filename": "src/rusty/src/lib.rs",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2c0dda33c51324686bc143d8bed89ebba088ab8a/src/rusty/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2c0dda33c51324686bc143d8bed89ebba088ab8a/src/rusty/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/lib.rs?ref=2c0dda33c51324686bc143d8bed89ebba088ab8a",
        "patch": "@@ -1,9 +1,16 @@\n+// Rust has a tendency to try to force users onto the Latest And Greatest (tm)\n+// with incredibly verbose warnings. Sadly, we need to support users who use rustc\n+// as distributed by their linux distribution, so in generally cannot \"fix\" the\n+// warnings. Thus, we should disable such useless lints below.\n+#![allow(deprecated)]\n+\n #[cfg(not(test))] mod bridge;\n #[cfg(test)] pub mod test_bridge;\n #[cfg(test)] pub use test_bridge as bridge;\n use bridge::*;\n \n mod dns_headers;\n+mod rest_downloader;\n \n use std::alloc::{GlobalAlloc, Layout, System};\n use std::ptr;"
      },
      {
        "sha": "fdc90f04f5cfae226ddd766bcbc8c1f84d41668e",
        "filename": "src/rusty/src/rest_downloader.rs",
        "status": "added",
        "additions": 350,
        "deletions": 0,
        "changes": 350,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2c0dda33c51324686bc143d8bed89ebba088ab8a/src/rusty/src/rest_downloader.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2c0dda33c51324686bc143d8bed89ebba088ab8a/src/rusty/src/rest_downloader.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/rest_downloader.rs?ref=2c0dda33c51324686bc143d8bed89ebba088ab8a",
        "patch": "@@ -0,0 +1,350 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+use std::ffi::CStr;\n+use std::os::raw::c_char;\n+\n+/// Splits an HTTP URI into its component part - (is_ssl, hostname, port number, and HTTP path)\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    host_path = host_path.trim_left_matches(\"/\");\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = r.starts_with(\"[\");\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[cfg(test)]\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        let mut end_headers_pos = None;\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                end_headers_pos = Some(idx + 2);\n+                break;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                end_headers_pos = Some(idx + 4);\n+                break;\n+            }\n+        }\n+        if let Some(pos) = end_headers_pos {\n+            resp = resp.split_off(pos);\n+            resp.resize(bytes_read - pos, 0);\n+            break 'read_headers;\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                {\n+                    let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                    loop {\n+                        let line = match lineiter.next() { Some(line) => line, None => break };\n+                        if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                            if line.len() > 8 {\n+                                // No reason to ever have a chunk length line longer than 4 chars\n+                                return None;\n+                            }\n+                            break;\n+                        }\n+                        bytes_skipped += line.len() + 1;\n+                        if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                        match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                            Ok(s) => s, Err(_) => return None,\n+                        }, 16) {\n+                            Ok(chunklen) => {\n+                                if chunklen == 0 { finished_read = true; }\n+                                chunk_remaining = chunklen;\n+                                match lineiter.next() {\n+                                    Some(l) if l.is_empty() => {\n+                                        // Drop \\r after \\n\n+                                        bytes_skipped += 1;\n+                                        if actual_len + bytes_skipped > bytes_read {\n+                                            // Go back and get more bytes so we can skip trailing \\n\n+                                            chunk_remaining = 0;\n+                                        }\n+                                    },\n+                                    Some(_) => {},\n+                                    None => {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    },\n+                                }\n+                                break;\n+                            },\n+                            Err(_) => return None,\n+                        }\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+static THREAD_COUNT: AtomicUsize = AtomicUsize::new(0);\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const c_char) -> bool {\n+    let uri_str: String = match unsafe { CStr::from_ptr(uri) }.to_str() {\n+        Ok(r) => r.to_string(),\n+        Err(_) => return false,\n+    };\n+    // Sadly only non-SSL is supported for now\n+    if let Some((false, _, _, _)) = split_uri(&uri_str) { } else { return false; }\n+    std::thread::spawn(move || {\n+        // Always catch panics so that even if we have some bug in our parser we don't take the\n+        // rest of Bitcoin Core down with us:\n+        THREAD_COUNT.fetch_add(1, Ordering::AcqRel);\n+        let _ = catch_unwind(move || {\n+            await_ibd_complete_or_stalled();\n+            let (ssl, host, port, path) = split_uri(&uri_str).unwrap();\n+            let mut provider_state = BlockProviderState::new_with_current_best(BlockIndex::tip());\n+            'reconnect: while unsafe { !rusty_ShutdownRequested() } {\n+                std::thread::sleep(Duration::from_secs(1));\n+                if unsafe { rusty_ShutdownRequested() } { return; }\n+\n+                let mut stream;\n+                macro_rules! reconnect {\n+                    () => { {\n+                        stream = match TcpStream::connect_timeout(&match (host, port).to_socket_addrs() {\n+                            Ok(mut sockaddrs) => match sockaddrs.next() { Some(sockaddr) => sockaddr, None => continue 'reconnect },\n+                            Err(_) => continue 'reconnect,\n+                        }, Duration::from_secs(1)) {\n+                            Ok(stream) => stream,\n+                            Err(_) => continue 'reconnect,\n+                        };\n+                        stream.set_write_timeout(Some(Duration::from_secs(1))).expect(\"Host kernel is uselessly old?\");\n+                        stream.set_read_timeout(Some(Duration::from_secs(10))).expect(\"Host kernel is uselessly old?\");\n+                        if ssl {\n+                            unimplemented!();\n+                        }\n+                    } }\n+                }\n+                reconnect!();\n+\n+                'continue_sync: while unsafe { !rusty_ShutdownRequested() } {\n+                    macro_rules! write_req {\n+                        ($req_str: expr) => { {\n+                            match stream.write($req_str.as_bytes()) {\n+                                Ok(len) if len == $req_str.len() => {},\n+                                _ => {\n+                                    // Reconnect since we've probably timed out and try again.\n+                                    reconnect!();\n+\n+                                    match stream.write($req_str.as_bytes()) {\n+                                        Ok(len) if len == $req_str.len() => {},\n+                                        _ => continue 'reconnect,\n+                                    }\n+                                }\n+                            }\n+                        } }\n+                    }\n+\n+                    'header_sync: while unsafe { !rusty_ShutdownRequested() } {\n+                        let req = format!(\"GET {}/headers/2000/{}.bin HTTP/1.1\\nHost: {}\\nConnection: keep-alive\\n\\n\", path, provider_state.get_current_best().hash_hex(), host);\n+                        write_req!(req);\n+                        let headers = match read_http_resp(&mut stream, 80*2000) {\n+                            Some(h) => h,\n+                            None => continue 'reconnect,\n+                        };\n+                        if headers.len() == 80 {\n+                            // We got exactly the header we requested, ie it is *also* the tip for the\n+                            // remote node, go on to block fetching!\n+                            break 'header_sync;\n+                        } else if headers.len() == 0 {\n+                            let genesis_tip = BlockIndex::genesis();\n+                            if genesis_tip == provider_state.get_current_best() { // Maybe they're on a different network entirely?\n+                                continue 'reconnect;\n+                            }\n+                            // We are on a fork, but there's nothing in REST (currently) that lets us walk\n+                            // back until we find the fork point, so we just start downloading again from\n+                            // genesis, 2000 headers at a time.\n+                            provider_state.set_current_best(genesis_tip);\n+                            continue 'header_sync;\n+                        }\n+                        match connect_headers_flat_bytes(&headers) {\n+                            Some(new_best) => {\n+                                if new_best == provider_state.get_current_best() {\n+                                    // We tried to connect > 1 header, but didn't move forward, reconnect\n+                                    // and try again\n+                                    continue 'reconnect;\n+                                }\n+                                provider_state.set_current_best(new_best);\n+                                continue 'header_sync;\n+                            },\n+                            None => {\n+                                // We consider their response bogus, reconnect and try again\n+                                continue 'reconnect;\n+                            },\n+                        }\n+                    }\n+\n+                    // We think we're caught up with their header chain!\n+                    // Wait a little bit to give the regular (more efficient) P2P logic a chance to\n+                    // download blocks, then check if we should download anything.\n+                    for _ in 0..30 {\n+                        std::thread::sleep(Duration::from_secs(1));\n+                        if unsafe { rusty_ShutdownRequested() } { return; }\n+                    }\n+\n+                    'block_fetch: while unsafe { !rusty_ShutdownRequested() } {\n+                        match provider_state.get_next_block_to_download(true) {\n+                            Some(to_fetch) => {\n+                                let req = format!(\"GET {}/block/{}.bin HTTP/1.1\\nHost: {}\\nConnection: keep-alive\\n\\n\", path, to_fetch.hash_hex(), host);\n+                                write_req!(req);\n+                                let block = match read_http_resp(&mut stream, 4 * 1000 * 1000) {\n+                                    Some(b) => b,\n+                                    None => continue 'reconnect,\n+                                };\n+                                connect_block(&block, Some(to_fetch));\n+                            },\n+                            None => continue 'continue_sync,\n+                        }\n+                    }\n+                }\n+            }\n+        });\n+        THREAD_COUNT.fetch_sub(1, Ordering::AcqRel);\n+    });\n+    true\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn stop_fetch_rest_blocks() {\n+    while THREAD_COUNT.load(Ordering::Acquire) != 0 {\n+        std::thread::sleep(Duration::from_millis(10));\n+    }\n+}"
      },
      {
        "sha": "166eee2d52b0ca6b63a26366027a845ee8603a5d",
        "filename": "src/rusty/src/rust_bridge.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2c0dda33c51324686bc143d8bed89ebba088ab8a/src/rusty/src/rust_bridge.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2c0dda33c51324686bc143d8bed89ebba088ab8a/src/rusty/src/rust_bridge.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/rust_bridge.h?ref=2c0dda33c51324686bc143d8bed89ebba088ab8a",
        "patch": "@@ -17,6 +17,8 @@ extern \"C\" {\n \n bool init_fetch_dns_headers(const char *domain);\n bool stop_fetch_dns_headers();\n+bool init_fetch_rest_blocks(const char *uri);\n+bool stop_fetch_rest_blocks();\n \n } // extern \"C\"\n "
      }
    ]
  }
]