[
  {
    "sha": "97ee8665497c78aff2f30c2f652b7afd376b5323",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5N2VlODY2NTQ5N2M3OGFmZjJmMzBjMmY2NTJiN2FmZDM3NmI1MzIz",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2014-12-01T11:38:42Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-04-21T18:26:49Z"
      },
      "message": "[REST] getutxos REST command (based on Bip64)\n\nhas parts of @mhearn #4351\n* allows querying the utxos over REST\n* same binary input and outputs as mentioned in Bip64\n* input format = output format\n* various rpc/rest regtests",
      "tree": {
        "sha": "cd3c73c54ec6e513d53a101d6f731eaea1b2a2ea",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cd3c73c54ec6e513d53a101d6f731eaea1b2a2ea"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/97ee8665497c78aff2f30c2f652b7afd376b5323",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/97ee8665497c78aff2f30c2f652b7afd376b5323",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/97ee8665497c78aff2f30c2f652b7afd376b5323",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/97ee8665497c78aff2f30c2f652b7afd376b5323/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b6ea3bcede1cbbf89486b9d67329e0110c4624ae",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b6ea3bcede1cbbf89486b9d67329e0110c4624ae",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b6ea3bcede1cbbf89486b9d67329e0110c4624ae"
      }
    ],
    "stats": {
      "total": 433,
      "additions": 407,
      "deletions": 26
    },
    "files": [
      {
        "sha": "3c4f83b90dd343b17a5b6e64a30de0012a3fbb3a",
        "filename": "qa/rpc-tests/rest.py",
        "status": "modified",
        "additions": 178,
        "deletions": 8,
        "changes": 186,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/97ee8665497c78aff2f30c2f652b7afd376b5323/qa/rpc-tests/rest.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/97ee8665497c78aff2f30c2f652b7afd376b5323/qa/rpc-tests/rest.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/rest.py?ref=97ee8665497c78aff2f30c2f652b7afd376b5323",
        "patch": "@@ -9,7 +9,10 @@\n \n from test_framework import BitcoinTestFramework\n from util import *\n+from struct import *\n+import binascii\n import json\n+import StringIO\n \n try:\n     import http.client as httplib\n@@ -20,45 +23,210 @@\n except ImportError:\n     import urlparse\n \n-def http_get_call(host, port, path, response_object = 0):\n+def deser_uint256(f):\n+    r = 0\n+    for i in range(8):\n+        t = unpack(b\"<I\", f.read(4))[0]\n+        r += t << (i * 32)\n+    return r\n+\n+#allows simple http get calls with a request body\n+def http_get_call(host, port, path, requestdata = '', response_object = 0):\n     conn = httplib.HTTPConnection(host, port)\n-    conn.request('GET', path)\n+    conn.request('GET', path, requestdata)\n \n     if response_object:\n         return conn.getresponse()\n \n     return conn.getresponse().read()\n \n-\n class RESTTest (BitcoinTestFramework):\n     FORMAT_SEPARATOR = \".\"\n \n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 3)\n+\n+    def setup_network(self, split=False):\n+        self.nodes = start_nodes(3, self.options.tmpdir)\n+        connect_nodes_bi(self.nodes,0,1)\n+        connect_nodes_bi(self.nodes,1,2)\n+        connect_nodes_bi(self.nodes,0,2)\n+        self.is_network_split=False\n+        self.sync_all()\n+        \n     def run_test(self):\n         url = urlparse.urlparse(self.nodes[0].url)\n+        print \"Mining blocks...\"\n+        \n+        self.nodes[0].setgenerate(True, 1)\n+        self.sync_all()\n+        self.nodes[2].setgenerate(True, 100)\n+        self.sync_all()\n+        \n+        assert_equal(self.nodes[0].getbalance(), 50)\n+        \n+        txid = self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 0.1)\n+        self.sync_all()\n+        self.nodes[2].setgenerate(True, 1)\n+        self.sync_all()\n+        bb_hash = self.nodes[0].getbestblockhash()\n+        \n+        assert_equal(self.nodes[1].getbalance(), Decimal(\"0.1\")) #balance now should be 0.1 on node 1\n+        \n+        # load the latest 0.1 tx over the REST API\n+        json_string = http_get_call(url.hostname, url.port, '/rest/tx/'+txid+self.FORMAT_SEPARATOR+\"json\")\n+        json_obj = json.loads(json_string)\n+        vintx = json_obj['vin'][0]['txid'] # get the vin to later check for utxo (should be spent by then)\n+        # get n of 0.1 outpoint \n+        n = 0\n+        for vout in json_obj['vout']:\n+            if vout['value'] == 0.1:\n+                n = vout['n']\n+        \n+        \n+        ######################################\n+        # GETUTXOS: query a unspent outpoint #\n+        ######################################\n+        json_request = '{\"checkmempool\":true,\"outpoints\":[{\"txid\":\"'+txid+'\",\"n\":'+str(n)+'}]}'\n+        json_string = http_get_call(url.hostname, url.port, '/rest/getutxos'+self.FORMAT_SEPARATOR+'json', json_request)\n+        json_obj = json.loads(json_string)\n+        \n+        #check chainTip response\n+        assert_equal(json_obj['chaintipHash'], bb_hash)\n+        \n+        #make sure there is one utxo\n+        assert_equal(len(json_obj['utxos']), 1)\n+        assert_equal(json_obj['utxos'][0]['value'], 0.1)\n+        \n+        \n+        ################################################\n+        # GETUTXOS: now query a already spent outpoint #\n+        ################################################\n+        json_request = '{\"checkmempool\":true,\"outpoints\":[{\"txid\":\"'+vintx+'\",\"n\":0}]}'\n+        json_string = http_get_call(url.hostname, url.port, '/rest/getutxos'+self.FORMAT_SEPARATOR+'json', json_request)\n+        json_obj = json.loads(json_string)\n+        \n+        #check chainTip response\n+        assert_equal(json_obj['chaintipHash'], bb_hash)\n+\n+        #make sure there is no utox in the response because this oupoint has been spent\n+        assert_equal(len(json_obj['utxos']), 0)\n+        \n+        #check bitmap\n+        assert_equal(json_obj['bitmap'], \"0\")\n+        \n+        \n+        ##################################################\n+        # GETUTXOS: now check both with the same request #\n+        ##################################################\n+        json_request = '{\"checkmempool\":true,\"outpoints\":[{\"txid\":\"'+txid+'\",\"n\":'+str(n)+'},{\"txid\":\"'+vintx+'\",\"n\":0}]}'\n+        json_string = http_get_call(url.hostname, url.port, '/rest/getutxos'+self.FORMAT_SEPARATOR+'json', json_request)\n+        json_obj = json.loads(json_string)\n+        assert_equal(len(json_obj['utxos']), 1)\n+        assert_equal(json_obj['bitmap'], \"10\")\n+        \n+        #test binary response\n         bb_hash = self.nodes[0].getbestblockhash()\n \n+        binaryRequest = b'\\x01\\x02'\n+        binaryRequest += binascii.unhexlify(txid)\n+        binaryRequest += pack(\"i\", n);\n+        binaryRequest += binascii.unhexlify(vintx);\n+        binaryRequest += pack(\"i\", 0);\n+        \n+        bin_response = http_get_call(url.hostname, url.port, '/rest/getutxos'+self.FORMAT_SEPARATOR+'bin', binaryRequest)\n+        \n+        output = StringIO.StringIO()\n+        output.write(bin_response)\n+        output.seek(0)\n+        chainHeight = unpack(\"i\", output.read(4))[0]\n+        hashFromBinResponse = hex(deser_uint256(output))[2:].zfill(65).rstrip(\"L\")\n+        \n+        assert_equal(bb_hash, hashFromBinResponse) #check if getutxo's chaintip during calculation was fine\n+        assert_equal(chainHeight, 102) #chain height must be 102\n+        \n+        \n+        ############################\n+        # GETUTXOS: mempool checks #\n+        ############################\n+\n+        # do a tx and don't sync\n+        txid = self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 0.1)\n+        json_string = http_get_call(url.hostname, url.port, '/rest/tx/'+txid+self.FORMAT_SEPARATOR+\"json\")\n+        json_obj = json.loads(json_string)\n+        vintx = json_obj['vin'][0]['txid'] # get the vin to later check for utxo (should be spent by then)\n+        # get n of 0.1 outpoint \n+        n = 0\n+        for vout in json_obj['vout']:\n+            if vout['value'] == 0.1:\n+                n = vout['n']\n+        \n+        json_request = '{\"checkmempool\":false,\"outpoints\":[{\"txid\":\"'+txid+'\",\"n\":'+str(n)+'}]}'\n+        json_string = http_get_call(url.hostname, url.port, '/rest/getutxos'+self.FORMAT_SEPARATOR+'json', json_request)\n+        json_obj = json.loads(json_string)\n+        assert_equal(len(json_obj['utxos']), 0) #there should be a outpoint because it has just added to the mempool\n+        \n+        json_request = '{\"checkmempool\":true,\"outpoints\":[{\"txid\":\"'+txid+'\",\"n\":'+str(n)+'}]}'\n+        json_string = http_get_call(url.hostname, url.port, '/rest/getutxos'+self.FORMAT_SEPARATOR+'json', json_request)\n+        json_obj = json.loads(json_string)\n+        assert_equal(len(json_obj['utxos']), 1) #there should be a outpoint because it has just added to the mempool\n+        \n+        #do some invalid requests\n+        json_request = '{\"checkmempool'\n+        response = http_get_call(url.hostname, url.port, '/rest/getutxos'+self.FORMAT_SEPARATOR+'json', json_request, True)\n+        assert_equal(response.status, 500) #must be a 500 because we send a invalid json request\n+        \n+        json_request = '{\"checkmempool'\n+        response = http_get_call(url.hostname, url.port, '/rest/getutxos'+self.FORMAT_SEPARATOR+'bin', json_request, True)\n+        assert_equal(response.status, 500) #must be a 500 because we send a invalid bin request\n+        \n+        #test limits\n+        json_request = '{\"checkmempool\":true,\"outpoints\":['\n+        for x in range(0, 200):\n+            json_request += '{\"txid\":\"'+txid+'\",\"n\":'+str(n)+'},'\n+        json_request = json_request.rstrip(\",\")\n+        json_request+=\"]}\";\n+        response = http_get_call(url.hostname, url.port, '/rest/getutxos'+self.FORMAT_SEPARATOR+'json', json_request, True)\n+        assert_equal(response.status, 500) #must be a 500 because we exceeding the limits\n+        \n+        json_request = '{\"checkmempool\":true,\"outpoints\":['\n+        for x in range(0, 90):\n+            json_request += '{\"txid\":\"'+txid+'\",\"n\":'+str(n)+'},'\n+        json_request = json_request.rstrip(\",\")\n+        json_request+=\"]}\";\n+        response = http_get_call(url.hostname, url.port, '/rest/getutxos'+self.FORMAT_SEPARATOR+'json', json_request, True)\n+        assert_equal(response.status, 200) #must be a 500 because we exceeding the limits\n+\n+        self.nodes[0].setgenerate(True, 1) #generate block to not affect upcomming tests\n+        self.sync_all()\n+        \n+        ################\n+        # /rest/block/ #\n+        ################\n+        \n         # check binary format\n-        response = http_get_call(url.hostname, url.port, '/rest/block/'+bb_hash+self.FORMAT_SEPARATOR+\"bin\", True)\n+        response = http_get_call(url.hostname, url.port, '/rest/block/'+bb_hash+self.FORMAT_SEPARATOR+\"bin\", \"\", True)\n         assert_equal(response.status, 200)\n         assert_greater_than(int(response.getheader('content-length')), 80)\n         response_str = response.read()\n \n         # compare with block header\n-        response_header = http_get_call(url.hostname, url.port, '/rest/headers/1/'+bb_hash+self.FORMAT_SEPARATOR+\"bin\", True)\n+        response_header = http_get_call(url.hostname, url.port, '/rest/headers/1/'+bb_hash+self.FORMAT_SEPARATOR+\"bin\", \"\", True)\n         assert_equal(response_header.status, 200)\n         assert_equal(int(response_header.getheader('content-length')), 80)\n         response_header_str = response_header.read()\n         assert_equal(response_str[0:80], response_header_str)\n \n         # check block hex format\n-        response_hex = http_get_call(url.hostname, url.port, '/rest/block/'+bb_hash+self.FORMAT_SEPARATOR+\"hex\", True)\n+        response_hex = http_get_call(url.hostname, url.port, '/rest/block/'+bb_hash+self.FORMAT_SEPARATOR+\"hex\", \"\", True)\n         assert_equal(response_hex.status, 200)\n         assert_greater_than(int(response_hex.getheader('content-length')), 160)\n         response_hex_str = response_hex.read()\n         assert_equal(response_str.encode(\"hex\")[0:160], response_hex_str[0:160])\n \n         # compare with hex block header\n-        response_header_hex = http_get_call(url.hostname, url.port, '/rest/headers/1/'+bb_hash+self.FORMAT_SEPARATOR+\"hex\", True)\n+        response_header_hex = http_get_call(url.hostname, url.port, '/rest/headers/1/'+bb_hash+self.FORMAT_SEPARATOR+\"hex\", \"\", True)\n         assert_equal(response_header_hex.status, 200)\n         assert_greater_than(int(response_header_hex.getheader('content-length')), 160)\n         response_header_hex_str = response_header_hex.read()\n@@ -77,9 +245,11 @@ def run_test(self):\n         assert_equal(json_obj['txid'], tx_hash)\n \n         # check hex format response\n-        hex_string = http_get_call(url.hostname, url.port, '/rest/tx/'+tx_hash+self.FORMAT_SEPARATOR+\"hex\", True)\n+        hex_string = http_get_call(url.hostname, url.port, '/rest/tx/'+tx_hash+self.FORMAT_SEPARATOR+\"hex\", \"\", True)\n         assert_equal(hex_string.status, 200)\n         assert_greater_than(int(response.getheader('content-length')), 10)\n+        \n+\n \n         # check block tx details\n         # let's make 3 tx and mine them on node 1"
      },
      {
        "sha": "78139682a64706cf06b32b2b7aa72a39febf8bcd",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 227,
        "deletions": 17,
        "changes": 244,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/97ee8665497c78aff2f30c2f652b7afd376b5323/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/97ee8665497c78aff2f30c2f652b7afd376b5323/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=97ee8665497c78aff2f30c2f652b7afd376b5323",
        "patch": "@@ -9,14 +9,18 @@\n #include \"rpcserver.h\"\n #include \"streams.h\"\n #include \"sync.h\"\n+#include \"txmempool.h\"\n #include \"utilstrencodings.h\"\n #include \"version.h\"\n \n #include <boost/algorithm/string.hpp>\n+#include <boost/dynamic_bitset.hpp>\n \n using namespace std;\n using namespace json_spirit;\n \n+static const int MAX_GETUTXOS_OUTPOINTS = 100; //allow a max of 100 outpoints to be queried at once\n+\n enum RetFormat {\n     RF_UNDEF,\n     RF_BINARY,\n@@ -34,6 +38,22 @@ static const struct {\n       {RF_JSON, \"json\"},\n };\n \n+struct CCoin {\n+    uint32_t nTxVer; // Don't call this nVersion, that name has a special meaning inside IMPLEMENT_SERIALIZE\n+    uint32_t nHeight;\n+    CTxOut out;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n+        READWRITE(nTxVer);\n+        READWRITE(nHeight);\n+        READWRITE(out);\n+    }\n+};\n+\n class RestErr\n {\n public:\n@@ -43,6 +63,7 @@ class RestErr\n \n extern void TxToJSON(const CTransaction& tx, const uint256 hashBlock, Object& entry);\n extern Object blockToJSON(const CBlock& block, const CBlockIndex* blockindex, bool txDetails = false);\n+extern void ScriptPubKeyToJSON(const CScript& scriptPubKey, Object& out, bool fIncludeHex);\n \n static RestErr RESTERR(enum HTTPStatusCode status, string message)\n {\n@@ -90,12 +111,13 @@ static bool ParseHashStr(const string& strReq, uint256& v)\n }\n \n static bool rest_headers(AcceptedConnection* conn,\n-                         const std::string& strReq,\n+                         const std::string& strURIPart,\n+                         const std::string& strRequest,\n                          const std::map<std::string, std::string>& mapHeaders,\n                          bool fRun)\n {\n     vector<string> params;\n-    const RetFormat rf = ParseDataFormat(params, strReq);\n+    const RetFormat rf = ParseDataFormat(params, strURIPart);\n     vector<string> path;\n     boost::split(path, params[0], boost::is_any_of(\"/\"));\n \n@@ -153,13 +175,14 @@ static bool rest_headers(AcceptedConnection* conn,\n }\n \n static bool rest_block(AcceptedConnection* conn,\n-                       const std::string& strReq,\n+                       const std::string& strURIPart,\n+                       const std::string& strRequest,\n                        const std::map<std::string, std::string>& mapHeaders,\n                        bool fRun,\n                        bool showTxDetails)\n {\n     vector<string> params;\n-    const RetFormat rf = ParseDataFormat(params, strReq);\n+    const RetFormat rf = ParseDataFormat(params, strURIPart);\n \n     string hashStr = params[0];\n     uint256 hash;\n@@ -211,28 +234,31 @@ static bool rest_block(AcceptedConnection* conn,\n }\n \n static bool rest_block_extended(AcceptedConnection* conn,\n-                       const std::string& strReq,\n+                       const std::string& strURIPart,\n+                       const std::string& strRequest,\n                        const std::map<std::string, std::string>& mapHeaders,\n                        bool fRun)\n {\n-    return rest_block(conn, strReq, mapHeaders, fRun, true);\n+    return rest_block(conn, strURIPart, strRequest, mapHeaders, fRun, true);\n }\n \n static bool rest_block_notxdetails(AcceptedConnection* conn,\n-                       const std::string& strReq,\n+                       const std::string& strURIPart,\n+                       const std::string& strRequest,\n                        const std::map<std::string, std::string>& mapHeaders,\n                        bool fRun)\n {\n-    return rest_block(conn, strReq, mapHeaders, fRun, false);\n+    return rest_block(conn, strURIPart, strRequest, mapHeaders, fRun, false);\n }\n \n static bool rest_chaininfo(AcceptedConnection* conn,\n-                                   const std::string& strReq,\n-                                   const std::map<std::string, std::string>& mapHeaders,\n-                                   bool fRun)\n+                           const std::string& strURIPart,\n+                           const std::string& strRequest,\n+                           const std::map<std::string, std::string>& mapHeaders,\n+                           bool fRun)\n {\n     vector<string> params;\n-    const RetFormat rf = ParseDataFormat(params, strReq);\n+    const RetFormat rf = ParseDataFormat(params, strURIPart);\n     \n     switch (rf) {\n     case RF_JSON: {\n@@ -253,12 +279,13 @@ static bool rest_chaininfo(AcceptedConnection* conn,\n }\n \n static bool rest_tx(AcceptedConnection* conn,\n-                    const std::string& strReq,\n+                    const std::string& strURIPart,\n+                    const std::string& strRequest,\n                     const std::map<std::string, std::string>& mapHeaders,\n                     bool fRun)\n {\n     vector<string> params;\n-    const RetFormat rf = ParseDataFormat(params, strReq);\n+    const RetFormat rf = ParseDataFormat(params, strURIPart);\n \n     string hashStr = params[0];\n     uint256 hash;\n@@ -303,10 +330,191 @@ static bool rest_tx(AcceptedConnection* conn,\n     return true; // continue to process further HTTP reqs on this cxn\n }\n \n+static bool rest_getutxos(AcceptedConnection* conn,\n+                          const std::string& strURIPart,\n+                          const std::string& strRequest,\n+                          const std::map<std::string, std::string>& mapHeaders,\n+                          bool fRun)\n+{\n+    vector<string> params;\n+    enum RetFormat rf = ParseDataFormat(params, strURIPart);\n+\n+    // throw exception in case of a empty request\n+    if (strRequest.length() == 0)\n+        throw RESTERR(HTTP_INTERNAL_SERVER_ERROR, \"Error: empty request\");\n+\n+    bool fCheckMemPool = false;\n+    vector<COutPoint> vOutPoints;\n+\n+    // parse/deserialize input\n+    // input-format = output-format, rest/getutxos/bin requires binary input, gives binary output, ...\n+    \n+    string strRequestMutable = strRequest; //convert const string to string for allowing hex to bin converting\n+    \n+    switch (rf) {\n+    case RF_HEX: {\n+        // convert hex to bin, continue then with bin part\n+        std::vector<unsigned char> strRequestV = ParseHex(strRequest);\n+        strRequestMutable.assign(strRequestV.begin(), strRequestV.end());\n+    }\n+\n+    case RF_BINARY: {\n+        try {\n+            //deserialize\n+            CDataStream oss(SER_NETWORK, PROTOCOL_VERSION);\n+            oss << strRequestMutable;\n+            oss >> fCheckMemPool;\n+            oss >> vOutPoints;\n+        } catch (const std::ios_base::failure& e) {\n+            // abort in case of unreadable binary data\n+            throw RESTERR(HTTP_INTERNAL_SERVER_ERROR, \"Parse error\");\n+        }\n+        break;\n+    }\n+\n+    case RF_JSON: {\n+        try {\n+            // parse json request\n+            Value valRequest;\n+            if (!read_string(strRequest, valRequest))\n+                throw RESTERR(HTTP_INTERNAL_SERVER_ERROR, \"Parse error\");\n+\n+            Object jsonObject = valRequest.get_obj();\n+            const Value& checkMempoolValue = find_value(jsonObject, \"checkmempool\");\n+\n+            if (!checkMempoolValue.is_null()) {\n+                fCheckMemPool = checkMempoolValue.get_bool();\n+            }\n+            const Value& outpointsValue = find_value(jsonObject, \"outpoints\");\n+            if (!outpointsValue.is_null()) {\n+                Array outPoints = outpointsValue.get_array();\n+                BOOST_FOREACH (const Value& outPoint, outPoints) {\n+                    Object outpointObject = outPoint.get_obj();\n+                    uint256 txid = ParseHashO(outpointObject, \"txid\");\n+                    Value nValue = find_value(outpointObject, \"n\");\n+                    int nOutput = nValue.get_int();\n+                    vOutPoints.push_back(COutPoint(txid, nOutput));\n+                }\n+            }\n+        } catch (...) {\n+            // return HTTP 500 if there was a json parsing error\n+            throw RESTERR(HTTP_INTERNAL_SERVER_ERROR, \"Parse error\");\n+        }\n+        break;\n+    }\n+    default: {\n+        throw RESTERR(HTTP_NOT_FOUND, \"output format not found (available: \" + AvailableDataFormatsString() + \")\");\n+    }\n+    }\n+\n+    // limit max outpoints\n+    if (vOutPoints.size() > MAX_GETUTXOS_OUTPOINTS)\n+        throw RESTERR(HTTP_INTERNAL_SERVER_ERROR, strprintf(\"Error: max outpoints exceeded (max: %d, tried: %d)\", MAX_GETUTXOS_OUTPOINTS, vOutPoints.size()));\n+\n+    // check spentness and form a bitmap (as well as a JSON capable human-readble string representation)\n+    vector<unsigned char> bitmap;\n+    vector<CCoin> outs;\n+    std::string bitmapStringRepresentation;\n+    boost::dynamic_bitset<unsigned char> hits(vOutPoints.size());\n+    {\n+        LOCK2(cs_main, mempool.cs);\n+\n+        CCoinsView viewDummy;\n+        CCoinsViewCache view(&viewDummy);\n+\n+        CCoinsViewCache& viewChain = *pcoinsTip;\n+        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+\n+        if (fCheckMemPool)\n+            view.SetBackend(viewMempool); // switch cache backend to db+mempool in case user likes to query mempool\n+\n+        for (size_t i = 0; i < vOutPoints.size(); i++) {\n+            CCoins coins;\n+            uint256 hash = vOutPoints[i].hash;\n+            if (view.GetCoins(hash, coins)) {\n+                mempool.pruneSpent(hash, coins);\n+                if (coins.IsAvailable(vOutPoints[i].n)) {\n+                    hits[i] = true;\n+                    // Safe to index into vout here because IsAvailable checked if it's off the end of the array, or if\n+                    // n is valid but points to an already spent output (IsNull).\n+                    CCoin coin;\n+                    coin.nTxVer = coins.nVersion;\n+                    coin.nHeight = coins.nHeight;\n+                    coin.out = coins.vout.at(vOutPoints[i].n);\n+                    assert(!coin.out.IsNull());\n+                    outs.push_back(coin);\n+                }\n+            }\n+\n+            bitmapStringRepresentation.append(hits[i] ? \"1\" : \"0\"); // form a binary string representation (human-readable for json output)\n+        }\n+    }\n+    boost::to_block_range(hits, std::back_inserter(bitmap));\n+\n+    switch (rf) {\n+    case RF_BINARY: {\n+        // serialize data\n+        // use exact same output as mentioned in Bip64\n+        CDataStream ssGetUTXOResponse(SER_NETWORK, PROTOCOL_VERSION);\n+        ssGetUTXOResponse << chainActive.Height() << chainActive.Tip()->GetBlockHash() << bitmap << outs;\n+        string ssGetUTXOResponseString = ssGetUTXOResponse.str();\n+\n+        conn->stream() << HTTPReplyHeader(HTTP_OK, fRun, ssGetUTXOResponseString.size(), \"application/octet-stream\") << ssGetUTXOResponseString << std::flush;\n+        return true;\n+    }\n+\n+    case RF_HEX: {\n+        CDataStream ssGetUTXOResponse(SER_NETWORK, PROTOCOL_VERSION);\n+        ssGetUTXOResponse << chainActive.Height() << chainActive.Tip()->GetBlockHash() << bitmap << outs;\n+        string strHex = HexStr(ssGetUTXOResponse.begin(), ssGetUTXOResponse.end()) + \"\\n\";\n+\n+        conn->stream() << HTTPReply(HTTP_OK, strHex, fRun, false, \"text/plain\") << std::flush;\n+        return true;\n+    }\n+\n+    case RF_JSON: {\n+        Object objGetUTXOResponse;\n+\n+        // pack in some essentials\n+        // use more or less the same output as mentioned in Bip64\n+        objGetUTXOResponse.push_back(Pair(\"chainHeight\", chainActive.Height()));\n+        objGetUTXOResponse.push_back(Pair(\"chaintipHash\", chainActive.Tip()->GetBlockHash().GetHex()));\n+        objGetUTXOResponse.push_back(Pair(\"bitmap\", bitmapStringRepresentation));\n+\n+        Array utxos;\n+        BOOST_FOREACH (const CCoin& coin, outs) {\n+            Object utxo;\n+            utxo.push_back(Pair(\"txvers\", (int32_t)coin.nTxVer));\n+            utxo.push_back(Pair(\"height\", (int32_t)coin.nHeight));\n+            utxo.push_back(Pair(\"value\", ValueFromAmount(coin.out.nValue)));\n+\n+            // include the script in a json output\n+            Object o;\n+            ScriptPubKeyToJSON(coin.out.scriptPubKey, o, true);\n+            utxo.push_back(Pair(\"scriptPubKey\", o));\n+            utxos.push_back(utxo);\n+        }\n+        objGetUTXOResponse.push_back(Pair(\"utxos\", utxos));\n+\n+        // return json string\n+        string strJSON = write_string(Value(objGetUTXOResponse), false) + \"\\n\";\n+        conn->stream() << HTTPReply(HTTP_OK, strJSON, fRun) << std::flush;\n+        return true;\n+    }\n+    default: {\n+        throw RESTERR(HTTP_NOT_FOUND, \"output format not found (available: \" + AvailableDataFormatsString() + \")\");\n+    }\n+    }\n+\n+    // not reached\n+    return true; // continue to process further HTTP reqs on this cxn\n+}\n+\n static const struct {\n     const char* prefix;\n     bool (*handler)(AcceptedConnection* conn,\n-                    const std::string& strURI,\n+                    const std::string& strURIPart,\n+                    const std::string& strRequest,\n                     const std::map<std::string, std::string>& mapHeaders,\n                     bool fRun);\n } uri_prefixes[] = {\n@@ -315,10 +523,12 @@ static const struct {\n       {\"/rest/block/\", rest_block_extended},\n       {\"/rest/chaininfo\", rest_chaininfo},\n       {\"/rest/headers/\", rest_headers},\n+      {\"/rest/getutxos\", rest_getutxos},\n };\n \n bool HTTPReq_REST(AcceptedConnection* conn,\n                   const std::string& strURI,\n+                  const string& strRequest,\n                   const std::map<std::string, std::string>& mapHeaders,\n                   bool fRun)\n {\n@@ -330,8 +540,8 @@ bool HTTPReq_REST(AcceptedConnection* conn,\n         for (unsigned int i = 0; i < ARRAYLEN(uri_prefixes); i++) {\n             unsigned int plen = strlen(uri_prefixes[i].prefix);\n             if (strURI.substr(0, plen) == uri_prefixes[i].prefix) {\n-                string strReq = strURI.substr(plen);\n-                return uri_prefixes[i].handler(conn, strReq, mapHeaders, fRun);\n+                string strURIPart = strURI.substr(plen);\n+                return uri_prefixes[i].handler(conn, strURIPart, strRequest, mapHeaders, fRun);\n             }\n         }\n     } catch (const RestErr& re) {"
      },
      {
        "sha": "254eea833e8cbf621e86e5f8e54fafa54b8d712d",
        "filename": "src/rpcserver.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/97ee8665497c78aff2f30c2f652b7afd376b5323/src/rpcserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/97ee8665497c78aff2f30c2f652b7afd376b5323/src/rpcserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcserver.cpp?ref=97ee8665497c78aff2f30c2f652b7afd376b5323",
        "patch": "@@ -992,7 +992,7 @@ void ServiceConnection(AcceptedConnection *conn)\n \n         // Process via HTTP REST API\n         } else if (strURI.substr(0, 6) == \"/rest/\" && GetBoolArg(\"-rest\", false)) {\n-            if (!HTTPReq_REST(conn, strURI, mapHeaders, fRun))\n+            if (!HTTPReq_REST(conn, strURI, strRequest, mapHeaders, fRun))\n                 break;\n \n         } else {"
      },
      {
        "sha": "8dcad261061e3be0380692c5fdba8b22976ba833",
        "filename": "src/rpcserver.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/97ee8665497c78aff2f30c2f652b7afd376b5323/src/rpcserver.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/97ee8665497c78aff2f30c2f652b7afd376b5323/src/rpcserver.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcserver.h?ref=97ee8665497c78aff2f30c2f652b7afd376b5323",
        "patch": "@@ -237,6 +237,7 @@ extern json_spirit::Value reconsiderblock(const json_spirit::Array& params, bool\n // in rest.cpp\n extern bool HTTPReq_REST(AcceptedConnection *conn,\n                   const std::string& strURI,\n+                  const std::string& strRequest,\n                   const std::map<std::string, std::string>& mapHeaders,\n                   bool fRun);\n "
      }
    ]
  },
  {
    "sha": "6b4feb89a81a6f166f13ecf480d18ccea5ff462e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2YjRmZWI4OWE4MWE2ZjE2NmYxM2VjZjQ4MGQxOGNjZWE1ZmY0NjJl",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-04-21T18:32:37Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-04-21T18:33:02Z"
      },
      "message": "[QA] rest.py RPC test: change setgenerate() to generate()",
      "tree": {
        "sha": "30ec3a5b9f51c9161864159dae87eec5587e6c09",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/30ec3a5b9f51c9161864159dae87eec5587e6c09"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6b4feb89a81a6f166f13ecf480d18ccea5ff462e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6b4feb89a81a6f166f13ecf480d18ccea5ff462e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6b4feb89a81a6f166f13ecf480d18ccea5ff462e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6b4feb89a81a6f166f13ecf480d18ccea5ff462e/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "97ee8665497c78aff2f30c2f652b7afd376b5323",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/97ee8665497c78aff2f30c2f652b7afd376b5323",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/97ee8665497c78aff2f30c2f652b7afd376b5323"
      }
    ],
    "stats": {
      "total": 15,
      "additions": 11,
      "deletions": 4
    },
    "files": [
      {
        "sha": "830445af73adee01401c0a31cc97196bb65273e0",
        "filename": "doc/REST-interface.md",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b4feb89a81a6f166f13ecf480d18ccea5ff462e/doc/REST-interface.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b4feb89a81a6f166f13ecf480d18ccea5ff462e/doc/REST-interface.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/REST-interface.md?ref=6b4feb89a81a6f166f13ecf480d18ccea5ff462e",
        "patch": "@@ -34,6 +34,13 @@ Only supports JSON as output format.\n * verificationprogress : (numeric) estimate of verification progress [0..1]\n * chainwork : (string) total amount of work in active chain, in hexadecimal\n \n+`GET /rest/getutxos`\n+\n+The getutxo command allows querying of the UTXO set given a set of of outpoints.\n+See BIP64 for input and output serialisation:\n+https://github.com/bitcoin/bips/blob/master/bip-0064.mediawiki\n+\n+\n Risks\n -------------\n Running a webbrowser on the same node with a REST enabled bitcoind can be a risk. Accessing prepared XSS websites could read out tx/block data of your node by placing links like `<script src=\"http://127.0.0.1:8332/rest/tx/1234567890.json\">` which might break the nodes privacy."
      },
      {
        "sha": "9f0d049fe926c16788bfd399e9dce13adbeda69b",
        "filename": "qa/rpc-tests/rest.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b4feb89a81a6f166f13ecf480d18ccea5ff462e/qa/rpc-tests/rest.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b4feb89a81a6f166f13ecf480d18ccea5ff462e/qa/rpc-tests/rest.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/rest.py?ref=6b4feb89a81a6f166f13ecf480d18ccea5ff462e",
        "patch": "@@ -59,16 +59,16 @@ def run_test(self):\n         url = urlparse.urlparse(self.nodes[0].url)\n         print \"Mining blocks...\"\n         \n-        self.nodes[0].setgenerate(True, 1)\n+        self.nodes[0].generate(1)\n         self.sync_all()\n-        self.nodes[2].setgenerate(True, 100)\n+        self.nodes[2].generate(100)\n         self.sync_all()\n         \n         assert_equal(self.nodes[0].getbalance(), 50)\n         \n         txid = self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 0.1)\n         self.sync_all()\n-        self.nodes[2].setgenerate(True, 1)\n+        self.nodes[2].generate(1)\n         self.sync_all()\n         bb_hash = self.nodes[0].getbestblockhash()\n         \n@@ -198,7 +198,7 @@ def run_test(self):\n         response = http_get_call(url.hostname, url.port, '/rest/getutxos'+self.FORMAT_SEPARATOR+'json', json_request, True)\n         assert_equal(response.status, 200) #must be a 500 because we exceeding the limits\n \n-        self.nodes[0].setgenerate(True, 1) #generate block to not affect upcomming tests\n+        self.nodes[0].generate(1) #generate block to not affect upcomming tests\n         self.sync_all()\n         \n         ################"
      }
    ]
  }
]