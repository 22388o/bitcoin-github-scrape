[
  {
    "sha": "d69f51b92555f183eec5c515529eac86f3e63e41",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkNjlmNTFiOTI1NTVmMTgzZWVjNWM1MTU1MjllYWM4NmYzZTYzZTQx",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2020-04-03T01:22:04Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-04-12T01:42:01Z"
      },
      "message": "Introduce Instruction enum in asmap",
      "tree": {
        "sha": "b02b33a11788b880bf9fe7f7b13fcaa75858d960",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b02b33a11788b880bf9fe7f7b13fcaa75858d960"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d69f51b92555f183eec5c515529eac86f3e63e41",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d69f51b92555f183eec5c515529eac86f3e63e41",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d69f51b92555f183eec5c515529eac86f3e63e41",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d69f51b92555f183eec5c515529eac86f3e63e41/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a5623ba89f050182ce9b1f570f3736b272b544b2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a5623ba89f050182ce9b1f570f3736b272b544b2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a5623ba89f050182ce9b1f570f3736b272b544b2"
      }
    ],
    "stats": {
      "total": 23,
      "additions": 16,
      "deletions": 7
    },
    "files": [
      {
        "sha": "2ffd61820346b4cfef4664a697fb144d7452aa03",
        "filename": "src/util/asmap.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 7,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d69f51b92555f183eec5c515529eac86f3e63e41/src/util/asmap.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d69f51b92555f183eec5c515529eac86f3e63e41/src/util/asmap.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/asmap.cpp?ref=d69f51b92555f183eec5c515529eac86f3e63e41",
        "patch": "@@ -36,10 +36,18 @@ uint32_t DecodeBits(std::vector<bool>::const_iterator& bitpos, const std::vector\n     return -1;\n }\n \n+enum class Instruction : uint32_t\n+{\n+    RETURN = 0,\n+    JUMP = 1,\n+    MATCH = 2,\n+    DEFAULT = 3,\n+};\n+\n const std::vector<uint8_t> TYPE_BIT_SIZES{0, 0, 1};\n-uint32_t DecodeType(std::vector<bool>::const_iterator& bitpos, const std::vector<bool>::const_iterator& endpos)\n+Instruction DecodeType(std::vector<bool>::const_iterator& bitpos, const std::vector<bool>::const_iterator& endpos)\n {\n-    return DecodeBits(bitpos, endpos, 0, TYPE_BIT_SIZES);\n+    return Instruction(DecodeBits(bitpos, endpos, 0, TYPE_BIT_SIZES));\n }\n \n const std::vector<uint8_t> ASN_BIT_SIZES{15, 16, 17, 18, 19, 20, 21, 22, 23, 24};\n@@ -70,20 +78,21 @@ uint32_t Interpret(const std::vector<bool> &asmap, const std::vector<bool> &ip)\n     const std::vector<bool>::const_iterator endpos = asmap.end();\n     uint8_t bits = ip.size();\n     uint32_t default_asn = 0;\n-    uint32_t opcode, jump, match, matchlen;\n+    uint32_t jump, match, matchlen;\n+    Instruction opcode;\n     while (pos != endpos) {\n         opcode = DecodeType(pos, endpos);\n-        if (opcode == 0) {\n+        if (opcode == Instruction::RETURN) {\n             return DecodeASN(pos, endpos);\n-        } else if (opcode == 1) {\n+        } else if (opcode == Instruction::JUMP) {\n             jump = DecodeJump(pos, endpos);\n             if (bits == 0) break;\n             if (ip[ip.size() - bits]) {\n                 if (jump >= endpos - pos) break;\n                 pos += jump;\n             }\n             bits--;\n-        } else if (opcode == 2) {\n+        } else if (opcode == Instruction::MATCH) {\n             match = DecodeMatch(pos, endpos);\n             matchlen = CountBits(match) - 1;\n             for (uint32_t bit = 0; bit < matchlen; bit++) {\n@@ -93,7 +102,7 @@ uint32_t Interpret(const std::vector<bool> &asmap, const std::vector<bool> &ip)\n                 }\n                 bits--;\n             }\n-        } else if (opcode == 3) {\n+        } else if (opcode == Instruction::DEFAULT) {\n             default_asn = DecodeASN(pos, endpos);\n         } else {\n             break;"
      }
    ]
  },
  {
    "sha": "9940be6f67cb2067e7ab049d9a9c4ca2f69a68f4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5OTQwYmU2ZjY3Y2IyMDY3ZTdhYjA0OWQ5YTljNGNhMmY2OWE2OGY0",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2020-04-03T17:43:38Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-04-12T01:42:01Z"
      },
      "message": "Deal with decoding failures explicitly in asmap Interpret",
      "tree": {
        "sha": "1721e2a701789da8825904fb50bf29619bdf5a16",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1721e2a701789da8825904fb50bf29619bdf5a16"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9940be6f67cb2067e7ab049d9a9c4ca2f69a68f4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9940be6f67cb2067e7ab049d9a9c4ca2f69a68f4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9940be6f67cb2067e7ab049d9a9c4ca2f69a68f4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9940be6f67cb2067e7ab049d9a9c4ca2f69a68f4/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d69f51b92555f183eec5c515529eac86f3e63e41",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d69f51b92555f183eec5c515529eac86f3e63e41",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d69f51b92555f183eec5c515529eac86f3e63e41"
      }
    ],
    "stats": {
      "total": 15,
      "additions": 11,
      "deletions": 4
    },
    "files": [
      {
        "sha": "5b21d01f3ac5bc0f3d50e54bd1c9c643d859abf5",
        "filename": "src/util/asmap.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 4,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9940be6f67cb2067e7ab049d9a9c4ca2f69a68f4/src/util/asmap.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9940be6f67cb2067e7ab049d9a9c4ca2f69a68f4/src/util/asmap.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/asmap.cpp?ref=9940be6f67cb2067e7ab049d9a9c4ca2f69a68f4",
        "patch": "@@ -8,6 +8,8 @@\n \n namespace {\n \n+constexpr uint32_t INVALID = 0xFFFFFFFF;\n+\n uint32_t DecodeBits(std::vector<bool>::const_iterator& bitpos, const std::vector<bool>::const_iterator& endpos, uint8_t minval, const std::vector<uint8_t> &bit_sizes)\n {\n     uint32_t val = minval;\n@@ -25,15 +27,15 @@ uint32_t DecodeBits(std::vector<bool>::const_iterator& bitpos, const std::vector\n             val += (1 << *bit_sizes_it);\n         } else {\n             for (int b = 0; b < *bit_sizes_it; b++) {\n-                if (bitpos == endpos) break;\n+                if (bitpos == endpos) return INVALID; // Reached EOF in mantissa\n                 bit = *bitpos;\n                 bitpos++;\n                 val += bit << (*bit_sizes_it - 1 - b);\n             }\n             return val;\n         }\n     }\n-    return -1;\n+    return INVALID; // Reached EOF in exponent\n }\n \n enum class Instruction : uint32_t\n@@ -83,9 +85,12 @@ uint32_t Interpret(const std::vector<bool> &asmap, const std::vector<bool> &ip)\n     while (pos != endpos) {\n         opcode = DecodeType(pos, endpos);\n         if (opcode == Instruction::RETURN) {\n-            return DecodeASN(pos, endpos);\n+            default_asn = DecodeASN(pos, endpos);\n+            if (default_asn == INVALID) break; // ASN straddles EOF\n+            return default_asn;\n         } else if (opcode == Instruction::JUMP) {\n             jump = DecodeJump(pos, endpos);\n+            if (jump == INVALID) break; // Jump offset straddles EOF\n             if (bits == 0) break;\n             if (ip[ip.size() - bits]) {\n                 if (jump >= endpos - pos) break;\n@@ -94,6 +99,7 @@ uint32_t Interpret(const std::vector<bool> &asmap, const std::vector<bool> &ip)\n             bits--;\n         } else if (opcode == Instruction::MATCH) {\n             match = DecodeMatch(pos, endpos);\n+            if (match == INVALID) break; // Match bits straddle EOF\n             matchlen = CountBits(match) - 1;\n             for (uint32_t bit = 0; bit < matchlen; bit++) {\n                 if (bits == 0) break;\n@@ -104,8 +110,9 @@ uint32_t Interpret(const std::vector<bool> &asmap, const std::vector<bool> &ip)\n             }\n         } else if (opcode == Instruction::DEFAULT) {\n             default_asn = DecodeASN(pos, endpos);\n+            if (default_asn == INVALID) break; // ASN straddles EOF\n         } else {\n-            break;\n+            break; // Instruction straddles EOF\n         }\n     }\n     return 0; // 0 is not a valid ASN"
      }
    ]
  },
  {
    "sha": "72a20f6db6a9e69b873daf3a81088fdea694b10f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3MmEyMGY2ZGI2YTllNjliODczZGFmM2E4MTA4OGZkZWE2OTRiMTBm",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2020-04-03T01:17:55Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-04-12T01:42:01Z"
      },
      "message": "Improve asmap Interpret checks and document failures",
      "tree": {
        "sha": "4dc1f425802fb2a6a7230996bb60e0289e6dd5bf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4dc1f425802fb2a6a7230996bb60e0289e6dd5bf"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/72a20f6db6a9e69b873daf3a81088fdea694b10f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/72a20f6db6a9e69b873daf3a81088fdea694b10f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/72a20f6db6a9e69b873daf3a81088fdea694b10f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/72a20f6db6a9e69b873daf3a81088fdea694b10f/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9940be6f67cb2067e7ab049d9a9c4ca2f69a68f4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9940be6f67cb2067e7ab049d9a9c4ca2f69a68f4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9940be6f67cb2067e7ab049d9a9c4ca2f69a68f4"
      }
    ],
    "stats": {
      "total": 7,
      "additions": 4,
      "deletions": 3
    },
    "files": [
      {
        "sha": "e428ec8138fd1ad7e47d52f884fe21ccfc2b21f9",
        "filename": "src/util/asmap.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/72a20f6db6a9e69b873daf3a81088fdea694b10f/src/util/asmap.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/72a20f6db6a9e69b873daf3a81088fdea694b10f/src/util/asmap.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/asmap.cpp?ref=72a20f6db6a9e69b873daf3a81088fdea694b10f",
        "patch": "@@ -91,18 +91,18 @@ uint32_t Interpret(const std::vector<bool> &asmap, const std::vector<bool> &ip)\n         } else if (opcode == Instruction::JUMP) {\n             jump = DecodeJump(pos, endpos);\n             if (jump == INVALID) break; // Jump offset straddles EOF\n-            if (bits == 0) break;\n+            if (bits == 0) break; // No input bits left\n+            if (jump >= endpos - pos) break; // Jumping past EOF\n             if (ip[ip.size() - bits]) {\n-                if (jump >= endpos - pos) break;\n                 pos += jump;\n             }\n             bits--;\n         } else if (opcode == Instruction::MATCH) {\n             match = DecodeMatch(pos, endpos);\n             if (match == INVALID) break; // Match bits straddle EOF\n             matchlen = CountBits(match) - 1;\n+            if (bits < matchlen) break; // Not enough input bits\n             for (uint32_t bit = 0; bit < matchlen; bit++) {\n-                if (bits == 0) break;\n                 if ((ip[ip.size() - bits]) != ((match >> (matchlen - 1 - bit)) & 1)) {\n                     return default_asn;\n                 }\n@@ -115,5 +115,6 @@ uint32_t Interpret(const std::vector<bool> &asmap, const std::vector<bool> &ip)\n             break; // Instruction straddles EOF\n         }\n     }\n+    // Reached EOF without RETURN, or aborted (see any of the breaks above).\n     return 0; // 0 is not a valid ASN\n }"
      }
    ]
  },
  {
    "sha": "868955528701cd0c9da80263110f768654c481b1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4Njg5NTU1Mjg3MDFjZDBjOWRhODAyNjMxMTBmNzY4NjU0YzQ4MWIx",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2020-04-03T01:18:08Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-04-12T01:42:01Z"
      },
      "message": "Add asmap sanity checker",
      "tree": {
        "sha": "ea72e1cef6ab9a6b402e5358815d1eda77a9f675",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ea72e1cef6ab9a6b402e5358815d1eda77a9f675"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/868955528701cd0c9da80263110f768654c481b1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/868955528701cd0c9da80263110f768654c481b1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/868955528701cd0c9da80263110f768654c481b1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/868955528701cd0c9da80263110f768654c481b1/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "72a20f6db6a9e69b873daf3a81088fdea694b10f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/72a20f6db6a9e69b873daf3a81088fdea694b10f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/72a20f6db6a9e69b873daf3a81088fdea694b10f"
      }
    ],
    "stats": {
      "total": 70,
      "additions": 70,
      "deletions": 0
    },
    "files": [
      {
        "sha": "b22ad6d641adf4276b98fff4dcc3247d691ae010",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/868955528701cd0c9da80263110f768654c481b1/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/868955528701cd0c9da80263110f768654c481b1/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=868955528701cd0c9da80263110f768654c481b1",
        "patch": "@@ -644,5 +644,9 @@ std::vector<bool> CAddrMan::DecodeAsmap(fs::path path)\n             bits.push_back((cur_byte >> bit) & 1);\n         }\n     }\n+    if (!SanityCheckASMap(bits)) {\n+        LogPrintf(\"Sanity check of asmap file %s failed\\n\", path);\n+        return {};\n+    }\n     return bits;\n }"
      },
      {
        "sha": "e0b27b1d7c00fc78ab912b5e820e0fb36ca64a8a",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/868955528701cd0c9da80263110f768654c481b1/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/868955528701cd0c9da80263110f768654c481b1/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=868955528701cd0c9da80263110f768654c481b1",
        "patch": "@@ -894,3 +894,8 @@ bool operator<(const CSubNet& a, const CSubNet& b)\n {\n     return (a.network < b.network || (a.network == b.network && memcmp(a.netmask, b.netmask, 16) < 0));\n }\n+\n+bool SanityCheckASMap(const std::vector<bool>& asmap)\n+{\n+    return SanityCheckASMap(asmap, 128); // For IP address lookups, the input is 128 bits\n+}"
      },
      {
        "sha": "ec06a588bf575c0aa4ebf6fd39c48a7405ea175d",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/868955528701cd0c9da80263110f768654c481b1/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/868955528701cd0c9da80263110f768654c481b1/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=868955528701cd0c9da80263110f768654c481b1",
        "patch": "@@ -180,4 +180,6 @@ class CService : public CNetAddr\n         }\n };\n \n+bool SanityCheckASMap(const std::vector<bool>& asmap);\n+\n #endif // BITCOIN_NETADDRESS_H"
      },
      {
        "sha": "5c3652f89b0052ae5b0c116b17d527b5b15fbe62",
        "filename": "src/util/asmap.cpp",
        "status": "modified",
        "additions": 54,
        "deletions": 0,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/868955528701cd0c9da80263110f768654c481b1/src/util/asmap.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/868955528701cd0c9da80263110f768654c481b1/src/util/asmap.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/asmap.cpp?ref=868955528701cd0c9da80263110f768654c481b1",
        "patch": "@@ -2,6 +2,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include <map>\n #include <vector>\n #include <assert.h>\n #include <crypto/common.h>\n@@ -118,3 +119,56 @@ uint32_t Interpret(const std::vector<bool> &asmap, const std::vector<bool> &ip)\n     // Reached EOF without RETURN, or aborted (see any of the breaks above).\n     return 0; // 0 is not a valid ASN\n }\n+\n+bool SanityCheckASMap(const std::vector<bool>& asmap, int bits)\n+{\n+    const std::vector<bool>::const_iterator begin = asmap.begin(), endpos = asmap.end();\n+    std::vector<bool>::const_iterator pos = begin;\n+    std::vector<std::pair<uint32_t, int>> jumps; // All future positions we may jump to (bit offset in asmap -> bits to consume left)\n+    jumps.reserve(bits);\n+    while (pos != endpos) {\n+        uint32_t offset = pos - begin;\n+        if (!jumps.empty() && offset >= jumps.back().first) return false; // There was a jump into the middle of the previous instruction\n+        Instruction opcode = DecodeType(pos, endpos);\n+        if (opcode == Instruction::RETURN) {\n+            uint32_t asn = DecodeASN(pos, endpos);\n+            if (asn == INVALID) return false; // ASN straddles EOF\n+            if (jumps.empty()) {\n+                // Nothing to execute anymore\n+                if (endpos - pos > 7) return false; // Excessive padding\n+                while (pos != endpos) {\n+                    if (*pos) return false; // Nonzero padding bit\n+                    ++pos;\n+                }\n+                return true; // Sanely reached EOF\n+            } else {\n+                // Continue by pretending we jumped to the next instruction\n+                offset = pos - begin;\n+                if (offset != jumps.back().first) return false; // Unreachable code\n+                bits = jumps.back().second; // Restore the number of bits we would have had left after this jump\n+                jumps.pop_back();\n+            }\n+        } else if (opcode == Instruction::JUMP) {\n+            uint32_t jump = DecodeJump(pos, endpos);\n+            if (jump == INVALID) return false; // Jump offset straddles EOF\n+            if (jump > endpos - pos) return false; // Jump out of range\n+            if (bits == 0) return false; // Consuming bits past the end of the input\n+            --bits;\n+            uint32_t jump_offset = pos - begin + jump;\n+            if (!jumps.empty() && jump_offset >= jumps.back().first) return false; // Intersecting jumps\n+            jumps.emplace_back(jump_offset, bits);\n+        } else if (opcode == Instruction::MATCH) {\n+            uint32_t match = DecodeMatch(pos, endpos);\n+            if (match == INVALID) return false; // Match bits straddle EOF\n+            int matchlen = CountBits(match) - 1;\n+            if (bits < matchlen) return false; // Consuming bits past the end of the input\n+            bits -= matchlen;\n+        } else if (opcode == Instruction::DEFAULT) {\n+            uint32_t asn = DecodeASN(pos, endpos);\n+            if (asn == INVALID) return false; // ASN straddles EOF\n+        } else {\n+            return false; // Instruction straddles EOF\n+        }\n+    }\n+    return false; // Reached EOF without RETURN instruction\n+}"
      },
      {
        "sha": "b31e639bb5d7187853302b9a014b1f9d48b75f89",
        "filename": "src/util/asmap.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/868955528701cd0c9da80263110f768654c481b1/src/util/asmap.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/868955528701cd0c9da80263110f768654c481b1/src/util/asmap.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/asmap.h?ref=868955528701cd0c9da80263110f768654c481b1",
        "patch": "@@ -5,6 +5,11 @@\n #ifndef BITCOIN_UTIL_ASMAP_H\n #define BITCOIN_UTIL_ASMAP_H\n \n+#include <stdint.h>\n+#include <vector>\n+\n uint32_t Interpret(const std::vector<bool> &asmap, const std::vector<bool> &ip);\n \n+bool SanityCheckASMap(const std::vector<bool>& asmap, int bits);\n+\n #endif // BITCOIN_UTIL_ASMAP_H"
      }
    ]
  },
  {
    "sha": "d01cfa80ac7f674aa64881014637e733c66c294f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkMDFjZmE4MGFjN2Y2NzRhYTY0ODgxMDE0NjM3ZTczM2M2NmMyOTRm",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2020-04-03T18:09:21Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-04-12T01:42:01Z"
      },
      "message": "Add additional effiency checks to sanity checker",
      "tree": {
        "sha": "c3576342dbfdd8d1636dd8417da521e401089f26",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c3576342dbfdd8d1636dd8417da521e401089f26"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d01cfa80ac7f674aa64881014637e733c66c294f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d01cfa80ac7f674aa64881014637e733c66c294f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d01cfa80ac7f674aa64881014637e733c66c294f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d01cfa80ac7f674aa64881014637e733c66c294f/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "868955528701cd0c9da80263110f768654c481b1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/868955528701cd0c9da80263110f768654c481b1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/868955528701cd0c9da80263110f768654c481b1"
      }
    ],
    "stats": {
      "total": 11,
      "additions": 11,
      "deletions": 0
    },
    "files": [
      {
        "sha": "5f3f53c3936002e2614f55d63c662fe13953dcc3",
        "filename": "src/util/asmap.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d01cfa80ac7f674aa64881014637e733c66c294f/src/util/asmap.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d01cfa80ac7f674aa64881014637e733c66c294f/src/util/asmap.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/asmap.cpp?ref=d01cfa80ac7f674aa64881014637e733c66c294f",
        "patch": "@@ -126,11 +126,14 @@ bool SanityCheckASMap(const std::vector<bool>& asmap, int bits)\n     std::vector<bool>::const_iterator pos = begin;\n     std::vector<std::pair<uint32_t, int>> jumps; // All future positions we may jump to (bit offset in asmap -> bits to consume left)\n     jumps.reserve(bits);\n+    Instruction prevopcode = Instruction::JUMP;\n+    bool had_incomplete_match = false;\n     while (pos != endpos) {\n         uint32_t offset = pos - begin;\n         if (!jumps.empty() && offset >= jumps.back().first) return false; // There was a jump into the middle of the previous instruction\n         Instruction opcode = DecodeType(pos, endpos);\n         if (opcode == Instruction::RETURN) {\n+            if (prevopcode == Instruction::DEFAULT) return false; // There should not be any RETURN immediately after a DEFAULT (could be combined into just RETURN)\n             uint32_t asn = DecodeASN(pos, endpos);\n             if (asn == INVALID) return false; // ASN straddles EOF\n             if (jumps.empty()) {\n@@ -147,6 +150,7 @@ bool SanityCheckASMap(const std::vector<bool>& asmap, int bits)\n                 if (offset != jumps.back().first) return false; // Unreachable code\n                 bits = jumps.back().second; // Restore the number of bits we would have had left after this jump\n                 jumps.pop_back();\n+                prevopcode = Instruction::JUMP;\n             }\n         } else if (opcode == Instruction::JUMP) {\n             uint32_t jump = DecodeJump(pos, endpos);\n@@ -157,15 +161,22 @@ bool SanityCheckASMap(const std::vector<bool>& asmap, int bits)\n             uint32_t jump_offset = pos - begin + jump;\n             if (!jumps.empty() && jump_offset >= jumps.back().first) return false; // Intersecting jumps\n             jumps.emplace_back(jump_offset, bits);\n+            prevopcode = Instruction::JUMP;\n         } else if (opcode == Instruction::MATCH) {\n             uint32_t match = DecodeMatch(pos, endpos);\n             if (match == INVALID) return false; // Match bits straddle EOF\n             int matchlen = CountBits(match) - 1;\n+            if (prevopcode != Instruction::MATCH) had_incomplete_match = false;\n+            if (matchlen < 8 && had_incomplete_match) return false; // Within a sequence of matches only at most one should be incomplete\n+            had_incomplete_match = (matchlen < 8);\n             if (bits < matchlen) return false; // Consuming bits past the end of the input\n             bits -= matchlen;\n+            prevopcode = Instruction::MATCH;\n         } else if (opcode == Instruction::DEFAULT) {\n+            if (prevopcode == Instruction::DEFAULT) return false; // There should not be two successive DEFAULTs (they could be combined into one)\n             uint32_t asn = DecodeASN(pos, endpos);\n             if (asn == INVALID) return false; // ASN straddles EOF\n+            prevopcode = Instruction::DEFAULT;\n         } else {\n             return false; // Instruction straddles EOF\n         }"
      }
    ]
  },
  {
    "sha": "9c31523e9e0b754ff023981e00c2eb8493189abd",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5YzMxNTIzZTllMGI3NTRmZjAyMzk4MWUwMGMyZWI4NDkzMTg5YWJk",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2020-04-03T20:32:34Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-04-12T01:42:01Z"
      },
      "message": "Make asmap Interpreter errors fatal and fuzz test it",
      "tree": {
        "sha": "0da833292406a8d3587d2f25643cf568784ec914",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0da833292406a8d3587d2f25643cf568784ec914"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9c31523e9e0b754ff023981e00c2eb8493189abd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9c31523e9e0b754ff023981e00c2eb8493189abd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9c31523e9e0b754ff023981e00c2eb8493189abd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9c31523e9e0b754ff023981e00c2eb8493189abd/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d01cfa80ac7f674aa64881014637e733c66c294f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d01cfa80ac7f674aa64881014637e733c66c294f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d01cfa80ac7f674aa64881014637e733c66c294f"
      }
    ],
    "stats": {
      "total": 47,
      "additions": 34,
      "deletions": 13
    },
    "files": [
      {
        "sha": "ea56277eacff36201617b165d0daa1b10e4a5bf7",
        "filename": "src/test/fuzz/asmap.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 12,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9c31523e9e0b754ff023981e00c2eb8493189abd/src/test/fuzz/asmap.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9c31523e9e0b754ff023981e00c2eb8493189abd/src/test/fuzz/asmap.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/asmap.cpp?ref=9c31523e9e0b754ff023981e00c2eb8493189abd",
        "patch": "@@ -3,26 +3,47 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <netaddress.h>\n-#include <test/fuzz/FuzzedDataProvider.h>\n #include <test/fuzz/fuzz.h>\n \n #include <cstdint>\n #include <vector>\n \n+//! asmap code that consumes nothing\n+static const std::vector<bool> IPV6_PREFIX_ASMAP = {};\n+\n+//! asmap code that consumes the 96 prefix bits of ::ffff:0/96 (IPv4-in-IPv6 map)\n+static const std::vector<bool> IPV4_PREFIX_ASMAP = {\n+    true, true, false, true, true, true, true, true, true, true, false, false, false, false, false, false, false, false, // Match 0x00\n+    true, true, false, true, true, true, true, true, true, true, false, false, false, false, false, false, false, false, // Match 0x00\n+    true, true, false, true, true, true, true, true, true, true, false, false, false, false, false, false, false, false, // Match 0x00\n+    true, true, false, true, true, true, true, true, true, true, false, false, false, false, false, false, false, false, // Match 0x00\n+    true, true, false, true, true, true, true, true, true, true, false, false, false, false, false, false, false, false, // Match 0x00\n+    true, true, false, true, true, true, true, true, true, true, false, false, false, false, false, false, false, false, // Match 0x00\n+    true, true, false, true, true, true, true, true, true, true, false, false, false, false, false, false, false, false, // Match 0x00\n+    true, true, false, true, true, true, true, true, true, true, false, false, false, false, false, false, false, false, // Match 0x00\n+    true, true, false, true, true, true, true, true, true, true, false, false, false, false, false, false, false, false, // Match 0x00\n+    true, true, false, true, true, true, true, true, true, true, false, false, false, false, false, false, false, false, // Match 0x00\n+    true, true, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, // Match 0xFF\n+    true, true, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true // Match 0xFF\n+};\n+\n void test_one_input(const std::vector<uint8_t>& buffer)\n {\n-    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n-    const Network network = fuzzed_data_provider.PickValueInArray({NET_IPV4, NET_IPV6});\n-    if (fuzzed_data_provider.remaining_bytes() < 16) {\n-        return;\n-    }\n-    CNetAddr net_addr;\n-    net_addr.SetRaw(network, fuzzed_data_provider.ConsumeBytes<uint8_t>(16).data());\n-    std::vector<bool> asmap;\n-    for (const char cur_byte : fuzzed_data_provider.ConsumeRemainingBytes<char>()) {\n-        for (int bit = 0; bit < 8; ++bit) {\n-            asmap.push_back((cur_byte >> bit) & 1);\n+    // Encoding: [7 bits: asmap size] [1 bit: ipv6?] [3-130 bytes: asmap] [4 or 16 bytes: addr]\n+    if (buffer.size() < 1 + 3 + 4) return;\n+    int asmap_size = 3 + (buffer[0] & 127);\n+    bool ipv6 = buffer[0] & 128;\n+    int addr_size = ipv6 ? 16 : 4;\n+    if (buffer.size() < size_t(1 + asmap_size + addr_size)) return;\n+    std::vector<bool> asmap = ipv6 ? IPV6_PREFIX_ASMAP : IPV4_PREFIX_ASMAP;\n+    asmap.reserve(asmap.size() + 8 * asmap_size);\n+    for (int i = 0; i < asmap_size; ++i) {\n+        for (int j = 0; j < 8; ++j) {\n+            asmap.push_back((buffer[1 + i] >> j) & 1);\n         }\n     }\n+    if (!SanityCheckASMap(asmap)) return;\n+    CNetAddr net_addr;\n+    net_addr.SetRaw(ipv6 ? NET_IPV6 : NET_IPV4, buffer.data() + 1 + asmap_size);\n     (void)net_addr.GetMappedAS(asmap);\n }"
      },
      {
        "sha": "f24a382d6e84835658c772d37a4fd7cef6d336eb",
        "filename": "src/util/asmap.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9c31523e9e0b754ff023981e00c2eb8493189abd/src/util/asmap.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9c31523e9e0b754ff023981e00c2eb8493189abd/src/util/asmap.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/asmap.cpp?ref=9c31523e9e0b754ff023981e00c2eb8493189abd",
        "patch": "@@ -116,7 +116,7 @@ uint32_t Interpret(const std::vector<bool> &asmap, const std::vector<bool> &ip)\n             break; // Instruction straddles EOF\n         }\n     }\n-    // Reached EOF without RETURN, or aborted (see any of the breaks above).\n+    assert(false); // Reached EOF without RETURN, or aborted (see any of the breaks above) - should have been caught by SanityCheckASMap below\n     return 0; // 0 is not a valid ASN\n }\n "
      }
    ]
  },
  {
    "sha": "9e54347e692f59eee649efceabe4b4107b8d443a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5ZTU0MzQ3ZTY5MmY1OWVlZTY0OWVmY2VhYmU0YjQxMDdiOGQ0NDNh",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2020-04-04T01:42:20Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-04-12T01:42:01Z"
      },
      "message": "Add asmap_direct fuzzer that tests Interpreter directly",
      "tree": {
        "sha": "e07d4b4be07a3dc89158de4e24483f3c14090e36",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e07d4b4be07a3dc89158de4e24483f3c14090e36"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9e54347e692f59eee649efceabe4b4107b8d443a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9e54347e692f59eee649efceabe4b4107b8d443a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9e54347e692f59eee649efceabe4b4107b8d443a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9e54347e692f59eee649efceabe4b4107b8d443a/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9c31523e9e0b754ff023981e00c2eb8493189abd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9c31523e9e0b754ff023981e00c2eb8493189abd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9c31523e9e0b754ff023981e00c2eb8493189abd"
      }
    ],
    "stats": {
      "total": 53,
      "additions": 53,
      "deletions": 0
    },
    "files": [
      {
        "sha": "cb26535d8469bdbb13d5f7caa52a6764e7abad7f",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e54347e692f59eee649efceabe4b4107b8d443a/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e54347e692f59eee649efceabe4b4107b8d443a/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=9e54347e692f59eee649efceabe4b4107b8d443a",
        "patch": "@@ -9,6 +9,7 @@ FUZZ_TARGETS = \\\n   test/fuzz/address_deserialize \\\n   test/fuzz/addrman_deserialize \\\n   test/fuzz/asmap \\\n+  test/fuzz/asmap_direct \\\n   test/fuzz/banentry_deserialize \\\n   test/fuzz/base_encode_decode \\\n   test/fuzz/bech32 \\\n@@ -324,6 +325,12 @@ test_fuzz_asmap_LDADD = $(FUZZ_SUITE_LD_COMMON)\n test_fuzz_asmap_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n test_fuzz_asmap_SOURCES = test/fuzz/asmap.cpp\n \n+test_fuzz_asmap_direct_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n+test_fuzz_asmap_direct_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n+test_fuzz_asmap_direct_LDADD = $(FUZZ_SUITE_LD_COMMON)\n+test_fuzz_asmap_direct_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n+test_fuzz_asmap_direct_SOURCES = test/fuzz/asmap_direct.cpp\n+\n test_fuzz_banentry_deserialize_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) -DBANENTRY_DESERIALIZE=1\n test_fuzz_banentry_deserialize_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n test_fuzz_banentry_deserialize_LDADD = $(FUZZ_SUITE_LD_COMMON)"
      },
      {
        "sha": "790f80237d1f0977191d33b214d77d6ee66a9909",
        "filename": "src/test/fuzz/asmap_direct.cpp",
        "status": "added",
        "additions": 46,
        "deletions": 0,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9e54347e692f59eee649efceabe4b4107b8d443a/src/test/fuzz/asmap_direct.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9e54347e692f59eee649efceabe4b4107b8d443a/src/test/fuzz/asmap_direct.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/asmap_direct.cpp?ref=9e54347e692f59eee649efceabe4b4107b8d443a",
        "patch": "@@ -0,0 +1,46 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/asmap.h>\n+#include <test/fuzz/fuzz.h>\n+\n+#include <cstdint>\n+#include <vector>\n+\n+#include <assert.h>\n+\n+void test_one_input(const std::vector<uint8_t>& buffer)\n+{\n+    // Encoding: [asmap using 1 bit / byte] 0xFF [addr using 1 bit / byte]\n+    bool have_sep = false;\n+    size_t sep_pos;\n+    for (size_t pos = 0; pos < buffer.size(); ++pos) {\n+        uint8_t x = buffer[pos];\n+        if ((x & 0xFE) == 0) continue;\n+        if (x == 0xFF) {\n+            if (have_sep) return;\n+            have_sep = true;\n+            sep_pos = pos;\n+        } else {\n+            return;\n+        }\n+    }\n+    if (!have_sep) return; // Needs exactly 1 separator\n+    if (buffer.size() - sep_pos - 1 > 128) return; // At most 128 bits in IP address\n+\n+    // Checks on asmap\n+    std::vector<bool> asmap(buffer.begin(), buffer.begin() + sep_pos);\n+    if (SanityCheckASMap(asmap, buffer.size() - 1 - sep_pos)) {\n+        // Verify that for valid asmaps, no prefix (except up to 7 zero padding bits) is valid.\n+        std::vector<bool> asmap_prefix = asmap;\n+        while (!asmap_prefix.empty() && asmap_prefix.size() + 7 > asmap.size() && asmap_prefix.back() == false) asmap_prefix.pop_back();\n+        while (!asmap_prefix.empty()) {\n+            asmap_prefix.pop_back();\n+            assert(!SanityCheckASMap(asmap_prefix, buffer.size() - 1 - sep_pos));\n+        }\n+        // No address input should trigger assertions in interpreter\n+        std::vector<bool> addr(buffer.begin() + sep_pos + 1, buffer.end());\n+        (void)Interpret(asmap, addr);\n+    }\n+}"
      }
    ]
  },
  {
    "sha": "e6712455df15b5f9781c057edbf2f26348411746",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNjcxMjQ1NWRmMTViNWY5NzgxYzA1N2VkYmYyZjI2MzQ4NDExNzQ2",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2020-04-10T22:01:09Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-04-12T01:42:01Z"
      },
      "message": "[REFACTOR] Add CSubNet::GetCIDR",
      "tree": {
        "sha": "6c7597fcfdcb29035cbe774819a3d4b471bdcf57",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6c7597fcfdcb29035cbe774819a3d4b471bdcf57"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e6712455df15b5f9781c057edbf2f26348411746",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e6712455df15b5f9781c057edbf2f26348411746",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e6712455df15b5f9781c057edbf2f26348411746",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e6712455df15b5f9781c057edbf2f26348411746/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9e54347e692f59eee649efceabe4b4107b8d443a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9e54347e692f59eee649efceabe4b4107b8d443a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9e54347e692f59eee649efceabe4b4107b8d443a"
      }
    ],
    "stats": {
      "total": 36,
      "additions": 23,
      "deletions": 13
    },
    "files": [
      {
        "sha": "1ef937b38424e227113bd3f96bd23eafeee38047",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 13,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e6712455df15b5f9781c057edbf2f26348411746/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e6712455df15b5f9781c057edbf2f26348411746/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=e6712455df15b5f9781c057edbf2f26348411746",
        "patch": "@@ -842,30 +842,34 @@ static inline int NetmaskBits(uint8_t x)\n     }\n }\n \n-std::string CSubNet::ToString() const\n+std::pair<CNetAddr, int> CSubNet::GetCIDR() const\n {\n     /* Parse binary 1{n}0{N-n} to see if mask can be represented as /n */\n     int cidr = 0;\n-    bool valid_cidr = true;\n-    int n = network.IsIPv4() ? 12 : 0;\n-    for (; n < 16 && netmask[n] == 0xff; ++n)\n-        cidr += 8;\n+    int n = 0;\n+    for (; n < 16 && netmask[n] == 0xff; ++n) cidr += 8;\n     if (n < 16) {\n         int bits = NetmaskBits(netmask[n]);\n-        if (bits < 0)\n-            valid_cidr = false;\n-        else\n-            cidr += bits;\n+        if (bits < 0) return {network, -1};\n+        cidr += bits;\n         ++n;\n     }\n-    for (; n < 16 && valid_cidr; ++n)\n-        if (netmask[n] != 0x00)\n-            valid_cidr = false;\n+    for (; n < 16; ++n) {\n+        if (netmask[n] != 0x00) return {network, -1};\n+    }\n+    return {network, cidr};\n+}\n+\n+std::string CSubNet::ToString() const\n+{\n+    auto cidr = GetCIDR();\n+    cidr.second -= 96 * network.IsIPv4();\n+    bool valid_cidr = cidr.second >= 0;\n \n     /* Format output */\n     std::string strNetmask;\n     if (valid_cidr) {\n-        strNetmask = strprintf(\"%u\", cidr);\n+        strNetmask = strprintf(\"%u\", cidr.second);\n     } else {\n         if (network.IsIPv4())\n             strNetmask = strprintf(\"%u.%u.%u.%u\", netmask[12], netmask[13], netmask[14], netmask[15]);"
      },
      {
        "sha": "62a6d05e8302bc19ef557b2d21c920bf6f2cae4d",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e6712455df15b5f9781c057edbf2f26348411746/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e6712455df15b5f9781c057edbf2f26348411746/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=e6712455df15b5f9781c057edbf2f26348411746",
        "patch": "@@ -136,6 +136,12 @@ class CSubNet\n         friend bool operator!=(const CSubNet& a, const CSubNet& b) { return !(a == b); }\n         friend bool operator<(const CSubNet& a, const CSubNet& b);\n \n+        /** Return the (prefix as CNetAddr, mask length) for a CIDR-compatible mask.\n+         * This treats IPv4 as embedded in IPv6 (so subtract 96 from length for IPv4).\n+         * The length will be negative for non-CIDR masks.\n+         */\n+        std::pair<CNetAddr, int> GetCIDR() const;\n+\n         ADD_SERIALIZE_METHODS;\n \n         template <typename Stream, typename Operation>"
      }
    ]
  },
  {
    "sha": "fc06b253cb4c5e6555656dd9dad152e68383abf0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYzA2YjI1M2NiNGM1ZTY1NTU2NTZkZDlkYWQxNTJlNjgzODNhYmYw",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2020-04-10T22:03:55Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-04-12T01:42:01Z"
      },
      "message": "Implement asmap decoder",
      "tree": {
        "sha": "a9ec564e04dc326cdf0b50e71cead3227bac49b3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a9ec564e04dc326cdf0b50e71cead3227bac49b3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fc06b253cb4c5e6555656dd9dad152e68383abf0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fc06b253cb4c5e6555656dd9dad152e68383abf0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fc06b253cb4c5e6555656dd9dad152e68383abf0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fc06b253cb4c5e6555656dd9dad152e68383abf0/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e6712455df15b5f9781c057edbf2f26348411746",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e6712455df15b5f9781c057edbf2f26348411746",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e6712455df15b5f9781c057edbf2f26348411746"
      }
    ],
    "stats": {
      "total": 87,
      "additions": 87,
      "deletions": 0
    },
    "files": [
      {
        "sha": "3e7b0a82fcaea044223436fc1b7444ad46c7189e",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fc06b253cb4c5e6555656dd9dad152e68383abf0/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fc06b253cb4c5e6555656dd9dad152e68383abf0/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=fc06b253cb4c5e6555656dd9dad152e68383abf0",
        "patch": "@@ -903,3 +903,26 @@ bool SanityCheckASMap(const std::vector<bool>& asmap)\n {\n     return SanityCheckASMap(asmap, 128); // For IP address lookups, the input is 128 bits\n }\n+\n+std::vector<std::pair<CSubNet, uint32_t>> DecodeASMap(const std::vector<bool>& asmap)\n+{\n+    std::vector<std::pair<CSubNet, uint32_t>> ret;\n+\n+    for (const auto& item : DecodeASMap(asmap, 128)) {\n+        unsigned char ip[16] = {0};\n+        for (size_t pos = 0; pos < item.first.size(); ++pos) {\n+            ip[pos >> 3] |= (int(item.first[pos]) << ((127 - pos) & 7));\n+        }\n+        CNetAddr addr;\n+        addr.SetRaw(NET_IPV6, ip);\n+        if (addr.IsIPv4()) {\n+            if (item.first.size() >= 96) {\n+                ret.emplace_back(CSubNet(addr, item.first.size() - 96), item.second);\n+            }\n+        } else {\n+            ret.emplace_back(CSubNet(addr, item.first.size()), item.second);\n+        }\n+    }\n+\n+    return ret;\n+}"
      },
      {
        "sha": "fe0e228d2518f75e3ee254a69928daabba2bd142",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fc06b253cb4c5e6555656dd9dad152e68383abf0/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fc06b253cb4c5e6555656dd9dad152e68383abf0/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=fc06b253cb4c5e6555656dd9dad152e68383abf0",
        "patch": "@@ -188,4 +188,6 @@ class CService : public CNetAddr\n \n bool SanityCheckASMap(const std::vector<bool>& asmap);\n \n+std::vector<std::pair<CSubNet, uint32_t>> DecodeASMap(const std::vector<bool>& asmap);\n+\n #endif // BITCOIN_NETADDRESS_H"
      },
      {
        "sha": "0c553b118c6ed08e593a4dfb945a9c0cf44252cb",
        "filename": "src/util/asmap.cpp",
        "status": "modified",
        "additions": 60,
        "deletions": 0,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fc06b253cb4c5e6555656dd9dad152e68383abf0/src/util/asmap.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fc06b253cb4c5e6555656dd9dad152e68383abf0/src/util/asmap.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/asmap.cpp?ref=fc06b253cb4c5e6555656dd9dad152e68383abf0",
        "patch": "@@ -183,3 +183,63 @@ bool SanityCheckASMap(const std::vector<bool>& asmap, int bits)\n     }\n     return false; // Reached EOF without RETURN instruction\n }\n+\n+std::vector<std::pair<std::vector<bool>, uint32_t>> DecodeASMap(const std::vector<bool>& asmap, int bits)\n+{\n+    std::vector<std::pair<std::vector<bool>, uint32_t>> ret;\n+\n+    const std::vector<bool>::const_iterator begin = asmap.begin(), endpos = asmap.end();\n+    std::vector<bool>::const_iterator pos = begin;\n+\n+    std::vector<bool> branch_bits; //!< The prefix currently assumed in the input\n+    std::vector<bool> branch_jumps; //!< For each bit in branch_bits, whether it's due to a JUMP (true) or a MATCH (false)\n+    branch_bits.reserve(bits);\n+    branch_jumps.reserve(bits);\n+\n+    while (pos != endpos) {\n+        Instruction opcode = DecodeType(pos, endpos);\n+        if (opcode == Instruction::RETURN || opcode == Instruction::DEFAULT) {\n+            uint32_t asn = DecodeASN(pos, endpos);\n+            if (asn == INVALID) return {};\n+            ret.emplace_back(branch_bits, asn);\n+            if (opcode == Instruction::RETURN) {\n+                while (true) {\n+                    // Drop MATCH bits\n+                    while (branch_jumps.size() && !branch_jumps.back()) {\n+                        branch_bits.pop_back();\n+                        branch_jumps.pop_back();\n+                    }\n+                    if (branch_jumps.empty()) return ret; // Done\n+                    // Process JUMP branch\n+                    if (branch_bits.back()) {\n+                        // We were on the 1 side, we're done with this JUMP\n+                        branch_bits.pop_back();\n+                        branch_jumps.pop_back();\n+                    } else {\n+                        // We were on the 0 side of a JUMP, switch to the 1 side\n+                        branch_bits.back() = true;\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (opcode == Instruction::JUMP) {\n+            uint32_t jump = DecodeJump(pos, endpos);\n+            if (jump == INVALID) return {};\n+            if (branch_bits.size() == (size_t)bits) return {}; // Cannot jump when all bits are already consumed\n+            branch_bits.push_back(false); // A new 0 bit is assumed in what follows\n+            branch_jumps.push_back(true); // ... and it's due to a JUMP\n+        } else if (opcode == Instruction::MATCH) {\n+            uint32_t match = DecodeMatch(pos, endpos);\n+            if (match == INVALID) return {};\n+            int matchlen = CountBits(match) - 1;\n+            if (branch_bits.size() + matchlen > (size_t)bits) return {}; // Comsuming more bits than exist in the input\n+            for (int bitpos = 0; bitpos < matchlen; ++bitpos) {\n+                branch_bits.push_back((match >> (matchlen - 1 - bitpos)) & 1);\n+                branch_jumps.push_back(false); // These bits added are MATCHes, not JUMPs\n+            }\n+        } else {\n+            return {};\n+        }\n+    }\n+    return {}; // Unexpected EOF\n+}"
      },
      {
        "sha": "86c8644581aeb1f434b639b08cf8225297d9b06f",
        "filename": "src/util/asmap.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fc06b253cb4c5e6555656dd9dad152e68383abf0/src/util/asmap.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fc06b253cb4c5e6555656dd9dad152e68383abf0/src/util/asmap.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/asmap.h?ref=fc06b253cb4c5e6555656dd9dad152e68383abf0",
        "patch": "@@ -12,4 +12,6 @@ uint32_t Interpret(const std::vector<bool> &asmap, const std::vector<bool> &ip);\n \n bool SanityCheckASMap(const std::vector<bool>& asmap, int bits);\n \n+std::vector<std::pair<std::vector<bool>, uint32_t>> DecodeASMap(const std::vector<bool>& asmap, int bits);\n+\n #endif // BITCOIN_UTIL_ASMAP_H"
      }
    ]
  },
  {
    "sha": "26f5a7e8c1fce381fc1bf49ce7e376f5cd678842",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNmY1YTdlOGMxZmNlMzgxZmMxYmY0OWNlN2UzNzZmNWNkNjc4ODQy",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2020-04-10T22:01:58Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-04-12T01:42:01Z"
      },
      "message": "Implement asmap encoder",
      "tree": {
        "sha": "a721c72499a9cc55873ee0cdaa8354363d6a428e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a721c72499a9cc55873ee0cdaa8354363d6a428e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/26f5a7e8c1fce381fc1bf49ce7e376f5cd678842",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/26f5a7e8c1fce381fc1bf49ce7e376f5cd678842",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/26f5a7e8c1fce381fc1bf49ce7e376f5cd678842",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/26f5a7e8c1fce381fc1bf49ce7e376f5cd678842/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fc06b253cb4c5e6555656dd9dad152e68383abf0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fc06b253cb4c5e6555656dd9dad152e68383abf0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fc06b253cb4c5e6555656dd9dad152e68383abf0"
      }
    ],
    "stats": {
      "total": 454,
      "additions": 454,
      "deletions": 0
    },
    "files": [
      {
        "sha": "7082645aac57e328344ce691c903a6ac1ede4eca",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26f5a7e8c1fce381fc1bf49ce7e376f5cd678842/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26f5a7e8c1fce381fc1bf49ce7e376f5cd678842/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=26f5a7e8c1fce381fc1bf49ce7e376f5cd678842",
        "patch": "@@ -926,3 +926,20 @@ std::vector<std::pair<CSubNet, uint32_t>> DecodeASMap(const std::vector<bool>& a\n \n     return ret;\n }\n+\n+std::vector<bool> EncodeASMap(const std::vector<std::pair<CSubNet, uint32_t>>& mappings)\n+{\n+    std::vector<std::pair<std::vector<bool>, uint32_t>> bitmap;\n+\n+    std::vector<bool> bits(128);\n+    for (const auto& item : mappings) {\n+        auto cidr = item.first.GetCIDR();\n+        if (cidr.second < 0) return {};\n+        for (int bit = 0; bit < cidr.second; ++bit) {\n+            bits[bit] = (cidr.first.GetByte((127 - bit) >> 3) >> ((127 - bit) & 7)) & 1;\n+        }\n+        bitmap.emplace_back(std::vector<bool>(bits.begin(), bits.begin() + cidr.second), item.second);\n+    }\n+\n+    return EncodeASMap(std::move(bitmap), true);\n+}"
      },
      {
        "sha": "cbdcddc0bc58d6601b71af3db39c05a62f2801f5",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26f5a7e8c1fce381fc1bf49ce7e376f5cd678842/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26f5a7e8c1fce381fc1bf49ce7e376f5cd678842/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=26f5a7e8c1fce381fc1bf49ce7e376f5cd678842",
        "patch": "@@ -190,4 +190,6 @@ bool SanityCheckASMap(const std::vector<bool>& asmap);\n \n std::vector<std::pair<CSubNet, uint32_t>> DecodeASMap(const std::vector<bool>& asmap);\n \n+std::vector<bool> EncodeASMap(const std::vector<std::pair<CSubNet, uint32_t>>& mappings);\n+\n #endif // BITCOIN_NETADDRESS_H"
      },
      {
        "sha": "dbf711d4a9c27a6e985d3aee47c9471483242a94",
        "filename": "src/util/asmap.cpp",
        "status": "modified",
        "additions": 429,
        "deletions": 0,
        "changes": 429,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26f5a7e8c1fce381fc1bf49ce7e376f5cd678842/src/util/asmap.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26f5a7e8c1fce381fc1bf49ce7e376f5cd678842/src/util/asmap.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/asmap.cpp?ref=26f5a7e8c1fce381fc1bf49ce7e376f5cd678842",
        "patch": "@@ -2,10 +2,15 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include <algorithm>\n #include <map>\n+#include <memory>\n #include <vector>\n #include <assert.h>\n #include <crypto/common.h>\n+#include <util/vector.h>\n+\n+#include <stdio.h>\n \n namespace {\n \n@@ -39,6 +44,42 @@ uint32_t DecodeBits(std::vector<bool>::const_iterator& bitpos, const std::vector\n     return INVALID; // Reached EOF in exponent\n }\n \n+/** Append an encoding of value (with specified minval/bit_sizes parameters) to out. */\n+void EncodeBits(std::vector<bool>& out, uint32_t val, uint32_t minval, const std::vector<uint8_t>& bit_sizes)\n+{\n+    val -= minval;\n+    for (size_t pos = 0; pos < bit_sizes.size(); ++pos) {\n+        uint8_t bit_size = bit_sizes[pos];\n+        if (val >> bit_size) {\n+            val -= (1 << bit_size);\n+            out.push_back(true);\n+        } else {\n+            if (pos + 1 < bit_sizes.size()) out.push_back(false);\n+            for (int b = 0; b < bit_size; ++b) out.push_back((val >> (bit_size - 1 - b)) & 1);\n+            return;\n+        }\n+    }\n+    assert(false);\n+}\n+\n+/** Predict how big an encoding of value (with specified minval/bit_sizes parameters) will be. */\n+size_t SizeBits(uint32_t val, uint32_t minval, const std::vector<uint8_t>& bit_sizes)\n+{\n+    size_t ret = 0;\n+    val -= minval;\n+    for (size_t pos = 0; pos < bit_sizes.size(); ++pos) {\n+        uint8_t bit_size = bit_sizes[pos];\n+        if (val >> bit_size) {\n+            val -= (1 << bit_size);\n+            ++ret;\n+        } else {\n+            if (pos + 1 < bit_sizes.size()) ++ret;\n+            return ret + bit_size;\n+        }\n+    }\n+    assert(false);\n+}\n+\n enum class Instruction : uint32_t\n {\n     RETURN = 0,\n@@ -53,26 +94,384 @@ Instruction DecodeType(std::vector<bool>::const_iterator& bitpos, const std::vec\n     return Instruction(DecodeBits(bitpos, endpos, 0, TYPE_BIT_SIZES));\n }\n \n+void EncodeType(std::vector<bool>& out, Instruction opcode) { EncodeBits(out, uint32_t(opcode), 0, TYPE_BIT_SIZES); }\n+size_t SizeType(Instruction opcode) { return SizeBits(uint32_t(opcode), 0, TYPE_BIT_SIZES); }\n+\n const std::vector<uint8_t> ASN_BIT_SIZES{15, 16, 17, 18, 19, 20, 21, 22, 23, 24};\n uint32_t DecodeASN(std::vector<bool>::const_iterator& bitpos, const std::vector<bool>::const_iterator& endpos)\n {\n     return DecodeBits(bitpos, endpos, 1, ASN_BIT_SIZES);\n }\n \n+void EncodeASN(std::vector<bool>& out, uint32_t asn) { EncodeBits(out, asn, 1, ASN_BIT_SIZES); }\n+size_t SizeASN(uint32_t asn) { return SizeBits(asn, 1, ASN_BIT_SIZES); }\n \n const std::vector<uint8_t> MATCH_BIT_SIZES{1, 2, 3, 4, 5, 6, 7, 8};\n uint32_t DecodeMatch(std::vector<bool>::const_iterator& bitpos, const std::vector<bool>::const_iterator& endpos)\n {\n     return DecodeBits(bitpos, endpos, 2, MATCH_BIT_SIZES);\n }\n \n+void EncodeMatch(std::vector<bool>& out, uint32_t match) { EncodeBits(out, match, 2, MATCH_BIT_SIZES); }\n+size_t SizeMatch(uint32_t match) { return SizeBits(match, 2, MATCH_BIT_SIZES); }\n+constexpr uint32_t MATCH_MAX = 0x1FF;\n \n const std::vector<uint8_t> JUMP_BIT_SIZES{5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30};\n uint32_t DecodeJump(std::vector<bool>::const_iterator& bitpos, const std::vector<bool>::const_iterator& endpos)\n {\n     return DecodeBits(bitpos, endpos, 17, JUMP_BIT_SIZES);\n }\n \n+void EncodeJump(std::vector<bool>& out, uint32_t offset) { EncodeBits(out, offset, 17, JUMP_BIT_SIZES); }\n+size_t SizeJump(uint32_t offset) { return SizeBits(offset, 17, JUMP_BIT_SIZES); }\n+\n+/** A (node of) a binary prefix tree that represents a mapping.\n+ *\n+ * This data structure is used as an intermediate representation when encoding.\n+ *\n+ * Each node is either:\n+ * - A leaf (with sub[0,1] set to nullptr, and asn set)\n+ * - An inner node (with sub[0,1] pointing to child nodes, and asn ignored)\n+ */\n+struct ASMapTrie {\n+    /** The asn this node maps to if it is a leaf.\n+     *\n+     * - 0 means unmatched (no mapping exists for this prefix)\n+     * - INVALID means dontcare (the encoding is allowed to map this to anything)\n+     * - Any other value is the ASN itself.\n+     *\n+     * This is always 0 for inner nodes in the tree.\n+     */\n+    uint32_t asn = 0; /* 0=unmatched; INVALID=dontcare; others=asn */\n+\n+    /** The child nodes of this tree. They're nullptr for leaf nodes. */\n+    std::unique_ptr<ASMapTrie> sub[2];\n+\n+    /** Check whether this node is a leaf. */\n+    bool IsLeaf() const { return !sub[0]; }\n+\n+    /** Convert this node into a leaf with ASN v, regardless of what it was. */\n+    void MakeLeaf(uint32_t v)\n+    {\n+        asn = v;\n+        sub[0].reset(nullptr);\n+        sub[1].reset(nullptr);\n+    }\n+\n+    /** Make the prefix identified by begin..end map to ASN v. */\n+    void MapTo(std::vector<bool>::const_iterator begin, std::vector<bool>::const_iterator end, uint32_t v)\n+    {\n+        if (begin == end) {\n+            MakeLeaf(v);\n+        } else {\n+            if (IsLeaf()) {\n+                // We need to descend into this node, but it's a leaf. Convert to inner node.\n+                sub[0].reset(new ASMapTrie());\n+                sub[1].reset(new ASMapTrie());\n+                sub[0]->asn = sub[1]->asn = asn;\n+                asn = 0;\n+            }\n+            sub[*begin]->MapTo(std::next(begin), end, v);\n+        }\n+    }\n+\n+    /** Remove unnecessary branches. */\n+    void Compact()\n+    {\n+        if (IsLeaf()) return; // If a node is already a leaf we can't compact it further.\n+        // Compact the child nodes, if possible.\n+        sub[0]->Compact();\n+        sub[1]->Compact();\n+        // If both are (now) leaf nodes, maybe then can be merged into one.\n+        if (sub[0]->IsLeaf() && sub[1]->IsLeaf()) {\n+            if (sub[0]->asn == sub[1]->asn || sub[1]->asn == INVALID) {\n+                // If they map to the same thing, or the second one does not matter, turn this\n+                // node into a leaf equal to the first one.\n+                MakeLeaf(sub[0]->asn);\n+            } else if (sub[0]->asn == INVALID) {\n+                // If the first one does not matter, turn this node into a leaf equal to the\n+                // second one.\n+                MakeLeaf(sub[1]->asn);\n+            }\n+        }\n+    }\n+};\n+\n+/** This class represents a potential encoding for an ASMapTrie node (=subtree). */\n+struct ASMapEncoding {\n+    /** Encodings for the subtrees.\n+     *  - For RETURN: both are nullptr\n+     *  - For DEFAULT and MATCH: left is set but right is nullptr\n+     *  - For JUMP: both are set (left represents the 0 path, right the 1 path)\n+     *\n+     * std::shared_ptr is used because these subtrees are built in a generic\n+     * programming fashion. We first construct the optimal encodings for every\n+     * ASMapTrie node's children, and from those, compute the optimal encodings\n+     * for the node itself. Since there may be multiple parent-encodings that\n+     * are built on the same child-encodings, we need to allow them to be\n+     * shared, or we'd end up with an exponential memory growth.\n+     */\n+    std::shared_ptr<const ASMapEncoding> left, right;\n+\n+    /** The number of bits this encoding will encode to (including all children).\n+     *\n+     * This value can be INVALID for RETURN instructions with ASN 0. These do not\n+     * actually have a valid encoding, but they're used as temporaries that can\n+     * get absorbed into MATCH instructions at parent levels.\n+     */\n+    uint32_t bits;\n+\n+    /** What opcode to encode. */\n+    Instruction opcode;\n+\n+    /** What value to encode.\n+     *  - For RETURN: the value to return (0=no match, INVALID=dontcare, anything else: ASN)\n+     *  - For DEFAULT: the ASN to set default_asn to (only valid ASNs>0 allowed)\n+     *  - For MATCH: the matchval (encoding the bits to match with; see PushMatchVal documentation)\n+     *  - For JUMP: 0\n+     */\n+    uint32_t value;\n+\n+    /** Encodings can be generic or contextual. They're contextual if they are only\n+     * valid when interpreted in an environment where default_asn has a specific\n+     * pre-set value. This is stored in the context member. It is:\n+     * - 0 if it has be interpreted with default_asn=0 (the initial value).\n+     * - INVALID if it is a generic encoding (which is valid in any context).\n+     * - Any other value if the last executed DEFAULT instruction before this\n+     *   encoding has to be that exact value.\n+    */\n+    uint32_t context;\n+\n+    /** Whether this encoding will be valid in any context. */\n+    bool IsGeneric() const { return context == INVALID; }\n+\n+    /** Whether an encoding actually exists for this node. */\n+    bool IsValid() const { return bits != INVALID; }\n+\n+    /** Compute number of bits of a prospective encoding. 0 = cannot be encoded.\n+     *\n+     * This is a separate static function, so that we can avoid constructing a\n+     * new object if it wouldn't actually be an improvement.\n+     */\n+    static size_t ComputeBits(Instruction opcode, uint32_t value, const std::shared_ptr<const ASMapEncoding>& left, const std::shared_ptr<const ASMapEncoding>& right)\n+    {\n+        if (opcode == Instruction::RETURN) {\n+            // Return 0 is invalid, so output INVALID. Return dontcare (INVALID) is encoded as RETURN 1.\n+            return value == 0 ? INVALID : SizeType(opcode) + SizeASN(value == INVALID ? 1 : value);\n+        } else if (opcode == Instruction::JUMP) {\n+            return SizeType(opcode) + SizeJump(left->bits) + left->bits + right->bits;\n+        } else if (opcode == Instruction::MATCH) {\n+            return SizeType(opcode) + SizeMatch(value) + left->bits;\n+        } else {\n+            return SizeType(opcode) + SizeASN(value) + left->bits;\n+        }\n+    }\n+\n+    /** Construct a new potential encoding object.\n+     * - o: the instruction opcode\n+     * - c: the context (incl. 0 or INVALID to represent default_asn=0 or dontcare)\n+     * - v: the value (ASN for RETURN/DEFAULT, matchval for MATCH, 0 for JUMP)\n+     * - l, r: the child encodings\n+     */\n+    ASMapEncoding(Instruction o, uint32_t c, uint32_t v, const std::shared_ptr<const ASMapEncoding>& l, const std::shared_ptr<const ASMapEncoding>& r)\n+    {\n+        opcode = o;\n+        value = v;\n+        context = c;\n+        bits = ComputeBits(o, v, l, r);\n+        left = l;\n+        right = r;\n+        if (o == Instruction::RETURN) {\n+            assert(IsGeneric()); // RETURN instructions are always generic,\n+            assert(!left && !right); // .. and never have child encodings\n+        } else if (o == Instruction::JUMP) {\n+            assert(left && right && left->IsValid() && right->IsValid()); // JUMP instructions have 2 valid child encodings,\n+            assert(value == 0); // ... and don't have any value.\n+            assert(l->IsGeneric() || r->IsGeneric() || l->context == r->context); // If both children are contextual, they must have the same context.\n+            assert(context == (l->IsGeneric() ? r->context : l->context)); // The JUMP's context is the more specific one of its children's contexts.\n+        } else if (o == Instruction::MATCH) {\n+            assert(left && !right && left->IsValid()); // MATCH instructions have 1 valid child encoding\n+            assert(value >= 2 && value <= MATCH_MAX); // Their value must be in range\n+            // If the child is contextual, the MATCH must inherit it. However,\n+            // if the child is generic, the MATCH may be more specific, as it\n+            // will return the default_asn in case of failure).\n+            assert(left->IsGeneric() || left->context == context);\n+        } else if (o == Instruction::DEFAULT) {\n+            assert(left && !right && left->IsValid()); // DEFAULT instructions have 1 valid child encoding,\n+            assert(value != 0 && value != INVALID); // ... they cannot be 0 or dontcare,\n+            assert(IsGeneric()); // ...and they're valid in every context.\n+        } else {\n+            assert(false);\n+        }\n+    }\n+\n+    /** Append the encoding to out. */\n+    void Encode(std::vector<bool>& out) const\n+    {\n+        assert(IsValid()); // Only valid nodes can be encoded.\n+        size_t old_size = out.size(); // Keep track of the old size.\n+        EncodeType(out, opcode);\n+        if (opcode == Instruction::RETURN) {\n+            EncodeASN(out, value == INVALID ? 1 : value);\n+        } else if (opcode == Instruction::JUMP) {\n+            EncodeJump(out, left->bits);\n+            left->Encode(out);\n+            right->Encode(out);\n+        } else if (opcode == Instruction::MATCH) {\n+            EncodeMatch(out, value);\n+            left->Encode(out);\n+        } else if (opcode == Instruction::DEFAULT) {\n+            EncodeASN(out, value);\n+            left->Encode(out);\n+        }\n+        assert(out.size() == old_size + bits); // Verify that exactly bits bits were added.\n+    }\n+};\n+\n+/** A data structure to hold all best encodings for a subtree. */\n+struct ASMapEncodings {\n+    // We only keep the single best generic encoding (if one exists), and at\n+    // most one contextual encoding per context value (including 0).\n+    //\n+    // If it were possible to have a MATCH encoding and a non-MATCH encoding\n+    // for the same node and the same context, where the non-MATCH encoding was\n+    // smaller, we would have needed to keep both. This is because MATCH nodes\n+    // may be extended more cheaply than others, so an extension of a MATCH\n+    // in that case could be smaller than the extension of the non-MATCH one.\n+    //\n+    // It turns out this is unnecessary, because when a MATCH encoding exists\n+    // for a certain node and context, it is always the smallest encoding.\n+\n+    /** The best generic encoding for the subtree (nullptr if none). */\n+    std::shared_ptr<const ASMapEncoding> generic;\n+    /** The best contextual encodings for the subtree (for every context value). */\n+    std::map<uint32_t, std::shared_ptr<const ASMapEncoding>> contextual;\n+\n+    /** Update this data structure with a new prospective encoding. */\n+    void Consider(Instruction opcode, uint32_t context, uint32_t value = 0, const std::shared_ptr<const ASMapEncoding>& left = {}, const std::shared_ptr<const ASMapEncoding>& right = {})\n+    {\n+        // Compute its validity/size without constructing a new object first.\n+        size_t bits = ASMapEncoding::ComputeBits(opcode, value, left, right);\n+        if (context == INVALID) {\n+            // Update best generic encoding if it's generic, and better than what we had.\n+            if (!generic || bits < generic->bits) {\n+                generic = std::make_shared<const ASMapEncoding>(opcode, context, value, left, right);\n+            }\n+        } else {\n+            // Contextual encodings are never invalid (only RETURN can be invalid, and those are always generic).\n+            assert(bits != INVALID);\n+            auto it = contextual.emplace(context, std::shared_ptr<const ASMapEncoding>());\n+            if (it.second || bits < it.first->second->bits) {\n+                // Update best contextual encoding for the provided context, if it's new, or better than what we had.\n+                it.first->second = std::make_shared<const ASMapEncoding>(opcode, context, value, left, right);\n+            }\n+        }\n+    }\n+};\n+\n+/** This function computes an extension to a matchval.\n+ *\n+ * Matchings are encoded as integers whose bits are the bits to be matched with,\n+ * prefixed by a 1.\n+ *\n+ * So for example:\n+ * - 2 = 0b10: match 0\n+ * - 3 = 0b11: match 1\n+ * - 9 = 0b1001: match 0,0,1\n+ * - 25 = 0b11001: match 1,0,0,1\n+ *\n+ * This function computes a matchval that represents first matching with bit,\n+ * and then matching with whatever is represented by matchval val.\n+ */\n+uint32_t PushMatchVal(uint32_t val, bool bit)\n+{\n+    int bits = CountBits(val) - 1;\n+    return val + ((1 + bit) << bits);\n+}\n+\n+/** Given an inner AsMapTrie node, with encodings l and r for its two children,\n+ *  update encs with all potential encodings for the node based on this child\n+ *  encodings.\n+ */\n+void ConsiderBranch(ASMapEncodings& encs, const std::shared_ptr<const ASMapEncoding>& l, const std::shared_ptr<const ASMapEncoding>& r) {\n+    // If the right side is a RETURN with a value that compatible with the left side's context,\n+    // consider a MATCH node that elides the RETURN.\n+    if (r->opcode == Instruction::RETURN && (l->context == r->value || l->IsGeneric() || r->value == INVALID)) {\n+        uint32_t context = l->IsGeneric() ? r->value : l->context;\n+        if (l->opcode == Instruction::MATCH && PushMatchVal(l->value, false) <= MATCH_MAX) {\n+            // The left side is a MATCH we can extend with a 0 bit.\n+            encs.Consider(Instruction::MATCH, context, PushMatchVal(l->value, false), l->left);\n+        } else if (l->IsValid()) {\n+            // The left side is a valid node we can choose (2 means \"match 0\").\n+            encs.Consider(Instruction::MATCH, context, 2, l);\n+        }\n+    }\n+    // If the left side is a RETURN with a value that compatible with the right side's context,\n+    // consider a MATCH node that elides the RETURN.\n+    if (l->opcode == Instruction::RETURN && (r->context == l->value || r->IsGeneric() || l->value == INVALID)) {\n+        uint32_t context = r->IsGeneric() ? l->value : r->context;\n+        if (r->opcode == Instruction::MATCH && PushMatchVal(r->value, true) <= MATCH_MAX) {\n+            // The right side is a MATCH we can extend with a 1 bit.\n+            encs.Consider(Instruction::MATCH, context, PushMatchVal(r->value, true), r->left);\n+        } else if (r->IsValid()) {\n+            // The right side is a valid node we can choose (3 means \"match 1\").\n+            encs.Consider(Instruction::MATCH, context, 3, r);\n+        }\n+    }\n+\n+    // If left and right are both valid, and they have compatible contexts, consider a JUMP node.\n+    if (l->IsValid() && r->IsValid() && (l->context == r->context || l->IsGeneric() || r->IsGeneric())) {\n+        encs.Consider(Instruction::JUMP, l->IsGeneric() ? r->context : l->context, 0, l, r);\n+    }\n+}\n+\n+/** Compute the best encodings (generic and contextual for any relevant context) for trie. */\n+ASMapEncodings Encode(const std::unique_ptr<ASMapTrie>& trie)\n+{\n+    ASMapEncodings ret;\n+\n+    if (trie->IsLeaf()) {\n+        // Leaf nodes are just directly turned into RETURN encodings (which may be invalid if asn=0).\n+        ret.Consider(Instruction::RETURN, INVALID, trie->asn);\n+    } else {\n+        // Otherwise, compute the best encodings for the child nodes.\n+        auto left = Encode(trie->sub[0]);\n+        auto right = Encode(trie->sub[1]);\n+\n+        // Consider a branch between the two best generic encodings.\n+        if (left.generic && right.generic) ConsiderBranch(ret, left.generic, right.generic);\n+        // If there is a generic encoding on the left, combine it with all contextual encodings on the right.\n+        if (left.generic) {\n+            for (const auto& entry : right.contextual) ConsiderBranch(ret, left.generic, entry.second);\n+        }\n+        // If there is a generic encoding on the right, combine it with all contextual encodings on the left\n+        if (right.generic) {\n+            for (const auto& entry : left.contextual) ConsiderBranch(ret, entry.second, right.generic);\n+        }\n+        // Combine all contextual encodings where the context matches left and right.\n+        for (const auto& left_entry : left.contextual) {\n+            auto it = right.contextual.find(left_entry.first);\n+            if (it != right.contextual.end()) ConsiderBranch(ret, left_entry.second, it->second);\n+        }\n+        // Any resulting contextual encoding with context!=0 can be converted into a generic one using a DEFAULT instruction.\n+        for (const auto& entry : ret.contextual) {\n+            if (entry.first != 0) ret.Consider(Instruction::DEFAULT, INVALID, entry.first, entry.second);\n+        }\n+        // If we have a valid generic encoding, any contextual ones that are not better can be removed.\n+        if (ret.generic && ret.generic->IsValid()) {\n+            for (auto it = ret.contextual.begin(); it != ret.contextual.end(); ) {\n+                if (it->second->bits >= ret.generic->bits) {\n+                    it = ret.contextual.erase(it);\n+                } else {\n+                    it = std::next(it);\n+                }\n+            }\n+        }\n+    }\n+\n+    return ret;\n+}\n+\n }\n \n uint32_t Interpret(const std::vector<bool> &asmap, const std::vector<bool> &ip)\n@@ -243,3 +642,33 @@ std::vector<std::pair<std::vector<bool>, uint32_t>> DecodeASMap(const std::vecto\n     }\n     return {}; // Unexpected EOF\n }\n+\n+std::vector<bool> EncodeASMap(std::vector<std::pair<std::vector<bool>, uint32_t>> input, bool approx)\n+{\n+    // Sort the list from short to long prefixes.\n+    using item = std::pair<std::vector<bool>, uint32_t>;\n+    std::sort(input.begin(), input.end(), [](const item& a, const item& b) { return a.first.size() < b.first.size(); });\n+\n+    std::unique_ptr<ASMapTrie> elem(new ASMapTrie());\n+    // If approx is set, we first assign the entire range to dontcare.\n+    if (approx) elem->MakeLeaf(INVALID);\n+    // Then overwrite the mapping for the provided prefixes to the provided ASNs.\n+    // This is done in order from short to long, so that a mapping for a shorter\n+    // prefix doesn't overwrite their children.\n+    for (const item& entry : input) {\n+        elem->MapTo(entry.first.begin(), entry.first.end(), entry.second);\n+    }\n+    // Remove unnecessary branches from the tree.\n+    elem->Compact();\n+\n+    auto data = Encode(elem);\n+    std::vector<bool> ret;\n+    if (data.contextual.count(0) && data.contextual[0]->IsValid()) {\n+        // Return the best encoding for context 0 (which is valid at the top level), if it exists.\n+        data.contextual[0]->Encode(ret);\n+    } else {\n+        // Or the best generic one otherwise.\n+        data.generic->Encode(ret);\n+    }\n+    return ret;\n+}"
      },
      {
        "sha": "2e2ab4e426adb803c4f5e368bedaf6ae37bd418f",
        "filename": "src/util/asmap.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26f5a7e8c1fce381fc1bf49ce7e376f5cd678842/src/util/asmap.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26f5a7e8c1fce381fc1bf49ce7e376f5cd678842/src/util/asmap.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/asmap.h?ref=26f5a7e8c1fce381fc1bf49ce7e376f5cd678842",
        "patch": "@@ -14,4 +14,10 @@ bool SanityCheckASMap(const std::vector<bool>& asmap, int bits);\n \n std::vector<std::pair<std::vector<bool>, uint32_t>> DecodeASMap(const std::vector<bool>& asmap, int bits);\n \n+/** Encode a mapping to an asmap.\n+ *\n+ * If approx is true, unmapped prefixes will be reassigned to minimize output size.\n+ */\n+std::vector<bool> EncodeASMap(std::vector<std::pair<std::vector<bool>, uint32_t>> input, bool approx);\n+\n #endif // BITCOIN_UTIL_ASMAP_H"
      }
    ]
  },
  {
    "sha": "fdebc68cd9eccdf01abe4349c8eee8d14c5b27db",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmZGViYzY4Y2Q5ZWNjZGYwMWFiZTQzNDljOGVlZThkMTRjNWIyN2Ri",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2020-04-09T01:45:34Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-04-12T01:42:01Z"
      },
      "message": "Add fuzzer for asmap encoder/decoder",
      "tree": {
        "sha": "d26a1ff4e1b72963e8615a5bf0bfb0ad4655e238",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d26a1ff4e1b72963e8615a5bf0bfb0ad4655e238"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fdebc68cd9eccdf01abe4349c8eee8d14c5b27db",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fdebc68cd9eccdf01abe4349c8eee8d14c5b27db",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fdebc68cd9eccdf01abe4349c8eee8d14c5b27db",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fdebc68cd9eccdf01abe4349c8eee8d14c5b27db/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "26f5a7e8c1fce381fc1bf49ce7e376f5cd678842",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/26f5a7e8c1fce381fc1bf49ce7e376f5cd678842",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/26f5a7e8c1fce381fc1bf49ce7e376f5cd678842"
      }
    ],
    "stats": {
      "total": 146,
      "additions": 146,
      "deletions": 0
    },
    "files": [
      {
        "sha": "18068949c8a4f1f0881f7548aa2710e1ffd5b443",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fdebc68cd9eccdf01abe4349c8eee8d14c5b27db/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fdebc68cd9eccdf01abe4349c8eee8d14c5b27db/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=fdebc68cd9eccdf01abe4349c8eee8d14c5b27db",
        "patch": "@@ -10,6 +10,7 @@ FUZZ_TARGETS = \\\n   test/fuzz/addrman_deserialize \\\n   test/fuzz/asmap \\\n   test/fuzz/asmap_direct \\\n+  test/fuzz/asmap_encoder \\\n   test/fuzz/banentry_deserialize \\\n   test/fuzz/base_encode_decode \\\n   test/fuzz/bech32 \\\n@@ -331,6 +332,12 @@ test_fuzz_asmap_direct_LDADD = $(FUZZ_SUITE_LD_COMMON)\n test_fuzz_asmap_direct_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n test_fuzz_asmap_direct_SOURCES = test/fuzz/asmap_direct.cpp\n \n+test_fuzz_asmap_encoder_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n+test_fuzz_asmap_encoder_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n+test_fuzz_asmap_encoder_LDADD = $(FUZZ_SUITE_LD_COMMON)\n+test_fuzz_asmap_encoder_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n+test_fuzz_asmap_encoder_SOURCES = test/fuzz/asmap_encoder.cpp\n+\n test_fuzz_banentry_deserialize_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) -DBANENTRY_DESERIALIZE=1\n test_fuzz_banentry_deserialize_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n test_fuzz_banentry_deserialize_LDADD = $(FUZZ_SUITE_LD_COMMON)"
      },
      {
        "sha": "f831a78d8d969dbaf7013502655e37b3fec6b729",
        "filename": "src/test/fuzz/asmap_encoder.cpp",
        "status": "added",
        "additions": 139,
        "deletions": 0,
        "changes": 139,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fdebc68cd9eccdf01abe4349c8eee8d14c5b27db/src/test/fuzz/asmap_encoder.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fdebc68cd9eccdf01abe4349c8eee8d14c5b27db/src/test/fuzz/asmap_encoder.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/asmap_encoder.cpp?ref=fdebc68cd9eccdf01abe4349c8eee8d14c5b27db",
        "patch": "@@ -0,0 +1,139 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/asmap.h>\n+#include <test/fuzz/fuzz.h>\n+\n+#include <algorithm>\n+#include <cstdint>\n+#include <functional>\n+#include <vector>\n+#include <stdio.h>\n+#include <unordered_map>\n+#include <set>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** Extend every prefix with a number of patterns for testing. */\n+const std::vector<uint32_t> TEST_PATTERNS = {0, 0xffffffff, 0x55555555, 0xaaaaaaa, 0x2461611a, 0x66eac6e1, 0x943eeccb, 0xc2889f4d};\n+\n+/** Bytes 0x02..0xFF at the end of a 0x00/0x01 sequence determines the ASN for\n+ *  that prefix. Those bytes are mapped to an geometric progressing of valid\n+ *  ASN values to give a wide range.\n+ */\n+const uint32_t TEST_ASNS[254] = {\n+    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 22,\n+    23, 25, 26, 28, 29, 31, 33, 35, 38, 40, 43, 45, 48, 51, 54, 58, 61, 65, 69,\n+    74, 78, 83, 89, 94, 100, 107, 113, 120, 128, 136, 145, 154, 163, 174, 185,\n+    196, 209, 222, 236, 251, 267, 283, 301, 320, 340, 362, 385, 409, 435, 462,\n+    491, 522, 555, 590, 628, 667, 709, 754, 802, 852, 906, 963, 1024, 1088,\n+    1157, 1230, 1307, 1390, 1478, 1571, 1670, 1775, 1887, 2006, 2133, 2267,\n+    2410, 2562, 2724, 2895, 3078, 3272, 3478, 3698, 3931, 4179, 4442, 4722,\n+    5020, 5337, 5673, 6031, 6412, 6816, 7246, 7703, 8189, 8705, 9254, 9838,\n+    10458, 11117, 11819, 12564, 13356, 14199, 15094, 16046, 17058, 18134,\n+    19277, 20493, 21785, 23159, 24620, 26172, 27823, 29578, 31443, 33426,\n+    35534, 37775, 40157, 42689, 45382, 48244, 51286, 54520, 57959, 61614,\n+    65499, 69630, 74021, 78689, 83652, 88927, 94536, 100498, 106835, 113573,\n+    120735, 128349, 136444, 145049, 154196, 163920, 174258, 185247, 196930,\n+    209349, 222552, 236587, 251507, 267369, 284230, 302155, 321210, 341467,\n+    363002, 385894, 410231, 436102, 463604, 492841, 523922, 556963, 592088,\n+    629428, 669122, 711320, 756180, 803868, 854563, 908456, 965748, 1026652,\n+    1091398, 1160226, 1233396, 1311179, 1393869, 1481772, 1575220, 1674561,\n+    1780166, 1892432, 2011778, 2138650, 2273523, 2416902, 2569323, 2731356,\n+    2903609, 3086724, 3281387, 3488327, 3708317, 3942181, 4190793, 4455084,\n+    4736042, 5034719, 5352232, 5689769, 6048592, 6430045, 6835554, 7266636,\n+    7724904, 8212072, 8729964, 9280516, 9865789, 10487972, 11149392, 11852525,\n+    12600001, 13394616, 14239343, 15137342, 16091974, 17106809, 18185644,\n+    19332516, 20551715, 21847802, 23225627, 24690343, 26247432, 27902718,\n+    29662394, 31533043, 33521664\n+};\n+\n+using elem = std::pair<std::vector<bool>, uint32_t>;\n+using elem_ref = std::reference_wrapper<const elem>;\n+\n+void UpdateExpect(std::unordered_map<std::vector<bool>, uint32_t>& expect, const std::vector<bool>& key, uint32_t asn)\n+{\n+    std::vector<bool> expanded_key;\n+    for (uint32_t pattern : TEST_PATTERNS) {\n+        expanded_key = key;\n+        expanded_key.resize(32);\n+        for (size_t pos = key.size(); pos < 32; ++pos) expanded_key[pos] = (pattern >> pos) & 1;\n+        expect[std::move(expanded_key)] = asn;\n+    }\n+}\n+\n+void TestASMap(std::vector<elem> input, const std::vector<elem_ref>& input_sorted, bool approx)\n+{\n+    // Iterate over the input in order from short to long, and build up\n+    // a map of expected inputs to outputs. By going from short to long,\n+    // the later inputs will correctly overwrite the mappings created by\n+    // their prefixes.\n+    std::unordered_map<std::vector<bool>, uint32_t> expect;\n+    if (!approx) UpdateExpect(expect, {}, 0); // When !approx, everything not explicitly overridden must map to 0\n+    for (elem_ref item : input_sorted) {\n+        UpdateExpect(expect, item.get().first, item.get().second);\n+    }\n+\n+    // Construct an asmap.\n+    auto asmap = EncodeASMap(std::move(input), approx);\n+    // It must sanity check.\n+    assert(SanityCheckASMap(asmap, 32));\n+    // All expected lookups must work.\n+    for (const auto& item : expect) {\n+        assert(Interpret(asmap, item.first) == item.second);\n+    }\n+\n+    // Check that decoding and re-encoding yields an identical results.\n+    // This guarantees that DecodeASMap does not lose any information.\n+    auto decoded_asmap = DecodeASMap(asmap, 32);\n+    auto recoded_asmap = EncodeASMap(std::move(decoded_asmap), approx);\n+    // All expected lookups must work.\n+    for (const auto& item : expect) {\n+        assert(Interpret(recoded_asmap, item.first) == item.second);\n+    }\n+}\n+\n+}\n+\n+void test_one_input(const std::vector<uint8_t>& buffer)\n+{\n+    // Input format: ([0-32 0/1 bytes for prefix bits of netmask] [1 byte 2-255 for ASN])*\n+\n+    // First do a sanity check on the input (so we quickly let the fuzzer know this is uninteresting)\n+    if (buffer.size() == 0) return;\n+    auto it = buffer.begin();\n+    while (it != buffer.end()) {\n+        auto mask_begin = it;\n+        while (it != buffer.end() && (*it & 0xfe) == 0) ++it;\n+        if (it - mask_begin > 32) return; // Netmask too short or too long\n+        if (it == buffer.end()) return; // Missing ASN\n+        ++it;\n+    }\n+\n+    // Parse the input into a format that EncodeASMap understands\n+    std::vector<elem> input;\n+    std::set<std::vector<bool>> already;\n+    it = buffer.begin();\n+    while (it != buffer.end()) {\n+        auto mask_begin = it;\n+        while ((*it & 0xfe) == 0) ++it;\n+        auto mask = std::vector<bool>(mask_begin, it);\n+        if (!already.emplace(mask).second) return; // Duplicate netmask in input\n+        input.emplace_back(std::move(mask), TEST_ASNS[(*it) - 2]);\n+        ++it;\n+    }\n+\n+    // Testing requires a sorted version of the inputs as well.\n+    // Use a vector of reference_wrapper to avoid copying the inputs.\n+    std::vector<elem_ref> input_sorted(input.begin(), input.end());\n+    std::sort(input_sorted.begin(), input_sorted.end(), [](elem_ref a, elem_ref b) { return a.get().first.size() < b.get().first.size(); });\n+\n+    // Test with approx = true\n+    TestASMap(input, input_sorted, true);\n+\n+    // Test with approx = false\n+    TestASMap(std::move(input), input_sorted, false);\n+}"
      }
    ]
  },
  {
    "sha": "3d435b1061ea52ed2db58b22f900cf8599c0a0d7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozZDQzNWIxMDYxZWE1MmVkMmRiNThiMjJmOTAwY2Y4NTk5YzBhMGQ3",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2020-04-10T22:04:38Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-04-12T01:42:01Z"
      },
      "message": "Add bitcoin-asmap tool",
      "tree": {
        "sha": "3b07a272aace1437a2c5e8b03c25f4039ca3d804",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3b07a272aace1437a2c5e8b03c25f4039ca3d804"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3d435b1061ea52ed2db58b22f900cf8599c0a0d7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3d435b1061ea52ed2db58b22f900cf8599c0a0d7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3d435b1061ea52ed2db58b22f900cf8599c0a0d7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3d435b1061ea52ed2db58b22f900cf8599c0a0d7/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fdebc68cd9eccdf01abe4349c8eee8d14c5b27db",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fdebc68cd9eccdf01abe4349c8eee8d14c5b27db",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fdebc68cd9eccdf01abe4349c8eee8d14c5b27db"
      }
    ],
    "stats": {
      "total": 239,
      "additions": 237,
      "deletions": 2
    },
    "files": [
      {
        "sha": "b0dd34075cf0605da5352b8ad5602ef9ab0b7a57",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 15,
        "deletions": 2,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3d435b1061ea52ed2db58b22f900cf8599c0a0d7/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3d435b1061ea52ed2db58b22f900cf8599c0a0d7/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=3d435b1061ea52ed2db58b22f900cf8599c0a0d7",
        "patch": "@@ -19,6 +19,7 @@ BITCOIN_GUI_NAME=bitcoin-qt\n BITCOIN_CLI_NAME=bitcoin-cli\n BITCOIN_TX_NAME=bitcoin-tx\n BITCOIN_WALLET_TOOL_NAME=bitcoin-wallet\n+BITCOIN_ASMAP_NAME=bitcoin-asmap\n \n dnl Unless the user specified ARFLAGS, force it to be cr\n AC_ARG_VAR(ARFLAGS, [Flags for the archiver, defaults to <cr> if not set])\n@@ -467,7 +468,7 @@ CPPFLAGS=\"$CPPFLAGS -DHAVE_BUILD_INFO -D__STDC_FORMAT_MACROS\"\n \n AC_ARG_WITH([utils],\n   [AS_HELP_STRING([--with-utils],\n-  [build bitcoin-cli bitcoin-tx bitcoin-wallet (default=yes)])],\n+  [build bitcoin-cli bitcoin-tx bitcoin-wallet bitcoin-asmap (default=yes)])],\n   [build_bitcoin_utils=$withval],\n   [build_bitcoin_utils=yes])\n \n@@ -489,6 +490,12 @@ AC_ARG_ENABLE([util-wallet],\n   [build_bitcoin_wallet=$enableval],\n   [build_bitcoin_wallet=$build_bitcoin_utils])\n \n+AC_ARG_ENABLE([util-asmap],\n+  [AS_HELP_STRING([--enable-util-asmap],\n+  [build bitcoin-asmap])],\n+  [build_bitcoin_asmap=$enableval],\n+  [build_bitcoin_asmap=$build_bitcoin_utils])\n+\n AC_ARG_WITH([libs],\n   [AS_HELP_STRING([--with-libs],\n   [build libraries (default=yes)])],\n@@ -1081,6 +1088,7 @@ if test \"x$enable_fuzz\" = \"xyes\"; then\n   build_bitcoin_cli=no\n   build_bitcoin_tx=no\n   build_bitcoin_wallet=no\n+  build_bitcoin_asmap=no\n   build_bitcoind=no\n   build_bitcoin_libs=no\n   bitcoin_enable_qt=no\n@@ -1385,6 +1393,10 @@ AC_MSG_CHECKING([whether to build bitcoin-wallet])\n AM_CONDITIONAL([BUILD_BITCOIN_WALLET], [test x$build_bitcoin_wallet = xyes])\n AC_MSG_RESULT($build_bitcoin_wallet)\n \n+AC_MSG_CHECKING([whether to build bitcoin-asmap])\n+AM_CONDITIONAL([BUILD_BITCOIN_ASMAP], [test x$build_bitcoin_asmap = xyes])\n+AC_MSG_RESULT($build_bitcoin_asmap)\n+\n AC_MSG_CHECKING([whether to build libraries])\n AM_CONDITIONAL([BUILD_BITCOIN_LIBS], [test x$build_bitcoin_libs = xyes])\n if test x$build_bitcoin_libs = xyes; then\n@@ -1508,7 +1520,7 @@ else\n   AC_MSG_RESULT([no])\n fi\n \n-if test x$build_bitcoin_wallet$build_bitcoin_cli$build_bitcoin_tx$build_bitcoin_libs$build_bitcoind$bitcoin_enable_qt$use_bench$use_tests = xnononononononono; then\n+if test x$build_bitcoin_wallet$build_bitcoin_cli$build_bitcoin_tx$build_bitcoin_asmap$build_bitcoin_libs$build_bitcoind$bitcoin_enable_qt$use_bench$use_tests = xnononononononnoono; then\n   AC_MSG_ERROR([No targets! Please specify at least one of: --with-utils --with-libs --with-daemon --with-gui --enable-bench or --enable-tests])\n fi\n \n@@ -1557,6 +1569,7 @@ AC_SUBST(BITCOIN_DAEMON_NAME)\n AC_SUBST(BITCOIN_GUI_NAME)\n AC_SUBST(BITCOIN_CLI_NAME)\n AC_SUBST(BITCOIN_TX_NAME)\n+AC_SUBST(BITCOIN_ASMAP_NAME)\n AC_SUBST(BITCOIN_WALLET_TOOL_NAME)\n \n AC_SUBST(RELDFLAGS)"
      },
      {
        "sha": "da91f1f3b0af9f2c8521530972be0f6550bb9a95",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3d435b1061ea52ed2db58b22f900cf8599c0a0d7/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3d435b1061ea52ed2db58b22f900cf8599c0a0d7/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=3d435b1061ea52ed2db58b22f900cf8599c0a0d7",
        "patch": "@@ -91,6 +91,9 @@ endif\n if BUILD_BITCOIN_TX\n   bin_PROGRAMS += bitcoin-tx\n endif\n+if BUILD_BITCOIN_ASMAP\n+  bin_PROGRAMS += bitcoin-asmap\n+endif\n if ENABLE_WALLET\n if BUILD_BITCOIN_WALLET\n   bin_PROGRAMS += bitcoin-wallet\n@@ -612,6 +615,19 @@ bitcoin_tx_LDADD = \\\n bitcoin_tx_LDADD += $(BOOST_LIBS)\n #\n \n+# bitcoin-asmap binary #\n+bitcoin_asmap_SOURCES = bitcoin-asmap.cpp\n+bitcoin_asmap_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n+bitcoin_asmap_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n+bitcoin_asmap_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n+\n+if TARGET_WINDOWS\n+bitcoin_asmap_SOURCES += bitcoin-asmap-res.rc\n+endif\n+\n+bitcoin_asmap_LDADD = $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CRYPTO) $(BOOST_LIBS)\n+#\n+\n # bitcoin-wallet binary #\n bitcoin_wallet_SOURCES = bitcoin-wallet.cpp\n bitcoin_wallet_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)"
      },
      {
        "sha": "bc301f0c63de4990a21aca587c219b9a57210395",
        "filename": "src/bitcoin-asmap-res.rc",
        "status": "added",
        "additions": 35,
        "deletions": 0,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3d435b1061ea52ed2db58b22f900cf8599c0a0d7/src/bitcoin-asmap-res.rc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3d435b1061ea52ed2db58b22f900cf8599c0a0d7/src/bitcoin-asmap-res.rc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-asmap-res.rc?ref=3d435b1061ea52ed2db58b22f900cf8599c0a0d7",
        "patch": "@@ -0,0 +1,35 @@\n+#include <windows.h>             // needed for VERSIONINFO\n+#include \"clientversion.h\"       // holds the needed client version information\n+\n+#define VER_PRODUCTVERSION     CLIENT_VERSION_MAJOR,CLIENT_VERSION_MINOR,CLIENT_VERSION_REVISION,CLIENT_VERSION_BUILD\n+#define VER_PRODUCTVERSION_STR STRINGIZE(CLIENT_VERSION_MAJOR) \".\" STRINGIZE(CLIENT_VERSION_MINOR) \".\" STRINGIZE(CLIENT_VERSION_REVISION) \".\" STRINGIZE(CLIENT_VERSION_BUILD)\n+#define VER_FILEVERSION        VER_PRODUCTVERSION\n+#define VER_FILEVERSION_STR    VER_PRODUCTVERSION_STR\n+\n+VS_VERSION_INFO VERSIONINFO\n+FILEVERSION     VER_FILEVERSION\n+PRODUCTVERSION  VER_PRODUCTVERSION\n+FILEOS          VOS_NT_WINDOWS32\n+FILETYPE        VFT_APP\n+BEGIN\n+    BLOCK \"StringFileInfo\"\n+    BEGIN\n+        BLOCK \"040904E4\" // U.S. English - multilingual (hex)\n+        BEGIN\n+            VALUE \"CompanyName\",        \"Bitcoin\"\n+            VALUE \"FileDescription\",    \"bitcoin-asmap (CLI Bitcoin asmap file manipulation tool)\"\n+            VALUE \"FileVersion\",        VER_FILEVERSION_STR\n+            VALUE \"InternalName\",       \"bitcoin-asmap\"\n+            VALUE \"LegalCopyright\",     COPYRIGHT_STR\n+            VALUE \"LegalTrademarks1\",   \"Distributed under the MIT software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\"\n+            VALUE \"OriginalFilename\",   \"bitcoin-asmap.exe\"\n+            VALUE \"ProductName\",        \"bitcoin-asmap\"\n+            VALUE \"ProductVersion\",     VER_PRODUCTVERSION_STR\n+        END\n+    END\n+\n+    BLOCK \"VarFileInfo\"\n+    BEGIN\n+        VALUE \"Translation\", 0x0, 1252 // language neutral - multilingual (decimal)\n+    END\n+END"
      },
      {
        "sha": "2b72cdc6c24ec00f885b0600e70303e69a5fdcf5",
        "filename": "src/bitcoin-asmap.cpp",
        "status": "added",
        "additions": 171,
        "deletions": 0,
        "changes": 171,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3d435b1061ea52ed2db58b22f900cf8599c0a0d7/src/bitcoin-asmap.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3d435b1061ea52ed2db58b22f900cf8599c0a0d7/src/bitcoin-asmap.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-asmap.cpp?ref=3d435b1061ea52ed2db58b22f900cf8599c0a0d7",
        "patch": "@@ -0,0 +1,171 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <fs.h>\n+#include <util/asmap.h>\n+#include <util/strencodings.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <streams.h>\n+#include <serialize.h>\n+#include <tinyformat.h>\n+\n+#include <iostream>\n+#include <memory>\n+#include <stdio.h>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+\n+bool LoadFile(const std::string& arg, std::vector<bool>& bits) {\n+    FILE *filestr = fsbridge::fopen(arg, \"rb\");\n+    CAutoFile file(filestr, SER_DISK, 0);\n+    if (file.IsNull()) {\n+        tfm::format(std::cerr, \"Failed to open asmap file '%s'\\n\", arg);\n+        return false;\n+    }\n+    fseek(filestr, 0, SEEK_END);\n+    int length = ftell(filestr);\n+    fseek(filestr, 0, SEEK_SET);\n+\n+    bits.clear();\n+    bits.reserve(8 * length);\n+    char cur_byte;\n+    for (int i = 0; i < length; ++i) {\n+        file >> cur_byte;\n+        for (int bit = 0; bit < 8; ++bit) {\n+            bits.push_back((cur_byte >> bit) & 1);\n+        }\n+    }\n+\n+    if (!SanityCheckASMap(bits)) {\n+        tfm::format(std::cerr, \"Provided asmap file '%s' is invalid\\n\", arg);\n+        return false;\n+    }\n+\n+    return true;\n+}\n+\n+bool SaveFile(const std::string& arg, const std::vector<bool>& bits) {\n+    FILE *filestr = fsbridge::fopen(arg, \"wb\");\n+    CAutoFile file(filestr, SER_DISK, 0);\n+    if (file.IsNull()) {\n+        tfm::format(std::cerr, \"Failed to open asmap file '%s'\\n\", arg);\n+        return false;\n+    }\n+    uint8_t cur_byte = 0;\n+    for (size_t i = 0; i < bits.size(); ++i) {\n+        cur_byte |= (bits[i] << (i & 7));\n+        if ((i & 7) == 7) {\n+            file << cur_byte;\n+            cur_byte = 0;\n+        }\n+    }\n+    if (bits.size() & 7) file << cur_byte;\n+\n+    return true;\n+}\n+\n+bool ExecuteDecode(const std::vector<std::string>& args) {\n+    if (args.size() != 1) {\n+        tfm::format(std::cerr, \"Incorrect number of arguments provided to decode (needs exactly 1)\\n\");\n+        return false;\n+    }\n+\n+    std::vector<bool> bits;\n+    if (!LoadFile(args[0], bits)) return false;\n+\n+    for (const auto& item : DecodeASMap(bits)) {\n+        tfm::format(std::cout, \"%s AS%lu\\n\", item.first.ToString(), item.second);\n+    }\n+    return true;\n+}\n+\n+bool ExecuteLookup(const std::vector<std::string>& args) {\n+    if (args.size() < 2) {\n+        tfm::format(std::cerr, \"Incorrect number of arguments provide to lookup (needs at least 2)\\n\");\n+        return false;\n+    }\n+\n+    std::vector<bool> bits;\n+    if (!LoadFile(args[0], bits)) return false;\n+\n+    std::vector<std::pair<CNetAddr, uint32_t>> results;\n+    for (size_t i = 1; i < args.size(); ++i) {\n+        CNetAddr addr;\n+        if (!LookupHost(args[i], addr, false)) {\n+            tfm::format(std::cerr, \"Cannot parse IP address '%s'\\n\", args[i]);\n+            return false;\n+        }\n+        uint32_t asn = addr.GetMappedAS(bits);\n+        if (asn != 0) results.emplace_back(addr, asn);\n+    }\n+\n+    for (const auto& item : results) {\n+        tfm::format(std::cout, \"%s AS%lu\\n\", item.first.ToString(), item.second);\n+    }\n+\n+    return true;\n+}\n+\n+bool ExecuteEncode(const std::vector<std::string>& args) {\n+    if (args.size() != 1) {\n+        tfm::format(std::cerr, \"Incorrect number of arguments provided to encode (needs exactly 1)\\n\");\n+        return false;\n+    }\n+\n+    std::vector<std::pair<CSubNet, uint32_t>> mapping;\n+    for (std::string line; std::getline(std::cin, line);) {\n+        size_t pos = line.find(\" AS\");\n+        if (pos == std::string::npos) {\n+            tfm::format(std::cerr, \"Cannot parse '%s'\\n\", line.c_str());\n+            return false;\n+        }\n+        CSubNet subnet;\n+        std::string subnetstr(line.begin(), line.begin() + pos);\n+        if (!LookupSubNet(subnetstr, subnet) || subnet.GetCIDR().second < 0) {\n+            tfm::format(std::cerr, \"Invalid subnet '%s'\\n\", subnetstr);\n+            return false;\n+        }\n+        uint32_t asn;\n+        std::string asnstr(line.begin() + pos +3, line.end());\n+        if (!ParseUInt32(asnstr, &asn) || asn == 0 || asn == 0xFFFFFFFF) {\n+            tfm::format(std::cerr, \"Invalid ASN 'AS%s'\\n\", asnstr);\n+            return false;\n+        }\n+        mapping.emplace_back(subnet, asn);\n+    }\n+\n+    auto asmap = EncodeASMap(mapping);\n+    return SaveFile(args[0], asmap);\n+}\n+\n+}\n+\n+int main(int argc, char** argv)\n+{\n+    std::vector<std::string> args;\n+    while (*argv != nullptr) args.emplace_back(*(argv++));\n+\n+    if (args.size() >= 2 && args[1] == \"decode\") {\n+        return !ExecuteDecode(std::vector<std::string>(args.begin() + 2, args.end()));\n+    } else if (args.size() >= 2 && args[1] == \"encode\") {\n+        return !ExecuteEncode(std::vector<std::string>(args.begin() + 2, args.end()));\n+    } else if (args.size() >= 2 && args[1] == \"lookup\") {\n+        return !ExecuteLookup(std::vector<std::string>(args.begin() + 2, args.end()));\n+    } else {\n+        tfm::format(std::cerr, \"Usage: %s decode <file>          Decode provided asmap file to stdout\\n\", args[0]);\n+        tfm::format(std::cerr, \"       %s encode <file>          Encode stdin into provided file\\n\", args[0]);\n+        tfm::format(std::cerr, \"       %s lookup <file> <IP>...  Look up ASN for provided IPs in file\\n\", args[0]);\n+        tfm::format(std::cerr, \"       %s help                   Print this message\\n\", args[0]);\n+        return (args.size() != 2 || args[1] == \"help\");\n+    }\n+\n+    return 0;\n+}"
      }
    ]
  }
]