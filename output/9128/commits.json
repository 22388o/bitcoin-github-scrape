[
  {
    "sha": "d74e352e0136bb746c2975f9a4092f23b9d8899c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkNzRlMzUyZTAxMzZiYjc0NmMyOTc1ZjlhNDA5MmYyM2I5ZDg4OTlj",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-11-15T22:26:32Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-11-24T00:53:28Z"
      },
      "message": "net: Set feelers to disconnect at the end of the version message\n\nThis way we're not relying on messages going out after fDisconnect has been\nset.\n\nThis should not cause any real behavioral changes, though feelers should\narguably disconnect earlier in the process. That can be addressed in a later\nfunctional change.",
      "tree": {
        "sha": "8493599f95d7ef3cdcd8b1dfd715313435c53bbc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8493599f95d7ef3cdcd8b1dfd715313435c53bbc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d74e352e0136bb746c2975f9a4092f23b9d8899c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d74e352e0136bb746c2975f9a4092f23b9d8899c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d74e352e0136bb746c2975f9a4092f23b9d8899c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d74e352e0136bb746c2975f9a4092f23b9d8899c/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "93566e0c37c5ae104095474fea89f00dcb40f551",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/93566e0c37c5ae104095474fea89f00dcb40f551",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/93566e0c37c5ae104095474fea89f00dcb40f551"
      }
    ],
    "stats": {
      "total": 12,
      "additions": 6,
      "deletions": 6
    },
    "files": [
      {
        "sha": "bc4be84e0220d1b5668321f54a8d68b05fa50a0a",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d74e352e0136bb746c2975f9a4092f23b9d8899c/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d74e352e0136bb746c2975f9a4092f23b9d8899c/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=d74e352e0136bb746c2975f9a4092f23b9d8899c",
        "patch": "@@ -5086,12 +5086,6 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n     if (strCommand == NetMsgType::VERSION)\n     {\n-        // Feeler connections exist only to verify if address is online.\n-        if (pfrom->fFeeler) {\n-            assert(pfrom->fInbound == false);\n-            pfrom->fDisconnect = true;\n-        }\n-\n         // Each connection can only send one version message\n         if (pfrom->nVersion != 0)\n         {\n@@ -5227,6 +5221,12 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         int64_t nTimeOffset = nTime - GetTime();\n         pfrom->nTimeOffset = nTimeOffset;\n         AddTimeData(pfrom->addr, nTimeOffset);\n+\n+        // Feeler connections exist only to verify if address is online.\n+        if (pfrom->fFeeler) {\n+            assert(pfrom->fInbound == false);\n+            pfrom->fDisconnect = true;\n+        }\n     }\n \n "
      }
    ]
  },
  {
    "sha": "fedea8a14d482c31e1736fe1d2d0668f06b8b398",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmZWRlYThhMTRkNDgyYzMxZTE3MzZmZTFkMmQwNjY4ZjA2YjhiMzk4",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-11-09T19:17:51Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-11-24T00:53:28Z"
      },
      "message": "net: don't send any messages before handshake or after requested disconnect\n\nAlso, send reject messages earlier in SendMessages(), so that disconnections are\nprocessed earlier.\n\nThese changes combined should ensure that no message is ever sent after\nfDisconnect is set.",
      "tree": {
        "sha": "f7bae17cacef9a2f6c42809b103bcd927049acd2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f7bae17cacef9a2f6c42809b103bcd927049acd2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fedea8a14d482c31e1736fe1d2d0668f06b8b398",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fedea8a14d482c31e1736fe1d2d0668f06b8b398",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fedea8a14d482c31e1736fe1d2d0668f06b8b398",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fedea8a14d482c31e1736fe1d2d0668f06b8b398/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d74e352e0136bb746c2975f9a4092f23b9d8899c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d74e352e0136bb746c2975f9a4092f23b9d8899c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d74e352e0136bb746c2975f9a4092f23b9d8899c"
      }
    ],
    "stats": {
      "total": 46,
      "additions": 25,
      "deletions": 21
    },
    "files": [
      {
        "sha": "24f320832f84a3186879badeeba53191d60a5a0f",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 21,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fedea8a14d482c31e1736fe1d2d0668f06b8b398/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fedea8a14d482c31e1736fe1d2d0668f06b8b398/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=fedea8a14d482c31e1736fe1d2d0668f06b8b398",
        "patch": "@@ -6512,7 +6512,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n     const Consensus::Params& consensusParams = Params().GetConsensus();\n     {\n         // Don't send anything until we get its version message\n-        if (pto->nVersion == 0)\n+        if (pto->nVersion == 0 || pto->fDisconnect)\n             return true;\n \n         //\n@@ -6548,6 +6548,28 @@ bool SendMessages(CNode* pto, CConnman& connman)\n         if (!lockMain)\n             return true;\n \n+        CNodeState &state = *State(pto->GetId());\n+\n+        BOOST_FOREACH(const CBlockReject& reject, state.rejects)\n+            connman.PushMessage(pto, NetMsgType::REJECT, (string)NetMsgType::BLOCK, reject.chRejectCode, reject.strRejectReason, reject.hashBlock);\n+        state.rejects.clear();\n+\n+        if (state.fShouldBan) {\n+            state.fShouldBan = false;\n+            if (pto->fWhitelisted)\n+                LogPrintf(\"Warning: not punishing whitelisted peer %s!\\n\", pto->addr.ToString());\n+            else {\n+                pto->fDisconnect = true;\n+                if (pto->addr.IsLocal())\n+                    LogPrintf(\"Warning: not banning local peer %s!\\n\", pto->addr.ToString());\n+                else\n+                {\n+                    connman.Ban(pto->addr, BanReasonNodeMisbehaving);\n+                }\n+                return true;\n+            }\n+        }\n+\n         // Address refresh broadcast\n         int64_t nNow = GetTimeMicros();\n         if (!IsInitialBlockDownload() && pto->nNextLocalAddrSend < nNow) {\n@@ -6584,26 +6606,6 @@ bool SendMessages(CNode* pto, CConnman& connman)\n                 pto->vAddrToSend.shrink_to_fit();\n         }\n \n-        CNodeState &state = *State(pto->GetId());\n-        if (state.fShouldBan) {\n-            if (pto->fWhitelisted)\n-                LogPrintf(\"Warning: not punishing whitelisted peer %s!\\n\", pto->addr.ToString());\n-            else {\n-                pto->fDisconnect = true;\n-                if (pto->addr.IsLocal())\n-                    LogPrintf(\"Warning: not banning local peer %s!\\n\", pto->addr.ToString());\n-                else\n-                {\n-                    connman.Ban(pto->addr, BanReasonNodeMisbehaving);\n-                }\n-            }\n-            state.fShouldBan = false;\n-        }\n-\n-        BOOST_FOREACH(const CBlockReject& reject, state.rejects)\n-            connman.PushMessage(pto, NetMsgType::REJECT, (string)NetMsgType::BLOCK, reject.chRejectCode, reject.strRejectReason, reject.hashBlock);\n-        state.rejects.clear();\n-\n         // Start block sync\n         if (pindexBestHeader == NULL)\n             pindexBestHeader = chainActive.Tip();\n@@ -6901,6 +6903,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n             // should only happen during initial block download.\n             LogPrintf(\"Peer=%d is stalling block download, disconnecting\\n\", pto->id);\n             pto->fDisconnect = true;\n+            return true;\n         }\n         // In case there is a block that has been in flight from this peer for 2 + 0.5 * N times the block interval\n         // (with N the number of peers from which we're downloading validated blocks), disconnect due to timeout.\n@@ -6913,6 +6916,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n             if (nNow > state.nDownloadingSince + consensusParams.nPowTargetSpacing * (BLOCK_DOWNLOAD_TIMEOUT_BASE + BLOCK_DOWNLOAD_TIMEOUT_PER_PEER * nOtherPeersWithValidatedDownloads)) {\n                 LogPrintf(\"Timeout downloading block %s from peer=%d, disconnecting\\n\", queuedBlock.hash.ToString(), pto->id);\n                 pto->fDisconnect = true;\n+                return true;\n             }\n         }\n "
      }
    ]
  },
  {
    "sha": "b7695c2275d977f20343020f2e9ba5d746928a6e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiNzY5NWMyMjc1ZDk3N2YyMDM0MzAyMGYyZTliYTVkNzQ2OTI4YTZl",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-11-09T19:25:19Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-11-25T17:09:58Z"
      },
      "message": "net: No need to check individually for disconnection anymore",
      "tree": {
        "sha": "3651c5b61f6c68cbd9110a36502aa16dd7e272aa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3651c5b61f6c68cbd9110a36502aa16dd7e272aa"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b7695c2275d977f20343020f2e9ba5d746928a6e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b7695c2275d977f20343020f2e9ba5d746928a6e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b7695c2275d977f20343020f2e9ba5d746928a6e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b7695c2275d977f20343020f2e9ba5d746928a6e/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fedea8a14d482c31e1736fe1d2d0668f06b8b398",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fedea8a14d482c31e1736fe1d2d0668f06b8b398",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fedea8a14d482c31e1736fe1d2d0668f06b8b398"
      }
    ],
    "stats": {
      "total": 14,
      "additions": 7,
      "deletions": 7
    },
    "files": [
      {
        "sha": "11c7b2ec6a0578830d53e218f19816126adc2459",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b7695c2275d977f20343020f2e9ba5d746928a6e/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b7695c2275d977f20343020f2e9ba5d746928a6e/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=b7695c2275d977f20343020f2e9ba5d746928a6e",
        "patch": "@@ -6527,7 +6527,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n             // Ping automatically sent as a latency probe & keepalive.\n             pingSend = true;\n         }\n-        if (pingSend && !pto->fDisconnect) {\n+        if (pingSend) {\n             uint64_t nonce = 0;\n             while (nonce == 0) {\n                 GetRandBytes((unsigned char*)&nonce, sizeof(nonce));\n@@ -6610,7 +6610,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n         if (pindexBestHeader == NULL)\n             pindexBestHeader = chainActive.Tip();\n         bool fFetch = state.fPreferredDownload || (nPreferredDownload == 0 && !pto->fClient && !pto->fOneShot); // Download if this is a nice peer, or we have no nice peers and this one might do.\n-        if (!state.fSyncStarted && !pto->fClient && !pto->fDisconnect && !fImporting && !fReindex) {\n+        if (!state.fSyncStarted && !pto->fClient && !fImporting && !fReindex) {\n             // Only actively request headers from a single peer, unless we're close to today.\n             if ((nSyncStarted == 0 && fFetch) || pindexBestHeader->GetBlockTime() > GetAdjustedTime() - 24 * 60 * 60) {\n                 state.fSyncStarted = true;\n@@ -6897,7 +6897,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n \n         // Detect whether we're stalling\n         nNow = GetTimeMicros();\n-        if (!pto->fDisconnect && state.nStallingSince && state.nStallingSince < nNow - 1000000 * BLOCK_STALLING_TIMEOUT) {\n+        if (state.nStallingSince && state.nStallingSince < nNow - 1000000 * BLOCK_STALLING_TIMEOUT) {\n             // Stalling only triggers when the block download window cannot move. During normal steady state,\n             // the download window should be much larger than the to-be-downloaded set of blocks, so disconnection\n             // should only happen during initial block download.\n@@ -6910,7 +6910,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n         // We compensate for other peers to prevent killing off peers due to our own downstream link\n         // being saturated. We only count validated in-flight blocks so peers can't advertise non-existing block hashes\n         // to unreasonably increase our timeout.\n-        if (!pto->fDisconnect && state.vBlocksInFlight.size() > 0) {\n+        if (state.vBlocksInFlight.size() > 0) {\n             QueuedBlock &queuedBlock = state.vBlocksInFlight.front();\n             int nOtherPeersWithValidatedDownloads = nPeersWithValidatedDownloads - (state.nBlocksInFlightValidHeaders > 0);\n             if (nNow > state.nDownloadingSince + consensusParams.nPowTargetSpacing * (BLOCK_DOWNLOAD_TIMEOUT_BASE + BLOCK_DOWNLOAD_TIMEOUT_PER_PEER * nOtherPeersWithValidatedDownloads)) {\n@@ -6924,7 +6924,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n         // Message: getdata (blocks)\n         //\n         vector<CInv> vGetData;\n-        if (!pto->fDisconnect && !pto->fClient && (fFetch || !IsInitialBlockDownload()) && state.nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n+        if (!pto->fClient && (fFetch || !IsInitialBlockDownload()) && state.nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n             vector<CBlockIndex*> vToDownload;\n             NodeId staller = -1;\n             FindNextBlocksToDownload(pto->GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller, consensusParams);\n@@ -6946,7 +6946,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n         //\n         // Message: getdata (non-blocks)\n         //\n-        while (!pto->fDisconnect && !pto->mapAskFor.empty() && (*pto->mapAskFor.begin()).first <= nNow)\n+        while (!pto->mapAskFor.empty() && (*pto->mapAskFor.begin()).first <= nNow)\n         {\n             const CInv& inv = (*pto->mapAskFor.begin()).second;\n             if (!AlreadyHave(inv))\n@@ -6972,7 +6972,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n         // Message: feefilter\n         //\n         // We don't want white listed peers to filter txs to us if we have -whitelistforcerelay\n-        if (!pto->fDisconnect && pto->nVersion >= FEEFILTER_VERSION && GetBoolArg(\"-feefilter\", DEFAULT_FEEFILTER) &&\n+        if (pto->nVersion >= FEEFILTER_VERSION && GetBoolArg(\"-feefilter\", DEFAULT_FEEFILTER) &&\n             !(pto->fWhitelisted && GetBoolArg(\"-whitelistforcerelay\", DEFAULT_WHITELISTFORCERELAY))) {\n             CAmount currentFilter = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFeePerK();\n             int64_t timeNow = GetTimeMicros();"
      }
    ]
  },
  {
    "sha": "2ec935dcaab9557addcf73c33aa7f2db8cc01fee",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyZWM5MzVkY2FhYjk1NTdhZGRjZjczYzMzYWE3ZjJkYjhjYzAxZmVl",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-11-10T22:05:23Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-11-25T17:09:58Z"
      },
      "message": "net: add CVectorWriter and CNetMsgMaker\n\nCVectorWriter is useful for overwriting or appending an existing byte vector.\n\nCNetMsgMaker is a shortcut for creating messages on-the-fly which are suitable\nfor pushing to CConnman.",
      "tree": {
        "sha": "3d5d7a29e05f457cee199fd273f24be8fd33550c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3d5d7a29e05f457cee199fd273f24be8fd33550c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2ec935dcaab9557addcf73c33aa7f2db8cc01fee",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2ec935dcaab9557addcf73c33aa7f2db8cc01fee",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2ec935dcaab9557addcf73c33aa7f2db8cc01fee",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2ec935dcaab9557addcf73c33aa7f2db8cc01fee/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b7695c2275d977f20343020f2e9ba5d746928a6e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b7695c2275d977f20343020f2e9ba5d746928a6e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b7695c2275d977f20343020f2e9ba5d746928a6e"
      }
    ],
    "stats": {
      "total": 178,
      "additions": 178,
      "deletions": 0
    },
    "files": [
      {
        "sha": "69ae02f582b305e8273c68a3cc3f662d79f2752d",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2ec935dcaab9557addcf73c33aa7f2db8cc01fee/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2ec935dcaab9557addcf73c33aa7f2db8cc01fee/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=2ec935dcaab9557addcf73c33aa7f2db8cc01fee",
        "patch": "@@ -111,6 +111,7 @@ BITCOIN_CORE_H = \\\n   net.h \\\n   netaddress.h \\\n   netbase.h \\\n+  netmessagemaker.h \\\n   noui.h \\\n   policy/fees.h \\\n   policy/policy.h \\"
      },
      {
        "sha": "9ea056c6eeb5d29e9fd128106a71de2ceac2f97f",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2ec935dcaab9557addcf73c33aa7f2db8cc01fee/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2ec935dcaab9557addcf73c33aa7f2db8cc01fee/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=2ec935dcaab9557addcf73c33aa7f2db8cc01fee",
        "patch": "@@ -101,6 +101,20 @@ class CTransaction;\n class CNodeStats;\n class CClientUIInterface;\n \n+struct CSerializedNetMsg\n+{\n+    CSerializedNetMsg() = default;\n+    CSerializedNetMsg(CSerializedNetMsg&&) = default;\n+    CSerializedNetMsg& operator=(CSerializedNetMsg&&) = default;\n+    // No copying, only moves.\n+    CSerializedNetMsg(const CSerializedNetMsg& msg) = delete;\n+    CSerializedNetMsg& operator=(const CSerializedNetMsg&) = delete;\n+\n+    std::vector<unsigned char> data;\n+    std::string command;\n+};\n+\n+\n class CConnman\n {\n public:"
      },
      {
        "sha": "7167434a19ebed663e10cd4c354540b09088c6dd",
        "filename": "src/netmessagemaker.h",
        "status": "added",
        "additions": 36,
        "deletions": 0,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2ec935dcaab9557addcf73c33aa7f2db8cc01fee/src/netmessagemaker.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2ec935dcaab9557addcf73c33aa7f2db8cc01fee/src/netmessagemaker.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netmessagemaker.h?ref=2ec935dcaab9557addcf73c33aa7f2db8cc01fee",
        "patch": "@@ -0,0 +1,36 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NETMESSAGEMAKER_H\n+#define BITCOIN_NETMESSAGEMAKER_H\n+\n+#include \"net.h\"\n+#include \"serialize.h\"\n+\n+class CNetMsgMaker\n+{\n+public:\n+    CNetMsgMaker(int nVersionIn) : nVersion(nVersionIn){}\n+\n+    template <typename... Args>\n+    CSerializedNetMsg Make(int nFlags, std::string sCommand, Args&&... args)\n+    {\n+        CSerializedNetMsg msg;\n+        msg.command = std::move(sCommand);\n+        CVectorWriter{ SER_NETWORK, nFlags | nVersion, msg.data, 0, std::forward<Args>(args)... };\n+        return msg;\n+    }\n+\n+    template <typename... Args>\n+    CSerializedNetMsg Make(std::string sCommand, Args&&... args)\n+    {\n+        return Make(0, std::move(sCommand), std::forward<Args>(args)...);\n+    }\n+\n+private:\n+    const int nVersion;\n+};\n+\n+#endif // BITCOIN_NETMESSAGEMAKER_H"
      },
      {
        "sha": "b508784238de7d3cf74f09588c8b35d5351a5ac2",
        "filename": "src/streams.h",
        "status": "modified",
        "additions": 69,
        "deletions": 0,
        "changes": 69,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2ec935dcaab9557addcf73c33aa7f2db8cc01fee/src/streams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2ec935dcaab9557addcf73c33aa7f2db8cc01fee/src/streams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/streams.h?ref=2ec935dcaab9557addcf73c33aa7f2db8cc01fee",
        "patch": "@@ -69,6 +69,75 @@ OverrideStream<S> WithOrVersion(S* s, int nVersionFlag)\n     return OverrideStream<S>(s, s->GetType(), s->GetVersion() | nVersionFlag);\n }\n \n+/* Minimal stream for overwriting and/or appending to an existing byte vector\n+ *\n+ * The referenced vector will grow as necessary\n+ */\n+class CVectorWriter\n+{\n+ public:\n+\n+/*\n+ * @param[in]  nTypeIn Serialization Type\n+ * @param[in]  nVersionIn Serialization Version (including any flags)\n+ * @param[in]  vchDataIn  Referenced byte vector to overwrite/append\n+ * @param[in]  nPosIn Starting position. Vector index where writes should start. The vector will initially\n+ *                    grow as necessary to  max(index, vec.size()). So to append, use vec.size().\n+*/\n+    CVectorWriter(int nTypeIn, int nVersionIn, std::vector<unsigned char>& vchDataIn, size_t nPosIn) : nType(nTypeIn), nVersion(nVersionIn), vchData(vchDataIn), nPos(nPosIn)\n+    {\n+        if(nPos > vchData.size())\n+            vchData.resize(nPos);\n+    }\n+/*\n+ * (other params same as above)\n+ * @param[in]  args  A list of items to serialize starting at nPos.\n+*/\n+    template <typename... Args>\n+    CVectorWriter(int nTypeIn, int nVersionIn, std::vector<unsigned char>& vchDataIn, size_t nPosIn, Args&&... args) : CVectorWriter(nTypeIn, nVersionIn, vchDataIn, nPosIn)\n+    {\n+        ::SerializeMany(*this, std::forward<Args>(args)...);\n+    }\n+    void write(const char* pch, size_t nSize)\n+    {\n+        assert(nPos <= vchData.size());\n+        size_t nOverwrite = std::min(nSize, vchData.size() - nPos);\n+        if (nOverwrite) {\n+            memcpy(vchData.data() + nPos, reinterpret_cast<const unsigned char*>(pch), nOverwrite);\n+        }\n+        if (nOverwrite < nSize) {\n+            vchData.insert(vchData.end(), reinterpret_cast<const unsigned char*>(pch) + nOverwrite, reinterpret_cast<const unsigned char*>(pch) + nSize);\n+        }\n+        nPos += nSize;\n+    }\n+    template<typename T>\n+    CVectorWriter& operator<<(const T& obj)\n+    {\n+        // Serialize to this stream\n+        ::Serialize(*this, obj);\n+        return (*this);\n+    }\n+    int GetVersion() const\n+    {\n+        return nVersion;\n+    }\n+    int GetType() const\n+    {\n+        return nType;\n+    }\n+    void seek(size_t nSize)\n+    {\n+        nPos += nSize;\n+        if(nPos > vchData.size())\n+            vchData.resize(nPos);\n+    }\n+private:\n+    const int nType;\n+    const int nVersion;\n+    std::vector<unsigned char>& vchData;\n+    size_t nPos;\n+};\n+\n /** Double ended buffer combining vector and stream-like interfaces.\n  *\n  * >> and << read and write unformatted data using the above serialization templates."
      },
      {
        "sha": "8b715ce93eefd3b8e1ebed429ef61d21dda0f3fb",
        "filename": "src/test/streams_tests.cpp",
        "status": "modified",
        "additions": 58,
        "deletions": 0,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2ec935dcaab9557addcf73c33aa7f2db8cc01fee/src/test/streams_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2ec935dcaab9557addcf73c33aa7f2db8cc01fee/src/test/streams_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/streams_tests.cpp?ref=2ec935dcaab9557addcf73c33aa7f2db8cc01fee",
        "patch": "@@ -15,6 +15,64 @@ using namespace boost::assign; // bring 'operator+=()' into scope\n \n BOOST_FIXTURE_TEST_SUITE(streams_tests, BasicTestingSetup)\n \n+BOOST_AUTO_TEST_CASE(streams_vector_writer)\n+{\n+    unsigned char a(1);\n+    unsigned char b(2);\n+    unsigned char bytes[] = { 3, 4, 5, 6 };\n+    std::vector<unsigned char> vch;\n+\n+    // Each test runs twice. Serializing a second time at the same starting\n+    // point should yield the same results, even if the first test grew the\n+    // vector.\n+\n+    CVectorWriter(SER_NETWORK, INIT_PROTO_VERSION, vch, 0, a, b);\n+    BOOST_CHECK((vch == std::vector<unsigned char>{{1, 2}}));\n+    CVectorWriter(SER_NETWORK, INIT_PROTO_VERSION, vch, 0, a, b);\n+    BOOST_CHECK((vch == std::vector<unsigned char>{{1, 2}}));\n+    vch.clear();\n+\n+    CVectorWriter(SER_NETWORK, INIT_PROTO_VERSION, vch, 2, a, b);\n+    BOOST_CHECK((vch == std::vector<unsigned char>{{0, 0, 1, 2}}));\n+    CVectorWriter(SER_NETWORK, INIT_PROTO_VERSION, vch, 2, a, b);\n+    BOOST_CHECK((vch == std::vector<unsigned char>{{0, 0, 1, 2}}));\n+    vch.clear();\n+\n+    vch.resize(5, 0);\n+    CVectorWriter(SER_NETWORK, INIT_PROTO_VERSION, vch, 2, a, b);\n+    BOOST_CHECK((vch == std::vector<unsigned char>{{0, 0, 1, 2, 0}}));\n+    CVectorWriter(SER_NETWORK, INIT_PROTO_VERSION, vch, 2, a, b);\n+    BOOST_CHECK((vch == std::vector<unsigned char>{{0, 0, 1, 2, 0}}));\n+    vch.clear();\n+\n+    vch.resize(4, 0);\n+    CVectorWriter(SER_NETWORK, INIT_PROTO_VERSION, vch, 3, a, b);\n+    BOOST_CHECK((vch == std::vector<unsigned char>{{0, 0, 0, 1, 2}}));\n+    CVectorWriter(SER_NETWORK, INIT_PROTO_VERSION, vch, 3, a, b);\n+    BOOST_CHECK((vch == std::vector<unsigned char>{{0, 0, 0, 1, 2}}));\n+    vch.clear();\n+\n+    vch.resize(4, 0);\n+    CVectorWriter(SER_NETWORK, INIT_PROTO_VERSION, vch, 4, a, b);\n+    BOOST_CHECK((vch == std::vector<unsigned char>{{0, 0, 0, 0, 1, 2}}));\n+    CVectorWriter(SER_NETWORK, INIT_PROTO_VERSION, vch, 4, a, b);\n+    BOOST_CHECK((vch == std::vector<unsigned char>{{0, 0, 0, 0, 1, 2}}));\n+    vch.clear();\n+\n+    CVectorWriter(SER_NETWORK, INIT_PROTO_VERSION, vch, 0, FLATDATA(bytes));\n+    BOOST_CHECK((vch == std::vector<unsigned char>{{3, 4, 5, 6}}));\n+    CVectorWriter(SER_NETWORK, INIT_PROTO_VERSION, vch, 0, FLATDATA(bytes));\n+    BOOST_CHECK((vch == std::vector<unsigned char>{{3, 4, 5, 6}}));\n+    vch.clear();\n+\n+    vch.resize(4, 8);\n+    CVectorWriter(SER_NETWORK, INIT_PROTO_VERSION, vch, 2, a, FLATDATA(bytes), b);\n+    BOOST_CHECK((vch == std::vector<unsigned char>{{8, 8, 1, 3, 4, 5, 6, 2}}));\n+    CVectorWriter(SER_NETWORK, INIT_PROTO_VERSION, vch, 2, a, FLATDATA(bytes), b);\n+    BOOST_CHECK((vch == std::vector<unsigned char>{{8, 8, 1, 3, 4, 5, 6, 2}}));\n+    vch.clear();\n+}\n+\n BOOST_AUTO_TEST_CASE(streams_serializedata_xor)\n {\n     std::vector<char> in;"
      }
    ]
  },
  {
    "sha": "c7be56dceff625991cb2884f2ce053996ac613cd",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjN2JlNTZkY2VmZjYyNTk5MWNiMjg4NGYyY2UwNTM5OTZhYzYxM2Nk",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-11-11T01:17:30Z"
      },
      "committer": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-11-25T17:37:33Z"
      },
      "message": "net: push only raw data into CConnman\n\nThis fixes one of the last major layer violations in the networking stack.\n\nThe network side is no longer in charge of message serialization, so it is now\ndecoupled from Bitcoin structures. Only the header is serialized and attached\nto the payload.",
      "tree": {
        "sha": "7a3ebc60d1d95ad377a9b000f42227b083e64b3b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7a3ebc60d1d95ad377a9b000f42227b083e64b3b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c7be56dceff625991cb2884f2ce053996ac613cd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c7be56dceff625991cb2884f2ce053996ac613cd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c7be56dceff625991cb2884f2ce053996ac613cd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c7be56dceff625991cb2884f2ce053996ac613cd/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2ec935dcaab9557addcf73c33aa7f2db8cc01fee",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2ec935dcaab9557addcf73c33aa7f2db8cc01fee",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2ec935dcaab9557addcf73c33aa7f2db8cc01fee"
      }
    ],
    "stats": {
      "total": 212,
      "additions": 93,
      "deletions": 119
    },
    "files": [
      {
        "sha": "559538165c1f2c066675ae96e0bc75a271f4606d",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 71,
        "deletions": 60,
        "changes": 131,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c7be56dceff625991cb2884f2ce053996ac613cd/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c7be56dceff625991cb2884f2ce053996ac613cd/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=c7be56dceff625991cb2884f2ce053996ac613cd",
        "patch": "@@ -18,6 +18,7 @@\n #include \"init.h\"\n #include \"merkleblock.h\"\n #include \"net.h\"\n+#include \"netmessagemaker.h\"\n #include \"netbase.h\"\n #include \"policy/fees.h\"\n #include \"policy/policy.h\"\n@@ -368,8 +369,8 @@ void PushNodeVersion(CNode *pnode, CConnman& connman, int64_t nTime)\n     CAddress addrYou = (addr.IsRoutable() && !IsProxy(addr) ? addr : CAddress(CService(), addr.nServices));\n     CAddress addrMe = CAddress(CService(), nLocalNodeServices);\n \n-    connman.PushMessageWithVersion(pnode, INIT_PROTO_VERSION, NetMsgType::VERSION, PROTOCOL_VERSION, (uint64_t)nLocalNodeServices, nTime, addrYou, addrMe,\n-            nonce, strSubVersion, nNodeStartingHeight, ::fRelayTxes);\n+    connman.PushMessage(pnode, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERSION, PROTOCOL_VERSION, (uint64_t)nLocalNodeServices, nTime, addrYou, addrMe,\n+            nonce, strSubVersion, nNodeStartingHeight, ::fRelayTxes));\n \n     if (fLogIPs)\n         LogPrint(\"net\", \"send version message: version %d, blocks=%d, us=%s, them=%s, peer=%d\\n\", PROTOCOL_VERSION, nNodeStartingHeight, addrMe.ToString(), addrYou.ToString(), nodeid);\n@@ -530,13 +531,13 @@ void MaybeSetPeerAsAnnouncingHeaderAndIDs(const CNodeState* nodestate, CNode* pf\n             // As per BIP152, we only get 3 of our peers to announce\n             // blocks using compact encodings.\n             connman.ForNode(lNodesAnnouncingHeaderAndIDs.front(), [&connman, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion](CNode* pnodeStop){\n-                connman.PushMessage(pnodeStop, NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion);\n+                connman.PushMessage(pnodeStop, CNetMsgMaker(pnodeStop->GetSendVersion()).Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n                 return true;\n             });\n             lNodesAnnouncingHeaderAndIDs.pop_front();\n         }\n         fAnnounceUsingCMPCTBLOCK = true;\n-        connman.PushMessage(pfrom, NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion);\n+        connman.PushMessage(pfrom, CNetMsgMaker(pfrom->GetSendVersion()).Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n         lNodesAnnouncingHeaderAndIDs.push_back(pfrom->GetId());\n     }\n }\n@@ -4893,9 +4894,8 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n {\n     std::deque<CInv>::iterator it = pfrom->vRecvGetData.begin();\n     unsigned int nMaxSendBufferSize = connman.GetSendBufferSize();\n-\n     vector<CInv> vNotFound;\n-\n+    CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n     LOCK(cs_main);\n \n     while (it != pfrom->vRecvGetData.end()) {\n@@ -4949,9 +4949,9 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                     if (!ReadBlockFromDisk(block, (*mi).second, consensusParams))\n                         assert(!\"cannot load block from disk\");\n                     if (inv.type == MSG_BLOCK)\n-                        connman.PushMessageWithFlag(pfrom, SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, block);\n+                        connman.PushMessage(pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, block));\n                     else if (inv.type == MSG_WITNESS_BLOCK)\n-                        connman.PushMessage(pfrom, NetMsgType::BLOCK, block);\n+                        connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::BLOCK, block));\n                     else if (inv.type == MSG_FILTERED_BLOCK)\n                     {\n                         bool sendMerkleBlock = false;\n@@ -4964,7 +4964,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                             }\n                         }\n                         if (sendMerkleBlock) {\n-                            connman.PushMessage(pfrom, NetMsgType::MERKLEBLOCK, merkleBlock);\n+                            connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::MERKLEBLOCK, merkleBlock));\n                             // CMerkleBlock just contains hashes, so also push any transactions in the block the client did not see\n                             // This avoids hurting performance by pointlessly requiring a round-trip\n                             // Note that there is currently no way for a node to request any single transactions we didn't send here -\n@@ -4973,7 +4973,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                             // however we MUST always provide at least what the remote peer needs\n                             typedef std::pair<unsigned int, uint256> PairType;\n                             BOOST_FOREACH(PairType& pair, merkleBlock.vMatchedTxn)\n-                                connman.PushMessageWithFlag(pfrom, SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::TX, *block.vtx[pair.first]);\n+                                connman.PushMessage(pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::TX, *block.vtx[pair.first]));\n                         }\n                         // else\n                             // no response\n@@ -4985,11 +4985,12 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                         // and we don't feel like constructing the object for them, so\n                         // instead we respond with the full, non-compact block.\n                         bool fPeerWantsWitness = State(pfrom->GetId())->fWantsCmpctWitness;\n+                        int nSendFlags = fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n                         if (CanDirectFetch(consensusParams) && mi->second->nHeight >= chainActive.Height() - MAX_CMPCTBLOCK_DEPTH) {\n                             CBlockHeaderAndShortTxIDs cmpctblock(block, fPeerWantsWitness);\n-                            connman.PushMessageWithFlag(pfrom, fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::CMPCTBLOCK, cmpctblock);\n+                            connman.PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n                         } else\n-                            connman.PushMessageWithFlag(pfrom, fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, block);\n+                            connman.PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCK, block));\n                     }\n \n                     // Trigger the peer node to send a getblocks request for the next batch of inventory\n@@ -5000,7 +5001,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                         // wait for other stuff first.\n                         vector<CInv> vInv;\n                         vInv.push_back(CInv(MSG_BLOCK, chainActive.Tip()->GetBlockHash()));\n-                        connman.PushMessage(pfrom, NetMsgType::INV, vInv);\n+                        connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::INV, vInv));\n                         pfrom->hashContinue.SetNull();\n                     }\n                 }\n@@ -5010,15 +5011,16 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                 // Send stream from relay memory\n                 bool push = false;\n                 auto mi = mapRelay.find(inv.hash);\n+                int nSendFlags = (inv.type == MSG_TX ? SERIALIZE_TRANSACTION_NO_WITNESS : 0);\n                 if (mi != mapRelay.end()) {\n-                    connman.PushMessageWithFlag(pfrom, inv.type == MSG_TX ? SERIALIZE_TRANSACTION_NO_WITNESS : 0, NetMsgType::TX, *mi->second);\n+                    connman.PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::TX, *mi->second));\n                     push = true;\n                 } else if (pfrom->timeLastMempoolReq) {\n                     auto txinfo = mempool.info(inv.hash);\n                     // To protect privacy, do not answer getdata using the mempool when\n                     // that TX couldn't have been INVed in reply to a MEMPOOL request.\n                     if (txinfo.tx && txinfo.nTime <= pfrom->timeLastMempoolReq) {\n-                        connman.PushMessageWithFlag(pfrom, inv.type == MSG_TX ? SERIALIZE_TRANSACTION_NO_WITNESS : 0, NetMsgType::TX, *txinfo.tx);\n+                        connman.PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::TX, *txinfo.tx));\n                         push = true;\n                     }\n                 }\n@@ -5045,7 +5047,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n         // do that because they want to know about (and store and rebroadcast and\n         // risk analyze) the dependencies of transactions relevant to them, without\n         // having to download the entire memory pool.\n-        connman.PushMessage(pfrom, NetMsgType::NOTFOUND, vNotFound);\n+        connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::NOTFOUND, vNotFound));\n     }\n }\n \n@@ -5089,7 +5091,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         // Each connection can only send one version message\n         if (pfrom->nVersion != 0)\n         {\n-            connman.PushMessageWithVersion(pfrom, INIT_PROTO_VERSION, NetMsgType::REJECT, strCommand, REJECT_DUPLICATE, string(\"Duplicate version message\"));\n+            connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_DUPLICATE, string(\"Duplicate version message\")));\n             LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 1);\n             return false;\n@@ -5109,8 +5111,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         if (pfrom->nServicesExpected & ~pfrom->nServices)\n         {\n             LogPrint(\"net\", \"peer=%d does not offer the expected services (%08x offered, %08x expected); disconnecting\\n\", pfrom->id, pfrom->nServices, pfrom->nServicesExpected);\n-            connman.PushMessageWithVersion(pfrom, INIT_PROTO_VERSION, NetMsgType::REJECT, strCommand, REJECT_NONSTANDARD,\n-                               strprintf(\"Expected to offer services %08x\", pfrom->nServicesExpected));\n+            connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_NONSTANDARD,\n+                               strprintf(\"Expected to offer services %08x\", pfrom->nServicesExpected)));\n             pfrom->fDisconnect = true;\n             return false;\n         }\n@@ -5119,8 +5121,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         {\n             // disconnect from peers older than this proto version\n             LogPrintf(\"peer=%d using obsolete version %i; disconnecting\\n\", pfrom->id, pfrom->nVersion);\n-            connman.PushMessageWithVersion(pfrom, INIT_PROTO_VERSION, NetMsgType::REJECT, strCommand, REJECT_OBSOLETE,\n-                               strprintf(\"Version must be %d or greater\", MIN_PEER_PROTO_VERSION));\n+            connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_OBSOLETE,\n+                               strprintf(\"Version must be %d or greater\", MIN_PEER_PROTO_VERSION)));\n             pfrom->fDisconnect = true;\n             return false;\n         }\n@@ -5177,8 +5179,9 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         }\n \n         // Change version\n-        connman.PushMessageWithVersion(pfrom, INIT_PROTO_VERSION, NetMsgType::VERACK);\n-        pfrom->SetSendVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n+        connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERACK));\n+        int nSendVersion = std::min(pfrom->nVersion, PROTOCOL_VERSION);\n+        pfrom->SetSendVersion(nSendVersion);\n \n         if (!pfrom->fInbound)\n         {\n@@ -5201,7 +5204,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             // Get recent addresses\n             if (pfrom->fOneShot || pfrom->nVersion >= CADDR_TIME_VERSION || connman.GetAddressCount() < 1000)\n             {\n-                connman.PushMessage(pfrom, NetMsgType::GETADDR);\n+                connman.PushMessage(pfrom, CNetMsgMaker(nSendVersion).Make(NetMsgType::GETADDR));\n                 pfrom->fGetAddr = true;\n             }\n             connman.MarkAddressGood(pfrom->addr);\n@@ -5227,6 +5230,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             assert(pfrom->fInbound == false);\n             pfrom->fDisconnect = true;\n         }\n+        return true;\n     }\n \n \n@@ -5238,8 +5242,10 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         return false;\n     }\n \n+    // At this point, the outgoing message serialization version can't change.\n+    CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n \n-    else if (strCommand == NetMsgType::VERACK)\n+    if (strCommand == NetMsgType::VERACK)\n     {\n         pfrom->SetRecvVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n \n@@ -5254,7 +5260,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             // We send this to non-NODE NETWORK peers as well, because even\n             // non-NODE NETWORK peers can announce blocks (such as pruning\n             // nodes)\n-            connman.PushMessage(pfrom, NetMsgType::SENDHEADERS);\n+            connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::SENDHEADERS));\n         }\n         if (pfrom->nVersion >= SHORT_IDS_BLOCKS_VERSION) {\n             // Tell our peer we are willing to provide version 1 or 2 cmpctblocks\n@@ -5265,9 +5271,9 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             bool fAnnounceUsingCMPCTBLOCK = false;\n             uint64_t nCMPCTBLOCKVersion = 2;\n             if (pfrom->GetLocalServices() & NODE_WITNESS)\n-                connman.PushMessage(pfrom, NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion);\n+                connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n             nCMPCTBLOCKVersion = 1;\n-            connman.PushMessage(pfrom, NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion);\n+            connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion));\n         }\n     }\n \n@@ -5392,7 +5398,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                     // fell back to inv we probably have a reorg which we should get the headers for first,\n                     // we now only provide a getheaders response here. When we receive the headers, we will\n                     // then ask for the blocks we need.\n-                    connman.PushMessage(pfrom, NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), inv.hash);\n+                    connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), inv.hash));\n                     LogPrint(\"net\", \"getheaders (%d) %s to peer=%d\\n\", pindexBestHeader->nHeight, inv.hash.ToString(), pfrom->id);\n                 }\n             }\n@@ -5415,7 +5421,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         }\n \n         if (!vToFetch.empty())\n-            connman.PushMessage(pfrom, NetMsgType::GETDATA, vToFetch);\n+            connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vToFetch));\n     }\n \n \n@@ -5527,7 +5533,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             }\n             resp.txn[i] = block.vtx[req.indexes[i]];\n         }\n-        connman.PushMessageWithFlag(pfrom, State(pfrom->GetId())->fWantsCmpctWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCKTXN, resp);\n+        int nSendFlags = State(pfrom->GetId())->fWantsCmpctWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n+        connman.PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCKTXN, resp));\n     }\n \n \n@@ -5576,7 +5583,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         // headers message). In both cases it's safe to update\n         // pindexBestHeaderSent to be our tip.\n         nodestate->pindexBestHeaderSent = pindex ? pindex : chainActive.Tip();\n-        connman.PushMessage(pfrom, NetMsgType::HEADERS, vHeaders);\n+        connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::HEADERS, vHeaders));\n     }\n \n \n@@ -5739,8 +5746,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                 pfrom->id,\n                 FormatStateMessage(state));\n             if (state.GetRejectCode() < REJECT_INTERNAL) // Never send AcceptToMemoryPool's internal codes over P2P\n-                connman.PushMessage(pfrom, NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n-                                   state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), inv.hash);\n+                connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n+                                   state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), inv.hash));\n             if (nDoS > 0) {\n                 Misbehaving(pfrom->GetId(), nDoS);\n             }\n@@ -5758,7 +5765,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         if (mapBlockIndex.find(cmpctblock.header.hashPrevBlock) == mapBlockIndex.end()) {\n             // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n             if (!IsInitialBlockDownload())\n-                connman.PushMessage(pfrom, NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());\n+                connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256()));\n             return true;\n         }\n \n@@ -5791,7 +5798,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                 // so we just grab the block via normal getdata\n                 std::vector<CInv> vInv(1);\n                 vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom, pindex->pprev, chainparams.GetConsensus()), cmpctblock.header.GetHash());\n-                connman.PushMessage(pfrom, NetMsgType::GETDATA, vInv);\n+                connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n             }\n             return true;\n         }\n@@ -5835,7 +5842,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                     // Duplicate txindexes, the block is now in-flight, so just request it\n                     std::vector<CInv> vInv(1);\n                     vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom, pindex->pprev, chainparams.GetConsensus()), cmpctblock.header.GetHash());\n-                    connman.PushMessage(pfrom, NetMsgType::GETDATA, vInv);\n+                    connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n                     return true;\n                 }\n \n@@ -5859,7 +5866,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                     return ProcessMessage(pfrom, NetMsgType::BLOCKTXN, blockTxnMsg, nTimeReceived, chainparams, connman);\n                 } else {\n                     req.blockhash = pindex->GetBlockHash();\n-                    connman.PushMessage(pfrom, NetMsgType::GETBLOCKTXN, req);\n+                    connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETBLOCKTXN, req));\n                 }\n             }\n         } else {\n@@ -5868,7 +5875,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                 // mempool will probably be useless - request the block normally\n                 std::vector<CInv> vInv(1);\n                 vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom, pindex->pprev, chainparams.GetConsensus()), cmpctblock.header.GetHash());\n-                connman.PushMessage(pfrom, NetMsgType::GETDATA, vInv);\n+                connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n                 return true;\n             } else {\n                 // If this was an announce-cmpctblock, we want the same treatment as a header message\n@@ -5910,7 +5917,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                 // Might have collided, fall back to getdata now :(\n                 std::vector<CInv> invs;\n                 invs.push_back(CInv(MSG_BLOCK | GetFetchFlags(pfrom, chainActive.Tip(), chainparams.GetConsensus()), resp.blockhash));\n-                connman.PushMessage(pfrom, NetMsgType::GETDATA, invs);\n+                connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, invs));\n             } else {\n                 // Block is either okay, or possibly we received\n                 // READ_STATUS_CHECKBLOCK_FAILED.\n@@ -5987,7 +5994,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         //   nUnconnectingHeaders gets reset back to 0.\n         if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end() && nCount < MAX_BLOCKS_TO_ANNOUNCE) {\n             nodestate->nUnconnectingHeaders++;\n-            connman.PushMessage(pfrom, NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());\n+            connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256()));\n             LogPrint(\"net\", \"received header %s: missing prev block %s, sending getheaders (%d) to end (peer=%d, nUnconnectingHeaders=%d)\\n\",\n                     headers[0].GetHash().ToString(),\n                     headers[0].hashPrevBlock.ToString(),\n@@ -6034,7 +6041,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             // TODO: optimize: if pindexLast is an ancestor of chainActive.Tip or pindexBestHeader, continue\n             // from there instead.\n             LogPrint(\"net\", \"more getheaders (%d) to end to peer=%d (startheight:%d)\\n\", pindexLast->nHeight, pfrom->id, pfrom->nStartingHeight);\n-            connman.PushMessage(pfrom, NetMsgType::GETHEADERS, chainActive.GetLocator(pindexLast), uint256());\n+            connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexLast), uint256()));\n         }\n \n         bool fCanDirectFetch = CanDirectFetch(chainparams.GetConsensus());\n@@ -6087,7 +6094,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                         // In any case, we want to download using a compact block, not a regular one\n                         vGetData[0] = CInv(MSG_CMPCT_BLOCK, vGetData[0].hash);\n                     }\n-                    connman.PushMessage(pfrom, NetMsgType::GETDATA, vGetData);\n+                    connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n                 }\n             }\n         }\n@@ -6191,7 +6198,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             // it, if the remote node sends a ping once per second and this node takes 5\n             // seconds to respond to each, the 5th ping the remote sends would appear to\n             // return very quickly.\n-            connman.PushMessage(pfrom, NetMsgType::PONG, nonce);\n+            connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::PONG, nonce));\n         }\n     }\n \n@@ -6447,7 +6454,7 @@ bool ProcessMessages(CNode* pfrom, CConnman& connman)\n         }\n         catch (const std::ios_base::failure& e)\n         {\n-            connman.PushMessageWithVersion(pfrom, INIT_PROTO_VERSION, NetMsgType::REJECT, strCommand, REJECT_MALFORMED, string(\"error parsing message\"));\n+            connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_MALFORMED, string(\"error parsing message\")));\n             if (strstr(e.what(), \"end of data\"))\n             {\n                 // Allow exceptions from under-length message on vRecv\n@@ -6515,6 +6522,9 @@ bool SendMessages(CNode* pto, CConnman& connman)\n         if (pto->nVersion == 0 || pto->fDisconnect)\n             return true;\n \n+        // If we get here, the outgoing message serialization version is set and can't change.\n+        CNetMsgMaker msgMaker(pto->GetSendVersion());\n+\n         //\n         // Message: ping\n         //\n@@ -6536,11 +6546,11 @@ bool SendMessages(CNode* pto, CConnman& connman)\n             pto->nPingUsecStart = GetTimeMicros();\n             if (pto->nVersion > BIP0031_VERSION) {\n                 pto->nPingNonceSent = nonce;\n-                connman.PushMessage(pto, NetMsgType::PING, nonce);\n+                connman.PushMessage(pto, msgMaker.Make(NetMsgType::PING, nonce));\n             } else {\n                 // Peer is too old to support ping command with nonce, pong will never arrive.\n                 pto->nPingNonceSent = 0;\n-                connman.PushMessage(pto, NetMsgType::PING);\n+                connman.PushMessage(pto, msgMaker.Make(NetMsgType::PING));\n             }\n         }\n \n@@ -6551,7 +6561,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n         CNodeState &state = *State(pto->GetId());\n \n         BOOST_FOREACH(const CBlockReject& reject, state.rejects)\n-            connman.PushMessage(pto, NetMsgType::REJECT, (string)NetMsgType::BLOCK, reject.chRejectCode, reject.strRejectReason, reject.hashBlock);\n+            connman.PushMessage(pto, msgMaker.Make(NetMsgType::REJECT, (string)NetMsgType::BLOCK, reject.chRejectCode, reject.strRejectReason, reject.hashBlock));\n         state.rejects.clear();\n \n         if (state.fShouldBan) {\n@@ -6593,14 +6603,14 @@ bool SendMessages(CNode* pto, CConnman& connman)\n                     // receiver rejects addr messages larger than 1000\n                     if (vAddr.size() >= 1000)\n                     {\n-                        connman.PushMessage(pto, NetMsgType::ADDR, vAddr);\n+                        connman.PushMessage(pto, msgMaker.Make(NetMsgType::ADDR, vAddr));\n                         vAddr.clear();\n                     }\n                 }\n             }\n             pto->vAddrToSend.clear();\n             if (!vAddr.empty())\n-                connman.PushMessage(pto, NetMsgType::ADDR, vAddr);\n+                connman.PushMessage(pto, msgMaker.Make(NetMsgType::ADDR, vAddr));\n             // we only send the big addr message once\n             if (pto->vAddrToSend.capacity() > 40)\n                 pto->vAddrToSend.shrink_to_fit();\n@@ -6626,7 +6636,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n                 if (pindexStart->pprev)\n                     pindexStart = pindexStart->pprev;\n                 LogPrint(\"net\", \"initial getheaders (%d) to peer=%d (startheight:%d)\\n\", pindexStart->nHeight, pto->id, pto->nStartingHeight);\n-                connman.PushMessage(pto, NetMsgType::GETHEADERS, chainActive.GetLocator(pindexStart), uint256());\n+                connman.PushMessage(pto, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexStart), uint256()));\n             }\n         }\n \n@@ -6715,7 +6725,8 @@ bool SendMessages(CNode* pto, CConnman& connman)\n                     CBlock block;\n                     assert(ReadBlockFromDisk(block, pBestIndex, consensusParams));\n                     CBlockHeaderAndShortTxIDs cmpctblock(block, state.fWantsCmpctWitness);\n-                    connman.PushMessageWithFlag(pto, state.fWantsCmpctWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::CMPCTBLOCK, cmpctblock);\n+                    int nSendFlags = state.fWantsCmpctWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n+                    connman.PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n                     state.pindexBestHeaderSent = pBestIndex;\n                 } else if (state.fPreferHeaders) {\n                     if (vHeaders.size() > 1) {\n@@ -6727,7 +6738,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n                         LogPrint(\"net\", \"%s: sending header %s to peer=%d\\n\", __func__,\n                                 vHeaders.front().GetHash().ToString(), pto->id);\n                     }\n-                    connman.PushMessage(pto, NetMsgType::HEADERS, vHeaders);\n+                    connman.PushMessage(pto, msgMaker.Make(NetMsgType::HEADERS, vHeaders));\n                     state.pindexBestHeaderSent = pBestIndex;\n                 } else\n                     fRevertToInv = true;\n@@ -6773,7 +6784,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n             BOOST_FOREACH(const uint256& hash, pto->vInventoryBlockToSend) {\n                 vInv.push_back(CInv(MSG_BLOCK, hash));\n                 if (vInv.size() == MAX_INV_SZ) {\n-                    connman.PushMessage(pto, NetMsgType::INV, vInv);\n+                    connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n                     vInv.clear();\n                 }\n             }\n@@ -6819,7 +6830,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n                     pto->filterInventoryKnown.insert(hash);\n                     vInv.push_back(inv);\n                     if (vInv.size() == MAX_INV_SZ) {\n-                        connman.PushMessage(pto, NetMsgType::INV, vInv);\n+                        connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n                         vInv.clear();\n                     }\n                 }\n@@ -6885,15 +6896,15 @@ bool SendMessages(CNode* pto, CConnman& connman)\n                         }\n                     }\n                     if (vInv.size() == MAX_INV_SZ) {\n-                        connman.PushMessage(pto, NetMsgType::INV, vInv);\n+                        connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n                         vInv.clear();\n                     }\n                     pto->filterInventoryKnown.insert(hash);\n                 }\n             }\n         }\n         if (!vInv.empty())\n-            connman.PushMessage(pto, NetMsgType::INV, vInv);\n+            connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n \n         // Detect whether we're stalling\n         nNow = GetTimeMicros();\n@@ -6956,7 +6967,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n                 vGetData.push_back(inv);\n                 if (vGetData.size() >= 1000)\n                 {\n-                    connman.PushMessage(pto, NetMsgType::GETDATA, vGetData);\n+                    connman.PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n                     vGetData.clear();\n                 }\n             } else {\n@@ -6966,7 +6977,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n             pto->mapAskFor.erase(pto->mapAskFor.begin());\n         }\n         if (!vGetData.empty())\n-            connman.PushMessage(pto, NetMsgType::GETDATA, vGetData);\n+            connman.PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n \n         //\n         // Message: feefilter\n@@ -6979,7 +6990,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n             if (timeNow > pto->nextSendTimeFeeFilter) {\n                 CAmount filterToSend = filterRounder.round(currentFilter);\n                 if (filterToSend != pto->lastSentFeeFilter) {\n-                    connman.PushMessage(pto, NetMsgType::FEEFILTER, filterToSend);\n+                    connman.PushMessage(pto, msgMaker.Make(NetMsgType::FEEFILTER, filterToSend));\n                     pto->lastSentFeeFilter = filterToSend;\n                 }\n                 pto->nextSendTimeFeeFilter = PoissonNextSend(timeNow, AVG_FEEFILTER_BROADCAST_INTERVAL);"
      },
      {
        "sha": "ce87150ae365f44e2bd6424d26bf937716de4dfb",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 27,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c7be56dceff625991cb2884f2ce053996ac613cd/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c7be56dceff625991cb2884f2ce053996ac613cd/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=c7be56dceff625991cb2884f2ce053996ac613cd",
        "patch": "@@ -768,13 +768,13 @@ const uint256& CNetMessage::GetMessageHash() const\n // requires LOCK(cs_vSend)\n size_t SocketSendData(CNode *pnode)\n {\n-    std::deque<CSerializeData>::iterator it = pnode->vSendMsg.begin();\n+    auto it = pnode->vSendMsg.begin();\n     size_t nSentSize = 0;\n \n     while (it != pnode->vSendMsg.end()) {\n-        const CSerializeData &data = *it;\n+        const auto &data = *it;\n         assert(data.size() > pnode->nSendOffset);\n-        int nBytes = send(pnode->hSocket, &data[pnode->nSendOffset], data.size() - pnode->nSendOffset, MSG_NOSIGNAL | MSG_DONTWAIT);\n+        int nBytes = send(pnode->hSocket, reinterpret_cast<const char*>(data.data()) + pnode->nSendOffset, data.size() - pnode->nSendOffset, MSG_NOSIGNAL | MSG_DONTWAIT);\n         if (nBytes > 0) {\n             pnode->nLastSend = GetTime();\n             pnode->nSendBytes += nBytes;\n@@ -2612,30 +2612,19 @@ void CNode::AskFor(const CInv& inv)\n     mapAskFor.insert(std::make_pair(nRequestTime, inv));\n }\n \n-CDataStream CConnman::BeginMessage(CNode* pnode, int nVersion, int flags, const std::string& sCommand)\n+void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n {\n-    return {SER_NETWORK, (nVersion ? nVersion : pnode->GetSendVersion()) | flags, CMessageHeader(Params().MessageStart(), sCommand.c_str(), 0) };\n-}\n-\n-void CConnman::EndMessage(CDataStream& strm)\n-{\n-    // Set the size\n-    assert(strm.size () >= CMessageHeader::HEADER_SIZE);\n-    unsigned int nSize = strm.size() - CMessageHeader::HEADER_SIZE;\n-    WriteLE32((uint8_t*)&strm[CMessageHeader::MESSAGE_SIZE_OFFSET], nSize);\n-    // Set the checksum\n-    uint256 hash = Hash(strm.begin() + CMessageHeader::HEADER_SIZE, strm.end());\n-    memcpy((char*)&strm[CMessageHeader::CHECKSUM_OFFSET], hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n-\n-}\n+    size_t nMessageSize = msg.data.size();\n+    size_t nTotalSize = nMessageSize + CMessageHeader::HEADER_SIZE;\n+    LogPrint(\"net\", \"sending %s (%d bytes) peer=%d\\n\",  SanitizeString(msg.command.c_str()), nMessageSize, pnode->id);\n \n-void CConnman::PushMessage(CNode* pnode, CDataStream& strm, const std::string& sCommand)\n-{\n-    if(strm.empty())\n-        return;\n+    std::vector<unsigned char> serializedHeader;\n+    serializedHeader.reserve(CMessageHeader::HEADER_SIZE);\n+    uint256 hash = Hash(msg.data.data(), msg.data.data() + nMessageSize);\n+    CMessageHeader hdr(Params().MessageStart(), msg.command.c_str(), nMessageSize);\n+    memcpy(hdr.pchChecksum, hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n \n-    unsigned int nSize = strm.size() - CMessageHeader::HEADER_SIZE;\n-    LogPrint(\"net\", \"sending %s (%d bytes) peer=%d\\n\",  SanitizeString(sCommand.c_str()), nSize, pnode->id);\n+    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, serializedHeader, 0, hdr};\n \n     size_t nBytesSent = 0;\n     {\n@@ -2644,11 +2633,14 @@ void CConnman::PushMessage(CNode* pnode, CDataStream& strm, const std::string& s\n             return;\n         }\n         bool optimisticSend(pnode->vSendMsg.empty());\n-        pnode->vSendMsg.emplace_back(strm.begin(), strm.end());\n \n         //log total amount of bytes per command\n-        pnode->mapSendBytesPerMsgCmd[sCommand] += strm.size();\n-        pnode->nSendSize += strm.size();\n+        pnode->mapSendBytesPerMsgCmd[msg.command] += nTotalSize;\n+        pnode->nSendSize += nTotalSize;\n+\n+        pnode->vSendMsg.push_back(std::move(serializedHeader));\n+        if (nMessageSize)\n+            pnode->vSendMsg.push_back(std::move(msg.data));\n \n         // If write queue empty, attempt \"optimistic write\"\n         if (optimisticSend == true)"
      },
      {
        "sha": "a4a9fb676af75937afc731ddfbc8ab50a49a9de0",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 3,
        "deletions": 32,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c7be56dceff625991cb2884f2ce053996ac613cd/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c7be56dceff625991cb2884f2ce053996ac613cd/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=c7be56dceff625991cb2884f2ce053996ac613cd",
        "patch": "@@ -152,32 +152,7 @@ class CConnman\n \n     bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func);\n \n-    template <typename... Args>\n-    void PushMessageWithVersionAndFlag(CNode* pnode, int nVersion, int flag, const std::string& sCommand, Args&&... args)\n-    {\n-        auto msg(BeginMessage(pnode, nVersion, flag, sCommand));\n-        ::SerializeMany(msg, std::forward<Args>(args)...);\n-        EndMessage(msg);\n-        PushMessage(pnode, msg, sCommand);\n-    }\n-\n-    template <typename... Args>\n-    void PushMessageWithFlag(CNode* pnode, int flag, const std::string& sCommand, Args&&... args)\n-    {\n-        PushMessageWithVersionAndFlag(pnode, 0, flag, sCommand, std::forward<Args>(args)...);\n-    }\n-\n-    template <typename... Args>\n-    void PushMessageWithVersion(CNode* pnode, int nVersion, const std::string& sCommand, Args&&... args)\n-    {\n-        PushMessageWithVersionAndFlag(pnode, nVersion, 0, sCommand, std::forward<Args>(args)...);\n-    }\n-\n-    template <typename... Args>\n-    void PushMessage(CNode* pnode, const std::string& sCommand, Args&&... args)\n-    {\n-        PushMessageWithVersionAndFlag(pnode, 0, 0, sCommand, std::forward<Args>(args)...);\n-    }\n+    void PushMessage(CNode* pnode, CSerializedNetMsg&& msg);\n \n     template<typename Callable>\n     bool ForEachNodeContinueIf(Callable&& func)\n@@ -388,10 +363,6 @@ class CConnman\n \n     unsigned int GetReceiveFloodSize() const;\n \n-    CDataStream BeginMessage(CNode* node, int nVersion, int flags, const std::string& sCommand);\n-    void PushMessage(CNode* pnode, CDataStream& strm, const std::string& sCommand);\n-    void EndMessage(CDataStream& strm);\n-\n     // Network stats\n     void RecordBytesRecv(uint64_t bytes);\n     void RecordBytesSent(uint64_t bytes);\n@@ -615,7 +586,7 @@ class CNode\n     size_t nSendSize; // total size of all vSendMsg entries\n     size_t nSendOffset; // offset inside the first vSendMsg already sent\n     uint64_t nSendBytes;\n-    std::deque<CSerializeData> vSendMsg;\n+    std::deque<std::vector<unsigned char>> vSendMsg;\n     CCriticalSection cs_vSend;\n \n     std::deque<CInv> vRecvGetData;\n@@ -785,7 +756,7 @@ class CNode\n     {\n         // The send version should always be explicitly set to\n         // INIT_PROTO_VERSION rather than using this value until the handshake\n-        // is complete. See PushMessageWithVersion().\n+        // is complete.\n         assert(nSendVersion != 0);\n         return nSendVersion;\n     }"
      }
    ]
  }
]