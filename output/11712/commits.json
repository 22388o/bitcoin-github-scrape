[
  {
    "sha": "ec59523c5915fb67db33149290dfc57049ba973d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplYzU5NTIzYzU5MTVmYjY3ZGIzMzE0OTI5MGRmYzU3MDQ5YmE5NzNk",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-10-17T12:02:15Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-22T23:08:37Z"
      },
      "message": "[tests] Remove rpc property from TestNode in p2p-segwit.py.\n\nChange the helper methods to functions which take a node and a p2p\nconnection as arguments.",
      "tree": {
        "sha": "45c476dd95191c51aa4af10e19ec458abe4dcab1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/45c476dd95191c51aa4af10e19ec458abe4dcab1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ec59523c5915fb67db33149290dfc57049ba973d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ec59523c5915fb67db33149290dfc57049ba973d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ec59523c5915fb67db33149290dfc57049ba973d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ec59523c5915fb67db33149290dfc57049ba973d/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3d6ad407770e13958e157bf026cae0bfb9254899",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3d6ad407770e13958e157bf026cae0bfb9254899",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3d6ad407770e13958e157bf026cae0bfb9254899"
      }
    ],
    "stats": {
      "total": 276,
      "additions": 141,
      "deletions": 135
    },
    "files": [
      {
        "sha": "586f2d1b79937fc8bb810d355ac91cd6e0f459b9",
        "filename": "test/functional/p2p-segwit.py",
        "status": "modified",
        "additions": 141,
        "deletions": 135,
        "changes": 276,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ec59523c5915fb67db33149290dfc57049ba973d/test/functional/p2p-segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ec59523c5915fb67db33149290dfc57049ba973d/test/functional/p2p-segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-segwit.py?ref=ec59523c5915fb67db33149290dfc57049ba973d",
        "patch": "@@ -31,11 +31,38 @@ def get_virtual_size(witness_block):\n     vsize = int((3*base_size + total_size + 3)/4)\n     return vsize\n \n+def test_transaction_acceptance(rpc, p2p, tx, with_witness, accepted, reason=None):\n+    \"\"\"Send a transaction to the node and check that it's accepted to the mempool\n+\n+    - Submit the transaction over the p2p interface\n+    - use the getrawmempool rpc to check for acceptance.\"\"\"\n+    tx_message = msg_tx(tx)\n+    if with_witness:\n+        tx_message = msg_witness_tx(tx)\n+    p2p.send_message(tx_message)\n+    p2p.sync_with_ping()\n+    assert_equal(tx.hash in rpc.getrawmempool(), accepted)\n+    if (reason != None and not accepted):\n+        # Check the rejection reason as well.\n+        with mininode_lock:\n+            assert_equal(p2p.last_message[\"reject\"].reason, reason)\n+\n+def test_witness_block(rpc, p2p, block, accepted, with_witness=True):\n+    \"\"\"Send a block to the node and check that it's accepted\n+\n+    - Submit the block over the p2p interface\n+    - use the getbestblockhash rpc to check for acceptance.\"\"\"\n+    if with_witness:\n+        p2p.send_message(msg_witness_block(block))\n+    else:\n+        p2p.send_message(msg_block(block))\n+    p2p.sync_with_ping()\n+    assert_equal(rpc.getbestblockhash() == block.hash, accepted)\n+\n class TestNode(NodeConnCB):\n-    def __init__(self, rpc):\n+    def __init__(self):\n         super().__init__()\n         self.getdataset = set()\n-        self.rpc = rpc\n \n     def on_getdata(self, conn, message):\n         for inv in message.inv:\n@@ -68,27 +95,6 @@ def request_block(self, blockhash, inv_type, timeout=60):\n         self.wait_for_block(blockhash, timeout)\n         return self.last_message[\"block\"].block\n \n-    def test_transaction_acceptance(self, tx, with_witness, accepted, reason=None):\n-        tx_message = msg_tx(tx)\n-        if with_witness:\n-            tx_message = msg_witness_tx(tx)\n-        self.send_message(tx_message)\n-        self.sync_with_ping()\n-        assert_equal(tx.hash in self.rpc.getrawmempool(), accepted)\n-        if (reason != None and not accepted):\n-            # Check the rejection reason as well.\n-            with mininode_lock:\n-                assert_equal(self.last_message[\"reject\"].reason, reason)\n-\n-    # Test whether a witness block had the correct effect on the tip\n-    def test_witness_block(self, block, accepted, with_witness=True):\n-        if with_witness:\n-            self.send_message(msg_witness_block(block))\n-        else:\n-            self.send_message(msg_block(block))\n-        self.sync_with_ping()\n-        assert_equal(self.rpc.getbestblockhash() == block.hash, accepted)\n-\n # Used to keep track of anyone-can-spend outputs that we can use in the tests\n class UTXO():\n     def __init__(self, sha256, n, nValue):\n@@ -201,7 +207,7 @@ def test_unnecessary_witness_before_segwit_activation(self):\n         self.update_witness_block_with_transactions(block, [tx])\n         # Sending witness data before activation is not allowed (anti-spam\n         # rule).\n-        self.test_node.test_witness_block(block, accepted=False)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n         # TODO: fix synchronization so we can test reject reason\n         # Right now, bitcoind delays sending reject messages for blocks\n         # until the future, making synchronization here difficult.\n@@ -228,7 +234,7 @@ def test_unnecessary_witness_before_segwit_activation(self):\n         tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n         tx2.vout.append(CTxOut(tx.vout[0].nValue-1000, scriptPubKey))\n         tx2.rehash()\n-        self.test_node.test_transaction_acceptance(tx2, False, True)\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx2, False, True)\n         self.nodes[0].generate(1)\n         sync_blocks(self.nodes)\n \n@@ -245,18 +251,18 @@ def test_unnecessary_witness_before_segwit_activation(self):\n         tx3.rehash()\n         # Note that this should be rejected for the premature witness reason,\n         # rather than a policy check, since segwit hasn't activated yet.\n-        self.std_node.test_transaction_acceptance(tx3, True, False, b'no-witness-yet')\n+        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, tx3, True, False, b'no-witness-yet')\n \n         # If we send without witness, it should be accepted.\n-        self.std_node.test_transaction_acceptance(tx3, False, True)\n+        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, tx3, False, True)\n \n         # Now create a new anyone-can-spend utxo for the next test.\n         tx4 = CTransaction()\n         tx4.vin.append(CTxIn(COutPoint(tx3.sha256, 0), CScript([p2sh_program])))\n         tx4.vout.append(CTxOut(tx3.vout[0].nValue-1000, CScript([OP_TRUE])))\n         tx4.rehash()\n-        self.test_node.test_transaction_acceptance(tx3, False, True)\n-        self.test_node.test_transaction_acceptance(tx4, False, True)\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx3, False, True)\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx4, False, True)\n \n         self.nodes[0].generate(1)\n         sync_blocks(self.nodes)\n@@ -317,7 +323,7 @@ def test_witness_commitments(self):\n         assert(msg_witness_block(block).serialize() != msg_block(block).serialize())\n \n         # This empty block should be valid.\n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n \n         # Try to tweak the nonce\n         block_2 = self.build_next_block()\n@@ -328,7 +334,7 @@ def test_witness_commitments(self):\n         assert(block_2.vtx[0].vout[-1] != block.vtx[0].vout[-1])\n \n         # This should also be valid.\n-        self.test_node.test_witness_block(block_2, accepted=True)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block_2, accepted=True)\n \n         # Now test commitments with actual transactions\n         assert (len(self.utxo) > 0)\n@@ -361,7 +367,7 @@ def test_witness_commitments(self):\n         block_3.rehash()\n         block_3.solve()\n \n-        self.test_node.test_witness_block(block_3, accepted=False)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block_3, accepted=False)\n \n         # Add a different commitment with different nonce, but in the\n         # right location, and with some funds burned(!).\n@@ -375,7 +381,7 @@ def test_witness_commitments(self):\n         block_3.rehash()\n         assert(len(block_3.vtx[0].vout) == 4) # 3 OP_returns\n         block_3.solve()\n-        self.test_node.test_witness_block(block_3, accepted=True)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block_3, accepted=True)\n \n         # Finally test that a block with no witness transactions can\n         # omit the commitment.\n@@ -387,7 +393,7 @@ def test_witness_commitments(self):\n         block_4.vtx.append(tx3)\n         block_4.hashMerkleRoot = block_4.calc_merkle_root()\n         block_4.solve()\n-        self.test_node.test_witness_block(block_4, with_witness=False, accepted=True)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block_4, with_witness=False, accepted=True)\n \n         # Update available utxo's for use in later test.\n         self.utxo.pop(0)\n@@ -428,11 +434,11 @@ def test_block_malleability(self):\n         # Change the nonce -- should not cause the block to be permanently\n         # failed\n         block.vtx[0].wit.vtxinwit[0].scriptWitness.stack = [ ser_uint256(1) ]\n-        self.test_node.test_witness_block(block, accepted=False)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n \n         # Changing the witness nonce doesn't change the block hash\n         block.vtx[0].wit.vtxinwit[0].scriptWitness.stack = [ ser_uint256(0) ]\n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n \n \n     def test_witness_block_size(self):\n@@ -497,7 +503,7 @@ def test_witness_block_size(self):\n         # limit\n         assert(len(block.serialize(True)) > 2*1024*1024)\n \n-        self.test_node.test_witness_block(block, accepted=False)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n \n         # Now resize the second transaction to make the block fit.\n         cur_length = len(block.vtx[-1].wit.vtxinwit[0].scriptWitness.stack[0])\n@@ -507,7 +513,7 @@ def test_witness_block_size(self):\n         block.solve()\n         assert(get_virtual_size(block) == MAX_BLOCK_BASE_SIZE)\n \n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n \n         # Update available utxo's\n         self.utxo.pop(0)\n@@ -574,7 +580,7 @@ def test_extra_witness_data(self):\n         self.update_witness_block_with_transactions(block, [tx])\n \n         # Extra witness data should not be allowed.\n-        self.test_node.test_witness_block(block, accepted=False)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n \n         # Try extra signature data.  Ok if we're not spending a witness output.\n         block.vtx[1].wit.vtxinwit = []\n@@ -583,7 +589,7 @@ def test_extra_witness_data(self):\n         add_witness_commitment(block)\n         block.solve()\n \n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n \n         # Now try extra witness/signature data on an input that DOES require a\n         # witness\n@@ -599,7 +605,7 @@ def test_extra_witness_data(self):\n         self.update_witness_block_with_transactions(block, [tx2])\n \n         # This has extra witness data, so it should fail.\n-        self.test_node.test_witness_block(block, accepted=False)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n \n         # Now get rid of the extra witness, but add extra scriptSig data\n         tx2.vin[0].scriptSig = CScript([OP_TRUE])\n@@ -611,7 +617,7 @@ def test_extra_witness_data(self):\n         block.solve()\n \n         # This has extra signature data for a witness input, so it should fail.\n-        self.test_node.test_witness_block(block, accepted=False)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n \n         # Now get rid of the extra scriptsig on the witness input, and verify\n         # success (even with extra scriptsig data in the non-witness input)\n@@ -620,7 +626,7 @@ def test_extra_witness_data(self):\n         add_witness_commitment(block)\n         block.solve()\n \n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n \n         # Update utxo for later tests\n         self.utxo.pop(0)\n@@ -653,14 +659,14 @@ def test_max_witness_push_length(self):\n         tx2.rehash()\n \n         self.update_witness_block_with_transactions(block, [tx, tx2])\n-        self.test_node.test_witness_block(block, accepted=False)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n \n         # Now reduce the length of the stack element\n         tx2.wit.vtxinwit[0].scriptWitness.stack[0] = b'a'*(MAX_SCRIPT_ELEMENT_SIZE)\n \n         add_witness_commitment(block)\n         block.solve()\n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n \n         # Update the utxo for later tests\n         self.utxo.pop()\n@@ -695,7 +701,7 @@ def test_max_witness_program_length(self):\n \n         self.update_witness_block_with_transactions(block, [tx, tx2])\n \n-        self.test_node.test_witness_block(block, accepted=False)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n \n         # Try again with one less byte in the witness program\n         witness_program = CScript([b'a'*520]*19 + [OP_DROP]*62 + [OP_TRUE])\n@@ -710,7 +716,7 @@ def test_max_witness_program_length(self):\n         tx2.rehash()\n         block.vtx = [block.vtx[0]]\n         self.update_witness_block_with_transactions(block, [tx, tx2])\n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n \n         self.utxo.pop()\n         self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n@@ -736,7 +742,7 @@ def test_witness_input_length(self):\n \n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx])\n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n \n         # Try various ways to spend tx that should all break.\n         # This \"broken\" transaction serializer will not normalize\n@@ -771,15 +777,15 @@ def serialize_with_witness(self):\n \n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx2])\n-        self.test_node.test_witness_block(block, accepted=False)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n \n         # Now try using a too short vtxinwit\n         tx2.wit.vtxinwit.pop()\n         tx2.wit.vtxinwit.pop()\n \n         block.vtx = [block.vtx[0]]\n         self.update_witness_block_with_transactions(block, [tx2])\n-        self.test_node.test_witness_block(block, accepted=False)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n \n         # Now make one of the intermediate witnesses be incorrect\n         tx2.wit.vtxinwit.append(CTxInWitness())\n@@ -788,13 +794,13 @@ def serialize_with_witness(self):\n \n         block.vtx = [block.vtx[0]]\n         self.update_witness_block_with_transactions(block, [tx2])\n-        self.test_node.test_witness_block(block, accepted=False)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n \n         # Fix the broken witness and the block should be accepted.\n         tx2.wit.vtxinwit[5].scriptWitness.stack = [b'a', witness_program]\n         block.vtx = [block.vtx[0]]\n         self.update_witness_block_with_transactions(block, [tx2])\n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n \n         self.utxo.pop()\n         self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n@@ -834,11 +840,11 @@ def test_witness_tx_relay_before_segwit_activation(self):\n         # its from)\n         assert_equal(len(self.nodes[0].getrawmempool()), 0)\n         assert_equal(len(self.nodes[1].getrawmempool()), 0)\n-        self.old_node.test_transaction_acceptance(tx, with_witness=True, accepted=False)\n-        self.test_node.test_transaction_acceptance(tx, with_witness=True, accepted=False)\n+        test_transaction_acceptance(self.nodes[0].rpc, self.old_node, tx, with_witness=True, accepted=False)\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx, with_witness=True, accepted=False)\n \n         # But eliminating the witness should fix it\n-        self.test_node.test_transaction_acceptance(tx, with_witness=False, accepted=True)\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx, with_witness=False, accepted=True)\n \n         # Cleanup: mine the first transaction and update utxo\n         self.nodes[0].generate(1)\n@@ -870,11 +876,11 @@ def test_tx_relay_after_segwit_activation(self):\n         # Verify that unnecessary witnesses are rejected.\n         self.test_node.announce_tx_and_wait_for_getdata(tx)\n         assert_equal(len(self.nodes[0].getrawmempool()), 0)\n-        self.test_node.test_transaction_acceptance(tx, with_witness=True, accepted=False)\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx, with_witness=True, accepted=False)\n \n         # Verify that removing the witness succeeds.\n         self.test_node.announce_tx_and_wait_for_getdata(tx)\n-        self.test_node.test_transaction_acceptance(tx, with_witness=False, accepted=True)\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx, with_witness=False, accepted=True)\n \n         # Now try to add extra witness data to a valid witness tx.\n         witness_program = CScript([OP_TRUE])\n@@ -899,24 +905,24 @@ def test_tx_relay_after_segwit_activation(self):\n \n         # Node will not be blinded to the transaction\n         self.std_node.announce_tx_and_wait_for_getdata(tx3)\n-        self.std_node.test_transaction_acceptance(tx3, True, False, b'tx-size')\n+        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, tx3, True, False, b'tx-size')\n         self.std_node.announce_tx_and_wait_for_getdata(tx3)\n-        self.std_node.test_transaction_acceptance(tx3, True, False, b'tx-size')\n+        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, tx3, True, False, b'tx-size')\n \n         # Remove witness stuffing, instead add extra witness push on stack\n         tx3.vout[0] = CTxOut(tx2.vout[0].nValue-1000, CScript([OP_TRUE]))\n         tx3.wit.vtxinwit[0].scriptWitness.stack = [CScript([CScriptNum(1)]), witness_program ]\n         tx3.rehash()\n \n-        self.test_node.test_transaction_acceptance(tx2, with_witness=True, accepted=True)\n-        self.test_node.test_transaction_acceptance(tx3, with_witness=True, accepted=False)\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx2, with_witness=True, accepted=True)\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx3, with_witness=True, accepted=False)\n \n         # Get rid of the extra witness, and verify acceptance.\n         tx3.wit.vtxinwit[0].scriptWitness.stack = [ witness_program ]\n         # Also check that old_node gets a tx announcement, even though this is\n         # a witness transaction.\n         self.old_node.wait_for_inv([CInv(1, tx2.sha256)]) # wait until tx2 was inv'ed\n-        self.test_node.test_transaction_acceptance(tx3, with_witness=True, accepted=True)\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx3, with_witness=True, accepted=True)\n         self.old_node.wait_for_inv([CInv(1, tx3.sha256)])\n \n         # Test that getrawtransaction returns correct witness information\n@@ -955,20 +961,20 @@ def test_block_relay(self, segwit_activated):\n \n         self.test_node.announce_block_and_wait_for_getdata(block1, use_header=False)\n         assert(self.test_node.last_message[\"getdata\"].inv[0].type == blocktype)\n-        self.test_node.test_witness_block(block1, True)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block1, True)\n \n         block2 = self.build_next_block(nVersion=4)\n         block2.solve()\n \n         self.test_node.announce_block_and_wait_for_getdata(block2, use_header=True)\n         assert(self.test_node.last_message[\"getdata\"].inv[0].type == blocktype)\n-        self.test_node.test_witness_block(block2, True)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block2, True)\n \n         block3 = self.build_next_block(nVersion=(VB_TOP_BITS | (1<<15)))\n         block3.solve()\n         self.test_node.announce_block_and_wait_for_getdata(block3, use_header=True)\n         assert(self.test_node.last_message[\"getdata\"].inv[0].type == blocktype)\n-        self.test_node.test_witness_block(block3, True)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block3, True)\n \n         # Check that we can getdata for witness blocks or regular blocks,\n         # and the right thing happens.\n@@ -998,7 +1004,7 @@ def test_block_relay(self, segwit_activated):\n             # This gives us a witness commitment.\n             assert(len(block.vtx[0].wit.vtxinwit) == 1)\n             assert(len(block.vtx[0].wit.vtxinwit[0].scriptWitness.stack) == 1)\n-            self.test_node.test_witness_block(block, accepted=True)\n+            test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n             # Now try to retrieve it...\n             rpc_block = self.nodes[0].getblock(block.hash, False)\n             non_wit_block = self.test_node.request_block(block.sha256, 2)\n@@ -1052,7 +1058,7 @@ def test_standardness_v0(self, segwit_activated):\n         p2sh_tx.rehash()\n \n         # Mine it on test_node to create the confirmed output.\n-        self.test_node.test_transaction_acceptance(p2sh_tx, with_witness=True, accepted=True)\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, p2sh_tx, with_witness=True, accepted=True)\n         self.nodes[0].generate(1)\n         sync_blocks(self.nodes)\n \n@@ -1064,7 +1070,7 @@ def test_standardness_v0(self, segwit_activated):\n         tx.vout.append(CTxOut(8000, scriptPubKey)) # Might burn this later\n         tx.rehash()\n \n-        self.std_node.test_transaction_acceptance(tx, with_witness=True, accepted=segwit_activated)\n+        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, tx, with_witness=True, accepted=segwit_activated)\n \n         # Now create something that looks like a P2PKH output. This won't be spendable.\n         scriptPubKey = CScript([OP_0, hash160(witness_hash)])\n@@ -1081,7 +1087,7 @@ def test_standardness_v0(self, segwit_activated):\n             tx2.vout = [CTxOut(p2sh_tx.vout[0].nValue-1000, scriptPubKey)]\n         tx2.rehash()\n \n-        self.std_node.test_transaction_acceptance(tx2, with_witness=True, accepted=segwit_activated)\n+        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, tx2, with_witness=True, accepted=segwit_activated)\n \n         # Now update self.utxo for later tests.\n         tx3 = CTransaction()\n@@ -1094,13 +1100,13 @@ def test_standardness_v0(self, segwit_activated):\n             tx3.wit.vtxinwit.append(CTxInWitness())\n             tx3.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n             tx3.rehash()\n-            self.test_node.test_transaction_acceptance(tx3, with_witness=True, accepted=True)\n+            test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx3, with_witness=True, accepted=True)\n         else:\n             # tx and tx2 didn't go anywhere; just clean up the p2sh_tx output.\n             tx3.vin = [CTxIn(COutPoint(p2sh_tx.sha256, 0), CScript([witness_program]))]\n             tx3.vout = [CTxOut(p2sh_tx.vout[0].nValue-1000, witness_program)]\n             tx3.rehash()\n-            self.test_node.test_transaction_acceptance(tx3, with_witness=True, accepted=True)\n+            test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx3, with_witness=True, accepted=True)\n \n         self.nodes[0].generate(1)\n         sync_blocks(self.nodes)\n@@ -1124,7 +1130,7 @@ def test_segwit_versions(self):\n             tx.rehash()\n             block = self.build_next_block()\n             self.update_witness_block_with_transactions(block, [tx])\n-            self.test_node.test_witness_block(block, accepted=True)\n+            test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n             self.utxo.pop(0)\n             for i in range(NUM_TESTS):\n                 self.utxo.append(UTXO(tx.sha256, i, split_value))\n@@ -1143,8 +1149,8 @@ def test_segwit_versions(self):\n             tx.vin = [CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\")]\n             tx.vout = [CTxOut(self.utxo[0].nValue-1000, scriptPubKey)]\n             tx.rehash()\n-            self.std_node.test_transaction_acceptance(tx, with_witness=True, accepted=False)\n-            self.test_node.test_transaction_acceptance(tx, with_witness=True, accepted=True)\n+            test_transaction_acceptance(self.nodes[1].rpc, self.std_node, tx, with_witness=True, accepted=False)\n+            test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx, with_witness=True, accepted=True)\n             self.utxo.pop(0)\n             temp_utxo.append(UTXO(tx.sha256, 0, tx.vout[0].nValue))\n \n@@ -1163,8 +1169,8 @@ def test_segwit_versions(self):\n         tx2.rehash()\n         # Gets accepted to test_node, because standardness of outputs isn't\n         # checked with fRequireStandard\n-        self.test_node.test_transaction_acceptance(tx2, with_witness=True, accepted=True)\n-        self.std_node.test_transaction_acceptance(tx2, with_witness=True, accepted=False)\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx2, with_witness=True, accepted=True)\n+        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, tx2, with_witness=True, accepted=False)\n         temp_utxo.pop() # last entry in temp_utxo was the output we just spent\n         temp_utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n \n@@ -1180,15 +1186,15 @@ def test_segwit_versions(self):\n         tx3.rehash()\n         # Spending a higher version witness output is not allowed by policy,\n         # even with fRequireStandard=false.\n-        self.test_node.test_transaction_acceptance(tx3, with_witness=True, accepted=False)\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx3, with_witness=True, accepted=False)\n         self.test_node.sync_with_ping()\n         with mininode_lock:\n             assert(b\"reserved for soft-fork upgrades\" in self.test_node.last_message[\"reject\"].reason)\n \n         # Building a block with the transaction must be valid, however.\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx2, tx3])\n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n         sync_blocks(self.nodes)\n \n         # Add utxo to our list\n@@ -1206,7 +1212,7 @@ def test_premature_coinbase_witness_spend(self):\n         # This next line will rehash the coinbase and update the merkle\n         # root, and solve.\n         self.update_witness_block_with_transactions(block, [])\n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n \n         spend_tx = CTransaction()\n         spend_tx.vin = [CTxIn(COutPoint(block.vtx[0].sha256, 0), b\"\")]\n@@ -1220,13 +1226,13 @@ def test_premature_coinbase_witness_spend(self):\n         sync_blocks(self.nodes)\n         block2 = self.build_next_block()\n         self.update_witness_block_with_transactions(block2, [spend_tx])\n-        self.test_node.test_witness_block(block2, accepted=False)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block2, accepted=False)\n \n         # Advancing one more block should allow the spend.\n         self.nodes[0].generate(1)\n         block2 = self.build_next_block()\n         self.update_witness_block_with_transactions(block2, [spend_tx])\n-        self.test_node.test_witness_block(block2, accepted=True)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block2, accepted=True)\n         sync_blocks(self.nodes)\n \n \n@@ -1247,11 +1253,11 @@ def test_signature_version_1(self):\n         tx.vout.append(CTxOut(self.utxo[0].nValue-1000, scriptPubKey))\n         tx.rehash()\n \n-        self.test_node.test_transaction_acceptance(tx, with_witness=True, accepted=True)\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx, with_witness=True, accepted=True)\n         # Mine this transaction in preparation for following tests.\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx])\n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n         sync_blocks(self.nodes)\n         self.utxo.pop(0)\n \n@@ -1268,19 +1274,19 @@ def test_signature_version_1(self):\n                 # Too-large input value\n                 sign_P2PK_witness_input(witness_program, tx, 0, hashtype, prev_utxo.nValue+1, key)\n                 self.update_witness_block_with_transactions(block, [tx])\n-                self.test_node.test_witness_block(block, accepted=False)\n+                test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n \n                 # Too-small input value\n                 sign_P2PK_witness_input(witness_program, tx, 0, hashtype, prev_utxo.nValue-1, key)\n                 block.vtx.pop() # remove last tx\n                 self.update_witness_block_with_transactions(block, [tx])\n-                self.test_node.test_witness_block(block, accepted=False)\n+                test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n \n                 # Now try correct value\n                 sign_P2PK_witness_input(witness_program, tx, 0, hashtype, prev_utxo.nValue, key)\n                 block.vtx.pop()\n                 self.update_witness_block_with_transactions(block, [tx])\n-                self.test_node.test_witness_block(block, accepted=True)\n+                test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n \n                 prev_utxo = UTXO(tx.sha256, 0, tx.vout[0].nValue)\n \n@@ -1304,7 +1310,7 @@ def test_signature_version_1(self):\n \n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx])\n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n \n         block = self.build_next_block()\n         used_sighash_single_out_of_bounds = False\n@@ -1346,15 +1352,15 @@ def test_signature_version_1(self):\n             # Test the block periodically, if we're close to maxblocksize\n             if (get_virtual_size(block) > MAX_BLOCK_BASE_SIZE - 1000):\n                 self.update_witness_block_with_transactions(block, [])\n-                self.test_node.test_witness_block(block, accepted=True)\n+                test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n                 block = self.build_next_block()\n \n         if (not used_sighash_single_out_of_bounds):\n             self.log.info(\"WARNING: this test run didn't attempt SIGHASH_SINGLE with out-of-bounds index value\")\n         # Test the transactions we've added to the block\n         if (len(block.vtx) > 1):\n             self.update_witness_block_with_transactions(block, [])\n-            self.test_node.test_witness_block(block, accepted=True)\n+            test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n \n         # Now test witness version 0 P2PKH transactions\n         pubkeyhash = hash160(pubkey)\n@@ -1376,7 +1382,7 @@ def test_signature_version_1(self):\n         tx2.vin[0].scriptSig = CScript([signature, pubkey])\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx, tx2])\n-        self.test_node.test_witness_block(block, accepted=False)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=False)\n \n         # Move the signature to the witness.\n         block.vtx.pop()\n@@ -1386,7 +1392,7 @@ def test_signature_version_1(self):\n         tx2.rehash()\n \n         self.update_witness_block_with_transactions(block, [tx2])\n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n \n         temp_utxos.pop(0)\n \n@@ -1405,7 +1411,7 @@ def test_signature_version_1(self):\n             index += 1\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx])\n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n \n         for i in range(len(tx.vout)):\n             self.utxo.append(UTXO(tx.sha256, i, tx.vout[i].nValue))\n@@ -1432,10 +1438,10 @@ def test_p2sh_witness(self, segwit_activated):\n         tx.rehash()\n \n         # Verify mempool acceptance and block validity\n-        self.test_node.test_transaction_acceptance(tx, with_witness=False, accepted=True)\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx, with_witness=False, accepted=True)\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx])\n-        self.test_node.test_witness_block(block, accepted=True, with_witness=segwit_activated)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True, with_witness=segwit_activated)\n         sync_blocks(self.nodes)\n \n         # Now test attempts to spend the output.\n@@ -1449,12 +1455,12 @@ def test_p2sh_witness(self, segwit_activated):\n         # will require a witness to spend a witness program regardless of\n         # segwit activation.  Note that older bitcoind's that are not\n         # segwit-aware would also reject this for failing CLEANSTACK.\n-        self.test_node.test_transaction_acceptance(spend_tx, with_witness=False, accepted=False)\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, spend_tx, with_witness=False, accepted=False)\n \n         # Try to put the witness script in the scriptSig, should also fail.\n         spend_tx.vin[0].scriptSig = CScript([p2wsh_pubkey, b'a'])\n         spend_tx.rehash()\n-        self.test_node.test_transaction_acceptance(spend_tx, with_witness=False, accepted=False)\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, spend_tx, with_witness=False, accepted=False)\n \n         # Now put the witness script in the witness, should succeed after\n         # segwit activates.\n@@ -1464,17 +1470,17 @@ def test_p2sh_witness(self, segwit_activated):\n         spend_tx.wit.vtxinwit[0].scriptWitness.stack = [ b'a', witness_program ]\n \n         # Verify mempool acceptance\n-        self.test_node.test_transaction_acceptance(spend_tx, with_witness=True, accepted=segwit_activated)\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, spend_tx, with_witness=True, accepted=segwit_activated)\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [spend_tx])\n \n         # If we're before activation, then sending this without witnesses\n         # should be valid.  If we're after activation, then sending this with\n         # witnesses should be valid.\n         if segwit_activated:\n-            self.test_node.test_witness_block(block, accepted=True)\n+            test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n         else:\n-            self.test_node.test_witness_block(block, accepted=True, with_witness=False)\n+            test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True, with_witness=False)\n \n         # Update self.utxo\n         self.utxo.pop(0)\n@@ -1558,7 +1564,7 @@ def test_witness_sigops(self):\n \n         block_1 = self.build_next_block()\n         self.update_witness_block_with_transactions(block_1, [tx])\n-        self.test_node.test_witness_block(block_1, accepted=True)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block_1, accepted=True)\n \n         tx2 = CTransaction()\n         # If we try to spend the first n-1 outputs from tx, that should be\n@@ -1575,7 +1581,7 @@ def test_witness_sigops(self):\n \n         block_2 = self.build_next_block()\n         self.update_witness_block_with_transactions(block_2, [tx2])\n-        self.test_node.test_witness_block(block_2, accepted=False)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block_2, accepted=False)\n \n         # Try dropping the last input in tx2, and add an output that has\n         # too many sigops (contributing to legacy sigop count).\n@@ -1588,14 +1594,14 @@ def test_witness_sigops(self):\n         tx2.rehash()\n         block_3 = self.build_next_block()\n         self.update_witness_block_with_transactions(block_3, [tx2])\n-        self.test_node.test_witness_block(block_3, accepted=False)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block_3, accepted=False)\n \n         # If we drop the last checksig in this output, the tx should succeed.\n         block_4 = self.build_next_block()\n         tx2.vout[-1].scriptPubKey = CScript([OP_CHECKSIG]*(checksig_count-1))\n         tx2.rehash()\n         self.update_witness_block_with_transactions(block_4, [tx2])\n-        self.test_node.test_witness_block(block_4, accepted=True)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block_4, accepted=True)\n \n         # Reset the tip back down for the next test\n         sync_blocks(self.nodes)\n@@ -1611,7 +1617,7 @@ def test_witness_sigops(self):\n         tx2.wit.vtxinwit[-1].scriptWitness.stack = [ witness_program_justright ]\n         tx2.rehash()\n         self.update_witness_block_with_transactions(block_5, [tx2])\n-        self.test_node.test_witness_block(block_5, accepted=True)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block_5, accepted=True)\n \n         # TODO: test p2sh sigop counting\n \n@@ -1689,7 +1695,7 @@ def test_uncompressed_pubkey(self):\n         # Confirm it in a block.\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx])\n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n \n         # Now try to spend it. Send it to a P2WSH output, which we'll\n         # use in the next test.\n@@ -1708,11 +1714,11 @@ def test_uncompressed_pubkey(self):\n         tx2.rehash()\n \n         # Should fail policy test.\n-        self.test_node.test_transaction_acceptance(tx2, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx2, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n         # But passes consensus.\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx2])\n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n \n         # Test 2: P2WSH\n         # Try to spend the P2WSH output created in last test.\n@@ -1728,11 +1734,11 @@ def test_uncompressed_pubkey(self):\n         sign_P2PK_witness_input(witness_program, tx3, 0, SIGHASH_ALL, tx2.vout[0].nValue, key)\n \n         # Should fail policy test.\n-        self.test_node.test_transaction_acceptance(tx3, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx3, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n         # But passes consensus.\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx3])\n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n \n         # Test 3: P2SH(P2WSH)\n         # Try to spend the P2SH output created in the last test.\n@@ -1745,10 +1751,10 @@ def test_uncompressed_pubkey(self):\n         sign_P2PK_witness_input(witness_program, tx4, 0, SIGHASH_ALL, tx3.vout[0].nValue, key)\n \n         # Should fail policy test.\n-        self.test_node.test_transaction_acceptance(tx4, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx4, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx4])\n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n \n         # Test 4: Uncompressed pubkeys should still be valid in non-segwit\n         # transactions.\n@@ -1760,10 +1766,10 @@ def test_uncompressed_pubkey(self):\n         tx5.vin[0].scriptSig = CScript([signature, pubkey])\n         tx5.rehash()\n         # Should pass policy and consensus.\n-        self.test_node.test_transaction_acceptance(tx5, True, True)\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx5, True, True)\n         block = self.build_next_block()\n         self.update_witness_block_with_transactions(block, [tx5])\n-        self.test_node.test_witness_block(block, accepted=True)\n+        test_witness_block(self.nodes[0].rpc, self.test_node, block, accepted=True)\n         self.utxo.append(UTXO(tx5.sha256, 0, tx5.vout[0].nValue))\n \n     def test_non_standard_witness(self):\n@@ -1793,7 +1799,7 @@ def test_non_standard_witness(self):\n             tx.vout.append(CTxOut(outputvalue, CScript([OP_HASH160, p2sh, OP_EQUAL])))\n         tx.rehash()\n         txid = tx.sha256\n-        self.test_node.test_transaction_acceptance(tx, with_witness=False, accepted=True)\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, tx, with_witness=False, accepted=True)\n \n         self.nodes[0].generate(1)\n         sync_blocks(self.nodes)\n@@ -1818,45 +1824,45 @@ def test_non_standard_witness(self):\n         # Testing native P2WSH\n         # Witness stack size, excluding witnessScript, over 100 is non-standard\n         p2wsh_txs[0].wit.vtxinwit[0].scriptWitness.stack = [pad] * 101 + [scripts[0]]\n-        self.std_node.test_transaction_acceptance(p2wsh_txs[0], True, False, b'bad-witness-nonstandard')\n+        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, p2wsh_txs[0], True, False, b'bad-witness-nonstandard')\n         # Non-standard nodes should accept\n-        self.test_node.test_transaction_acceptance(p2wsh_txs[0], True, True)\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, p2wsh_txs[0], True, True)\n \n         # Stack element size over 80 bytes is non-standard\n         p2wsh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 81] * 100 + [scripts[1]]\n-        self.std_node.test_transaction_acceptance(p2wsh_txs[1], True, False, b'bad-witness-nonstandard')\n+        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, p2wsh_txs[1], True, False, b'bad-witness-nonstandard')\n         # Non-standard nodes should accept\n-        self.test_node.test_transaction_acceptance(p2wsh_txs[1], True, True)\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, p2wsh_txs[1], True, True)\n         # Standard nodes should accept if element size is not over 80 bytes\n         p2wsh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 80] * 100 + [scripts[1]]\n-        self.std_node.test_transaction_acceptance(p2wsh_txs[1], True, True)\n+        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, p2wsh_txs[1], True, True)\n \n         # witnessScript size at 3600 bytes is standard\n         p2wsh_txs[2].wit.vtxinwit[0].scriptWitness.stack = [pad, pad, scripts[2]]\n-        self.test_node.test_transaction_acceptance(p2wsh_txs[2], True, True)\n-        self.std_node.test_transaction_acceptance(p2wsh_txs[2], True, True)\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, p2wsh_txs[2], True, True)\n+        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, p2wsh_txs[2], True, True)\n \n         # witnessScript size at 3601 bytes is non-standard\n         p2wsh_txs[3].wit.vtxinwit[0].scriptWitness.stack = [pad, pad, pad, scripts[3]]\n-        self.std_node.test_transaction_acceptance(p2wsh_txs[3], True, False, b'bad-witness-nonstandard')\n+        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, p2wsh_txs[3], True, False, b'bad-witness-nonstandard')\n         # Non-standard nodes should accept\n-        self.test_node.test_transaction_acceptance(p2wsh_txs[3], True, True)\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, p2wsh_txs[3], True, True)\n \n         # Repeating the same tests with P2SH-P2WSH\n         p2sh_txs[0].wit.vtxinwit[0].scriptWitness.stack = [pad] * 101 + [scripts[0]]\n-        self.std_node.test_transaction_acceptance(p2sh_txs[0], True, False, b'bad-witness-nonstandard')\n-        self.test_node.test_transaction_acceptance(p2sh_txs[0], True, True)\n+        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, p2sh_txs[0], True, False, b'bad-witness-nonstandard')\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, p2sh_txs[0], True, True)\n         p2sh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 81] * 100 + [scripts[1]]\n-        self.std_node.test_transaction_acceptance(p2sh_txs[1], True, False, b'bad-witness-nonstandard')\n-        self.test_node.test_transaction_acceptance(p2sh_txs[1], True, True)\n+        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, p2sh_txs[1], True, False, b'bad-witness-nonstandard')\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, p2sh_txs[1], True, True)\n         p2sh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 80] * 100 + [scripts[1]]\n-        self.std_node.test_transaction_acceptance(p2sh_txs[1], True, True)\n+        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, p2sh_txs[1], True, True)\n         p2sh_txs[2].wit.vtxinwit[0].scriptWitness.stack = [pad, pad, scripts[2]]\n-        self.test_node.test_transaction_acceptance(p2sh_txs[2], True, True)\n-        self.std_node.test_transaction_acceptance(p2sh_txs[2], True, True)\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, p2sh_txs[2], True, True)\n+        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, p2sh_txs[2], True, True)\n         p2sh_txs[3].wit.vtxinwit[0].scriptWitness.stack = [pad, pad, pad, scripts[3]]\n-        self.std_node.test_transaction_acceptance(p2sh_txs[3], True, False, b'bad-witness-nonstandard')\n-        self.test_node.test_transaction_acceptance(p2sh_txs[3], True, True)\n+        test_transaction_acceptance(self.nodes[1].rpc, self.std_node, p2sh_txs[3], True, False, b'bad-witness-nonstandard')\n+        test_transaction_acceptance(self.nodes[0].rpc, self.test_node, p2sh_txs[3], True, True)\n \n         self.nodes[0].generate(1)  # Mine and clean up the mempool of non-standard node\n         # Valid but non-standard transactions in a block should be accepted by standard node\n@@ -1870,11 +1876,11 @@ def test_non_standard_witness(self):\n     def run_test(self):\n         # Setup the p2p connections and start up the network thread.\n         # self.test_node sets NODE_WITNESS|NODE_NETWORK\n-        self.test_node = self.nodes[0].add_p2p_connection(TestNode(self.nodes[0].rpc), services=NODE_NETWORK|NODE_WITNESS)\n+        self.test_node = self.nodes[0].add_p2p_connection(p2p_conn=TestNode(), services=NODE_NETWORK|NODE_WITNESS)\n         # self.old_node sets only NODE_NETWORK\n-        self.old_node = self.nodes[0].add_p2p_connection(TestNode(self.nodes[0].rpc), services=NODE_NETWORK)\n+        self.old_node = self.nodes[0].add_p2p_connection(p2p_conn=TestNode(), services=NODE_NETWORK)\n         # self.std_node is for testing node1 (fRequireStandard=true)\n-        self.std_node = self.nodes[1].add_p2p_connection(TestNode(self.nodes[1].rpc), services=NODE_NETWORK|NODE_WITNESS)\n+        self.std_node = self.nodes[1].add_p2p_connection(p2p_conn=TestNode(), services=NODE_NETWORK|NODE_WITNESS)\n \n         NetworkThread().start() # Start up network handling in another thread\n "
      }
    ]
  },
  {
    "sha": "f2ae6f32a6e3e90d77564758383b9afbbac890b7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmMmFlNmYzMmE2ZTNlOTBkNzc1NjQ3NTgzODNiOWFmYmJhYzg5MGI3",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-23T14:36:35Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-23T15:03:22Z"
      },
      "message": "[tests] Remove mininode periodic (half-hour) ping messages",
      "tree": {
        "sha": "6f532316b1bfcb5ddaea5fcb11ab0663d07775da",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6f532316b1bfcb5ddaea5fcb11ab0663d07775da"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f2ae6f32a6e3e90d77564758383b9afbbac890b7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f2ae6f32a6e3e90d77564758383b9afbbac890b7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f2ae6f32a6e3e90d77564758383b9afbbac890b7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f2ae6f32a6e3e90d77564758383b9afbbac890b7/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ec59523c5915fb67db33149290dfc57049ba973d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ec59523c5915fb67db33149290dfc57049ba973d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ec59523c5915fb67db33149290dfc57049ba973d"
      }
    ],
    "stats": {
      "total": 5,
      "additions": 0,
      "deletions": 5
    },
    "files": [
      {
        "sha": "c8bd21e51fffa3a607b382959d2e420df737c9fc",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f2ae6f32a6e3e90d77564758383b9afbbac890b7/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f2ae6f32a6e3e90d77564758383b9afbbac890b7/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=f2ae6f32a6e3e90d77564758383b9afbbac890b7",
        "patch": "@@ -20,7 +20,6 @@\n import socket\n import struct\n import sys\n-import time\n from threading import RLock, Thread\n \n from test_framework.messages import *\n@@ -208,7 +207,6 @@ def __init__(self, dstaddr, dstport, callback, net=\"regtest\", services=NODE_NETW\n         self.socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n         self.sendbuf = b\"\"\n         self.recvbuf = b\"\"\n-        self.last_sent = 0\n         self.state = \"connecting\"\n         self.network = net\n         self.cb = callback\n@@ -300,8 +298,6 @@ def got_data(self):\n             raise\n \n     def got_message(self, message):\n-        if self.last_sent + 30 * 60 < time.time():\n-            self.send_message(MESSAGEMAP[b'ping']())\n         self._log_message(\"receive\", message)\n         self.cb.deliver(self, message)\n \n@@ -353,7 +349,6 @@ def send_message(self, message, pushbuf=False):\n                     self.sendbuf = tmsg\n             else:\n                 self.sendbuf += tmsg\n-            self.last_sent = time.time()\n \n     # Class utility methods\n "
      }
    ]
  },
  {
    "sha": "4d50598569fec0a4be4adef978a593aa71e87d02",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ZDUwNTk4NTY5ZmVjMGE0YmU0YWRlZjk3OGE1OTNhYTcxZTg3ZDAy",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-23T14:47:11Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-28T17:31:31Z"
      },
      "message": "[tests] Tidy up mininode\n\nAdd docstrings and renames some methods.\nAlso removes the redundant NodeConn.readable() method override.",
      "tree": {
        "sha": "b8093e1cdcd17cc1077a72ecaa119c27c50cf94d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b8093e1cdcd17cc1077a72ecaa119c27c50cf94d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4d50598569fec0a4be4adef978a593aa71e87d02",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4d50598569fec0a4be4adef978a593aa71e87d02",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4d50598569fec0a4be4adef978a593aa71e87d02",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4d50598569fec0a4be4adef978a593aa71e87d02/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f2ae6f32a6e3e90d77564758383b9afbbac890b7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f2ae6f32a6e3e90d77564758383b9afbbac890b7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f2ae6f32a6e3e90d77564758383b9afbbac890b7"
      }
    ],
    "stats": {
      "total": 35,
      "additions": 24,
      "deletions": 11
    },
    "files": [
      {
        "sha": "838c88573572b4d9006082e79ffec81cbbb03504",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 24,
        "deletions": 11,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4d50598569fec0a4be4adef978a593aa71e87d02/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4d50598569fec0a4be4adef978a593aa71e87d02/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=4d50598569fec0a4be4adef978a593aa71e87d02",
        "patch": "@@ -76,7 +76,7 @@ def __init__(self):\n \n     # Message receiving methods\n \n-    def deliver(self, conn, message):\n+    def on_message(self, conn, message):\n         \"\"\"Receive message and dispatch message to appropriate callback.\n \n         We keep a count of how many of each message type has been received\n@@ -233,12 +233,14 @@ def __init__(self, dstaddr, dstport, callback, net=\"regtest\", services=NODE_NETW\n     # Connection and disconnection methods\n \n     def handle_connect(self):\n+        \"\"\"asyncore callback when a connection is opened.\"\"\"\n         if self.state != \"connected\":\n             logger.debug(\"Connected & Listening: %s:%d\" % (self.dstaddr, self.dstport))\n             self.state = \"connected\"\n             self.cb.on_open(self)\n \n     def handle_close(self):\n+        \"\"\"asyncore callback when a connection is closed.\"\"\"\n         logger.debug(\"Closing connection to: %s:%d\" % (self.dstaddr, self.dstport))\n         self.state = \"closed\"\n         self.recvbuf = b\"\"\n@@ -250,24 +252,27 @@ def handle_close(self):\n         self.cb.on_close(self)\n \n     def disconnect_node(self):\n-        \"\"\" Disconnect the p2p connection.\n+        \"\"\"Disconnect the p2p connection.\n \n         Called by the test logic thread. Causes the p2p connection\n         to be disconnected on the next iteration of the asyncore loop.\"\"\"\n         self.disconnect = True\n \n     # Socket read methods\n \n-    def readable(self):\n-        return True\n-\n     def handle_read(self):\n+        \"\"\"asyncore callback when data is read from the socket.\"\"\"\n         t = self.recv(8192)\n         if len(t) > 0:\n             self.recvbuf += t\n-            self.got_data()\n+            self._on_data()\n+\n+    def _on_data(self):\n+        \"\"\"Try to read P2P messages from the recv buffer.\n \n-    def got_data(self):\n+        This method reads data from the buffer in a loop. It deserializes,\n+        parses and verifies the P2P header, then passes the P2P payload to\n+        the on_message callback for processing.\"\"\"\n         try:\n             while True:\n                 if len(self.recvbuf) < 4:\n@@ -292,24 +297,27 @@ def got_data(self):\n                 f = BytesIO(msg)\n                 t = MESSAGEMAP[command]()\n                 t.deserialize(f)\n-                self.got_message(t)\n+                self._log_message(\"receive\", t)\n+                self.on_message(t)\n         except Exception as e:\n             logger.exception('Error reading message:', repr(e))\n             raise\n \n-    def got_message(self, message):\n-        self._log_message(\"receive\", message)\n-        self.cb.deliver(self, message)\n+    def on_message(self, message):\n+        \"\"\"Callback for processing a P2P payload. Calls into NodeConnCB.\"\"\"\n+        self.cb.on_message(self, message)\n \n     # Socket write methods\n \n     def writable(self):\n+        \"\"\"asyncore method to determine whether the handle_write() callback should be called on the next loop.\"\"\"\n         with mininode_lock:\n             pre_connection = self.state == \"connecting\"\n             length = len(self.sendbuf)\n         return (length > 0 or pre_connection)\n \n     def handle_write(self):\n+        \"\"\"asyncore callback when data should be written to the socket.\"\"\"\n         with mininode_lock:\n             # asyncore does not expose socket connection, only the first read/write\n             # event, thus we must check connection manually here to know when we\n@@ -327,6 +335,10 @@ def handle_write(self):\n             self.sendbuf = self.sendbuf[sent:]\n \n     def send_message(self, message, pushbuf=False):\n+        \"\"\"Send a P2P message over the socket.\n+\n+        This method takes a P2P payload, builds the P2P header and adds\n+        the message to the send buffer to be sent over the socket.\"\"\"\n         if self.state != \"connected\" and not pushbuf:\n             raise IOError('Not connected, no pushbuf')\n         self._log_message(\"send\", message)\n@@ -353,6 +365,7 @@ def send_message(self, message, pushbuf=False):\n     # Class utility methods\n \n     def _log_message(self, direction, msg):\n+        \"\"\"Logs a message being sent or received over the connection.\"\"\"\n         if direction == \"send\":\n             log_message = \"Send message to \"\n         elif direction == \"receive\":"
      }
    ]
  },
  {
    "sha": "e30d404385f46811eeeea05c55ef786bc4adcb77",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplMzBkNDA0Mzg1ZjQ2ODExZWVlZWEwNWM1NWVmNzg2YmM0YWRjYjc3",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-23T15:17:50Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-28T17:31:37Z"
      },
      "message": "[tests] Move only: move NodeConnCB below NodeConn\n\nThis is required since NodeConnCB will inherit from NodeConn\nafter the next commit.",
      "tree": {
        "sha": "7f4d783580f7c89d697007b28aed4f3640cec53a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7f4d783580f7c89d697007b28aed4f3640cec53a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e30d404385f46811eeeea05c55ef786bc4adcb77",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e30d404385f46811eeeea05c55ef786bc4adcb77",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e30d404385f46811eeeea05c55ef786bc4adcb77",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e30d404385f46811eeeea05c55ef786bc4adcb77/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4d50598569fec0a4be4adef978a593aa71e87d02",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4d50598569fec0a4be4adef978a593aa71e87d02",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4d50598569fec0a4be4adef978a593aa71e87d02"
      }
    ],
    "stats": {
      "total": 277,
      "additions": 139,
      "deletions": 138
    },
    "files": [
      {
        "sha": "2b888949f4b662704bf1547feae107b742b9991b",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 139,
        "deletions": 138,
        "changes": 277,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e30d404385f46811eeeea05c55ef786bc4adcb77/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e30d404385f46811eeeea05c55ef786bc4adcb77/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=e30d404385f46811eeeea05c55ef786bc4adcb77",
        "patch": "@@ -56,144 +56,6 @@\n     \"regtest\": b\"\\xfa\\xbf\\xb5\\xda\",   # regtest\n }\n \n-class NodeConnCB():\n-    \"\"\"Callback and helper functions for P2P connection to a bitcoind node.\n-\n-    Individual testcases should subclass this and override the on_* methods\n-    if they want to alter message handling behaviour.\"\"\"\n-    def __init__(self):\n-        # Track whether we have a P2P connection open to the node\n-        self.connected = False\n-        self.connection = None\n-\n-        # Track number of messages of each type received and the most recent\n-        # message of each type\n-        self.message_count = defaultdict(int)\n-        self.last_message = {}\n-\n-        # A count of the number of ping messages we've sent to the node\n-        self.ping_counter = 1\n-\n-    # Message receiving methods\n-\n-    def on_message(self, conn, message):\n-        \"\"\"Receive message and dispatch message to appropriate callback.\n-\n-        We keep a count of how many of each message type has been received\n-        and the most recent message of each type.\"\"\"\n-        with mininode_lock:\n-            try:\n-                command = message.command.decode('ascii')\n-                self.message_count[command] += 1\n-                self.last_message[command] = message\n-                getattr(self, 'on_' + command)(conn, message)\n-            except:\n-                print(\"ERROR delivering %s (%s)\" % (repr(message),\n-                                                    sys.exc_info()[0]))\n-                raise\n-\n-    # Callback methods. Can be overridden by subclasses in individual test\n-    # cases to provide custom message handling behaviour.\n-\n-    def on_open(self, conn):\n-        self.connected = True\n-\n-    def on_close(self, conn):\n-        self.connected = False\n-        self.connection = None\n-\n-    def on_addr(self, conn, message): pass\n-    def on_block(self, conn, message): pass\n-    def on_blocktxn(self, conn, message): pass\n-    def on_cmpctblock(self, conn, message): pass\n-    def on_feefilter(self, conn, message): pass\n-    def on_getaddr(self, conn, message): pass\n-    def on_getblocks(self, conn, message): pass\n-    def on_getblocktxn(self, conn, message): pass\n-    def on_getdata(self, conn, message): pass\n-    def on_getheaders(self, conn, message): pass\n-    def on_headers(self, conn, message): pass\n-    def on_mempool(self, conn): pass\n-    def on_pong(self, conn, message): pass\n-    def on_reject(self, conn, message): pass\n-    def on_sendcmpct(self, conn, message): pass\n-    def on_sendheaders(self, conn, message): pass\n-    def on_tx(self, conn, message): pass\n-\n-    def on_inv(self, conn, message):\n-        want = msg_getdata()\n-        for i in message.inv:\n-            if i.type != 0:\n-                want.inv.append(i)\n-        if len(want.inv):\n-            conn.send_message(want)\n-\n-    def on_ping(self, conn, message):\n-        conn.send_message(msg_pong(message.nonce))\n-\n-    def on_verack(self, conn, message):\n-        self.verack_received = True\n-\n-    def on_version(self, conn, message):\n-        assert message.nVersion >= MIN_VERSION_SUPPORTED, \"Version {} received. Test framework only supports versions greater than {}\".format(message.nVersion, MIN_VERSION_SUPPORTED)\n-        conn.send_message(msg_verack())\n-        conn.nServices = message.nServices\n-\n-    # Connection helper methods\n-\n-    def add_connection(self, conn):\n-        self.connection = conn\n-\n-    def wait_for_disconnect(self, timeout=60):\n-        test_function = lambda: not self.connected\n-        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n-\n-    # Message receiving helper methods\n-\n-    def wait_for_block(self, blockhash, timeout=60):\n-        test_function = lambda: self.last_message.get(\"block\") and self.last_message[\"block\"].block.rehash() == blockhash\n-        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n-\n-    def wait_for_getdata(self, timeout=60):\n-        test_function = lambda: self.last_message.get(\"getdata\")\n-        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n-\n-    def wait_for_getheaders(self, timeout=60):\n-        test_function = lambda: self.last_message.get(\"getheaders\")\n-        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n-\n-    def wait_for_inv(self, expected_inv, timeout=60):\n-        \"\"\"Waits for an INV message and checks that the first inv object in the message was as expected.\"\"\"\n-        if len(expected_inv) > 1:\n-            raise NotImplementedError(\"wait_for_inv() will only verify the first inv object\")\n-        test_function = lambda: self.last_message.get(\"inv\") and \\\n-                                self.last_message[\"inv\"].inv[0].type == expected_inv[0].type and \\\n-                                self.last_message[\"inv\"].inv[0].hash == expected_inv[0].hash\n-        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n-\n-    def wait_for_verack(self, timeout=60):\n-        test_function = lambda: self.message_count[\"verack\"]\n-        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n-\n-    # Message sending helper functions\n-\n-    def send_message(self, message):\n-        if self.connection:\n-            self.connection.send_message(message)\n-        else:\n-            logger.error(\"Cannot send message. No connection to node!\")\n-\n-    def send_and_ping(self, message):\n-        self.send_message(message)\n-        self.sync_with_ping()\n-\n-    # Sync up with the node\n-    def sync_with_ping(self, timeout=60):\n-        self.send_message(msg_ping(nonce=self.ping_counter))\n-        test_function = lambda: self.last_message.get(\"pong\") and self.last_message[\"pong\"].nonce == self.ping_counter\n-        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n-        self.ping_counter += 1\n-\n class NodeConn(asyncore.dispatcher):\n     \"\"\"The actual NodeConn class\n \n@@ -376,6 +238,145 @@ def _log_message(self, direction, msg):\n         logger.debug(log_message)\n \n \n+class NodeConnCB():\n+    \"\"\"Callback and helper functions for P2P connection to a bitcoind node.\n+\n+    Individual testcases should subclass this and override the on_* methods\n+    if they want to alter message handling behaviour.\"\"\"\n+    def __init__(self):\n+        # Track whether we have a P2P connection open to the node\n+        self.connected = False\n+        self.connection = None\n+\n+        # Track number of messages of each type received and the most recent\n+        # message of each type\n+        self.message_count = defaultdict(int)\n+        self.last_message = {}\n+\n+        # A count of the number of ping messages we've sent to the node\n+        self.ping_counter = 1\n+\n+    # Message receiving methods\n+\n+    def on_message(self, conn, message):\n+        \"\"\"Receive message and dispatch message to appropriate callback.\n+\n+        We keep a count of how many of each message type has been received\n+        and the most recent message of each type.\"\"\"\n+        with mininode_lock:\n+            try:\n+                command = message.command.decode('ascii')\n+                self.message_count[command] += 1\n+                self.last_message[command] = message\n+                getattr(self, 'on_' + command)(conn, message)\n+            except:\n+                print(\"ERROR delivering %s (%s)\" % (repr(message),\n+                                                    sys.exc_info()[0]))\n+                raise\n+\n+    # Callback methods. Can be overridden by subclasses in individual test\n+    # cases to provide custom message handling behaviour.\n+\n+    def on_open(self, conn):\n+        self.connected = True\n+\n+    def on_close(self, conn):\n+        self.connected = False\n+        self.connection = None\n+\n+    def on_addr(self, conn, message): pass\n+    def on_block(self, conn, message): pass\n+    def on_blocktxn(self, conn, message): pass\n+    def on_cmpctblock(self, conn, message): pass\n+    def on_feefilter(self, conn, message): pass\n+    def on_getaddr(self, conn, message): pass\n+    def on_getblocks(self, conn, message): pass\n+    def on_getblocktxn(self, conn, message): pass\n+    def on_getdata(self, conn, message): pass\n+    def on_getheaders(self, conn, message): pass\n+    def on_headers(self, conn, message): pass\n+    def on_mempool(self, conn): pass\n+    def on_pong(self, conn, message): pass\n+    def on_reject(self, conn, message): pass\n+    def on_sendcmpct(self, conn, message): pass\n+    def on_sendheaders(self, conn, message): pass\n+    def on_tx(self, conn, message): pass\n+\n+    def on_inv(self, conn, message):\n+        want = msg_getdata()\n+        for i in message.inv:\n+            if i.type != 0:\n+                want.inv.append(i)\n+        if len(want.inv):\n+            conn.send_message(want)\n+\n+    def on_ping(self, conn, message):\n+        conn.send_message(msg_pong(message.nonce))\n+\n+    def on_verack(self, conn, message):\n+        self.verack_received = True\n+\n+    def on_version(self, conn, message):\n+        assert message.nVersion >= MIN_VERSION_SUPPORTED, \"Version {} received. Test framework only supports versions greater than {}\".format(message.nVersion, MIN_VERSION_SUPPORTED)\n+        conn.send_message(msg_verack())\n+        conn.nServices = message.nServices\n+\n+    # Connection helper methods\n+\n+    def add_connection(self, conn):\n+        self.connection = conn\n+\n+    def wait_for_disconnect(self, timeout=60):\n+        test_function = lambda: not self.connected\n+        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n+\n+    # Message receiving helper methods\n+\n+    def wait_for_block(self, blockhash, timeout=60):\n+        test_function = lambda: self.last_message.get(\"block\") and self.last_message[\"block\"].block.rehash() == blockhash\n+        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n+\n+    def wait_for_getdata(self, timeout=60):\n+        test_function = lambda: self.last_message.get(\"getdata\")\n+        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n+\n+    def wait_for_getheaders(self, timeout=60):\n+        test_function = lambda: self.last_message.get(\"getheaders\")\n+        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n+\n+    def wait_for_inv(self, expected_inv, timeout=60):\n+        \"\"\"Waits for an INV message and checks that the first inv object in the message was as expected.\"\"\"\n+        if len(expected_inv) > 1:\n+            raise NotImplementedError(\"wait_for_inv() will only verify the first inv object\")\n+        test_function = lambda: self.last_message.get(\"inv\") and \\\n+                                self.last_message[\"inv\"].inv[0].type == expected_inv[0].type and \\\n+                                self.last_message[\"inv\"].inv[0].hash == expected_inv[0].hash\n+        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n+\n+    def wait_for_verack(self, timeout=60):\n+        test_function = lambda: self.message_count[\"verack\"]\n+        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n+\n+    # Message sending helper functions\n+\n+    def send_message(self, message):\n+        if self.connection:\n+            self.connection.send_message(message)\n+        else:\n+            logger.error(\"Cannot send message. No connection to node!\")\n+\n+    def send_and_ping(self, message):\n+        self.send_message(message)\n+        self.sync_with_ping()\n+\n+    # Sync up with the node\n+    def sync_with_ping(self, timeout=60):\n+        self.send_message(msg_ping(nonce=self.ping_counter))\n+        test_function = lambda: self.last_message.get(\"pong\") and self.last_message[\"pong\"].nonce == self.ping_counter\n+        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n+        self.ping_counter += 1\n+\n+\n # Keep our own socket map for asyncore, so that we can track disconnects\n # ourselves (to workaround an issue with closing an asyncore socket when\n # using select)"
      }
    ]
  },
  {
    "sha": "dad596fc37c8733ab806a0aa4224ac437d37aee5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkYWQ1OTZmYzM3Yzg3MzNhYjgwNmEwYWE0MjI0YWM0MzdkMzdhZWU1",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-17T20:01:24Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-28T17:44:16Z"
      },
      "message": "[tests] Make NodeConnCB a subclass of NodeConn\n\nThis makes NodeConnCB a subclass of NodeConn, and\nremoves the need for the client code to know\nanything about the implementation details of NodeConnCB.\n\nNodeConn can now be swapped out for any other implementation\nof a low-level connection without changing client code.",
      "tree": {
        "sha": "bf014d46fb9d4e0ae865756c422000914dc9c314",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bf014d46fb9d4e0ae865756c422000914dc9c314"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dad596fc37c8733ab806a0aa4224ac437d37aee5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dad596fc37c8733ab806a0aa4224ac437d37aee5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/dad596fc37c8733ab806a0aa4224ac437d37aee5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dad596fc37c8733ab806a0aa4224ac437d37aee5/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e30d404385f46811eeeea05c55ef786bc4adcb77",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e30d404385f46811eeeea05c55ef786bc4adcb77",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e30d404385f46811eeeea05c55ef786bc4adcb77"
      }
    ],
    "stats": {
      "total": 394,
      "additions": 197,
      "deletions": 197
    },
    "files": [
      {
        "sha": "72da955641b2627396f9ed3e45dea3628322fc24",
        "filename": "test/functional/assumevalid.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dad596fc37c8733ab806a0aa4224ac437d37aee5/test/functional/assumevalid.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dad596fc37c8733ab806a0aa4224ac437d37aee5/test/functional/assumevalid.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/assumevalid.py?ref=dad596fc37c8733ab806a0aa4224ac437d37aee5",
        "patch": "@@ -67,7 +67,7 @@ def setup_network(self):\n     def send_blocks_until_disconnected(self, p2p_conn):\n         \"\"\"Keep sending blocks to the node until we're disconnected.\"\"\"\n         for i in range(len(self.blocks)):\n-            if not p2p_conn.connection:\n+            if p2p_conn.state != \"connected\":\n                 break\n             try:\n                 p2p_conn.send_message(msg_block(self.blocks[i]))"
      },
      {
        "sha": "ec4d1d93652964684a58d1dfd15b29d4f73f5f29",
        "filename": "test/functional/bip9-softforks.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dad596fc37c8733ab806a0aa4224ac437d37aee5/test/functional/bip9-softforks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dad596fc37c8733ab806a0aa4224ac437d37aee5/test/functional/bip9-softforks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bip9-softforks.py?ref=dad596fc37c8733ab806a0aa4224ac437d37aee5",
        "patch": "@@ -246,7 +246,7 @@ def test_BIP(self, bipName, activated_version, invalidate, invalidatePostSignatu\n         self.setup_network()\n         self.test.add_all_connections(self.nodes)\n         NetworkThread().start()\n-        self.test.test_nodes[0].wait_for_verack()\n+        self.test.p2p_connections[0].wait_for_verack()\n \n     def get_tests(self):\n         for test in itertools.chain("
      },
      {
        "sha": "54cabee51c24f4e7dbf3f0fb3c9b000ab3c63904",
        "filename": "test/functional/example_test.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dad596fc37c8733ab806a0aa4224ac437d37aee5/test/functional/example_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dad596fc37c8733ab806a0aa4224ac437d37aee5/test/functional/example_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/example_test.py?ref=dad596fc37c8733ab806a0aa4224ac437d37aee5",
        "patch": "@@ -49,14 +49,14 @@ def __init__(self):\n         # Stores a dictionary of all blocks received\n         self.block_receive_map = defaultdict(int)\n \n-    def on_block(self, conn, message):\n+    def on_block(self, message):\n         \"\"\"Override the standard on_block callback\n \n         Store the hash of a received block in the dictionary.\"\"\"\n         message.block.calc_sha256()\n         self.block_receive_map[message.block.sha256] += 1\n \n-    def on_inv(self, conn, message):\n+    def on_inv(self, message):\n         \"\"\"Override the standard on_inv callback\"\"\"\n         pass\n "
      },
      {
        "sha": "beb0d599d2306b2376bbd1f80699d9e32f53b16b",
        "filename": "test/functional/maxuploadtarget.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dad596fc37c8733ab806a0aa4224ac437d37aee5/test/functional/maxuploadtarget.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dad596fc37c8733ab806a0aa4224ac437d37aee5/test/functional/maxuploadtarget.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/maxuploadtarget.py?ref=dad596fc37c8733ab806a0aa4224ac437d37aee5",
        "patch": "@@ -22,10 +22,10 @@ def __init__(self):\n         super().__init__()\n         self.block_receive_map = defaultdict(int)\n \n-    def on_inv(self, conn, message):\n+    def on_inv(self, message):\n         pass\n \n-    def on_block(self, conn, message):\n+    def on_block(self, message):\n         message.block.calc_sha256()\n         self.block_receive_map[message.block.sha256] += 1\n "
      },
      {
        "sha": "5aba1db8730d925abf8a95c9f3ba0be65602cdfa",
        "filename": "test/functional/p2p-compactblocks.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dad596fc37c8733ab806a0aa4224ac437d37aee5/test/functional/p2p-compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dad596fc37c8733ab806a0aa4224ac437d37aee5/test/functional/p2p-compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-compactblocks.py?ref=dad596fc37c8733ab806a0aa4224ac437d37aee5",
        "patch": "@@ -25,21 +25,21 @@ def __init__(self):\n         # so we can eg wait until a particular block is announced.\n         self.announced_blockhashes = set()\n \n-    def on_sendcmpct(self, conn, message):\n+    def on_sendcmpct(self, message):\n         self.last_sendcmpct.append(message)\n \n-    def on_cmpctblock(self, conn, message):\n+    def on_cmpctblock(self, message):\n         self.block_announced = True\n         self.last_message[\"cmpctblock\"].header_and_shortids.header.calc_sha256()\n         self.announced_blockhashes.add(self.last_message[\"cmpctblock\"].header_and_shortids.header.sha256)\n \n-    def on_headers(self, conn, message):\n+    def on_headers(self, message):\n         self.block_announced = True\n         for x in self.last_message[\"headers\"].headers:\n             x.calc_sha256()\n             self.announced_blockhashes.add(x.sha256)\n \n-    def on_inv(self, conn, message):\n+    def on_inv(self, message):\n         for x in self.last_message[\"inv\"].inv:\n             if x.type == 2:\n                 self.block_announced = True\n@@ -60,7 +60,7 @@ def get_headers(self, locator, hashstop):\n         msg = msg_getheaders()\n         msg.locator.vHave = locator\n         msg.hashstop = hashstop\n-        self.connection.send_message(msg)\n+        self.send_message(msg)\n \n     def send_header_for_blocks(self, new_blocks):\n         headers_message = msg_headers()\n@@ -86,7 +86,7 @@ def send_await_disconnect(self, message, timeout=30):\n         This is used when we want to send a message into the node that we expect\n         will get us disconnected, eg an invalid block.\"\"\"\n         self.send_message(message)\n-        wait_until(lambda: not self.connected, timeout=timeout, lock=mininode_lock)\n+        wait_until(lambda: self.state != \"connected\", timeout=timeout, lock=mininode_lock)\n \n class CompactBlocksTest(BitcoinTestFramework):\n     def set_test_params(self):"
      },
      {
        "sha": "0ce3c3f42938d11bca9f5d69907093764215c2c6",
        "filename": "test/functional/p2p-feefilter.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dad596fc37c8733ab806a0aa4224ac437d37aee5/test/functional/p2p-feefilter.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dad596fc37c8733ab806a0aa4224ac437d37aee5/test/functional/p2p-feefilter.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-feefilter.py?ref=dad596fc37c8733ab806a0aa4224ac437d37aee5",
        "patch": "@@ -27,7 +27,7 @@ def __init__(self):\n         super().__init__()\n         self.txinvs = []\n \n-    def on_inv(self, conn, message):\n+    def on_inv(self, message):\n         for i in message.inv:\n             if (i.type == 1):\n                 self.txinvs.append(hashToHex(i.hash))"
      },
      {
        "sha": "3634f3836dc75b5788b009b258af0699b9bf1ffc",
        "filename": "test/functional/p2p-leaktests.py",
        "status": "modified",
        "additions": 33,
        "deletions": 34,
        "changes": 67,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dad596fc37c8733ab806a0aa4224ac437d37aee5/test/functional/p2p-leaktests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dad596fc37c8733ab806a0aa4224ac437d37aee5/test/functional/p2p-leaktests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-leaktests.py?ref=dad596fc37c8733ab806a0aa4224ac437d37aee5",
        "patch": "@@ -30,43 +30,42 @@ def bad_message(self, message):\n         self.unexpected_msg = True\n         self.log.info(\"should not have received message: %s\" % message.command)\n \n-    def on_open(self, conn):\n-        self.connected = True\n+    def on_open(self):\n         self.ever_connected = True\n \n-    def on_version(self, conn, message): self.bad_message(message)\n-    def on_verack(self, conn, message): self.bad_message(message)\n-    def on_reject(self, conn, message): self.bad_message(message)\n-    def on_inv(self, conn, message): self.bad_message(message)\n-    def on_addr(self, conn, message): self.bad_message(message)\n-    def on_getdata(self, conn, message): self.bad_message(message)\n-    def on_getblocks(self, conn, message): self.bad_message(message)\n-    def on_tx(self, conn, message): self.bad_message(message)\n-    def on_block(self, conn, message): self.bad_message(message)\n-    def on_getaddr(self, conn, message): self.bad_message(message)\n-    def on_headers(self, conn, message): self.bad_message(message)\n-    def on_getheaders(self, conn, message): self.bad_message(message)\n-    def on_ping(self, conn, message): self.bad_message(message)\n-    def on_mempool(self, conn): self.bad_message(message)\n-    def on_pong(self, conn, message): self.bad_message(message)\n-    def on_feefilter(self, conn, message): self.bad_message(message)\n-    def on_sendheaders(self, conn, message): self.bad_message(message)\n-    def on_sendcmpct(self, conn, message): self.bad_message(message)\n-    def on_cmpctblock(self, conn, message): self.bad_message(message)\n-    def on_getblocktxn(self, conn, message): self.bad_message(message)\n-    def on_blocktxn(self, conn, message): self.bad_message(message)\n+    def on_version(self, message): self.bad_message(message)\n+    def on_verack(self, message): self.bad_message(message)\n+    def on_reject(self, message): self.bad_message(message)\n+    def on_inv(self, message): self.bad_message(message)\n+    def on_addr(self, message): self.bad_message(message)\n+    def on_getdata(self, message): self.bad_message(message)\n+    def on_getblocks(self, message): self.bad_message(message)\n+    def on_tx(self, message): self.bad_message(message)\n+    def on_block(self, message): self.bad_message(message)\n+    def on_getaddr(self, message): self.bad_message(message)\n+    def on_headers(self, message): self.bad_message(message)\n+    def on_getheaders(self, message): self.bad_message(message)\n+    def on_ping(self, message): self.bad_message(message)\n+    def on_mempool(self, message): self.bad_message(message)\n+    def on_pong(self, message): self.bad_message(message)\n+    def on_feefilter(self, message): self.bad_message(message)\n+    def on_sendheaders(self, message): self.bad_message(message)\n+    def on_sendcmpct(self, message): self.bad_message(message)\n+    def on_cmpctblock(self, message): self.bad_message(message)\n+    def on_getblocktxn(self, message): self.bad_message(message)\n+    def on_blocktxn(self, message): self.bad_message(message)\n \n # Node that never sends a version. We'll use this to send a bunch of messages\n # anyway, and eventually get disconnected.\n class CNodeNoVersionBan(CLazyNode):\n     # send a bunch of veracks without sending a message. This should get us disconnected.\n     # NOTE: implementation-specific check here. Remove if bitcoind ban behavior changes\n-    def on_open(self, conn):\n-        super().on_open(conn)\n+    def on_open(self):\n+        super().on_open()\n         for i in range(banscore):\n             self.send_message(msg_verack())\n \n-    def on_reject(self, conn, message): pass\n+    def on_reject(self, message): pass\n \n # Node that never sends a version. This one just sits idle and hopes to receive\n # any message (it shouldn't!)\n@@ -80,15 +79,15 @@ def __init__(self):\n         self.version_received = False\n         super().__init__()\n \n-    def on_reject(self, conn, message): pass\n-    def on_verack(self, conn, message): pass\n+    def on_reject(self, message): pass\n+    def on_verack(self, message): pass\n     # When version is received, don't reply with a verack. Instead, see if the\n     # node will give us a message that it shouldn't. This is not an exhaustive\n     # list!\n-    def on_version(self, conn, message):\n+    def on_version(self, message):\n         self.version_received = True\n-        conn.send_message(msg_ping())\n-        conn.send_message(msg_getaddr())\n+        self.send_message(msg_ping())\n+        self.send_message(msg_getaddr())\n \n class P2PLeakTest(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -119,11 +118,11 @@ def run_test(self):\n         time.sleep(5)\n \n         #This node should have been banned\n-        assert not no_version_bannode.connected\n+        assert no_version_bannode.state != \"connected\"\n \n         # These nodes should have been disconnected\n-        assert not unsupported_service_bit5_node.connected\n-        assert not unsupported_service_bit7_node.connected\n+        assert unsupported_service_bit5_node.state != \"connected\"\n+        assert unsupported_service_bit7_node.state != \"connected\"\n \n         self.nodes[0].disconnect_p2ps()\n "
      },
      {
        "sha": "5776d99f6e1bd1f13b122f7abe9ecaff661b42cb",
        "filename": "test/functional/p2p-segwit.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dad596fc37c8733ab806a0aa4224ac437d37aee5/test/functional/p2p-segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dad596fc37c8733ab806a0aa4224ac437d37aee5/test/functional/p2p-segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-segwit.py?ref=dad596fc37c8733ab806a0aa4224ac437d37aee5",
        "patch": "@@ -64,7 +64,7 @@ def __init__(self):\n         super().__init__()\n         self.getdataset = set()\n \n-    def on_getdata(self, conn, message):\n+    def on_getdata(self, message):\n         for inv in message.inv:\n             self.getdataset.add(inv.hash)\n \n@@ -148,7 +148,7 @@ def update_witness_block_with_transactions(self, block, tx_list, nonce=0):\n     ''' Individual tests '''\n     def test_witness_services(self):\n         self.log.info(\"Verifying NODE_WITNESS service bit\")\n-        assert((self.test_node.connection.nServices & NODE_WITNESS) != 0)\n+        assert((self.test_node.nServices & NODE_WITNESS) != 0)\n \n \n     # See if sending a regular transaction works, and create a utxo\n@@ -1876,11 +1876,11 @@ def test_non_standard_witness(self):\n     def run_test(self):\n         # Setup the p2p connections and start up the network thread.\n         # self.test_node sets NODE_WITNESS|NODE_NETWORK\n-        self.test_node = self.nodes[0].add_p2p_connection(p2p_conn=TestNode(), services=NODE_NETWORK|NODE_WITNESS)\n+        self.test_node = self.nodes[0].add_p2p_connection(TestNode(), services=NODE_NETWORK|NODE_WITNESS)\n         # self.old_node sets only NODE_NETWORK\n-        self.old_node = self.nodes[0].add_p2p_connection(p2p_conn=TestNode(), services=NODE_NETWORK)\n+        self.old_node = self.nodes[0].add_p2p_connection(TestNode(), services=NODE_NETWORK)\n         # self.std_node is for testing node1 (fRequireStandard=true)\n-        self.std_node = self.nodes[1].add_p2p_connection(p2p_conn=TestNode(), services=NODE_NETWORK|NODE_WITNESS)\n+        self.std_node = self.nodes[1].add_p2p_connection(TestNode(), services=NODE_NETWORK|NODE_WITNESS)\n \n         NetworkThread().start() # Start up network handling in another thread\n "
      },
      {
        "sha": "21ae29eb6a0c9b9c3be56b725f4fa3e8b228288d",
        "filename": "test/functional/p2p-timeouts.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dad596fc37c8733ab806a0aa4224ac437d37aee5/test/functional/p2p-timeouts.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dad596fc37c8733ab806a0aa4224ac437d37aee5/test/functional/p2p-timeouts.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-timeouts.py?ref=dad596fc37c8733ab806a0aa4224ac437d37aee5",
        "patch": "@@ -28,7 +28,7 @@\n from test_framework.util import *\n \n class TestNode(NodeConnCB):\n-    def on_version(self, conn, message):\n+    def on_version(self, message):\n         # Don't send a verack in response\n         pass\n "
      },
      {
        "sha": "a6265f6d9cf4c25553fb7de6440b99fa4adb65e4",
        "filename": "test/functional/p2p-versionbits-warning.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dad596fc37c8733ab806a0aa4224ac437d37aee5/test/functional/p2p-versionbits-warning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dad596fc37c8733ab806a0aa4224ac437d37aee5/test/functional/p2p-versionbits-warning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-versionbits-warning.py?ref=dad596fc37c8733ab806a0aa4224ac437d37aee5",
        "patch": "@@ -24,7 +24,7 @@\n VB_PATTERN = re.compile(\"^Warning.*versionbit\")\n \n class TestNode(NodeConnCB):\n-    def on_inv(self, conn, message):\n+    def on_inv(self, message):\n         pass\n \n class VersionBitsWarningTest(BitcoinTestFramework):"
      },
      {
        "sha": "b589d0e8a56258a132d97cc89cbba5ad5b4d0624",
        "filename": "test/functional/sendheaders.py",
        "status": "modified",
        "additions": 6,
        "deletions": 5,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dad596fc37c8733ab806a0aa4224ac437d37aee5/test/functional/sendheaders.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dad596fc37c8733ab806a0aa4224ac437d37aee5/test/functional/sendheaders.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/sendheaders.py?ref=dad596fc37c8733ab806a0aa4224ac437d37aee5",
        "patch": "@@ -113,6 +113,7 @@\n class BaseNode(NodeConnCB):\n     def __init__(self):\n         super().__init__()\n+\n         self.block_announced = False\n         self.last_blockhash_announced = None\n \n@@ -121,18 +122,18 @@ def send_get_data(self, block_hashes):\n         msg = msg_getdata()\n         for x in block_hashes:\n             msg.inv.append(CInv(2, x))\n-        self.connection.send_message(msg)\n+        self.send_message(msg)\n \n     def send_get_headers(self, locator, hashstop):\n         msg = msg_getheaders()\n         msg.locator.vHave = locator\n         msg.hashstop = hashstop\n-        self.connection.send_message(msg)\n+        self.send_message(msg)\n \n     def send_block_inv(self, blockhash):\n         msg = msg_inv()\n         msg.inv = [CInv(2, blockhash)]\n-        self.connection.send_message(msg)\n+        self.send_message(msg)\n \n     def send_header_for_blocks(self, new_blocks):\n         headers_message = msg_headers()\n@@ -155,11 +156,11 @@ def wait_for_block_announcement(self, block_hash, timeout=60):\n         test_function = lambda: self.last_blockhash_announced == block_hash\n         wait_until(test_function, timeout=timeout, lock=mininode_lock)\n \n-    def on_inv(self, conn, message):\n+    def on_inv(self, message):\n         self.block_announced = True\n         self.last_blockhash_announced = message.inv[-1].hash\n \n-    def on_headers(self, conn, message):\n+    def on_headers(self, message):\n         if len(message.headers):\n             self.block_announced = True\n             message.headers[-1].calc_sha256()"
      },
      {
        "sha": "2f64fba7536d877a9e2eb88af39076d4911d99ff",
        "filename": "test/functional/test_framework/comptool.py",
        "status": "modified",
        "additions": 58,
        "deletions": 67,
        "changes": 125,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dad596fc37c8733ab806a0aa4224ac437d37aee5/test/functional/test_framework/comptool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dad596fc37c8733ab806a0aa4224ac437d37aee5/test/functional/test_framework/comptool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/comptool.py?ref=dad596fc37c8733ab806a0aa4224ac437d37aee5",
        "patch": "@@ -43,7 +43,6 @@ class TestNode(NodeConnCB):\n \n     def __init__(self, block_store, tx_store):\n         super().__init__()\n-        self.conn = None\n         self.bestblockhash = None\n         self.block_store = block_store\n         self.block_request_map = {}\n@@ -58,74 +57,71 @@ def __init__(self, block_store, tx_store):\n         self.lastInv = []\n         self.closed = False\n \n-    def on_close(self, conn):\n+    def on_close(self):\n         self.closed = True\n \n-    def add_connection(self, conn):\n-        self.conn = conn\n-\n-    def on_headers(self, conn, message):\n+    def on_headers(self, message):\n         if len(message.headers) > 0:\n             best_header = message.headers[-1]\n             best_header.calc_sha256()\n             self.bestblockhash = best_header.sha256\n \n-    def on_getheaders(self, conn, message):\n+    def on_getheaders(self, message):\n         response = self.block_store.headers_for(message.locator, message.hashstop)\n         if response is not None:\n-            conn.send_message(response)\n+            self.send_message(response)\n \n-    def on_getdata(self, conn, message):\n-        [conn.send_message(r) for r in self.block_store.get_blocks(message.inv)]\n-        [conn.send_message(r) for r in self.tx_store.get_transactions(message.inv)]\n+    def on_getdata(self, message):\n+        [self.send_message(r) for r in self.block_store.get_blocks(message.inv)]\n+        [self.send_message(r) for r in self.tx_store.get_transactions(message.inv)]\n \n         for i in message.inv:\n             if i.type == 1 or i.type == 1 | (1 << 30): # MSG_TX or MSG_WITNESS_TX\n                 self.tx_request_map[i.hash] = True\n             elif i.type == 2 or i.type == 2 | (1 << 30): # MSG_BLOCK or MSG_WITNESS_BLOCK\n                 self.block_request_map[i.hash] = True\n \n-    def on_inv(self, conn, message):\n+    def on_inv(self, message):\n         self.lastInv = [x.hash for x in message.inv]\n \n-    def on_pong(self, conn, message):\n+    def on_pong(self, message):\n         try:\n             del self.pingMap[message.nonce]\n         except KeyError:\n             raise AssertionError(\"Got pong for unknown ping [%s]\" % repr(message))\n \n-    def on_reject(self, conn, message):\n+    def on_reject(self, message):\n         if message.message == b'tx':\n             self.tx_reject_map[message.data] = RejectResult(message.code, message.reason)\n         if message.message == b'block':\n             self.block_reject_map[message.data] = RejectResult(message.code, message.reason)\n \n     def send_inv(self, obj):\n         mtype = 2 if isinstance(obj, CBlock) else 1\n-        self.conn.send_message(msg_inv([CInv(mtype, obj.sha256)]))\n+        self.send_message(msg_inv([CInv(mtype, obj.sha256)]))\n \n     def send_getheaders(self):\n         # We ask for headers from their last tip.\n         m = msg_getheaders()\n         m.locator = self.block_store.get_locator(self.bestblockhash)\n-        self.conn.send_message(m)\n+        self.send_message(m)\n \n     def send_header(self, header):\n         m = msg_headers()\n         m.headers.append(header)\n-        self.conn.send_message(m)\n+        self.send_message(m)\n \n     # This assumes BIP31\n     def send_ping(self, nonce):\n         self.pingMap[nonce] = True\n-        self.conn.send_message(msg_ping(nonce))\n+        self.send_message(msg_ping(nonce))\n \n     def received_ping_response(self, nonce):\n         return nonce not in self.pingMap\n \n     def send_mempool(self):\n         self.lastInv = []\n-        self.conn.send_message(msg_mempool())\n+        self.send_message(msg_mempool())\n \n # TestInstance:\n #\n@@ -166,37 +162,32 @@ class TestManager():\n \n     def __init__(self, testgen, datadir):\n         self.test_generator = testgen\n-        self.connections    = []\n-        self.test_nodes     = []\n+        self.p2p_connections= []\n         self.block_store    = BlockStore(datadir)\n         self.tx_store       = TxStore(datadir)\n         self.ping_counter   = 1\n \n     def add_all_connections(self, nodes):\n         for i in range(len(nodes)):\n             # Create a p2p connection to each node\n-            test_node = TestNode(self.block_store, self.tx_store)\n-            self.test_nodes.append(test_node)\n-            self.connections.append(NodeConn('127.0.0.1', p2p_port(i), test_node))\n-            # Make sure the TestNode (callback class) has a reference to its\n-            # associated NodeConn\n-            test_node.add_connection(self.connections[-1])\n+            node = TestNode(self.block_store, self.tx_store)\n+            node.peer_connect('127.0.0.1', p2p_port(i))\n+            self.p2p_connections.append(node)\n \n     def clear_all_connections(self):\n-        self.connections    = []\n-        self.test_nodes     = []\n+        self.p2p_connections = []\n \n     def wait_for_disconnections(self):\n         def disconnected():\n-            return all(node.closed for node in self.test_nodes)\n+            return all(node.closed for node in self.p2p_connections)\n         wait_until(disconnected, timeout=10, lock=mininode_lock)\n \n     def wait_for_verack(self):\n-        return all(node.wait_for_verack() for node in self.test_nodes)\n+        return all(node.wait_for_verack() for node in self.p2p_connections)\n \n     def wait_for_pings(self, counter):\n         def received_pongs():\n-            return all(node.received_ping_response(counter) for node in self.test_nodes)\n+            return all(node.received_ping_response(counter) for node in self.p2p_connections)\n         wait_until(received_pongs, lock=mininode_lock)\n \n     # sync_blocks: Wait for all connections to request the blockhash given\n@@ -206,17 +197,17 @@ def sync_blocks(self, blockhash, num_blocks):\n         def blocks_requested():\n             return all(\n                 blockhash in node.block_request_map and node.block_request_map[blockhash]\n-                for node in self.test_nodes\n+                for node in self.p2p_connections\n             )\n \n         # --> error if not requested\n         wait_until(blocks_requested, attempts=20*num_blocks, lock=mininode_lock)\n \n         # Send getheaders message\n-        [ c.cb.send_getheaders() for c in self.connections ]\n+        [ c.send_getheaders() for c in self.p2p_connections ]\n \n         # Send ping and wait for response -- synchronization hack\n-        [ c.cb.send_ping(self.ping_counter) for c in self.connections ]\n+        [ c.send_ping(self.ping_counter) for c in self.p2p_connections ]\n         self.wait_for_pings(self.ping_counter)\n         self.ping_counter += 1\n \n@@ -226,42 +217,42 @@ def sync_transaction(self, txhash, num_events):\n         def transaction_requested():\n             return all(\n                 txhash in node.tx_request_map and node.tx_request_map[txhash]\n-                for node in self.test_nodes\n+                for node in self.p2p_connections\n             )\n \n         # --> error if not requested\n         wait_until(transaction_requested, attempts=20*num_events, lock=mininode_lock)\n \n         # Get the mempool\n-        [ c.cb.send_mempool() for c in self.connections ]\n+        [ c.send_mempool() for c in self.p2p_connections ]\n \n         # Send ping and wait for response -- synchronization hack\n-        [ c.cb.send_ping(self.ping_counter) for c in self.connections ]\n+        [ c.send_ping(self.ping_counter) for c in self.p2p_connections ]\n         self.wait_for_pings(self.ping_counter)\n         self.ping_counter += 1\n \n         # Sort inv responses from each node\n         with mininode_lock:\n-            [ c.cb.lastInv.sort() for c in self.connections ]\n+            [ c.lastInv.sort() for c in self.p2p_connections ]\n \n     # Verify that the tip of each connection all agree with each other, and\n     # with the expected outcome (if given)\n     def check_results(self, blockhash, outcome):\n         with mininode_lock:\n-            for c in self.connections:\n+            for c in self.p2p_connections:\n                 if outcome is None:\n-                    if c.cb.bestblockhash != self.connections[0].cb.bestblockhash:\n+                    if c.bestblockhash != self.p2p_connections[0].bestblockhash:\n                         return False\n                 elif isinstance(outcome, RejectResult): # Check that block was rejected w/ code\n-                    if c.cb.bestblockhash == blockhash:\n+                    if c.bestblockhash == blockhash:\n                         return False\n-                    if blockhash not in c.cb.block_reject_map:\n+                    if blockhash not in c.block_reject_map:\n                         logger.error('Block not in reject map: %064x' % (blockhash))\n                         return False\n-                    if not outcome.match(c.cb.block_reject_map[blockhash]):\n-                        logger.error('Block rejected with %s instead of expected %s: %064x' % (c.cb.block_reject_map[blockhash], outcome, blockhash))\n+                    if not outcome.match(c.block_reject_map[blockhash]):\n+                        logger.error('Block rejected with %s instead of expected %s: %064x' % (c.block_reject_map[blockhash], outcome, blockhash))\n                         return False\n-                elif ((c.cb.bestblockhash == blockhash) != outcome):\n+                elif ((c.bestblockhash == blockhash) != outcome):\n                     return False\n             return True\n \n@@ -273,21 +264,21 @@ def check_results(self, blockhash, outcome):\n     # a particular tx's existence in the mempool is the same across all nodes.\n     def check_mempool(self, txhash, outcome):\n         with mininode_lock:\n-            for c in self.connections:\n+            for c in self.p2p_connections:\n                 if outcome is None:\n                     # Make sure the mempools agree with each other\n-                    if c.cb.lastInv != self.connections[0].cb.lastInv:\n+                    if c.lastInv != self.p2p_connections[0].lastInv:\n                         return False\n                 elif isinstance(outcome, RejectResult): # Check that tx was rejected w/ code\n-                    if txhash in c.cb.lastInv:\n+                    if txhash in c.lastInv:\n                         return False\n-                    if txhash not in c.cb.tx_reject_map:\n+                    if txhash not in c.tx_reject_map:\n                         logger.error('Tx not in reject map: %064x' % (txhash))\n                         return False\n-                    if not outcome.match(c.cb.tx_reject_map[txhash]):\n-                        logger.error('Tx rejected with %s instead of expected %s: %064x' % (c.cb.tx_reject_map[txhash], outcome, txhash))\n+                    if not outcome.match(c.tx_reject_map[txhash]):\n+                        logger.error('Tx rejected with %s instead of expected %s: %064x' % (c.tx_reject_map[txhash], outcome, txhash))\n                         return False\n-                elif ((txhash in c.cb.lastInv) != outcome):\n+                elif ((txhash in c.lastInv) != outcome):\n                     return False\n             return True\n \n@@ -332,25 +323,25 @@ def run(self):\n                         first_block_with_hash = False\n                     with mininode_lock:\n                         self.block_store.add_block(block)\n-                        for c in self.connections:\n-                            if first_block_with_hash and block.sha256 in c.cb.block_request_map and c.cb.block_request_map[block.sha256] == True:\n+                        for c in self.p2p_connections:\n+                            if first_block_with_hash and block.sha256 in c.block_request_map and c.block_request_map[block.sha256] == True:\n                                 # There was a previous request for this block hash\n                                 # Most likely, we delivered a header for this block\n                                 # but never had the block to respond to the getdata\n                                 c.send_message(msg_block(block))\n                             else:\n-                                c.cb.block_request_map[block.sha256] = False\n+                                c.block_request_map[block.sha256] = False\n                     # Either send inv's to each node and sync, or add\n                     # to invqueue for later inv'ing.\n                     if (test_instance.sync_every_block):\n                         # if we expect success, send inv and sync every block\n                         # if we expect failure, just push the block and see what happens.\n                         if outcome == True:\n-                            [ c.cb.send_inv(block) for c in self.connections ]\n+                            [ c.send_inv(block) for c in self.p2p_connections ]\n                             self.sync_blocks(block.sha256, 1)\n                         else:\n-                            [ c.send_message(msg_block(block)) for c in self.connections ]\n-                            [ c.cb.send_ping(self.ping_counter) for c in self.connections ]\n+                            [ c.send_message(msg_block(block)) for c in self.p2p_connections ]\n+                            [ c.send_ping(self.ping_counter) for c in self.p2p_connections ]\n                             self.wait_for_pings(self.ping_counter)\n                             self.ping_counter += 1\n                         if (not self.check_results(tip, outcome)):\n@@ -360,7 +351,7 @@ def run(self):\n                 elif isinstance(b_or_t, CBlockHeader):\n                     block_header = b_or_t\n                     self.block_store.add_header(block_header)\n-                    [ c.cb.send_header(block_header) for c in self.connections ]\n+                    [ c.send_header(block_header) for c in self.p2p_connections ]\n \n                 else:  # Tx test runner\n                     assert(isinstance(b_or_t, CTransaction))\n@@ -369,38 +360,38 @@ def run(self):\n                     # Add to shared tx store and clear map entry\n                     with mininode_lock:\n                         self.tx_store.add_transaction(tx)\n-                        for c in self.connections:\n-                            c.cb.tx_request_map[tx.sha256] = False\n+                        for c in self.p2p_connections:\n+                            c.tx_request_map[tx.sha256] = False\n                     # Again, either inv to all nodes or save for later\n                     if (test_instance.sync_every_tx):\n-                        [ c.cb.send_inv(tx) for c in self.connections ]\n+                        [ c.send_inv(tx) for c in self.p2p_connections ]\n                         self.sync_transaction(tx.sha256, 1)\n                         if (not self.check_mempool(tx.sha256, outcome)):\n                             raise AssertionError(\"Test failed at test %d\" % test_number)\n                     else:\n                         invqueue.append(CInv(1, tx.sha256))\n                 # Ensure we're not overflowing the inv queue\n                 if len(invqueue) == MAX_INV_SZ:\n-                    [ c.send_message(msg_inv(invqueue)) for c in self.connections ]\n+                    [ c.send_message(msg_inv(invqueue)) for c in self.p2p_connections ]\n                     invqueue = []\n \n             # Do final sync if we weren't syncing on every block or every tx.\n             if (not test_instance.sync_every_block and block is not None):\n                 if len(invqueue) > 0:\n-                    [ c.send_message(msg_inv(invqueue)) for c in self.connections ]\n+                    [ c.send_message(msg_inv(invqueue)) for c in self.p2p_connections ]\n                     invqueue = []\n                 self.sync_blocks(block.sha256, len(test_instance.blocks_and_transactions))\n                 if (not self.check_results(tip, block_outcome)):\n                     raise AssertionError(\"Block test failed at test %d\" % test_number)\n             if (not test_instance.sync_every_tx and tx is not None):\n                 if len(invqueue) > 0:\n-                    [ c.send_message(msg_inv(invqueue)) for c in self.connections ]\n+                    [ c.send_message(msg_inv(invqueue)) for c in self.p2p_connections ]\n                     invqueue = []\n                 self.sync_transaction(tx.sha256, len(test_instance.blocks_and_transactions))\n                 if (not self.check_mempool(tx.sha256, tx_outcome)):\n                     raise AssertionError(\"Mempool test failed at test %d\" % test_number)\n \n-        [ c.disconnect_node() for c in self.connections ]\n+        [ c.disconnect_node() for c in self.p2p_connections ]\n         self.wait_for_disconnections()\n         self.block_store.close()\n         self.tx_store.close()"
      },
      {
        "sha": "09a382c727a7a5c9e7c9b169feff601f3aeba4da",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 75,
        "deletions": 63,
        "changes": 138,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dad596fc37c8733ab806a0aa4224ac437d37aee5/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dad596fc37c8733ab806a0aa4224ac437d37aee5/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=dad596fc37c8733ab806a0aa4224ac437d37aee5",
        "patch": "@@ -23,6 +23,7 @@\n from threading import RLock, Thread\n \n from test_framework.messages import *\n+from test_framework.util import wait_until\n \n logger = logging.getLogger(\"TestFramework.mininode\")\n \n@@ -57,12 +58,24 @@\n }\n \n class NodeConn(asyncore.dispatcher):\n-    \"\"\"The actual NodeConn class\n+    \"\"\"A low-level connection object to a node's P2P interface.\n \n-    This class provides an interface for a p2p connection to a specified node.\"\"\"\n+    This class is responsible for:\n \n-    def __init__(self, dstaddr, dstport, callback, net=\"regtest\", services=NODE_NETWORK|NODE_WITNESS, send_version=True):\n-        asyncore.dispatcher.__init__(self, map=mininode_socket_map)\n+    - opening and closing the TCP connection to the node\n+    - reading bytes from and writing bytes to the socket\n+    - deserializing and serializing the P2P message header\n+    - logging messages as they are sent and received\n+\n+    This class contains no logic for handing the P2P message payloads. It must be\n+    sub-classed and the on_message() callback overridden.\n+\n+    TODO: rename this class P2PConnection.\"\"\"\n+\n+    def __init__(self):\n+        super().__init__(map=mininode_socket_map)\n+\n+    def peer_connect(self, dstaddr, dstport, net=\"regtest\", services=NODE_NETWORK|NODE_WITNESS, send_version=True):\n         self.dstaddr = dstaddr\n         self.dstport = dstport\n         self.create_socket(socket.AF_INET, socket.SOCK_STREAM)\n@@ -71,9 +84,7 @@ def __init__(self, dstaddr, dstport, callback, net=\"regtest\", services=NODE_NETW\n         self.recvbuf = b\"\"\n         self.state = \"connecting\"\n         self.network = net\n-        self.cb = callback\n         self.disconnect = False\n-        self.nServices = 0\n \n         if send_version:\n             # stuff version msg into sendbuf\n@@ -92,14 +103,19 @@ def __init__(self, dstaddr, dstport, callback, net=\"regtest\", services=NODE_NETW\n         except:\n             self.handle_close()\n \n+    def peer_disconnect(self):\n+        # Connection could have already been closed by other end.\n+        if self.state == \"connected\":\n+            self.disconnect_node()\n+\n     # Connection and disconnection methods\n \n     def handle_connect(self):\n         \"\"\"asyncore callback when a connection is opened.\"\"\"\n         if self.state != \"connected\":\n             logger.debug(\"Connected & Listening: %s:%d\" % (self.dstaddr, self.dstport))\n             self.state = \"connected\"\n-            self.cb.on_open(self)\n+            self.on_open()\n \n     def handle_close(self):\n         \"\"\"asyncore callback when a connection is closed.\"\"\"\n@@ -111,7 +127,7 @@ def handle_close(self):\n             self.close()\n         except:\n             pass\n-        self.cb.on_close(self)\n+        self.on_close()\n \n     def disconnect_node(self):\n         \"\"\"Disconnect the p2p connection.\n@@ -166,8 +182,8 @@ def _on_data(self):\n             raise\n \n     def on_message(self, message):\n-        \"\"\"Callback for processing a P2P payload. Calls into NodeConnCB.\"\"\"\n-        self.cb.on_message(self, message)\n+        \"\"\"Callback for processing a P2P payload. Must be overridden by derived class.\"\"\"\n+        raise NotImplementedError\n \n     # Socket write methods\n \n@@ -238,15 +254,19 @@ def _log_message(self, direction, msg):\n         logger.debug(log_message)\n \n \n-class NodeConnCB():\n-    \"\"\"Callback and helper functions for P2P connection to a bitcoind node.\n+class NodeConnCB(NodeConn):\n+    \"\"\"A high-level P2P interface class for communicating with a Bitcoin node.\n+\n+    This class provides high-level callbacks for processing P2P message\n+    payloads, as well as convenience methods for interacting with the\n+    node over P2P.\n \n     Individual testcases should subclass this and override the on_* methods\n-    if they want to alter message handling behaviour.\"\"\"\n+    if they want to alter message handling behaviour.\n+\n+    TODO: rename this class P2PInterface\"\"\"\n     def __init__(self):\n-        # Track whether we have a P2P connection open to the node\n-        self.connected = False\n-        self.connection = None\n+        super().__init__()\n \n         # Track number of messages of each type received and the most recent\n         # message of each type\n@@ -256,9 +276,12 @@ def __init__(self):\n         # A count of the number of ping messages we've sent to the node\n         self.ping_counter = 1\n \n+        # The network services received from the peer\n+        self.nServices = 0\n+\n     # Message receiving methods\n \n-    def on_message(self, conn, message):\n+    def on_message(self, message):\n         \"\"\"Receive message and dispatch message to appropriate callback.\n \n         We keep a count of how many of each message type has been received\n@@ -268,66 +291,61 @@ def on_message(self, conn, message):\n                 command = message.command.decode('ascii')\n                 self.message_count[command] += 1\n                 self.last_message[command] = message\n-                getattr(self, 'on_' + command)(conn, message)\n+                getattr(self, 'on_' + command)(message)\n             except:\n-                print(\"ERROR delivering %s (%s)\" % (repr(message),\n-                                                    sys.exc_info()[0]))\n+                print(\"ERROR delivering %s (%s)\" % (repr(message), sys.exc_info()[0]))\n                 raise\n \n     # Callback methods. Can be overridden by subclasses in individual test\n     # cases to provide custom message handling behaviour.\n \n-    def on_open(self, conn):\n-        self.connected = True\n-\n-    def on_close(self, conn):\n-        self.connected = False\n-        self.connection = None\n-\n-    def on_addr(self, conn, message): pass\n-    def on_block(self, conn, message): pass\n-    def on_blocktxn(self, conn, message): pass\n-    def on_cmpctblock(self, conn, message): pass\n-    def on_feefilter(self, conn, message): pass\n-    def on_getaddr(self, conn, message): pass\n-    def on_getblocks(self, conn, message): pass\n-    def on_getblocktxn(self, conn, message): pass\n-    def on_getdata(self, conn, message): pass\n-    def on_getheaders(self, conn, message): pass\n-    def on_headers(self, conn, message): pass\n-    def on_mempool(self, conn): pass\n-    def on_pong(self, conn, message): pass\n-    def on_reject(self, conn, message): pass\n-    def on_sendcmpct(self, conn, message): pass\n-    def on_sendheaders(self, conn, message): pass\n-    def on_tx(self, conn, message): pass\n-\n-    def on_inv(self, conn, message):\n+    def on_open(self):\n+        pass\n+\n+    def on_close(self):\n+        pass\n+\n+    def on_addr(self, message): pass\n+    def on_block(self, message): pass\n+    def on_blocktxn(self, message): pass\n+    def on_cmpctblock(self, message): pass\n+    def on_feefilter(self, message): pass\n+    def on_getaddr(self, message): pass\n+    def on_getblocks(self, message): pass\n+    def on_getblocktxn(self, message): pass\n+    def on_getdata(self, message): pass\n+    def on_getheaders(self, message): pass\n+    def on_headers(self, message): pass\n+    def on_mempool(self, message): pass\n+    def on_pong(self, message): pass\n+    def on_reject(self, message): pass\n+    def on_sendcmpct(self, message): pass\n+    def on_sendheaders(self, message): pass\n+    def on_tx(self, message): pass\n+\n+    def on_inv(self, message):\n         want = msg_getdata()\n         for i in message.inv:\n             if i.type != 0:\n                 want.inv.append(i)\n         if len(want.inv):\n-            conn.send_message(want)\n+            self.send_message(want)\n \n-    def on_ping(self, conn, message):\n-        conn.send_message(msg_pong(message.nonce))\n+    def on_ping(self, message):\n+        self.send_message(msg_pong(message.nonce))\n \n-    def on_verack(self, conn, message):\n+    def on_verack(self, message):\n         self.verack_received = True\n \n-    def on_version(self, conn, message):\n+    def on_version(self, message):\n         assert message.nVersion >= MIN_VERSION_SUPPORTED, \"Version {} received. Test framework only supports versions greater than {}\".format(message.nVersion, MIN_VERSION_SUPPORTED)\n-        conn.send_message(msg_verack())\n-        conn.nServices = message.nServices\n+        self.send_message(msg_verack())\n+        self.nServices = message.nServices\n \n     # Connection helper methods\n \n-    def add_connection(self, conn):\n-        self.connection = conn\n-\n     def wait_for_disconnect(self, timeout=60):\n-        test_function = lambda: not self.connected\n+        test_function = lambda: self.state != \"connected\"\n         wait_until(test_function, timeout=timeout, lock=mininode_lock)\n \n     # Message receiving helper methods\n@@ -359,12 +377,6 @@ def wait_for_verack(self, timeout=60):\n \n     # Message sending helper functions\n \n-    def send_message(self, message):\n-        if self.connection:\n-            self.connection.send_message(message)\n-        else:\n-            logger.error(\"Cannot send message. No connection to node!\")\n-\n     def send_and_ping(self, message):\n         self.send_message(message)\n         self.sync_with_ping()"
      },
      {
        "sha": "a9248c764e3d440f7cab4cf7269cc17ea4dd66d5",
        "filename": "test/functional/test_framework/test_node.py",
        "status": "modified",
        "additions": 5,
        "deletions": 8,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dad596fc37c8733ab806a0aa4224ac437d37aee5/test/functional/test_framework/test_node.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dad596fc37c8733ab806a0aa4224ac437d37aee5/test/functional/test_framework/test_node.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_node.py?ref=dad596fc37c8733ab806a0aa4224ac437d37aee5",
        "patch": "@@ -14,7 +14,6 @@\n import time\n \n from .authproxy import JSONRPCException\n-from .mininode import NodeConn\n from .util import (\n     assert_equal,\n     get_rpc_proxy,\n@@ -158,7 +157,7 @@ def node_encrypt_wallet(self, passphrase):\n         self.encryptwallet(passphrase)\n         self.wait_until_stopped()\n \n-    def add_p2p_connection(self, p2p_conn, **kwargs):\n+    def add_p2p_connection(self, p2p_conn, *args, **kwargs):\n         \"\"\"Add a p2p connection to the node.\n \n         This method adds the p2p connection to the self.p2ps list and also\n@@ -167,9 +166,9 @@ def add_p2p_connection(self, p2p_conn, **kwargs):\n             kwargs['dstport'] = p2p_port(self.index)\n         if 'dstaddr' not in kwargs:\n             kwargs['dstaddr'] = '127.0.0.1'\n+\n+        p2p_conn.peer_connect(*args, **kwargs)\n         self.p2ps.append(p2p_conn)\n-        kwargs.update({'callback': p2p_conn})\n-        p2p_conn.add_connection(NodeConn(**kwargs))\n \n         return p2p_conn\n \n@@ -185,10 +184,8 @@ def p2p(self):\n     def disconnect_p2ps(self):\n         \"\"\"Close all p2p connections to the node.\"\"\"\n         for p in self.p2ps:\n-            # Connection could have already been closed by other end.\n-            if p.connection is not None:\n-                p.connection.disconnect_node()\n-        self.p2ps = []\n+            p.peer_disconnect()\n+        del self.p2ps[:]\n \n \n class TestNodeCLI():"
      }
    ]
  },
  {
    "sha": "e9dfa9bccc5cbb6096c60498651b451297f0a931",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplOWRmYTliY2NjNWNiYjYwOTZjNjA0OTg2NTFiNDUxMjk3ZjBhOTMx",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-10-17T19:56:12Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-28T17:47:02Z"
      },
      "message": "[tests] Move version message sending from NodeConn to NodeConnCB\n\nThis commit moves the logic that sends a version message\non connection from NodeConn to NodeConnCB. NodeConn should\nnot be aware of the semantics or meaning of the P2P payloads.",
      "tree": {
        "sha": "d5579409c9cef4ca156693b5f4eb2b71684b8780",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d5579409c9cef4ca156693b5f4eb2b71684b8780"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e9dfa9bccc5cbb6096c60498651b451297f0a931",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e9dfa9bccc5cbb6096c60498651b451297f0a931",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e9dfa9bccc5cbb6096c60498651b451297f0a931",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e9dfa9bccc5cbb6096c60498651b451297f0a931/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "dad596fc37c8733ab806a0aa4224ac437d37aee5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dad596fc37c8733ab806a0aa4224ac437d37aee5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/dad596fc37c8733ab806a0aa4224ac437d37aee5"
      }
    ],
    "stats": {
      "total": 25,
      "additions": 14,
      "deletions": 11
    },
    "files": [
      {
        "sha": "c580d99c79e2017eedb822f9df20a54b4cde4357",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 14,
        "deletions": 11,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e9dfa9bccc5cbb6096c60498651b451297f0a931/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e9dfa9bccc5cbb6096c60498651b451297f0a931/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=e9dfa9bccc5cbb6096c60498651b451297f0a931",
        "patch": "@@ -75,7 +75,7 @@ class NodeConn(asyncore.dispatcher):\n     def __init__(self):\n         super().__init__(map=mininode_socket_map)\n \n-    def peer_connect(self, dstaddr, dstport, net=\"regtest\", services=NODE_NETWORK|NODE_WITNESS, send_version=True):\n+    def peer_connect(self, dstaddr, dstport, net=\"regtest\"):\n         self.dstaddr = dstaddr\n         self.dstport = dstport\n         self.create_socket(socket.AF_INET, socket.SOCK_STREAM)\n@@ -86,16 +86,6 @@ def peer_connect(self, dstaddr, dstport, net=\"regtest\", services=NODE_NETWORK|NO\n         self.network = net\n         self.disconnect = False\n \n-        if send_version:\n-            # stuff version msg into sendbuf\n-            vt = msg_version()\n-            vt.nServices = services\n-            vt.addrTo.ip = self.dstaddr\n-            vt.addrTo.port = self.dstport\n-            vt.addrFrom.ip = \"0.0.0.0\"\n-            vt.addrFrom.port = 0\n-            self.send_message(vt, True)\n-\n         logger.info('Connecting to Bitcoin Node: %s:%d' % (self.dstaddr, self.dstport))\n \n         try:\n@@ -279,6 +269,19 @@ def __init__(self):\n         # The network services received from the peer\n         self.nServices = 0\n \n+    def peer_connect(self, *args, services=NODE_NETWORK|NODE_WITNESS, send_version=True, **kwargs):\n+        super().peer_connect(*args, **kwargs)\n+\n+        if send_version:\n+            # Send a version msg\n+            vt = msg_version()\n+            vt.nServices = services\n+            vt.addrTo.ip = self.dstaddr\n+            vt.addrTo.port = self.dstport\n+            vt.addrFrom.ip = \"0.0.0.0\"\n+            vt.addrFrom.port = 0\n+            self.send_message(vt, True)\n+\n     # Message receiving methods\n \n     def on_message(self, message):"
      }
    ]
  }
]