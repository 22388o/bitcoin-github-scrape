[
  {
    "sha": "9bbe71b641e2fc985daf127988a14a67c99da50a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5YmJlNzFiNjQxZTJmYzk4NWRhZjEyNzk4OGExNGE2N2M5OWRhNTBh",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-12-07T14:31:32Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-12-10T11:14:06Z"
      },
      "message": "net: Add and document network messages in protocol.h\n\n- Avoids string typos (by making the compiler check)\n- Makes it easier to grep for handling/generation of a certain message type\n- Refer directly to documentation by following the symbol in IDE\n- Move list of valid message types to protocol.cpp:\n    protocol.cpp is a more appropriate place for this, and having\n    the array there makes it easier to keep things consistent.",
      "tree": {
        "sha": "6d13cf5ecbceb44ec633ad07b435799c6c73e4f5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6d13cf5ecbceb44ec633ad07b435799c6c73e4f5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9bbe71b641e2fc985daf127988a14a67c99da50a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9bbe71b641e2fc985daf127988a14a67c99da50a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9bbe71b641e2fc985daf127988a14a67c99da50a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9bbe71b641e2fc985daf127988a14a67c99da50a/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5dc63ed1ca8aca62f28881ba9ef996d4036a23ea",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5dc63ed1ca8aca62f28881ba9ef996d4036a23ea",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5dc63ed1ca8aca62f28881ba9ef996d4036a23ea"
      }
    ],
    "stats": {
      "total": 356,
      "additions": 283,
      "deletions": 73
    },
    "files": [
      {
        "sha": "b705069407e54e7162b5bd4cc01bd7d6ef923ba0",
        "filename": "src/alert.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9bbe71b641e2fc985daf127988a14a67c99da50a/src/alert.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9bbe71b641e2fc985daf127988a14a67c99da50a/src/alert.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/alert.cpp?ref=9bbe71b641e2fc985daf127988a14a67c99da50a",
        "patch": "@@ -138,7 +138,7 @@ bool CAlert::RelayTo(CNode* pnode) const\n             AppliesToMe() ||\n             GetAdjustedTime() < nRelayUntil)\n         {\n-            pnode->PushMessage(\"alert\", *this);\n+            pnode->PushMessage(NetMsgType::ALERT, *this);\n             return true;\n         }\n     }"
      },
      {
        "sha": "d2e736d421d72aae965beb268aac88e44865c0e9",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 57,
        "deletions": 57,
        "changes": 114,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9bbe71b641e2fc985daf127988a14a67c99da50a/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9bbe71b641e2fc985daf127988a14a67c99da50a/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=9bbe71b641e2fc985daf127988a14a67c99da50a",
        "patch": "@@ -4171,14 +4171,14 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                     if (!ReadBlockFromDisk(block, (*mi).second, consensusParams))\n                         assert(!\"cannot load block from disk\");\n                     if (inv.type == MSG_BLOCK)\n-                        pfrom->PushMessage(\"block\", block);\n+                        pfrom->PushMessage(NetMsgType::BLOCK, block);\n                     else // MSG_FILTERED_BLOCK)\n                     {\n                         LOCK(pfrom->cs_filter);\n                         if (pfrom->pfilter)\n                         {\n                             CMerkleBlock merkleBlock(block, *pfrom->pfilter);\n-                            pfrom->PushMessage(\"merkleblock\", merkleBlock);\n+                            pfrom->PushMessage(NetMsgType::MERKLEBLOCK, merkleBlock);\n                             // CMerkleBlock just contains hashes, so also push any transactions in the block the client did not see\n                             // This avoids hurting performance by pointlessly requiring a round-trip\n                             // Note that there is currently no way for a node to request any single transactions we didn't send here -\n@@ -4187,7 +4187,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                             // however we MUST always provide at least what the remote peer needs\n                             typedef std::pair<unsigned int, uint256> PairType;\n                             BOOST_FOREACH(PairType& pair, merkleBlock.vMatchedTxn)\n-                                pfrom->PushMessage(\"tx\", block.vtx[pair.first]);\n+                                pfrom->PushMessage(NetMsgType::TX, block.vtx[pair.first]);\n                         }\n                         // else\n                             // no response\n@@ -4201,7 +4201,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                         // wait for other stuff first.\n                         vector<CInv> vInv;\n                         vInv.push_back(CInv(MSG_BLOCK, chainActive.Tip()->GetBlockHash()));\n-                        pfrom->PushMessage(\"inv\", vInv);\n+                        pfrom->PushMessage(NetMsgType::INV, vInv);\n                         pfrom->hashContinue.SetNull();\n                     }\n                 }\n@@ -4224,7 +4224,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                         CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n                         ss.reserve(1000);\n                         ss << tx;\n-                        pfrom->PushMessage(\"tx\", ss);\n+                        pfrom->PushMessage(NetMsgType::TX, ss);\n                         pushed = true;\n                     }\n                 }\n@@ -4251,7 +4251,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n         // do that because they want to know about (and store and rebroadcast and\n         // risk analyze) the dependencies of transactions relevant to them, without\n         // having to download the entire memory pool.\n-        pfrom->PushMessage(\"notfound\", vNotFound);\n+        pfrom->PushMessage(NetMsgType::NOTFOUND, vNotFound);\n     }\n }\n \n@@ -4268,9 +4268,9 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n \n     if (!(nLocalServices & NODE_BLOOM) &&\n-              (strCommand == \"filterload\" ||\n-               strCommand == \"filteradd\" ||\n-               strCommand == \"filterclear\"))\n+              (strCommand == NetMsgType::FILTERLOAD ||\n+               strCommand == NetMsgType::FILTERADD ||\n+               strCommand == NetMsgType::FILTERCLEAR))\n     {\n         if (pfrom->nVersion >= NO_BLOOM_VERSION) {\n             Misbehaving(pfrom->GetId(), 100);\n@@ -4282,12 +4282,12 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n-    if (strCommand == \"version\")\n+    if (strCommand == NetMsgType::VERSION)\n     {\n         // Each connection can only send one version message\n         if (pfrom->nVersion != 0)\n         {\n-            pfrom->PushMessage(\"reject\", strCommand, REJECT_DUPLICATE, string(\"Duplicate version message\"));\n+            pfrom->PushMessage(NetMsgType::REJECT, strCommand, REJECT_DUPLICATE, string(\"Duplicate version message\"));\n             Misbehaving(pfrom->GetId(), 1);\n             return false;\n         }\n@@ -4301,7 +4301,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         {\n             // disconnect from peers older than this proto version\n             LogPrintf(\"peer=%d using obsolete version %i; disconnecting\\n\", pfrom->id, pfrom->nVersion);\n-            pfrom->PushMessage(\"reject\", strCommand, REJECT_OBSOLETE,\n+            pfrom->PushMessage(NetMsgType::REJECT, strCommand, REJECT_OBSOLETE,\n                                strprintf(\"Version must be %d or greater\", MIN_PEER_PROTO_VERSION));\n             pfrom->fDisconnect = true;\n             return false;\n@@ -4346,7 +4346,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         UpdatePreferredDownload(pfrom, State(pfrom->GetId()));\n \n         // Change version\n-        pfrom->PushMessage(\"verack\");\n+        pfrom->PushMessage(NetMsgType::VERACK);\n         pfrom->ssSend.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n \n         if (!pfrom->fInbound)\n@@ -4369,7 +4369,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             // Get recent addresses\n             if (pfrom->fOneShot || pfrom->nVersion >= CADDR_TIME_VERSION || addrman.size() < 1000)\n             {\n-                pfrom->PushMessage(\"getaddr\");\n+                pfrom->PushMessage(NetMsgType::GETADDR);\n                 pfrom->fGetAddr = true;\n             }\n             addrman.Good(pfrom->addr);\n@@ -4413,7 +4413,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n-    else if (strCommand == \"verack\")\n+    else if (strCommand == NetMsgType::VERACK)\n     {\n         pfrom->SetRecvVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n \n@@ -4428,12 +4428,12 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             // We send this to non-NODE NETWORK peers as well, because even\n             // non-NODE NETWORK peers can announce blocks (such as pruning\n             // nodes)\n-            pfrom->PushMessage(\"sendheaders\");\n+            pfrom->PushMessage(NetMsgType::SENDHEADERS);\n         }\n     }\n \n \n-    else if (strCommand == \"addr\")\n+    else if (strCommand == NetMsgType::ADDR)\n     {\n         vector<CAddress> vAddr;\n         vRecv >> vAddr;\n@@ -4499,14 +4499,14 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             pfrom->fDisconnect = true;\n     }\n \n-    else if (strCommand == \"sendheaders\")\n+    else if (strCommand == NetMsgType::SENDHEADERS)\n     {\n         LOCK(cs_main);\n         State(pfrom->GetId())->fPreferHeaders = true;\n     }\n \n \n-    else if (strCommand == \"inv\")\n+    else if (strCommand == NetMsgType::INV)\n     {\n         vector<CInv> vInv;\n         vRecv >> vInv;\n@@ -4547,7 +4547,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                     // time the block arrives, the header chain leading up to it is already validated. Not\n                     // doing this will result in the received block being rejected as an orphan in case it is\n                     // not a direct successor.\n-                    pfrom->PushMessage(\"getheaders\", chainActive.GetLocator(pindexBestHeader), inv.hash);\n+                    pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), inv.hash);\n                     CNodeState *nodestate = State(pfrom->GetId());\n                     if (CanDirectFetch(chainparams.GetConsensus()) &&\n                         nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n@@ -4577,11 +4577,11 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         }\n \n         if (!vToFetch.empty())\n-            pfrom->PushMessage(\"getdata\", vToFetch);\n+            pfrom->PushMessage(NetMsgType::GETDATA, vToFetch);\n     }\n \n \n-    else if (strCommand == \"getdata\")\n+    else if (strCommand == NetMsgType::GETDATA)\n     {\n         vector<CInv> vInv;\n         vRecv >> vInv;\n@@ -4602,7 +4602,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n-    else if (strCommand == \"getblocks\")\n+    else if (strCommand == NetMsgType::GETBLOCKS)\n     {\n         CBlockLocator locator;\n         uint256 hashStop;\n@@ -4646,7 +4646,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n-    else if (strCommand == \"getheaders\")\n+    else if (strCommand == NetMsgType::GETHEADERS)\n     {\n         CBlockLocator locator;\n         uint256 hashStop;\n@@ -4691,11 +4691,11 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         // headers message). In both cases it's safe to update\n         // pindexBestHeaderSent to be our tip.\n         nodestate->pindexBestHeaderSent = pindex ? pindex : chainActive.Tip();\n-        pfrom->PushMessage(\"headers\", vHeaders);\n+        pfrom->PushMessage(NetMsgType::HEADERS, vHeaders);\n     }\n \n \n-    else if (strCommand == \"tx\")\n+    else if (strCommand == NetMsgType::TX)\n     {\n         // Stop processing the transaction early if\n         // We are in blocks only mode and peer is either not whitelisted or whitelistalwaysrelay is off\n@@ -4824,7 +4824,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                 pfrom->id,\n                 FormatStateMessage(state));\n             if (state.GetRejectCode() < REJECT_INTERNAL) // Never send AcceptToMemoryPool's internal codes over P2P\n-                pfrom->PushMessage(\"reject\", strCommand, (unsigned char)state.GetRejectCode(),\n+                pfrom->PushMessage(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n                                    state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), inv.hash);\n             if (nDoS > 0)\n                 Misbehaving(pfrom->GetId(), nDoS);\n@@ -4833,7 +4833,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n-    else if (strCommand == \"headers\" && !fImporting && !fReindex) // Ignore headers received while importing\n+    else if (strCommand == NetMsgType::HEADERS && !fImporting && !fReindex) // Ignore headers received while importing\n     {\n         std::vector<CBlockHeader> headers;\n \n@@ -4881,7 +4881,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             // TODO: optimize: if pindexLast is an ancestor of chainActive.Tip or pindexBestHeader, continue\n             // from there instead.\n             LogPrint(\"net\", \"more getheaders (%d) to end to peer=%d (startheight:%d)\\n\", pindexLast->nHeight, pfrom->id, pfrom->nStartingHeight);\n-            pfrom->PushMessage(\"getheaders\", chainActive.GetLocator(pindexLast), uint256());\n+            pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexLast), uint256());\n         }\n \n         bool fCanDirectFetch = CanDirectFetch(chainparams.GetConsensus());\n@@ -4926,15 +4926,15 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                             pindexLast->GetBlockHash().ToString(), pindexLast->nHeight);\n                 }\n                 if (vGetData.size() > 0) {\n-                    pfrom->PushMessage(\"getdata\", vGetData);\n+                    pfrom->PushMessage(NetMsgType::GETDATA, vGetData);\n                 }\n             }\n         }\n \n         CheckBlockIndex(chainparams.GetConsensus());\n     }\n \n-    else if (strCommand == \"block\" && !fImporting && !fReindex) // Ignore blocks received while importing\n+    else if (strCommand == NetMsgType::BLOCK && !fImporting && !fReindex) // Ignore blocks received while importing\n     {\n         CBlock block;\n         vRecv >> block;\n@@ -4954,7 +4954,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         int nDoS;\n         if (state.IsInvalid(nDoS)) {\n             assert (state.GetRejectCode() < REJECT_INTERNAL); // Blocks are never rejected with internal reject codes\n-            pfrom->PushMessage(\"reject\", strCommand, (unsigned char)state.GetRejectCode(),\n+            pfrom->PushMessage(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n                                state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), inv.hash);\n             if (nDoS > 0) {\n                 LOCK(cs_main);\n@@ -4970,7 +4970,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     // to users' AddrMan and later request them by sending getaddr messages.\n     // Making nodes which are behind NAT and can only make outgoing connections ignore\n     // the getaddr message mitigates the attack.\n-    else if ((strCommand == \"getaddr\") && (pfrom->fInbound))\n+    else if ((strCommand == NetMsgType::GETADDR) && (pfrom->fInbound))\n     {\n         pfrom->vAddrToSend.clear();\n         vector<CAddress> vAddr = addrman.GetAddr();\n@@ -4979,7 +4979,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n-    else if (strCommand == \"mempool\")\n+    else if (strCommand == NetMsgType::MEMPOOL)\n     {\n         if (CNode::OutboundTargetReached(false) && !pfrom->fWhitelisted)\n         {\n@@ -5002,16 +5002,16 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             }\n             vInv.push_back(inv);\n             if (vInv.size() == MAX_INV_SZ) {\n-                pfrom->PushMessage(\"inv\", vInv);\n+                pfrom->PushMessage(NetMsgType::INV, vInv);\n                 vInv.clear();\n             }\n         }\n         if (vInv.size() > 0)\n-            pfrom->PushMessage(\"inv\", vInv);\n+            pfrom->PushMessage(NetMsgType::INV, vInv);\n     }\n \n \n-    else if (strCommand == \"ping\")\n+    else if (strCommand == NetMsgType::PING)\n     {\n         if (pfrom->nVersion > BIP0031_VERSION)\n         {\n@@ -5028,12 +5028,12 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             // it, if the remote node sends a ping once per second and this node takes 5\n             // seconds to respond to each, the 5th ping the remote sends would appear to\n             // return very quickly.\n-            pfrom->PushMessage(\"pong\", nonce);\n+            pfrom->PushMessage(NetMsgType::PONG, nonce);\n         }\n     }\n \n \n-    else if (strCommand == \"pong\")\n+    else if (strCommand == NetMsgType::PONG)\n     {\n         int64_t pingUsecEnd = nTimeReceived;\n         uint64_t nonce = 0;\n@@ -5090,7 +5090,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n-    else if (fAlerts && strCommand == \"alert\")\n+    else if (fAlerts && strCommand == NetMsgType::ALERT)\n     {\n         CAlert alert;\n         vRecv >> alert;\n@@ -5121,7 +5121,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n-    else if (strCommand == \"filterload\")\n+    else if (strCommand == NetMsgType::FILTERLOAD)\n     {\n         CBloomFilter filter;\n         vRecv >> filter;\n@@ -5140,7 +5140,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n-    else if (strCommand == \"filteradd\")\n+    else if (strCommand == NetMsgType::FILTERADD)\n     {\n         vector<unsigned char> vData;\n         vRecv >> vData;\n@@ -5160,7 +5160,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n-    else if (strCommand == \"filterclear\")\n+    else if (strCommand == NetMsgType::FILTERCLEAR)\n     {\n         LOCK(pfrom->cs_filter);\n         delete pfrom->pfilter;\n@@ -5169,7 +5169,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n-    else if (strCommand == \"reject\")\n+    else if (strCommand == NetMsgType::REJECT)\n     {\n         if (fDebug) {\n             try {\n@@ -5179,7 +5179,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                 ostringstream ss;\n                 ss << strMsg << \" code \" << itostr(ccode) << \": \" << strReason;\n \n-                if (strMsg == \"block\" || strMsg == \"tx\")\n+                if (strMsg == NetMsgType::BLOCK || strMsg == NetMsgType::TX)\n                 {\n                     uint256 hash;\n                     vRecv >> hash;\n@@ -5287,7 +5287,7 @@ bool ProcessMessages(CNode* pfrom)\n         }\n         catch (const std::ios_base::failure& e)\n         {\n-            pfrom->PushMessage(\"reject\", strCommand, REJECT_MALFORMED, string(\"error parsing message\"));\n+            pfrom->PushMessage(NetMsgType::REJECT, strCommand, REJECT_MALFORMED, string(\"error parsing message\"));\n             if (strstr(e.what(), \"end of data\"))\n             {\n                 // Allow exceptions from under-length message on vRecv\n@@ -5355,11 +5355,11 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n             pto->nPingUsecStart = GetTimeMicros();\n             if (pto->nVersion > BIP0031_VERSION) {\n                 pto->nPingNonceSent = nonce;\n-                pto->PushMessage(\"ping\", nonce);\n+                pto->PushMessage(NetMsgType::PING, nonce);\n             } else {\n                 // Peer is too old to support ping command with nonce, pong will never arrive.\n                 pto->nPingNonceSent = 0;\n-                pto->PushMessage(\"ping\");\n+                pto->PushMessage(NetMsgType::PING);\n             }\n         }\n \n@@ -5401,14 +5401,14 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n                     // receiver rejects addr messages larger than 1000\n                     if (vAddr.size() >= 1000)\n                     {\n-                        pto->PushMessage(\"addr\", vAddr);\n+                        pto->PushMessage(NetMsgType::ADDR, vAddr);\n                         vAddr.clear();\n                     }\n                 }\n             }\n             pto->vAddrToSend.clear();\n             if (!vAddr.empty())\n-                pto->PushMessage(\"addr\", vAddr);\n+                pto->PushMessage(NetMsgType::ADDR, vAddr);\n         }\n \n         CNodeState &state = *State(pto->GetId());\n@@ -5428,7 +5428,7 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n         }\n \n         BOOST_FOREACH(const CBlockReject& reject, state.rejects)\n-            pto->PushMessage(\"reject\", (string)\"block\", reject.chRejectCode, reject.strRejectReason, reject.hashBlock);\n+            pto->PushMessage(NetMsgType::REJECT, (string)NetMsgType::BLOCK, reject.chRejectCode, reject.strRejectReason, reject.hashBlock);\n         state.rejects.clear();\n \n         // Start block sync\n@@ -5451,7 +5451,7 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n                 if (pindexStart->pprev)\n                     pindexStart = pindexStart->pprev;\n                 LogPrint(\"net\", \"initial getheaders (%d) to peer=%d (startheight:%d)\\n\", pindexStart->nHeight, pto->id, pto->nStartingHeight);\n-                pto->PushMessage(\"getheaders\", chainActive.GetLocator(pindexStart), uint256());\n+                pto->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexStart), uint256());\n             }\n         }\n \n@@ -5551,7 +5551,7 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n                     LogPrint(\"net\", \"%s: sending header %s to peer=%d\\n\", __func__,\n                             vHeaders.front().GetHash().ToString(), pto->id);\n                 }\n-                pto->PushMessage(\"headers\", vHeaders);\n+                pto->PushMessage(NetMsgType::HEADERS, vHeaders);\n                 state.pindexBestHeaderSent = pBestIndex;\n             }\n             pto->vBlockHashesToAnnounce.clear();\n@@ -5594,14 +5594,14 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n                 vInv.push_back(inv);\n                 if (vInv.size() >= 1000)\n                 {\n-                    pto->PushMessage(\"inv\", vInv);\n+                    pto->PushMessage(NetMsgType::INV, vInv);\n                     vInv.clear();\n                 }\n             }\n             pto->vInventoryToSend = vInvWait;\n         }\n         if (!vInv.empty())\n-            pto->PushMessage(\"inv\", vInv);\n+            pto->PushMessage(NetMsgType::INV, vInv);\n \n         // Detect whether we're stalling\n         int64_t nNow = GetTimeMicros();\n@@ -5670,7 +5670,7 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n                 vGetData.push_back(inv);\n                 if (vGetData.size() >= 1000)\n                 {\n-                    pto->PushMessage(\"getdata\", vGetData);\n+                    pto->PushMessage(NetMsgType::GETDATA, vGetData);\n                     vGetData.clear();\n                 }\n             } else {\n@@ -5680,7 +5680,7 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n             pto->mapAskFor.erase(pto->mapAskFor.begin());\n         }\n         if (!vGetData.empty())\n-            pto->PushMessage(\"getdata\", vGetData);\n+            pto->PushMessage(NetMsgType::GETDATA, vGetData);\n \n     }\n     return true;"
      },
      {
        "sha": "c5e7ece79d31c265a8de8fede0cefb20431b94ca",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 11,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9bbe71b641e2fc985daf127988a14a67c99da50a/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9bbe71b641e2fc985daf127988a14a67c99da50a/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=9bbe71b641e2fc985daf127988a14a67c99da50a",
        "patch": "@@ -67,14 +67,6 @@ namespace {\n     };\n }\n \n-//immutable thread safe array of allowed commands for logging inbound traffic\n-const static std::string logAllowIncomingMsgCmds[] = {\n-    \"version\", \"addr\", \"inv\", \"getdata\", \"merkleblock\",\n-    \"getblocks\", \"getheaders\", \"tx\", \"headers\", \"block\",\n-    \"getaddr\", \"mempool\", \"ping\", \"pong\", \"alert\", \"notfound\",\n-    \"filterload\", \"filteradd\", \"filterclear\", \"reject\",\n-    \"sendheaders\", \"verack\"};\n-\n const static std::string NET_MESSAGE_COMMAND_OTHER = \"*other*\";\n \n //\n@@ -469,7 +461,7 @@ void CNode::PushVersion()\n         LogPrint(\"net\", \"send version message: version %d, blocks=%d, us=%s, them=%s, peer=%d\\n\", PROTOCOL_VERSION, nBestHeight, addrMe.ToString(), addrYou.ToString(), id);\n     else\n         LogPrint(\"net\", \"send version message: version %d, blocks=%d, us=%s, peer=%d\\n\", PROTOCOL_VERSION, nBestHeight, addrMe.ToString(), id);\n-    PushMessage(\"version\", PROTOCOL_VERSION, nLocalServices, nTime, addrYou, addrMe,\n+    PushMessage(NetMsgType::VERSION, PROTOCOL_VERSION, nLocalServices, nTime, addrYou, addrMe,\n                 nLocalHostNonce, strSubVersion, nBestHeight, !GetBoolArg(\"-blocksonly\", DEFAULT_BLOCKSONLY));\n }\n \n@@ -2399,8 +2391,8 @@ CNode::CNode(SOCKET hSocketIn, const CAddress& addrIn, const std::string& addrNa\n     nPingUsecTime = 0;\n     fPingQueued = false;\n     nMinPingUsecTime = std::numeric_limits<int64_t>::max();\n-    for (unsigned int i = 0; i < sizeof(logAllowIncomingMsgCmds)/sizeof(logAllowIncomingMsgCmds[0]); i++)\n-        mapRecvBytesPerMsgCmd[logAllowIncomingMsgCmds[i]] = 0;\n+    BOOST_FOREACH(const std::string &msg, getAllNetMessageTypes())\n+        mapRecvBytesPerMsgCmd[msg] = 0;\n     mapRecvBytesPerMsgCmd[NET_MESSAGE_COMMAND_OTHER] = 0;\n \n     {"
      },
      {
        "sha": "5d3ae87de8bd8ea48a3ec49c4885e68d3f87d35f",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 63,
        "deletions": 4,
        "changes": 67,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9bbe71b641e2fc985daf127988a14a67c99da50a/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9bbe71b641e2fc985daf127988a14a67c99da50a/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=9bbe71b641e2fc985daf127988a14a67c99da50a",
        "patch": "@@ -12,13 +12,67 @@\n # include <arpa/inet.h>\n #endif\n \n+namespace NetMsgType {\n+const char *VERSION=\"version\";\n+const char *VERACK=\"verack\";\n+const char *ADDR=\"addr\";\n+const char *INV=\"inv\";\n+const char *GETDATA=\"getdata\";\n+const char *MERKLEBLOCK=\"merkleblock\";\n+const char *GETBLOCKS=\"getblocks\";\n+const char *GETHEADERS=\"getheaders\";\n+const char *TX=\"tx\";\n+const char *HEADERS=\"headers\";\n+const char *BLOCK=\"block\";\n+const char *GETADDR=\"getaddr\";\n+const char *MEMPOOL=\"mempool\";\n+const char *PING=\"ping\";\n+const char *PONG=\"pong\";\n+const char *ALERT=\"alert\";\n+const char *NOTFOUND=\"notfound\";\n+const char *FILTERLOAD=\"filterload\";\n+const char *FILTERADD=\"filteradd\";\n+const char *FILTERCLEAR=\"filterclear\";\n+const char *REJECT=\"reject\";\n+const char *SENDHEADERS=\"sendheaders\";\n+};\n+\n static const char* ppszTypeName[] =\n {\n-    \"ERROR\",\n-    \"tx\",\n-    \"block\",\n-    \"filtered block\"\n+    \"ERROR\", // Should never occur\n+    NetMsgType::TX,\n+    NetMsgType::BLOCK,\n+    \"filtered block\" // Should never occur\n+};\n+\n+/** All known message types. Keep this in the same order as the list of\n+ * messages above and in protocol.h.\n+ */\n+const static std::string allNetMessageTypes[] = {\n+    NetMsgType::VERSION,\n+    NetMsgType::VERACK,\n+    NetMsgType::ADDR,\n+    NetMsgType::INV,\n+    NetMsgType::GETDATA,\n+    NetMsgType::MERKLEBLOCK,\n+    NetMsgType::GETBLOCKS,\n+    NetMsgType::GETHEADERS,\n+    NetMsgType::TX,\n+    NetMsgType::HEADERS,\n+    NetMsgType::BLOCK,\n+    NetMsgType::GETADDR,\n+    NetMsgType::MEMPOOL,\n+    NetMsgType::PING,\n+    NetMsgType::PONG,\n+    NetMsgType::ALERT,\n+    NetMsgType::NOTFOUND,\n+    NetMsgType::FILTERLOAD,\n+    NetMsgType::FILTERADD,\n+    NetMsgType::FILTERCLEAR,\n+    NetMsgType::REJECT,\n+    NetMsgType::SENDHEADERS\n };\n+const static std::vector<std::string> allNetMessageTypesVec(allNetMessageTypes, allNetMessageTypes+ARRAYLEN(allNetMessageTypes));\n \n CMessageHeader::CMessageHeader(const MessageStartChars& pchMessageStartIn)\n {\n@@ -140,3 +194,8 @@ std::string CInv::ToString() const\n {\n     return strprintf(\"%s %s\", GetCommand(), hash.ToString());\n }\n+\n+const std::vector<std::string> &getAllNetMessageTypes()\n+{\n+    return allNetMessageTypesVec;\n+}"
      },
      {
        "sha": "b84c78baca41d251b866063e6528d7d57ece2db2",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 159,
        "deletions": 0,
        "changes": 159,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9bbe71b641e2fc985daf127988a14a67c99da50a/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9bbe71b641e2fc985daf127988a14a67c99da50a/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=9bbe71b641e2fc985daf127988a14a67c99da50a",
        "patch": "@@ -65,6 +65,165 @@ class CMessageHeader\n     unsigned int nChecksum;\n };\n \n+/**\n+ * Bitcoin protocol message types. When adding new message types, don't forget\n+ * to update allNetMessageTypes in protocol.cpp.\n+ */\n+namespace NetMsgType {\n+\n+/**\n+ * The version message provides information about the transmitting node to the\n+ * receiving node at the beginning of a connection.\n+ * @see https://bitcoin.org/en/developer-reference#version\n+ */\n+extern const char *VERSION;\n+/**\n+ * The verack message acknowledges a previously-received version message,\n+ * informing the connecting node that it can begin to send other messages.\n+ * @see https://bitcoin.org/en/developer-reference#verack\n+ */\n+extern const char *VERACK;\n+/**\n+ * The addr (IP address) message relays connection information for peers on the\n+ * network.\n+ * @see https://bitcoin.org/en/developer-reference#addr\n+ */\n+extern const char *ADDR;\n+/**\n+ * The inv message (inventory message) transmits one or more inventories of\n+ * objects known to the transmitting peer.\n+ * @see https://bitcoin.org/en/developer-reference#inv\n+ */\n+extern const char *INV;\n+/**\n+ * The getdata message requests one or more data objects from another node.\n+ * @see https://bitcoin.org/en/developer-reference#getdata\n+ */\n+extern const char *GETDATA;\n+/**\n+ * The merkleblock message is a reply to a getdata message which requested a\n+ * block using the inventory type MSG_MERKLEBLOCK.\n+ * @since protocol version 70001 as described by BIP37.\n+ * @see https://bitcoin.org/en/developer-reference#merkleblock\n+ */\n+extern const char *MERKLEBLOCK;\n+/**\n+ * The getblocks message requests an inv message that provides block header\n+ * hashes starting from a particular point in the block chain.\n+ * @see https://bitcoin.org/en/developer-reference#getblocks\n+ */\n+extern const char *GETBLOCKS;\n+/**\n+ * The getheaders message requests a headers message that provides block\n+ * headers starting from a particular point in the block chain.\n+ * @since protocol version 31800.\n+ * @see https://bitcoin.org/en/developer-reference#getheaders\n+ */\n+extern const char *GETHEADERS;\n+/**\n+ * The tx message transmits a single transaction.\n+ * @see https://bitcoin.org/en/developer-reference#tx\n+ */\n+extern const char *TX;\n+/**\n+ * The headers message sends one or more block headers to a node which\n+ * previously requested certain headers with a getheaders message.\n+ * @since protocol version 31800.\n+ * @see https://bitcoin.org/en/developer-reference#headers\n+ */\n+extern const char *HEADERS;\n+/**\n+ * The block message transmits a single serialized block.\n+ * @see https://bitcoin.org/en/developer-reference#block\n+ */\n+extern const char *BLOCK;\n+/**\n+ * The getaddr message requests an addr message from the receiving node,\n+ * preferably one with lots of IP addresses of other receiving nodes.\n+ * @see https://bitcoin.org/en/developer-reference#getaddr\n+ */\n+extern const char *GETADDR;\n+/**\n+ * The mempool message requests the TXIDs of transactions that the receiving\n+ * node has verified as valid but which have not yet appeared in a block.\n+ * @since protocol version 60002.\n+ * @see https://bitcoin.org/en/developer-reference#mempool\n+ */\n+extern const char *MEMPOOL;\n+/**\n+ * The ping message is sent periodically to help confirm that the receiving\n+ * peer is still connected.\n+ * @see https://bitcoin.org/en/developer-reference#ping\n+ */\n+extern const char *PING;\n+/**\n+ * The pong message replies to a ping message, proving to the pinging node that\n+ * the ponging node is still alive.\n+ * @since protocol version 60001 as described by BIP31.\n+ * @see https://bitcoin.org/en/developer-reference#pong\n+ */\n+extern const char *PONG;\n+/**\n+ * The alert message warns nodes of problems that may affect them or the rest\n+ * of the network.\n+ * @since protocol version 311.\n+ * @see https://bitcoin.org/en/developer-reference#alert\n+ */\n+extern const char *ALERT;\n+/**\n+ * The notfound message is a reply to a getdata message which requested an\n+ * object the receiving node does not have available for relay.\n+ * @ince protocol version 70001.\n+ * @see https://bitcoin.org/en/developer-reference#notfound\n+ */\n+extern const char *NOTFOUND;\n+/**\n+ * The filterload message tells the receiving peer to filter all relayed\n+ * transactions and requested merkle blocks through the provided filter.\n+ * @since protocol version 70001 as described by BIP37.\n+ *   Only available with service bit NODE_BLOOM since protocol version\n+ *   70011 as described by BIP111.\n+ * @see https://bitcoin.org/en/developer-reference#filterload\n+ */\n+extern const char *FILTERLOAD;\n+/**\n+ * The filteradd message tells the receiving peer to add a single element to a\n+ * previously-set bloom filter, such as a new public key.\n+ * @since protocol version 70001 as described by BIP37.\n+ *   Only available with service bit NODE_BLOOM since protocol version\n+ *   70011 as described by BIP111.\n+ * @see https://bitcoin.org/en/developer-reference#filteradd\n+ */\n+extern const char *FILTERADD;\n+/**\n+ * The filterclear message tells the receiving peer to remove a previously-set\n+ * bloom filter.\n+ * @since protocol version 70001 as described by BIP37.\n+ *   Only available with service bit NODE_BLOOM since protocol version\n+ *   70011 as described by BIP111.\n+ * @see https://bitcoin.org/en/developer-reference#filterclear\n+ */\n+extern const char *FILTERCLEAR;\n+/**\n+ * The reject message informs the receiving node that one of its previous\n+ * messages has been rejected.\n+ * @since protocol version 70002 as described by BIP61.\n+ * @see https://bitcoin.org/en/developer-reference#reject\n+ */\n+extern const char *REJECT;\n+/**\n+ * Indicates that a node prefers to receive new block announcements via a\n+ * \"headers\" message rather than an \"inv\".\n+ * @since protocol version 70012 as described by BIP130.\n+ * @see https://bitcoin.org/en/developer-reference#sendheaders\n+ */\n+extern const char *SENDHEADERS;\n+\n+};\n+\n+/* Get a vector of all valid message types (see above) */\n+const std::vector<std::string> &getAllNetMessageTypes();\n+\n /** nServices flags */\n enum {\n     // NODE_NETWORK means that the node is capable of serving the block chain. It is currently"
      }
    ]
  }
]