[
  {
    "sha": "095c2e7e781d41b694d581892deaa8cd01f29b0a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowOTVjMmU3ZTc4MWQ0MWI2OTRkNTgxODkyZGVhYThjZDAxZjI5YjBh",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2016-12-09T14:50:33Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2017-06-12T14:29:59Z"
      },
      "message": "Make CCoinsViewCache::Cursor() return latest data\n\nChange CCoinsViewCache::Cursor() method to return a cursor yielding the latest\nCCoins entries, instead of just previous entries prior to the last cache flush.\n\nThe CCoinsViewCache::Cursor method is not currently used. This change just\nenables new features that rely on scanning the UXTO set to work correctly (for\nexample https://github.com/bitcoin/bitcoin/pull/9152, which adds a\nsweepprivkeys RPC, and https://github.com/bitcoin/bitcoin/pull/9137, which\nimproves handling of imported keys for nodes with pruning enabled.)",
      "tree": {
        "sha": "870c0f4cd6ad78277d5546e5f16da10a90da94f5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/870c0f4cd6ad78277d5546e5f16da10a90da94f5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/095c2e7e781d41b694d581892deaa8cd01f29b0a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/095c2e7e781d41b694d581892deaa8cd01f29b0a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/095c2e7e781d41b694d581892deaa8cd01f29b0a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/095c2e7e781d41b694d581892deaa8cd01f29b0a/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b7296bcea0c942abefcb3243e3e558b95933c082",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b7296bcea0c942abefcb3243e3e558b95933c082",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b7296bcea0c942abefcb3243e3e558b95933c082"
      }
    ],
    "stats": {
      "total": 163,
      "additions": 160,
      "deletions": 3
    },
    "files": [
      {
        "sha": "f9c5cbd8f17ea4f531d3c6e35dd261b987d2682d",
        "filename": "src/coins.cpp",
        "status": "modified",
        "additions": 66,
        "deletions": 0,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/095c2e7e781d41b694d581892deaa8cd01f29b0a/src/coins.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/095c2e7e781d41b694d581892deaa8cd01f29b0a/src/coins.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.cpp?ref=095c2e7e781d41b694d581892deaa8cd01f29b0a",
        "patch": "@@ -34,6 +34,72 @@ size_t CCoinsViewCache::DynamicMemoryUsage() const {\n     return memusage::DynamicUsage(cacheCoins) + cachedCoinsUsage;\n }\n \n+CCoinsViewCacheCursor::CCoinsViewCacheCursor(const CCoinsViewCache& cache)\n+    : CCoinsViewCursor(cache.GetBestBlock()), cache(cache), base(cache.base->Cursor()),\n+      it(cache.cacheCoins.begin())\n+{\n+    AdvanceToNonPruned();\n+}\n+\n+void CCoinsViewCacheCursor::AdvanceToNonPruned()\n+{\n+    // Skip non-dirty cache entries and dirty but pruned entries.\n+    for (; it != cache.cacheCoins.end(); ++it)\n+        if (it->second.flags & CCoinsCacheEntry::DIRTY && !it->second.coin.IsSpent())\n+            return;\n+\n+    // Skip base entries overridden by dirty cache entries.\n+    COutPoint key;\n+    CCoinsMap::iterator match;\n+    for (; base->Valid(); base->Next())\n+        if (!base->GetKey(key) ||\n+            (match = cache.cacheCoins.find(key)) == cache.cacheCoins.end() ||\n+            !(match->second.flags & CCoinsCacheEntry::DIRTY))\n+            return;\n+}\n+\n+bool CCoinsViewCacheCursor::GetKey(COutPoint &key) const\n+{\n+    if (it != cache.cacheCoins.end()) {\n+        key = it->first;\n+        return true;\n+    }\n+    return base->GetKey(key);\n+}\n+\n+bool CCoinsViewCacheCursor::GetValue(Coin &coin) const\n+{\n+    if (it != cache.cacheCoins.end()) {\n+        coin = it->second.coin;\n+        return true;\n+    }\n+    return base->GetValue(coin);\n+}\n+\n+unsigned int CCoinsViewCacheCursor::GetValueSize() const\n+{\n+    return it != cache.cacheCoins.end() ? 0 : base->GetValueSize();\n+}\n+\n+bool CCoinsViewCacheCursor::Valid() const\n+{\n+    return it != cache.cacheCoins.end() || base->Valid();\n+}\n+\n+void CCoinsViewCacheCursor::Next()\n+{\n+    if (it != cache.cacheCoins.end())\n+        ++it;\n+    else\n+        base->Next();\n+    AdvanceToNonPruned();\n+}\n+\n+CCoinsViewCursor* CCoinsViewCache::Cursor() const\n+{\n+    return new CCoinsViewCacheCursor(*this);\n+}\n+\n CCoinsMap::iterator CCoinsViewCache::FetchCoin(const COutPoint &outpoint) const {\n     CCoinsMap::iterator it = cacheCoins.find(outpoint);\n     if (it != cacheCoins.end())"
      },
      {
        "sha": "9621355fb797fe5b3478804bcbf935df30a0af69",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 31,
        "deletions": 3,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/095c2e7e781d41b694d581892deaa8cd01f29b0a/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/095c2e7e781d41b694d581892deaa8cd01f29b0a/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=095c2e7e781d41b694d581892deaa8cd01f29b0a",
        "patch": "@@ -211,9 +211,7 @@ class CCoinsViewCache : public CCoinsViewBacked\n     uint256 GetBestBlock() const override;\n     void SetBestBlock(const uint256 &hashBlock);\n     bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) override;\n-    CCoinsViewCursor* Cursor() const override {\n-        throw std::logic_error(\"CCoinsViewCache cursor iteration not supported.\");\n-    }\n+    CCoinsViewCursor* Cursor() const override;\n \n     /**\n      * Check if we have the given utxo already loaded in this cache.\n@@ -274,13 +272,17 @@ class CCoinsViewCache : public CCoinsViewBacked\n     //! Check whether all prevouts of the transaction are present in the UTXO set represented by this view\n     bool HaveInputs(const CTransaction& tx) const;\n \n+    friend class CCoinsModifier;\n+\n private:\n     CCoinsMap::iterator FetchCoin(const COutPoint &outpoint) const;\n \n     /**\n      * By making the copy constructor private, we prevent accidentally using it when one intends to create a cache on top of a base cache.\n      */\n     CCoinsViewCache(const CCoinsViewCache &);\n+\n+    friend class CCoinsViewCacheCursor;\n };\n \n //! Utility function to add all of a transaction's outputs to a cache.\n@@ -292,4 +294,30 @@ void AddCoins(CCoinsViewCache& cache, const CTransaction& tx, int nHeight);\n //! Utility function to find any unspent output with a given txid.\n const Coin& AccessByTxid(const CCoinsViewCache& cache, const uint256& txid);\n \n+/**\n+ * Cursor view of cache. First returns dirty, non-pruned rows in cache, then\n+ * returns rows from the underlying base cursor.\n+ */\n+class CCoinsViewCacheCursor : public CCoinsViewCursor\n+{\n+public:\n+    CCoinsViewCacheCursor(const CCoinsViewCache& cache);\n+    void AdvanceToNonPruned();\n+    bool GetKey(COutPoint &key) const override;\n+    bool GetValue(Coin &coin) const override;\n+    unsigned int GetValueSize() const override;\n+    bool Valid() const override;\n+    void Next() override;\n+\n+private:\n+    const CCoinsViewCache& cache;\n+    std::unique_ptr<CCoinsViewCursor> base;\n+\n+    /**\n+     * Current cache entry during the initial scan of the cache, before\n+     * resorting to underlying base cursor.\n+     */\n+    CCoinsMap::iterator it;\n+};\n+\n #endif // BITCOIN_COINS_H"
      },
      {
        "sha": "9564d876608dff2ef0711b37328dc696678f917f",
        "filename": "src/test/coins_tests.cpp",
        "status": "modified",
        "additions": 63,
        "deletions": 0,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/095c2e7e781d41b694d581892deaa8cd01f29b0a/src/test/coins_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/095c2e7e781d41b694d581892deaa8cd01f29b0a/src/test/coins_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/coins_tests.cpp?ref=095c2e7e781d41b694d581892deaa8cd01f29b0a",
        "patch": "@@ -75,8 +75,53 @@ class CCoinsViewTest : public CCoinsView\n             hashBestBlock_ = hashBlock;\n         return true;\n     }\n+\n+    CCoinsViewCursor* Cursor() const override;\n+\n+    friend class CCoinsViewTestCursor;\n };\n \n+class CCoinsViewTestCursor : public CCoinsViewCursor\n+{\n+public:\n+    CCoinsViewTestCursor(const CCoinsViewTest& test) : CCoinsViewCursor(test.GetBestBlock()), test(test), it(test.map_.begin()) {}\n+\n+    bool GetKey(COutPoint &key) const override\n+    {\n+        if (it == test.map_.end())\n+            return false;\n+        key = it->first;\n+        return true;\n+    }\n+\n+    bool GetValue(Coin &coin) const override\n+    {\n+        if (it == test.map_.end())\n+            return false;\n+        coin = it->second;\n+        return true;\n+    }\n+\n+    unsigned int GetValueSize() const override { return 0; }\n+\n+    bool Valid() const override { return it != test.map_.end(); }\n+\n+    void Next() override\n+    {\n+        if (it != test.map_.end())\n+            ++it;\n+    }\n+\n+private:\n+    const CCoinsViewTest& test;\n+    std::map<COutPoint, Coin>::const_iterator it;\n+};\n+\n+CCoinsViewCursor* CCoinsViewTest::Cursor() const\n+{\n+    return new CCoinsViewTestCursor(*this);\n+}\n+\n class CCoinsViewCacheTest : public CCoinsViewCache\n {\n public:\n@@ -181,6 +226,16 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n \n         // Once every 1000 iterations and at the end, verify the full cache.\n         if (InsecureRandRange(1000) == 1 || i == NUM_SIMULATION_ITERATIONS - 1) {\n+            std::map<COutPoint, Coin> cursorResult;\n+            for (std::unique_ptr<CCoinsViewCursor> cursor(stack.back()->Cursor()); cursor->Valid(); cursor->Next()) {\n+                COutPoint key;\n+                BOOST_CHECK(cursor->GetKey(key));\n+                Coin value;\n+                BOOST_CHECK(cursor->GetValue(value));\n+                BOOST_CHECK(cursorResult.emplace(key, value).second);\n+            }\n+\n+            auto cursor = cursorResult.begin();\n             for (auto it = result.begin(); it != result.end(); it++) {\n                 bool have = stack.back()->HaveCoin(it->first);\n                 const Coin& coin = stack.back()->AccessCoin(it->first);\n@@ -192,7 +247,15 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n                     BOOST_CHECK(stack.back()->HaveCoinInCache(it->first));\n                     found_an_entry = true;\n                 }\n+\n+                if (cursor != cursorResult.end() && cursor->first == it->first) {\n+                  BOOST_CHECK(cursor->second == it->second);\n+                  ++cursor;\n+                } else {\n+                  BOOST_CHECK(it->second.IsSpent());\n+                }\n             }\n+            BOOST_CHECK(cursor == cursorResult.end());\n             BOOST_FOREACH(const CCoinsViewCacheTest *test, stack) {\n                 test->SelfTest();\n             }"
      }
    ]
  }
]