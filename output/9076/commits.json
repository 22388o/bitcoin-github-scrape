[
  {
    "sha": "96bdeffb78eecb7a82f7325272ed9374e8dcd782",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NmJkZWZmYjc4ZWVjYjdhODJmNzMyNTI3MmVkOTM3NGU4ZGNkNzgy",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2016-11-03T15:41:41Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2016-11-08T14:34:11Z"
      },
      "message": "[WIP][Experimental] Add Hybrid SPV mode",
      "tree": {
        "sha": "097fa419d92f5acd847864d0f68c0456e45aeacb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/097fa419d92f5acd847864d0f68c0456e45aeacb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/96bdeffb78eecb7a82f7325272ed9374e8dcd782",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "expired_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2\n\niQIcBAABCAAGBQJYIeJkAAoJECnUvLZBb1PsORwQALbt43GmCbd5R1ueLxDxKSTe\nU3/S1Ycuc3xMmKt+NDbg+tokYCcXFy/u7u78HnQaV9173c2Pl2+ciH8tq5OqvogH\nYmidNziDlijPh1DQ7ci86R/vnoHmi72yz1mxedklCscCaX0/mqe7gk/mSGE4IwIN\nl43Ixv0WtGAvtPFLVHV/gGotpKghXvQkXIhAGyyi75+afKLMbRfsdU+rR3Gv+Arm\ne/fWVvfa0KNCvtPwMh+85P+pCllwVskrc2Vtxr4tFDNv/YwbZoLvgs+dJq0R/njU\nK0HuZ7e+KATfhz2Oyg3AVvcu2jWxwy1Ybs/9LYn4QQa3EvZuapLWHvfbBqOCobON\nKnzUDeBs9Zzt0Klgsp7tSw9K0Ue7SDtVGJy4aDkSi+YG0XOTT8clFwr3gLsvXB5y\nI/4gUQj+5jnuZuWHPNOKdcyxgeR0xSQsF6r7GxaIvO60Yb0Om4Kiq6ySb9Q4Sa0i\nEG1G1oPR9o3T93SnR6qvoHBnn88G41eWA/97r49CvhDjtVmp3iTLO4Fvm+wMOYSD\nT3EZTy4vHNq3NccN4tw2HVsiJ9F5wwtx+NLBUDeb8mdoS/poL9zXbTmGSqkJjHO1\nOP7sFwOfHH04sSjeOiQPDNeYvXWKwUsjjQOOuqUyN6VOS0vRiMgg6TVm/GHENaYo\nk6K2p716xpB0nI267x7S\n=MhLM\n-----END PGP SIGNATURE-----",
        "payload": "tree 097fa419d92f5acd847864d0f68c0456e45aeacb\nparent 4e5782438c3d117be7e52ddd0d35ae0475a30759\nauthor Jonas Schnelli <dev@jonasschnelli.ch> 1478187701 +0100\ncommitter Jonas Schnelli <dev@jonasschnelli.ch> 1478615651 +0100\n\n[WIP][Experimental] Add Hybrid SPV mode\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/96bdeffb78eecb7a82f7325272ed9374e8dcd782",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/96bdeffb78eecb7a82f7325272ed9374e8dcd782",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/96bdeffb78eecb7a82f7325272ed9374e8dcd782/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4e5782438c3d117be7e52ddd0d35ae0475a30759",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4e5782438c3d117be7e52ddd0d35ae0475a30759",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4e5782438c3d117be7e52ddd0d35ae0475a30759"
      }
    ],
    "stats": {
      "total": 862,
      "additions": 761,
      "deletions": 101
    },
    "files": [
      {
        "sha": "b85b42b0b7cce602b78cf526ac0bb03792c2f7f6",
        "filename": "qa/pull-tester/rpc-tests.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96bdeffb78eecb7a82f7325272ed9374e8dcd782/qa/pull-tester/rpc-tests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96bdeffb78eecb7a82f7325272ed9374e8dcd782/qa/pull-tester/rpc-tests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/rpc-tests.py?ref=96bdeffb78eecb7a82f7325272ed9374e8dcd782",
        "patch": "@@ -104,6 +104,7 @@\n     'walletbackup.py',\n     'bip68-112-113-p2p.py',\n     'wallet.py',\n+    'walletspv.py',\n     'wallet-accounts.py',\n     'wallet-hd.py',\n     'wallet-dump.py',"
      },
      {
        "sha": "37031b0d608ededce869438578cac1eaee83123f",
        "filename": "qa/rpc-tests/walletspv.py",
        "status": "added",
        "additions": 108,
        "deletions": 0,
        "changes": 108,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96bdeffb78eecb7a82f7325272ed9374e8dcd782/qa/rpc-tests/walletspv.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96bdeffb78eecb7a82f7325272ed9374e8dcd782/qa/rpc-tests/walletspv.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/walletspv.py?ref=96bdeffb78eecb7a82f7325272ed9374e8dcd782",
        "patch": "@@ -0,0 +1,108 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2015-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.mininode import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+import time\n+\n+\n+class WalletSPVTest(BitcoinTestFramework):\n+ \n+    def __init__(self):\n+        super().__init__()\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4\n+        self.extra_args = [[\"-debug=net\"], [\"-spv=1\", \"-spvonly=1\", \"-debug=net\"], [\"-debug=net\"]]\n+\n+    def setup_network(self, split=False):\n+        self.nodes = start_nodes(3, self.options.tmpdir, self.extra_args)\n+        connect_nodes(self.nodes[0], 1)\n+        connect_nodes(self.nodes[0], 2)\n+        connect_nodes(self.nodes[1], 2)\n+        self.is_network_split=False\n+        self.sync_all()\n+\n+    def sync_spv(self, headerheight, wait=1, timeout=20):\n+        \"\"\"\n+        Wait until everybody has the same tip\n+        \"\"\"\n+        maxheight = 0\n+        while timeout > 0:\n+            insync = True\n+            for x in self.nodes:\n+                info = x.getwalletinfo()\n+                if info['spv']['enabled'] == True:\n+                    if not info['spv']['synced_up_to_height'] == headerheight:\n+                        insync = False\n+            if insync == True:\n+                return True\n+            timeout -= wait\n+            time.sleep(wait)\n+        raise AssertionError(\"SPV sync failed\")\n+\n+    def run_test(self):\n+        # Generate some old blocks\n+        addr = self.nodes[1].getnewaddress() #for 1 conf tx\n+        self.nodes[0].generate(130)\n+        self.nodes[0].sendtoaddress(addr, 1.1)\n+        self.nodes[0].generate(1)\n+        headerheight = self.nodes[0].getblockchaininfo()['headers']\n+        self.sync_spv(headerheight)\n+\n+        time.sleep(5)\n+        \n+        node1info = self.nodes[1].getblockchaininfo()\n+        assert_equal(node1info['blocks'], 0)\n+        assert_equal(node1info['headers'], headerheight)\n+        spvinfo = self.nodes[1].getwalletinfo()['spv']\n+        assert_equal(headerheight, spvinfo['best_known_header_height'])\n+        lt = self.nodes[1].listtransactions()\n+        \n+        # node1 is in SPV only mode\n+        # txes should not be present in the wallet with spv\n+        assert_equal(lt[0]['address'], addr)\n+        assert_equal(lt[0]['spv'], True)\n+        assert_equal(lt[0]['confirmations'], 1)\n+        \n+        print(\"Restarting nodes without -spvonly (hybrid SPV)\")\n+        self.stop_node(1)\n+        os.mkdir(self.options.tmpdir + \"/node3/regtest\")\n+        shutil.copyfile(self.options.tmpdir + \"/node1/regtest/wallet.dat\", self.options.tmpdir + \"/node3/regtest/wallet.dat\")\n+        self.nodes[1] = start_node(1, self.options.tmpdir, [\"-spv=1\", \"-debug=net\"])\n+        connect_nodes_bi(self.nodes,0, 1)\n+        connect_nodes_bi(self.nodes,1, 2)\n+    \n+        self.nodes[0].resendwallettransactions()\n+        self.sync_all()\n+        \n+        lt = self.nodes[1].listtransactions()\n+\n+        # tx should now be fully validated\n+        assert_equal(lt[0]['address'], addr)\n+        assert_equal(lt[0]['spv'], False)\n+        assert_equal(lt[0]['confirmations'], 1)\n+        \n+        # start another node with initial hyprid SPV mode\n+        # use the wallet from node1\n+        self.nodes.append(start_node(3, self.options.tmpdir, [\"-debug=net\",\"-spv=1\"]))\n+        connect_nodes_bi(self.nodes,0, 3)\n+        connect_nodes_bi(self.nodes,0, 2)\n+        headerheight = self.nodes[0].getblockchaininfo()['headers']\n+        self.sync_spv(headerheight)\n+        # make sure we have identical mempools\n+        self.nodes[0].resendwallettransactions()\n+        self.sync_all()\n+        \n+        # currently there is no efficient way to test for the \"SPV first\" wallet listing\n+        # but we test that the hybrid modes results with a standard full validated wtxns\n+        lt = self.nodes[3].listtransactions()\n+        assert_equal(lt[0]['address'], addr)\n+        assert_equal(lt[0]['spv'], False)\n+        assert_equal(lt[0]['confirmations'], 1)\n+    \n+\n+if __name__ == '__main__':\n+    WalletSPVTest().main()"
      },
      {
        "sha": "27c1c628eaff5b2ce5d6cdc6f27a3a146f26f64e",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=96bdeffb78eecb7a82f7325272ed9374e8dcd782",
        "patch": "@@ -80,6 +80,7 @@ BITCOIN_CORE_H = \\\n   base58.h \\\n   bloom.h \\\n   blockencodings.h \\\n+  blockrequest.h \\\n   chain.h \\\n   chainparams.h \\\n   chainparamsbase.h \\\n@@ -172,6 +173,7 @@ libbitcoin_server_a_SOURCES = \\\n   addrdb.cpp \\\n   bloom.cpp \\\n   blockencodings.cpp \\\n+  blockrequest.cpp \\\n   chain.cpp \\\n   checkpoints.cpp \\\n   httprpc.cpp \\"
      },
      {
        "sha": "4dda273987d83a9e6a3281110bb953e684cf2045",
        "filename": "src/blockrequest.cpp",
        "status": "added",
        "additions": 128,
        "deletions": 0,
        "changes": 128,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/blockrequest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/blockrequest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockrequest.cpp?ref=96bdeffb78eecb7a82f7325272ed9374e8dcd782",
        "patch": "@@ -0,0 +1,128 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockrequest.h\"\n+\n+#include \"chainparams.h\"\n+#include \"main.h\"\n+\n+#include <exception>\n+\n+std::shared_ptr<CBlockRequest> currentBlockRequest; //thread-safe pointer (CBlockRequest, the object, is also lock-free)\n+\n+CBlockRequest::CBlockRequest(std::vector<CBlockIndex*> vBlocksToDownloadIn, int64_t createdIn, const std::function<bool(std::shared_ptr<CBlockRequest>, CBlockIndex *pindex)> progressCallbackIn) : vBlocksToDownload(vBlocksToDownloadIn), created(createdIn), progressCallback(progressCallbackIn)\n+{\n+    fCancelled = false;\n+    requestedUpToSize = 0;\n+    processedUpToSize = 0;\n+}\n+\n+CBlockRequest::~CBlockRequest()\n+{\n+    LogPrint(\"net\", \"Deallocating CBlockRequest\\n\");\n+}\n+\n+void CBlockRequest::processWithPossibleBlock(const CBlock* pblock, CBlockIndex *pindex)\n+{\n+    // don't process anything if request was cancled\n+    if (this->fCancelled)\n+        return;\n+\n+    int MAX_PROCESS = 5;\n+    int loop_processed = 0;\n+    for (unsigned int i = this->processedUpToSize; i < this->vBlocksToDownload.size() ; i++) {\n+        CBlockIndex *pindexRequest = this->vBlocksToDownload[i];\n+        CBlock loadBlock;\n+        const CBlock *currentBlock = &loadBlock;\n+\n+        // if a block has been passed, check if is the next item in the sequence\n+        if (pindex && pblock && pindex == pindexRequest)\n+            currentBlock = pblock;\n+        else if (pindexRequest->nStatus & BLOCK_HAVE_DATA) {\n+            if (!ReadBlockFromDisk(loadBlock, pindexRequest, Params().GetConsensus()))\n+                throw std::runtime_error(std::string(__func__) + \"Can't read block from disk\");\n+        } else {\n+            break;\n+        }\n+\n+        // fire signal with txns\n+        int cnt = 0;\n+        BOOST_FOREACH(const CTransaction &tx, currentBlock->vtx) {\n+            GetMainSignals().SyncTransaction(tx, pindexRequest, cnt, false);\n+            cnt++;\n+        }\n+        this->processedUpToSize++;\n+\n+        // log some info\n+        LogPrint(\"net\", \"BlockRequest: proccessed up to %ld of total requested %ld blocks\\n\", this->processedUpToSize, this->vBlocksToDownload.size());\n+\n+        if (progressCallback)\n+            if (!progressCallback(shared_from_this(), pindexRequest))\n+                this->cancel();\n+\n+        // release global block request pointer if request has been completed\n+        if (this->processedUpToSize == this->vBlocksToDownload.size())\n+            currentBlockRequest = nullptr;\n+\n+        if (loop_processed >= MAX_PROCESS)\n+            break;\n+        loop_processed++;\n+    }\n+}\n+\n+void CBlockRequest::cancel()\n+{\n+    fCancelled = true;\n+    if (currentBlockRequest.get() == this) {\n+        // release shared pointer\n+        currentBlockRequest = nullptr;\n+    }\n+}\n+\n+bool CBlockRequest::isCancelled()\n+{\n+    return fCancelled;\n+}\n+\n+void CBlockRequest::setAsCurrentRequest()\n+{\n+    // if there is an existing block request, cancle it\n+    if (currentBlockRequest != nullptr)\n+        currentBlockRequest->fCancelled = true;\n+\n+    currentBlockRequest = shared_from_this();\n+}\n+\n+void CBlockRequest::fillInNextBlocks(std::vector<CBlockIndex*>& vBlocks, unsigned int count, std::function<bool(CBlockIndex*)> filterBlocksCallback)\n+{\n+    for (unsigned int i = this->processedUpToSize; i < this->vBlocksToDownload.size() ; i++) {\n+        CBlockIndex *pindex = this->vBlocksToDownload[i];\n+        if ( filterBlocksCallback(pindex) && !(pindex->nStatus & BLOCK_HAVE_DATA)) {\n+            // the block was accepted by the filter, add it to the download queue\n+            vBlocks.push_back(pindex);\n+            if (vBlocks.size() == count) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    //try to push already available blocks through the signal\n+    this->processWithPossibleBlock(NULL, NULL);\n+}\n+\n+unsigned int CBlockRequest::amountOfBlocksLoaded()\n+{\n+    unsigned int haveData = 0;\n+    for (unsigned int i = 0; i < this->vBlocksToDownload.size() ; i++) {\n+        CBlockIndex *pindex = this->vBlocksToDownload[i];\n+        if (pindex->nStatus & BLOCK_HAVE_DATA)\n+            haveData++;\n+    }\n+    return haveData;\n+}\n+\n+std::shared_ptr<CBlockRequest> CBlockRequest::GetCurrentRequest()\n+{\n+    return currentBlockRequest;\n+}"
      },
      {
        "sha": "921df31c36fe52aa603bd0c59cae6cd90a9fcd03",
        "filename": "src/blockrequest.h",
        "status": "added",
        "additions": 55,
        "deletions": 0,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/blockrequest.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/blockrequest.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockrequest.h?ref=96bdeffb78eecb7a82f7325272ed9374e8dcd782",
        "patch": "@@ -0,0 +1,55 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_BLOCKREQUEST_H\n+#define BITCOIN_BLOCKREQUEST_H\n+\n+#include <atomic>\n+#include \"chain.h\"\n+#include \"consensus/consensus.h\"\n+#include \"net.h\"\n+#include <stdint.h>\n+#include <vector>\n+\n+// \"Lock free\" block request\n+class CBlockRequest : public std::enable_shared_from_this<CBlockRequest> {\n+public:\n+    std::atomic<size_t> requestedUpToSize; //requested up to this element in vBlocksToDownload\n+    std::atomic<size_t> processedUpToSize; //processed up to this element in vBlocksToDownload\n+\n+    const std::vector<CBlockIndex*> vBlocksToDownload;\n+    const int64_t created; //!When the request was started\n+\n+    /** Constructor of the lock free CBlockRequest, vBlocksToDownloadIn remains constant */\n+    CBlockRequest(std::vector<CBlockIndex*> vBlocksToDownloadIn, int64_t created, const std::function<bool(std::shared_ptr<CBlockRequest>, CBlockIndex *pindex)> progressCallbackIn);\n+    ~CBlockRequest();\n+\n+    /** Process the request, check if there are blocks available to \"stream\"\n+        over the SyncTransaction signal \n+        Allow to provide an optional block to avoid disk re-loading\n+     */\n+    void processWithPossibleBlock(const CBlock* pblock = NULL, CBlockIndex *pindex = NULL);\n+\n+    /** Cancel the block request */\n+    void cancel();\n+    bool isCancelled();\n+\n+    /** Set as the current block request, invalidate/cancle the current one */\n+    void setAsCurrentRequest();\n+\n+    /** Fill next available, not already requested blocks into vBlocks\n+        allow to provide a function to check if block is already in flight somewhere */\n+    void fillInNextBlocks(std::vector<CBlockIndex*>& vBlocks, unsigned int count, std::function<bool(CBlockIndex*)> filterBlocksCallback);\n+\n+    unsigned int amountOfBlocksLoaded();\n+\n+    /** Get the current main block request, thread_safe */\n+    static std::shared_ptr<CBlockRequest> GetCurrentRequest();\n+\n+private:\n+    const std::function<bool(std::shared_ptr<CBlockRequest>, CBlockIndex *pindex)> progressCallback; //! progress callback, with optional cancle mechanism (return false == cancel)\n+    std::atomic<bool> fCancelled;\n+};\n+\n+#endif // BITCOIN_BLOCKREQUEST_H"
      },
      {
        "sha": "62b76b606b9c01bccb96cf1234873400f844984c",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 121,
        "deletions": 63,
        "changes": 184,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=96bdeffb78eecb7a82f7325272ed9374e8dcd782",
        "patch": "@@ -8,6 +8,7 @@\n #include \"addrman.h\"\n #include \"arith_uint256.h\"\n #include \"blockencodings.h\"\n+#include \"blockrequest.h\"\n #include \"chainparams.h\"\n #include \"checkpoints.h\"\n #include \"checkqueue.h\"\n@@ -89,6 +90,8 @@ CAmount maxTxFee = DEFAULT_TRANSACTION_MAXFEE;\n CTxMemPool mempool(::minRelayTxFee);\n FeeFilterRounder filterRounder(::minRelayTxFee);\n \n+std::atomic<bool> fAutodownloadBlocks(true);\n+\n struct IteratorComparator\n {\n     template<typename I>\n@@ -214,6 +217,7 @@ namespace {\n         CBlockIndex* pindex;                                     //!< Optional.\n         bool fValidatedHeaders;                                  //!< Whether this block has validated headers at the time of request.\n         std::unique_ptr<PartiallyDownloadedBlock> partialBlock;  //!< Optional, used for CMPCTBLOCK downloads\n+        std::shared_ptr<CBlockRequest> blockRequest;                  //!< Optional, used for specific block downloads (SPV)\n     };\n     map<uint256, pair<NodeId, list<QueuedBlock>::iterator> > mapBlocksInFlight;\n \n@@ -422,7 +426,13 @@ void FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) {\n // Requires cs_main.\n // Returns a bool indicating whether we requested this block.\n // Also used if a block was /not/ received and timed out or started with another peer\n-bool MarkBlockAsReceived(const uint256& hash) {\n+\n+struct MarkBlockAsReceivedResult {\n+    bool fRequested;\n+    std::shared_ptr<CBlockRequest> blockRequest;\n+};\n+\n+const MarkBlockAsReceivedResult MarkBlockAsReceived(const uint256& hash) {\n     map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n     if (itInFlight != mapBlocksInFlight.end()) {\n         CNodeState *state = State(itInFlight->second.first);\n@@ -435,19 +445,20 @@ bool MarkBlockAsReceived(const uint256& hash) {\n             // First block on the queue was received, update the start download time for the next one\n             state->nDownloadingSince = std::max(state->nDownloadingSince, GetTimeMicros());\n         }\n+        std::shared_ptr<CBlockRequest> blockRequest = itInFlight->second.second->blockRequest;\n         state->vBlocksInFlight.erase(itInFlight->second.second);\n         state->nBlocksInFlight--;\n         state->nStallingSince = 0;\n         mapBlocksInFlight.erase(itInFlight);\n-        return true;\n+        return {true, blockRequest};\n     }\n-    return false;\n+    return {false, nullptr};\n }\n \n // Requires cs_main.\n // returns false, still setting pit, if the block was already in flight from the same peer\n // pit will only be valid as long as the same cs_main lock is being held\n-bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const Consensus::Params& consensusParams, CBlockIndex *pindex = NULL, list<QueuedBlock>::iterator **pit = NULL) {\n+bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const Consensus::Params& consensusParams, CBlockIndex *pindex = NULL, list<QueuedBlock>::iterator **pit = NULL, std::shared_ptr<CBlockRequest> blockRequest = {} ) {\n     CNodeState *state = State(nodeid);\n     assert(state != NULL);\n \n@@ -462,7 +473,7 @@ bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const Consensus::Pa\n     MarkBlockAsReceived(hash);\n \n     list<QueuedBlock>::iterator it = state->vBlocksInFlight.insert(state->vBlocksInFlight.end(),\n-            {hash, pindex, pindex != NULL, std::unique_ptr<PartiallyDownloadedBlock>(pit ? new PartiallyDownloadedBlock(&mempool) : NULL)});\n+            {hash, pindex, pindex != NULL, std::unique_ptr<PartiallyDownloadedBlock>(pit ? new PartiallyDownloadedBlock(&mempool) : NULL), blockRequest});\n     state->nBlocksInFlight++;\n     state->nBlocksInFlightValidHeaders += it->fValidatedHeaders;\n     if (state->nBlocksInFlight == 1) {\n@@ -579,7 +590,7 @@ CBlockIndex* LastCommonAncestor(CBlockIndex* pa, CBlockIndex* pb) {\n \n /** Update pindexLastCommonBlock and add not-in-flight missing successors to vBlocks, until it has\n  *  at most count entries. */\n-void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<CBlockIndex*>& vBlocks, NodeId& nodeStaller, const Consensus::Params& consensusParams) {\n+void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<CBlockIndex*>& vBlocks, NodeId& nodeStaller, const Consensus::Params& consensusParams, std::shared_ptr<CBlockRequest> blockRequest) {\n     if (count == 0)\n         return;\n \n@@ -590,6 +601,26 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<CBl\n     // Make sure pindexBestKnownBlock is up to date, we'll need it.\n     ProcessBlockAvailability(nodeid);\n \n+    // if there is an open CBlockRequest (out-of-band/specific block donwload), privileg it\n+    if (blockRequest && !blockRequest->isCancelled()) {\n+        // fill in next blocks to download, pass in a filter function to check mapBlocksInFlight\n+        blockRequest->fillInNextBlocks(vBlocks, count, [state](CBlockIndex *pIndexCheck) -> bool {\n+            // make sure the remote node has this block\n+            // we have already verified the chainWork through the headers-sync\n+            // lets just compare heights\n+            // missing blocks will lead to a time-out/missbehave and re-request (from different peer) (TODO: check)\n+            if (state->pindexBestKnownBlock == NULL || state->pindexBestKnownBlock->nHeight < pIndexCheck->nHeight)\n+                return false;\n+            return (mapBlocksInFlight.count(pIndexCheck->GetBlockHash()) == 0);\n+        });\n+\n+        // if we haven't completed the individual CBlockRequest, we wont continue with \"normal\" IBD\n+        return;\n+    }\n+    // don't download any other blocks if we are in non autodownload mode (pure SPV)\n+    if (!fAutodownloadBlocks)\n+        return;\n+\n     if (state->pindexBestKnownBlock == NULL || state->pindexBestKnownBlock->nChainWork < chainActive.Tip()->nChainWork) {\n         // This peer has nothing interesting.\n         return;\n@@ -848,7 +879,7 @@ bool IsFinalTx(const CTransaction &tx, int nBlockHeight, int64_t nBlockTime)\n     return true;\n }\n \n-bool CheckFinalTx(const CTransaction &tx, int flags)\n+bool CheckFinalTx(const CTransaction &tx, int flags, bool fHeadersChain)\n {\n     AssertLockHeld(cs_main);\n \n@@ -866,8 +897,7 @@ bool CheckFinalTx(const CTransaction &tx, int flags)\n     // evaluated is what is used. Thus if we want to know if a\n     // transaction can be part of the *next* block, we need to call\n     // IsFinalTx() with one more than chainActive.Height().\n-    const int nBlockHeight = chainActive.Height() + 1;\n-\n+    const int nBlockHeight = ((fHeadersChain && pindexBestHeader) ? pindexBestHeader->nHeight : chainActive.Height()) + 1;\n     // BIP113 will require that time-locked transactions have nLockTime set to\n     // less than the median time of the previous block they're contained in.\n     // When the next block is created its previous block will be the current\n@@ -1605,7 +1635,7 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n         }\n     }\n \n-    GetMainSignals().SyncTransaction(tx, NULL, CMainSignals::SYNC_TRANSACTION_NOT_IN_BLOCK);\n+    GetMainSignals().SyncTransaction(tx, NULL, CMainSignals::SYNC_TRANSACTION_NOT_IN_BLOCK, true);\n \n     return true;\n }\n@@ -2828,7 +2858,7 @@ bool static DisconnectTip(CValidationState& state, const CChainParams& chainpara\n     // Let wallets know transactions went from 1-confirmed to\n     // 0-confirmed or conflicted:\n     BOOST_FOREACH(const CTransaction &tx, block.vtx) {\n-        GetMainSignals().SyncTransaction(tx, pindexDelete->pprev, CMainSignals::SYNC_TRANSACTION_NOT_IN_BLOCK);\n+        GetMainSignals().SyncTransaction(tx, pindexDelete->pprev, CMainSignals::SYNC_TRANSACTION_NOT_IN_BLOCK, true);\n     }\n     return true;\n }\n@@ -3056,6 +3086,7 @@ static void NotifyHeaderTip() {\n     // Send block tip changed notifications without cs_main\n     if (fNotify) {\n         uiInterface.NotifyHeaderTip(fInitialBlockDownload, pindexHeader);\n+        GetMainSignals().UpdatedBlockHeaderTip(fInitialBlockDownload, pindexHeader);\n     }\n }\n \n@@ -3110,11 +3141,11 @@ bool ActivateBestChain(CValidationState &state, const CChainParams& chainparams,\n         // while _not_ holding the cs_main lock\n         for(std::shared_ptr<const CTransaction> tx : txConflicted)\n         {\n-            GetMainSignals().SyncTransaction(*tx, pindexNewTip, CMainSignals::SYNC_TRANSACTION_NOT_IN_BLOCK);\n+            GetMainSignals().SyncTransaction(*tx, pindexNewTip, CMainSignals::SYNC_TRANSACTION_NOT_IN_BLOCK, true);\n         }\n         // ... and about transactions that got confirmed:\n         for(unsigned int i = 0; i < txChanged.size(); i++)\n-            GetMainSignals().SyncTransaction(std::get<0>(txChanged[i]), std::get<1>(txChanged[i]), std::get<2>(txChanged[i]));\n+            GetMainSignals().SyncTransaction(std::get<0>(txChanged[i]), std::get<1>(txChanged[i]), std::get<2>(txChanged[i]), true);\n \n         // Notify external listeners about the new tip.\n         GetMainSignals().UpdatedBlockTip(pindexNewTip, pindexFork, fInitialDownload);\n@@ -3715,7 +3746,7 @@ static bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state\n }\n \n /** Store block on disk. If dbp is non-NULL, the file is known to already reside on disk */\n-static bool AcceptBlock(const CBlock& block, CValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex, bool fRequested, const CDiskBlockPos* dbp, bool* fNewBlock)\n+static bool AcceptBlock(const CBlock& block, CValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex, bool fRequested, const CDiskBlockPos* dbp, bool* fNewBlock, bool onlyHeaderCheck = false)\n {\n     if (fNewBlock) *fNewBlock = false;\n     AssertLockHeld(cs_main);\n@@ -3726,40 +3757,48 @@ static bool AcceptBlock(const CBlock& block, CValidationState& state, const CCha\n     if (!AcceptBlockHeader(block, state, chainparams, &pindex))\n         return false;\n \n-    // Try to process all requested blocks that we don't have, but only\n-    // process an unrequested block if it's new and has enough work to\n-    // advance our tip, and isn't too many blocks ahead.\n-    bool fAlreadyHave = pindex->nStatus & BLOCK_HAVE_DATA;\n-    bool fHasMoreWork = (chainActive.Tip() ? pindex->nChainWork > chainActive.Tip()->nChainWork : true);\n-    // Blocks that are too out-of-order needlessly limit the effectiveness of\n-    // pruning, because pruning will not delete block files that contain any\n-    // blocks which are too close in height to the tip.  Apply this test\n-    // regardless of whether pruning is enabled; it should generally be safe to\n-    // not process unrequested blocks.\n-    bool fTooFarAhead = (pindex->nHeight > int(chainActive.Height() + MIN_BLOCKS_TO_KEEP));\n-\n-    // TODO: Decouple this function from the block download logic by removing fRequested\n-    // This requires some new chain datastructure to efficiently look up if a\n-    // block is in a chain leading to a candidate for best tip, despite not\n-    // being such a candidate itself.\n-\n-    // TODO: deal better with return value and error conditions for duplicate\n-    // and unrequested blocks.\n-    if (fAlreadyHave) return true;\n-    if (!fRequested) {  // If we didn't ask for it:\n-        if (pindex->nTx != 0) return true;  // This is a previously-processed block that was pruned\n-        if (!fHasMoreWork) return true;     // Don't process less-work chains\n-        if (fTooFarAhead) return true;      // Block height is too high\n-    }\n-    if (fNewBlock) *fNewBlock = true;\n-\n-    if (!CheckBlock(block, state, chainparams.GetConsensus(), GetAdjustedTime()) ||\n-        !ContextualCheckBlock(block, state, chainparams.GetConsensus(), pindex->pprev)) {\n-        if (state.IsInvalid() && !state.CorruptionPossible()) {\n-            pindex->nStatus |= BLOCK_FAILED_VALID;\n-            setDirtyBlockIndex.insert(pindex);\n+    // don't validate the block if we fetch it with a specific CBlockRequest\n+    if (onlyHeaderCheck) {\n+        LogPrint(\"net\", \"Accept specific block %s (%d)\\n\", pindex->GetBlockHash().ToString(),\n+                 pindex->nHeight);\n+    }\n+    else\n+    {\n+        // Try to process all requested blocks that we don't have, but only\n+        // process an unrequested block if it's new and has enough work to\n+        // advance our tip, and isn't too many blocks ahead.\n+        bool fAlreadyHave = pindex->nStatus & BLOCK_HAVE_DATA;\n+        bool fHasMoreWork = (chainActive.Tip() ? pindex->nChainWork > chainActive.Tip()->nChainWork : true);\n+        // Blocks that are too out-of-order needlessly limit the effectiveness of\n+        // pruning, because pruning will not delete block files that contain any\n+        // blocks which are too close in height to the tip.  Apply this test\n+        // regardless of whether pruning is enabled; it should generally be safe to\n+        // not process unrequested blocks.\n+        bool fTooFarAhead = (pindex->nHeight > int(chainActive.Height() + MIN_BLOCKS_TO_KEEP));\n+\n+        // TODO: Decouple this function from the block download logic by removing fRequested\n+        // This requires some new chain datastructure to efficiently look up if a\n+        // block is in a chain leading to a candidate for best tip, despite not\n+        // being such a candidate itself.\n+\n+        // TODO: deal better with return value and error conditions for duplicate\n+        // and unrequested blocks.\n+        if (fAlreadyHave) return true;\n+        if (!fRequested) {  // If we didn't ask for it:\n+            if (pindex->nTx != 0) return true;  // This is a previously-processed block that was pruned\n+            if (!fHasMoreWork) return true;     // Don't process less-work chains\n+            if (fTooFarAhead) return true;      // Block height is too high\n+        }\n+        if (fNewBlock) *fNewBlock = true;\n+\n+        if (!CheckBlock(block, state, chainparams.GetConsensus(), GetAdjustedTime()) ||\n+            !ContextualCheckBlock(block, state, chainparams.GetConsensus(), pindex->pprev)) {\n+            if (state.IsInvalid() && !state.CorruptionPossible()) {\n+                pindex->nStatus |= BLOCK_FAILED_VALID;\n+                setDirtyBlockIndex.insert(pindex);\n+            }\n+            return error(\"%s: %s\", __func__, FormatStateMessage(state));\n         }\n-        return error(\"%s: %s\", __func__, FormatStateMessage(state));\n     }\n \n     int nHeight = pindex->nHeight;\n@@ -3787,15 +3826,16 @@ static bool AcceptBlock(const CBlock& block, CValidationState& state, const CCha\n     return true;\n }\n \n-bool ProcessNewBlock(CValidationState& state, const CChainParams& chainparams, CNode* pfrom, const CBlock* pblock, bool fForceProcessing, const CDiskBlockPos* dbp, bool fMayBanPeerIfInvalid)\n+bool ProcessNewBlock(CValidationState& state, const CChainParams& chainparams, CNode* pfrom, const CBlock* pblock, bool fForceProcessing, std::shared_ptr<CBlockRequest> blockRequest, const CDiskBlockPos* dbp, bool fMayBanPeerIfInvalid)\n {\n+    CBlockIndex *pindex = NULL;\n     {\n         LOCK(cs_main);\n \n         // Store to disk\n-        CBlockIndex *pindex = NULL;\n         bool fNewBlock = false;\n-        bool ret = AcceptBlock(*pblock, state, chainparams, &pindex, fForceProcessing, dbp, &fNewBlock);\n+        bool ret = AcceptBlock(*pblock, state, chainparams, &pindex, fForceProcessing, dbp, &fNewBlock, (blockRequest\n+ != nullptr));\n         if (pindex && pfrom) {\n             mapBlockSource[pindex->GetBlockHash()] = std::make_pair(pfrom->GetId(), fMayBanPeerIfInvalid);\n             if (fNewBlock) pfrom->nLastBlockTime = GetTime();\n@@ -3805,9 +3845,11 @@ bool ProcessNewBlock(CValidationState& state, const CChainParams& chainparams, C\n             return error(\"%s: AcceptBlock FAILED\", __func__);\n     }\n \n-    NotifyHeaderTip();\n+    if (blockRequest)\n+        blockRequest->processWithPossibleBlock(pblock, pindex);\n \n-    if (!ActivateBestChain(state, chainparams, pblock))\n+    NotifyHeaderTip();\n+    if (!blockRequest && !ActivateBestChain(state, chainparams, pblock))\n         return error(\"%s: ActivateBestChain failed\", __func__);\n \n     return true;\n@@ -5923,7 +5965,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             // BIP 152 permits peers to relay compact blocks after validating\n             // the header only; we should not punish peers if the block turns\n             // out to be invalid.\n-            ProcessNewBlock(state, chainparams, pfrom, &block, true, NULL, false);\n+            ProcessNewBlock(state, chainparams, pfrom, &block, true, nullptr, NULL, false);\n             int nDoS;\n             if (state.IsInvalid(nDoS)) {\n                 assert (state.GetRejectCode() < REJECT_INTERNAL); // Blocks are never rejected with internal reject codes\n@@ -6085,21 +6127,32 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         CBlock block;\n         vRecv >> block;\n \n-        LogPrint(\"net\", \"received block %s peer=%d\\n\", block.GetHash().ToString(), pfrom->id);\n+        BlockMap::iterator mi = mapBlockIndex.find(block.GetHash());\n+        if (mi != mapBlockIndex.end())\n+        {\n+            CBlockIndex* pindex = (*mi).second;\n+            LogPrint(\"net\", \"received block %s (%d) peer=%d\\n\", block.GetHash().ToString(), pindex->nHeight, pfrom->id);\n+        }\n+        else\n+            LogPrint(\"net\", \"received block %s peer=%d\\n\", block.GetHash().ToString(), pfrom->id);\n \n         CValidationState state;\n         // Process all blocks from whitelisted peers, even if not requested,\n         // unless we're still syncing with the network.\n         // Such an unrequested block may still be processed, subject to the\n         // conditions in AcceptBlock().\n         bool forceProcessing = pfrom->fWhitelisted && !IsInitialBlockDownload();\n+        std::shared_ptr<CBlockRequest> blockRequest = nullptr;\n         {\n             LOCK(cs_main);\n             // Also always process if we requested the block explicitly, as we may\n             // need it even though it is not a candidate for a new best tip.\n-            forceProcessing |= MarkBlockAsReceived(block.GetHash());\n+            MarkBlockAsReceivedResult result;\n+            result = MarkBlockAsReceived(block.GetHash());\n+            forceProcessing |= result.fRequested;\n+            blockRequest = result.blockRequest;\n         }\n-        ProcessNewBlock(state, chainparams, pfrom, &block, forceProcessing, NULL, true);\n+        ProcessNewBlock(state, chainparams, pfrom, &block, forceProcessing, blockRequest, NULL, true);\n         int nDoS;\n         if (state.IsInvalid(nDoS)) {\n             assert (state.GetRejectCode() < REJECT_INTERNAL); // Blocks are never rejected with internal reject codes\n@@ -6848,13 +6901,16 @@ bool SendMessages(CNode* pto, CConnman& connman)\n                     }\n                     // Not in the mempool anymore? don't bother sending it.\n                     auto txinfo = mempool.info(hash);\n-                    if (!txinfo.tx) {\n+                    std::shared_ptr<const CTransaction> txsp = txinfo.tx;\n+                    if (!txsp)\n+                        GetMainSignals().FindTransaction(hash, txsp);\n+                    if (!txsp) {\n                         continue;\n                     }\n-                    if (filterrate && txinfo.feeRate.GetFeePerK() < filterrate) {\n+                    if (filterrate && txinfo.tx && txinfo.feeRate.GetFeePerK() < filterrate) {\n                         continue;\n                     }\n-                    if (pto->pfilter && !pto->pfilter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n+                    if (pto->pfilter && !pto->pfilter->IsRelevantAndUpdate(*txsp)) continue;\n                     // Send\n                     vInv.push_back(CInv(MSG_TX, hash));\n                     nRelayedTransactions++;\n@@ -6866,7 +6922,7 @@ bool SendMessages(CNode* pto, CConnman& connman)\n                             vRelayExpiration.pop_front();\n                         }\n \n-                        auto ret = mapRelay.insert(std::make_pair(hash, std::move(txinfo.tx)));\n+                        auto ret = mapRelay.insert(std::make_pair(hash, std::move(txsp)));\n                         if (ret.second) {\n                             vRelayExpiration.push_back(std::make_pair(nNow + 15 * 60 * 1000000, ret.first));\n                         }\n@@ -6912,12 +6968,14 @@ bool SendMessages(CNode* pto, CConnman& connman)\n         if (!pto->fDisconnect && !pto->fClient && (fFetch || !IsInitialBlockDownload()) && state.nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n             vector<CBlockIndex*> vToDownload;\n             NodeId staller = -1;\n-            FindNextBlocksToDownload(pto->GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller, consensusParams);\n+            std::shared_ptr<CBlockRequest> blockRequest = CBlockRequest::GetCurrentRequest();\n+            FindNextBlocksToDownload(pto->GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller, consensusParams, blockRequest);\n             BOOST_FOREACH(CBlockIndex *pindex, vToDownload) {\n                 uint32_t nFetchFlags = GetFetchFlags(pto, pindex->pprev, consensusParams);\n                 vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n-                MarkBlockAsInFlight(pto->GetId(), pindex->GetBlockHash(), consensusParams, pindex);\n-                LogPrint(\"net\", \"Requesting block %s (%d) peer=%d\\n\", pindex->GetBlockHash().ToString(),\n+                list<QueuedBlock>::iterator *queuedBlockIt = NULL;\n+                MarkBlockAsInFlight(pto->GetId(), pindex->GetBlockHash(), consensusParams, pindex, &queuedBlockIt, blockRequest);\n+                LogPrint(\"net\", \"Requesting%s block %s (%d) peer=%d\\n\", (blockRequest ? \" (specific/SPV)\" : \" \"), pindex->GetBlockHash().ToString(),\n                     pindex->nHeight, pto->id);\n             }\n             if (state.nBlocksInFlight == 0 && staller != -1) {"
      },
      {
        "sha": "cbc7eade4cfd95c506a57c97fd4602d5fa3d4102",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 6,
        "deletions": 2,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=96bdeffb78eecb7a82f7325272ed9374e8dcd782",
        "patch": "@@ -31,6 +31,7 @@\n #include <boost/unordered_map.hpp>\n \n class CBlockIndex;\n+class CBlockRequest;\n class CBlockTreeDB;\n class CBloomFilter;\n class CChainParams;\n@@ -201,6 +202,9 @@ static const unsigned int MIN_BLOCKS_TO_KEEP = 288;\n static const signed int DEFAULT_CHECKBLOCKS = 6;\n static const unsigned int DEFAULT_CHECKLEVEL = 3;\n \n+/** if disabled, blocks will not be downloaded automatically, usefull for pure SPV mode */\n+extern std::atomic<bool> fAutodownloadBlocks;\n+\n // Require that user allocate at least 550MB for block & undo files (blk???.dat and rev???.dat)\n // At 1MB per block, 288 blocks = 288MB.\n // Add 15% for Undo data = 331MB\n@@ -223,7 +227,7 @@ static const uint64_t MIN_DISK_SPACE_FOR_BLOCK_FILES = 550 * 1024 * 1024;\n  * @param[out]  dbp     The already known disk position of pblock, or NULL if not yet stored.\n  * @return True if state.IsValid()\n  */\n-bool ProcessNewBlock(CValidationState& state, const CChainParams& chainparams, CNode* pfrom, const CBlock* pblock, bool fForceProcessing, const CDiskBlockPos* dbp, bool fMayBanPeerIfInvalid);\n+bool ProcessNewBlock(CValidationState& state, const CChainParams& chainparams, CNode* pfrom, const CBlock* pblock, bool fForceProcessing, std::shared_ptr<CBlockRequest> blockRequest, const CDiskBlockPos* dbp, bool fMayBanPeerIfInvalid);\n /** Check whether enough disk space is available for an incoming block */\n bool CheckDiskSpace(uint64_t nAdditionalBytes = 0);\n /** Open a block file (blk?????.dat) */\n@@ -369,7 +373,7 @@ bool IsFinalTx(const CTransaction &tx, int nBlockHeight, int64_t nBlockTime);\n  *\n  * See consensus/consensus.h for flag definitions.\n  */\n-bool CheckFinalTx(const CTransaction &tx, int flags = -1);\n+bool CheckFinalTx(const CTransaction &tx, int flags = -1, bool fHeadersChain = false);\n \n /**\n  * Test whether the LockPoints height and time are still valid on the current chain"
      },
      {
        "sha": "f7da9543a6c8b38d889770776089c473517f0f13",
        "filename": "src/qt/guiconstants.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/qt/guiconstants.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/qt/guiconstants.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiconstants.h?ref=96bdeffb78eecb7a82f7325272ed9374e8dcd782",
        "patch": "@@ -31,6 +31,7 @@ static const bool DEFAULT_SPLASHSCREEN = true;\n #define COLOR_TX_STATUS_OFFLINE QColor(192, 192, 192)\n /* Transaction list -- TX status decoration - danger, tx needs attention */\n #define COLOR_TX_STATUS_DANGER QColor(200, 100, 100)\n+#define COLOR_TX_STATUS_DANGER_BACKGROUND QColor(250, 200, 200)\n /* Transaction list -- TX status decoration - default color */\n #define COLOR_BLACK QColor(0, 0, 0)\n "
      },
      {
        "sha": "721510cbb0c4eec8fe03c0e6b3ced857cc549d12",
        "filename": "src/qt/optionsmodel.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/qt/optionsmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/qt/optionsmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsmodel.cpp?ref=96bdeffb78eecb7a82f7325272ed9374e8dcd782",
        "patch": "@@ -464,4 +464,4 @@ void OptionsModel::checkAndMigrate()\n \n         settings.setValue(strSettingsVersionKey, CLIENT_VERSION);\n     }\n-}\n\\ No newline at end of file\n+}"
      },
      {
        "sha": "0063bdcaf997f660cb9eff2bb044d9f93e5fa203",
        "filename": "src/qt/transactiondesc.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/qt/transactiondesc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/qt/transactiondesc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiondesc.cpp?ref=96bdeffb78eecb7a82f7325272ed9374e8dcd782",
        "patch": "@@ -24,7 +24,7 @@\n QString TransactionDesc::FormatTxStatus(const CWalletTx& wtx)\n {\n     AssertLockHeld(cs_main);\n-    if (!CheckFinalTx(wtx))\n+    if (!CheckFinalTx(wtx, -1 , wtx.fSPV))\n     {\n         if (wtx.nLockTime < LOCKTIME_THRESHOLD)\n             return tr(\"Open for %n more block(s)\", \"\", wtx.nLockTime - chainActive.Height());\n@@ -70,7 +70,7 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n             strHTML += tr(\", broadcast through %n node(s)\", \"\", nRequests);\n     }\n     strHTML += \"<br>\";\n-\n+    strHTML += \"<b>\" + tr(\"SPV\") + \":</b> \" + (rec->status.fSPV ? \"yes\" : \"no\") + \"<br>\";\n     strHTML += \"<b>\" + tr(\"Date\") + \":</b> \" + (nTime ? GUIUtil::dateTimeStr(nTime) : \"\") + \"<br>\";\n \n     //"
      },
      {
        "sha": "19992ef3a0fe469ca5891ea2717174fdf6270cbe",
        "filename": "src/qt/transactionrecord.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/qt/transactionrecord.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/qt/transactionrecord.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionrecord.cpp?ref=96bdeffb78eecb7a82f7325272ed9374e8dcd782",
        "patch": "@@ -187,8 +187,8 @@ void TransactionRecord::updateStatus(const CWalletTx &wtx)\n     status.countsForBalance = wtx.IsTrusted() && !(wtx.GetBlocksToMaturity() > 0);\n     status.depth = wtx.GetDepthInMainChain();\n     status.cur_num_blocks = chainActive.Height();\n-\n-    if (!CheckFinalTx(wtx))\n+    status.fSPV = wtx.fSPV;\n+    if (!CheckFinalTx(wtx, -1, status.fSPV))\n     {\n         if (wtx.nLockTime < LOCKTIME_THRESHOLD)\n         {"
      },
      {
        "sha": "6d447cdcb037a073a990bf40b089df3387e1c2c0",
        "filename": "src/qt/transactionrecord.h",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/qt/transactionrecord.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/qt/transactionrecord.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionrecord.h?ref=96bdeffb78eecb7a82f7325272ed9374e8dcd782",
        "patch": "@@ -61,6 +61,8 @@ class TransactionStatus\n \n     /** Current number of blocks (to know whether cached status is still valid) */\n     int cur_num_blocks;\n+\n+    bool fSPV;\n };\n \n /** UI model for a transaction. A core transaction can be represented by multiple UI transactions if it has\n@@ -96,7 +98,7 @@ class TransactionRecord\n \n     TransactionRecord(uint256 _hash, qint64 _time,\n                 Type _type, const std::string &_address,\n-                const CAmount& _debit, const CAmount& _credit):\n+                const CAmount& _debit, const CAmount& _credit, bool _spv = false):\n             hash(_hash), time(_time), type(_type), address(_address), debit(_debit), credit(_credit),\n             idx(0)\n     {\n@@ -125,7 +127,7 @@ class TransactionRecord\n \n     /** Whether the transaction was sent/received with a watch-only address */\n     bool involvesWatchAddress;\n-\n+    \n     /** Return the unique identifier for this transaction (part) */\n     QString getTxID() const;\n "
      },
      {
        "sha": "a4806053367014b58a03e11a0003ec598668a06c",
        "filename": "src/qt/transactiontablemodel.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/qt/transactiontablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/qt/transactiontablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiontablemodel.cpp?ref=96bdeffb78eecb7a82f7325272ed9374e8dcd782",
        "patch": "@@ -577,6 +577,12 @@ QVariant TransactionTableModel::data(const QModelIndex &index, int role) const\n         return formatTooltip(rec);\n     case Qt::TextAlignmentRole:\n         return column_alignments[index.column()];\n+    case Qt::BackgroundRole:\n+        if(rec->status.fSPV)\n+        {\n+            return COLOR_TX_STATUS_DANGER_BACKGROUND;\n+        }\n+        return QColor(255,255,255,255);\n     case Qt::ForegroundRole:\n         // Use the \"danger\" color for abandoned transactions\n         if(rec->status.status == TransactionStatus::Abandoned)"
      },
      {
        "sha": "53f6c6d6f25edb1b71a2152e6660169fc50c94ac",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=96bdeffb78eecb7a82f7325272ed9374e8dcd782",
        "patch": "@@ -132,7 +132,7 @@ UniValue generateBlocks(boost::shared_ptr<CReserveScript> coinbaseScript, int nG\n             continue;\n         }\n         CValidationState state;\n-        if (!ProcessNewBlock(state, Params(), NULL, pblock, true, NULL, false))\n+        if (!ProcessNewBlock(state, Params(), NULL, pblock, true, nullptr, NULL, false))\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"ProcessNewBlock, block not accepted\");\n         ++nHeight;\n         blockHashes.push_back(pblock->GetHash().GetHex());\n@@ -757,7 +757,7 @@ UniValue submitblock(const JSONRPCRequest& request)\n     CValidationState state;\n     submitblock_StateCatcher sc(block.GetHash());\n     RegisterValidationInterface(&sc);\n-    bool fAccepted = ProcessNewBlock(state, Params(), NULL, &block, true, NULL, false);\n+    bool fAccepted = ProcessNewBlock(state, Params(), NULL, &block, true, nullptr, NULL, false);\n     UnregisterValidationInterface(&sc);\n     if (fBlockPresent)\n     {"
      },
      {
        "sha": "3e74e337f033b34108b8ca01e1b479494b1dfb2b",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=96bdeffb78eecb7a82f7325272ed9374e8dcd782",
        "patch": "@@ -223,7 +223,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         pblock->hashMerkleRoot = BlockMerkleRoot(*pblock);\n         pblock->nNonce = blockinfo[i].nonce;\n         CValidationState state;\n-        BOOST_CHECK(ProcessNewBlock(state, chainparams, NULL, pblock, true, NULL, false));\n+        BOOST_CHECK(ProcessNewBlock(state, chainparams, NULL, pblock, true, nullptr, NULL, false));\n         BOOST_CHECK(state.IsValid());\n         pblock->hashPrevBlock = pblock->GetHash();\n     }"
      },
      {
        "sha": "27c95e2b04e48ade695343cc740c5a4a83ff24bc",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=96bdeffb78eecb7a82f7325272ed9374e8dcd782",
        "patch": "@@ -127,7 +127,7 @@ TestChain100Setup::CreateAndProcessBlock(const std::vector<CMutableTransaction>&\n     while (!CheckProofOfWork(block.GetHash(), block.nBits, chainparams.GetConsensus())) ++block.nNonce;\n \n     CValidationState state;\n-    ProcessNewBlock(state, chainparams, NULL, &block, true, NULL, false);\n+    ProcessNewBlock(state, chainparams, NULL, &block, true, nullptr, NULL, false);\n \n     CBlock result = block;\n     return result;"
      },
      {
        "sha": "f247b9ec3fbbbe5c138dca5bb3c443431afd7c98",
        "filename": "src/validationinterface.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/validationinterface.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/validationinterface.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.cpp?ref=96bdeffb78eecb7a82f7325272ed9374e8dcd782",
        "patch": "@@ -14,36 +14,42 @@ CMainSignals& GetMainSignals()\n \n void RegisterValidationInterface(CValidationInterface* pwalletIn) {\n     g_signals.UpdatedBlockTip.connect(boost::bind(&CValidationInterface::UpdatedBlockTip, pwalletIn, _1, _2, _3));\n-    g_signals.SyncTransaction.connect(boost::bind(&CValidationInterface::SyncTransaction, pwalletIn, _1, _2, _3));\n+    g_signals.SyncTransaction.connect(boost::bind(&CValidationInterface::SyncTransaction, pwalletIn, _1, _2, _3, _4));\n+    g_signals.FindTransaction.connect(boost::bind(&CValidationInterface::GetNonMempoolTransaction, pwalletIn, _1, _2));\n     g_signals.UpdatedTransaction.connect(boost::bind(&CValidationInterface::UpdatedTransaction, pwalletIn, _1));\n     g_signals.SetBestChain.connect(boost::bind(&CValidationInterface::SetBestChain, pwalletIn, _1));\n     g_signals.Inventory.connect(boost::bind(&CValidationInterface::Inventory, pwalletIn, _1));\n     g_signals.Broadcast.connect(boost::bind(&CValidationInterface::ResendWalletTransactions, pwalletIn, _1, _2));\n     g_signals.BlockChecked.connect(boost::bind(&CValidationInterface::BlockChecked, pwalletIn, _1, _2));\n     g_signals.ScriptForMining.connect(boost::bind(&CValidationInterface::GetScriptForMining, pwalletIn, _1));\n     g_signals.BlockFound.connect(boost::bind(&CValidationInterface::ResetRequestCount, pwalletIn, _1));\n+    g_signals.UpdatedBlockHeaderTip.connect(boost::bind(&CValidationInterface::UpdatedBlockHeaderTip, pwalletIn, _1, _2));\n }\n \n void UnregisterValidationInterface(CValidationInterface* pwalletIn) {\n+    g_signals.UpdatedBlockHeaderTip.disconnect(boost::bind(&CValidationInterface::UpdatedBlockHeaderTip, pwalletIn, _1, _2));\n     g_signals.BlockFound.disconnect(boost::bind(&CValidationInterface::ResetRequestCount, pwalletIn, _1));\n     g_signals.ScriptForMining.disconnect(boost::bind(&CValidationInterface::GetScriptForMining, pwalletIn, _1));\n     g_signals.BlockChecked.disconnect(boost::bind(&CValidationInterface::BlockChecked, pwalletIn, _1, _2));\n     g_signals.Broadcast.disconnect(boost::bind(&CValidationInterface::ResendWalletTransactions, pwalletIn, _1, _2));\n     g_signals.Inventory.disconnect(boost::bind(&CValidationInterface::Inventory, pwalletIn, _1));\n     g_signals.SetBestChain.disconnect(boost::bind(&CValidationInterface::SetBestChain, pwalletIn, _1));\n     g_signals.UpdatedTransaction.disconnect(boost::bind(&CValidationInterface::UpdatedTransaction, pwalletIn, _1));\n-    g_signals.SyncTransaction.disconnect(boost::bind(&CValidationInterface::SyncTransaction, pwalletIn, _1, _2, _3));\n+    g_signals.FindTransaction.disconnect(boost::bind(&CValidationInterface::GetNonMempoolTransaction, pwalletIn, _1, _2));\n+    g_signals.SyncTransaction.disconnect(boost::bind(&CValidationInterface::SyncTransaction, pwalletIn, _1, _2, _3, _4));\n     g_signals.UpdatedBlockTip.disconnect(boost::bind(&CValidationInterface::UpdatedBlockTip, pwalletIn, _1, _2, _3));\n }\n \n void UnregisterAllValidationInterfaces() {\n+    g_signals.UpdatedBlockHeaderTip.disconnect_all_slots();\n     g_signals.BlockFound.disconnect_all_slots();\n     g_signals.ScriptForMining.disconnect_all_slots();\n     g_signals.BlockChecked.disconnect_all_slots();\n     g_signals.Broadcast.disconnect_all_slots();\n     g_signals.Inventory.disconnect_all_slots();\n     g_signals.SetBestChain.disconnect_all_slots();\n     g_signals.UpdatedTransaction.disconnect_all_slots();\n+    g_signals.FindTransaction.disconnect_all_slots();\n     g_signals.SyncTransaction.disconnect_all_slots();\n     g_signals.UpdatedBlockTip.disconnect_all_slots();\n }"
      },
      {
        "sha": "d110629cf58ebe76894529d7d53aed1b1a4651a5",
        "filename": "src/validationinterface.h",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/validationinterface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/validationinterface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.h?ref=96bdeffb78eecb7a82f7325272ed9374e8dcd782",
        "patch": "@@ -32,7 +32,9 @@ void UnregisterAllValidationInterfaces();\n class CValidationInterface {\n protected:\n     virtual void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) {}\n-    virtual void SyncTransaction(const CTransaction &tx, const CBlockIndex *pindex, int posInBlock) {}\n+    virtual void UpdatedBlockHeaderTip(bool fInitialDownload, const CBlockIndex *pindexNew) {}\n+    virtual void SyncTransaction(const CTransaction &tx, const CBlockIndex *pindex, int posInBlock, bool validated = true) {}\n+    virtual void GetNonMempoolTransaction(const uint256 &hash, std::shared_ptr<const CTransaction> &txsp) {}\n     virtual void SetBestChain(const CBlockLocator &locator) {}\n     virtual void UpdatedTransaction(const uint256 &hash) {}\n     virtual void Inventory(const uint256 &hash) {}\n@@ -51,7 +53,9 @@ struct CMainSignals {\n     /** A posInBlock value for SyncTransaction which indicates the transaction was conflicted, disconnected, or not in a block */\n     static const int SYNC_TRANSACTION_NOT_IN_BLOCK = -1;\n     /** Notifies listeners of updated transaction data (transaction, and optionally the block it is found in. */\n-    boost::signals2::signal<void (const CTransaction &, const CBlockIndex *pindex, int posInBlock)> SyncTransaction;\n+    boost::signals2::signal<void (const CTransaction &, const CBlockIndex *pindex, int posInBlock, bool validated)> SyncTransaction;\n+    /** Notifies listeners of updated transaction data (transaction, and optionally the block it is found in. */\n+    boost::signals2::signal<void (const uint256 &, std::shared_ptr<const CTransaction> &)> FindTransaction;\n     /** Notifies listeners of an updated transaction without new data (for now: a coinbase potentially becoming visible). */\n     boost::signals2::signal<void (const uint256 &)> UpdatedTransaction;\n     /** Notifies listeners of a new active block chain. */\n@@ -66,6 +70,8 @@ struct CMainSignals {\n     boost::signals2::signal<void (boost::shared_ptr<CReserveScript>&)> ScriptForMining;\n     /** Notifies listeners that a block has been successfully mined */\n     boost::signals2::signal<void (const uint256 &)> BlockFound;\n+    /** Best header has changed */\n+    boost::signals2::signal<void (bool, const CBlockIndex *)> UpdatedBlockHeaderTip;\n };\n \n CMainSignals& GetMainSignals();"
      },
      {
        "sha": "08c85835be5c959bfaf36dcd1b49bb265a54c3e1",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 4,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=96bdeffb78eecb7a82f7325272ed9374e8dcd782",
        "patch": "@@ -5,6 +5,7 @@\n \n #include \"amount.h\"\n #include \"base58.h\"\n+#include \"blockrequest.h\"\n #include \"chain.h\"\n #include \"consensus/validation.h\"\n #include \"core_io.h\"\n@@ -89,6 +90,7 @@ void WalletTxToJSON(const CWalletTx& wtx, UniValue& entry)\n             rbfStatus = \"yes\";\n     }\n     entry.push_back(Pair(\"bip125-replaceable\", rbfStatus));\n+    entry.push_back(Pair(\"spv\", wtx.fSPV));\n \n     BOOST_FOREACH(const PAIRTYPE(string,string)& item, wtx.mapValue)\n         entry.push_back(Pair(item.first, item.second));\n@@ -583,7 +585,7 @@ UniValue getreceivedbyaddress(const JSONRPCRequest& request)\n     for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n     {\n         const CWalletTx& wtx = (*it).second;\n-        if (wtx.IsCoinBase() || !CheckFinalTx(wtx))\n+        if (wtx.IsCoinBase() || !CheckFinalTx(wtx, -1, wtx.fSPV))\n             continue;\n \n         BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n@@ -637,7 +639,7 @@ UniValue getreceivedbyaccount(const JSONRPCRequest& request)\n     for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n     {\n         const CWalletTx& wtx = (*it).second;\n-        if (wtx.IsCoinBase() || !CheckFinalTx(wtx))\n+        if (wtx.IsCoinBase() || !CheckFinalTx(wtx, -1, wtx.fSPV))\n             continue;\n \n         BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n@@ -701,7 +703,7 @@ UniValue getbalance(const JSONRPCRequest& request)\n         for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n         {\n             const CWalletTx& wtx = (*it).second;\n-            if (!CheckFinalTx(wtx) || wtx.GetBlocksToMaturity() > 0 || wtx.GetDepthInMainChain() < 0)\n+            if (!CheckFinalTx(wtx, -1, wtx.fSPV) || wtx.GetBlocksToMaturity() > 0 || wtx.GetDepthInMainChain() < 0)\n                 continue;\n \n             CAmount allFee;\n@@ -1149,7 +1151,7 @@ UniValue ListReceived(const UniValue& params, bool fByAccounts)\n     {\n         const CWalletTx& wtx = (*it).second;\n \n-        if (wtx.IsCoinBase() || !CheckFinalTx(wtx))\n+        if (wtx.IsCoinBase() || !CheckFinalTx(wtx, -1, wtx.fSPV))\n             continue;\n \n         int nDepth = wtx.GetDepthInMainChain();\n@@ -2313,6 +2315,26 @@ UniValue getwalletinfo(const JSONRPCRequest& request)\n     CKeyID masterKeyID = pwalletMain->GetHDChain().masterKeyID;\n     if (!masterKeyID.IsNull())\n          obj.push_back(Pair(\"hdmasterkeyid\", masterKeyID.GetHex()));\n+\n+\n+    std::shared_ptr<CBlockRequest> blockRequest = CBlockRequest::GetCurrentRequest();\n+    UniValue spvInfo(UniValue::VOBJ);\n+    spvInfo.push_back(Pair(\"enabled\", fUseSPV));\n+    spvInfo.push_back(Pair(\"hybrid_mode\", fAutodownloadBlocks));\n+    spvInfo.push_back(Pair(\"synced_up_to_height\", pwalletMain->nBestSpvHeight));\n+    spvInfo.push_back(Pair(\"best_known_header_height\", pindexBestHeader->nHeight));\n+    spvInfo.push_back(Pair(\"sync_in_progress\", (bool)(blockRequest)));\n+\n+    if (blockRequest)\n+    {\n+        spvInfo.push_back(Pair(\"started\", blockRequest->created));\n+        spvInfo.push_back(Pair(\"is_cancled\", (bool)blockRequest->isCancelled()));\n+        spvInfo.push_back(Pair(\"requested_blocks\", (int64_t)blockRequest->vBlocksToDownload.size()));\n+        spvInfo.push_back(Pair(\"loaded_blocks\", (int)blockRequest->amountOfBlocksLoaded()));\n+        spvInfo.push_back(Pair(\"processed_blocks\", (int64_t)blockRequest->processedUpToSize));\n+    }\n+\n+    obj.push_back(Pair(\"spv\", spvInfo));\n     return obj;\n }\n "
      },
      {
        "sha": "d42f32d8412cf4ee1e3a25beac5ef6b703c55bd2",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 220,
        "deletions": 11,
        "changes": 231,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=96bdeffb78eecb7a82f7325272ed9374e8dcd782",
        "patch": "@@ -6,6 +6,7 @@\n #include \"wallet/wallet.h\"\n \n #include \"base58.h\"\n+#include \"blockrequest.h\"\n #include \"checkpoints.h\"\n #include \"chain.h\"\n #include \"wallet/coincontrol.h\"\n@@ -26,6 +27,7 @@\n #include \"ui_interface.h\"\n #include \"utilmoneystr.h\"\n \n+\n #include <assert.h>\n \n #include <boost/algorithm/string/replace.hpp>\n@@ -59,6 +61,12 @@ CFeeRate CWallet::fallbackFee = CFeeRate(DEFAULT_FALLBACK_FEE);\n \n const uint256 CMerkleTx::ABANDON_HASH(uint256S(\"0000000000000000000000000000000000000000000000000000000000000001\"));\n \n+std::atomic<bool> fUseSPV(true);\n+std::atomic<bool> fSPVOnly(true);\n+\n+static const bool DEFAULT_ENABLE_HYBRID_SPV = false;\n+static const bool DEFAULT_ENABLE_PURE_SPV   = false;\n+\n /** @defgroup mapWallet\n  *\n  * @{\n@@ -917,6 +925,12 @@ bool CWallet::AddToWallet(const CWalletTx& wtxIn, bool fFlushOnClose)\n             wtx.fFromMe = wtxIn.fFromMe;\n             fUpdated = true;\n         }\n+        // If SPV mode has changed, update\n+        if (wtxIn.fSPV != wtx.fSPV)\n+        {\n+            wtx.fSPV = wtxIn.fSPV;\n+            fUpdated = true;\n+        }\n     }\n \n     //// debug print\n@@ -971,7 +985,7 @@ bool CWallet::LoadToWallet(const CWalletTx& wtxIn)\n  * pblock is optional, but should be provided if the transaction is known to be in a block.\n  * If fUpdate is true, existing transactions will be updated.\n  */\n-bool CWallet::AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlockIndex* pIndex, int posInBlock, bool fUpdate)\n+bool CWallet::AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlockIndex* pIndex, int posInBlock, bool fUpdate, bool fSPV)\n {\n     {\n         AssertLockHeld(cs_wallet);\n@@ -994,7 +1008,8 @@ bool CWallet::AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlockIndex\n         if (fExisted || IsMine(tx) || IsFromMe(tx))\n         {\n             CWalletTx wtx(this,tx);\n-\n+            // eventually set SPV mode\n+            wtx.fSPV = fSPV;\n             // Get merkle branch if transaction was found in a block\n             if (posInBlock != -1)\n                 wtx.SetMerkleBranch(pIndex, posInBlock);\n@@ -1122,11 +1137,20 @@ void CWallet::MarkConflicted(const uint256& hashBlock, const uint256& hashTx)\n     }\n }\n \n-void CWallet::SyncTransaction(const CTransaction& tx, const CBlockIndex *pindex, int posInBlock)\n+void CWallet::GetNonMempoolTransaction(const uint256 &hash, std::shared_ptr<const CTransaction> &txsp)\n+{\n+    map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(hash);\n+    if (mi != mapWallet.end())\n+    {\n+        txsp = std::make_shared<CTransaction>(mi->second);\n+    }\n+}\n+\n+void CWallet::SyncTransaction(const CTransaction& tx, const CBlockIndex *pindex, int posInBlock, bool validated)\n {\n     LOCK2(cs_main, cs_wallet);\n \n-    if (!AddToWalletIfInvolvingMe(tx, pindex, posInBlock, true))\n+    if (!AddToWalletIfInvolvingMe(tx, pindex, posInBlock, true, !validated))\n         return; // Not one of ours\n \n     // If a transaction changes 'conflicted' state, that changes the balance\n@@ -1139,6 +1163,82 @@ void CWallet::SyncTransaction(const CTransaction& tx, const CBlockIndex *pindex,\n     }\n }\n \n+void CWallet::UpdatedBlockHeaderTip(bool fInitialDownload, const CBlockIndex *pindexNew)\n+{\n+    int bestSPVBlockHeight = 0;\n+    {\n+        LOCK2(cs_main, cs_wallet);\n+        bestSPVBlockHeight = nBestSpvHeight;\n+    }\n+\n+    // check if the new tip extends the wallets current known best headers tip\n+    const CBlockIndex *pCurrent = pindexNew;\n+    bool fReorg = true;\n+    while (pCurrent)\n+    {\n+        if (pCurrent->GetBlockHash() == bestSpvBlockHash || bestSpvBlockHash.IsNull())\n+        {\n+            // new header tip extends the current headers chain, standard operation\n+            fReorg = false;\n+            break;\n+        }\n+        pCurrent = pCurrent->pprev;\n+    }\n+    if (fReorg)\n+    {\n+        // we are on a different chain, we don't know at which dept the fork happend\n+        // do a SPV rescan back to the oldest wtx time that was received from a block that now has been forked away\n+        CWalletDB walletdb(strWalletFile, \"r+\", false);\n+        int64_t rescanBackTo = std::numeric_limits<int64_t>::max();\n+        // the current wallets best header tip is not in the active headers chain\n+        for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        {\n+            CWalletTx* wtx = &(*it).second;\n+            if (wtx->fSPV)\n+            {\n+                bool found = false;\n+                const CBlockIndex *pCurrent = pindexNew;\n+                while (pCurrent)\n+                {\n+                    if (wtx->hashBlock == pCurrent->GetBlockHash())\n+                    {\n+                        found = true;\n+                        break;\n+                    }\n+                    pCurrent = pCurrent->pprev;\n+                }\n+                if (!found)\n+                {\n+                    if (wtx->GetTxTime() < rescanBackTo)\n+                        rescanBackTo = wtx->GetTxTime();\n+                    // wtx is no longer confirmed\n+                    wtx->hashBlock.SetNull();\n+                    wtx->MarkDirty();\n+                    walletdb.WriteTx(*wtx);\n+                }\n+            }\n+        }\n+        // try to find a reasonable height to spv-scan from again\n+        const CBlockIndex *pCurrent = pindexNew;\n+        nBestSpvHeight = 0;\n+        bestSpvBlockHash.SetNull();\n+        while (pCurrent)\n+        {\n+            if (pCurrent->GetBlockTime() < rescanBackTo)\n+            {\n+                nBestSpvHeight = pCurrent->nHeight;\n+                bestSpvBlockHash = pCurrent->GetBlockHash();\n+                break;\n+            }\n+            pCurrent = pCurrent->pprev;\n+        }\n+        if (nBestSpvHeight > 0 && rescanBackTo != std::numeric_limits<int64_t>::max())\n+            ScanSPV(rescanBackTo);\n+    }\n+    if (fUseSPV && pindexNew && pindexNew->nHeight > bestSPVBlockHeight)\n+        ScanSPV();\n+}\n+\n \n isminetype CWallet::IsMine(const CTxIn &txin) const\n {\n@@ -1544,7 +1644,7 @@ bool CWalletTx::RelayWalletTransaction(CConnman* connman)\n     assert(pwallet->GetBroadcastTransactions());\n     if (!IsCoinBase())\n     {\n-        if (GetDepthInMainChain() == 0 && !isAbandoned() && InMempool()) {\n+        if (GetDepthInMainChain() == 0 && !isAbandoned() && (InMempool() || fSPV)) {\n             LogPrintf(\"Relaying wtx %s\\n\", GetHash().ToString());\n             if (connman) {\n                 CInv inv(MSG_TX, GetHash());\n@@ -1743,7 +1843,7 @@ bool CWalletTx::InMempool() const\n bool CWalletTx::IsTrusted() const\n {\n     // Quick answer in most cases\n-    if (!CheckFinalTx(*this))\n+    if (!CheckFinalTx(*this, -1, fSPV))\n         return false;\n     int nDepth = GetDepthInMainChain();\n     if (nDepth >= 1)\n@@ -1862,7 +1962,7 @@ CAmount CWallet::GetUnconfirmedBalance() const\n         for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n         {\n             const CWalletTx* pcoin = &(*it).second;\n-            if (!pcoin->IsTrusted() && pcoin->GetDepthInMainChain() == 0 && pcoin->InMempool())\n+            if (!pcoin->IsTrusted() && pcoin->GetDepthInMainChain() == 0 && (pcoin->InMempool() || pcoin->fSPV))\n                 nTotal += pcoin->GetAvailableCredit();\n         }\n     }\n@@ -1939,7 +2039,7 @@ void CWallet::AvailableCoins(vector<COutput>& vCoins, bool fOnlyConfirmed, const\n             const uint256& wtxid = it->first;\n             const CWalletTx* pcoin = &(*it).second;\n \n-            if (!CheckFinalTx(*pcoin))\n+            if (!CheckFinalTx(*pcoin, -1, pcoin->fSPV))\n                 continue;\n \n             if (fOnlyConfirmed && !pcoin->IsTrusted())\n@@ -2256,6 +2356,9 @@ bool CWallet::CreateTransaction(const vector<CRecipient>& vecSend, CWalletTx& wt\n     wtxNew.BindWallet(this);\n     CMutableTransaction txNew;\n \n+    // set SPV flag if we are in SPV mode and the best spv header is higher then the chaintip\n+    wtxNew.fSPV = (fUseSPV && chainActive.Height() < nBestSpvHeight);\n+\n     // Discourage fee sniping.\n     //\n     // For a large miner the value of the transactions in the best block and\n@@ -2579,7 +2682,7 @@ bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey, CCon\n         if (fBroadcastTransactions)\n         {\n             // Broadcast\n-            if (!wtxNew.AcceptToMemoryPool(maxTxFee, state)) {\n+            if (!wtxNew.fSPV && !wtxNew.AcceptToMemoryPool(maxTxFee, state)) {\n                 // This must not fail. The transaction has already been signed and recorded.\n                 LogPrintf(\"CommitTransaction(): Error: Transaction not valid, %s\\n\", state.GetRejectReason());\n                 return false;\n@@ -2929,7 +3032,7 @@ std::map<CTxDestination, CAmount> CWallet::GetAddressBalances()\n         {\n             CWalletTx *pcoin = &walletEntry.second;\n \n-            if (!CheckFinalTx(*pcoin) || !pcoin->IsTrusted())\n+            if (!CheckFinalTx(*pcoin, -1, pcoin->fSPV) || !pcoin->IsTrusted())\n                 continue;\n \n             if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0)\n@@ -3066,7 +3169,7 @@ CAmount CWallet::GetAccountBalance(CWalletDB& walletdb, const std::string& strAc\n     for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n     {\n         const CWalletTx& wtx = (*it).second;\n-        if (!CheckFinalTx(wtx) || wtx.GetBlocksToMaturity() > 0 || wtx.GetDepthInMainChain() < 0)\n+        if (!CheckFinalTx(wtx, -1, wtx.fSPV) || wtx.GetBlocksToMaturity() > 0 || wtx.GetDepthInMainChain() < 0)\n             continue;\n \n         CAmount nReceived, nSent, nFee;\n@@ -3352,6 +3455,8 @@ std::string CWallet::GetWalletHelpString(bool showDebug)\n     if (showDebug)\n         strUsage += HelpMessageOpt(\"-sendfreetransactions\", strprintf(_(\"Send transactions as zero-fee transactions if possible (default: %u)\"), DEFAULT_SEND_FREE_TRANSACTIONS));\n     strUsage += HelpMessageOpt(\"-spendzeroconfchange\", strprintf(_(\"Spend unconfirmed change when sending transactions (default: %u)\"), DEFAULT_SPEND_ZEROCONF_CHANGE));\n+    strUsage += HelpMessageOpt(\"-spv\", strprintf(_(\"Use hybrid SPV mode to show transactions before verification (default: %u)\"), DEFAULT_ENABLE_HYBRID_SPV));\n+    strUsage += HelpMessageOpt(\"-spvonly\", strprintf(_(\"Use hybrid SPV mode to show transactions before verification (default: %u)\"), DEFAULT_ENABLE_HYBRID_SPV));\n     strUsage += HelpMessageOpt(\"-txconfirmtarget=<n>\", strprintf(_(\"If paytxfee is not set, include enough fee so transactions begin confirmation on average within n blocks (default: %u)\"), DEFAULT_TX_CONFIRM_TARGET));\n     strUsage += HelpMessageOpt(\"-usehd\", _(\"Use hierarchical deterministic key generation (HD) after BIP32. Only has effect during wallet creation/first start\") + \" \" + strprintf(_(\"(default: %u)\"), DEFAULT_USE_HD_WALLET));\n     strUsage += HelpMessageOpt(\"-walletrbf\", strprintf(_(\"Send transactions with full-RBF opt-in enabled (default: %u)\"), DEFAULT_WALLET_RBF));\n@@ -3535,6 +3640,14 @@ bool CWallet::InitLoadWallet()\n             }\n         }\n     }\n+    // check if we need to request blocks for hybrid SPV\n+    walletInstance->nBestSpvHeight = 0;\n+    CWalletDB walletdb(walletFile);\n+    walletdb.ReadBestSPVHeight(walletInstance->nBestSpvHeight);\n+    walletdb.ReadBestSPVBlockHash(walletInstance->bestSpvBlockHash);\n+    if (fUseSPV)\n+        walletInstance->ScanSPV();\n+    \n     walletInstance->SetBroadcastTransactions(GetBoolArg(\"-walletbroadcast\", DEFAULT_WALLETBROADCAST));\n \n     {\n@@ -3632,9 +3745,103 @@ bool CWallet::ParameterInteraction()\n     fSendFreeTransactions = GetBoolArg(\"-sendfreetransactions\", DEFAULT_SEND_FREE_TRANSACTIONS);\n     fWalletRbf = GetBoolArg(\"-walletrbf\", DEFAULT_WALLET_RBF);\n \n+    if (GetBoolArg(\"-spvonly\", DEFAULT_ENABLE_PURE_SPV) && SoftSetBoolArg(\"-spv\", true)) {\n+        LogPrintf(\"%s: parameter interaction: -spvonly=1 -> setting -spv=1\\n\", __func__);\n+    }\n+\n+    // if using block pruning, then disallow spv\n+    if (GetArg(\"-prune\", 0)) {\n+        if (GetBoolArg(\"-spv\", DEFAULT_ENABLE_HYBRID_SPV) || GetBoolArg(\"-spvonly\", DEFAULT_ENABLE_HYBRID_SPV))\n+            return InitError(_(\"Prune mode is incompatible with -spv|-spvonly.\"));\n+    }\n+\n+    fUseSPV = GetBoolArg(\"-spv\", DEFAULT_ENABLE_HYBRID_SPV);\n+    fAutodownloadBlocks = !GetBoolArg(\"-spvonly\", DEFAULT_ENABLE_PURE_SPV);\n+\n     return true;\n }\n \n+void CWallet::ScanSPV(int64_t optional_timestamp)\n+{\n+    CBlockIndex *pIndex = NULL;\n+    CBlockIndex *chainActiveTip = NULL;\n+    // calculate the oldest key and don't use nTimeFirstKey\n+    // adding WatchOnly addresses will result in nTimeFirstKey == 1\n+    int64_t oldest_key = std::numeric_limits<int64_t>::max();;\n+\n+    int bestWalletSPVHeight = 0;\n+    {\n+        LOCK2(cs_main, cs_wallet);\n+        bestWalletSPVHeight = nBestSpvHeight;\n+        chainActiveTip = chainActive.Tip();\n+        std::map<CKeyID, int64_t> mapKeyBirth;\n+        GetKeyBirthTimes(mapKeyBirth);\n+        for (std::map<CKeyID, int64_t>::const_iterator it = mapKeyBirth.begin(); it != mapKeyBirth.end(); it++) {\n+            if ((*it).second < oldest_key)\n+                oldest_key = (*it).second;\n+        }\n+\n+        pIndex = pindexBestHeader;\n+    }\n+    \n+    if (optional_timestamp > 0)\n+    {\n+        oldest_key = optional_timestamp;\n+        bestWalletSPVHeight = 0;\n+    }\n+\n+    // find header\n+    if (!pIndex)\n+        return;\n+\n+    std::vector<CBlockIndex*> blocksToDownload;\n+    do {\n+        if (pIndex == chainActiveTip)\n+            break;\n+\n+        // don't request blocks that are already scanned\n+        if (pIndex->nHeight <= bestWalletSPVHeight)\n+            break;\n+\n+        // check if pIndex is still relevant for this wallet\n+        if (pIndex->GetBlockTime() + 7200 < oldest_key)\n+            break;\n+\n+        // block is relevant, make sure we download this block in full-block SPV mode\n+        blocksToDownload.push_back(pIndex);\n+\n+        // traverse\n+        pIndex = pIndex->pprev;\n+    } while (pIndex->pprev);\n+\n+    // don't create empty CBlockRequests\n+    if (blocksToDownload.size() == 0)\n+        return;\n+\n+    // reverse the blocks vector from older->newer\n+    std::reverse(blocksToDownload.begin(), blocksToDownload.end());\n+    // create an spv request\n+    std::shared_ptr<CBlockRequest> spvRequest(new CBlockRequest(blocksToDownload, GetAdjustedTime(), [this](std::shared_ptr<CBlockRequest> cb_spvRequest, CBlockIndex *pindex) -> bool {\n+\n+        LOCK(cs_wallet);\n+        if (cb_spvRequest && pindex && pindex->nHeight > nBestSpvHeight)\n+        {\n+            nBestSpvHeight = pindex->nHeight;\n+            bestSpvBlockHash = pindex->GetBlockHash();\n+\n+            // write best known height in case of an SPV block\n+            CWalletDB walletdb(strWalletFile);\n+            walletdb.WriteBestSPVHeight(nBestSpvHeight);\n+            walletdb.WriteBestSPVBlockHash(bestSpvBlockHash);\n+        }\n+\n+        // continue the spv request\n+        return true;\n+    }));\n+    // set the global SPV Request\n+    spvRequest->setAsCurrentRequest();\n+}\n+\n bool CWallet::BackupWallet(const std::string& strDest)\n {\n     if (!fFileBacked)\n@@ -3721,6 +3928,8 @@ int CMerkleTx::GetDepthInMainChain(const CBlockIndex* &pindexRet) const\n     if (mi == mapBlockIndex.end())\n         return 0;\n     CBlockIndex* pindex = (*mi).second;\n+    if (fSPV)\n+        return pindexBestHeader->nHeight - pindex->nHeight + 1;\n     if (!pindex || !chainActive.Contains(pindex))\n         return 0;\n "
      },
      {
        "sha": "e84719ef1f0984690e737aba493127d241b8b140",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 25,
        "deletions": 4,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=96bdeffb78eecb7a82f7325272ed9374e8dcd782",
        "patch": "@@ -18,6 +18,7 @@\n #include \"wallet/rpcwallet.h\"\n \n #include <algorithm>\n+#include <atomic>\n #include <map>\n #include <set>\n #include <stdexcept>\n@@ -66,6 +67,11 @@ static const bool DEFAULT_USE_HD_WALLET = true;\n \n extern const char * DEFAULT_WALLET_DAT;\n \n+//! global var to define if we are using hybrid SPV\n+extern std::atomic<bool> fUseSPV;\n+//! global var to define if we are using pure SPV (no validation)\n+extern std::atomic<bool> fSPVOnly;\n+\n class CBlockIndex;\n class CCoinControl;\n class COutput;\n@@ -175,6 +181,7 @@ class CMerkleTx : public CTransaction\n      * compatibility.\n      */\n     int nIndex;\n+    bool fSPV;\n \n     CMerkleTx()\n     {\n@@ -328,6 +335,9 @@ class CWalletTx : public CMerkleTx\n \n             if (nTimeSmart)\n                 mapValue[\"timesmart\"] = strprintf(\"%u\", nTimeSmart);\n+\n+            if (fSPV)\n+                mapValue[\"mode\"] = \"spv\";\n         }\n \n         READWRITE(*(CMerkleTx*)this);\n@@ -347,13 +357,16 @@ class CWalletTx : public CMerkleTx\n             ReadOrderPos(nOrderPos, mapValue);\n \n             nTimeSmart = mapValue.count(\"timesmart\") ? (unsigned int)atoi64(mapValue[\"timesmart\"]) : 0;\n+\n+            fSPV = (mapValue.count(\"mode\") && mapValue[\"mode\"] == \"spv\") ? true : false;\n         }\n \n         mapValue.erase(\"fromaccount\");\n         mapValue.erase(\"version\");\n         mapValue.erase(\"spent\");\n         mapValue.erase(\"n\");\n         mapValue.erase(\"timesmart\");\n+        mapValue.erase(\"mode\");\n     }\n \n     //! make sure balances are recalculated\n@@ -394,7 +407,7 @@ class CWalletTx : public CMerkleTx\n     {\n         return (GetDebit(filter) > 0);\n     }\n-\n+    \n     // True if only scriptSigs are different\n     bool IsEquivalentTo(const CWalletTx& tx) const;\n \n@@ -616,7 +629,9 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     typedef std::map<unsigned int, CMasterKey> MasterKeyMap;\n     MasterKeyMap mapMasterKeys;\n     unsigned int nMasterKeyMaxID;\n-\n+    int nBestSpvHeight;\n+    uint256 bestSpvBlockHash;\n+    \n     CWallet()\n     {\n         SetNull();\n@@ -648,6 +663,7 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n         nLastResend = 0;\n         nTimeFirstKey = 0;\n         fBroadcastTransactions = false;\n+        nBestSpvHeight = 0;\n     }\n \n     std::map<uint256, CWalletTx> mapWallet;\n@@ -749,8 +765,12 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     void MarkDirty();\n     bool AddToWallet(const CWalletTx& wtxIn, bool fFlushOnClose=true);\n     bool LoadToWallet(const CWalletTx& wtxIn);\n-    void SyncTransaction(const CTransaction& tx, const CBlockIndex *pindex, int posInBlock);\n-    bool AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlockIndex* pIndex, int posInBlock, bool fUpdate);\n+    void GetNonMempoolTransaction(const uint256 &hash, std::shared_ptr<const CTransaction> &txsp);\n+    void SyncTransaction(const CTransaction& tx, const CBlockIndex *pindex, int posInBlock, bool validated);\n+    \n+    void UpdatedBlockHeaderTip(bool fInitialDownload, const CBlockIndex *pindexNew);\n+\n+    bool AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlockIndex* pIndex, int posInBlock, bool fUpdate, bool fSPV = false);\n     int ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate = false);\n     void ReacceptWalletTransactions();\n     void ResendWalletTransactions(int64_t nBestBlockTime, CConnman* connman);\n@@ -922,6 +942,7 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     /* Wallets parameter interaction */\n     static bool ParameterInteraction();\n \n+    void ScanSPV(int64_t optional_timestamp = 0);\n     bool BackupWallet(const std::string& strDest);\n \n     /* Set the HD chain model (chain child index counters) */"
      },
      {
        "sha": "1bf7ac18e9451b70838dc6712151682dad996c5f",
        "filename": "src/wallet/walletdb.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/wallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/wallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.cpp?ref=96bdeffb78eecb7a82f7325272ed9374e8dcd782",
        "patch": "@@ -141,6 +141,28 @@ bool CWalletDB::ReadBestBlock(CBlockLocator& locator)\n     return Read(std::string(\"bestblock_nomerkle\"), locator);\n }\n \n+bool CWalletDB::WriteBestSPVHeight(int nHeight)\n+{\n+    nWalletDBUpdated++;\n+    return Write(std::string(\"bestspvheight\"), nHeight);\n+}\n+\n+bool CWalletDB::ReadBestSPVHeight(int& nHeight)\n+{\n+    return Read(std::string(\"bestspvheight\"), nHeight);\n+}\n+\n+bool CWalletDB::WriteBestSPVBlockHash(const uint256 hash)\n+{\n+    nWalletDBUpdated++;\n+    return Write(std::string(\"bestspvblockhash\"), hash);\n+}\n+\n+bool CWalletDB::ReadBestSPVBlockHash(uint256& hash)\n+{\n+    return Read(std::string(\"bestspvblockhash\"), hash);\n+}\n+\n bool CWalletDB::WriteOrderPosNext(int64_t nOrderPosNext)\n {\n     nWalletDBUpdated++;"
      },
      {
        "sha": "7c693b6d3ba75c837803aa1129d371f44eafea56",
        "filename": "src/wallet/walletdb.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/wallet/walletdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/wallet/walletdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.h?ref=96bdeffb78eecb7a82f7325272ed9374e8dcd782",
        "patch": "@@ -141,6 +141,11 @@ class CWalletDB : public CDB\n     bool WriteBestBlock(const CBlockLocator& locator);\n     bool ReadBestBlock(CBlockLocator& locator);\n \n+    bool WriteBestSPVHeight(int nHeight);\n+    bool ReadBestSPVHeight(int& nHeight);\n+    bool WriteBestSPVBlockHash(const uint256 hash);\n+    bool ReadBestSPVBlockHash(uint256 &hash);\n+\n     bool WriteOrderPosNext(int64_t nOrderPosNext);\n \n     bool WriteDefaultKey(const CPubKey& vchPubKey);"
      },
      {
        "sha": "9d53304dea490f8a558d1a5c46cc702a0f8ad932",
        "filename": "src/zmq/zmqnotificationinterface.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/zmq/zmqnotificationinterface.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/zmq/zmqnotificationinterface.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/zmq/zmqnotificationinterface.cpp?ref=96bdeffb78eecb7a82f7325272ed9374e8dcd782",
        "patch": "@@ -144,8 +144,12 @@ void CZMQNotificationInterface::UpdatedBlockTip(const CBlockIndex *pindexNew, co\n     }\n }\n \n-void CZMQNotificationInterface::SyncTransaction(const CTransaction& tx, const CBlockIndex* pindex, int posInBlock)\n+void CZMQNotificationInterface::SyncTransaction(const CTransaction& tx, const CBlockIndex* pindex, int posInBlock, bool validated)\n {\n+    // don't post non-validated tx for now\n+    if (!validated)\n+        return;\n+\n     for (std::list<CZMQAbstractNotifier*>::iterator i = notifiers.begin(); i!=notifiers.end(); )\n     {\n         CZMQAbstractNotifier *notifier = *i;"
      },
      {
        "sha": "8a3ed36086116314f31f18666a2b8c6a58c8467b",
        "filename": "src/zmq/zmqnotificationinterface.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/zmq/zmqnotificationinterface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96bdeffb78eecb7a82f7325272ed9374e8dcd782/src/zmq/zmqnotificationinterface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/zmq/zmqnotificationinterface.h?ref=96bdeffb78eecb7a82f7325272ed9374e8dcd782",
        "patch": "@@ -24,7 +24,7 @@ class CZMQNotificationInterface : public CValidationInterface\n     void Shutdown();\n \n     // CValidationInterface\n-    void SyncTransaction(const CTransaction& tx, const CBlockIndex *pindex, int posInBlock);\n+    void SyncTransaction(const CTransaction& tx, const CBlockIndex *pindex, int posInBlock, bool validated);\n     void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload);\n \n private:"
      }
    ]
  }
]