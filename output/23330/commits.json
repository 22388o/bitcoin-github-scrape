[
  {
    "sha": "b13b8ca3be326a7c98689d50f148bcc4d93f6c87",
    "node_id": "C_kwDOABII59oAKGIxM2I4Y2EzYmUzMjZhN2M5ODY4OWQ1MGYxNDhiY2M0ZDkzZjZjODc",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "j@rubin.io",
        "date": "2021-10-20T22:32:44Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "j@rubin.io",
        "date": "2021-10-21T15:25:25Z"
      },
      "message": "[RPC] allow fetching headers by pages",
      "tree": {
        "sha": "00be1850b40fdb219db3edaf8f0c14c3ff61bb65",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/00be1850b40fdb219db3edaf8f0c14c3ff61bb65"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b13b8ca3be326a7c98689d50f148bcc4d93f6c87",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b13b8ca3be326a7c98689d50f148bcc4d93f6c87",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b13b8ca3be326a7c98689d50f148bcc4d93f6c87",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b13b8ca3be326a7c98689d50f148bcc4d93f6c87/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "986003aff93c099c400c9285b4a2ed63f4b3f180",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/986003aff93c099c400c9285b4a2ed63f4b3f180",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/986003aff93c099c400c9285b4a2ed63f4b3f180"
      }
    ],
    "stats": {
      "total": 73,
      "additions": 63,
      "deletions": 10
    },
    "files": [
      {
        "sha": "7d648e64eb7ac454026b85994f8512964aa0935a",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 63,
        "deletions": 10,
        "changes": 73,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b13b8ca3be326a7c98689d50f148bcc4d93f6c87/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b13b8ca3be326a7c98689d50f148bcc4d93f6c87/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=b13b8ca3be326a7c98689d50f148bcc4d93f6c87",
        "patch": "@@ -840,9 +840,10 @@ static RPCHelpMan getblockheader()\n                 {\n                     {\"blockhash\", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, \"The block hash\"},\n                     {\"verbose\", RPCArg::Type::BOOL, RPCArg::Default{true}, \"true for a json object, false for the hex-encoded data\"},\n+                    {\"count\", RPCArg::Type::NUM, RPCArg::Default{0}, \"Number of headers to retrieve (backwards including blockhash), stops at genesis. If 0, one header will be returned not in an array. Max Value = 2000.\"},\n                 },\n                 {\n-                    RPCResult{\"for verbose = true\",\n+                    RPCResult{\"for verbose = true, count = 0\",\n                         RPCResult::Type::OBJ, \"\", \"\",\n                         {\n                             {RPCResult::Type::STR_HEX, \"hash\", \"the block hash (same as provided)\"},\n@@ -860,9 +861,35 @@ static RPCHelpMan getblockheader()\n                             {RPCResult::Type::NUM, \"nTx\", \"The number of transactions in the block\"},\n                             {RPCResult::Type::STR_HEX, \"previousblockhash\", /* optional */ true, \"The hash of the previous block (if available)\"},\n                             {RPCResult::Type::STR_HEX, \"nextblockhash\", /* optional */ true, \"The hash of the next block (if available)\"},\n-                        }},\n-                    RPCResult{\"for verbose=false\",\n+                        }\n+                    },\n+                    RPCResult{\"for verbose=false, count = 0\",\n                         RPCResult::Type::STR_HEX, \"\", \"A string that is serialized, hex-encoded data for block 'hash'\"},\n+                    RPCResult{\"for verbose = true, count > 0\",\n+                        RPCResult::Type::ARR, \"\", \"\",\n+                        {\n+                            RPCResult{RPCResult::Type::OBJ, \"\", \"\",\n+                            {\n+                                {RPCResult::Type::STR_HEX, \"hash\", \"the block hash (same as provided)\"},\n+                                {RPCResult::Type::NUM, \"confirmations\", \"The number of confirmations, or -1 if the block is not on the main chain\"},\n+                                {RPCResult::Type::NUM, \"height\", \"The block height or index\"},\n+                                {RPCResult::Type::NUM, \"version\", \"The block version\"},\n+                                {RPCResult::Type::STR_HEX, \"versionHex\", \"The block version formatted in hexadecimal\"},\n+                                {RPCResult::Type::STR_HEX, \"merkleroot\", \"The merkle root\"},\n+                                {RPCResult::Type::NUM_TIME, \"time\", \"The block time expressed in \" + UNIX_EPOCH_TIME},\n+                                {RPCResult::Type::NUM_TIME, \"mediantime\", \"The median block time expressed in \" + UNIX_EPOCH_TIME},\n+                                {RPCResult::Type::NUM, \"nonce\", \"The nonce\"},\n+                                {RPCResult::Type::STR_HEX, \"bits\", \"The bits\"},\n+                                {RPCResult::Type::NUM, \"difficulty\", \"The difficulty\"},\n+                                {RPCResult::Type::STR_HEX, \"chainwork\", \"Expected number of hashes required to produce the current chain\"},\n+                                {RPCResult::Type::NUM, \"nTx\", \"The number of transactions in the block\"},\n+                                {RPCResult::Type::STR_HEX, \"previousblockhash\", /* optional */ true, \"The hash of the previous block (if available)\"},\n+                                {RPCResult::Type::STR_HEX, \"nextblockhash\", /* optional */ true, \"The hash of the next block (if available)\"},\n+                            }}\n+                        },\n+                    },\n+                    RPCResult{\"for verbose=false, count > 0\",\n+                         RPCResult::Type::STR_HEX, \"\", \"A string that is serialized, hex-encoded data for blocks 'hash' and count prior\"},\n                 },\n                 RPCExamples{\n                     HelpExampleCli(\"getblockheader\", \"\\\"00000000c937983704a73af28acdec37b049d214adbda81d7e2a3dd146f6ed09\\\"\")\n@@ -876,6 +903,14 @@ static RPCHelpMan getblockheader()\n     if (!request.params[1].isNull())\n         fVerbose = request.params[1].get_bool();\n \n+    int count = 0;\n+    if (!request.params[2].isNull())\n+        count = request.params[2].get_int();\n+    if (count < 0)\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Count must be >= 0\");\n+    if (count > 2000)\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Count must be <= 2000\");\n+\n     const CBlockIndex* pblockindex;\n     const CBlockIndex* tip;\n     {\n@@ -889,15 +924,33 @@ static RPCHelpMan getblockheader()\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n     }\n \n-    if (!fVerbose)\n-    {\n-        CDataStream ssBlock(SER_NETWORK, PROTOCOL_VERSION);\n-        ssBlock << pblockindex->GetBlockHeader();\n-        std::string strHex = HexStr(ssBlock);\n-        return strHex;\n+    if (count == 0) {\n+        if (!fVerbose)\n+        {\n+            CDataStream ssBlock(SER_NETWORK, PROTOCOL_VERSION);\n+            ssBlock << pblockindex->GetBlockHeader();\n+            std::string strHex = HexStr(ssBlock);\n+            return strHex;\n+        } else {\n+            return blockheaderToJSON(tip, pblockindex);\n+        }\n+    } else {\n+        if (!fVerbose) {\n+            CDataStream ssBlocks(SER_NETWORK, PROTOCOL_VERSION);\n+            for (int i = 0; i < count && pblockindex != nullptr; ++i, pblockindex = pblockindex->pprev) {\n+                ssBlocks << pblockindex->GetBlockHeader();\n+            }\n+            std::string strHex = HexStr(ssBlocks);\n+            return strHex;\n+        } else {\n+            UniValue res(UniValue::VARR);\n+            for (int i = 0; i < count && pblockindex != nullptr; ++i, pblockindex = pblockindex->pprev){\n+                res.push_back(blockheaderToJSON(tip, pblockindex));\n+            }\n+            return res;\n+        }\n     }\n \n-    return blockheaderToJSON(tip, pblockindex);\n },\n     };\n }"
      }
    ]
  }
]