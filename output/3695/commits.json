[
  {
    "sha": "deb3572ab160221124dfa3e9c5c4e493529f59e4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkZWIzNTcyYWIxNjAyMjExMjRkZmEzZTljNWM0ZTQ5MzUyOWY1OWU0",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2014-02-17T16:35:40Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2014-05-13T05:23:23Z"
      },
      "message": "Add -rpcbind option to allow binding RPC port on a specific interface\n\nAdd -rpcbind command option to specify binding RPC service on one\nor multiple specific interfaces.\n\nFunctionality if -rpcbind is not specified remains the same as before:\n\n- If no -rpcallowip specified, bind on localhost\n- If no -rpcbind specified, bind on any interface\n\nImplements part of #3111.",
      "tree": {
        "sha": "faf1d8bd451deea0bb030c69ca119f4f22eb3e4e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/faf1d8bd451deea0bb030c69ca119f4f22eb3e4e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/deb3572ab160221124dfa3e9c5c4e493529f59e4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/deb3572ab160221124dfa3e9c5c4e493529f59e4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/deb3572ab160221124dfa3e9c5c4e493529f59e4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/deb3572ab160221124dfa3e9c5c4e493529f59e4/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fa41db8779a64afd3109b86ab24f948202d237d9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa41db8779a64afd3109b86ab24f948202d237d9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fa41db8779a64afd3109b86ab24f948202d237d9"
      }
    ],
    "stats": {
      "total": 98,
      "additions": 62,
      "deletions": 36
    },
    "files": [
      {
        "sha": "766498876283d77817d9a8316677b0c0f1c3aca1",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/deb3572ab160221124dfa3e9c5c4e493529f59e4/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/deb3572ab160221124dfa3e9c5c4e493529f59e4/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=deb3572ab160221124dfa3e9c5c4e493529f59e4",
        "patch": "@@ -304,10 +304,11 @@ std::string HelpMessage(HelpMessageMode hmm)\n \n     strUsage += \"\\n\" + _(\"RPC server options:\") + \"\\n\";\n     strUsage += \"  -server                \" + _(\"Accept command line and JSON-RPC commands\") + \"\\n\";\n+    strUsage += \"  -rpcbind=<addr>        \" + _(\"Bind to given address to listen for JSON-RPC connections. Use [host]:port notation for IPv6. This option can be specified multiple times (default: bind to all interfaces)\") + \"\\n\";\n     strUsage += \"  -rpcuser=<user>        \" + _(\"Username for JSON-RPC connections\") + \"\\n\";\n     strUsage += \"  -rpcpassword=<pw>      \" + _(\"Password for JSON-RPC connections\") + \"\\n\";\n     strUsage += \"  -rpcport=<port>        \" + _(\"Listen for JSON-RPC connections on <port> (default: 8332 or testnet: 18332)\") + \"\\n\";\n-    strUsage += \"  -rpcallowip=<ip>       \" + _(\"Allow JSON-RPC connections from specified IP address\") + \"\\n\";\n+    strUsage += \"  -rpcallowip=<ip>       \" + _(\"Allow JSON-RPC connections from specified IP address. This option can be specified multiple times\") + \"\\n\";\n     strUsage += \"  -rpcthreads=<n>        \" + _(\"Set the number of threads to service RPC calls (default: 4)\") + \"\\n\";\n \n     strUsage += \"\\n\" + _(\"RPC SSL options: (see the Bitcoin Wiki for SSL setup instructions)\") + \"\\n\";"
      },
      {
        "sha": "2534a9dcf41fcbf0a9771f66ca0cfd3941e1d474",
        "filename": "src/rpcserver.cpp",
        "status": "modified",
        "additions": 60,
        "deletions": 35,
        "changes": 95,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/deb3572ab160221124dfa3e9c5c4e493529f59e4/src/rpcserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/deb3572ab160221124dfa3e9c5c4e493529f59e4/src/rpcserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcserver.cpp?ref=deb3572ab160221124dfa3e9c5c4e493529f59e4",
        "patch": "@@ -508,6 +508,14 @@ static void RPCAcceptHandler(boost::shared_ptr< basic_socket_acceptor<Protocol,\n     }\n }\n \n+static ip::tcp::endpoint ParseEndpoint(const std::string &strEndpoint, int defaultPort)\n+{\n+    std::string addr;\n+    int port = defaultPort;\n+    SplitHostPort(strEndpoint, port, addr);\n+    return ip::tcp::endpoint(asio::ip::address::from_string(addr), port);\n+}\n+\n void StartRPCThreads()\n {\n     rpc_allow_subnets.clear();\n@@ -589,57 +597,74 @@ void StartRPCThreads()\n         SSL_CTX_set_cipher_list(rpc_ssl_context->impl(), strCiphers.c_str());\n     }\n \n-    // Try a dual IPv6/IPv4 socket, falling back to separate IPv4 and IPv6 sockets\n-    const bool loopback = !mapArgs.count(\"-rpcallowip\");\n-    asio::ip::address bindAddress = loopback ? asio::ip::address_v6::loopback() : asio::ip::address_v6::any();\n-    ip::tcp::endpoint endpoint(bindAddress, GetArg(\"-rpcport\", Params().RPCPort()));\n-    boost::system::error_code v6_only_error;\n+    std::vector<ip::tcp::endpoint> vEndpoints;\n+    bool bBindAny = false;\n+    int defaultPort = GetArg(\"-rpcport\", Params().RPCPort());\n+    if (!mapArgs.count(\"-rpcallowip\")) // Default to loopback if not allowing external IPs\n+    {\n+        vEndpoints.push_back(ip::tcp::endpoint(asio::ip::address_v6::loopback(), defaultPort));\n+        vEndpoints.push_back(ip::tcp::endpoint(asio::ip::address_v4::loopback(), defaultPort));\n+        if (mapArgs.count(\"-rpcbind\"))\n+        {\n+            LogPrintf(\"WARNING: option -rpcbind was ignored because -rpcallowip was not specified, refusing to allow everyone to connect\\n\");\n+        }\n+    } else if (mapArgs.count(\"-rpcbind\")) // Specific bind address\n+    {\n+        BOOST_FOREACH(const std::string &addr, mapMultiArgs[\"-rpcbind\"])\n+        {\n+            try {\n+                vEndpoints.push_back(ParseEndpoint(addr, defaultPort));\n+            }\n+            catch(boost::system::system_error &e)\n+            {\n+                uiInterface.ThreadSafeMessageBox(\n+                    strprintf(_(\"Could not parse -rpcbind value %s as network address\"), addr),\n+                    \"\", CClientUIInterface::MSG_ERROR);\n+                StartShutdown();\n+                return;\n+            }\n+        }\n+    } else { // No specific bind address specified, bind to any\n+        vEndpoints.push_back(ip::tcp::endpoint(asio::ip::address_v6::any(), defaultPort));\n+        vEndpoints.push_back(ip::tcp::endpoint(asio::ip::address_v4::any(), defaultPort));\n+        // Prefer making the socket dual IPv6/IPv4 instead of binding\n+        // to both addresses seperately.\n+        bBindAny = true;\n+    }\n \n     bool fListening = false;\n     std::string strerr;\n-    try\n+    BOOST_FOREACH(const ip::tcp::endpoint &endpoint, vEndpoints)\n     {\n+        asio::ip::address bindAddress = endpoint.address();\n+        LogPrintf(\"Binding RPC on address %s port %i (IPv4+IPv6 bind any: %i)\\n\", bindAddress.to_string(), endpoint.port(), bBindAny);\n+        boost::system::error_code v6_only_error;\n         boost::shared_ptr<ip::tcp::acceptor> acceptor(new ip::tcp::acceptor(*rpc_io_service));\n         rpc_acceptors.push_back(acceptor);\n-        acceptor->open(endpoint.protocol());\n-        acceptor->set_option(boost::asio::ip::tcp::acceptor::reuse_address(true));\n-\n-        // Try making the socket dual IPv6/IPv4 (if listening on the \"any\" address)\n-        acceptor->set_option(boost::asio::ip::v6_only(loopback), v6_only_error);\n-\n-        acceptor->bind(endpoint);\n-        acceptor->listen(socket_base::max_connections);\n-\n-        RPCListen(acceptor, *rpc_ssl_context, fUseSSL);\n-\n-        fListening = true;\n-    }\n-    catch(boost::system::system_error &e)\n-    {\n-        strerr = strprintf(_(\"An error occurred while setting up the RPC port %u for listening on IPv6, falling back to IPv4: %s\"), endpoint.port(), e.what());\n-    }\n-    try {\n-        // If dual IPv6/IPv4 failed (or we're opening loopback interfaces only), open IPv4 separately\n-        if (!fListening || loopback || v6_only_error)\n-        {\n-            bindAddress = loopback ? asio::ip::address_v4::loopback() : asio::ip::address_v4::any();\n-            endpoint.address(bindAddress);\n \n-            boost::shared_ptr<ip::tcp::acceptor> acceptor(new ip::tcp::acceptor(*rpc_io_service));\n-            rpc_acceptors.push_back(acceptor);\n+        try {\n             acceptor->open(endpoint.protocol());\n             acceptor->set_option(boost::asio::ip::tcp::acceptor::reuse_address(true));\n+\n+            // Try making the socket dual IPv6/IPv4 when listening on the IPv6 \"any\" address\n+            acceptor->set_option(boost::asio::ip::v6_only(\n+                !bBindAny || bindAddress != asio::ip::address_v6::any()), v6_only_error);\n+\n             acceptor->bind(endpoint);\n             acceptor->listen(socket_base::max_connections);\n \n             RPCListen(acceptor, *rpc_ssl_context, fUseSSL);\n \n             fListening = true;\n+            // If dual IPv6/IPv4 bind succesful, skip binding to IPv4 separately\n+            if(bBindAny && bindAddress == asio::ip::address_v6::any() && !v6_only_error)\n+                break;\n+        }\n+        catch(boost::system::system_error &e)\n+        {\n+            LogPrintf(\"ERROR: Binding RPC on address %s port %i failed: %s\\n\", bindAddress.to_string(), endpoint.port(), e.what());\n+            strerr = strprintf(_(\"An error occurred while setting up the RPC address %s port %u for listening: %s\"), bindAddress.to_string(), endpoint.port(), e.what());\n         }\n-    }\n-    catch(boost::system::system_error &e)\n-    {\n-        strerr = strprintf(_(\"An error occurred while setting up the RPC port %u for listening on IPv4: %s\"), endpoint.port(), e.what());\n     }\n \n     if (!fListening) {"
      }
    ]
  },
  {
    "sha": "f923c077547ceb8492e11001d571ba27145242ef",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmOTIzYzA3NzU0N2NlYjg0OTJlMTEwMDFkNTcxYmEyNzE0NTI0MmVm",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2014-04-07T14:22:59Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2014-05-13T05:23:23Z"
      },
      "message": "Support IPv6 lookup in bitcoin-cli even when IPv6 only bound on localhost\n\nFirst query in the current way (intelligently determining which network\nhas a non-localhost interface). If this does not succeed, try plain\nlookup.\n\nNeeded for testing.\n\nFixes #1827 by always allowing IPv6 to be used.",
      "tree": {
        "sha": "bda88128b0f71e3644c73a3b235e7c4d0f88b37f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bda88128b0f71e3644c73a3b235e7c4d0f88b37f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f923c077547ceb8492e11001d571ba27145242ef",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f923c077547ceb8492e11001d571ba27145242ef",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f923c077547ceb8492e11001d571ba27145242ef",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f923c077547ceb8492e11001d571ba27145242ef/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "deb3572ab160221124dfa3e9c5c4e493529f59e4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/deb3572ab160221124dfa3e9c5c4e493529f59e4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/deb3572ab160221124dfa3e9c5c4e493529f59e4"
      }
    ],
    "stats": {
      "total": 24,
      "additions": 20,
      "deletions": 4
    },
    "files": [
      {
        "sha": "11bdd171d9a1e24c40999c11ac8bae7195e84b1e",
        "filename": "src/rpcprotocol.h",
        "status": "modified",
        "additions": 20,
        "deletions": 4,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f923c077547ceb8492e11001d571ba27145242ef/src/rpcprotocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f923c077547ceb8492e11001d571ba27145242ef/src/rpcprotocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcprotocol.h?ref=f923c077547ceb8492e11001d571ba27145242ef",
        "patch": "@@ -103,11 +103,27 @@ class SSLIOStreamDevice : public boost::iostreams::device<boost::iostreams::bidi\n     }\n     bool connect(const std::string& server, const std::string& port)\n     {\n-        boost::asio::ip::tcp::resolver resolver(stream.get_io_service());\n-        boost::asio::ip::tcp::resolver::query query(server.c_str(), port.c_str());\n-        boost::asio::ip::tcp::resolver::iterator endpoint_iterator = resolver.resolve(query);\n-        boost::asio::ip::tcp::resolver::iterator end;\n+        using namespace boost::asio::ip;\n+        tcp::resolver resolver(stream.get_io_service());\n+        tcp::resolver::iterator endpoint_iterator;\n+#if BOOST_VERSION >= 104300\n+        try {\n+#endif\n+            // The default query (flags address_configured) tries IPv6 if\n+            // non-localhost IPv6 configured, and IPv4 if non-localhost IPv4\n+            // configured.\n+            tcp::resolver::query query(server.c_str(), port.c_str());\n+            endpoint_iterator = resolver.resolve(query);\n+#if BOOST_VERSION >= 104300\n+        } catch(boost::system::system_error &e)\n+        {\n+            // If we at first don't succeed, try blanket lookup (IPv4+IPv6 independent of configured interfaces)\n+            tcp::resolver::query query(server.c_str(), port.c_str(), resolver_query_base::flags());\n+            endpoint_iterator = resolver.resolve(query);\n+        }\n+#endif\n         boost::system::error_code error = boost::asio::error::host_not_found;\n+        tcp::resolver::iterator end;\n         while (error && endpoint_iterator != end)\n         {\n             stream.lowest_layer().close();"
      }
    ]
  },
  {
    "sha": "b5ad5e783d6f636d5ca5703919d05fd0119a34fc",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiNWFkNWU3ODNkNmY2MzZkNWNhNTcwMzkxOWQwNWZkMDExOWEzNGZj",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2014-04-07T15:29:36Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2014-05-13T05:23:23Z"
      },
      "message": "Add Python test for -rpcbind and -rpcallowip\n\nAdd a new test, `rpcbind_test.py`, that extensively tests the new\n`-rpcbind` functionality.",
      "tree": {
        "sha": "2f6a26031cec7701c8517a411e502c84eb8686a1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2f6a26031cec7701c8517a411e502c84eb8686a1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b5ad5e783d6f636d5ca5703919d05fd0119a34fc",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b5ad5e783d6f636d5ca5703919d05fd0119a34fc",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b5ad5e783d6f636d5ca5703919d05fd0119a34fc",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b5ad5e783d6f636d5ca5703919d05fd0119a34fc/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f923c077547ceb8492e11001d571ba27145242ef",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f923c077547ceb8492e11001d571ba27145242ef",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f923c077547ceb8492e11001d571ba27145242ef"
      }
    ],
    "stats": {
      "total": 318,
      "additions": 314,
      "deletions": 4
    },
    "files": [
      {
        "sha": "9bea2e355e15da0b8f66acff974ea655966c88dc",
        "filename": "qa/rpc-tests/netutil.py",
        "status": "added",
        "additions": 134,
        "deletions": 0,
        "changes": 134,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b5ad5e783d6f636d5ca5703919d05fd0119a34fc/qa/rpc-tests/netutil.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b5ad5e783d6f636d5ca5703919d05fd0119a34fc/qa/rpc-tests/netutil.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/netutil.py?ref=b5ad5e783d6f636d5ca5703919d05fd0119a34fc",
        "patch": "@@ -0,0 +1,134 @@\n+# Linux network utilities\n+import sys\n+import socket\n+import fcntl\n+import struct\n+import array\n+import os\n+import binascii\n+\n+# Roughly based on http://voorloopnul.com/blog/a-python-netstat-in-less-than-100-lines-of-code/ by Ricardo Pascal\n+STATE_ESTABLISHED = '01'\n+STATE_SYN_SENT  = '02'\n+STATE_SYN_RECV = '03'\n+STATE_FIN_WAIT1 = '04'\n+STATE_FIN_WAIT2 = '05'\n+STATE_TIME_WAIT = '06'\n+STATE_CLOSE = '07'\n+STATE_CLOSE_WAIT = '08'\n+STATE_LAST_ACK = '09'\n+STATE_LISTEN = '0A'\n+STATE_CLOSING = '0B'\n+\n+def get_socket_inodes(pid):\n+    '''\n+    Get list of socket inodes for process pid.\n+    '''\n+    base = '/proc/%i/fd' % pid\n+    inodes = []\n+    for item in os.listdir(base):\n+        target = os.readlink(os.path.join(base, item))\n+        if target.startswith('socket:'):\n+            inodes.append(int(target[8:-1]))\n+    return inodes\n+\n+def _remove_empty(array):\n+    return [x for x in array if x !='']\n+\n+def _convert_ip_port(array):\n+    host,port = array.split(':')\n+    # convert host from mangled-per-four-bytes form as used by kernel\n+    host = binascii.unhexlify(host)\n+    host_out = ''\n+    for x in range(0, len(host)/4):\n+        (val,) = struct.unpack('=I', host[x*4:(x+1)*4])\n+        host_out += '%08x' % val\n+\n+    return host_out,int(port,16)\n+\n+def netstat(typ='tcp'):\n+    '''\n+    Function to return a list with status of tcp connections at linux systems\n+    To get pid of all network process running on system, you must run this script\n+    as superuser\n+    '''\n+    with open('/proc/net/'+typ,'r') as f:\n+        content = f.readlines()\n+        content.pop(0)\n+    result = []\n+    for line in content:\n+        line_array = _remove_empty(line.split(' '))     # Split lines and remove empty spaces.\n+        tcp_id = line_array[0]\n+        l_addr = _convert_ip_port(line_array[1])\n+        r_addr = _convert_ip_port(line_array[2])\n+        state = line_array[3]\n+        inode = int(line_array[9])                      # Need the inode to match with process pid.\n+        nline = [tcp_id, l_addr, r_addr, state, inode]\n+        result.append(nline)\n+    return result\n+\n+def get_bind_addrs(pid):\n+    '''\n+    Get bind addresses as (host,port) tuples for process pid.\n+    '''\n+    inodes = get_socket_inodes(pid)\n+    bind_addrs = []\n+    for conn in netstat('tcp') + netstat('tcp6'):\n+        if conn[3] == STATE_LISTEN and conn[4] in inodes:\n+            bind_addrs.append(conn[1])\n+    return bind_addrs\n+\n+# from: http://code.activestate.com/recipes/439093/\n+def all_interfaces():\n+    '''\n+    Return all interfaces that are up\n+    '''\n+    is_64bits = sys.maxsize > 2**32\n+    struct_size = 40 if is_64bits else 32\n+    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n+    max_possible = 8 # initial value\n+    while True:\n+        bytes = max_possible * struct_size\n+        names = array.array('B', '\\0' * bytes)\n+        outbytes = struct.unpack('iL', fcntl.ioctl(\n+            s.fileno(),\n+            0x8912,  # SIOCGIFCONF\n+            struct.pack('iL', bytes, names.buffer_info()[0])\n+        ))[0]\n+        if outbytes == bytes:\n+            max_possible *= 2\n+        else:\n+            break\n+    namestr = names.tostring()\n+    return [(namestr[i:i+16].split('\\0', 1)[0],\n+             socket.inet_ntoa(namestr[i+20:i+24]))\n+            for i in range(0, outbytes, struct_size)]\n+\n+def addr_to_hex(addr):\n+    '''\n+    Convert string IPv4 or IPv6 address to binary address as returned by\n+    get_bind_addrs.\n+    Very naive implementation that certainly doesn't work for all IPv6 variants.\n+    '''\n+    if '.' in addr: # IPv4\n+        addr = [int(x) for x in addr.split('.')]\n+    elif ':' in addr: # IPv6\n+        sub = [[], []] # prefix, suffix\n+        x = 0\n+        addr = addr.split(':')\n+        for i,comp in enumerate(addr):\n+            if comp == '':\n+                if i == 0 or i == (len(addr)-1): # skip empty component at beginning or end\n+                    continue\n+                x += 1 # :: skips to suffix\n+                assert(x < 2)\n+            else: # two bytes per component\n+                val = int(comp, 16)\n+                sub[x].append(val >> 8)\n+                sub[x].append(val & 0xff)\n+        nullbytes = 16 - len(sub[0]) - len(sub[1])\n+        assert((x == 0 and nullbytes == 0) or (x == 1 and nullbytes > 0))\n+        addr = sub[0] + ([0] * nullbytes) + sub[1]\n+    else:\n+        raise ValueError('Could not parse address %s' % addr)\n+    return binascii.hexlify(bytearray(addr))"
      },
      {
        "sha": "a31f8d98ef7cc140a8c2b7c61d260faf475e123f",
        "filename": "qa/rpc-tests/rpcbind_test.py",
        "status": "added",
        "additions": 152,
        "deletions": 0,
        "changes": 152,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b5ad5e783d6f636d5ca5703919d05fd0119a34fc/qa/rpc-tests/rpcbind_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b5ad5e783d6f636d5ca5703919d05fd0119a34fc/qa/rpc-tests/rpcbind_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/rpcbind_test.py?ref=b5ad5e783d6f636d5ca5703919d05fd0119a34fc",
        "patch": "@@ -0,0 +1,152 @@\n+#!/usr/bin/env python\n+# Copyright (c) 2014 The Bitcoin Core developers\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+# Test for -rpcbind, as well as -rpcallowip and -rpcconnect\n+\n+# Add python-bitcoinrpc to module search path:\n+import os\n+import sys\n+sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), \"python-bitcoinrpc\"))\n+\n+import json\n+import shutil\n+import subprocess\n+import tempfile\n+import traceback\n+\n+from bitcoinrpc.authproxy import AuthServiceProxy, JSONRPCException\n+from util import *\n+from netutil import *\n+\n+def run_bind_test(tmpdir, allow_ips, connect_to, addresses, expected):\n+    '''\n+    Start a node with requested rpcallowip and rpcbind parameters,\n+    then try to connect, and check if the set of bound addresses\n+    matches the expected set.\n+    '''\n+    expected = [(addr_to_hex(addr), port) for (addr, port) in expected]\n+    base_args = ['-disablewallet', '-nolisten']\n+    if allow_ips:\n+        base_args += ['-rpcallowip=' + x for x in allow_ips]\n+    binds = ['-rpcbind='+addr for addr in addresses]\n+    nodes = start_nodes(1, tmpdir, [base_args + binds], connect_to)\n+    try:\n+        pid = bitcoind_processes[0].pid\n+        assert_equal(set(get_bind_addrs(pid)), set(expected))\n+    finally:\n+        stop_nodes(nodes)\n+        wait_bitcoinds()\n+\n+def run_allowip_test(tmpdir, allow_ips, rpchost):\n+    '''\n+    Start a node with rpcwallow IP, and request getinfo\n+    at a non-localhost IP.\n+    '''\n+    base_args = ['-disablewallet', '-nolisten'] + ['-rpcallowip='+x for x in allow_ips]\n+    nodes = start_nodes(1, tmpdir, [base_args])\n+    try:\n+        # connect to node through non-loopback interface\n+        url = \"http://rt:rt@%s:%d\" % (rpchost, START_RPC_PORT,)\n+        node = AuthServiceProxy(url)\n+        node.getinfo()\n+    finally:\n+        node = None # make sure connection will be garbage collected and closed\n+        stop_nodes(nodes)\n+        wait_bitcoinds()\n+\n+\n+def run_test(tmpdir):\n+    assert(sys.platform == 'linux2') # due to OS-specific network stats queries, this test works only on Linux\n+    # find the first non-loopback interface for testing\n+    non_loopback_ip = None\n+    for name,ip in all_interfaces():\n+        if ip != '127.0.0.1':\n+            non_loopback_ip = ip\n+            break\n+    if non_loopback_ip is None:\n+        assert(not 'This test requires at least one non-loopback IPv4 interface')\n+    print(\"Using interface %s for testing\" % non_loopback_ip)\n+\n+    # check default without rpcallowip (IPv4 and IPv6 localhost)\n+    run_bind_test(tmpdir, None, '127.0.0.1', [],\n+        [('127.0.0.1', 11100), ('::1', 11100)])\n+    # check default with rpcallowip (IPv6 any)\n+    run_bind_test(tmpdir, ['127.0.0.1'], '127.0.0.1', [],\n+        [('::0', 11100)])\n+    # check only IPv4 localhost (explicit)\n+    run_bind_test(tmpdir, ['127.0.0.1'], '127.0.0.1', ['127.0.0.1'],\n+        [('127.0.0.1', START_RPC_PORT)])\n+    # check only IPv4 localhost (explicit) with alternative port\n+    run_bind_test(tmpdir, ['127.0.0.1'], '127.0.0.1:32171', ['127.0.0.1:32171'],\n+        [('127.0.0.1', 32171)])\n+    # check only IPv4 localhost (explicit) with multiple alternative ports on same host\n+    run_bind_test(tmpdir, ['127.0.0.1'], '127.0.0.1:32171', ['127.0.0.1:32171', '127.0.0.1:32172'],\n+        [('127.0.0.1', 32171), ('127.0.0.1', 32172)])\n+    # check only IPv6 localhost (explicit)\n+    run_bind_test(tmpdir, ['[::1]'], '[::1]', ['[::1]'],\n+        [('::1', 11100)])\n+    # check both IPv4 and IPv6 localhost (explicit)\n+    run_bind_test(tmpdir, ['127.0.0.1'], '127.0.0.1', ['127.0.0.1', '[::1]'],\n+        [('127.0.0.1', START_RPC_PORT), ('::1', START_RPC_PORT)])\n+    # check only non-loopback interface\n+    run_bind_test(tmpdir, [non_loopback_ip], non_loopback_ip, [non_loopback_ip],\n+        [(non_loopback_ip, START_RPC_PORT)])\n+\n+    # Check that with invalid rpcallowip, we are denied\n+    run_allowip_test(tmpdir, [non_loopback_ip], non_loopback_ip)\n+    try:\n+        run_allowip_test(tmpdir, ['1.1.1.1'], non_loopback_ip)\n+        assert(not 'Connection not denied by rpcallowip as expected')\n+    except ValueError:\n+        pass\n+\n+def main():\n+    import optparse\n+\n+    parser = optparse.OptionParser(usage=\"%prog [options]\")\n+    parser.add_option(\"--nocleanup\", dest=\"nocleanup\", default=False, action=\"store_true\",\n+                      help=\"Leave bitcoinds and test.* datadir on exit or error\")\n+    parser.add_option(\"--srcdir\", dest=\"srcdir\", default=\"../../src\",\n+                      help=\"Source directory containing bitcoind/bitcoin-cli (default: %default%)\")\n+    parser.add_option(\"--tmpdir\", dest=\"tmpdir\", default=tempfile.mkdtemp(prefix=\"test\"),\n+                      help=\"Root directory for datadirs\")\n+    (options, args) = parser.parse_args()\n+\n+    os.environ['PATH'] = options.srcdir+\":\"+os.environ['PATH']\n+\n+    check_json_precision()\n+\n+    success = False\n+    nodes = []\n+    try:\n+        print(\"Initializing test directory \"+options.tmpdir)\n+        if not os.path.isdir(options.tmpdir):\n+            os.makedirs(options.tmpdir)\n+        initialize_chain(options.tmpdir)\n+\n+        run_test(options.tmpdir)\n+\n+        success = True\n+\n+    except AssertionError as e:\n+        print(\"Assertion failed: \"+e.message)\n+    except Exception as e:\n+        print(\"Unexpected exception caught during testing: \"+str(e))\n+        traceback.print_tb(sys.exc_info()[2])\n+\n+    if not options.nocleanup:\n+        print(\"Cleaning up\")\n+        wait_bitcoinds()\n+        shutil.rmtree(options.tmpdir)\n+\n+    if success:\n+        print(\"Tests successful\")\n+        sys.exit(0)\n+    else:\n+        print(\"Failed\")\n+        sys.exit(1)\n+\n+if __name__ == '__main__':\n+    main()"
      },
      {
        "sha": "40f4a1458f99cc205677353e5b53b8bb3458aaec",
        "filename": "qa/rpc-tests/util.py",
        "status": "modified",
        "additions": 28,
        "deletions": 4,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b5ad5e783d6f636d5ca5703919d05fd0119a34fc/qa/rpc-tests/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b5ad5e783d6f636d5ca5703919d05fd0119a34fc/qa/rpc-tests/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/util.py?ref=b5ad5e783d6f636d5ca5703919d05fd0119a34fc",
        "patch": "@@ -15,6 +15,7 @@\n import shutil\n import subprocess\n import time\n+import re\n \n from bitcoinrpc.authproxy import AuthServiceProxy, JSONRPCException\n from util import *\n@@ -112,20 +113,43 @@ def initialize_chain(test_dir):\n         to_dir = os.path.join(test_dir,  \"node\"+str(i))\n         shutil.copytree(from_dir, to_dir)\n \n-def start_nodes(num_nodes, dir):\n+def _rpchost_to_args(rpchost):\n+    '''Convert optional IP:port spec to rpcconnect/rpcport args'''\n+    if rpchost is None:\n+        return []\n+\n+    match = re.match('(\\[[0-9a-fA-f:]+\\]|[^:]+)(?::([0-9]+))?$', rpchost)\n+    if not match:\n+        raise ValueError('Invalid RPC host spec ' + rpchost)\n+\n+    rpcconnect = match.group(1)\n+    rpcport = match.group(2)\n+\n+    if rpcconnect.startswith('['): # remove IPv6 [...] wrapping\n+        rpcconnect = rpcconnect[1:-1]\n+\n+    rv = ['-rpcconnect=' + rpcconnect]\n+    if rpcport:\n+        rv += ['-rpcport=' + rpcport]\n+    return rv\n+\n+def start_nodes(num_nodes, dir, extra_args=None, rpchost=None):\n     # Start bitcoinds, and wait for RPC interface to be up and running:\n     devnull = open(\"/dev/null\", \"w+\")\n     for i in range(num_nodes):\n         datadir = os.path.join(dir, \"node\"+str(i))\n         args = [ \"bitcoind\", \"-datadir=\"+datadir ]\n+        if extra_args is not None:\n+            args += extra_args[i]\n         bitcoind_processes.append(subprocess.Popen(args))\n-        subprocess.check_call([ \"bitcoin-cli\", \"-datadir=\"+datadir,\n-                                  \"-rpcwait\", \"getblockcount\"], stdout=devnull)\n+        subprocess.check_call([ \"bitcoin-cli\", \"-datadir=\"+datadir] +\n+                                  _rpchost_to_args(rpchost)  +\n+                                  [\"-rpcwait\", \"getblockcount\"], stdout=devnull)\n     devnull.close()\n     # Create&return JSON-RPC connections\n     rpc_connections = []\n     for i in range(num_nodes):\n-        url = \"http://rt:rt@127.0.0.1:%d\"%(START_RPC_PORT+i,)\n+        url = \"http://rt:rt@%s:%d\" % (rpchost or '127.0.0.1', START_RPC_PORT+i,)\n         rpc_connections.append(AuthServiceProxy(url))\n     return rpc_connections\n "
      }
    ]
  }
]