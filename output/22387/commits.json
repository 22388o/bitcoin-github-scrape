[
  {
    "sha": "0d64b8f709b4655d8702f810d4876cd8d96ded82",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowZDY0YjhmNzA5YjQ2NTVkODcwMmY4MTBkNDg3NmNkOGQ5NmRlZDgy",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-06-30T18:52:40Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-07-15T19:52:38Z"
      },
      "message": "Rate limit the processing of incoming addr messages\n\nWhile limitations on the influence of attackers on addrman already\nexist (affected buckets are restricted to a subset based on incoming\nIP / network group), there is no reason to permit them to let them\nfeed us addresses at more than a multiple of the normal network\nrate.\n\nThis commit introduces a \"token bucket\" rate limiter for the\nprocessing of addresses in incoming ADDR and ADDRV2 messages.\nEvery connection gets an associated token bucket. Processing an\naddress in an ADDR or ADDRV2 message from non-whitelisted peers\nconsumes a token from the bucket. If the bucket is empty, the\naddress is ignored (it is not forwarded or processed). The token\ncounter increases at a rate of 0.1 tokens per second, and will\naccrue up to a maximum of 1000 tokens (the maximum we accept in a\nsingle ADDR or ADDRV2). When a GETADDR is sent to a peer, it\nimmediately gets 1000 additional tokens, as we actively desire many\naddresses from such peers (this may temporarily cause the token\ncount to exceed 1000).\n\nThe rate limit of 0.1 addr/s was chosen based on observation of\nhonest nodes on the network. Activity in general from most nodes\nis either 0, or up to a maximum around 0.025 addr/s for recent\nBitcoin Core nodes. A few (self-identified, through subver) crawler\nnodes occasionally exceed 0.1 addr/s.",
      "tree": {
        "sha": "8cb80df524d325c9fddd5f7e43202176375951ec",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8cb80df524d325c9fddd5f7e43202176375951ec"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0d64b8f709b4655d8702f810d4876cd8d96ded82",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0d64b8f709b4655d8702f810d4876cd8d96ded82",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0d64b8f709b4655d8702f810d4876cd8d96ded82",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0d64b8f709b4655d8702f810d4876cd8d96ded82/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a88fa1a555195af6543cdc802e8e1c2e1668dd38",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a88fa1a555195af6543cdc802e8e1c2e1668dd38",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a88fa1a555195af6543cdc802e8e1c2e1668dd38"
      }
    ],
    "stats": {
      "total": 40,
      "additions": 38,
      "deletions": 2
    },
    "files": [
      {
        "sha": "bc979e3792c79f4d180d24b60014cfd8983bbc8e",
        "filename": "src/net_permissions.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0d64b8f709b4655d8702f810d4876cd8d96ded82/src/net_permissions.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0d64b8f709b4655d8702f810d4876cd8d96ded82/src/net_permissions.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_permissions.h?ref=0d64b8f709b4655d8702f810d4876cd8d96ded82",
        "patch": "@@ -31,7 +31,8 @@ enum class NetPermissionFlags : uint32_t {\n     NoBan = (1U << 4) | Download,\n     // Can query the mempool\n     Mempool = (1U << 5),\n-    // Can request addrs without hitting a privacy-preserving cache\n+    // Can request addrs without hitting a privacy-preserving cache, and send us\n+    // unlimited amounts of addrs.\n     Addr = (1U << 7),\n \n     // True if the user did not specifically set fine grained permissions"
      },
      {
        "sha": "8d24b00887704dd0ab44e4bffcba932a18f62b30",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 0,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0d64b8f709b4655d8702f810d4876cd8d96ded82/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0d64b8f709b4655d8702f810d4876cd8d96ded82/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=0d64b8f709b4655d8702f810d4876cd8d96ded82",
        "patch": "@@ -155,6 +155,13 @@ static constexpr uint32_t MAX_GETCFHEADERS_SIZE = 2000;\n static constexpr size_t MAX_PCT_ADDR_TO_SEND = 23;\n /** The maximum number of address records permitted in an ADDR message. */\n static constexpr size_t MAX_ADDR_TO_SEND{1000};\n+/** The maximum rate of address records we're willing to process on average. Can be bypassed using\n+ *  the NetPermissionFlags::Addr permission. */\n+static constexpr double MAX_ADDR_RATE_PER_SECOND{0.1};\n+/** The soft limit of the address processing token bucket (the regular MAX_ADDR_RATE_PER_SECOND\n+ *  based increments won't go above this, but the MAX_ADDR_TO_SEND increment following GETADDR\n+ *  is exempt from this limit. */\n+static constexpr size_t MAX_ADDR_PROCESSING_TOKEN_BUCKET{MAX_ADDR_TO_SEND};\n \n // Internal stuff\n namespace {\n@@ -233,6 +240,11 @@ struct Peer {\n     std::atomic_bool m_wants_addrv2{false};\n     /** Whether this peer has already sent us a getaddr message. */\n     bool m_getaddr_recvd{false};\n+    /** Number of addr messages that can be processed from this peer. Start at 1 to\n+     *  permit self-announcement. */\n+    double m_addr_token_bucket{1.0};\n+    /** When m_addr_token_bucket was last updated */\n+    std::chrono::microseconds m_addr_token_timestamp{GetTime<std::chrono::microseconds>()};\n \n     /** Set of txids to reconsider once their parent transactions have been accepted **/\n     std::set<uint256> m_orphan_work_set GUARDED_BY(g_cs_orphans);\n@@ -2583,6 +2595,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             // Get recent addresses\n             m_connman.PushMessage(&pfrom, CNetMsgMaker(greatest_common_version).Make(NetMsgType::GETADDR));\n             peer->m_getaddr_sent = true;\n+            // When requesting a getaddr, accept an additional MAX_ADDR_TO_SEND addresses in response\n+            // (bypassing the MAX_ADDR_PROCESSING_TOKEN_BUCKET limit).\n+            peer->m_addr_token_bucket += MAX_ADDR_TO_SEND;\n         }\n \n         if (!pfrom.IsInboundConn()) {\n@@ -2777,11 +2792,28 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         std::vector<CAddress> vAddrOk;\n         int64_t nNow = GetAdjustedTime();\n         int64_t nSince = nNow - 10 * 60;\n+\n+        // Update/increment addr rate limiting bucket.\n+        const auto current_time = GetTime<std::chrono::microseconds>();\n+        if (peer->m_addr_token_bucket < MAX_ADDR_PROCESSING_TOKEN_BUCKET) {\n+            // Don't increment bucket if it's already full\n+            const auto time_diff = std::max(current_time - peer->m_addr_token_timestamp, 0us);\n+            const double increment = CountSecondsDouble(time_diff) * MAX_ADDR_RATE_PER_SECOND;\n+            peer->m_addr_token_bucket = std::min<double>(peer->m_addr_token_bucket + increment, MAX_ADDR_PROCESSING_TOKEN_BUCKET);\n+        }\n+        peer->m_addr_token_timestamp = current_time;\n+\n+        const bool rate_limited = !pfrom.HasPermission(NetPermissionFlags::Addr);\n         for (CAddress& addr : vAddr)\n         {\n             if (interruptMsgProc)\n                 return;\n \n+            // Apply rate limiting.\n+            if (rate_limited) {\n+                if (peer->m_addr_token_bucket < 1.0) break;\n+                peer->m_addr_token_bucket -= 1.0;\n+            }\n             // We only bother storing full nodes, though this may include\n             // things which we would not make an outbound connection to, in\n             // part because we may make feeler connections to them."
      },
      {
        "sha": "cd668dc315290cc9999198aa492fd45f98852bab",
        "filename": "test/functional/p2p_addr_relay.py",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0d64b8f709b4655d8702f810d4876cd8d96ded82/test/functional/p2p_addr_relay.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0d64b8f709b4655d8702f810d4876cd8d96ded82/test/functional/p2p_addr_relay.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_addr_relay.py?ref=0d64b8f709b4655d8702f810d4876cd8d96ded82",
        "patch": "@@ -53,6 +53,7 @@ class AddrTest(BitcoinTestFramework):\n \n     def set_test_params(self):\n         self.num_nodes = 1\n+        self.extra_args = [[\"-whitelist=addr@127.0.0.1\"]]\n \n     def run_test(self):\n         self.oversized_addr_test()\n@@ -191,7 +192,7 @@ def getaddr_tests(self):\n \n     def blocksonly_mode_tests(self):\n         self.log.info('Test addr relay in -blocksonly mode')\n-        self.restart_node(0, [\"-blocksonly\"])\n+        self.restart_node(0, [\"-blocksonly\", \"-whitelist=addr@127.0.0.1\"])\n         self.mocktime = int(time.time())\n \n         self.log.info('Check that we send getaddr messages')"
      },
      {
        "sha": "9d36bc03a3bf7cb0d1a52688c9c909db6e6f506c",
        "filename": "test/functional/p2p_addrv2_relay.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0d64b8f709b4655d8702f810d4876cd8d96ded82/test/functional/p2p_addrv2_relay.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0d64b8f709b4655d8702f810d4876cd8d96ded82/test/functional/p2p_addrv2_relay.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_addrv2_relay.py?ref=0d64b8f709b4655d8702f810d4876cd8d96ded82",
        "patch": "@@ -53,6 +53,7 @@ class AddrTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.setup_clean_chain = True\n         self.num_nodes = 1\n+        self.extra_args = [[\"-whitelist=addr@127.0.0.1\"]]\n \n     def run_test(self):\n         self.log.info('Create connection that sends addrv2 messages')"
      },
      {
        "sha": "9c345063205504d1d8b2ff9f2328cdf3e2f2eeef",
        "filename": "test/functional/p2p_invalid_messages.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0d64b8f709b4655d8702f810d4876cd8d96ded82/test/functional/p2p_invalid_messages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0d64b8f709b4655d8702f810d4876cd8d96ded82/test/functional/p2p_invalid_messages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_invalid_messages.py?ref=0d64b8f709b4655d8702f810d4876cd8d96ded82",
        "patch": "@@ -58,6 +58,7 @@ class InvalidMessagesTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 1\n         self.setup_clean_chain = True\n+        self.extra_args = [[\"-whitelist=addr@127.0.0.1\"]]\n \n     def run_test(self):\n         self.test_buffer()"
      }
    ]
  },
  {
    "sha": "5648138f5949013331c017c740646e2f4013bc24",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1NjQ4MTM4ZjU5NDkwMTMzMzFjMDE3Yzc0MDY0NmUyZjQwMTNiYzI0",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-07-15T19:59:23Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-07-15T19:59:23Z"
      },
      "message": "Randomize the order of addr processing",
      "tree": {
        "sha": "180d8e759edcd7497ff3dc78e1ec67eff8c406cb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/180d8e759edcd7497ff3dc78e1ec67eff8c406cb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5648138f5949013331c017c740646e2f4013bc24",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5648138f5949013331c017c740646e2f4013bc24",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5648138f5949013331c017c740646e2f4013bc24",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5648138f5949013331c017c740646e2f4013bc24/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0d64b8f709b4655d8702f810d4876cd8d96ded82",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0d64b8f709b4655d8702f810d4876cd8d96ded82",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0d64b8f709b4655d8702f810d4876cd8d96ded82"
      }
    ],
    "stats": {
      "total": 5,
      "additions": 4,
      "deletions": 1
    },
    "files": [
      {
        "sha": "79ef11a7904e4c4bfdfb14c1e36cfa6d470057fe",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5648138f5949013331c017c740646e2f4013bc24/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5648138f5949013331c017c740646e2f4013bc24/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=5648138f5949013331c017c740646e2f4013bc24",
        "patch": "@@ -2804,6 +2804,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         peer->m_addr_token_timestamp = current_time;\n \n         const bool rate_limited = !pfrom.HasPermission(NetPermissionFlags::Addr);\n+        Shuffle(vAddr.begin(), vAddr.end(), FastRandomContext());\n         for (CAddress& addr : vAddr)\n         {\n             if (interruptMsgProc)"
      },
      {
        "sha": "32c1d42b1cf80f5fbb0367b79ca1879d23d31c9c",
        "filename": "test/functional/p2p_addrv2_relay.py",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5648138f5949013331c017c740646e2f4013bc24/test/functional/p2p_addrv2_relay.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5648138f5949013331c017c740646e2f4013bc24/test/functional/p2p_addrv2_relay.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_addrv2_relay.py?ref=5648138f5949013331c017c740646e2f4013bc24",
        "patch": "@@ -42,7 +42,9 @@ def __init__(self):\n         super().__init__(support_addrv2 = True)\n \n     def on_addrv2(self, message):\n-        if ADDRS == message.addrs:\n+        expected_set = set((addr.ip, addr.port) for addr in ADDRS)\n+        received_set = set((addr.ip, addr.port) for addr in message.addrs)\n+        if expected_set == received_set:\n             self.addrv2_received_and_checked = True\n \n     def wait_for_addrv2(self):"
      }
    ]
  },
  {
    "sha": "b4ece8a1cda69cc268d39d21bba59c51fa2fb9ed",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiNGVjZThhMWNkYTY5Y2MyNjhkMzlkMjFiYmE1OWM1MWZhMmZiOWVk",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-07-01T23:02:05Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-07-15T20:03:17Z"
      },
      "message": "Functional tests for addr rate limiting",
      "tree": {
        "sha": "aa77badd1339302803db3f12b2e75a304c543634",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/aa77badd1339302803db3f12b2e75a304c543634"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b4ece8a1cda69cc268d39d21bba59c51fa2fb9ed",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b4ece8a1cda69cc268d39d21bba59c51fa2fb9ed",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b4ece8a1cda69cc268d39d21bba59c51fa2fb9ed",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b4ece8a1cda69cc268d39d21bba59c51fa2fb9ed/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5648138f5949013331c017c740646e2f4013bc24",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5648138f5949013331c017c740646e2f4013bc24",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5648138f5949013331c017c740646e2f4013bc24"
      }
    ],
    "stats": {
      "total": 80,
      "additions": 80,
      "deletions": 0
    },
    "files": [
      {
        "sha": "b53231b6df4be2f6ac0d5178584b81f9d82d729c",
        "filename": "test/functional/p2p_addr_relay.py",
        "status": "modified",
        "additions": 80,
        "deletions": 0,
        "changes": 80,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b4ece8a1cda69cc268d39d21bba59c51fa2fb9ed/test/functional/p2p_addr_relay.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b4ece8a1cda69cc268d39d21bba59c51fa2fb9ed/test/functional/p2p_addr_relay.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_addr_relay.py?ref=b4ece8a1cda69cc268d39d21bba59c51fa2fb9ed",
        "patch": "@@ -17,7 +17,10 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n+    assert_greater_than_or_equal,\n )\n+import os\n+import random\n import time\n \n \n@@ -60,6 +63,7 @@ def run_test(self):\n         self.relay_tests()\n         self.getaddr_tests()\n         self.blocksonly_mode_tests()\n+        self.rate_limit_tests()\n \n     def setup_addr_msg(self, num):\n         addrs = []\n@@ -76,6 +80,19 @@ def setup_addr_msg(self, num):\n         msg.addrs = addrs\n         return msg\n \n+    def setup_rand_addr_msg(self, num):\n+        addrs = []\n+        for i in range(num):\n+            addr = CAddress()\n+            addr.time = self.mocktime + i\n+            addr.nServices = NODE_NETWORK | NODE_WITNESS\n+            addr.ip = f\"{random.randrange(128,169)}.{random.randrange(1,255)}.{random.randrange(1,255)}.{random.randrange(1,255)}\"\n+            addr.port = 8333\n+            addrs.append(addr)\n+        msg = msg_addr()\n+        msg.addrs = addrs\n+        return msg\n+\n     def send_addr_msg(self, source, msg, receivers):\n         source.send_and_ping(msg)\n         # pop m_next_addr_send timer\n@@ -208,6 +225,69 @@ def blocksonly_mode_tests(self):\n \n         self.nodes[0].disconnect_p2ps()\n \n+    def rate_limit_tests(self):\n+\n+        for contype, tokens, no_relay in [(\"outbound-full-relay\", 1001, False), (\"block-relay-only\", 0, True), (\"inbound\", 1, False)]:\n+            self.log.info(f'Test rate limiting of addr processing for {contype} peers')\n+            self.stop_node(0)\n+            os.remove(os.path.join(self.nodes[0].datadir, \"regtest\", \"peers.dat\"))\n+            self.start_node(0, [])\n+            self.mocktime = int(time.time())\n+            self.nodes[0].setmocktime(self.mocktime)\n+            if contype == \"inbound\":\n+                peer = self.nodes[0].add_p2p_connection(AddrReceiver())\n+            else:\n+                peer = self.nodes[0].add_outbound_p2p_connection(AddrReceiver(), p2p_idx=0, connection_type=contype)\n+\n+            # Check that we start off with empty addrman\n+            addr_count_0 = len(self.nodes[0].getnodeaddresses(0))\n+            assert_equal(addr_count_0, 0)\n+\n+            # Send 600 addresses. For all but the block-relay-only peer this should result in at least 1 address.\n+            peer.send_and_ping(self.setup_rand_addr_msg(600))\n+            addr_count_1 = len(self.nodes[0].getnodeaddresses(0))\n+            assert_greater_than_or_equal(tokens, addr_count_1)\n+            assert_greater_than_or_equal(addr_count_0 + 600, addr_count_1)\n+            assert_equal(addr_count_1 > addr_count_0, tokens > 0)\n+\n+            # Send 600 more addresses. For the outbound-full-relay peer (which we send a GETADDR, and thus will\n+            # process up to 1001 incoming addresses), this means more entries will appear.\n+            peer.send_and_ping(self.setup_rand_addr_msg(600))\n+            addr_count_2 = len(self.nodes[0].getnodeaddresses(0))\n+            assert_greater_than_or_equal(tokens, addr_count_2)\n+            assert_greater_than_or_equal(addr_count_1 + 600, addr_count_2)\n+            assert_equal(addr_count_2 > addr_count_1, tokens > 600)\n+\n+            # Send 10 more. As we reached the processing limit for all nodes, this should have no effect.\n+            peer.send_and_ping(self.setup_rand_addr_msg(10))\n+            addr_count_3 = len(self.nodes[0].getnodeaddresses(0))\n+            assert_greater_than_or_equal(tokens, addr_count_3)\n+            assert_equal(addr_count_2, addr_count_3)\n+\n+            # Advance the time by 100 seconds, permitting the processing of 10 more addresses. Send 200,\n+            # but verify that no more than 10 are processed.\n+            self.mocktime += 100\n+            self.nodes[0].setmocktime(self.mocktime)\n+            new_tokens = 0 if no_relay else 10\n+            tokens += new_tokens\n+            peer.send_and_ping(self.setup_rand_addr_msg(200))\n+            addr_count_4 = len(self.nodes[0].getnodeaddresses(0))\n+            assert_greater_than_or_equal(tokens, addr_count_4)\n+            assert_greater_than_or_equal(addr_count_3 + new_tokens, addr_count_4)\n+\n+            # Advance the time by 1000 seconds, permitting the processing of 100 more addresses. Send 200,\n+            # but verify that no more than 100 are processed (and at least some).\n+            self.mocktime += 1000\n+            self.nodes[0].setmocktime(self.mocktime)\n+            new_tokens = 0 if no_relay else 100\n+            tokens += new_tokens\n+            peer.send_and_ping(self.setup_rand_addr_msg(200))\n+            addr_count_5 = len(self.nodes[0].getnodeaddresses(0))\n+            assert_greater_than_or_equal(tokens, addr_count_5)\n+            assert_greater_than_or_equal(addr_count_4 + new_tokens, addr_count_5)\n+            assert_equal(addr_count_5 > addr_count_4, not no_relay)\n+\n+            self.nodes[0].disconnect_p2ps()\n \n if __name__ == '__main__':\n     AddrTest().main()"
      }
    ]
  },
  {
    "sha": "f424d601e1b6870e20bc60f5ccba36d2e210377b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmNDI0ZDYwMWUxYjY4NzBlMjBiYzYwZjVjY2JhMzZkMmUyMTAzNzdi",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-07-07T18:44:40Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-07-15T20:03:20Z"
      },
      "message": "Add logging and addr rate limiting statistics\n\nIncludes logging improvements by Vasil Dimov and John Newbery.",
      "tree": {
        "sha": "d56831c9b26dcc22796bcb39349e946cd9016175",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d56831c9b26dcc22796bcb39349e946cd9016175"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f424d601e1b6870e20bc60f5ccba36d2e210377b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f424d601e1b6870e20bc60f5ccba36d2e210377b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f424d601e1b6870e20bc60f5ccba36d2e210377b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f424d601e1b6870e20bc60f5ccba36d2e210377b/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b4ece8a1cda69cc268d39d21bba59c51fa2fb9ed",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b4ece8a1cda69cc268d39d21bba59c51fa2fb9ed",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b4ece8a1cda69cc268d39d21bba59c51fa2fb9ed"
      }
    ],
    "stats": {
      "total": 27,
      "additions": 26,
      "deletions": 1
    },
    "files": [
      {
        "sha": "9c4544df215be220c5b51ac4cf47459f436f4b8d",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 1,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f424d601e1b6870e20bc60f5ccba36d2e210377b/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f424d601e1b6870e20bc60f5ccba36d2e210377b/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=f424d601e1b6870e20bc60f5ccba36d2e210377b",
        "patch": "@@ -245,6 +245,10 @@ struct Peer {\n     double m_addr_token_bucket{1.0};\n     /** When m_addr_token_bucket was last updated */\n     std::chrono::microseconds m_addr_token_timestamp{GetTime<std::chrono::microseconds>()};\n+    /** Total number of addresses that were dropped due to rate limiting. */\n+    std::atomic<uint64_t> m_addr_rate_limited{0};\n+    /** Total number of addresses that were processed (excludes rate limited ones). */\n+    std::atomic<uint64_t> m_addr_processed{0};\n \n     /** Set of txids to reconsider once their parent transactions have been accepted **/\n     std::set<uint256> m_orphan_work_set GUARDED_BY(g_cs_orphans);\n@@ -1251,6 +1255,8 @@ bool PeerManagerImpl::GetNodeStateStats(NodeId nodeid, CNodeStateStats& stats) c\n     }\n \n     stats.m_ping_wait = ping_wait;\n+    stats.m_addr_processed = peer->m_addr_processed.load();\n+    stats.m_addr_rate_limited = peer->m_addr_rate_limited.load();\n \n     return true;\n }\n@@ -2804,6 +2810,8 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         peer->m_addr_token_timestamp = current_time;\n \n         const bool rate_limited = !pfrom.HasPermission(NetPermissionFlags::Addr);\n+        uint64_t num_proc = 0;\n+        uint64_t num_rate_limit = 0;\n         Shuffle(vAddr.begin(), vAddr.end(), FastRandomContext());\n         for (CAddress& addr : vAddr)\n         {\n@@ -2812,7 +2820,10 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n             // Apply rate limiting.\n             if (rate_limited) {\n-                if (peer->m_addr_token_bucket < 1.0) break;\n+                if (peer->m_addr_token_bucket < 1.0) {\n+                    ++num_rate_limit;\n+                    continue;\n+                }\n                 peer->m_addr_token_bucket -= 1.0;\n             }\n             // We only bother storing full nodes, though this may include\n@@ -2828,6 +2839,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 // Do not process banned/discouraged addresses beyond remembering we received them\n                 continue;\n             }\n+            ++num_proc;\n             bool fReachable = IsReachable(addr);\n             if (addr.nTime > nSince && !peer->m_getaddr_sent && vAddr.size() <= 10 && addr.IsRoutable()) {\n                 // Relay to a limited number of other nodes\n@@ -2837,6 +2849,15 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             if (fReachable)\n                 vAddrOk.push_back(addr);\n         }\n+        peer->m_addr_processed += num_proc;\n+        peer->m_addr_rate_limited += num_rate_limit;\n+        LogPrint(BCLog::NET, \"Received addr: %u addresses (%u processed, %u rate-limited) from peer=%d%s\\n\",\n+                 vAddr.size(),\n+                 num_proc,\n+                 num_rate_limit,\n+                 pfrom.GetId(),\n+                 fLogIPs ? \", peeraddr=\" + pfrom.addr.ToString() : \"\");\n+\n         m_addrman.Add(vAddrOk, pfrom.addr, 2 * 60 * 60);\n         if (vAddr.size() < 1000) peer->m_getaddr_sent = false;\n         if (pfrom.IsAddrFetchConn()) {"
      },
      {
        "sha": "c537efb5db9582d948efa5c1148d771f21ea8d4d",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f424d601e1b6870e20bc60f5ccba36d2e210377b/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f424d601e1b6870e20bc60f5ccba36d2e210377b/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=f424d601e1b6870e20bc60f5ccba36d2e210377b",
        "patch": "@@ -29,6 +29,8 @@ struct CNodeStateStats {\n     int m_starting_height = -1;\n     std::chrono::microseconds m_ping_wait;\n     std::vector<int> vHeightInFlight;\n+    uint64_t m_addr_processed = 0;\n+    uint64_t m_addr_rate_limited = 0;\n };\n \n class PeerManager : public CValidationInterface, public NetEventsInterface"
      },
      {
        "sha": "083ba31b712a26ad8f18ce289f8e275cf11bea48",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f424d601e1b6870e20bc60f5ccba36d2e210377b/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f424d601e1b6870e20bc60f5ccba36d2e210377b/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=f424d601e1b6870e20bc60f5ccba36d2e210377b",
        "patch": "@@ -242,6 +242,8 @@ static RPCHelpMan getpeerinfo()\n                 heights.push_back(height);\n             }\n             obj.pushKV(\"inflight\", heights);\n+            obj.pushKV(\"addr_processed\", statestats.m_addr_processed);\n+            obj.pushKV(\"addr_rate_limited\", statestats.m_addr_rate_limited);\n         }\n         UniValue permissions(UniValue::VARR);\n         for (const auto& permission : NetPermissions::ToStrings(stats.m_permissionFlags)) {"
      }
    ]
  },
  {
    "sha": "a4bcd687c934d47aa3922334e97e579caf5f8124",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphNGJjZDY4N2M5MzRkNDdhYTM5MjIzMzRlOTdlNTc5Y2FmNWY4MTI0",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-07-14T18:58:50Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-07-15T23:31:47Z"
      },
      "message": "Improve tests using statistics",
      "tree": {
        "sha": "2ff4bd1efd38936b75bdf26e8ccae3a0538e247b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2ff4bd1efd38936b75bdf26e8ccae3a0538e247b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a4bcd687c934d47aa3922334e97e579caf5f8124",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a4bcd687c934d47aa3922334e97e579caf5f8124",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a4bcd687c934d47aa3922334e97e579caf5f8124",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a4bcd687c934d47aa3922334e97e579caf5f8124/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f424d601e1b6870e20bc60f5ccba36d2e210377b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f424d601e1b6870e20bc60f5ccba36d2e210377b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f424d601e1b6870e20bc60f5ccba36d2e210377b"
      }
    ],
    "stats": {
      "total": 114,
      "additions": 61,
      "deletions": 53
    },
    "files": [
      {
        "sha": "ff1d85a9be74d24c4d0c748c8c696572d984d075",
        "filename": "test/functional/p2p_addr_relay.py",
        "status": "modified",
        "additions": 61,
        "deletions": 53,
        "changes": 114,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4bcd687c934d47aa3922334e97e579caf5f8124/test/functional/p2p_addr_relay.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4bcd687c934d47aa3922334e97e579caf5f8124/test/functional/p2p_addr_relay.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_addr_relay.py?ref=a4bcd687c934d47aa3922334e97e579caf5f8124",
        "patch": "@@ -13,20 +13,20 @@\n     msg_addr,\n     msg_getaddr\n )\n-from test_framework.p2p import P2PInterface\n-from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import (\n-    assert_equal,\n-    assert_greater_than_or_equal,\n+from test_framework.p2p import (\n+    P2PInterface,\n+    p2p_lock,\n )\n-import os\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_equal\n import random\n import time\n \n \n class AddrReceiver(P2PInterface):\n     num_ipv4_received = 0\n     test_addr_contents = False\n+    _tokens = 1\n \n     def __init__(self, test_addr_contents=False):\n         super().__init__()\n@@ -43,6 +43,20 @@ def on_addr(self, message):\n                     raise AssertionError(\"Invalid addr.port of {} (8333-8342 expected)\".format(addr.port))\n                 assert addr.ip.startswith('123.123.123.')\n \n+    def on_getaddr(self, message):\n+        # When the node sends us a getaddr, it increments the addr relay tokens for the connection by 1000\n+        self._tokens += 1000\n+\n+    @property\n+    def tokens(self):\n+        with p2p_lock:\n+            return self._tokens\n+\n+    def increment_tokens(self, n):\n+        # When we move mocktime forward, the node increments the addr relay tokens for its peers\n+        with p2p_lock:\n+            self._tokens += n\n+\n     def addr_received(self):\n         return self.num_ipv4_received != 0\n \n@@ -225,67 +239,61 @@ def blocksonly_mode_tests(self):\n \n         self.nodes[0].disconnect_p2ps()\n \n+    def send_addrs_and_test_rate_limiting(self, peer, no_relay, new_addrs, total_addrs):\n+        \"\"\"Send an addr message and check that the number of addresses processed and rate-limited is as expected\"\"\"\n+\n+        peer.send_and_ping(self.setup_rand_addr_msg(new_addrs))\n+\n+        peerinfo = self.nodes[0].getpeerinfo()[0]\n+        addrs_processed = peerinfo['addr_processed']\n+        addrs_rate_limited = peerinfo['addr_rate_limited']\n+        self.log.debug(f\"addrs_processed = {addrs_processed}, addrs_rate_limited = {addrs_rate_limited}\")\n+\n+        if no_relay:\n+            assert_equal(addrs_processed, 0)\n+            assert_equal(addrs_rate_limited, 0)\n+        else:\n+            assert_equal(addrs_processed, min(total_addrs, peer.tokens))\n+            assert_equal(addrs_rate_limited, max(0, total_addrs - peer.tokens))\n+\n     def rate_limit_tests(self):\n \n-        for contype, tokens, no_relay in [(\"outbound-full-relay\", 1001, False), (\"block-relay-only\", 0, True), (\"inbound\", 1, False)]:\n+        self.mocktime = int(time.time())\n+        self.restart_node(0, [])\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+        for contype, no_relay in [(\"outbound-full-relay\", False), (\"block-relay-only\", True), (\"inbound\", False)]:\n             self.log.info(f'Test rate limiting of addr processing for {contype} peers')\n-            self.stop_node(0)\n-            os.remove(os.path.join(self.nodes[0].datadir, \"regtest\", \"peers.dat\"))\n-            self.start_node(0, [])\n-            self.mocktime = int(time.time())\n-            self.nodes[0].setmocktime(self.mocktime)\n             if contype == \"inbound\":\n                 peer = self.nodes[0].add_p2p_connection(AddrReceiver())\n             else:\n                 peer = self.nodes[0].add_outbound_p2p_connection(AddrReceiver(), p2p_idx=0, connection_type=contype)\n \n-            # Check that we start off with empty addrman\n-            addr_count_0 = len(self.nodes[0].getnodeaddresses(0))\n-            assert_equal(addr_count_0, 0)\n-\n-            # Send 600 addresses. For all but the block-relay-only peer this should result in at least 1 address.\n-            peer.send_and_ping(self.setup_rand_addr_msg(600))\n-            addr_count_1 = len(self.nodes[0].getnodeaddresses(0))\n-            assert_greater_than_or_equal(tokens, addr_count_1)\n-            assert_greater_than_or_equal(addr_count_0 + 600, addr_count_1)\n-            assert_equal(addr_count_1 > addr_count_0, tokens > 0)\n+            # Send 600 addresses. For all but the block-relay-only peer this should result in addresses being processed.\n+            self.send_addrs_and_test_rate_limiting(peer, no_relay, 600, 600)\n \n             # Send 600 more addresses. For the outbound-full-relay peer (which we send a GETADDR, and thus will\n-            # process up to 1001 incoming addresses), this means more entries will appear.\n-            peer.send_and_ping(self.setup_rand_addr_msg(600))\n-            addr_count_2 = len(self.nodes[0].getnodeaddresses(0))\n-            assert_greater_than_or_equal(tokens, addr_count_2)\n-            assert_greater_than_or_equal(addr_count_1 + 600, addr_count_2)\n-            assert_equal(addr_count_2 > addr_count_1, tokens > 600)\n-\n-            # Send 10 more. As we reached the processing limit for all nodes, this should have no effect.\n-            peer.send_and_ping(self.setup_rand_addr_msg(10))\n-            addr_count_3 = len(self.nodes[0].getnodeaddresses(0))\n-            assert_greater_than_or_equal(tokens, addr_count_3)\n-            assert_equal(addr_count_2, addr_count_3)\n-\n-            # Advance the time by 100 seconds, permitting the processing of 10 more addresses. Send 200,\n-            # but verify that no more than 10 are processed.\n+            # process up to 1001 incoming addresses), this means more addresses will be processed.\n+            self.send_addrs_and_test_rate_limiting(peer, no_relay, 600, 1200)\n+\n+            # Send 10 more. As we reached the processing limit for all nodes, no more addresses should be procesesd.\n+            self.send_addrs_and_test_rate_limiting(peer, no_relay, 10, 1210)\n+\n+            # Advance the time by 100 seconds, permitting the processing of 10 more addresses.\n+            # Send 200 and verify that 10 are processed.\n             self.mocktime += 100\n             self.nodes[0].setmocktime(self.mocktime)\n-            new_tokens = 0 if no_relay else 10\n-            tokens += new_tokens\n-            peer.send_and_ping(self.setup_rand_addr_msg(200))\n-            addr_count_4 = len(self.nodes[0].getnodeaddresses(0))\n-            assert_greater_than_or_equal(tokens, addr_count_4)\n-            assert_greater_than_or_equal(addr_count_3 + new_tokens, addr_count_4)\n-\n-            # Advance the time by 1000 seconds, permitting the processing of 100 more addresses. Send 200,\n-            # but verify that no more than 100 are processed (and at least some).\n+            peer.increment_tokens(10)\n+\n+            self.send_addrs_and_test_rate_limiting(peer, no_relay, 200, 1410)\n+\n+            # Advance the time by 1000 seconds, permitting the processing of 100 more addresses.\n+            # Send 200 and verify that 100 are processed.\n             self.mocktime += 1000\n             self.nodes[0].setmocktime(self.mocktime)\n-            new_tokens = 0 if no_relay else 100\n-            tokens += new_tokens\n-            peer.send_and_ping(self.setup_rand_addr_msg(200))\n-            addr_count_5 = len(self.nodes[0].getnodeaddresses(0))\n-            assert_greater_than_or_equal(tokens, addr_count_5)\n-            assert_greater_than_or_equal(addr_count_4 + new_tokens, addr_count_5)\n-            assert_equal(addr_count_5 > addr_count_4, not no_relay)\n+            peer.increment_tokens(100)\n+\n+            self.send_addrs_and_test_rate_limiting(peer, no_relay, 200, 1610)\n \n             self.nodes[0].disconnect_p2ps()\n "
      }
    ]
  }
]