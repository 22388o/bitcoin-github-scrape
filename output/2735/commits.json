[
  {
    "sha": "18e6e3ed07744e2fd0ac077e210068f5ee8a8f26",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxOGU2ZTNlZDA3NzQ0ZTJmZDBhYzA3N2UyMTAwNjhmNWVlOGE4ZjI2",
    "commit": {
      "author": {
        "name": "Vinnie Falco",
        "email": "vinnie.falco@gmail.com",
        "date": "2013-06-04T14:10:25Z"
      },
      "committer": {
        "name": "Vinnie Falco",
        "email": "vinnie.falco@gmail.com",
        "date": "2013-06-04T14:10:25Z"
      },
      "message": "Add coding style document",
      "tree": {
        "sha": "158663d8a0dc05870d44d94cffbb35b05e8acc5b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/158663d8a0dc05870d44d94cffbb35b05e8acc5b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/18e6e3ed07744e2fd0ac077e210068f5ee8a8f26",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/18e6e3ed07744e2fd0ac077e210068f5ee8a8f26",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/18e6e3ed07744e2fd0ac077e210068f5ee8a8f26",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/18e6e3ed07744e2fd0ac077e210068f5ee8a8f26/comments",
    "author": {
      "login": "vinniefalco",
      "id": 1503976,
      "node_id": "MDQ6VXNlcjE1MDM5NzY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1503976?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vinniefalco",
      "html_url": "https://github.com/vinniefalco",
      "followers_url": "https://api.github.com/users/vinniefalco/followers",
      "following_url": "https://api.github.com/users/vinniefalco/following{/other_user}",
      "gists_url": "https://api.github.com/users/vinniefalco/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vinniefalco/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vinniefalco/subscriptions",
      "organizations_url": "https://api.github.com/users/vinniefalco/orgs",
      "repos_url": "https://api.github.com/users/vinniefalco/repos",
      "events_url": "https://api.github.com/users/vinniefalco/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vinniefalco/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "vinniefalco",
      "id": 1503976,
      "node_id": "MDQ6VXNlcjE1MDM5NzY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1503976?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vinniefalco",
      "html_url": "https://github.com/vinniefalco",
      "followers_url": "https://api.github.com/users/vinniefalco/followers",
      "following_url": "https://api.github.com/users/vinniefalco/following{/other_user}",
      "gists_url": "https://api.github.com/users/vinniefalco/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vinniefalco/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vinniefalco/subscriptions",
      "organizations_url": "https://api.github.com/users/vinniefalco/orgs",
      "repos_url": "https://api.github.com/users/vinniefalco/repos",
      "events_url": "https://api.github.com/users/vinniefalco/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vinniefalco/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "365ab225c082277076debeb68ddd75e73f71ac26",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/365ab225c082277076debeb68ddd75e73f71ac26",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/365ab225c082277076debeb68ddd75e73f71ac26"
      }
    ],
    "stats": {
      "total": 216,
      "additions": 216,
      "deletions": 0
    },
    "files": [
      {
        "sha": "642590f07a419811b5c2c387840a6e83bfd6ed18",
        "filename": "CODING_STYLE.md",
        "status": "added",
        "additions": 216,
        "deletions": 0,
        "changes": 216,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/18e6e3ed07744e2fd0ac077e210068f5ee8a8f26/CODING_STYLE.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/18e6e3ed07744e2fd0ac077e210068f5ee8a8f26/CODING_STYLE.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/CODING_STYLE.md?ref=18e6e3ed07744e2fd0ac077e210068f5ee8a8f26",
        "patch": "@@ -0,0 +1,216 @@\n+--------------------------------------------------------------------------------\n+\n+# Coding Standards\n+\n+Coding standards used here are extreme strict and consistent. The style\n+evolved gradually over the years, incorporating generally acknowledged\n+best-practice C++ advice, experience, and personal preference.\n+\n+## Don't Repeat Yourself!\n+\n+The [Don't Repeat Yourself][1] principle summarises the essence of what it\n+means to write good code, in all languages, at all levels.\n+\n+## Formatting\n+\n+The goal of source code formatting should always be to make things as easy to\n+read as possible. White space is used to guide the eye so that details are not\n+overlooked. Blank lines are used to separate code into \"paragraphs.\"\n+\n+* No tab characters please.\n+* Tab stops are set to 4 spaces.\n+* Braces are indented in the [Allman style][2].\n+* Always place a space before and after all binary operators,\n+  especially assignments (`operator=`).\n+* The `!` operator should always be followed by a space.\n+* The `~` operator should be preceded by a space, but not followed by one.\n+* The `++` and `--` operators should have no spaces between the operator and\n+  the operand.\n+* A space never appears before a comma, and always appears after a comma.\n+* Always place a space before an opening parenthesis. One exception is if\n+  the parentheses are empty.\n+* Don't put spaces after a parenthesis. A typical member function call might\n+  look like this: `foobar (1, 2, 3);`\n+* In general, leave a blank line before an `if` statement.\n+* In general, leave a blank line after a closing brace `}`.\n+* Do not place code or comments on the same line as any opening or\n+  closing brace.\n+* Do not write `if` statements all-on-one-line. The exception to this is when\n+  you've got a sequence of similar `if` statements, and are aligning them all\n+  vertically to highlight their similarities.\n+* In an `if-else` statement, if you surround one half of the statement with\n+  braces, you also need to put braces around the other half, to match.\n+* When writing a pointer type, use this spacing: `SomeObject* myObject`.\n+  Technically, a more correct spacing would be `SomeObject *myObject`, but\n+  it makes more sense for the asterisk to be grouped with the type name,\n+  since being a pointer is part of the type, not the variable name. The only\n+  time that this can lead to any problems is when you're declaring multiple\n+  pointers of the same type in the same statement - which leads on to the next\n+  rule:\n+* When declaring multiple pointers, never do so in a single statement, e.g.\n+  `SomeObject* p1, *p2;` - instead, always split them out onto separate lines\n+  and write the type name again, to make it quite clear what's going on, and\n+  avoid the danger of missing out any vital asterisks.\n+* The previous point also applies to references, so always put the `&` next to\n+  the type rather than the variable, e.g. `void foo (Thing const& thing)`. And\n+  don't put a space on both sides of the `*` or `&` - always put a space after\n+  it, but never before it.\n+* The word `const` should be placed to the right of the thing that it modifies,\n+  for consistency. For example `int const` refers to an int which is const.\n+  `int const*` is a pointer to an int which is const. `int *const` is a const\n+  pointer to an int.\n+* Always place a space in between the template angle brackets and the type\n+  name. Template code is already hard enough to read!\n+\n+## Naming conventions\n+\n+* Member variables and method names are written with camel-case, and never\n+  begin with a capital letter.\n+* Class names are also written in camel-case, but always begin with a capital\n+  letter.\n+* For global variables... well, you shouldn't have any, so it doesn't matter.\n+* Class data members begin with `m_`, static data members begin with `s_`.\n+  Global variables begin with `g_`. This is so the scope of the corresponding\n+  declaration can be easily determined.\n+* Avoid underscores in your names, especially leading or trailing underscores.\n+  In particular, leading underscores should be avoided, as these are often used\n+  in standard library code, so to use them in your own code looks quite jarring.\n+* If you really have to write a macro for some reason, then make it all caps,\n+  with underscores to separate the words. And obviously make sure that its name\n+  is unlikely to clash with symbols used in other libraries or 3rd party code.\n+\n+## Types, const-correctness\n+\n+* If a method can (and should!) be const, make it const!\n+* If a method definitely doesn't throw an exception (be careful!), mark it as\n+  `noexcept`\n+* When returning a temporary object, e.g. a String, the returned object should\n+  be non-const, so that if the class has a C++11 move operator, it can be used.\n+* If a local variable can be const, then make it const!\n+* Remember that pointers can be const as well as primitives; For example, if\n+  you have a `char*` whose contents are going to be altered, you may still be\n+  able to make the pointer itself const, e.g. `char* const foobar = getFoobar();`.\n+* Do not declare all your local variables at the top of a function or method\n+  (i.e. in the old-fashioned C-style). Declare them at the last possible moment,\n+  and give them as small a scope as possible.\n+* Object parameters should be passed as `const&` wherever possible. Only\n+  pass a parameter as a copy-by-value object if you really need to mutate\n+  a local copy inside the method, and if making a local copy inside the method\n+  would be difficult.\n+* Use portable `for()` loop variable scoping (i.e. do not have multiple for\n+  loops in the same scope that each re-declare the same variable name, as\n+  this fails on older compilers)\n+* When you're testing a pointer to see if it's null, never write\n+  `if (myPointer)`. Always avoid that implicit cast-to-bool by writing it more\n+  fully: `if (myPointer != nullptr)`. And likewise, never ever write\n+  `if (! myPointer)`, instead always write `if (myPointer == nullptr)`.\n+  It is more readable that way.\n+* Avoid C-style casts except when converting between primitive numeric types.\n+  Some people would say \"avoid C-style casts altogether\", but `static_cast` is\n+  a bit unreadable when you just want to cast an `int` to a `float`. But\n+  whenever a pointer is involved, or a non-primitive object, always use\n+  `static_cast`. And when you're reinterpreting data, always use\n+  `reinterpret_cast`.\n+* Until C++ gets a universal 64-bit primitive type (part of the C++11\n+  standard), it's best to stick to the `int64` and `uint64` typedefs.\n+\n+## Object lifetime and ownership\n+\n+* Absolutely do NOT use `delete`, `deleteAndZero`, etc. There are very very few\n+  situations where you can't use a `ScopedPointer` or some other automatic\n+  lifetime management class.\n+* Do not use `new` unless there's no alternative. Whenever you type `new`, always\n+  treat it as a failure to find a better solution. If a local variable can be\n+  allocated on the stack rather than the heap, then always do so.\n+* Do not ever use `new` or `malloc` to allocate a C++ array. Always use a\n+  `HeapBlock` instead.\n+* And just to make it doubly clear: Never use `malloc` or `calloc`.\n+* If a parent object needs to create and own some kind of child object, always\n+  use composition as your first choice. If that's not possible (e.g. if the\n+  child needs a pointer to the parent for its constructor), then use a\n+  `ScopedPointer`.\n+* If possible, pass an object as a reference rather than a pointer. If possible,\n+  make it a `const` reference.\n+* Obviously avoid static and global values. Sometimes there's no alternative,\n+  but if there is an alternative, then use it, no matter how much effort it\n+  involves.\n+* If allocating a local POD structure (e.g. an operating-system structure in\n+  native code), and you need to initialise it with zeros, use the `= { 0 };`\n+  syntax as your first choice for doing this. If for some reason that's not\n+  appropriate, use the `zerostruct()` function, or in case that isn't suitable,\n+  use `zeromem()`. Don't use `memset()`.\n+\n+## Classes\n+\n+* Declare a class's public section first, and put its constructors and\n+  destructor first. Any protected items come next, and then private ones.\n+* Use the most restrictive access-specifier possible for each member. Prefer\n+  `private` over `protected`, and `protected` over `public`. Don't expose\n+  things unnecessarily.\n+* Preferred positioning for any inherited classes is to put them to the right\n+  of the class name, vertically aligned, e.g.:\n+        class Thing  : public Foo, \n+                       private Bar\n+        {\n+        }\n+* Put a class's member variables (which should almost always be private, of course),\n+  after all the public and protected method declarations.\n+* Any private methods can go towards the end of the class, after the member\n+  variables.\n+* If your class does not have copy-by-value semantics, derive the class from\n+  `Uncopyable`.\n+* If your class is likely to be leaked, then derive your class from\n+  `LeakChecked<>`.\n+* Constructors that take a single parameter should be default be marked\n+  `explicit`. Obviously there are cases where you do want implicit conversion,\n+  but always think about it carefully before writing a non-explicit constructor.\n+* Do not use `NULL`, `null`, or 0 for a null-pointer. And especially never use\n+  '0L', which is particulary burdensome. Use `nullptr` instead - this is the\n+  C++2011 standard, so get used to it. There's a fallback definition for `nullptr`\n+  in Beast, so it's always possible to use it even if your compiler isn't yet\n+  C++2011 compliant.\n+* All the C++ 'guru' books and articles are full of excellent and detailed advice\n+  on when it's best to use inheritance vs composition. If you're not already\n+  familiar with the received wisdom in these matters, then do some reading!\n+\n+## Miscellaneous\n+\n+* `goto` statements should not be used at all, even if the alternative is\n+  more verbose code. The only exception is when implementing an algorithm in\n+  a function as a state machine.\n+* Don't use macros! OK, obviously there are many situations where they're the\n+  right tool for the job, but treat them as a last resort. Certainly don't ever\n+  use a macro just to hold a constant value or to perform any kind of function\n+  that could have been done as a real inline function. And it goes without saying\n+  that you should give them names which aren't going to clash with other code.\n+  And #undef them after you've used them, if possible.\n+* When using the ++ or -- operators, never use post-increment if pre-increment\n+  could be used instead. Although it doesn't matter for primitive types, it's good\n+  practice to pre-increment since this can be much more efficient for more complex\n+  objects. In particular, if you're writing a for loop, always use pre-increment,\n+  e.g. `for (int = 0; i < 10; ++i)`\n+* Never put an \"else\" statement after a \"return\"! This is well-explained in the\n+  LLVM coding standards...and a couple of other very good pieces of advice from\n+  the LLVM standards are in there as well.\n+* When getting a possibly-null pointer and using it only if it's non-null, limit\n+  the scope of the pointer as much as possible - e.g. Do NOT do this:\n+\n+        Foo* f = getFoo ();\n+        if (f != nullptr)\n+            f->doSomething ();\n+        // other code\n+        f->doSomething ();  // oops! f may be null!\n+\n+  ..instead, prefer to write it like this, which reduces the scope of the\n+  pointer, making it impossible to write code that accidentally uses a null\n+  pointer:\n+\n+        if (Foo* f = getFoo ())\n+            f->doSomethingElse ();\n+\n+        // f is out-of-scope here, so impossible to use it if it's null\n+\n+  (This also results in smaller, cleaner code)\n+\n+[1]: http://en.wikipedia.org/wiki/Don%27t_repeat_yourself\n+[2]: http://en.wikipedia.org/wiki/Indent_style#Allman_style"
      }
    ]
  }
]