[
  {
    "sha": "ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjYTkxZDNmZjhhY2ZkYjNiOGRjYTYxYzA4OGJmZmM2ZjlhNzI4NDFi",
    "commit": {
      "author": {
        "name": "victorly",
        "email": "leiyong1413@gmail.com",
        "date": "2018-05-10T03:26:59Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2018-05-10T03:26:59Z"
      },
      "message": "Merge pull request #1 from bitcoin/master\n\nupdate",
      "tree": {
        "sha": "483182d89f4aa4d219868bea17ff7a83e0e5baaa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/483182d89f4aa4d219868bea17ff7a83e0e5baaa"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJa87wDCRBK7hj4Ov3rIwAAdHIIAIhDvMVWG+c1Bmuh6CIvyiPF\nYMLZXuiwxDhjPkrxN0LcQIypWFo7srCsa0w/9aQ91rDZQSGqV+V+X7VMKdSWDMgR\npr/wSTCvRRVJAyQAavhA7N9abLrix9gDZzGYSXfdz154meJJdpbThYAyXGd1jw9x\niux7CyygSDhtPigFoYDoCbIWPuH/IvFs8V880xH8MgRJ7usd/XVeKQLB/f431rcY\n1GWHomJ4DahOq/fZ3RcvWKMXlyrMfiuRjvKFHLnVMXBQ2IoMnFV12anzs82BESOr\nZidIigq8ual/GXH+TLoCF9liQOfSB94B7oJ7ud3KqKA+/lhtufkjBeUbLPeapFg=\n=Wedb\n-----END PGP SIGNATURE-----\n",
        "payload": "tree 483182d89f4aa4d219868bea17ff7a83e0e5baaa\nparent 7466a26cab5d66665991433947964a638f5b957e\nparent 196c5a947a071f7c9c5b211f0a47787a7d540ecb\nauthor victorly <leiyong1413@gmail.com> 1525922819 +0800\ncommitter GitHub <noreply@github.com> 1525922819 +0800\n\nMerge pull request #1 from bitcoin/master\n\nupdate"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/comments",
    "author": {
      "login": "leiyong1413",
      "id": 26705397,
      "node_id": "MDQ6VXNlcjI2NzA1Mzk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/26705397?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/leiyong1413",
      "html_url": "https://github.com/leiyong1413",
      "followers_url": "https://api.github.com/users/leiyong1413/followers",
      "following_url": "https://api.github.com/users/leiyong1413/following{/other_user}",
      "gists_url": "https://api.github.com/users/leiyong1413/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/leiyong1413/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/leiyong1413/subscriptions",
      "organizations_url": "https://api.github.com/users/leiyong1413/orgs",
      "repos_url": "https://api.github.com/users/leiyong1413/repos",
      "events_url": "https://api.github.com/users/leiyong1413/events{/privacy}",
      "received_events_url": "https://api.github.com/users/leiyong1413/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7466a26cab5d66665991433947964a638f5b957e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7466a26cab5d66665991433947964a638f5b957e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7466a26cab5d66665991433947964a638f5b957e"
      },
      {
        "sha": "196c5a947a071f7c9c5b211f0a47787a7d540ecb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/196c5a947a071f7c9c5b211f0a47787a7d540ecb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/196c5a947a071f7c9c5b211f0a47787a7d540ecb"
      }
    ],
    "stats": {
      "total": 20383,
      "additions": 12680,
      "deletions": 7703
    },
    "files": [
      {
        "sha": "1f871de800e4eb6d68517b78dd39b1ceaeefe953",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 34,
        "deletions": 21,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -8,13 +8,13 @@ cache:\n   - depends/built\n   - depends/sdk-sources\n   - $HOME/.ccache\n-git:\n-  depth: 1\n+stages:\n+  - check_doc\n+  - test\n env:\n   global:\n     - MAKEJOBS=-j3\n     - RUN_TESTS=false\n-    - CHECK_DOC=0\n     - BOOST_TEST_RANDOM=1$TRAVIS_BUILD_ID\n     - CCACHE_SIZE=100M\n     - CCACHE_TEMPDIR=/tmp/.ccache-temp\n@@ -24,17 +24,17 @@ env:\n     - WINEDEBUG=fixme-all\n   matrix:\n # ARM\n-    - HOST=arm-linux-gnueabihf PACKAGES=\"g++-arm-linux-gnueabihf python3-pip\" DEP_OPTS=\"NO_QT=1\" CHECK_DOC=1 GOAL=\"install\" BITCOIN_CONFIG=\"--enable-glibc-back-compat --enable-reduce-exports\"\n+    - HOST=arm-linux-gnueabihf PACKAGES=\"g++-arm-linux-gnueabihf\" DEP_OPTS=\"NO_QT=1\" GOAL=\"install\" BITCOIN_CONFIG=\"--enable-glibc-back-compat --enable-reduce-exports\"\n # Win32\n     - HOST=i686-w64-mingw32 DPKG_ADD_ARCH=\"i386\" DEP_OPTS=\"NO_QT=1\" PACKAGES=\"python3 nsis g++-mingw-w64-i686 wine1.6\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-reduce-exports\"\n-# Qt4 & system libs\n-    - HOST=x86_64-unknown-linux-gnu PACKAGES=\"python3-zmq qt4-dev-tools libssl-dev libevent-dev bsdmainutils libboost-system-dev libboost-filesystem-dev libboost-chrono-dev libboost-program-options-dev libboost-test-dev libboost-thread-dev libdb5.1++-dev libminiupnpc-dev libzmq3-dev libprotobuf-dev protobuf-compiler libqrencode-dev xvfb\" NO_DEPENDS=1 NEED_XVFB=1 RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-zmq --with-incompatible-bdb --enable-glibc-back-compat --enable-reduce-exports --with-gui=qt4 CPPFLAGS=-DDEBUG_LOCKORDER\"\n-# 32-bit + dash\n-    - HOST=i686-pc-linux-gnu PACKAGES=\"g++-multilib python3-zmq\" DEP_OPTS=\"NO_QT=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-zmq --enable-glibc-back-compat --enable-reduce-exports LDFLAGS=-static-libstdc++\" USE_SHELL=\"/bin/dash\"\n # Win64\n     - HOST=x86_64-w64-mingw32 DPKG_ADD_ARCH=\"i386\" DEP_OPTS=\"NO_QT=1\" PACKAGES=\"python3 nsis g++-mingw-w64-x86-64 wine1.6\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-reduce-exports\"\n+# 32-bit + dash\n+    - HOST=i686-pc-linux-gnu PACKAGES=\"g++-multilib python3-zmq\" DEP_OPTS=\"NO_QT=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-zmq --enable-glibc-back-compat --enable-reduce-exports LDFLAGS=-static-libstdc++\" USE_SHELL=\"/bin/dash\"\n # x86_64 Linux (uses qt5 dev package instead of depends Qt to speed up build and avoid timeout)\n     - HOST=x86_64-unknown-linux-gnu PACKAGES=\"python3-zmq qtbase5-dev qttools5-dev-tools protobuf-compiler libdbus-1-dev libharfbuzz-dev\" DEP_OPTS=\"NO_QT=1 NO_UPNP=1 DEBUG=1 ALLOW_HOST_PACKAGES=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-zmq --with-gui=qt5 --enable-glibc-back-compat --enable-reduce-exports CPPFLAGS=-DDEBUG_LOCKORDER\"\n+# Qt4 & system libs\n+    - HOST=x86_64-unknown-linux-gnu PACKAGES=\"python3-zmq qt4-dev-tools libssl-dev libevent-dev bsdmainutils libboost-system-dev libboost-filesystem-dev libboost-chrono-dev libboost-program-options-dev libboost-test-dev libboost-thread-dev libdb5.1++-dev libminiupnpc-dev libzmq3-dev libprotobuf-dev protobuf-compiler libqrencode-dev xvfb\" NO_DEPENDS=1 NEED_XVFB=1 RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-zmq --with-incompatible-bdb --enable-glibc-back-compat --enable-reduce-exports --with-gui=qt4 CPPFLAGS=-DDEBUG_LOCKORDER\"\n # x86_64 Linux, No wallet\n     - HOST=x86_64-unknown-linux-gnu PACKAGES=\"python3\" DEP_OPTS=\"NO_WALLET=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-glibc-back-compat --enable-reduce-exports\"\n # Cross-Mac\n@@ -46,17 +46,7 @@ install:\n     - if [ -n \"$DPKG_ADD_ARCH\" ]; then sudo dpkg --add-architecture \"$DPKG_ADD_ARCH\" ; fi\n     - if [ -n \"$PACKAGES\" ]; then travis_retry sudo apt-get update; fi\n     - if [ -n \"$PACKAGES\" ]; then travis_retry sudo apt-get install --no-install-recommends --no-upgrade -qq $PACKAGES; fi\n-    - if [ \"$CHECK_DOC\" = 1 -a \"$TRAVIS_EVENT_TYPE\" = \"pull_request\" ]; then travis_retry pip3 install flake8 --user; fi\n before_script:\n-    - if [ \"$CHECK_DOC\" = 1 ]; then git fetch --unshallow; fi\n-    - if [ \"$CHECK_DOC\" = 1 -a \"$TRAVIS_EVENT_TYPE\" = \"pull_request\" ]; then contrib/devtools/commit-script-check.sh $TRAVIS_COMMIT_RANGE; fi\n-    - if [ \"$CHECK_DOC\" = 1 ]; then contrib/devtools/git-subtree-check.sh src/crypto/ctaes; fi\n-    - if [ \"$CHECK_DOC\" = 1 ]; then contrib/devtools/git-subtree-check.sh src/secp256k1; fi\n-    - if [ \"$CHECK_DOC\" = 1 ]; then contrib/devtools/git-subtree-check.sh src/univalue; fi\n-    - if [ \"$CHECK_DOC\" = 1 ]; then contrib/devtools/git-subtree-check.sh src/leveldb; fi\n-    - if [ \"$CHECK_DOC\" = 1 ]; then contrib/devtools/check-doc.py; fi\n-    - if [ \"$CHECK_DOC\" = 1 ]; then contrib/devtools/check-rpc-mappings.py .; fi\n-    - if [ \"$CHECK_DOC\" = 1 -a \"$TRAVIS_EVENT_TYPE\" = \"pull_request\" ]; then contrib/devtools/lint-all.sh; fi\n     - unset CC; unset CXX\n     - mkdir -p depends/SDKs depends/sdk-sources\n     - if [ -n \"$OSX_SDK\" -a ! -f depends/sdk-sources/MacOSX${OSX_SDK}.sdk.tar.gz ]; then curl --location --fail $SDK_URL/MacOSX${OSX_SDK}.sdk.tar.gz -o depends/sdk-sources/MacOSX${OSX_SDK}.sdk.tar.gz; fi\n@@ -65,8 +55,6 @@ before_script:\n     # Start xvfb if needed, as documented at https://docs.travis-ci.com/user/gui-and-headless-browsers/#Using-xvfb-to-Run-Tests-That-Require-a-GUI\n     - if [ \"$NEED_XVFB\" = 1 ]; then export DISPLAY=:99.0; /sbin/start-stop-daemon --start --pidfile /tmp/custom_xvfb_99.pid --make-pidfile --background --exec /usr/bin/Xvfb -- :99 -ac; fi\n script:\n-    - if [ \"$CHECK_DOC\" = 1 -a \"$TRAVIS_REPO_SLUG\" = \"bitcoin/bitcoin\" -a \"$TRAVIS_PULL_REQUEST\" = \"false\" ]; then while read LINE; do travis_retry gpg --keyserver hkp://subset.pool.sks-keyservers.net --recv-keys $LINE; done < contrib/verify-commits/trusted-keys; fi\n-    - if [ \"$CHECK_DOC\" = 1 -a \"$TRAVIS_REPO_SLUG\" = \"bitcoin/bitcoin\" -a \"$TRAVIS_PULL_REQUEST\" = \"false\" ]; then contrib/verify-commits/verify-commits.sh; fi\n     - export TRAVIS_COMMIT_LOG=`git log --format=fuller -1`\n     - if [ -n \"$USE_SHELL\" ]; then export CONFIG_SHELL=\"$USE_SHELL\"; fi\n     - OUTDIR=$BASE_OUTDIR/$TRAVIS_PULL_REQUEST/$TRAVIS_JOB_NUMBER-$HOST\n@@ -82,7 +70,32 @@ script:\n     - export LD_LIBRARY_PATH=$TRAVIS_BUILD_DIR/depends/$HOST/lib\n     - if [ \"$RUN_TESTS\" = \"true\" ]; then travis_wait 50 make $MAKEJOBS check VERBOSE=1; fi\n     - if [ \"$TRAVIS_EVENT_TYPE\" = \"cron\" ]; then extended=\"--extended --exclude feature_pruning,feature_dbcrash\"; fi\n-    - if [ \"$RUN_TESTS\" = \"true\" ]; then test/functional/test_runner.py --combinedlogslen=4000 --coverage --quiet ${extended}; fi\n+    - if [ \"$RUN_TESTS\" = \"true\" ]; then test/functional/test_runner.py --combinedlogslen=4000 --coverage --quiet --failfast ${extended}; fi\n after_script:\n     - echo $TRAVIS_COMMIT_RANGE\n     - echo $TRAVIS_COMMIT_LOG\n+\n+jobs:\n+  include:\n+    - stage: check_doc\n+      sudo: false\n+      addons:\n+        apt:\n+          packages:\n+            - python3-pip\n+            - shellcheck\n+      install:\n+        - if [ \"$TRAVIS_EVENT_TYPE\" = \"pull_request\" ]; then travis_retry pip3 install flake8 --user; fi\n+      before_script:\n+        - git fetch --unshallow\n+        - if [ \"$TRAVIS_EVENT_TYPE\" = \"pull_request\" ]; then contrib/devtools/commit-script-check.sh $TRAVIS_COMMIT_RANGE; fi\n+        - contrib/devtools/git-subtree-check.sh src/crypto/ctaes\n+        - contrib/devtools/git-subtree-check.sh src/secp256k1\n+        - contrib/devtools/git-subtree-check.sh src/univalue\n+        - contrib/devtools/git-subtree-check.sh src/leveldb\n+        - contrib/devtools/check-doc.py\n+        - contrib/devtools/check-rpc-mappings.py .\n+        - if [ \"$TRAVIS_EVENT_TYPE\" = \"pull_request\" ]; then contrib/devtools/lint-all.sh; fi\n+      script:\n+        - if [ \"$TRAVIS_REPO_SLUG\" = \"bitcoin/bitcoin\" -a \"$TRAVIS_PULL_REQUEST\" = \"false\" ]; then while read LINE; do travis_retry gpg --keyserver hkp://subset.pool.sks-keyservers.net --recv-keys $LINE; done < contrib/verify-commits/trusted-keys; fi\n+        - if [ \"$TRAVIS_REPO_SLUG\" = \"bitcoin/bitcoin\" -a \"$TRAVIS_EVENT_TYPE\" = \"cron\" ]; then travis_wait 30 contrib/verify-commits/verify-commits.sh; fi"
      },
      {
        "sha": "c390595abf285f5e2411f2b348819fd9d3a6b22a",
        "filename": "CONTRIBUTING.md",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/CONTRIBUTING.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/CONTRIBUTING.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/CONTRIBUTING.md?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -14,6 +14,9 @@ purposes. As such there are repository \"maintainers\" who are responsible for\n merging pull requests as well as a \"lead maintainer\" who is responsible for the\n release cycle, overall merging, moderation and appointment of maintainers.\n \n+If you're looking for somewhere to start contributing, check out the\n+[good first issue](https://github.com/bitcoin/bitcoin/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22)\n+list.\n \n Communication Channels\n ----------------------"
      },
      {
        "sha": "8a8debb079d499485ff950726ce53b7f2843b3e0",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -269,7 +269,8 @@ EXTRA_DIST += \\\n     test/util/data/txcreatescript4.json \\\n     test/util/data/txcreatesignv1.hex \\\n     test/util/data/txcreatesignv1.json \\\n-    test/util/data/txcreatesignv2.hex\n+    test/util/data/txcreatesignv2.hex \\\n+    test/util/rpcauth-test.py\n \n CLEANFILES = $(OSX_DMG) $(BITCOIN_WIN_INSTALLER)\n \n@@ -293,6 +294,5 @@ clean-docs:\n \trm -rf doc/doxygen\n \n clean-local: clean-docs\n-\trm -rf coverage_percent.txt test_bitcoin.coverage/ total.coverage/ test/tmp/ cache/ $(OSX_APP)\n+\trm -rf coverage_percent.txt test_bitcoin.coverage/ total.coverage/ test/tmp/ cache/ $(OSX_APP) src/qt/moc_*\n \trm -rf test/functional/__pycache__ test/functional/test_framework/__pycache__ test/cache\n-"
      },
      {
        "sha": "ce9e683eda03233b637510aaadae5ad5d45adb22",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 32,
        "deletions": 6,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -84,7 +84,7 @@ AC_PATH_TOOL(STRIP, strip)\n AC_PATH_TOOL(GCOV, gcov)\n AC_PATH_PROG(LCOV, lcov)\n dnl Python 3.x is supported from 3.4 on (see https://github.com/bitcoin/bitcoin/issues/7893)\n-AC_PATH_PROGS([PYTHON], [python3.6 python3.5 python3.4 python3 python2.7 python2 python])\n+AC_PATH_PROGS([PYTHON], [python3.7 python3.6 python3.5 python3.4 python3 python])\n AC_PATH_PROG(GENHTML, genhtml)\n AC_PATH_PROG([GIT], [git])\n AC_PATH_PROG(CCACHE,ccache)\n@@ -219,6 +219,12 @@ AC_ARG_ENABLE([debug],\n     [enable_debug=$enableval],\n     [enable_debug=no])\n \n+# Enable different -fsanitize options\n+AC_ARG_WITH([sanitizers],\n+    [AS_HELP_STRING([--with-sanitizers],\n+                    [comma separated list of extra sanitizers to build with (default is none enabled)])],\n+    [use_sanitizers=$withval])\n+\n # Enable gprof profiling\n AC_ARG_ENABLE([gprof],\n     [AS_HELP_STRING([--enable-gprof],\n@@ -247,6 +253,26 @@ if test \"x$enable_debug\" = xyes; then\n     fi\n fi\n \n+if test x$use_sanitizers != x; then\n+  # First check if the compiler accepts flags. If an incompatible pair like\n+  # -fsanitize=address,thread is used here, this check will fail. This will also\n+  # fail if a bad argument is passed, e.g. -fsanitize=undfeined\n+  AX_CHECK_COMPILE_FLAG(\n+    [[-fsanitize=$use_sanitizers]],\n+    [[SANITIZER_CXXFLAGS=-fsanitize=$use_sanitizers]],\n+    [AC_MSG_ERROR([compiler did not accept requested flags])])\n+\n+  # Some compilers (e.g. GCC) require additional libraries like libasan,\n+  # libtsan, libubsan, etc. Make sure linking still works with the sanitize\n+  # flag. This is a separate check so we can give a better error message when\n+  # the sanitize flags are supported by the compiler but the actual sanitizer\n+  # libs are missing.\n+  AX_CHECK_LINK_FLAG(\n+    [[-fsanitize=$use_sanitizers]],\n+    [[SANITIZER_LDFLAGS=-fsanitize=$use_sanitizers]],\n+    [AC_MSG_ERROR([linker did not accept requested flags, you are missing required libraries])])\n+fi\n+\n ERROR_CXXFLAGS=\n if test \"x$enable_werror\" = \"xyes\"; then\n   if test \"x$CXXFLAG_WERROR\" = \"x\"; then\n@@ -604,11 +630,7 @@ if test x$use_hardening != xno; then\n   AX_CHECK_LINK_FLAG([[-Wl,--high-entropy-va]], [HARDENED_LDFLAGS=\"$HARDENED_LDFLAGS -Wl,--high-entropy-va\"])\n   AX_CHECK_LINK_FLAG([[-Wl,-z,relro]], [HARDENED_LDFLAGS=\"$HARDENED_LDFLAGS -Wl,-z,relro\"])\n   AX_CHECK_LINK_FLAG([[-Wl,-z,now]], [HARDENED_LDFLAGS=\"$HARDENED_LDFLAGS -Wl,-z,now\"])\n-\n-  if test x$TARGET_OS != xwindows; then\n-    AX_CHECK_COMPILE_FLAG([-fPIE],[PIE_FLAGS=\"-fPIE\"])\n-    AX_CHECK_LINK_FLAG([[-pie]], [HARDENED_LDFLAGS=\"$HARDENED_LDFLAGS -pie\"])\n-  fi\n+  AX_CHECK_LINK_FLAG([[-fPIE -pie]], [PIE_FLAGS=\"-fPIE\"; HARDENED_LDFLAGS=\"$HARDENED_LDFLAGS -pie\"],, [[$CXXFLAG_WERROR]])\n \n   case $host in\n     *mingw*)\n@@ -1258,6 +1280,8 @@ AC_SUBST(HARDENED_CPPFLAGS)\n AC_SUBST(HARDENED_LDFLAGS)\n AC_SUBST(PIC_FLAGS)\n AC_SUBST(PIE_FLAGS)\n+AC_SUBST(SANITIZER_CXXFLAGS)\n+AC_SUBST(SANITIZER_LDFLAGS)\n AC_SUBST(SSE42_CXXFLAGS)\n AC_SUBST(LIBTOOL_APP_LDFLAGS)\n AC_SUBST(USE_UPNP)\n@@ -1280,6 +1304,7 @@ AM_COND_IF([HAVE_DOXYGEN], [AC_CONFIG_FILES([doc/Doxyfile])])\n AC_CONFIG_LINKS([contrib/filter-lcov.py:contrib/filter-lcov.py])\n AC_CONFIG_LINKS([test/functional/test_runner.py:test/functional/test_runner.py])\n AC_CONFIG_LINKS([test/util/bitcoin-util-test.py:test/util/bitcoin-util-test.py])\n+AC_CONFIG_LINKS([test/util/rpcauth-test.py:test/util/rpcauth-test.py])\n \n dnl boost's m4 checks do something really nasty: they export these vars. As a\n dnl result, they leak into secp256k1's configure and crazy things happen.\n@@ -1345,6 +1370,7 @@ echo \"  with test     = $use_tests\"\n echo \"  with bench    = $use_bench\"\n echo \"  with upnp     = $use_upnp\"\n echo \"  use asm       = $use_asm\"\n+echo \"  sanitizers    = $use_sanitizers\"\n echo \"  debug enabled = $enable_debug\"\n echo \"  gprof enabled = $enable_gprof\"\n echo \"  werror        = $enable_werror\""
      },
      {
        "sha": "8b312226482e1e937458133df92032092d5b7cb6",
        "filename": "contrib/debian/bitcoin-qt.desktop",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/debian/bitcoin-qt.desktop",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/debian/bitcoin-qt.desktop",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/bitcoin-qt.desktop?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -10,5 +10,5 @@ Terminal=false\n Type=Application\n Icon=bitcoin128\n MimeType=x-scheme-handler/bitcoin;\n-Categories=Office;Finance;\n+Categories=Office;Finance;P2P;Network;Qt;\n StartupWMClass=Bitcoin-qt"
      },
      {
        "sha": "15ee8a3959b1428432f430165923591cbc1bb7b0",
        "filename": "contrib/devtools/README.md",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/devtools/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/devtools/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/README.md?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -144,6 +144,14 @@ Configuring the github-merge tool for the bitcoin repository is done in the foll\n     git config githubmerge.testcmd \"make -j4 check\" (adapt to whatever you want to use for testing)\n     git config --global user.signingkey mykeyid (if you want to GPG sign)\n \n+Create and verify timestamps of merge commits\n+---------------------------------------------\n+To create or verify timestamps on the merge commits, install the OpenTimestamps\n+client via `pip3 install opentimestamps-client`. Then, dowload the gpg wrapper\n+`ots-git-gpg-wrapper.sh` and set it as git's `gpg.program`. See\n+[the ots git integration documentation](https://github.com/opentimestamps/opentimestamps-client/blob/master/doc/git-integration.md#usage)\n+for further details.\n+\n optimize-pngs.py\n ================\n "
      },
      {
        "sha": "de5719eb29e63a20cca8392aed6b1fc62890c47c",
        "filename": "contrib/devtools/check-doc.py",
        "status": "modified",
        "additions": 24,
        "deletions": 22,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/devtools/check-doc.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/devtools/check-doc.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/check-doc.py?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/env python\n+#!/usr/bin/env python3\n # Copyright (c) 2015-2017 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n@@ -16,31 +16,33 @@\n \n FOLDER_GREP = 'src'\n FOLDER_TEST = 'src/test/'\n-CMD_ROOT_DIR = '`git rev-parse --show-toplevel`/%s' % FOLDER_GREP\n-CMD_GREP_ARGS = r\"egrep -r -I '(map(Multi)?Args(\\.count\\(|\\[)|Get(Bool)?Arg\\()\\\"\\-[^\\\"]+?\\\"' %s | grep -v '%s'\" % (CMD_ROOT_DIR, FOLDER_TEST)\n-CMD_GREP_DOCS = r\"egrep -r -I 'HelpMessageOpt\\(\\\"\\-[^\\\"=]+?(=|\\\")' %s\" % (CMD_ROOT_DIR)\n-REGEX_ARG = re.compile(r'(?:map(?:Multi)?Args(?:\\.count\\(|\\[)|Get(?:Bool)?Arg\\()\\\"(\\-[^\\\"]+?)\\\"')\n-REGEX_DOC = re.compile(r'HelpMessageOpt\\(\\\"(\\-[^\\\"=]+?)(?:=|\\\")')\n+REGEX_ARG = '(?:ForceSet|SoftSet|Get|Is)(?:Bool)?Args?(?:Set)?\\(\"(-[^\"]+)\"'\n+REGEX_DOC = 'AddArg\\(\"(-[^\"=]+?)(?:=|\")'\n+CMD_ROOT_DIR = '`git rev-parse --show-toplevel`/{}'.format(FOLDER_GREP)\n+CMD_GREP_ARGS = r\"git grep --perl-regexp '{}' -- {} ':(exclude){}'\".format(REGEX_ARG, CMD_ROOT_DIR, FOLDER_TEST)\n+CMD_GREP_DOCS = r\"git grep --perl-regexp '{}' {}\".format(REGEX_DOC, CMD_ROOT_DIR)\n # list unsupported, deprecated and duplicate args as they need no documentation\n SET_DOC_OPTIONAL = set(['-rpcssl', '-benchmark', '-h', '-help', '-socks', '-tor', '-debugnet', '-whitelistalwaysrelay', '-prematurewitness', '-walletprematurewitness', '-promiscuousmempoolflags', '-blockminsize', '-dbcrashratio', '-forcecompactdb', '-usehd'])\n \n+\n def main():\n-  used = check_output(CMD_GREP_ARGS, shell=True)\n-  docd = check_output(CMD_GREP_DOCS, shell=True)\n-\n-  args_used = set(re.findall(REGEX_ARG,used))\n-  args_docd = set(re.findall(REGEX_DOC,docd)).union(SET_DOC_OPTIONAL)\n-  args_need_doc = args_used.difference(args_docd)\n-  args_unknown = args_docd.difference(args_used)\n-\n-  print \"Args used        : %s\" % len(args_used)\n-  print \"Args documented  : %s\" % len(args_docd)\n-  print \"Args undocumented: %s\" % len(args_need_doc)\n-  print args_need_doc\n-  print \"Args unknown     : %s\" % len(args_unknown)\n-  print args_unknown\n-\n-  sys.exit(len(args_need_doc))\n+    used = check_output(CMD_GREP_ARGS, shell=True, universal_newlines=True)\n+    docd = check_output(CMD_GREP_DOCS, shell=True, universal_newlines=True)\n+\n+    args_used = set(re.findall(re.compile(REGEX_ARG), used))\n+    args_docd = set(re.findall(re.compile(REGEX_DOC), docd)).union(SET_DOC_OPTIONAL)\n+    args_need_doc = args_used.difference(args_docd)\n+    args_unknown = args_docd.difference(args_used)\n+\n+    print(\"Args used        : {}\".format(len(args_used)))\n+    print(\"Args documented  : {}\".format(len(args_docd)))\n+    print(\"Args undocumented: {}\".format(len(args_need_doc)))\n+    print(args_need_doc)\n+    print(\"Args unknown     : {}\".format(len(args_unknown)))\n+    print(args_unknown)\n+\n+    sys.exit(len(args_need_doc))\n+\n \n if __name__ == \"__main__\":\n     main()"
      },
      {
        "sha": "5402870fbab15be89b38cf8deeffe425a51c27d0",
        "filename": "contrib/devtools/clang-format-diff.py",
        "status": "modified",
        "additions": 11,
        "deletions": 9,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/devtools/clang-format-diff.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/devtools/clang-format-diff.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/clang-format-diff.py?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/env python\n+#!/usr/bin/env python3\n #\n #===- clang-format-diff.py - ClangFormat Diff Reformatter ----*- python -*--===#\n #\n@@ -69,10 +69,9 @@\n \n import argparse\n import difflib\n+import io\n import re\n-import string\n import subprocess\n-import StringIO\n import sys\n \n \n@@ -133,30 +132,33 @@ def main():\n           ['-lines', str(start_line) + ':' + str(end_line)])\n \n   # Reformat files containing changes in place.\n-  for filename, lines in lines_by_file.iteritems():\n+  for filename, lines in lines_by_file.items():\n     if args.i and args.verbose:\n-      print 'Formatting', filename\n+      print('Formatting {}'.format(filename))\n     command = [binary, filename]\n     if args.i:\n       command.append('-i')\n     if args.sort_includes:\n       command.append('-sort-includes')\n     command.extend(lines)\n     command.extend(['-style=file', '-fallback-style=none'])\n-    p = subprocess.Popen(command, stdout=subprocess.PIPE,\n-                         stderr=None, stdin=subprocess.PIPE)\n+    p = subprocess.Popen(command,\n+                         stdout=subprocess.PIPE,\n+                         stderr=None,\n+                         stdin=subprocess.PIPE,\n+                         universal_newlines=True)\n     stdout, stderr = p.communicate()\n     if p.returncode != 0:\n       sys.exit(p.returncode)\n \n     if not args.i:\n       with open(filename) as f:\n         code = f.readlines()\n-      formatted_code = StringIO.StringIO(stdout).readlines()\n+      formatted_code = io.StringIO(stdout).readlines()\n       diff = difflib.unified_diff(code, formatted_code,\n                                   filename, filename,\n                                   '(before formatting)', '(after formatting)')\n-      diff_string = string.join(diff, '')\n+      diff_string = ''.join(diff)\n       if len(diff_string) > 0:\n         sys.stdout.write(diff_string)\n "
      },
      {
        "sha": "e7cccaab036b32d55fa6f3d073f9498a25f98cc5",
        "filename": "contrib/devtools/copyright_header.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/devtools/copyright_header.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/devtools/copyright_header.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/copyright_header.py?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -286,7 +286,7 @@ def exec_report(base_directory, verbose):\n def report_cmd(argv):\n     if len(argv) == 2:\n         sys.exit(REPORT_USAGE)\n-        \n+\n     base_directory = argv[2]\n     if not os.path.exists(base_directory):\n         sys.exit(\"*** bad <base_directory>: %s\" % base_directory)\n@@ -444,7 +444,7 @@ def print_file_action_message(filename, action):\n def update_cmd(argv):\n     if len(argv) != 3:\n         sys.exit(UPDATE_USAGE)\n-    \n+\n     base_directory = argv[2]\n     if not os.path.exists(base_directory):\n         sys.exit(\"*** bad base_directory: %s\" % base_directory)\n@@ -570,13 +570,13 @@ def insert_cmd(argv):\n     _, extension = os.path.splitext(filename)\n     if extension not in ['.h', '.cpp', '.cc', '.c', '.py']:\n         sys.exit(\"*** cannot insert for file extension %s\" % extension)\n-   \n+\n     if extension == '.py': \n         style = 'python'\n     else:\n         style = 'cpp'\n     exec_insert_header(filename, style)\n-         \n+\n ################################################################################\n # UI\n ################################################################################"
      },
      {
        "sha": "187ef75fb7183eac7b919c19609f7302ddf74d18",
        "filename": "contrib/devtools/github-merge.py",
        "status": "modified",
        "additions": 11,
        "deletions": 10,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/devtools/github-merge.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/devtools/github-merge.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/github-merge.py?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -21,7 +21,8 @@\n import hashlib\n import subprocess\n import sys\n-import json,codecs\n+import json\n+import codecs\n try:\n     from urllib.request import Request,urlopen\n except:\n@@ -46,7 +47,7 @@ def git_config_get(option, default=None):\n     '''\n     try:\n         return subprocess.check_output([GIT,'config','--get',option]).rstrip().decode('utf-8')\n-    except subprocess.CalledProcessError as e:\n+    except subprocess.CalledProcessError:\n         return default\n \n def retrieve_pr_info(repo,pull):\n@@ -193,23 +194,23 @@ def main():\n     devnull = open(os.devnull,'w')\n     try:\n         subprocess.check_call([GIT,'checkout','-q',branch])\n-    except subprocess.CalledProcessError as e:\n+    except subprocess.CalledProcessError:\n         print(\"ERROR: Cannot check out branch %s.\" % (branch), file=stderr)\n         sys.exit(3)\n     try:\n         subprocess.check_call([GIT,'fetch','-q',host_repo,'+refs/pull/'+pull+'/*:refs/heads/pull/'+pull+'/*',\n                                                           '+refs/heads/'+branch+':refs/heads/'+base_branch])\n-    except subprocess.CalledProcessError as e:\n+    except subprocess.CalledProcessError:\n         print(\"ERROR: Cannot find pull request #%s or branch %s on %s.\" % (pull,branch,host_repo), file=stderr)\n         sys.exit(3)\n     try:\n         subprocess.check_call([GIT,'log','-q','-1','refs/heads/'+head_branch], stdout=devnull, stderr=stdout)\n-    except subprocess.CalledProcessError as e:\n+    except subprocess.CalledProcessError:\n         print(\"ERROR: Cannot find head of pull request #%s on %s.\" % (pull,host_repo), file=stderr)\n         sys.exit(3)\n     try:\n         subprocess.check_call([GIT,'log','-q','-1','refs/heads/'+merge_branch], stdout=devnull, stderr=stdout)\n-    except subprocess.CalledProcessError as e:\n+    except subprocess.CalledProcessError:\n         print(\"ERROR: Cannot find merge of pull request #%s on %s.\" % (pull,host_repo), file=stderr)\n         sys.exit(3)\n     subprocess.check_call([GIT,'checkout','-q',base_branch])\n@@ -230,7 +231,7 @@ def main():\n         message += '\\n\\nPull request description:\\n\\n  ' + body.replace('\\n', '\\n  ') + '\\n'\n         try:\n             subprocess.check_call([GIT,'merge','-q','--commit','--no-edit','--no-ff','-m',message.encode('utf-8'),head_branch])\n-        except subprocess.CalledProcessError as e:\n+        except subprocess.CalledProcessError:\n             print(\"ERROR: Cannot be merged cleanly.\",file=stderr)\n             subprocess.check_call([GIT,'merge','--abort'])\n             sys.exit(4)\n@@ -249,12 +250,12 @@ def main():\n         try:\n             first_sha512 = tree_sha512sum()\n             message += '\\n\\nTree-SHA512: ' + first_sha512\n-        except subprocess.CalledProcessError as e:\n+        except subprocess.CalledProcessError:\n             print(\"ERROR: Unable to compute tree hash\")\n             sys.exit(4)\n         try:\n             subprocess.check_call([GIT,'commit','--amend','-m',message.encode('utf-8')])\n-        except subprocess.CalledProcessError as e:\n+        except subprocess.CalledProcessError:\n             print(\"ERROR: Cannot update message.\", file=stderr)\n             sys.exit(4)\n \n@@ -299,7 +300,7 @@ def main():\n                 try:\n                     subprocess.check_call([GIT,'commit','-q','--gpg-sign','--amend','--no-edit'])\n                     break\n-                except subprocess.CalledProcessError as e:\n+                except subprocess.CalledProcessError:\n                     print(\"Error while signing, asking again.\",file=stderr)\n             elif reply == 'x':\n                 print(\"Not signing off on merge, exiting.\",file=stderr)"
      },
      {
        "sha": "6a0dd556bbd76343941aaf8953bf855c64cde817",
        "filename": "contrib/devtools/lint-include-guards.sh",
        "status": "added",
        "additions": 29,
        "deletions": 0,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/devtools/lint-include-guards.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/devtools/lint-include-guards.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/lint-include-guards.sh?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -0,0 +1,29 @@\n+#!/bin/bash\n+#\n+# Copyright (c) 2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+# Check include guards.\n+\n+HEADER_ID_PREFIX=\"BITCOIN_\"\n+HEADER_ID_SUFFIX=\"_H\"\n+\n+REGEXP_EXCLUDE_FILES_WITH_PREFIX=\"src/(crypto/ctaes/|leveldb/|secp256k1/|tinyformat.h|univalue/)\"\n+\n+EXIT_CODE=0\n+for HEADER_FILE in $(git ls-files -- \"*.h\" | grep -vE \"^${REGEXP_EXCLUDE_FILES_WITH_PREFIX}\")\n+do\n+    HEADER_ID_BASE=$(cut -f2- -d/ <<< \"${HEADER_FILE}\" | sed \"s/\\.h$//g\" | tr / _ | tr \"[:lower:]\" \"[:upper:]\")\n+    HEADER_ID=\"${HEADER_ID_PREFIX}${HEADER_ID_BASE}${HEADER_ID_SUFFIX}\"\n+    if [[ $(grep -cE \"^#(ifndef|define) ${HEADER_ID}\" \"${HEADER_FILE}\") != 2 ]]; then\n+        echo \"${HEADER_FILE} seems to be missing the expected include guard:\"\n+        echo \"  #ifndef ${HEADER_ID}\"\n+        echo \"  #define ${HEADER_ID}\"\n+        echo \"  ...\"\n+        echo \"  #endif // ${HEADER_ID}\"\n+        echo\n+        EXIT_CODE=1\n+    fi\n+done\n+exit ${EXIT_CODE}"
      },
      {
        "sha": "f54be46b529da74c7a95894c1cb25152da084a5b",
        "filename": "contrib/devtools/lint-includes.sh",
        "status": "added",
        "additions": 32,
        "deletions": 0,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/devtools/lint-includes.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/devtools/lint-includes.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/lint-includes.sh?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -0,0 +1,32 @@\n+#!/bin/bash\n+#\n+# Copyright (c) 2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+# Check for duplicate includes.\n+\n+filter_suffix() {\n+    git ls-files | grep -E \"^src/.*\\.${1}\"'$' | grep -Ev \"/(leveldb|secp256k1|univalue)/\"\n+}\n+\n+EXIT_CODE=0\n+for HEADER_FILE in $(filter_suffix h); do\n+    DUPLICATE_INCLUDES_IN_HEADER_FILE=$(grep -E \"^#include \" < \"${HEADER_FILE}\" | sort | uniq -d)\n+    if [[ ${DUPLICATE_INCLUDES_IN_HEADER_FILE} != \"\" ]]; then\n+        echo \"Duplicate include(s) in ${HEADER_FILE}:\"\n+        echo \"${DUPLICATE_INCLUDES_IN_HEADER_FILE}\"\n+        echo\n+        EXIT_CODE=1\n+    fi\n+done\n+for CPP_FILE in $(filter_suffix cpp); do\n+    DUPLICATE_INCLUDES_IN_CPP_FILE=$(grep -E \"^#include \" < \"${CPP_FILE}\" | sort | uniq -d)\n+    if [[ ${DUPLICATE_INCLUDES_IN_CPP_FILE} != \"\" ]]; then\n+        echo \"Duplicate include(s) in ${CPP_FILE}:\"\n+        echo \"${DUPLICATE_INCLUDES_IN_CPP_FILE}\"\n+        echo\n+        EXIT_CODE=1\n+    fi\n+done\n+exit ${EXIT_CODE}"
      },
      {
        "sha": "35be13ec197fd6fd34b8b9d0bd6c5f51f08612b2",
        "filename": "contrib/devtools/lint-logs.sh",
        "status": "added",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/devtools/lint-logs.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/devtools/lint-logs.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/lint-logs.sh?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -0,0 +1,26 @@\n+#!/bin/bash\n+#\n+# Copyright (c) 2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+# Check that all logs are terminated with '\\n'\n+#\n+# Some logs are continued over multiple lines. They should be explicitly\n+# commented with \\* Continued *\\\n+#\n+# There are some instances of LogPrintf() in comments. Those can be\n+# ignored\n+\n+\n+UNTERMINATED_LOGS=$(git grep --extended-regexp \"LogPrintf?\\(\" -- \"*.cpp\" | \\\n+    grep -v '\\\\n\"' | \\\n+    grep -v \"/\\* Continued \\*/\" | \\\n+    grep -v \"LogPrint()\" | \\\n+    grep -v \"LogPrintf()\")\n+if [[ ${UNTERMINATED_LOGS} != \"\" ]]; then\n+    echo \"All calls to LogPrintf() and LogPrint() should be terminated with \\\\n\"\n+    echo\n+    echo \"${UNTERMINATED_LOGS}\"\n+    exit 1\n+fi"
      },
      {
        "sha": "f5c5971c0379fde7bc9bcaa858e74bab23d003bd",
        "filename": "contrib/devtools/lint-python-shebang.sh",
        "status": "added",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/devtools/lint-python-shebang.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/devtools/lint-python-shebang.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/lint-python-shebang.sh?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -0,0 +1,11 @@\n+#!/bin/bash\n+# Shebang must use python3 (not python or python2)\n+EXIT_CODE=0\n+for PYTHON_FILE in $(git ls-files -- \"*.py\"); do\n+    if [[ $(head -c 2 \"${PYTHON_FILE}\") == \"#!\" &&\n+          $(head -n 1 \"${PYTHON_FILE}\") != \"#!/usr/bin/env python3\" ]]; then\n+        echo \"Missing shebang \\\"#!/usr/bin/env python3\\\" in ${PYTHON_FILE} (do not use python or python2)\"\n+        EXIT_CODE=1\n+    fi\n+done\n+exit ${EXIT_CODE}"
      },
      {
        "sha": "239337000dc8c6d48f2c2cb0b1eecc7ac985600e",
        "filename": "contrib/devtools/lint-python.sh",
        "status": "modified",
        "additions": 12,
        "deletions": 1,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/devtools/lint-python.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/devtools/lint-python.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/lint-python.sh?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -15,21 +15,28 @@\n # E133 closing bracket is missing indentation\n # E223 tab before operator\n # E224 tab after operator\n+# E242 tab after ','\n+# E266 too many leading '#' for block comment\n # E271 multiple spaces after keyword\n # E272 multiple spaces before keyword\n # E273 tab after keyword\n # E274 tab before keyword\n # E275 missing whitespace after keyword\n # E304 blank lines found after function decorator\n # E306 expected 1 blank line before a nested definition\n+# E401 multiple imports on one line\n+# E402 module level import not at top of file\n # E502 the backslash is redundant between brackets\n+# E701 multiple statements on one line (colon)\n # E702 multiple statements on one line (semicolon)\n # E703 statement ends with a semicolon\n # E714 test for object identity should be \"is not\"\n # E721 do not compare types, use \"isinstance()\"\n # E741 do not use variables named \"l\", \"O\", or \"I\"\n # E742 do not define classes named \"l\", \"O\", or \"I\"\n # E743 do not define functions named \"l\", \"O\", or \"I\"\n+# E901 SyntaxError: invalid syntax\n+# E902 TokenError: EOF in multi-line string\n # F401 module imported but unused\n # F402 import module from line N shadowed by loop variable\n # F404 future import(s) name after other statements\n@@ -49,15 +56,19 @@\n # F707 an except: block as not the last exception handler\n # F811 redefinition of unused name from line N\n # F812 list comprehension redefines 'foo' from line N\n+# F821 undefined name 'Foo'\n # F822 undefined name name in __all__\n # F823 local variable name \u2026 referenced before assignment\n # F831 duplicate argument name in function definition\n+# F841 local variable 'foo' is assigned to but never used\n # W292 no newline at end of file\n+# W293 blank line contains whitespace\n # W504 line break after binary operator\n # W601 .has_key() is deprecated, use \"in\"\n # W602 deprecated form of raising exception\n # W603 \"<>\" is deprecated, use \"!=\"\n # W604 backticks are deprecated, use \"repr()\"\n # W605 invalid escape sequence \"x\"\n+# W606 'async' and 'await' are reserved keywords starting with Python 3.7\n \n-flake8 --ignore=B,C,E,F,I,N,W --select=E112,E113,E115,E116,E125,E131,E133,E223,E224,E271,E272,E273,E274,E275,E304,E306,E502,E702,E703,E714,E721,E741,E742,E743,F401,F402,F404,F406,F407,F601,F602,F621,F622,F631,F701,F702,F703,F704,F705,F706,F707,F811,F812,F822,F823,F831,W292,W504,W601,W602,W603,W604,W605 .\n+flake8 --ignore=B,C,E,F,I,N,W --select=E112,E113,E115,E116,E125,E131,E133,E223,E224,E242,E266,E271,E272,E273,E274,E275,E304,E306,E401,E402,E502,E701,E702,E703,E714,E721,E741,E742,E743,F401,E901,E902,F402,F404,F406,F407,F601,F602,F621,F622,F631,F701,F702,F703,F704,F705,F706,F707,F811,F812,F821,F822,F823,F831,F841,W292,W293,W504,W601,W602,W603,W604,W605,W606 ."
      },
      {
        "sha": "5f5fa9a925db4a144498168fef46d292002d6146",
        "filename": "contrib/devtools/lint-shell.sh",
        "status": "added",
        "additions": 27,
        "deletions": 0,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/devtools/lint-shell.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/devtools/lint-shell.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/lint-shell.sh?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -0,0 +1,27 @@\n+#!/bin/bash\n+#\n+# Copyright (c) 2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+# Check for shellcheck warnings in shell scripts.\n+\n+# Disabled warnings:\n+# SC2001: See if you can use ${variable//search/replace} instead.\n+# SC2004: $/${} is unnecessary on arithmetic variables.\n+# SC2005: Useless echo? Instead of 'echo $(cmd)', just use 'cmd'.\n+# SC2006: Use $(..) instead of legacy `..`.\n+# SC2016: Expressions don't expand in single quotes, use double quotes for that.\n+# SC2028: echo won't expand escape sequences. Consider printf.\n+# SC2046: Quote this to prevent word splitting.\n+# SC2048: Use \"$@\" (with quotes) to prevent whitespace problems.\n+# SC2066: Since you double quoted this, it will not word split, and the loop will only run once.\n+# SC2086: Double quote to prevent globbing and word splitting.\n+# SC2116: Useless echo? Instead of 'cmd $(echo foo)', just use 'cmd foo'.\n+# SC2148: Tips depend on target shell and yours is unknown. Add a shebang.\n+# SC2162: read without -r will mangle backslashes.\n+# SC2166: Prefer [ p ] && [ q ] as [ p -a q ] is not well defined.\n+# SC2166: Prefer [ p ] || [ q ] as [ p -o q ] is not well defined.\n+# SC2181: Check exit code directly with e.g. 'if mycmd;', not indirectly with $?.\n+shellcheck -e SC2001,SC2004,SC2005,SC2006,SC2016,SC2028,SC2046,SC2048,SC2066,SC2086,SC2116,SC2148,SC2162,SC2166,SC2181 \\\n+    $(git ls-files -- \"*.sh\" | grep -vE 'src/(secp256k1|univalue)/')"
      },
      {
        "sha": "ffc0660551e85660d04dc69d482a5c83aa7d5183",
        "filename": "contrib/devtools/lint-tests.sh",
        "status": "added",
        "additions": 34,
        "deletions": 0,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/devtools/lint-tests.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/devtools/lint-tests.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/lint-tests.sh?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -0,0 +1,34 @@\n+#!/bin/bash\n+#\n+# Copyright (c) 2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+# Check the test suite naming conventions\n+\n+EXIT_CODE=0\n+\n+NAMING_INCONSISTENCIES=$(git grep -E '^BOOST_FIXTURE_TEST_SUITE\\(' -- \\\n+    \"src/test/**.cpp\" \"src/wallet/test/**.cpp\" | \\\n+    grep -vE '/(.*?)\\.cpp:BOOST_FIXTURE_TEST_SUITE\\(\\1, .*\\)$')\n+if [[ ${NAMING_INCONSISTENCIES} != \"\" ]]; then\n+    echo \"The test suite in file src/test/foo_tests.cpp should be named\"\n+    echo \"\\\"foo_tests\\\". Please make sure the following test suites follow\"\n+    echo \"that convention:\"\n+    echo\n+    echo \"${NAMING_INCONSISTENCIES}\"\n+    EXIT_CODE=1\n+fi\n+\n+TEST_SUITE_NAME_COLLISSIONS=$(git grep -E '^BOOST_FIXTURE_TEST_SUITE\\(' -- \\\n+    \"src/test/**.cpp\" \"src/wallet/test/**.cpp\" | cut -f2 -d'(' | cut -f1 -d, | \\\n+    sort | uniq -d)\n+if [[ ${TEST_SUITE_NAME_COLLISSIONS} != \"\" ]]; then\n+    echo \"Test suite names must be unique. The following test suite names\"\n+    echo \"appear to be used more than once:\"\n+    echo\n+    echo \"${TEST_SUITE_NAME_COLLISSIONS}\"\n+    EXIT_CODE=1\n+fi\n+\n+exit ${EXIT_CODE}"
      },
      {
        "sha": "a75731ef76e60863562a42dfb56c9a506af9355a",
        "filename": "contrib/devtools/optimize-pngs.py",
        "status": "modified",
        "additions": 18,
        "deletions": 20,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/devtools/optimize-pngs.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/devtools/optimize-pngs.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/optimize-pngs.py?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/env python\n+#!/usr/bin/env python3\n # Copyright (c) 2014-2017 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n@@ -10,7 +10,7 @@\n import sys\n import subprocess\n import hashlib\n-from PIL import Image\n+from PIL import Image  # pip3 install Pillow\n \n def file_hash(filename):\n     '''Return hash of raw file contents'''\n@@ -27,7 +27,7 @@ def content_hash(filename):\n pngcrush = 'pngcrush'\n git = 'git'\n folders = [\"src/qt/res/movies\", \"src/qt/res/icons\", \"share/pixmaps\"]\n-basePath = subprocess.check_output([git, 'rev-parse', '--show-toplevel']).rstrip('\\n')\n+basePath = subprocess.check_output([git, 'rev-parse', '--show-toplevel'], universal_newlines=True).rstrip('\\n')\n totalSaveBytes = 0\n noHashChange = True\n \n@@ -37,42 +37,40 @@ def content_hash(filename):\n     for file in os.listdir(absFolder):\n         extension = os.path.splitext(file)[1]\n         if extension.lower() == '.png':\n-            print(\"optimizing \"+file+\"...\"),\n+            print(\"optimizing {}...\".format(file), end =' ')\n             file_path = os.path.join(absFolder, file)\n             fileMetaMap = {'file' : file, 'osize': os.path.getsize(file_path), 'sha256Old' : file_hash(file_path)}\n             fileMetaMap['contentHashPre'] = content_hash(file_path)\n-        \n-            pngCrushOutput = \"\"\n+\n             try:\n-                pngCrushOutput = subprocess.check_output(\n-                        [pngcrush, \"-brute\", \"-ow\", \"-rem\", \"gAMA\", \"-rem\", \"cHRM\", \"-rem\", \"iCCP\", \"-rem\", \"sRGB\", \"-rem\", \"alla\", \"-rem\", \"text\", file_path],\n-                        stderr=subprocess.STDOUT).rstrip('\\n')\n+                subprocess.call([pngcrush, \"-brute\", \"-ow\", \"-rem\", \"gAMA\", \"-rem\", \"cHRM\", \"-rem\", \"iCCP\", \"-rem\", \"sRGB\", \"-rem\", \"alla\", \"-rem\", \"text\", file_path],\n+                                stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n             except:\n-                print \"pngcrush is not installed, aborting...\"\n+                print(\"pngcrush is not installed, aborting...\")\n                 sys.exit(0)\n-        \n+\n             #verify\n-            if \"Not a PNG file\" in subprocess.check_output([pngcrush, \"-n\", \"-v\", file_path], stderr=subprocess.STDOUT):\n-                print \"PNG file \"+file+\" is corrupted after crushing, check out pngcursh version\"\n+            if \"Not a PNG file\" in subprocess.check_output([pngcrush, \"-n\", \"-v\", file_path], stderr=subprocess.STDOUT, universal_newlines=True):\n+                print(\"PNG file \"+file+\" is corrupted after crushing, check out pngcursh version\")\n                 sys.exit(1)\n-            \n+\n             fileMetaMap['sha256New'] = file_hash(file_path)\n             fileMetaMap['contentHashPost'] = content_hash(file_path)\n \n             if fileMetaMap['contentHashPre'] != fileMetaMap['contentHashPost']:\n-                print \"Image contents of PNG file \"+file+\" before and after crushing don't match\"\n+                print(\"Image contents of PNG file {} before and after crushing don't match\".format(file))\n                 sys.exit(1)\n \n             fileMetaMap['psize'] = os.path.getsize(file_path)\n             outputArray.append(fileMetaMap)\n-            print(\"done\\n\"),\n+            print(\"done\")\n \n-print \"summary:\\n+++++++++++++++++\"\n+print(\"summary:\\n+++++++++++++++++\")\n for fileDict in outputArray:\n     oldHash = fileDict['sha256Old']\n     newHash = fileDict['sha256New']\n     totalSaveBytes += fileDict['osize'] - fileDict['psize']\n     noHashChange = noHashChange and (oldHash == newHash)\n-    print fileDict['file']+\"\\n  size diff from: \"+str(fileDict['osize'])+\" to: \"+str(fileDict['psize'])+\"\\n  old sha256: \"+oldHash+\"\\n  new sha256: \"+newHash+\"\\n\"\n-    \n-print \"completed. Checksum stable: \"+str(noHashChange)+\". Total reduction: \"+str(totalSaveBytes)+\" bytes\"\n+    print(fileDict['file']+\"\\n  size diff from: \"+str(fileDict['osize'])+\" to: \"+str(fileDict['psize'])+\"\\n  old sha256: \"+oldHash+\"\\n  new sha256: \"+newHash+\"\\n\")\n+\n+print(\"completed. Checksum stable: \"+str(noHashChange)+\". Total reduction: \"+str(totalSaveBytes)+\" bytes\")"
      },
      {
        "sha": "0f2099953f8ad47cb95eb8c066ae4d169ed82bd6",
        "filename": "contrib/devtools/security-check.py",
        "status": "modified",
        "additions": 23,
        "deletions": 24,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/devtools/security-check.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/devtools/security-check.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/security-check.py?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/env python\n+#!/usr/bin/env python3\n # Copyright (c) 2015-2017 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n@@ -8,7 +8,6 @@\n Otherwise the exit status will be 1 and it will log which executables failed which checks.\n Needs `readelf` (for ELF) and `objdump` (for PE).\n '''\n-from __future__ import division,print_function,unicode_literals\n import subprocess\n import sys\n import os\n@@ -21,38 +20,38 @@ def check_ELF_PIE(executable):\n     '''\n     Check for position independent executable (PIE), allowing for address space randomization.\n     '''\n-    p = subprocess.Popen([READELF_CMD, '-h', '-W', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n+    p = subprocess.Popen([READELF_CMD, '-h', '-W', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, universal_newlines=True)\n     (stdout, stderr) = p.communicate()\n     if p.returncode:\n         raise IOError('Error opening file')\n \n     ok = False\n-    for line in stdout.split(b'\\n'):\n+    for line in stdout.splitlines():\n         line = line.split()\n-        if len(line)>=2 and line[0] == b'Type:' and line[1] == b'DYN':\n+        if len(line)>=2 and line[0] == 'Type:' and line[1] == 'DYN':\n             ok = True\n     return ok\n \n def get_ELF_program_headers(executable):\n     '''Return type and flags for ELF program headers'''\n-    p = subprocess.Popen([READELF_CMD, '-l', '-W', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n+    p = subprocess.Popen([READELF_CMD, '-l', '-W', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, universal_newlines=True)\n     (stdout, stderr) = p.communicate()\n     if p.returncode:\n         raise IOError('Error opening file')\n     in_headers = False\n     count = 0\n     headers = []\n-    for line in stdout.split(b'\\n'):\n-        if line.startswith(b'Program Headers:'):\n+    for line in stdout.splitlines():\n+        if line.startswith('Program Headers:'):\n             in_headers = True\n-        if line == b'':\n+        if line == '':\n             in_headers = False\n         if in_headers:\n             if count == 1: # header line\n-                ofs_typ = line.find(b'Type')\n-                ofs_offset = line.find(b'Offset')\n-                ofs_flags = line.find(b'Flg')\n-                ofs_align = line.find(b'Align')\n+                ofs_typ = line.find('Type')\n+                ofs_offset = line.find('Offset')\n+                ofs_flags = line.find('Flg')\n+                ofs_align = line.find('Align')\n                 if ofs_typ == -1 or ofs_offset == -1 or ofs_flags == -1 or ofs_align  == -1:\n                     raise ValueError('Cannot parse elfread -lW output')\n             elif count > 1:\n@@ -69,9 +68,9 @@ def check_ELF_NX(executable):\n     have_wx = False\n     have_gnu_stack = False\n     for (typ, flags) in get_ELF_program_headers(executable):\n-        if typ == b'GNU_STACK':\n+        if typ == 'GNU_STACK':\n             have_gnu_stack = True\n-        if b'W' in flags and b'E' in flags: # section is both writable and executable\n+        if 'W' in flags and 'E' in flags: # section is both writable and executable\n             have_wx = True\n     return have_gnu_stack and not have_wx\n \n@@ -88,31 +87,31 @@ def check_ELF_RELRO(executable):\n         # However, the dynamic linker need to write to this area so these are RW.\n         # Glibc itself takes care of mprotecting this area R after relocations are finished.\n         # See also http://permalink.gmane.org/gmane.comp.gnu.binutils/71347\n-        if typ == b'GNU_RELRO':\n+        if typ == 'GNU_RELRO':\n             have_gnu_relro = True\n \n     have_bindnow = False\n-    p = subprocess.Popen([READELF_CMD, '-d', '-W', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n+    p = subprocess.Popen([READELF_CMD, '-d', '-W', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, universal_newlines=True)\n     (stdout, stderr) = p.communicate()\n     if p.returncode:\n         raise IOError('Error opening file')\n-    for line in stdout.split(b'\\n'):\n+    for line in stdout.splitlines():\n         tokens = line.split()\n-        if len(tokens)>1 and tokens[1] == b'(BIND_NOW)' or (len(tokens)>2 and tokens[1] == b'(FLAGS)' and b'BIND_NOW' in tokens[2]):\n+        if len(tokens)>1 and tokens[1] == '(BIND_NOW)' or (len(tokens)>2 and tokens[1] == '(FLAGS)' and 'BIND_NOW' in tokens[2]):\n             have_bindnow = True\n     return have_gnu_relro and have_bindnow\n \n def check_ELF_Canary(executable):\n     '''\n     Check for use of stack canary\n     '''\n-    p = subprocess.Popen([READELF_CMD, '--dyn-syms', '-W', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n+    p = subprocess.Popen([READELF_CMD, '--dyn-syms', '-W', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, universal_newlines=True)\n     (stdout, stderr) = p.communicate()\n     if p.returncode:\n         raise IOError('Error opening file')\n     ok = False\n-    for line in stdout.split(b'\\n'):\n-        if b'__stack_chk_fail' in line:\n+    for line in stdout.splitlines():\n+        if '__stack_chk_fail' in line:\n             ok = True\n     return ok\n \n@@ -122,13 +121,13 @@ def get_PE_dll_characteristics(executable):\n     Returns a tuple (arch,bits) where arch is 'i386:x86-64' or 'i386'\n     and bits is the DllCharacteristics value.\n     '''\n-    p = subprocess.Popen([OBJDUMP_CMD, '-x',  executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n+    p = subprocess.Popen([OBJDUMP_CMD, '-x',  executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, universal_newlines=True)\n     (stdout, stderr) = p.communicate()\n     if p.returncode:\n         raise IOError('Error opening file')\n     arch = ''\n     bits = 0\n-    for line in stdout.split('\\n'):\n+    for line in stdout.splitlines():\n         tokens = line.split()\n         if len(tokens)>=2 and tokens[0] == 'architecture:':\n             arch = tokens[1].rstrip(',')"
      },
      {
        "sha": "3a67319eaa81783ad3afdd65650e899b39a5781c",
        "filename": "contrib/devtools/symbol-check.py",
        "status": "modified",
        "additions": 34,
        "deletions": 35,
        "changes": 69,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/devtools/symbol-check.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/devtools/symbol-check.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/symbol-check.py?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/env python\n+#!/usr/bin/env python3\n # Copyright (c) 2014 Wladimir J. van der Laan\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n@@ -11,7 +11,6 @@\n \n     find ../gitian-builder/build -type f -executable | xargs python contrib/devtools/symbol-check.py\n '''\n-from __future__ import division, print_function, unicode_literals\n import subprocess\n import re\n import sys\n@@ -47,28 +46,28 @@\n \n # Ignore symbols that are exported as part of every executable\n IGNORE_EXPORTS = {\n-b'_edata', b'_end', b'_init', b'__bss_start', b'_fini', b'_IO_stdin_used'\n+'_edata', '_end', '_init', '__bss_start', '_fini', '_IO_stdin_used'\n }\n READELF_CMD = os.getenv('READELF', '/usr/bin/readelf')\n CPPFILT_CMD = os.getenv('CPPFILT', '/usr/bin/c++filt')\n # Allowed NEEDED libraries\n ALLOWED_LIBRARIES = {\n # bitcoind and bitcoin-qt\n-b'libgcc_s.so.1', # GCC base support\n-b'libc.so.6', # C library\n-b'libpthread.so.0', # threading\n-b'libanl.so.1', # DNS resolve\n-b'libm.so.6', # math library\n-b'librt.so.1', # real-time (clock)\n-b'ld-linux-x86-64.so.2', # 64-bit dynamic linker\n-b'ld-linux.so.2', # 32-bit dynamic linker\n+'libgcc_s.so.1', # GCC base support\n+'libc.so.6', # C library\n+'libpthread.so.0', # threading\n+'libanl.so.1', # DNS resolve\n+'libm.so.6', # math library\n+'librt.so.1', # real-time (clock)\n+'ld-linux-x86-64.so.2', # 64-bit dynamic linker\n+'ld-linux.so.2', # 32-bit dynamic linker\n # bitcoin-qt only\n-b'libX11-xcb.so.1', # part of X11\n-b'libX11.so.6', # part of X11\n-b'libxcb.so.1', # part of X11\n-b'libfontconfig.so.1', # font support\n-b'libfreetype.so.6', # font parsing\n-b'libdl.so.2' # programming interface to dynamic linker\n+'libX11-xcb.so.1', # part of X11\n+'libX11.so.6', # part of X11\n+'libxcb.so.1', # part of X11\n+'libfontconfig.so.1', # font support\n+'libfreetype.so.6', # font parsing\n+'libdl.so.2' # programming interface to dynamic linker\n }\n \n class CPPFilt(object):\n@@ -78,10 +77,10 @@ class CPPFilt(object):\n     Use a pipe to the 'c++filt' command.\n     '''\n     def __init__(self):\n-        self.proc = subprocess.Popen(CPPFILT_CMD, stdin=subprocess.PIPE, stdout=subprocess.PIPE)\n+        self.proc = subprocess.Popen(CPPFILT_CMD, stdin=subprocess.PIPE, stdout=subprocess.PIPE, universal_newlines=True)\n \n     def __call__(self, mangled):\n-        self.proc.stdin.write(mangled + b'\\n')\n+        self.proc.stdin.write(mangled + '\\n')\n         self.proc.stdin.flush()\n         return self.proc.stdout.readline().rstrip()\n \n@@ -95,43 +94,43 @@ def read_symbols(executable, imports=True):\n     Parse an ELF executable and return a list of (symbol,version) tuples\n     for dynamic, imported symbols.\n     '''\n-    p = subprocess.Popen([READELF_CMD, '--dyn-syms', '-W', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n+    p = subprocess.Popen([READELF_CMD, '--dyn-syms', '-W', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, universal_newlines=True)\n     (stdout, stderr) = p.communicate()\n     if p.returncode:\n         raise IOError('Could not read symbols for %s: %s' % (executable, stderr.strip()))\n     syms = []\n-    for line in stdout.split(b'\\n'):\n+    for line in stdout.splitlines():\n         line = line.split()\n-        if len(line)>7 and re.match(b'[0-9]+:$', line[0]):\n-            (sym, _, version) = line[7].partition(b'@')\n-            is_import = line[6] == b'UND'\n-            if version.startswith(b'@'):\n+        if len(line)>7 and re.match('[0-9]+:$', line[0]):\n+            (sym, _, version) = line[7].partition('@')\n+            is_import = line[6] == 'UND'\n+            if version.startswith('@'):\n                 version = version[1:]\n             if is_import == imports:\n                 syms.append((sym, version))\n     return syms\n \n def check_version(max_versions, version):\n-    if b'_' in version:\n-        (lib, _, ver) = version.rpartition(b'_')\n+    if '_' in version:\n+        (lib, _, ver) = version.rpartition('_')\n     else:\n         lib = version\n         ver = '0'\n-    ver = tuple([int(x) for x in ver.split(b'.')])\n+    ver = tuple([int(x) for x in ver.split('.')])\n     if not lib in max_versions:\n         return False\n     return ver <= max_versions[lib]\n \n def read_libraries(filename):\n-    p = subprocess.Popen([READELF_CMD, '-d', '-W', filename], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n+    p = subprocess.Popen([READELF_CMD, '-d', '-W', filename], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, universal_newlines=True)\n     (stdout, stderr) = p.communicate()\n     if p.returncode:\n         raise IOError('Error opening file')\n     libraries = []\n-    for line in stdout.split(b'\\n'):\n+    for line in stdout.splitlines():\n         tokens = line.split()\n-        if len(tokens)>2 and tokens[1] == b'(NEEDED)':\n-            match = re.match(b'^Shared library: \\[(.*)\\]$', b' '.join(tokens[2:]))\n+        if len(tokens)>2 and tokens[1] == '(NEEDED)':\n+            match = re.match('^Shared library: \\[(.*)\\]$', ' '.join(tokens[2:]))\n             if match:\n                 libraries.append(match.group(1))\n             else:\n@@ -145,18 +144,18 @@ def read_libraries(filename):\n         # Check imported symbols\n         for sym,version in read_symbols(filename, True):\n             if version and not check_version(MAX_VERSIONS, version):\n-                print('%s: symbol %s from unsupported version %s' % (filename, cppfilt(sym).decode('utf-8'), version.decode('utf-8')))\n+                print('%s: symbol %s from unsupported version %s' % (filename, cppfilt(sym), version))\n                 retval = 1\n         # Check exported symbols\n         for sym,version in read_symbols(filename, False):\n             if sym in IGNORE_EXPORTS:\n                 continue\n-            print('%s: export of symbol %s not allowed' % (filename, cppfilt(sym).decode('utf-8')))\n+            print('%s: export of symbol %s not allowed' % (filename, cppfilt(sym)))\n             retval = 1\n         # Check dependency libraries\n         for library_name in read_libraries(filename):\n             if library_name not in ALLOWED_LIBRARIES:\n-                print('%s: NEEDED library %s is not allowed' % (filename, library_name.decode('utf-8')))\n+                print('%s: NEEDED library %s is not allowed' % (filename, library_name))\n                 retval = 1\n \n     sys.exit(retval)"
      },
      {
        "sha": "37a895872f5e17634b94047835608b423224f1bb",
        "filename": "contrib/devtools/test-security-check.py",
        "status": "modified",
        "additions": 15,
        "deletions": 6,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/devtools/test-security-check.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/devtools/test-security-check.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/test-security-check.py?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -1,11 +1,10 @@\n-#!/usr/bin/env python2\n+#!/usr/bin/env python3\n # Copyright (c) 2015-2017 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n '''\n Test script for security-check.py\n '''\n-from __future__ import division,print_function\n import subprocess\n import unittest\n \n@@ -22,7 +21,7 @@ def write_testcode(filename):\n \n def call_security_check(cc, source, executable, options):\n     subprocess.check_call([cc,source,'-o',executable] + options)\n-    p = subprocess.Popen(['./security-check.py',executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n+    p = subprocess.Popen(['./security-check.py',executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, universal_newlines=True)\n     (stdout, stderr) = p.communicate()\n     return (p.returncode, stdout.rstrip())\n \n@@ -44,18 +43,28 @@ def test_ELF(self):\n         self.assertEqual(call_security_check(cc, source, executable, ['-Wl,-znoexecstack','-fstack-protector-all','-Wl,-zrelro','-Wl,-z,now','-pie','-fPIE']), \n                 (0, ''))\n \n-    def test_PE(self):\n+    def test_32bit_PE(self):\n         source = 'test1.c'\n         executable = 'test1.exe'\n         cc = 'i686-w64-mingw32-gcc'\n         write_testcode(source)\n \n         self.assertEqual(call_security_check(cc, source, executable, []), \n-                (1, executable+': failed PIE NX'))\n+                (1, executable+': failed DYNAMIC_BASE NX'))\n         self.assertEqual(call_security_check(cc, source, executable, ['-Wl,--nxcompat']), \n-                (1, executable+': failed PIE'))\n+                (1, executable+': failed DYNAMIC_BASE'))\n         self.assertEqual(call_security_check(cc, source, executable, ['-Wl,--nxcompat','-Wl,--dynamicbase']), \n                 (0, ''))\n+    def test_64bit_PE(self):\n+        source = 'test1.c'\n+        executable = 'test1.exe'\n+        cc = 'x86_64-w64-mingw32-gcc'\n+        write_testcode(source)\n+\n+        self.assertEqual(call_security_check(cc, source, executable, []), (1, executable+': failed DYNAMIC_BASE NX\\n'+executable+': warning HIGH_ENTROPY_VA'))\n+        self.assertEqual(call_security_check(cc, source, executable, ['-Wl,--nxcompat']), (1, executable+': failed DYNAMIC_BASE\\n'+executable+': warning HIGH_ENTROPY_VA'))\n+        self.assertEqual(call_security_check(cc, source, executable, ['-Wl,--nxcompat','-Wl,--dynamicbase']), (0, executable+': warning HIGH_ENTROPY_VA'))\n+        self.assertEqual(call_security_check(cc, source, executable, ['-Wl,--nxcompat','-Wl,--dynamicbase','-Wl,--high-entropy-va']), (0, ''))\n \n if __name__ == '__main__':\n     unittest.main()"
      },
      {
        "sha": "b36e6968bf0f64d424992ff1589f9e44fb3ce671",
        "filename": "contrib/devtools/update-translations.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/devtools/update-translations.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/devtools/update-translations.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/update-translations.py?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/env python\n+#!/usr/bin/env python3\n # Copyright (c) 2014 Wladimir J. van der Laan\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n@@ -15,7 +15,6 @@\n TODO:\n - auto-add new translations to the build system according to the translation process\n '''\n-from __future__ import division, print_function\n import subprocess\n import re\n import sys"
      },
      {
        "sha": "c609e9b3363de88c61f4c5277a5215b1e1a10b3a",
        "filename": "contrib/linearize/linearize-data.py",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/linearize/linearize-data.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/linearize/linearize-data.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/linearize/linearize-data.py?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -21,7 +21,6 @@\n \n settings = {}\n \n-##### Switch endian-ness #####\n def hex_switchEndian(s):\n \t\"\"\" Switches the endianness of a hex string (in pairs of hex chars) \"\"\"\n \tpairList = [s[i:i+2].encode() for i in range(0, len(s), 2)]"
      },
      {
        "sha": "e1304e26d0492bc824fb2987f4d6b5edc83f142c",
        "filename": "contrib/linearize/linearize-hashes.py",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/linearize/linearize-hashes.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/linearize/linearize-hashes.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/linearize/linearize-hashes.py?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -21,7 +21,6 @@\n \n settings = {}\n \n-##### Switch endian-ness #####\n def hex_switchEndian(s):\n \t\"\"\" Switches the endianness of a hex string (in pairs of hex chars) \"\"\"\n \tpairList = [s[i:i+2].encode() for i in range(0, len(s), 2)]"
      },
      {
        "sha": "b29fc71765653b816e9fcef0437c302c0dd55a86",
        "filename": "contrib/macdeploy/custom_dsstore.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/macdeploy/custom_dsstore.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/macdeploy/custom_dsstore.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/macdeploy/custom_dsstore.py?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -1,8 +1,7 @@\n-#!/usr/bin/env python\n+#!/usr/bin/env python3\n # Copyright (c) 2013-2016 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-from __future__ import division,print_function,unicode_literals\n import biplist\n from ds_store import DSStore\n from mac_alias import Alias"
      },
      {
        "sha": "17ce6c44f93b0d1f5746f22153210a243979836b",
        "filename": "contrib/macdeploy/macdeployqtplus",
        "status": "modified",
        "additions": 5,
        "deletions": 22,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/macdeploy/macdeployqtplus",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/macdeploy/macdeployqtplus",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/macdeploy/macdeployqtplus?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -1,5 +1,4 @@\n-#!/usr/bin/env python\n-from __future__ import division, print_function, unicode_literals\n+#!/usr/bin/env python3\n #\n # Copyright (C) 2011  Patrick \"p2k\" Schneider <me@p2k-network.org>\n #\n@@ -203,15 +202,15 @@ def getFrameworks(binaryPath, verbose):\n     if verbose >= 3:\n         print(\"Inspecting with otool: \" + binaryPath)\n     otoolbin=os.getenv(\"OTOOL\", \"otool\")\n-    otool = subprocess.Popen([otoolbin, \"-L\", binaryPath], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+    otool = subprocess.Popen([otoolbin, \"-L\", binaryPath], stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)\n     o_stdout, o_stderr = otool.communicate()\n     if otool.returncode != 0:\n         if verbose >= 1:\n             sys.stderr.write(o_stderr)\n             sys.stderr.flush()\n             raise RuntimeError(\"otool failed with return code %d\" % otool.returncode)\n \n-    otoolLines = o_stdout.decode().split(\"\\n\")\n+    otoolLines = o_stdout.split(\"\\n\")\n     otoolLines.pop(0) # First line is the inspected binary\n     if \".framework\" in binaryPath or binaryPath.endswith(\".dylib\"):\n         otoolLines.pop(0) # Frameworks and dylibs list themselves as a dependency.\n@@ -714,22 +713,6 @@ elif config.sign:\n \n if config.dmg is not None:\n \n-    #Patch in check_output for Python 2.6\n-    if \"check_output\" not in dir( subprocess ):\n-        def f(*popenargs, **kwargs):\n-            if 'stdout' in kwargs:\n-                raise ValueError('stdout argument not allowed, it will be overridden.')\n-            process = subprocess.Popen(stdout=subprocess.PIPE, *popenargs, **kwargs)\n-            output, unused_err = process.communicate()\n-            retcode = process.poll()\n-            if retcode:\n-                cmd = kwargs.get(\"args\")\n-                if cmd is None:\n-                    cmd = popenargs[0]\n-                raise CalledProcessError(retcode, cmd)\n-            return output\n-        subprocess.check_output = f\n-\n     def runHDIUtil(verb, image_basename, **kwargs):\n         hdiutil_args = [\"hdiutil\", verb, image_basename + \".dmg\"]\n         if \"capture_stdout\" in kwargs:\n@@ -747,7 +730,7 @@ if config.dmg is not None:\n             if not value is True:\n                 hdiutil_args.append(str(value))\n         \n-        return run(hdiutil_args)\n+        return run(hdiutil_args, universal_newlines=True)\n     \n     if verbose >= 2:\n         if fancy is None:\n@@ -789,7 +772,7 @@ if config.dmg is not None:\n         except subprocess.CalledProcessError as e:\n             sys.exit(e.returncode)\n         \n-        m = re.search(\"/Volumes/(.+$)\", output.decode())\n+        m = re.search(\"/Volumes/(.+$)\", output)\n         disk_root = m.group(0)\n         disk_name = m.group(1)\n         "
      },
      {
        "sha": "72eb7255f30e9c084bd8890a7d05c7b8b08dd0c6",
        "filename": "contrib/seeds/generate-seeds.py",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/seeds/generate-seeds.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/seeds/generate-seeds.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/seeds/generate-seeds.py?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -34,7 +34,8 @@\n \n from base64 import b32decode\n from binascii import a2b_hex\n-import sys, os\n+import sys\n+import os\n import re\n \n # ipv4 in ipv6 prefix\n@@ -46,7 +47,7 @@ def name_to_ipv6(addr):\n     if len(addr)>6 and addr.endswith('.onion'):\n         vchAddr = b32decode(addr[0:-6], True)\n         if len(vchAddr) != 16-len(pchOnionCat):\n-            raise ValueError('Invalid onion %s' % s)\n+            raise ValueError('Invalid onion %s' % vchAddr)\n         return pchOnionCat + vchAddr\n     elif '.' in addr: # IPv4\n         return pchIPv4 + bytearray((int(x) for x in addr.split('.')))\n@@ -132,7 +133,7 @@ def main():\n     with open(os.path.join(indir,'nodes_test.txt'),'r') as f:\n         process_nodes(g, f, 'pnSeed6_test', 18333)\n     g.write('#endif // BITCOIN_CHAINPARAMSSEEDS_H\\n')\n-            \n+\n if __name__ == '__main__':\n     main()\n "
      },
      {
        "sha": "59044e701af8cf07f98cff9dc0055e905fb4406d",
        "filename": "contrib/seeds/makeseeds.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/seeds/makeseeds.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/seeds/makeseeds.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/seeds/makeseeds.py?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -6,6 +6,11 @@\n # Generate seeds.txt from Pieter's DNS seeder\n #\n \n+import re\n+import sys\n+import dns.resolver\n+import collections\n+\n NSEEDS=512\n \n MAX_SEEDS_PER_ASN=2\n@@ -22,11 +27,6 @@\n     \"54.94.195.96\", \"54.94.200.247\"\n }\n \n-import re\n-import sys\n-import dns.resolver\n-import collections\n-\n PATTERN_IPV4 = re.compile(r\"^((\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})):(\\d+)$\")\n PATTERN_IPV6 = re.compile(r\"^\\[([0-9a-z:]+)\\]:(\\d+)$\")\n PATTERN_ONION = re.compile(r\"^([abcdefghijklmnopqrstuvwxyz234567]{16}\\.onion):(\\d+)$\")"
      },
      {
        "sha": "071bc722b0eee886b5f1acd8bae4634e3f384186",
        "filename": "contrib/testgen/base58.py",
        "status": "modified",
        "additions": 18,
        "deletions": 9,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/testgen/base58.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/testgen/base58.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/testgen/base58.py?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -28,7 +28,9 @@ def b58encode(v):\n     \"\"\"\n     long_value = 0\n     for (i, c) in enumerate(v[::-1]):\n-        long_value += (256**i) * ord(c)\n+        if isinstance(c, str):\n+            c = ord(c)\n+        long_value += (256**i) * c\n \n     result = ''\n     while long_value >= __b58base:\n@@ -41,17 +43,21 @@ def b58encode(v):\n     # leading 0-bytes in the input become leading-1s\n     nPad = 0\n     for c in v:\n-        if c == '\\0': nPad += 1\n-        else: break\n+        if c == 0:\n+            nPad += 1\n+        else:\n+            break\n \n     return (__b58chars[0]*nPad) + result\n \n def b58decode(v, length = None):\n     \"\"\" decode v into a string of len bytes\n     \"\"\"\n     long_value = 0\n-    for (i, c) in enumerate(v[::-1]):\n-        long_value += __b58chars.find(c) * (__b58base**i)\n+    for i, c in enumerate(v[::-1]):\n+        pos = __b58chars.find(c)\n+        assert pos != -1\n+        long_value += pos * (__b58base**i)\n \n     result = bytes()\n     while long_value >= 256:\n@@ -62,10 +68,12 @@ def b58decode(v, length = None):\n \n     nPad = 0\n     for c in v:\n-        if c == __b58chars[0]: nPad += 1\n-        else: break\n+        if c == __b58chars[0]:\n+            nPad += 1\n+            continue\n+        break\n \n-    result = chr(0)*nPad + result\n+    result = bytes(nPad) + result\n     if length is not None and len(result) != length:\n         return None\n \n@@ -92,7 +100,8 @@ def b58decode_chk(v):\n def get_bcaddress_version(strAddress):\n     \"\"\" Returns None if strAddress is invalid.  Otherwise returns integer version of address. \"\"\"\n     addr = b58decode_chk(strAddress)\n-    if addr is None or len(addr)!=21: return None\n+    if addr is None or len(addr)!=21:\n+        return None\n     version = addr[0]\n     return ord(version)\n "
      },
      {
        "sha": "de15657d27ed319a2ed8acdd0b9ed80397056687",
        "filename": "contrib/testgen/gen_base58_test_vectors.py",
        "status": "modified",
        "additions": 19,
        "deletions": 15,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/testgen/gen_base58_test_vectors.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/testgen/gen_base58_test_vectors.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/testgen/gen_base58_test_vectors.py?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -1,11 +1,11 @@\n-#!/usr/bin/env python\n+#!/usr/bin/env python3\n # Copyright (c) 2012-2017 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n '''\n Generate valid and invalid base58 address and private key test vectors.\n \n-Usage: \n+Usage:\n     gen_base58_test_vectors.py valid 50 > ../../src/test/data/base58_keys_valid.json\n     gen_base58_test_vectors.py invalid 50 > ../../src/test/data/base58_keys_invalid.json\n '''\n@@ -46,8 +46,8 @@ def is_valid(v):\n     if result is None:\n         return False\n     for template in templates:\n-        prefix = str(bytearray(template[0]))\n-        suffix = str(bytearray(template[2]))\n+        prefix = bytearray(template[0])\n+        suffix = bytearray(template[2])\n         if result.startswith(prefix) and result.endswith(suffix):\n             if (len(result) - len(prefix) - len(suffix)) == template[1]:\n                 return True\n@@ -57,30 +57,33 @@ def gen_valid_vectors():\n     '''Generate valid test vectors'''\n     while True:\n         for template in templates:\n-            prefix = str(bytearray(template[0]))\n-            payload = os.urandom(template[1]) \n-            suffix = str(bytearray(template[2]))\n+            prefix = bytearray(template[0])\n+            payload = bytearray(os.urandom(template[1]))\n+            suffix = bytearray(template[2])\n             rv = b58encode_chk(prefix + payload + suffix)\n             assert is_valid(rv)\n-            metadata = dict([(x,y) for (x,y) in zip(metadata_keys,template[3]) if y is not None])\n-            yield (rv, b2a_hex(payload), metadata)\n+            metadata = {x: y for x, y in zip(metadata_keys,template[3]) if y is not None}\n+            hexrepr = b2a_hex(payload)\n+            if isinstance(hexrepr, bytes):\n+                hexrepr = hexrepr.decode('utf8')\n+            yield (rv, hexrepr, metadata)\n \n def gen_invalid_vector(template, corrupt_prefix, randomize_payload_size, corrupt_suffix):\n     '''Generate possibly invalid vector'''\n     if corrupt_prefix:\n         prefix = os.urandom(1)\n     else:\n-        prefix = str(bytearray(template[0]))\n-    \n+        prefix = bytearray(template[0])\n+\n     if randomize_payload_size:\n         payload = os.urandom(max(int(random.expovariate(0.5)), 50))\n     else:\n         payload = os.urandom(template[1])\n-    \n+\n     if corrupt_suffix:\n         suffix = os.urandom(len(template[2]))\n     else:\n-        suffix = str(bytearray(template[2]))\n+        suffix = bytearray(template[2])\n \n     return b58encode_chk(prefix + payload + suffix)\n \n@@ -111,7 +114,8 @@ def gen_invalid_vectors():\n                 yield val,\n \n if __name__ == '__main__':\n-    import sys, json\n+    import sys\n+    import json\n     iters = {'valid':gen_valid_vectors, 'invalid':gen_invalid_vectors}\n     try:\n         uiter = iters[sys.argv[1]]\n@@ -121,7 +125,7 @@ def gen_invalid_vectors():\n         count = int(sys.argv[2])\n     except IndexError:\n         count = 0\n-   \n+\n     data = list(islice(uiter(), count))\n     json.dump(data, sys.stdout, sort_keys=True, indent=4)\n     sys.stdout.write('\\n')"
      },
      {
        "sha": "b845b34e41044f19adc35b36ab8fec45d74dc5a3",
        "filename": "contrib/tidy_datadir.sh",
        "status": "removed",
        "additions": 0,
        "deletions": 62,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7466a26cab5d66665991433947964a638f5b957e/contrib/tidy_datadir.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7466a26cab5d66665991433947964a638f5b957e/contrib/tidy_datadir.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/tidy_datadir.sh?ref=7466a26cab5d66665991433947964a638f5b957e",
        "patch": "@@ -1,62 +0,0 @@\n-#!/bin/bash\n-# Copyright (c) 2013 The Bitcoin Core developers\n-# Distributed under the MIT software license, see the accompanying\n-# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-if [ -d \"$1\" ]; then\n-  cd \"$1\" || exit 1\n-else\n-  echo \"Usage: $0 <datadir>\" >&2\n-  echo \"Removes obsolete Bitcoin database files\" >&2\n-  exit 1\n-fi\n-\n-LEVEL=0\n-if [ -f wallet.dat -a -f addr.dat -a -f blkindex.dat -a -f blk0001.dat ]; then LEVEL=1; fi\n-if [ -f wallet.dat -a -f peers.dat -a -f blkindex.dat -a -f blk0001.dat ]; then LEVEL=2; fi\n-if [ -f wallet.dat -a -f peers.dat -a -f coins/CURRENT -a -f blktree/CURRENT -a -f blocks/blk00000.dat ]; then LEVEL=3; fi\n-if [ -f wallet.dat -a -f peers.dat -a -f chainstate/CURRENT -a -f blocks/index/CURRENT -a -f blocks/blk00000.dat ]; then LEVEL=4; fi\n-\n-case $LEVEL in\n-  0)\n-    echo \"Error: no Bitcoin datadir detected.\"\n-    exit 1\n-    ;;\n-  1)\n-    echo \"Detected old Bitcoin datadir (before 0.7).\"\n-    echo \"Nothing to do.\"\n-    exit 0\n-    ;;\n-  2)\n-    echo \"Detected Bitcoin 0.7 datadir.\"\n-    ;;\n-  3)\n-    echo \"Detected Bitcoin pre-0.8 datadir.\"\n-    ;;\n-  4)\n-    echo \"Detected Bitcoin 0.8 datadir.\"\n-    ;;\n-esac\n-\n-FILES=\"\"\n-DIRS=\"\"\n-\n-if [ $LEVEL -ge 3 ]; then FILES=$(echo $FILES blk????.dat blkindex.dat); fi\n-if [ $LEVEL -ge 2 ]; then FILES=$(echo $FILES addr.dat); fi\n-if [ $LEVEL -ge 4 ]; then DIRS=$(echo $DIRS coins blktree); fi\n-\n-for FILE in $FILES; do\n-  if [ -f $FILE ]; then\n-    echo \"Deleting: $FILE\"\n-    rm -f $FILE\n-  fi\n-done\n-\n-for DIR in $DIRS; do\n-  if [ -d $DIR ]; then\n-    echo \"Deleting: $DIR/\"\n-    rm -rf $DIR\n-  fi\n-done\n-\n-echo \"Done.\""
      },
      {
        "sha": "fa492fdd2750639aca86c787da7a797e7a22479e",
        "filename": "contrib/verify-commits/README.md",
        "status": "modified",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/verify-commits/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/verify-commits/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/verify-commits/README.md?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -24,3 +24,24 @@ keys:\n Note that the above isn't a good UI/UX yet, and needs significant improvements\n to make it more convenient and reduce the chance of errors; pull-reqs\n improving this process would be much appreciated.\n+\n+Configuration files\n+-------------------\n+\n+* `trusted-git-root`: This file should contain a single git commit hash which is the first unsigned git commit (hence it is the \"root of trust\").\n+* `trusted-sha512-root-commit`: This file should contain a single git commit hash which is the first commit without a SHA512 root commitment.\n+* `trusted-keys`: This file should contain a \\n-delimited list of all PGP fingerprints of authorized commit signers (primary, not subkeys).\n+* `allow-revsig-commits`: This file should contain a \\n-delimited list of git commit hashes. See next section for more info.\n+\n+Key expiry/revocation\n+---------------------\n+\n+When a key (or subkey) which has signed old commits expires or is revoked,\n+verify-commits will start failing to verify all commits which were signed by\n+said key. In order to avoid bumping the root-of-trust `trusted-git-root`\n+file, individual commits which were signed by such a key can be added to the\n+`allow-revsig-commits` file. That way, the PGP signatures are still verified\n+but no new commits can be signed by any expired/revoked key. To easily build a\n+list of commits which need to be added, verify-commits.sh can be edited to test\n+each commit with BITCOIN_VERIFY_COMMITS_ALLOW_REVSIG set to both 1 and 0, and\n+those which need it set to 1 printed."
      },
      {
        "sha": "3abf82e529cbbbc766d0b7f7c4028d7721eb6755",
        "filename": "contrib/verify-commits/allow-revsig-commits",
        "status": "modified",
        "additions": 400,
        "deletions": 0,
        "changes": 400,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/verify-commits/allow-revsig-commits",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/verify-commits/allow-revsig-commits",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/verify-commits/allow-revsig-commits?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -102,3 +102,403 @@ bafd075c5e6a1088ef0f1aa0b0b224e026a3d3e0\n c8d2473e6cb042e7275a10c49d3f6a4a91bf0166\n 386f4385ab04b0b2c3d47bddc0dc0f2de7354964\n 9f33dba05c01ecc5c56eb1284ab7d64d42f55171\n+7466a26cab5d66665991433947964a638f5b957e\n+b43aba89e356ff95b706e80d4802f60fc46a569a\n+02b7e8319aef2a870264ad4fa2e3bb18664dcc36\n+f686002a8eba820a40ac2f34a6e8f57b2b5cc54c\n+2b1c50b9352ab1dc40b0f877db23c1fa4048fae3\n+2405ce1df043f778b8efb9205009500cbc17313a\n+4ad3b3c72c73d61e0a0cab541dca20acf651320d\n+4ba3d4f4393d81148422d24d222fe7ed00130194\n+8ee5c7b747171e335793c74cd9d2f7491da58164\n+872c921c0a208b04bd0713758e52fcab5b7c1684\n+00d1680498c5550e7db1f359202d3433a092fafd\n+585db41e9ab7a6fb262c8bad7f427cdbdc497188\n+18462960c0f13bd07d8f52b61e7d7bc17e991eea\n+0630974647dacaf25e7fcb7f9cbb785bb078ede6\n+0f58d7f3d62f012f2584f5e781fc73de4763dd9e\n+3d16f581538b0974853e820508e8b3093269d2fd\n+66e91420ab233cf1dac64504e0dc129019bf8c0d\n+d8d9162f5bad39b2720dd2b2da237c6159e4755f\n+29fad97c320c892ab6a480c81e2078ec22ab354b\n+791c3ea61b4e49fd46a1a71b84ca99ddf69d2ff7\n+a312e201ba56742499a5480b5f2115f01505c217\n+ce56fdd2e8cdf94fd0ab76d71adbfa755e23ce7d\n+480f42630cbd598c04fa59ee0e406f56904ecffb\n+6012f1caf744ac9b53383d7d10a8f1b70ca2c0e1\n+ded6a2afa549f693dcabb430ce0862f8631360c8\n+07090c5339436f856e79a8036d1c85deeb453803\n+0e265916d1c6a63e4a3821dab9db597b5ec64b46\n+e4ffcacc2187d3419c8ea12b82fb06d82d8751d2\n+e117cfe45eee9169409e74a44ef4a866be25bc35\n+dcfe218626b05204e9fbc95ba5d95ca0eb72ec9b\n+23481fa50301201ef5a60675ef899aa6ce94ca03\n+27c59dc502f29cf1d76290556c21e366145e3b2e\n+4a62ddd01873d18dbca96c81d756be1020249b45\n+a233fb4f1d037e68ff70eef3a9f5b7bf1d631918\n+b2089c51cc4af2f7e1c0ec75be9449ee222b1d69\n+c997f8808256521397f1c003bb1e9896fee6eaa0\n+5dc00f68c49c46a380a98d06233f90528b8e2557\n+fe53d5f3636aed064823bc220d828c7ff08d1d52\n+935eb8de039dec65669a96a1c3b86f4b03a1b86c\n+0277173b1defb63216d40a8d8805ae6d5d563c26\n+2a30e67d20f76bbcd9a7d445f616f005316e0a1a\n+d32528e733f2711b34dbc41fbb2bb0f153bf7e9a\n+4cad91663df381d0dff8526f3b4aa74569dfb626\n+1b06ed136f17b526360617a70026aed5ded5746c\n+895fbd768f0c89cea3f78acac58b233d4e3a145e\n+f0295becbf3ef1fb78095306408789253fe0c114\n+8d573198638e52e2dbd9abc609861430f9d2bcc3\n+9d9c4185fadaf243bb97c226e2fef16b65299699\n+eebe4580bc8d6484d79ecb24dd87412221cf2ea7\n+9cf6393a4f82b9c81d3b4b468a17a89db10531a2\n+598a9c4e4dcd03c6d80fba005de729a6a3aeba7e\n+6970b30c6f1d2be7947295fe18f2390649b17a4b\n+f359afcc410432ed5d30001acda0c66741ee8935\n+126000ba9e7ff16271be2f4eef3df99ade8d624f\n+b5e4b9b5100ec15217d43edb5f4149439f4b20a5\n+b987ca4ee495a7fff82f0ac14ef0753bfb7586e2\n+b03013396cb2f4bf25746388b3982a2c3616e16b\n+9a97f39afaa890caa7987c6bc001b9a66e3e74e8\n+cad504bf4c302f7a72e0a0e191f3fdbafda7340f\n+45cf8a03cb57b8639a8d47323bde46ba22d9eeaf\n+b7450cdbd89a1c862f4d4d8bf093f8a0b5448f9c\n+0910cbe4ef31eb95fd76c7c2f820419fe64a3150\n+92a810d04b906722c9efe60e3997243c71ff3d4c\n+45173fa6fca9537abb0a0554f731d14b9f89c456\n+fd4ca17360e6fc0c9bb76bf6b5b07c9102c12728\n+ddff3447f29b62d79a33f728791f42fa9436216e\n+36a5a4404836da323c755523fbd27563a8e84f94\n+c991b304dee368f506cfee27ddaa333f1f82c518\n+d38d1a3e75aa97ffa8755ddd431754a6d0942964\n+a332a7d5a15214015f9553fdb2bcf80a1a4b8dc0\n+604e08c83cf58ca7e7cda2ab284c1ace7bb12977\n+18a1bbad98bd4321f15e7921d9aec91661499d90\n+8049241e226c16bd07b029c0cb4b62ac40f0c923\n+797441ee995aac59f55d59a93ecb55e8ecbe7dbc\n+62fdf9b07087b80d2142799bdd2324f61483359d\n+f60b4ad57912b78a96af08046a503f7905610a8c\n+13e31dd6548d64a5992f439e74bb424bf88aca04\n+fbce66a982679b5409a295be5c99a2eef429cabf\n+9f2c2dba21855b8cb9b193b1819be73fa4a23a99\n+a89221873a3ee2451c73b41bbe2d99d36f439d31\n+3d6ad407770e13958e157bf026cae0bfb9254899\n+901ba3e3819405306414628306746552b0aa1d28\n+7a43fbb959c38e025e558e472ad57de357539894\n+0d89fa0877930c6c8a539a656c1009ad8ab6755b\n+54aedc013744c86b11157423fa3cffc9a51eef02\n+f0c1f8abb0182da557d07372b938f3a0a4bb906f\n+4ed818060ecf4a38a02c8cb48f6cbc78d2ee7708\n+3bdf242fc68a8d767932c6214455d4d413effbc9\n+5e468994fbb349e8eefc996954a31a67a34aaa15\n+41aa9c4a801a01eca1fad22a7095372d23dace60\n+2adbddb03840ad71e843c6c4a207a13e871cd1d4\n+13e352dc53dec0127c5f94a60055d0ca829420dc\n+95e14dc81dd30ee0d396ad08dca9a6980d16eee1\n+61fb80660f73e5aa5b69302ecc7ac33da206ba5a\n+05a761932edd05cf94ffe938908baf058f38632a\n+ee92243e66f2df03b3a759a8ffb75dc06f0cea0d\n+22cdf93c062eeaa0f8f9d6220f01b67240073dfb\n+76b33491596736ca804e3a29bd8398d7a1516ab7\n+6e4e98ee8ce2da3cca2e2fd210e9e8dbc9b1c936\n+c838283ecdfb9490425bb071b7c22e542de46c7c\n+5e3f5e4f25b65b583d3bfefac9e1148035781089\n+f7388e93d3dd91a90239aedac4ec58404f103a2e\n+0a2f46b0158b6fc7244a585913b0925c0acf707f\n+dd561667cb7ccbbfed3134b05a565971ef6f5873\n+6f01dcf63873a5e42798635ab4026c9a5f9fa213\n+70fec9e36bcd1a3d93df019be084aaf89cecd7d7\n+f9b74ef3fc74fd7d2aa94560820341f03cda8e12\n+998c3046fab2b52bc9f141cfb588a18c05506a86\n+89cc4f905e30b913ca20e4192d538cc5cbe2c38d\n+87d90efd69b64f769116956a5db89e536e9e3714\n+5aeaa9ccd1568a77e075dbe2bd2435bd60c87c91\n+bfb270acfa30713dc8c968bb9ee40cf5a2360359\n+1b8c88451b0554502435d3883c528ad0aad1b09b\n+57ee73990f1ce29916adfd99f93eae1ccea1a43b\n+808c84f89d0edcef9ddaab0b849a382719f6ec9e\n+14b860bf64020451ced823b859da8cb912278ab9\n+c63364610f4a041df1c1bd81d01b1f6856160749\n+92eadc395071876d77f3babddc056b4325bdbabc\n+e93fff1463ae906fc986bf98c3b118c82f171546\n+9ccafb1d7bdd172a9b963444072a844da379c4f7\n+b4a509a3f817121c3df98ddfd96b2769e18a3e5a\n+dbc4ae03963014ab4b7957d62ba59dbd8f938c33\n+8ddf60db7ad636b6a31b590251c671ded635fa1d\n+f199b8a33d9443a258a1f49a1a29674cd9ee9a20\n+e542728cde676f218c552d841d0af29b92f9800b\n+763231051596b8e3455b839911ad6a3a1f1c3c74\n+ff4cd6075b12fb32b9a906deea3ed033e3f9560a\n+9c3c9cdae3e20b5bdea91a0631edac5116bbc89f\n+93d20a734d2ee873832bed8ca5c05cf8e539c53c\n+ef8340d25f7c5dd5682bdecea97ce84cfce1493c\n+69c7ecef405d168f658a9cc7996da84c17f61e66\n+4ce2f3d0d33346e9f0e96851689ee6550b2a72e3\n+44e1fd926cfb0df0fbd8c41de8cd65ed8d5d6e18\n+d6d2c8503c4039b682196d83a67dc28359c10c5c\n+ae233c4ec3d14a97c6195059f52873cdba2b4755\n+0f399a9ff227896265cafab9b2e9fab6cdb9b5b9\n+f4ed44ab4a8f9a87ba678d5fd1449fbf636103dc\n+7fcd61b2613c211bb042a82a889655178be6a212\n+42973f834445d7735738bdba8847812ba3c34d95\n+8df48b36ed3201d938b9974ecbee455d7dc2fb84\n+96ac26e56627f0c24213fcd3a1cce9fc95f1f661\n+cce94c518a46b7b0006f984bbe4d69e8749182d2\n+801dd40666d1e6009920ad3ff755c7bb993b2a62\n+ce829855cfca103dde55661fa1524e66b139d063\n+b148803b181e30213e8a7f3bd89c8239e9dcb866\n+c377feaad87f8109f85da6caf62602b30c20effc\n+b37cab65c63e051ebc5b491da9bd687581df94df\n+16e41844e7d6c5876d2caaeef6010656950c6ec5\n+ee50c9e48786dea0d9df2e45805c25565c100fe3\n+11dacc6154c42bc6fe3ba94c1823f8a46e4fe81a\n+791a0e6ddade27d1b69f4861a6640de60b9553cf\n+638e6c59da4fad987c437592174b188510193b2e\n+52f8877525d5238f3440e73710507be889d14127\n+2a56baf395bf11835d784c4f8634f4525deed6a1\n+bc561b4b7d6a3f71649d37d5eb9047c29efa2b13\n+31809d6f8514c4a8d5677e947e3f1ebb0db210b9\n+a31e9ad4f027955d43c04a05517244647e250161\n+777519bd96f68c18150a0f5942f8f97a91937f5e\n+4eb1f39d421024d9666cec61deaf96715ffae4c6\n+50fae68d416b4b8ec4ca192923dfd5ae9ea42773\n+ce665863b137ac4a7470cf006a92aa7694faca71\n+81f8c0378b2ab5ea0d7b65635cb529bd3c69127c\n+108222b9c323a05cc9339368f10ddd0859f62b43\n+28f788e47e58f2b462351d6989348a4e1a241b2b\n+d81dccf191a48a6b59c3747d7b4ccbe3535dde40\n+a90e6d2bffc422ddcdb771c53aac0bceb970a2c4\n+91e49c51f1aecc9e1d75457f4920d52a4b0a133c\n+60dd9cc470584960431de425e2a9ffbed0e8034a\n+ede386c2193fc31351e193b3a8cf30030d6be62c\n+a084767b40c0d3ba8fa8f8d60f1e8d99a9dc3457\n+3f726c99f819f97f2ab21b94d34c6b3129cd883a\n+77fc469fc78cdd87c29f398d46ac58dbb9ef62c0\n+4ae6d0fbef60ccbecf8f23bb482e201b3678f7a3\n+8858b6ddd3bce9daa08da6e05de3ca863a399c15\n+22e301a3d56dc9e6878380ee92c7d19ca43119d2\n+c484ec6c9b85ca4e331e395c564ae232fd0681dd\n+a46a671e253528e450bd57645c400bf761da07ab\n+655970d9c60ae6850daf452457e14e21047c0e1b\n+b6a48914c50631914192aa11b19205436a9c664d\n+7db65c363a0cc6ca7cdb04de9a973ab70013baad\n+6366941275344dac7e2130b0c972e90117d37ed0\n+4fb2586661471a1572c2df2a5a091011d45eb7c4\n+d7be7b39fa1021ec4518186afe145ee948e12a94\n+85aec87b11ec41295558175c63f1f5a849460fdf\n+aeb31756276034dd506fdf97c8aaade0e7e584f5\n+ac016e17d20253129a0287cee7e1d06b7ef15966\n+bf74d377fb8e20140da6eac1407414928384bcea\n+2c811e08db651a4aed6ea0f7c1972d60de6de8ab\n+e5d26e47c7a482c072a7fe47bb84c56854734184\n+96a63a3e0cefe920819bd42add0041837b1214a1\n+e526ca6284b9e13be1b912b80dd73a34e739b539\n+ecd21357f16106e541e9c2854ead2a906659b938\n+4b5a7ce0c301ad971f383eb60f61bf9b4026efda\n+929fd7276c0f0c30b9416f61a6f5f35d763d81e4\n+fa8a0639f7b0ce04030b72b4d5be4f0aa36fc5cb\n+f1f1605c22a6283bbfd757055fcf2b584a857709\n+0c173a15ca1bf20999f74987988985508c9de463\n+df0793f324e33066cc746c0cb1d053d35733d626\n+2b0179d8a9b75397937126b36114df0dddeab40c\n+bf0a08be281dc42241e7f264c2a20515eb4781bb\n+3895e25a77363ae8b49358fb793f50fa8b271e2d\n+1fc783fc08bc078239537535f174ab8a489772c0\n+1d4805ce04645f3203b0cfd3d66ea710e7433eb4\n+d3b58704d1d325875fc605580c1c02b825c1bbcc\n+ed88e3194c4bc43aeafef929da7b419d03dea1ad\n+dd07f47b79628668e29cc0143b21e790100ee445\n+65cc7aacfbfc7b747926375280a1d839e88d576b\n+080ec5209172ac9605f1434559dbb3c1e012b10a\n+416af3edf5b5ab265acf95568f2bc9eabd3d96de\n+e0a7801223fd573863939e76cb633f1dcc2d22c4\n+4bc853b50fd9127687eb9e4f3b679dd261a4fa96\n+c68a9a69278aa194fed96bd9733d32af3690a11e\n+c38f540298f0e188df5ed68fd56c623b9ac8331b\n+643fa0b22d70e459d7f7ec3d728ae4811dc5158f\n+e053e05c130549f43953f1d70e724dc9ce3e1b85\n+75e898c094eea533d1dfaf141c6afccc3072c49f\n+2805d606bc46bf5589093a1b92d3542c13ce50c2\n+32751807c9c06011eb689cba56b401a6302699c0\n+30853e16d332816752dafcfca92147c7ffef5b54\n+bea5b00cfe95cd37832305c0f93c339a22a7d79d\n+c871f323b418fac27bf834843ca26985010df53f\n+329fc1dce7a1c372c8b10c2f2f8732b2c60daff0\n+1aefc94dd78d6e0c9209cb09fc16f53dedf42108\n+8e5725666b519b61fcdc3141da5c6a57c1959909\n+a4ca0b042365061020627a8c045cddacea3312ec\n+8bd16ee12fc8ef6723e0572c29b979c15b92b4f4\n+87abe20fc118721cc5efdbd94a8462468cd1da2b\n+4b766fcdd4ca16399075d1e081a321b3b05ce516\n+f6241b3e420e19f3f0507cbbc872fe9218916a02\n+7ee523604851af62c0a47c07ee023a8710ef32f7\n+776ba233e939fe41a74c6b2632b93a0679a32c71\n+6a796b2b53fe542e0f340f250f4f20d69efed8d0\n+23d78c4dd01bc74ba35db3e3df95280f6f1b2e22\n+f4b15e2de97c4f8cdbb40bef4c9d0ab2807974d9\n+fff72de5bf8ac7b70208e655f237b80e70e18851\n+170bc2c381f86a523de2fc8b71d62ade66303c0d\n+314ebdfcb38d4b4c977579f787d5e1a20d068c94\n+e9274839bf316b1972d80d28e45759f898edbf86\n+75171f099e82e3527d7c3469b15891bd92227ec2\n+3c5e6c94caf40395e031fbde44a0cca46fdd76ec\n+dc8fc0c73bebbc1c48ac5540026030c9cc00ec23\n+492d22f92919d8d9d59568318c26c1e2ac4890cc\n+80c3a734298e824f9321c4efdd446086a3baad89\n+47535d7c3ec79c5978cdcc03a5351ddbbb22538d\n+1b25b6df0f08f7474228c5b6ed13b58682e1e440\n+c530c15180631cea95e9c292cf7fabde9dca9db3\n+2723bcdce3248417e98e6c43207bef74d34076c1\n+ed22eb4a62bd8d5369aaec87d4cbdc03c9f16368\n+9111df9673beb6d6616d491a5478f09b5f14d040\n+d86bb075bf6d1e78c1e4f3dd38b0ea828ef5ecfe\n+50a1cc0f0aef1514b917a5a3f4476967170b429d\n+6ce733747e160ca699711f2c47e686284ca9aa07\n+b44adf92342ad4f9c343ba29c081a91687932936\n+88799ea1b1c08f4bc1a487c9e3c2effd5e1650ae\n+080d7c700fc3291560d79fc590e05b8e2bad984f\n+12af74b289f8cdc6caf850dc6c802f9936b1e8b3\n+8e4f7e72410df3ba430082c7cf385f26fd75b033\n+8ac80412867118172dc4172494304e19969e9489\n+f2734c2828f69d9cfd535e5eab0592a7674b2b61\n+0b9fb682890b8fe10cec54072b809a5efe57d33d\n+5b029aaedb5fcf7cadd249607dd28eb3f233ab8c\n+79af9fbd8c3c0e54702a9c92b171f134bd4466c8\n+c412fd805ddf3282dc2e1f28e30f51ffcb1f1da2\n+111849345bb5140f86b48e730ceab4bff45fa2e9\n+a0b1e57b20a17177ed5a9a54e4a8aab597a546b4\n+ca209230c8e73745cf8cfc79f500c9c46e103306\n+a230b0588788dbe1ac84622aea169c577b381241\n+dfef6b6af08097f0676a2323085558fbbd3c48c6\n+3192e5278abca7c1f3b4a2a7f77a0ce941c73985\n+7c7ddd9ead99a8b5033a1a5d4698032c9e2b3a92\n+10b930dde8f14e9cb661810e97a33bbf144fc55c\n+9225de2cf652fe2bf6e50636824cdb641546f57d\n+598ef9c44b3ea2cc142c175f077b493f39f5ba22\n+c49355c7170a64bdd7864cc3ba9a64916b67fe7c\n+857d1e171e051b254a617f27b39f6a551054cee2\n+21833f9456f6ad5bc06321ad6d9590f42ce0195c\n+8910b4717e5bb946ee6988f7fe9fd461f53a5935\n+5703dff0939f05c7457cebd6fc61d88ab13afe41\n+8bfa13b15b84cb372950fb7b25a1080173060b6a\n+ac23a7c1f19b3d8c326ffe75c8e13edf285f90fe\n+19be26afe3d04783a92d032b55bf3fb1e2ae63cc\n+f7ec7cfd38b543ba81ac7bed5b77f9a19739460b\n+36afd4db4442c45d4078b1a7ad16a1872b5bee0d\n+88c2ae3ed2bb5d367dd408c9255cd8f1e7a36c7d\n+a13a417cdcfdfd1f1b3bf997bb6ffe6e69b096b9\n+d6064a89ac97dc0d2ce9da3982e1a4e25afaeda8\n+7146d96de3e15a80cafbab2af48ff6f65d8e41bb\n+5628c70f2a44567695e5331fe2293c5b7f35b629\n+7ff4a538a8682cdf02a4bcd6f15499c841001b73\n+aa5fa642b0e7ce2ea55e2298886f212f11a8894e\n+8efd1c820b9a782d8608d54d924658536178295c\n+50a226563cd8d7c0a5e8448e87fede0eb72a8354\n+b860915f8b0dae98e57a254d11575ea41f5c5a79\n+d304fef3746039183f51b3ac8f4774dcf3a64f59\n+53ab12d9318d5d195ccc77028b0e3ae66dc6e1fd\n+668de70be039a4f1ffcf20aeae2a22ee71fc55a8\n+0fea960ca917b73aff853fe88476174c8a313863\n+f89502306dcf6393a2c7b0efbb0fa728fc582137\n+ff58b1c3bdff5e5f687f10f9e40ce495ca49674e\n+0b96abc35f1a9d46a27eeddd7df418d107c29c57\n+b0b57a17306a7e963a4fe463f84e2b150a00a859\n+4105cb6fd964ad13099ca83b1fdf3d35f3961f74\n+23281a4dc3afc42a001346caec4dbb8193f0bb53\n+8daf103fa138f9a184448ebf1c2e03b9dbd96f21\n+02e5308c1b9f3771bbe49bc5036215fa2bd66aa9\n+a65ced1a66575c652baf5084644b8647f531be8c\n+2456a835f0bc7796d9ff71f64837fa6790e2b7cc\n+9ec1330b455c1ab2eb6b89f8a2ab885677d4ae8a\n+0b738075bd43fbd4410e30a51e0498cbfd2b7513\n+98c80e374b84e5a9c2d5c36889a0b1ebed5b814b\n+25720fc394e27a951bcad26095fb5a711bfacb8f\n+4cfd57d2e38207d78722ce8c9274ba8dd700d1cc\n+0fc1c31a878e93d938c67db3f958e82e3c39659f\n+df1ab5b4d67b46b5e9e840b1fbe0ff02520831f9\n+5bc3b6cede8dabdf3f4f27ddb03723cbb7cde51a\n+c2ea1e6561caba3abffce361abc800822b9e0efe\n+caa2f106d704ec3ade63498031dd58d34510bc76\n+dce853ef76ef90c46d84294225088d595467d08c\n+dbc8a8c86ae50059fddb2d6834fa5f0c9bbf9b71\n+0f921e6a0492c4e9f037a9ed91f474885032d68c\n+041331e1da23e4136fd046ed870cdcc177464176\n+e6ba5068f107ac234576e77cedbd748b665369c2\n+76fcd9d5034143a5b041766552670d19f926097d\n+72bf1b3d0962304850a3ef5fe375db4bff1d0a39\n+919db037f1f5cc73cdcaef92dd9cb0e7f5c8dec3\n+c36229b0b2e9d4554053f5c9fc451ac29a493b1f\n+9e4bb312e6958d2baa309ba670e5eed1523c6f47\n+d7ba4a233bd5a6f8fadee681c68a995e23fe36d7\n+98514988a3d3e8b7dbf0463884a5c38f5ed5562d\n+5412c08c3cf13577566064edd04da021c37b7cbe\n+31bcc667863f368157efa1143a78623a5db8f0d1\n+7bd1aa566fb4a4fe194f209085649f2c722b0cff\n+c4522e71c7e1d8ecfd70112e9375b9d00d6733a8\n+e22f409f18881b63a8e747036584a71217f40e6e\n+97ec6e5c9098a1240655cfcab05b6cd5eedb6cd1\n+bc121b0eb19713ec72002b5be03ba5ac35903a17\n+c98f6b3d93a2cc1b49a6db425ea2b661089d0f9e\n+0de7fd36de57a68e543b4c1f184fba192c398c73\n+e662d281b837c25b2b70525aa8fe8af894339823\n+44adf683ad232db8ce0cb89b3e236a1f5944cfb0\n+cb2ed300a89ebf9f0654da869ced665ed8b2abe7\n+0a6d48d9ed60b0b02177059ab116f8f46d2cbed3\n+b42291334651fff46dbfe5947a726f65cb9d7dfe\n+e5364991daecb73aca3bb5ac37f2619d7a89211b\n+4a2b170c075ce703cbdc82519a48016a9ee3f99c\n+924de0bd75a7f75df65d7d15f9d1587a2e794abf\n+1253f8692fc3a11be9430685cd405236a68df6c3\n+2b799ae9e1e0a540f9a5971ddf27d83254668279\n+c9bdf9a75f9fde8cd011e4aa94be4ed4347078a3\n+3d69ecb4edeb80003a1a41442e320898a30dbd9c\n+f08222e882b18c1f279308636e03beceece2dbf1\n+23e03f8d26d7bd03273a5dcbdcfe3905dfb49ffb\n+03dd707dc027fbf6f24120213f8eb66571600374\n+d0754799698de2c032abcb8198ee5d5401063213\n+072116fceb2294b97d1c40f79305f2e3ff71812b\n+e66cc1d58e16bf1650dd6479fed64ecaca8c6098\n+f137753a2dcd8229f89d1d1ac28039364e5850b4\n+61d191fbf953700ba8aeadc9c8cf4c195efbd10c\n+76f3c02fb01a6df98fbd8c16ac21d159d4649d37\n+6013c73b3312e11b447ed387426749014716f820\n+6faffb8a83db3f209a303a4464dbdd597faad5a4\n+cc9e8aca5f950c78dcfeff63c441ba993c1fe12f\n+8ca69a2a88a77eb06149fa049ab1a7e6de38b321\n+2f71490d21796594ca6f55e375558944de9db5a0\n+08cc5fd666456cb476467473ed1880c90c92dedb\n+e31a43c725ebe641d7c219c3886eee18eebf0bb8\n+52b5a8785de760a204b2b0aab19dfaf79c2c3ff0\n+483e8e4f4875a1a621ec9e9df2880d3037d95ed7\n+1e5799c52535a3fc20e885916f1e7ed33ecc7f46\n+a82e5d8220bbc8b5d786bed99b0876f530b9b7cc\n+7fe6c5c993706e8395cdaf7977bee793c06f48f3\n+2a0836f6d5e7c1d7e97bedb0e0ea33dcaf981f77\n+ddc308068d69c6c9aa629ee3c4ce75e1d1cf08b5\n+ec139a5621a9c9f03e1988391a3c7c6c5d849776\n+c01a6c48b982d625fd9f4f69005878781d3d56fa\n+95a983d56dbda457e3bf8766d59bac74c7aa5699\n+760741a00833876976389ed7a6b73f36ee5b4c13\n+6e5e5abba6f8bbbe61c22795df440dfafcfdc378\n+cf2cecb18779ce83de9adebf382dff1c19b12840\n+af9b7a9f2f73b1a2f9728106774dd13e8d1cdd8d\n+115735d547fdeade822f547eb3e8c8f9961a9b07\n+c2c69edf37b5c02aafa01d0407dadbf5ef8751b5\n+a072d1a83787e786d074a4b5871b0b961781f7c6\n+ed2cd59e258f756b2eaed7909a60956ade6ef7ee\n+ae5575ba41c8a782805afb1c08730343cfc22397\n+6ff2c8d29f6b5a5c2ce63f0a16f3bb0dbd049451\n+a80de15113166354cdf208e3d8b6e25f4511a591\n+06bd4f637f15e769f088d9051a5af94bbb0217a3\n+6700cc993cc07fb0f5b8b577ff8c4afcf0b18274\n+37f9a1f627c0995d89b62923e75cd092600894f9\n+8844ef15ded02d5ed86fb95aaf251235fcef2396\n+1b87e5b5b184a0a6c683eda23b36393822b57f03\n+e2bf830bb6c1bfa038c943dd6f5d92a406bd723f\n+423ca302a3ee87000530da3c105f269b8fabece7\n+4e14afe42fdd468d5de11df8cc13defdcb8e83f8\n+3e90fe6534206412ea22beaa445cf20d28fbe718\n+88b77c7da0a672c89e24df37ea6e9085b4e2a05c\n+0ad104190465d8d65c2344bbe10dcf3df025d86c\n+5c7df7022bcd360e6af00b9458b1a3fd54e1cc9a\n+59ad56851a342d2c62f6b38bf15002b23ab439e1"
      },
      {
        "sha": "c60f8ab695e9c0fb01feafb1c28074cb98ab122d",
        "filename": "contrib/verify-commits/trusted-git-root",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/verify-commits/trusted-git-root",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/verify-commits/trusted-git-root",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/verify-commits/trusted-git-root?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -1 +1 @@\n-11049f4fe62606d1b0380a9ef800ac130f0fbadf\n+82bcf405f6db1d55b684a1f63a4aabad376cdad7"
      },
      {
        "sha": "6415eea4d53fe805367f1cf7ed06d5e7339f55db",
        "filename": "contrib/verify-commits/verify-commits.sh",
        "status": "modified",
        "additions": 27,
        "deletions": 5,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/verify-commits/verify-commits.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/contrib/verify-commits/verify-commits.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/verify-commits/verify-commits.sh?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -35,6 +35,8 @@ NO_SHA1=1\n PREV_COMMIT=\"\"\n INITIAL_COMMIT=\"${CURRENT_COMMIT}\"\n \n+BRANCH=\"$(git rev-parse --abbrev-ref HEAD)\"\n+\n while true; do\n \tif [ \"$CURRENT_COMMIT\" = $VERIFIED_ROOT ]; then\n \t\techo \"There is a valid path from \\\"$INITIAL_COMMIT\\\" to $VERIFIED_ROOT where all commits are signed!\"\n@@ -123,9 +125,29 @@ while true; do\n \tfi\n \n \tPARENTS=$(git show -s --format=format:%P \"$CURRENT_COMMIT\")\n-\tfor PARENT in $PARENTS; do\n-\t\tPREV_COMMIT=\"$CURRENT_COMMIT\"\n-\t\tCURRENT_COMMIT=\"$PARENT\"\n-\t\tbreak\n-\tdone\n+\tPARENT1=${PARENTS%% *}\n+\tPARENT2=\"\"\n+\tif [ \"x$PARENT1\" != \"x$PARENTS\" ]; then\n+\t\tPARENTX=${PARENTS#* }\n+\t\tPARENT2=${PARENTX%% *}\n+\t\tif [ \"x$PARENT2\" != \"x$PARENTX\" ]; then\n+\t\t\techo \"Commit $CURRENT_COMMIT is an octopus merge\" > /dev/stderr\n+\t\t\texit 1\n+\t\tfi\n+\tfi\n+\tif [ \"x$PARENT2\" != \"x\" ]; then\n+\t\tCURRENT_TREE=\"$(git show --format=\"%T\" \"$CURRENT_COMMIT\")\"\n+\t\tgit checkout --force --quiet \"$PARENT1\"\n+\t\tgit merge --no-ff --quiet \"$PARENT2\" >/dev/null\n+\t\tRECREATED_TREE=\"$(git show --format=\"%T\" HEAD)\"\n+\t\tif [ \"$CURRENT_TREE\" != \"$RECREATED_TREE\" ]; then\n+\t\t\techo \"Merge commit $CURRENT_COMMIT is not clean\" > /dev/stderr\n+\t\t\tgit diff \"$CURRENT_COMMIT\"\n+\t\t\tgit checkout --force --quiet \"$BRANCH\"\n+\t\t\texit 1\n+\t\tfi\n+\t\tgit checkout --force --quiet \"$BRANCH\"\n+\tfi\n+\tPREV_COMMIT=\"$CURRENT_COMMIT\"\n+\tCURRENT_COMMIT=\"$PARENT1\"\n done"
      },
      {
        "sha": "8b67bce9d8468a83b6d3d236d3ee1390b9fc8591",
        "filename": "depends/Makefile",
        "status": "modified",
        "additions": 11,
        "deletions": 4,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/depends/Makefile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/depends/Makefile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/Makefile?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -1,6 +1,7 @@\n .NOTPARALLEL :\n \n SOURCES_PATH ?= $(BASEDIR)/sources\n+WORK_PATH = $(BASEDIR)/work\n BASE_CACHE ?= $(BASEDIR)/built\n SDK_PATH ?= $(BASEDIR)/SDKs\n NO_QT ?=\n@@ -29,9 +30,9 @@ else\n release_type=release\n endif\n \n-base_build_dir=$(BASEDIR)/work/build\n-base_staging_dir=$(BASEDIR)/work/staging\n-base_download_dir=$(BASEDIR)/work/download\n+base_build_dir=$(WORK_PATH)/build\n+base_staging_dir=$(WORK_PATH)/staging\n+base_download_dir=$(WORK_PATH)/download\n canonical_host:=$(shell ./config.sub $(HOST))\n build:=$(shell ./config.sub $(BUILD))\n \n@@ -165,6 +166,12 @@ $(host_prefix)/share/config.site: check-packages\n \n check-packages: check-sources\n \n+clean-all: clean\n+\t@rm -rf $(SOURCES_PATH) x86_64* i686* mips* arm* aarch64*\n+\n+clean:\n+\t@rm -rf $(WORK_PATH) $(BASE_CACHE) $(BUILD)\n+\n install: check-packages $(host_prefix)/share/config.site\n \n \n@@ -178,4 +185,4 @@ download-win:\n \t@$(MAKE) -s HOST=x86_64-w64-mingw32 download-one\n download: download-osx download-linux download-win\n \n-.PHONY: install cached download-one download-osx download-linux download-win download check-packages check-sources\n+.PHONY: install cached clean clean-all download-one download-osx download-linux download-win download check-packages check-sources"
      },
      {
        "sha": "745c9e11570e46c9cc56ae7b1e5644f4a4f4f2e4",
        "filename": "depends/packages/qt.mk",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/depends/packages/qt.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/depends/packages/qt.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/qt.mk?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -8,7 +8,8 @@ $(package)_dependencies=openssl zlib\n $(package)_linux_dependencies=freetype fontconfig libxcb libX11 xproto libXext\n $(package)_build_subdir=qtbase\n $(package)_qt_libs=corelib network widgets gui plugins testlib\n-$(package)_patches=mac-qmake.conf mingw-uuidof.patch pidlist_absolute.patch fix-xcb-include-order.patch fix_qt_pkgconfig.patch fix-cocoahelpers-macos.patch\n+$(package)_patches=mac-qmake.conf mingw-uuidof.patch pidlist_absolute.patch fix-xcb-include-order.patch\n+$(package)_patches+=fix_qt_pkgconfig.patch fix-cocoahelpers-macos.patch qfixed-coretext.patch\n \n $(package)_qttranslations_file_name=qttranslations-$($(package)_suffix)\n $(package)_qttranslations_sha256_hash=3a15aebd523c6d89fb97b2d3df866c94149653a26d27a00aac9b6d3020bc5a1d\n@@ -141,6 +142,7 @@ define $(package)_preprocess_cmds\n   patch -p1 < $($(package)_patch_dir)/fix-xcb-include-order.patch && \\\n   patch -p1 < $($(package)_patch_dir)/fix_qt_pkgconfig.patch && \\\n   patch -p1 < $($(package)_patch_dir)/fix-cocoahelpers-macos.patch && \\\n+  patch -p1 < $($(package)_patch_dir)/qfixed-coretext.patch && \\\n   echo \"!host_build: QMAKE_CFLAGS     += $($(package)_cflags) $($(package)_cppflags)\" >> qtbase/mkspecs/common/gcc-base.conf && \\\n   echo \"!host_build: QMAKE_CXXFLAGS   += $($(package)_cxxflags) $($(package)_cppflags)\" >> qtbase/mkspecs/common/gcc-base.conf && \\\n   echo \"!host_build: QMAKE_LFLAGS     += $($(package)_ldflags)\" >> qtbase/mkspecs/common/gcc-base.conf && \\"
      },
      {
        "sha": "aa56f1e1de51acdcef0da8c12ec46d4b4c80a8c7",
        "filename": "depends/patches/qt/qfixed-coretext.patch",
        "status": "added",
        "additions": 34,
        "deletions": 0,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/depends/patches/qt/qfixed-coretext.patch",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/depends/patches/qt/qfixed-coretext.patch",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/patches/qt/qfixed-coretext.patch?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -0,0 +1,34 @@\n+From dbdd5f0ffbce52c8b789ed09f1aa3f1da6c02e23 Mon Sep 17 00:00:00 2001\n+From: Gabriel de Dietrich <gabriel.dedietrich@qt.io>\n+Date: Fri, 30 Mar 2018 11:58:16 -0700\n+Subject: [PATCH] QCoreTextFontEngine: Fix build with Xcode 9.3\n+\n+Apple LLVM version 9.1.0 (clang-902.0.39.1)\n+\n+Error message:\n+\n+.../qfontengine_coretext.mm:827:20: error: qualified reference to\n+      'QFixed' is a constructor name rather than a type in this context\n+    return QFixed::QFixed(int(CTFontGetUnitsPerEm(ctfont)));\n+\n+Change-Id: Iebe26b3b087a16b10664208fc8851cbddb47f043\n+Reviewed-by: Konstantin Ritt <ritt.ks@gmail.com>\n+---\n+ src/platformsupport/fontdatabases/mac/qfontengine_coretext.mm | 2 +-\n+ 1 file changed, 1 insertion(+), 1 deletion(-)\n+\n+diff --git old/qtbase/src/platformsupport/fontdatabases/mac/qfontengine_coretext.mm new/qtbase/src/platformsupport/fontdatabases/mac/qfontengine_coretext.mm\n+index 25ff69d877d..98b753eff96 100644\n+--- old/qtbase/src/platformsupport/fontdatabases/mac/qfontengine_coretext.mm\n++++ new/qtbase/src/platformsupport/fontdatabases/mac/qfontengine_coretext.mm\n+@@ -824,7 +824,7 @@ void QCoreTextFontEngine::getUnscaledGlyph(glyph_t glyph, QPainterPath *path, gl\n+ \n+ QFixed QCoreTextFontEngine::emSquareSize() const\n+ {\n+-    return QFixed::QFixed(int(CTFontGetUnitsPerEm(ctfont)));\n++    return QFixed(int(CTFontGetUnitsPerEm(ctfont)));\n+ }\n+ \n+ QFontEngine *QCoreTextFontEngine::cloneWithSize(qreal pixelSize) const\n+-- \n+2.16.3\n\\ No newline at end of file"
      },
      {
        "sha": "5b8eabd6dfa36acd13ca320ed545b87258ba18b0",
        "filename": "doc/bips.md",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/doc/bips.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/doc/bips.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/bips.md?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -1,4 +1,4 @@\n-BIPs that are implemented by Bitcoin Core (up-to-date up to **v0.13.0**):\n+BIPs that are implemented by Bitcoin Core (up-to-date up to **v0.16.0**):\n \n * [`BIP 9`](https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki): The changes allowing multiple soft-forks to be deployed in parallel have been implemented since **v0.12.1**  ([PR #7575](https://github.com/bitcoin/bitcoin/pull/7575))\n * [`BIP 11`](https://github.com/bitcoin/bips/blob/master/bip-0011.mediawiki): Multisig outputs are standard since **v0.6.0** ([PR #669](https://github.com/bitcoin/bitcoin/pull/669)).\n@@ -34,4 +34,5 @@ BIPs that are implemented by Bitcoin Core (up-to-date up to **v0.13.0**):\n * [`BIP 147`](https://github.com/bitcoin/bips/blob/master/bip-0147.mediawiki): NULLDUMMY softfork as of **v0.13.1** ([PR 8636](https://github.com/bitcoin/bitcoin/pull/8636) and [PR 8937](https://github.com/bitcoin/bitcoin/pull/8937)).\n * [`BIP 152`](https://github.com/bitcoin/bips/blob/master/bip-0152.mediawiki): Compact block transfer and related optimizations are used as of **v0.13.0** ([PR 8068](https://github.com/bitcoin/bitcoin/pull/8068)).\n * [`BIP 159`](https://github.com/bitcoin/bips/blob/master/bip-0159.mediawiki): NODE_NETWORK_LIMITED service bit [signaling only] is supported as of **v0.16.0** ([PR 11740](https://github.com/bitcoin/bitcoin/pull/11740)).\n+* [`BIP 173`](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki): Bech32 addresses for native Segregated Witness outputs are supported as of **v0.16.0** ([PR 11167](https://github.com/bitcoin/bitcoin/pull/11167)).\n * [`BIP 176`](https://github.com/bitcoin/bips/blob/master/bip-0176.mediawiki): Bits Denomination [QT only] is supported as of **v0.16.0** ([PR 12035](https://github.com/bitcoin/bitcoin/pull/12035))."
      },
      {
        "sha": "e52a770cedb68df51523681742dfaed8108d12fe",
        "filename": "doc/build-osx.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/doc/build-osx.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/doc/build-osx.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-osx.md?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -16,7 +16,7 @@ Then install [Homebrew](https://brew.sh).\n Dependencies\n ----------------------\n \n-    brew install automake berkeley-db4 libtool boost miniupnpc openssl pkg-config protobuf python qt libevent\n+    brew install automake berkeley-db4 libtool boost miniupnpc openssl pkg-config protobuf python qt libevent qrencode\n \n See [dependencies.md](dependencies.md) for a complete overview.\n "
      },
      {
        "sha": "07bb0c096ab245a92f1592cb5eb4120f4fb354a0",
        "filename": "doc/build-windows.md",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/doc/build-windows.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/doc/build-windows.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-windows.md?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -53,8 +53,8 @@ Cross-compilation for Ubuntu and Windows Subsystem for Linux\n \n At the time of writing the Windows Subsystem for Linux installs Ubuntu Xenial 16.04. The Mingw-w64 package\n for Ubuntu Xenial does not produce working executables for some of the Bitcoin Core applications.\n-It is possible to build on Ubuntu Xenial by installing the cross compiler packages from Ubuntu Zesty, see the steps below.\n-Building on Ubuntu Zesty 17.04 up to 17.10 has been verified to work.\n+It is possible to build on Ubuntu Xenial by installing the cross compiler packages from Ubuntu Artful, see the steps below.\n+Building on Ubuntu Artful 17.10 has been verified to work.\n \n The steps below can be performed on Ubuntu (including in a VM) or WSL. The depends system\n will also work on other Linux distributions, however the commands for\n@@ -88,12 +88,12 @@ Ubuntu Trusty 14.04:\n Ubuntu Xenial 16.04 and Windows Subsystem for Linux <sup>[1](#footnote1),[2](#footnote2)</sup>:\n \n     sudo apt install software-properties-common\n-    sudo add-apt-repository \"deb http://archive.ubuntu.com/ubuntu zesty universe\"\n+    sudo add-apt-repository \"deb http://archive.ubuntu.com/ubuntu artful universe\"\n     sudo apt update\n     sudo apt upgrade\n     sudo update-alternatives --config x86_64-w64-mingw32-g++ # Set the default mingw32 g++ compiler option to posix.\n \n-Ubuntu Zesty 17.04 <sup>[2](#footnote2)</sup>:\n+Ubuntu Artful 17.10 <sup>[2](#footnote2)</sup>:\n \n     sudo update-alternatives --config x86_64-w64-mingw32-g++ # Set the default mingw32 g++ compiler option to posix.\n \n@@ -123,7 +123,7 @@ To build executables for Windows 32-bit, install the following dependencies:\n \n     sudo apt install g++-mingw-w64-i686 mingw-w64-i686-dev\n \n-For Ubuntu Xenial 16.04, Ubuntu Zesty 17.04 and Windows Subsystem for Linux <sup>[2](#footnote2)</sup>:\n+For Ubuntu Xenial 16.04, Ubuntu Artful 17.10 and Windows Subsystem for Linux <sup>[2](#footnote2)</sup>:\n \n     sudo update-alternatives --config i686-w64-mingw32-g++  # Set the default mingw32 g++ compiler option to posix.\n \n@@ -165,7 +165,7 @@ Footnotes\n <a name=\"footnote1\">1</a>: There is currently a bug in the 64 bit Mingw-w64 cross compiler packaged for WSL/Ubuntu Xenial 16.04 that\n causes two of the bitcoin executables to crash shortly after start up. The bug is related to the\n -fstack-protector-all g++ compiler flag which is used to mitigate buffer overflows.\n-Installing the Mingw-w64 packages from the Ubuntu 17 distribution solves the issue, however, this is not\n+Installing the Mingw-w64 packages from the Ubuntu 17.10 distribution solves the issue, however, this is not\n an officially supported approach and it's only recommended if you are prepared to reinstall WSL/Ubuntu should\n something break.\n "
      },
      {
        "sha": "1f237b750eaeec5ee6816e3b00dec0efa19bba20",
        "filename": "doc/developer-notes.md",
        "status": "modified",
        "additions": 211,
        "deletions": 51,
        "changes": 262,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/doc/developer-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/doc/developer-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/developer-notes.md?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -1,6 +1,43 @@\n Developer Notes\n ===============\n \n+<!-- markdown-toc start -->\n+**Table of Contents**\n+\n+- [Developer Notes](#developer-notes)\n+    - [Coding Style](#coding-style)\n+    - [Doxygen comments](#doxygen-comments)\n+    - [Development tips and tricks](#development-tips-and-tricks)\n+        - [Compiling for debugging](#compiling-for-debugging)\n+        - [Compiling for gprof profiling](#compiling-for-gprof-profiling)\n+        - [debug.log](#debuglog)\n+        - [Testnet and Regtest modes](#testnet-and-regtest-modes)\n+        - [DEBUG_LOCKORDER](#debug_lockorder)\n+        - [Valgrind suppressions file](#valgrind-suppressions-file)\n+        - [Compiling for test coverage](#compiling-for-test-coverage)\n+    - [Locking/mutex usage notes](#lockingmutex-usage-notes)\n+    - [Threads](#threads)\n+    - [Ignoring IDE/editor files](#ignoring-ideeditor-files)\n+- [Development guidelines](#development-guidelines)\n+    - [General Bitcoin Core](#general-bitcoin-core)\n+    - [Wallet](#wallet)\n+    - [General C++](#general-c)\n+    - [C++ data structures](#c-data-structures)\n+    - [Strings and formatting](#strings-and-formatting)\n+    - [Variable names](#variable-names)\n+    - [Threads and synchronization](#threads-and-synchronization)\n+    - [Source code organization](#source-code-organization)\n+    - [GUI](#gui)\n+    - [Subtrees](#subtrees)\n+    - [Git and GitHub tips](#git-and-github-tips)\n+    - [Scripted diffs](#scripted-diffs)\n+    - [RPC interface guidelines](#rpc-interface-guidelines)\n+\n+<!-- markdown-toc end -->\n+\n+Coding Style\n+---------------\n+\n Various coding styles have been used during the history of the codebase,\n and the result is not very consistent. However, we're now trying to converge to\n a single style, which is specified below. When writing patches, favor the new\n@@ -13,7 +50,7 @@ Do not submit patches solely to modify the style of existing code.\n [src/.clang-format](/src/.clang-format). You can use the provided\n [clang-format-diff script](/contrib/devtools/README.md#clang-format-diffpy)\n tool to clean up patches automatically before submission.\n-  - Braces on new lines for namespaces, classes, functions, methods.\n+  - Braces on new lines for classes, functions, methods.\n   - Braces on the same line for everything else.\n   - 4 space indentation (no tabs) for every block except namespaces.\n   - No indentation for `public`/`protected`/`private` or for `namespace`.\n@@ -34,18 +71,21 @@ code.\n   - Constant names are all uppercase, and use `_` to separate words.\n   - Class names, function names and method names are UpperCamelCase\n     (PascalCase). Do not prefix class names with `C`.\n+  - Test suite naming convention: The Boost test suite in file\n+    `src/test/foo_tests.cpp` should be named `foo_tests`. Test suite names\n+    must be unique.\n \n - **Miscellaneous**\n   - `++i` is preferred over `i++`.\n   - `nullptr` is preferred over `NULL` or `(void*)0`.\n   - `static_assert` is preferred over `assert` where possible. Generally; compile-time checking is preferred over run-time checking.\n+  - `enum class` is preferred over `enum` where possible. Scoped enumerations avoid two potential pitfalls/problems with traditional C++ enumerations: implicit conversions to int, and name clashes due to enumerators being exported to the surrounding scope.\n \n Block style example:\n ```c++\n int g_count = 0;\n \n-namespace foo\n-{\n+namespace foo {\n class Class\n {\n     std::string m_name;\n@@ -137,43 +177,44 @@ Documentation can be generated with `make docs` and cleaned up with `make clean-\n Development tips and tricks\n ---------------------------\n \n-**compiling for debugging**\n+### Compiling for debugging\n \n-Run configure with the --enable-debug option, then make. Or run configure with\n-CXXFLAGS=\"-g -ggdb -O0\" or whatever debug flags you need.\n+Run configure with `--enable-debug` to add additional compiler flags that\n+produce better debugging builds.\n \n-**compiling for gprof profiling**\n+### Compiling for gprof profiling\n \n-Run configure with the --enable-gprof option, then make.\n+Run configure with the `--enable-gprof` option, then make.\n \n-**debug.log**\n+### debug.log\n \n If the code is behaving strangely, take a look in the debug.log file in the data directory;\n error and debugging messages are written there.\n \n-The -debug=... command-line option controls debugging; running with just -debug or -debug=1 will turn\n+The `-debug=...` command-line option controls debugging; running with just `-debug` or `-debug=1` will turn\n on all categories (and give you a very large debug.log file).\n \n-The Qt code routes qDebug() output to debug.log under category \"qt\": run with -debug=qt\n+The Qt code routes `qDebug()` output to debug.log under category \"qt\": run with `-debug=qt`\n to see it.\n \n-**testnet and regtest modes**\n+### Testnet and Regtest modes\n \n-Run with the -testnet option to run with \"play bitcoins\" on the test network, if you\n+Run with the `-testnet` option to run with \"play bitcoins\" on the test network, if you\n are testing multi-machine code that needs to operate across the internet.\n \n-If you are testing something that can run on one machine, run with the -regtest option.\n-In regression test mode, blocks can be created on-demand; see test/functional/ for tests\n-that run in -regtest mode.\n+If you are testing something that can run on one machine, run with the `-regtest` option.\n+In regression test mode, blocks can be created on-demand; see [test/functional/](/test/functional) for tests\n+that run in `-regtest` mode.\n \n-**DEBUG_LOCKORDER**\n+### DEBUG_LOCKORDER\n \n-Bitcoin Core is a multithreaded application, and deadlocks or other multithreading bugs\n-can be very difficult to track down. Compiling with -DDEBUG_LOCKORDER (configure\n-CXXFLAGS=\"-DDEBUG_LOCKORDER -g\") inserts run-time checks to keep track of which locks\n-are held, and adds warnings to the debug.log file if inconsistencies are detected.\n+Bitcoin Core is a multi-threaded application, and deadlocks or other\n+multi-threading bugs can be very difficult to track down. The `--enable-debug`\n+configure option adds `-DDEBUG_LOCKORDER` to the compiler flags. This inserts\n+run-time checks to keep track of which locks are held, and adds warnings to the\n+debug.log file if inconsistencies are detected.\n \n-**Valgrind suppressions file**\n+### Valgrind suppressions file\n \n Valgrind is a programming tool for memory debugging, memory leak detection, and\n profiling. The repo contains a Valgrind suppressions file\n@@ -188,7 +229,7 @@ $ valgrind --suppressions=contrib/valgrind.supp --leak-check=full \\\n $ valgrind -v --leak-check=full src/bitcoind -printtoconsole\n ```\n \n-**compiling for test coverage**\n+### Compiling for test coverage\n \n LCOV can be used to generate a test coverage report based upon `make check`\n execution. LCOV must be installed on your system (e.g. the `lcov` package\n@@ -204,22 +245,73 @@ make cov\n # A coverage report will now be accessible at `./test_bitcoin.coverage/index.html`.\n ```\n \n+**Sanitizers**\n+\n+Bitcoin can be compiled with various \"sanitizers\" enabled, which add\n+instrumentation for issues regarding things like memory safety, thread race\n+conditions, or undefined behavior. This is controlled with the\n+`--with-sanitizers` configure flag, which should be a comma separated list of\n+sanitizers to enable. The sanitizer list should correspond to supported\n+`-fsanitize=` options in your compiler. These sanitizers have runtime overhead,\n+so they are most useful when testing changes or producing debugging builds.\n+\n+Some examples:\n+\n+```bash\n+# Enable both the address sanitizer and the undefined behavior sanitizer\n+./configure --with-sanitizers=address,undefined\n+\n+# Enable the thread sanitizer\n+./configure --with-sanitizers=thread\n+```\n+\n+If you are compiling with GCC you will typically need to install corresponding\n+\"san\" libraries to actually compile with these flags, e.g. libasan for the\n+address sanitizer, libtsan for the thread sanitizer, and libubsan for the\n+undefined sanitizer. If you are missing required libraries, the configure script\n+will fail with a linker error when testing the sanitizer flags.\n+\n+The test suite should pass cleanly with the `thread` and `undefined` sanitizers,\n+but there are a number of known problems when using the `address` sanitizer. The\n+address sanitizer is known to fail in\n+[sha256_sse4::Transform](/src/crypto/sha256_sse4.cpp) which makes it unusable\n+unless you also use `--disable-asm` when running configure. We would like to fix\n+sanitizer issues, so please send pull requests if you can fix any errors found\n+by the address sanitizer (or any other sanitizer).\n+\n+Not all sanitizer options can be enabled at the same time, e.g. trying to build\n+with `--with-sanitizers=address,thread` will fail in the configure script as\n+these sanitizers are mutually incompatible. Refer to your compiler manual to\n+learn more about these options and which sanitizers are supported by your\n+compiler.\n+\n+Additional resources:\n+\n+ * [AddressSanitizer](https://clang.llvm.org/docs/AddressSanitizer.html)\n+ * [LeakSanitizer](https://clang.llvm.org/docs/LeakSanitizer.html)\n+ * [MemorySanitizer](https://clang.llvm.org/docs/MemorySanitizer.html)\n+ * [ThreadSanitizer](https://clang.llvm.org/docs/ThreadSanitizer.html)\n+ * [UndefinedBehaviorSanitizer](https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html)\n+ * [GCC Instrumentation Options](https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html)\n+ * [Google Sanitizers Wiki](https://github.com/google/sanitizers/wiki)\n+ * [Issue #12691: Enable -fsanitize flags in Travis](https://github.com/bitcoin/bitcoin/issues/12691)\n+\n Locking/mutex usage notes\n -------------------------\n \n The code is multi-threaded, and uses mutexes and the\n-LOCK/TRY_LOCK macros to protect data structures.\n+`LOCK` and `TRY_LOCK` macros to protect data structures.\n \n-Deadlocks due to inconsistent lock ordering (thread 1 locks cs_main\n-and then cs_wallet, while thread 2 locks them in the opposite order:\n-result, deadlock as each waits for the other to release its lock) are\n-a problem. Compile with -DDEBUG_LOCKORDER to get lock order\n-inconsistencies reported in the debug.log file.\n+Deadlocks due to inconsistent lock ordering (thread 1 locks `cs_main` and then\n+`cs_wallet`, while thread 2 locks them in the opposite order: result, deadlock\n+as each waits for the other to release its lock) are a problem. Compile with\n+`-DDEBUG_LOCKORDER` (or use `--enable-debug`) to get lock order inconsistencies\n+reported in the debug.log file.\n \n Re-architecting the core code so there are better-defined interfaces\n between the various components is a goal, with any necessary locking\n-done by the components (e.g. see the self-contained CKeyStore class\n-and its cs_KeyStore lock for example).\n+done by the components (e.g. see the self-contained `CBasicKeyStore` class\n+and its `cs_KeyStore` lock for example).\n \n Threads\n -------\n@@ -358,12 +450,21 @@ C++ data structures\n \n - Vector bounds checking is only enabled in debug mode. Do not rely on it\n \n-- Make sure that constructors initialize all fields. If this is skipped for a\n-  good reason (i.e., optimization on the critical path), add an explicit\n-  comment about this\n+- Initialize all non-static class members where they are defined.\n+  If this is skipped for a good reason (i.e., optimization on the critical\n+  path), add an explicit comment about this\n \n   - *Rationale*: Ensure determinism by avoiding accidental use of uninitialized\n     values. Also, static analyzers balk about this.\n+    Initializing the members in the declaration makes it easy to\n+    spot uninitialized ones.\n+\n+```cpp\n+class A\n+{\n+    uint32_t m_count{0};\n+}\n+```\n \n - By default, declare single-argument constructors `explicit`.\n \n@@ -382,18 +483,6 @@ C++ data structures\n   - *Rationale*: Easier to understand what is happening, thus easier to spot mistakes, even for those\n   that are not language lawyers\n \n-- Initialize all non-static class members where they are defined\n-\n-  - *Rationale*: Initializing the members in the declaration makes it easy to spot uninitialized ones,\n-  and avoids accidentally reading uninitialized memory\n-\n-```cpp\n-class A\n-{\n-    uint32_t m_count{0};\n-}\n-```\n-\n Strings and formatting\n ------------------------\n \n@@ -479,8 +568,7 @@ Source code organization\n   - *Rationale*: Shorter and simpler header files are easier to read, and reduce compile time\n \n - Every `.cpp` and `.h` file should `#include` every header file it directly uses classes, functions or other\n-  definitions from, even if those headers are already included indirectly through other headers. One exception\n-  is that a `.cpp` file does not need to re-include the includes already included in its corresponding `.h` file.\n+  definitions from, even if those headers are already included indirectly through other headers.\n \n   - *Rationale*: Excluding headers because they are already indirectly included results in compilation\n     failures when those indirect dependencies change. Furthermore, it obscures what the real code\n@@ -496,11 +584,11 @@ Source code organization\n \n ```c++\n namespace mynamespace {\n-    ...\n+...\n } // namespace mynamespace\n \n namespace {\n-    ...\n+...\n } // namespace\n ```\n \n@@ -514,6 +602,16 @@ namespace {\n     source file into account. This allows quoted includes to stand out more when\n     the location of the source file actually is relevant.\n \n+- Use include guards to avoid the problem of double inclusion. The header file\n+  `foo/bar.h` should use the include guard identifier `BITCOIN_FOO_BAR_H`, e.g.\n+\n+```c++\n+#ifndef BITCOIN_FOO_BAR_H\n+#define BITCOIN_FOO_BAR_H\n+...\n+#endif // BITCOIN_FOO_BAR_H\n+```\n+\n GUI\n -----\n \n@@ -523,6 +621,19 @@ GUI\n     should not interact with the user. That's where View classes come in. The converse also\n     holds: try to not directly access core data structures from Views.\n \n+- Avoid adding slow or blocking code in the GUI thread. In particular do not\n+  add new `interfaces::Node` and `interfaces::Wallet` method calls, even if they\n+  may be fast now, in case they are changed to lock or communicate across\n+  processes in the future.\n+\n+  Prefer to offload work from the GUI thread to worker threads (see\n+  `RPCExecutor` in console code as an example) or take other steps (see\n+  https://doc.qt.io/archives/qq/qq27-responsive-guis.html) to keep the GUI\n+  responsive.\n+\n+  - *Rationale*: Blocking the GUI thread can increase latency, and lead to\n+    hangs and deadlocks.\n+\n Subtrees\n ----------\n \n@@ -542,7 +653,10 @@ its upstream repository.\n Current subtrees include:\n \n - src/leveldb\n-  - Upstream at https://github.com/google/leveldb ; Maintained by Google, but open important PRs to Core to avoid delay\n+  - Upstream at https://github.com/google/leveldb ; Maintained by Google, but\n+    open important PRs to Core to avoid delay.\n+  - **Note**: Follow the instructions in [Upgrading LevelDB](#upgrading-leveldb) when\n+    merging upstream changes to the leveldb subtree.\n \n - src/libsecp256k1\n   - Upstream at https://github.com/bitcoin-core/secp256k1/ ; actively maintaned by Core contributors.\n@@ -553,6 +667,52 @@ Current subtrees include:\n - src/univalue\n   - Upstream at https://github.com/jgarzik/univalue ; report important PRs to Core to avoid delay.\n \n+Upgrading LevelDB\n+---------------------\n+\n+Extra care must be taken when upgrading LevelDB. This section explains issues\n+you must be aware of.\n+\n+### File Descriptor Counts\n+\n+In most configurations we use the default LevelDB value for `max_open_files`,\n+which is 1000 at the time of this writing. If LevelDB actually uses this many\n+file descriptors it will cause problems with Bitcoin's `select()` loop, because\n+it may cause new sockets to be created where the fd value is >= 1024. For this\n+reason, on 64-bit Unix systems we rely on an internal LevelDB optimization that\n+uses `mmap()` + `close()` to open table files without actually retaining\n+references to the table file descriptors. If you are upgrading LevelDB, you must\n+sanity check the changes to make sure that this assumption remains valid.\n+\n+In addition to reviewing the upstream changes in `env_posix.cc`, you can use `lsof` to\n+check this. For example, on Linux this command will show open `.ldb` file counts:\n+\n+```bash\n+$ lsof -p $(pidof bitcoind) |\\\n+    awk 'BEGIN { fd=0; mem=0; } /ldb$/ { if ($4 == \"mem\") mem++; else fd++ } END { printf \"mem = %s, fd = %s\\n\", mem, fd}'\n+mem = 119, fd = 0\n+```\n+\n+The `mem` value shows how many files are mmap'ed, and the `fd` value shows you\n+many file descriptors these files are using. You should check that `fd` is a\n+small number (usually 0 on 64-bit hosts).\n+\n+See the notes in the `SetMaxOpenFiles()` function in `dbwrapper.cc` for more\n+details.\n+\n+### Consensus Compatibility\n+\n+It is possible for LevelDB changes to inadvertently change consensus\n+compatibility between nodes. This happened in Bitcoin 0.8 (when LevelDB was\n+first introduced). When upgrading LevelDB you should review the upstream changes\n+to check for issues affecting consensus compatibility.\n+\n+For example, if LevelDB had a bug that accidentally prevented a key from being\n+returned in an edge case, and that bug was fixed upstream, the bug \"fix\" would\n+be an incompatible consensus change. In this situation the correct behavior\n+would be to revert the upstream fix before applying the updates to Bitcoin's\n+copy of LevelDB. In general you should be wary of any upstream changes affecting\n+what data is returned from LevelDB queries.\n \n Git and GitHub tips\n ---------------------"
      },
      {
        "sha": "5657b1e6cbebb7d3424836b56bff78036017e7b2",
        "filename": "doc/files.md",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/doc/files.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/doc/files.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/files.md?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -10,6 +10,7 @@\n * db.log: wallet database log file; moved to wallets/ directory on new installs since 0.16.0\n * debug.log: contains debug information and general logging generated by bitcoind or bitcoin-qt\n * fee_estimates.dat: stores statistics used to estimate minimum transaction fees and priorities required for confirmation; since 0.10.0\n+* indexes/txindex/*: optional transaction index database (LevelDB); since 0.17.0\n * mempool.dat: dump of the mempool's transactions; since 0.14.0.\n * peers.dat: peer IP address database (custom format); since 0.7.0\n * wallet.dat: personal wallet (BDB) with keys and transactions; moved to wallets/ directory on new installs since 0.16.0"
      },
      {
        "sha": "7e1967daf020a50c2cc98cdb59bc44fae623b349",
        "filename": "doc/release-notes-pr10267.md",
        "status": "added",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/doc/release-notes-pr10267.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/doc/release-notes-pr10267.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes-pr10267.md?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -0,0 +1,13 @@\n+Changed command-line options\n+----------------------------\n+\n+- `-includeconf=<file>` can be used to include additional configuration files.\n+  Only works inside the `bitcoin.conf` file, not inside included files or from\n+  command-line. Multiple files may be included. Can be disabled from command-\n+  line via `-noincludeconf`. Note that multi-argument commands like\n+  `-includeconf` will override preceding `-noincludeconf`, i.e.\n+\n+    noincludeconf=1\n+    includeconf=relative.conf\n+\n+  as bitcoin.conf will still include `relative.conf`."
      },
      {
        "sha": "b493908716c9cbc9f8db932961873b5d0e0a29dc",
        "filename": "doc/release-notes-pr12823.md",
        "status": "added",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/doc/release-notes-pr12823.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/doc/release-notes-pr12823.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes-pr12823.md?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -0,0 +1,20 @@\n+Configuration sections for testnet and regtest\n+----------------------------------------------\n+\n+It is now possible for a single configuration file to set different\n+options for different networks. This is done by using sections or by\n+prefixing the option with the network, such as:\n+\n+    main.uacomment=bitcoin\n+    test.uacomment=bitcoin-testnet\n+    regtest.uacomment=regtest\n+    [main]\n+    mempoolsize=300\n+    [test]\n+    mempoolsize=100\n+    [regtest]\n+    mempoolsize=20\n+\n+The `addnode=`, `connect=`, `port=`, `bind=`, `rpcport=`, `rpcbind=`\n+and `wallet=` options will only apply to mainnet when specified in the\n+configuration file, unless a network is specified."
      },
      {
        "sha": "8105eca5c0894a7a73ad2ce7e6c20b8d7f5a0c63",
        "filename": "doc/release-notes-pr12892.md",
        "status": "added",
        "additions": 37,
        "deletions": 0,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/doc/release-notes-pr12892.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/doc/release-notes-pr12892.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes-pr12892.md?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -0,0 +1,37 @@\n+'label' and 'account' APIs for wallet\n+-------------------------------------\n+\n+A new 'label' API has been introduced for the wallet. This is intended as a\n+replacement for the deprecated 'account' API. The 'account' can continue to\n+be used in V0.17 by starting bitcoind with the '-deprecatedrpc=accounts'\n+argument, and will be fully removed in V0.18.\n+\n+The label RPC methods mirror the account functionality, with the following functional differences:\n+\n+- Labels can be set on any address, not just receiving addresses. This functionality was previously only available through the GUI.\n+- Labels can be deleted by reassigning all addresses using the `setlabel` RPC method.\n+- There isn't support for sending transactions _from_ a label, or for determining which label a transaction was sent from.\n+- Labels do not have a balance.\n+\n+Here are the changes to RPC methods:\n+\n+| Deprecated Method       | New Method            | Notes       |\n+| :---------------------- | :-------------------- | :-----------|\n+| `getaccount`            | `getaddressinfo`      | `getaddressinfo` returns a json object with address information instead of just the name of the account as a string. |\n+| `getaccountaddress`     | `getlabeladdress`     | `getlabeladdress` throws an error by default if the label does not already exist, but provides a `force` option for compatibility with existing applications. |\n+| `getaddressesbyaccount` | `getaddressesbylabel` | `getaddressesbylabel` returns a json object with the addresses as keys, instead of a list of strings. |\n+| `getreceivedbyaccount`  | `getreceivedbylabel`  | _no change in behavior_ |\n+| `listaccounts`          | `listlabels`          | `listlabels` does not return a balance or accept `minconf` and `watchonly` arguments. |\n+| `listreceivedbyaccount` | `listreceivedbylabel` | Both methods return new `label` fields, along with `account` fields for backward compatibility. |\n+| `move`                  | n/a                   | _no replacement_ |\n+| `sendfrom`              | n/a                   | _no replacement_ |\n+| `setaccount`            | `setlabel`            | Both methods now: <ul><li>allow assigning labels to any address, instead of raising an error if the address is not receiving address.<li>delete the previous label associated with an address when the final address using that label is reassigned to a different label, instead of making an implicit `getaccountaddress` call to ensure the previous label still has a receiving address. |\n+\n+| Changed Method         | Notes   |\n+| :--------------------- | :------ |\n+| `addmultisigaddress`   | Renamed `account` named parameter to `label`. Still accepts `account` for backward compatibility if running with '-deprecatedrpc=accounts'. |\n+| `getnewaddress`        | Renamed `account` named parameter to `label`. Still accepts `account` for backward compatibility. if running with '-deprecatedrpc=accounts' |\n+| `listunspent`          | Returns new `label` fields. `account` field will be returned for backward compatibility if running with '-deprecatedrpc=accounts' |\n+| `sendmany`             | The `account` named parameter has been renamed to `dummy`. If provided, the `dummy` parameter must be set to the empty string, unless running with the `-deprecatedrpc=accounts` argument (in which case functionality is unchanged). |\n+| `listtransactions`     | The `account` named parameter has been renamed to `dummy`. If provided, the `dummy` parameter must be set to the string `*`, unless running with the `-deprecatedrpc=accounts` argument (in which case functionality is unchanged). |\n+| `getbalance`           | `account`, `minconf` and `include_watchonly` parameters are deprecated, and can only be used if running with '-deprecatedrpc=accounts' |"
      },
      {
        "sha": "3ab4a984dbad651184ba3e9ea19bc9894d4d80b3",
        "filename": "doc/release-notes-pr13033.md",
        "status": "added",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/doc/release-notes-pr13033.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/doc/release-notes-pr13033.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes-pr13033.md?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -0,0 +1,11 @@\n+Transaction index changes\n+-------------------------\n+\n+The transaction index is now built separately from the main node procedure,\n+meaning the `-txindex` flag can be toggled without a full reindex. If bitcoind\n+is run with `-txindex` on a node that is already partially or fully synced\n+without one, the transaction index will be built in the background and become\n+available once caught up. When switching from running `-txindex` to running\n+without the flag, the transaction index database will *not* be deleted\n+automatically, meaning it could be turned back on at a later time without a full\n+resync."
      },
      {
        "sha": "7a9a98bfec5cf86edf99b2eb869628e84a6a2f05",
        "filename": "doc/release-notes.md",
        "status": "modified",
        "additions": 38,
        "deletions": 10,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/doc/release-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/doc/release-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes.md?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -63,17 +63,17 @@ RPC changes\n \n - The `createrawtransaction` RPC will now accept an array or dictionary (kept for compatibility) for the `outputs` parameter. This means the order of transaction outputs can be specified by the client.\n - The `fundrawtransaction` RPC will reject the previously deprecated `reserveChangeKey` option.\n-- Wallet `getnewaddress` and `addmultisigaddress` RPC `account` named\n-  parameters have been renamed to `label` with no change in behavior.\n-- Wallet `getlabeladdress`, `getreceivedbylabel`, `listreceivedbylabel`, and\n-  `setlabel` RPCs have been added to replace `getaccountaddress`,\n-  `getreceivedbyaccount`, `listreceivedbyaccount`, and `setaccount` RPCs,\n-  which are now deprecated. There is no change in behavior between the\n-  new RPCs and deprecated RPCs.\n-- Wallet `listreceivedbylabel`, `listreceivedbyaccount` and `listunspent` RPCs\n-  add `label` fields to returned JSON objects that previously only had\n-  `account` fields.\n - `sendmany` now shuffles outputs to improve privacy, so any previously expected behavior with regards to output ordering can no longer be relied upon.\n+- The new RPC `testmempoolaccept` can be used to test acceptance of a transaction to the mempool without adding it.\n+- JSON transaction decomposition now includes a `weight` field which provides\n+  the transaction's exact weight. This is included in REST /rest/tx/ and\n+  /rest/block/ endpoints when in json mode. This is also included in `getblock`\n+  (with verbosity=2), `listsinceblock`, `listtransactions`, and\n+  `getrawtransaction` RPC commands.\n+- New `fees` field introduced in `getrawmempool`, `getmempoolancestors`, `getmempooldescendants` and\n+   `getmempoolentry` when verbosity is set to `true` with sub-fields `ancestor`, `base`, `modified`\n+   and `descendant` denominated in BTC. This new field deprecates previous fee fields, such as\n+   `fee`, `modifiedfee`, `ancestorfee` and `descendantfee`.\n \n External wallet files\n ---------------------\n@@ -104,11 +104,39 @@ Low-level RPC changes\n   now the empty string `\"\"` instead of `\"wallet.dat\"`. If bitcoin is started\n   with any `-wallet=<path>` options, there is no change in behavior, and the\n   name of any wallet is just its `<path>` string.\n+- Passing an empty string (`\"\"`) as the `address_type` parameter to\n+  `getnewaddress`, `getrawchangeaddress`, `addmultisigaddress`,\n+  `fundrawtransaction` RPCs is now an error. Previously, this would fall back\n+  to using the default address type. It is still possible to pass null or leave\n+  the parameter unset to use the default address type.\n+\n+- Bare multisig outputs to our keys are no longer automatically treated as\n+  incoming payments. As this feature was only available for multisig outputs for\n+  which you had all private keys in your wallet, there was generally no use for\n+  them compared to single-key schemes. Furthermore, no address format for such\n+  outputs is defined, and wallet software can't easily send to it. These outputs\n+  will no longer show up in `listtransactions`, `listunspent`, or contribute to\n+  your balance, unless they are explicitly watched (using `importaddress` or\n+  `importmulti` with hex script argument). `signrawtransaction*` also still\n+  works for them.\n \n ### Logging\n \n - The log timestamp format is now ISO 8601 (e.g. \"2018-02-28T12:34:56Z\").\n \n+Miner block size removed\n+------------------------\n+\n+The `-blockmaxsize` option for miners to limit their blocks' sizes was\n+deprecated in V0.15.1, and has now been removed. Miners should use the\n+`-blockmaxweight` option if they want to limit the weight of their blocks'\n+weights.\n+\n+Python Support\n+--------------\n+\n+Support for Python 2 has been discontinued for all test files and tools.\n+\n Credits\n =======\n "
      },
      {
        "sha": "f0f98b7d12b7e88be27df2a322add0c35c31f07d",
        "filename": "doc/tor.md",
        "status": "modified",
        "additions": 9,
        "deletions": 13,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/doc/tor.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/doc/tor.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/tor.md?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -1,14 +1,12 @@\n-TOR SUPPORT IN BITCOIN\n-======================\n+# TOR SUPPORT IN BITCOIN\n \n It is possible to run Bitcoin as a Tor hidden service, and connect to such services.\n \n The following directions assume you have a Tor proxy running on port 9050. Many distributions default to having a SOCKS proxy listening on port 9050, but others may not. In particular, the Tor Browser Bundle defaults to listening on port 9150. See [Tor Project FAQ:TBBSocksPort](https://www.torproject.org/docs/faq.html.en#TBBSocksPort) for how to properly\n configure Tor.\n \n \n-1. Run bitcoin behind a Tor proxy\n----------------------------------\n+## 1. Run bitcoin behind a Tor proxy\n \n The first step is running Bitcoin behind a Tor proxy. This will already make all\n outgoing connections be anonymized, but more is possible.\n@@ -31,15 +29,15 @@ outgoing connections be anonymized, but more is possible.\n \n In a typical situation, this suffices to run behind a Tor proxy:\n \n-\t./bitcoin -proxy=127.0.0.1:9050\n+\t./bitcoind -proxy=127.0.0.1:9050\n \n \n-2. Run a bitcoin hidden server\n-------------------------------\n+## 2. Run a bitcoin hidden server\n \n If you configure your Tor system accordingly, it is possible to make your node also\n reachable from the Tor network. Add these lines to your /etc/tor/torrc (or equivalent\n-config file):\n+config file): *Needed for Tor version 0.2.7.0 and older versions of Tor only. For newer\n+versions of Tor see [Section 3](#3-automatically-listen-on-tor).*\n \n \tHiddenServiceDir /var/lib/tor/bitcoin-service/\n \tHiddenServicePort 8333 127.0.0.1:8333\n@@ -86,10 +84,9 @@ and open port 8333 on your firewall (or use -upnp).\n If you only want to use Tor to reach onion addresses, but not use it as a proxy\n for normal IPv4/IPv6 communication, use:\n \n-\t./bitcoin -onion=127.0.0.1:9050 -externalip=57qr3yd1nyntf5k.onion -discover\n+\t./bitcoind -onion=127.0.0.1:9050 -externalip=57qr3yd1nyntf5k.onion -discover\n \n-3. Automatically listen on Tor\n---------------------------------\n+## 3. Automatically listen on Tor\n \n Starting with Tor version 0.2.7.1 it is possible, through Tor's control socket\n API, to create and destroy 'ephemeral' hidden services programmatically.\n@@ -115,8 +112,7 @@ which has the appropriate permissions. An alternative authentication method is t\n of the `-torpassword` flag and a `hash-password` which can be enabled and specified in \n Tor configuration.\n \n-4. Privacy recommendations\n----------------------------\n+## 4. Privacy recommendations\n \n - Do not add anything but bitcoin ports to the hidden service created in section 2.\n   If you run a web service too, create a new hidden service for that."
      },
      {
        "sha": "e8f0820ca878b16551748d16020bb54022941ded",
        "filename": "share/qt/extract_strings_qt.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/share/qt/extract_strings_qt.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/share/qt/extract_strings_qt.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/qt/extract_strings_qt.py?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -1,12 +1,11 @@\n-#!/usr/bin/env python\n+#!/usr/bin/env python3\n # Copyright (c) 2012-2017 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n '''\n Extract _(\"...\") strings for translation and convert to Qt stringdefs so that\n they can be picked up by Qt linguist.\n '''\n-from __future__ import division,print_function,unicode_literals\n from subprocess import Popen, PIPE\n import operator\n import os"
      },
      {
        "sha": "20d16f0a974f5b6c179b495de0fd3eb1bd6bfce8",
        "filename": "share/rpcauth/README.md",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/share/rpcauth/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/share/rpcauth/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/rpcauth/README.md?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -8,3 +8,7 @@ Create login credentials for a JSON-RPC user.\n Usage:\n \n     ./rpcauth.py <username>\n+\n+in which case the script will generate a password. To specify a custom password do:\n+\n+    ./rpcauth.py <username> <password>"
      },
      {
        "sha": "566c55aba98a096c549bc239853e278c0563462d",
        "filename": "share/rpcauth/rpcauth.py",
        "status": "modified",
        "additions": 31,
        "deletions": 25,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/share/rpcauth/rpcauth.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/share/rpcauth/rpcauth.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/rpcauth/rpcauth.py?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -1,41 +1,47 @@\n-#!/usr/bin/env python\n+#!/usr/bin/env python3\n # Copyright (c) 2015-2017 The Bitcoin Core developers\n-# Distributed under the MIT software license, see the accompanying \n+# Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-import hashlib\n import sys\n import os\n from random import SystemRandom\n import base64\n import hmac\n \n-if len(sys.argv) < 2:\n-    sys.stderr.write('Please include username as an argument.\\n')\n-    sys.exit(0)\n+def generate_salt():\n+    # This uses os.urandom() underneath\n+    cryptogen = SystemRandom()\n \n-username = sys.argv[1]\n+    # Create 16 byte hex salt\n+    salt_sequence = [cryptogen.randrange(256) for _ in range(16)]\n+    return ''.join([format(r, 'x') for r in salt_sequence])\n \n-#This uses os.urandom() underneath\n-cryptogen = SystemRandom()\n+def generate_password():\n+    \"\"\"Create 32 byte b64 password\"\"\"\n+    return base64.urlsafe_b64encode(os.urandom(32)).decode('utf-8')\n \n-#Create 16 byte hex salt\n-salt_sequence = [cryptogen.randrange(256) for i in range(16)]\n-hexseq = list(map(hex, salt_sequence))\n-salt = \"\".join([x[2:] for x in hexseq])\n+def password_to_hmac(salt, password):\n+    m = hmac.new(bytearray(salt, 'utf-8'), bytearray(password, 'utf-8'), 'SHA256')\n+    return m.hexdigest()\n \n-#Create 32 byte b64 password\n-password = base64.urlsafe_b64encode(os.urandom(32))\n+def main():\n+    if len(sys.argv) < 2:\n+        sys.stderr.write('Please include username (and an optional password, will generate one if not provided) as an argument.\\n')\n+        sys.exit(0)\n \n-digestmod = hashlib.sha256\n+    username = sys.argv[1]\n \n-if sys.version_info.major >= 3:\n-    password = password.decode('utf-8')\n-    digestmod = 'SHA256'\n- \n-m = hmac.new(bytearray(salt, 'utf-8'), bytearray(password, 'utf-8'), digestmod)\n-result = m.hexdigest()\n+    salt = generate_salt()\n+    if len(sys.argv) > 2:\n+        password = sys.argv[2]\n+    else:\n+        password = generate_password()\n+    password_hmac = password_to_hmac(salt, password)\n \n-print(\"String to be appended to bitcoin.conf:\")\n-print(\"rpcauth=\"+username+\":\"+salt+\"$\"+result)\n-print(\"Your password:\\n\"+password)\n+    print('String to be appended to bitcoin.conf:')\n+    print('rpcauth={0}:{1}${2}'.format(username, salt, password_hmac))\n+    print('Your password:\\n{0}'.format(password))\n+\n+if __name__ == '__main__':\n+    main()"
      },
      {
        "sha": "9fee9b42e00156616ed393c22235beb1c54ef972",
        "filename": "share/setup.nsi.in",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/share/setup.nsi.in",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/share/setup.nsi.in",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/setup.nsi.in?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -20,7 +20,8 @@ SetCompressor /SOLID lzma\n !define MUI_STARTMENUPAGE_REGISTRY_KEY ${REGKEY}\n !define MUI_STARTMENUPAGE_REGISTRY_VALUENAME StartMenuGroup\n !define MUI_STARTMENUPAGE_DEFAULTFOLDER \"@PACKAGE_NAME@\"\n-!define MUI_FINISHPAGE_RUN $INSTDIR\\@BITCOIN_GUI_NAME@@EXEEXT@\n+!define MUI_FINISHPAGE_RUN \"$WINDIR\\explorer.exe\"\n+!define MUI_FINISHPAGE_RUN_PARAMETERS $INSTDIR\\@BITCOIN_GUI_NAME@@EXEEXT@\n !define MUI_UNICON \"${NSISDIR}\\Contrib\\Graphics\\Icons\\modern-uninstall.ico\"\n !define MUI_UNWELCOMEFINISHPAGE_BITMAP \"@abs_top_srcdir@/share/pixmaps/nsis-wizard.bmp\"\n !define MUI_UNFINISHPAGE_NOAUTOCLOSE"
      },
      {
        "sha": "38e19edf2c4713bc5874c13508ffdf0992fd3120",
        "filename": "src/.clang-format",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/.clang-format",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/.clang-format",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/.clang-format?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -12,7 +12,10 @@ AlwaysBreakBeforeMultilineStrings: false\n AlwaysBreakTemplateDeclarations: true\n BinPackParameters: false\n BreakBeforeBinaryOperators: false\n-BreakBeforeBraces: Linux\n+BreakBeforeBraces: Custom\n+BraceWrapping:\n+  AfterClass: true\n+  AfterFunction: true\n BreakBeforeTernaryOperators: false\n BreakConstructorInitializersBeforeComma: false\n ColumnLimit:     0"
      },
      {
        "sha": "04bd75a2a5ed9bd659d1d24f30344bff5b091c46",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 15,
        "deletions": 5,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -4,9 +4,10 @@\n \n DIST_SUBDIRS = secp256k1 univalue\n \n-AM_LDFLAGS = $(PTHREAD_CFLAGS) $(LIBTOOL_LDFLAGS) $(HARDENED_LDFLAGS) $(GPROF_LDFLAGS)\n-AM_CXXFLAGS = $(HARDENED_CXXFLAGS) $(ERROR_CXXFLAGS) $(GPROF_CXXFLAGS)\n+AM_LDFLAGS = $(PTHREAD_CFLAGS) $(LIBTOOL_LDFLAGS) $(HARDENED_LDFLAGS) $(GPROF_LDFLAGS) $(SANITIZER_LDFLAGS)\n+AM_CXXFLAGS = $(HARDENED_CXXFLAGS) $(ERROR_CXXFLAGS) $(GPROF_CXXFLAGS) $(SANITIZER_CXXFLAGS)\n AM_CPPFLAGS = $(HARDENED_CPPFLAGS)\n+AM_LIBTOOLFLAGS = --preserve-dup-deps\n EXTRA_LIBRARIES =\n \n if EMBEDDED_UNIVALUE\n@@ -102,13 +103,18 @@ BITCOIN_CORE_H = \\\n   fs.h \\\n   httprpc.h \\\n   httpserver.h \\\n+  index/txindex.h \\\n   indirectmap.h \\\n   init.h \\\n+  interfaces/handler.h \\\n+  interfaces/node.h \\\n+  interfaces/wallet.h \\\n   key.h \\\n   key_io.h \\\n   keystore.h \\\n   dbwrapper.h \\\n   limitedmap.h \\\n+  logging.h \\\n   memusage.h \\\n   merkleblock.h \\\n   miner.h \\\n@@ -131,7 +137,6 @@ BITCOIN_CORE_H = \\\n   rpc/client.h \\\n   rpc/mining.h \\\n   rpc/protocol.h \\\n-  rpc/safemode.h \\\n   rpc/server.h \\\n   rpc/rawtransaction.h \\\n   rpc/register.h \\\n@@ -162,12 +167,12 @@ BITCOIN_CORE_H = \\\n   validation.h \\\n   validationinterface.h \\\n   versionbits.h \\\n+  walletinitinterface.h \\\n   wallet/coincontrol.h \\\n   wallet/crypter.h \\\n   wallet/db.h \\\n   wallet/feebumper.h \\\n   wallet/fees.h \\\n-  wallet/init.h \\\n   wallet/rpcwallet.h \\\n   wallet/wallet.h \\\n   wallet/walletdb.h \\\n@@ -199,6 +204,7 @@ libbitcoin_server_a_SOURCES = \\\n   consensus/tx_verify.cpp \\\n   httprpc.cpp \\\n   httpserver.cpp \\\n+  index/txindex.cpp \\\n   init.cpp \\\n   dbwrapper.cpp \\\n   merkleblock.cpp \\\n@@ -216,7 +222,6 @@ libbitcoin_server_a_SOURCES = \\\n   rpc/misc.cpp \\\n   rpc/net.cpp \\\n   rpc/rawtransaction.cpp \\\n-  rpc/safemode.cpp \\\n   rpc/server.cpp \\\n   script/sigcache.cpp \\\n   timedata.cpp \\\n@@ -244,6 +249,7 @@ endif\n libbitcoin_wallet_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n libbitcoin_wallet_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libbitcoin_wallet_a_SOURCES = \\\n+  interfaces/wallet.cpp \\\n   wallet/crypter.cpp \\\n   wallet/db.cpp \\\n   wallet/feebumper.cpp \\\n@@ -311,6 +317,7 @@ libbitcoin_consensus_a_SOURCES = \\\n   script/script_error.cpp \\\n   script/script_error.h \\\n   serialize.h \\\n+  span.h \\\n   tinyformat.h \\\n   uint256.cpp \\\n   uint256.h \\\n@@ -356,6 +363,9 @@ libbitcoin_util_a_SOURCES = \\\n   compat/glibcxx_sanity.cpp \\\n   compat/strnlen.cpp \\\n   fs.cpp \\\n+  interfaces/handler.cpp \\\n+  interfaces/node.cpp \\\n+  logging.cpp \\\n   random.cpp \\\n   rpc/protocol.cpp \\\n   rpc/util.cpp \\"
      },
      {
        "sha": "3306dcf598e1681e26fb3b7901a4a46c9377eaa2",
        "filename": "src/Makefile.bench.include",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/Makefile.bench.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/Makefile.bench.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.bench.include?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -25,8 +25,6 @@ bench_bench_bitcoin_SOURCES = \\\n   bench/verify_script.cpp \\\n   bench/base58.cpp \\\n   bench/lockedpool.cpp \\\n-  bench/perf.cpp \\\n-  bench/perf.h \\\n   bench/prevector.cpp\n \n nodist_bench_bench_bitcoin_SOURCES = $(GENERATED_BENCH_FILES)"
      },
      {
        "sha": "38eb12ce0d463eb65d822052901228d9ed9e1da6",
        "filename": "src/Makefile.qt.include",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/Makefile.qt.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/Makefile.qt.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qt.include?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -402,7 +402,7 @@ if TARGET_WINDOWS\n endif\n qt_bitcoin_qt_LDADD = qt/libbitcoinqt.a $(LIBBITCOIN_SERVER)\n if ENABLE_WALLET\n-qt_bitcoin_qt_LDADD += $(LIBBITCOIN_WALLET)\n+qt_bitcoin_qt_LDADD += $(LIBBITCOIN_UTIL) $(LIBBITCOIN_WALLET)\n endif\n if ENABLE_ZMQ\n qt_bitcoin_qt_LDADD += $(LIBBITCOIN_ZMQ) $(ZMQ_LIBS)\n@@ -411,7 +411,7 @@ qt_bitcoin_qt_LDADD += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL)\n   $(BOOST_LIBS) $(QT_LIBS) $(QT_DBUS_LIBS) $(QR_LIBS) $(PROTOBUF_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(LIBSECP256K1) \\\n   $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS)\n qt_bitcoin_qt_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(QT_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n-qt_bitcoin_qt_LIBTOOLFLAGS = --tag CXX\n+qt_bitcoin_qt_LIBTOOLFLAGS = $(AM_LIBTOOLFLAGS) --tag CXX\n \n #locale/foo.ts -> locale/foo.qm\n QT_QM=$(QT_TS:.ts=.qm)"
      },
      {
        "sha": "4b14212b2ebaf1d1595a959b94e55c5f46d5a8b7",
        "filename": "src/Makefile.qttest.include",
        "status": "modified",
        "additions": 6,
        "deletions": 1,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/Makefile.qttest.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/Makefile.qttest.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qttest.include?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -12,14 +12,17 @@ TEST_QT_MOC_CPP = \\\n \n if ENABLE_WALLET\n TEST_QT_MOC_CPP += \\\n+  qt/test/moc_addressbooktests.cpp \\\n   qt/test/moc_paymentservertests.cpp \\\n   qt/test/moc_wallettests.cpp\n endif\n \n TEST_QT_H = \\\n+  qt/test/addressbooktests.h \\\n   qt/test/compattests.h \\\n   qt/test/rpcnestedtests.h \\\n   qt/test/uritests.h \\\n+  qt/test/util.h \\\n   qt/test/paymentrequestdata.h \\\n   qt/test/paymentservertests.h \\\n   qt/test/wallettests.h\n@@ -38,11 +41,13 @@ qt_test_test_bitcoin_qt_SOURCES = \\\n   qt/test/rpcnestedtests.cpp \\\n   qt/test/test_main.cpp \\\n   qt/test/uritests.cpp \\\n+  qt/test/util.cpp \\\n   $(TEST_QT_H) \\\n   $(TEST_BITCOIN_CPP) \\\n   $(TEST_BITCOIN_H)\n if ENABLE_WALLET\n qt_test_test_bitcoin_qt_SOURCES += \\\n+  qt/test/addressbooktests.cpp \\\n   qt/test/paymentservertests.cpp \\\n   qt/test/wallettests.cpp \\\n   wallet/test/wallet_test_fixture.cpp\n@@ -52,7 +57,7 @@ nodist_qt_test_test_bitcoin_qt_SOURCES = $(TEST_QT_MOC_CPP)\n \n qt_test_test_bitcoin_qt_LDADD = $(LIBBITCOINQT) $(LIBBITCOIN_SERVER)\n if ENABLE_WALLET\n-qt_test_test_bitcoin_qt_LDADD += $(LIBBITCOIN_WALLET)\n+qt_test_test_bitcoin_qt_LDADD += $(LIBBITCOIN_UTIL) $(LIBBITCOIN_WALLET)\n endif\n if ENABLE_ZMQ\n qt_test_test_bitcoin_qt_LDADD += $(LIBBITCOIN_ZMQ) $(ZMQ_LIBS)"
      },
      {
        "sha": "91d3a3d47c9c13be560fc6d030e5f1a3653b9529",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 19,
        "deletions": 9,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -2,7 +2,6 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-TESTS += test/test_bitcoin\n bin_PROGRAMS += test/test_bitcoin\n noinst_PROGRAMS += test/test_bitcoin_fuzzy\n TEST_SRCDIR = test\n@@ -21,6 +20,11 @@ RAW_TEST_FILES =\n \n GENERATED_TEST_FILES = $(JSON_TEST_FILES:.json=.json.h) $(RAW_TEST_FILES:.raw=.raw.h)\n \n+BITCOIN_TEST_SUITE = \\\n+  test/test_bitcoin_main.cpp \\\n+  test/test_bitcoin.h \\\n+  test/test_bitcoin.cpp\n+\n # test_bitcoin binary #\n BITCOIN_TESTS =\\\n   test/arith_uint256_tests.cpp \\\n@@ -76,12 +80,10 @@ BITCOIN_TESTS =\\\n   test/sigopcount_tests.cpp \\\n   test/skiplist_tests.cpp \\\n   test/streams_tests.cpp \\\n-  test/test_bitcoin.cpp \\\n-  test/test_bitcoin.h \\\n-  test/test_bitcoin_main.cpp \\\n   test/timedata_tests.cpp \\\n   test/torcontrol_tests.cpp \\\n   test/transaction_tests.cpp \\\n+  test/txindex_tests.cpp \\\n   test/txvalidation_tests.cpp \\\n   test/txvalidationcache_tests.cpp \\\n   test/versionbits_tests.cpp \\\n@@ -90,15 +92,17 @@ BITCOIN_TESTS =\\\n \n if ENABLE_WALLET\n BITCOIN_TESTS += \\\n-  wallet/test/wallet_test_fixture.cpp \\\n-  wallet/test/wallet_test_fixture.h \\\n   wallet/test/accounting_tests.cpp \\\n   wallet/test/wallet_tests.cpp \\\n-  wallet/test/crypto_tests.cpp \\\n+  wallet/test/wallet_crypto_tests.cpp \\\n   wallet/test/coinselector_tests.cpp\n+\n+BITCOIN_TEST_SUITE += \\\n+  wallet/test/wallet_test_fixture.cpp \\\n+  wallet/test/wallet_test_fixture.h\n endif\n \n-test_test_bitcoin_SOURCES = $(BITCOIN_TESTS) $(JSON_TEST_FILES) $(RAW_TEST_FILES)\n+test_test_bitcoin_SOURCES = $(BITCOIN_TEST_SUITE) $(BITCOIN_TESTS) $(JSON_TEST_FILES) $(RAW_TEST_FILES)\n test_test_bitcoin_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(TESTDEFS) $(EVENT_CFLAGS)\n test_test_bitcoin_LDADD =\n if ENABLE_WALLET\n@@ -150,14 +154,20 @@ bitcoin_test_check: $(TEST_BINARY) FORCE\n bitcoin_test_clean : FORCE\n \trm -f $(CLEAN_BITCOIN_TEST) $(test_test_bitcoin_OBJECTS) $(TEST_BINARY)\n \n-check-local:\n+check-local: $(BITCOIN_TESTS:.cpp=.cpp.test)\n \t@echo \"Running test/util/bitcoin-util-test.py...\"\n \t$(PYTHON) $(top_builddir)/test/util/bitcoin-util-test.py\n+\t@echo \"Running test/util/rpcauth-test.py...\"\n+\t$(PYTHON) $(top_builddir)/test/util/rpcauth-test.py\n \t$(AM_V_at)$(MAKE) $(AM_MAKEFLAGS) -C secp256k1 check\n if EMBEDDED_UNIVALUE\n \t$(AM_V_at)$(MAKE) $(AM_MAKEFLAGS) -C univalue check\n endif\n \n+%.cpp.test: %.cpp\n+\t@echo Running tests: `cat $< | grep \"BOOST_FIXTURE_TEST_SUITE(\\|BOOST_AUTO_TEST_SUITE(\" | cut -d '(' -f 2 | cut -d ',' -f 1 | cut -d ')' -f 1` from $<\n+\t$(AM_V_at)$(TEST_BINARY) -l test_suite -t \"`cat $< | grep \"BOOST_FIXTURE_TEST_SUITE(\\|BOOST_AUTO_TEST_SUITE(\" | cut -d '(' -f 2 | cut -d ',' -f 1 | cut -d ')' -f 1`\" > $<.log 2>&1 || (cat $<.log && false)\n+\n %.json.h: %.json\n \t@$(MKDIR_P) $(@D)\n \t@{ \\"
      },
      {
        "sha": "59305ff187da17442a6021f9663502cf11c1aa5b",
        "filename": "src/addrdb.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/addrdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/addrdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrdb.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -22,8 +22,8 @@ bool SerializeDB(Stream& stream, const Data& data)\n     // Write and commit header, data\n     try {\n         CHashWriter hasher(SER_DISK, CLIENT_VERSION);\n-        stream << FLATDATA(Params().MessageStart()) << data;\n-        hasher << FLATDATA(Params().MessageStart()) << data;\n+        stream << Params().MessageStart() << data;\n+        hasher << Params().MessageStart() << data;\n         stream << hasher.GetHash();\n     } catch (const std::exception& e) {\n         return error(\"%s: Serialize or I/O error - %s\", __func__, e.what());\n@@ -49,7 +49,8 @@ bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data\n \n     // Serialize\n     if (!SerializeDB(fileout, data)) return false;\n-    FileCommit(fileout.Get());\n+    if (!FileCommit(fileout.Get()))\n+        return error(\"%s: Failed to flush file %s\", __func__, pathTmp.string());\n     fileout.fclose();\n \n     // replace existing file, if any, with new file\n@@ -66,7 +67,7 @@ bool DeserializeDB(Stream& stream, Data& data, bool fCheckSum = true)\n         CHashVerifier<Stream> verifier(&stream);\n         // de-serialize file header (network specific magic number) and ..\n         unsigned char pchMsgTmp[4];\n-        verifier >> FLATDATA(pchMsgTmp);\n+        verifier >> pchMsgTmp;\n         // ... verify the network matches ours\n         if (memcmp(pchMsgTmp, Params().MessageStart(), sizeof(pchMsgTmp)))\n             return error(\"%s: Invalid network magic number\", __func__);"
      },
      {
        "sha": "a36f7ea1002c80637e799c059f97f3a8b8873446",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -59,7 +59,7 @@ class CAddrInfo : public CAddress\n \n     template <typename Stream, typename Operation>\n     inline void SerializationOp(Stream& s, Operation ser_action) {\n-        READWRITE(*static_cast<CAddress*>(this));\n+        READWRITEAS(CAddress, *this);\n         READWRITE(source);\n         READWRITE(nLastSuccess);\n         READWRITE(nAttempts);"
      },
      {
        "sha": "c7ddb17eb0c41173a00dc51b9236ae5fd59c710d",
        "filename": "src/arith_uint256.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/arith_uint256.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/arith_uint256.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/arith_uint256.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -69,16 +69,16 @@ base_uint<BITS>& base_uint<BITS>::operator*=(uint32_t b32)\n template <unsigned int BITS>\n base_uint<BITS>& base_uint<BITS>::operator*=(const base_uint& b)\n {\n-    base_uint<BITS> a = *this;\n-    *this = 0;\n+    base_uint<BITS> a;\n     for (int j = 0; j < WIDTH; j++) {\n         uint64_t carry = 0;\n         for (int i = 0; i + j < WIDTH; i++) {\n-            uint64_t n = carry + pn[i + j] + (uint64_t)a.pn[j] * b.pn[i];\n-            pn[i + j] = n & 0xffffffff;\n+            uint64_t n = carry + a.pn[i + j] + (uint64_t)pn[j] * b.pn[i];\n+            a.pn[i + j] = n & 0xffffffff;\n             carry = n >> 32;\n         }\n     }\n+    *this = a;\n     return *this;\n }\n "
      },
      {
        "sha": "2e2823e974ef81b92859c6c02a778c2f1916f4a7",
        "filename": "src/bech32.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/bech32.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/bech32.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bech32.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -9,6 +9,9 @@\n //\n // For more information, see BIP 173.\n \n+#ifndef BITCOIN_BECH32_H\n+#define BITCOIN_BECH32_H\n+\n #include <stdint.h>\n #include <string>\n #include <vector>\n@@ -23,3 +26,5 @@ std::string Encode(const std::string& hrp, const std::vector<uint8_t>& values);\n std::pair<std::string, std::vector<uint8_t>> Decode(const std::string& str);\n \n } // namespace bech32\n+\n+#endif // BITCOIN_BECH32_H"
      },
      {
        "sha": "de3e57b04fa127bed0a5be5cfe34b759c7636fbe",
        "filename": "src/bench/bench.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/bench/bench.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/bench/bench.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -3,7 +3,6 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <bench/bench.h>\n-#include <bench/perf.h>\n \n #include <assert.h>\n #include <iostream>\n@@ -96,7 +95,6 @@ benchmark::BenchRunner::BenchRunner(std::string name, benchmark::BenchFunction f\n \n void benchmark::BenchRunner::RunAll(Printer& printer, uint64_t num_evals, double scaling, const std::string& filter, bool is_list_only)\n {\n-    perf_init();\n     if (!std::ratio_less_equal<benchmark::clock::period, std::micro>::value) {\n         std::cerr << \"WARNING: Clock precision is worse than microsecond - benchmarks may be less accurate!\\n\";\n     }\n@@ -126,8 +124,6 @@ void benchmark::BenchRunner::RunAll(Printer& printer, uint64_t num_evals, double\n     }\n \n     printer.footer();\n-\n-    perf_fini();\n }\n \n bool benchmark::State::UpdateTimer(const benchmark::time_point current_time)"
      },
      {
        "sha": "81648f534cae9ad1da95aabbc534857af1f23b5a",
        "filename": "src/bench/bench_bitcoin.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 12,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/bench/bench_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/bench/bench_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench_bitcoin.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -22,22 +22,27 @@ static const char* DEFAULT_PLOT_PLOTLYURL = \"https://cdn.plot.ly/plotly-latest.m\n static const int64_t DEFAULT_PLOT_WIDTH = 1024;\n static const int64_t DEFAULT_PLOT_HEIGHT = 768;\n \n+static void SetupBenchArgs()\n+{\n+    gArgs.AddArg(\"-?\", _(\"Print this help message and exit\"), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-list\", _(\"List benchmarks without executing them. Can be combined with -scaling and -filter\"), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-evals=<n>\", strprintf(_(\"Number of measurement evaluations to perform. (default: %u)\"), DEFAULT_BENCH_EVALUATIONS), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-filter=<regex>\", strprintf(_(\"Regular expression filter to select benchmark by name (default: %s)\"), DEFAULT_BENCH_FILTER), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-scaling=<n>\", strprintf(_(\"Scaling factor for benchmark's runtime (default: %u)\"), DEFAULT_BENCH_SCALING), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-printer=(console|plot)\", strprintf(_(\"Choose printer format. console: print data to console. plot: Print results as HTML graph (default: %s)\"), DEFAULT_BENCH_PRINTER), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-plot-plotlyurl=<uri>\", strprintf(_(\"URL to use for plotly.js (default: %s)\"), DEFAULT_PLOT_PLOTLYURL), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-plot-width=<x>\", strprintf(_(\"Plot width in pixel (default: %u)\"), DEFAULT_PLOT_WIDTH), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-plot-height=<x>\", strprintf(_(\"Plot height in pixel (default: %u)\"), DEFAULT_PLOT_HEIGHT), false, OptionsCategory::OPTIONS);\n+}\n+\n int\n main(int argc, char** argv)\n {\n+    SetupBenchArgs();\n     gArgs.ParseParameters(argc, argv);\n \n-    if (gArgs.IsArgSet(\"-?\") || gArgs.IsArgSet(\"-h\") || gArgs.IsArgSet(\"-help\")) {\n-        std::cout << HelpMessageGroup(_(\"Options:\"))\n-                  << HelpMessageOpt(\"-?\", _(\"Print this help message and exit\"))\n-                  << HelpMessageOpt(\"-list\", _(\"List benchmarks without executing them. Can be combined with -scaling and -filter\"))\n-                  << HelpMessageOpt(\"-evals=<n>\", strprintf(_(\"Number of measurement evaluations to perform. (default: %u)\"), DEFAULT_BENCH_EVALUATIONS))\n-                  << HelpMessageOpt(\"-filter=<regex>\", strprintf(_(\"Regular expression filter to select benchmark by name (default: %s)\"), DEFAULT_BENCH_FILTER))\n-                  << HelpMessageOpt(\"-scaling=<n>\", strprintf(_(\"Scaling factor for benchmark's runtime (default: %u)\"), DEFAULT_BENCH_SCALING))\n-                  << HelpMessageOpt(\"-printer=(console|plot)\", strprintf(_(\"Choose printer format. console: print data to console. plot: Print results as HTML graph (default: %s)\"), DEFAULT_BENCH_PRINTER))\n-                  << HelpMessageOpt(\"-plot-plotlyurl=<uri>\", strprintf(_(\"URL to use for plotly.js (default: %s)\"), DEFAULT_PLOT_PLOTLYURL))\n-                  << HelpMessageOpt(\"-plot-width=<x>\", strprintf(_(\"Plot width in pixel (default: %u)\"), DEFAULT_PLOT_WIDTH))\n-                  << HelpMessageOpt(\"-plot-height=<x>\", strprintf(_(\"Plot height in pixel (default: %u)\"), DEFAULT_PLOT_HEIGHT));\n+    if (HelpRequested(gArgs)) {\n+        std::cout << gArgs.GetHelpMessage();\n \n         return 0;\n     }\n@@ -46,7 +51,6 @@ main(int argc, char** argv)\n     RandomInit();\n     ECC_Start();\n     SetupEnvironment();\n-    fPrintToDebugLog = false; // don't want to write to debug.log file\n \n     int64_t evaluations = gArgs.GetArg(\"-evals\", DEFAULT_BENCH_EVALUATIONS);\n     std::string regex_filter = gArgs.GetArg(\"-filter\", DEFAULT_BENCH_FILTER);"
      },
      {
        "sha": "64ec056c4dae5ea6f2df7613b7be80187862ce78",
        "filename": "src/bench/coin_selection.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/bench/coin_selection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/bench/coin_selection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/coin_selection.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -33,7 +33,7 @@ static void addCoin(const CAmount& nValue, const CWallet& wallet, std::vector<CO\n // (https://github.com/bitcoin/bitcoin/issues/7883#issuecomment-224807484)\n static void CoinSelection(benchmark::State& state)\n {\n-    const CWallet wallet(\"dummy\", CWalletDBWrapper::CreateDummy());\n+    const CWallet wallet(\"dummy\", WalletDatabase::CreateDummy());\n     std::vector<COutput> vCoins;\n     LOCK(wallet.cs_wallet);\n "
      },
      {
        "sha": "4c947a519fcf7161f1e72f2d8d0422a6fa8c3ed5",
        "filename": "src/bench/mempool_eviction.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 11,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/bench/mempool_eviction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/bench/mempool_eviction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/mempool_eviction.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -9,16 +9,16 @@\n #include <list>\n #include <vector>\n \n-static void AddTx(const CTransaction& tx, const CAmount& nFee, CTxMemPool& pool)\n+static void AddTx(const CTransactionRef& tx, const CAmount& nFee, CTxMemPool& pool)\n {\n     int64_t nTime = 0;\n     unsigned int nHeight = 1;\n     bool spendsCoinbase = false;\n     unsigned int sigOpCost = 4;\n     LockPoints lp;\n-    pool.addUnchecked(tx.GetHash(), CTxMemPoolEntry(\n-                                        MakeTransactionRef(tx), nFee, nTime, nHeight,\n-                                        spendsCoinbase, sigOpCost, lp));\n+    pool.addUnchecked(tx->GetHash(), CTxMemPoolEntry(\n+                                         tx, nFee, nTime, nHeight,\n+                                         spendsCoinbase, sigOpCost, lp));\n }\n \n // Right now this is only testing eviction performance in an extremely small\n@@ -29,13 +29,15 @@ static void MempoolEviction(benchmark::State& state)\n     CMutableTransaction tx1 = CMutableTransaction();\n     tx1.vin.resize(1);\n     tx1.vin[0].scriptSig = CScript() << OP_1;\n+    tx1.vin[0].scriptWitness.stack.push_back({1});\n     tx1.vout.resize(1);\n     tx1.vout[0].scriptPubKey = CScript() << OP_1 << OP_EQUAL;\n     tx1.vout[0].nValue = 10 * COIN;\n \n     CMutableTransaction tx2 = CMutableTransaction();\n     tx2.vin.resize(1);\n     tx2.vin[0].scriptSig = CScript() << OP_2;\n+    tx2.vin[0].scriptWitness.stack.push_back({2});\n     tx2.vout.resize(1);\n     tx2.vout[0].scriptPubKey = CScript() << OP_2 << OP_EQUAL;\n     tx2.vout[0].nValue = 10 * COIN;\n@@ -44,6 +46,7 @@ static void MempoolEviction(benchmark::State& state)\n     tx3.vin.resize(1);\n     tx3.vin[0].prevout = COutPoint(tx2.GetHash(), 0);\n     tx3.vin[0].scriptSig = CScript() << OP_2;\n+    tx3.vin[0].scriptWitness.stack.push_back({3});\n     tx3.vout.resize(1);\n     tx3.vout[0].scriptPubKey = CScript() << OP_3 << OP_EQUAL;\n     tx3.vout[0].nValue = 10 * COIN;\n@@ -52,8 +55,10 @@ static void MempoolEviction(benchmark::State& state)\n     tx4.vin.resize(2);\n     tx4.vin[0].prevout.SetNull();\n     tx4.vin[0].scriptSig = CScript() << OP_4;\n+    tx4.vin[0].scriptWitness.stack.push_back({4});\n     tx4.vin[1].prevout.SetNull();\n     tx4.vin[1].scriptSig = CScript() << OP_4;\n+    tx4.vin[1].scriptWitness.stack.push_back({4});\n     tx4.vout.resize(2);\n     tx4.vout[0].scriptPubKey = CScript() << OP_4 << OP_EQUAL;\n     tx4.vout[0].nValue = 10 * COIN;\n@@ -64,8 +69,10 @@ static void MempoolEviction(benchmark::State& state)\n     tx5.vin.resize(2);\n     tx5.vin[0].prevout = COutPoint(tx4.GetHash(), 0);\n     tx5.vin[0].scriptSig = CScript() << OP_4;\n+    tx5.vin[0].scriptWitness.stack.push_back({4});\n     tx5.vin[1].prevout.SetNull();\n     tx5.vin[1].scriptSig = CScript() << OP_5;\n+    tx5.vin[1].scriptWitness.stack.push_back({5});\n     tx5.vout.resize(2);\n     tx5.vout[0].scriptPubKey = CScript() << OP_5 << OP_EQUAL;\n     tx5.vout[0].nValue = 10 * COIN;\n@@ -76,8 +83,10 @@ static void MempoolEviction(benchmark::State& state)\n     tx6.vin.resize(2);\n     tx6.vin[0].prevout = COutPoint(tx4.GetHash(), 1);\n     tx6.vin[0].scriptSig = CScript() << OP_4;\n+    tx6.vin[0].scriptWitness.stack.push_back({4});\n     tx6.vin[1].prevout.SetNull();\n     tx6.vin[1].scriptSig = CScript() << OP_6;\n+    tx6.vin[1].scriptWitness.stack.push_back({6});\n     tx6.vout.resize(2);\n     tx6.vout[0].scriptPubKey = CScript() << OP_6 << OP_EQUAL;\n     tx6.vout[0].nValue = 10 * COIN;\n@@ -88,24 +97,34 @@ static void MempoolEviction(benchmark::State& state)\n     tx7.vin.resize(2);\n     tx7.vin[0].prevout = COutPoint(tx5.GetHash(), 0);\n     tx7.vin[0].scriptSig = CScript() << OP_5;\n+    tx7.vin[0].scriptWitness.stack.push_back({5});\n     tx7.vin[1].prevout = COutPoint(tx6.GetHash(), 0);\n     tx7.vin[1].scriptSig = CScript() << OP_6;\n+    tx7.vin[1].scriptWitness.stack.push_back({6});\n     tx7.vout.resize(2);\n     tx7.vout[0].scriptPubKey = CScript() << OP_7 << OP_EQUAL;\n     tx7.vout[0].nValue = 10 * COIN;\n     tx7.vout[1].scriptPubKey = CScript() << OP_7 << OP_EQUAL;\n     tx7.vout[1].nValue = 10 * COIN;\n \n     CTxMemPool pool;\n+    // Create transaction references outside the \"hot loop\"\n+    const CTransactionRef tx1_r{MakeTransactionRef(tx1)};\n+    const CTransactionRef tx2_r{MakeTransactionRef(tx2)};\n+    const CTransactionRef tx3_r{MakeTransactionRef(tx3)};\n+    const CTransactionRef tx4_r{MakeTransactionRef(tx4)};\n+    const CTransactionRef tx5_r{MakeTransactionRef(tx5)};\n+    const CTransactionRef tx6_r{MakeTransactionRef(tx6)};\n+    const CTransactionRef tx7_r{MakeTransactionRef(tx7)};\n \n     while (state.KeepRunning()) {\n-        AddTx(tx1, 10000LL, pool);\n-        AddTx(tx2, 5000LL, pool);\n-        AddTx(tx3, 20000LL, pool);\n-        AddTx(tx4, 7000LL, pool);\n-        AddTx(tx5, 1000LL, pool);\n-        AddTx(tx6, 1100LL, pool);\n-        AddTx(tx7, 9000LL, pool);\n+        AddTx(tx1_r, 10000LL, pool);\n+        AddTx(tx2_r, 5000LL, pool);\n+        AddTx(tx3_r, 20000LL, pool);\n+        AddTx(tx4_r, 7000LL, pool);\n+        AddTx(tx5_r, 1000LL, pool);\n+        AddTx(tx6_r, 1100LL, pool);\n+        AddTx(tx7_r, 9000LL, pool);\n         pool.TrimToSize(pool.DynamicMemoryUsage() * 3 / 4);\n         pool.TrimToSize(GetVirtualTransactionSize(tx1));\n     }"
      },
      {
        "sha": "f92d08c56ecfe3afd39c1d4a284d5d728696829d",
        "filename": "src/bench/perf.cpp",
        "status": "removed",
        "additions": 0,
        "deletions": 53,
        "changes": 53,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7466a26cab5d66665991433947964a638f5b957e/src/bench/perf.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7466a26cab5d66665991433947964a638f5b957e/src/bench/perf.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/perf.cpp?ref=7466a26cab5d66665991433947964a638f5b957e",
        "patch": "@@ -1,53 +0,0 @@\n-// Copyright (c) 2016-2017 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include <bench/perf.h>\n-\n-#if defined(__i386__) || defined(__x86_64__)\n-\n-/* These architectures support querying the cycle counter\n- * from user space, no need for any syscall overhead.\n- */\n-void perf_init(void) { }\n-void perf_fini(void) { }\n-\n-#elif defined(__linux__)\n-\n-#include <unistd.h>\n-#include <sys/syscall.h>\n-#include <linux/perf_event.h>\n-\n-static int fd = -1;\n-static struct perf_event_attr attr;\n-\n-void perf_init(void)\n-{\n-    attr.type = PERF_TYPE_HARDWARE;\n-    attr.config = PERF_COUNT_HW_CPU_CYCLES;\n-    fd = syscall(__NR_perf_event_open, &attr, 0, -1, -1, 0);\n-}\n-\n-void perf_fini(void)\n-{\n-    if (fd != -1) {\n-        close(fd);\n-    }\n-}\n-\n-uint64_t perf_cpucycles(void)\n-{\n-    uint64_t result = 0;\n-    if (fd == -1 || read(fd, &result, sizeof(result)) < (ssize_t)sizeof(result)) {\n-        return 0;\n-    }\n-    return result;\n-}\n-\n-#else /* Unhandled platform */\n-\n-void perf_init(void) { }\n-void perf_fini(void) { }\n-uint64_t perf_cpucycles(void) { return 0; }\n-\n-#endif"
      },
      {
        "sha": "681bd0c8a27e690580254012ac84d95be955a590",
        "filename": "src/bench/perf.h",
        "status": "removed",
        "additions": 0,
        "deletions": 37,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7466a26cab5d66665991433947964a638f5b957e/src/bench/perf.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7466a26cab5d66665991433947964a638f5b957e/src/bench/perf.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/perf.h?ref=7466a26cab5d66665991433947964a638f5b957e",
        "patch": "@@ -1,37 +0,0 @@\n-// Copyright (c) 2016 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-/** Functions for measurement of CPU cycles */\n-#ifndef H_PERF\n-#define H_PERF\n-\n-#include <stdint.h>\n-\n-#if defined(__i386__)\n-\n-static inline uint64_t perf_cpucycles(void)\n-{\n-    uint64_t x;\n-    __asm__ volatile (\".byte 0x0f, 0x31\" : \"=A\" (x));\n-    return x;\n-}\n-\n-#elif defined(__x86_64__)\n-\n-static inline uint64_t perf_cpucycles(void)\n-{\n-    uint32_t hi, lo;\n-    __asm__ __volatile__ (\"rdtsc\" : \"=a\"(lo), \"=d\"(hi));\n-    return ((uint64_t)lo)|(((uint64_t)hi)<<32);\n-}\n-#else\n-\n-uint64_t perf_cpucycles(void);\n-\n-#endif\n-\n-void perf_init(void);\n-void perf_fini(void);\n-\n-#endif // H_PERF"
      },
      {
        "sha": "3cfad1b2c408cc174a973a20e8687a4c83c3bf47",
        "filename": "src/bench/prevector.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/bench/prevector.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/bench/prevector.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/prevector.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -48,7 +48,7 @@ static void PrevectorClear(benchmark::State& state)\n }\n \n template <typename T>\n-void PrevectorResize(benchmark::State& state)\n+static void PrevectorResize(benchmark::State& state)\n {\n     while (state.KeepRunning()) {\n         prevector<28, T> t0;"
      },
      {
        "sha": "4100519d48b74fa933586ee3b895cd2ef6be2459",
        "filename": "src/bench/verify_script.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/bench/verify_script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/bench/verify_script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/verify_script.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -71,11 +71,11 @@ static void VerifyScriptBench(benchmark::State& state)\n     CScript scriptPubKey = CScript() << witnessversion << ToByteVector(pubkeyHash);\n     CScript scriptSig;\n     CScript witScriptPubkey = CScript() << OP_DUP << OP_HASH160 << ToByteVector(pubkeyHash) << OP_EQUALVERIFY << OP_CHECKSIG;\n-    CTransaction txCredit = BuildCreditingTransaction(scriptPubKey);\n+    const CMutableTransaction& txCredit = BuildCreditingTransaction(scriptPubKey);\n     CMutableTransaction txSpend = BuildSpendingTransaction(scriptSig, txCredit);\n     CScriptWitness& witness = txSpend.vin[0].scriptWitness;\n     witness.stack.emplace_back();\n-    key.Sign(SignatureHash(witScriptPubkey, txSpend, 0, SIGHASH_ALL, txCredit.vout[0].nValue, SIGVERSION_WITNESS_V0), witness.stack.back(), 0);\n+    key.Sign(SignatureHash(witScriptPubkey, txSpend, 0, SIGHASH_ALL, txCredit.vout[0].nValue, SigVersion::WITNESS_V0), witness.stack.back(), 0);\n     witness.stack.back().push_back(static_cast<unsigned char>(SIGHASH_ALL));\n     witness.stack.push_back(ToByteVector(pubkey));\n "
      },
      {
        "sha": "b26b17230599f51dc4ec002c0b7a258e66f65130",
        "filename": "src/bitcoin-cli.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 26,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/bitcoin-cli.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/bitcoin-cli.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-cli.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -15,6 +15,7 @@\n #include <util.h>\n #include <utilstrencodings.h>\n \n+#include <memory>\n #include <stdio.h>\n \n #include <event2/buffer.h>\n@@ -28,29 +29,26 @@ static const int DEFAULT_HTTP_CLIENT_TIMEOUT=900;\n static const bool DEFAULT_NAMED=false;\n static const int CONTINUE_EXECUTION=-1;\n \n-std::string HelpMessageCli()\n+static void SetupCliArgs()\n {\n     const auto defaultBaseParams = CreateBaseChainParams(CBaseChainParams::MAIN);\n     const auto testnetBaseParams = CreateBaseChainParams(CBaseChainParams::TESTNET);\n-    std::string strUsage;\n-    strUsage += HelpMessageGroup(_(\"Options:\"));\n-    strUsage += HelpMessageOpt(\"-?\", _(\"This help message\"));\n-    strUsage += HelpMessageOpt(\"-conf=<file>\", strprintf(_(\"Specify configuration file. Relative paths will be prefixed by datadir location. (default: %s)\"), BITCOIN_CONF_FILENAME));\n-    strUsage += HelpMessageOpt(\"-datadir=<dir>\", _(\"Specify data directory\"));\n-    strUsage += HelpMessageOpt(\"-getinfo\", _(\"Get general information from the remote server. Note that unlike server-side RPC calls, the results of -getinfo is the result of multiple non-atomic requests. Some entries in the result may represent results from different states (e.g. wallet balance may be as of a different block from the chain state reported)\"));\n-    AppendParamsHelpMessages(strUsage);\n-    strUsage += HelpMessageOpt(\"-named\", strprintf(_(\"Pass named instead of positional arguments (default: %s)\"), DEFAULT_NAMED));\n-    strUsage += HelpMessageOpt(\"-rpcclienttimeout=<n>\", strprintf(_(\"Timeout in seconds during HTTP requests, or 0 for no timeout. (default: %d)\"), DEFAULT_HTTP_CLIENT_TIMEOUT));\n-    strUsage += HelpMessageOpt(\"-rpcconnect=<ip>\", strprintf(_(\"Send commands to node running on <ip> (default: %s)\"), DEFAULT_RPCCONNECT));\n-    strUsage += HelpMessageOpt(\"-rpcpassword=<pw>\", _(\"Password for JSON-RPC connections\"));\n-    strUsage += HelpMessageOpt(\"-rpcport=<port>\", strprintf(_(\"Connect to JSON-RPC on <port> (default: %u or testnet: %u)\"), defaultBaseParams->RPCPort(), testnetBaseParams->RPCPort()));\n-    strUsage += HelpMessageOpt(\"-rpcuser=<user>\", _(\"Username for JSON-RPC connections\"));\n-    strUsage += HelpMessageOpt(\"-rpcwait\", _(\"Wait for RPC server to start\"));\n-    strUsage += HelpMessageOpt(\"-rpcwallet=<walletname>\", _(\"Send RPC for non-default wallet on RPC server (needs to exactly match corresponding -wallet option passed to bitcoind)\"));\n-    strUsage += HelpMessageOpt(\"-stdin\", _(\"Read extra arguments from standard input, one per line until EOF/Ctrl-D (recommended for sensitive information such as passphrases).  When combined with -stdinrpcpass, the first line from standard input is used for the RPC password.\"));\n-    strUsage += HelpMessageOpt(\"-stdinrpcpass\", strprintf(_(\"Read RPC password from standard input as a single line.  When combined with -stdin, the first line from standard input is used for the RPC password.\")));\n-\n-    return strUsage;\n+\n+    gArgs.AddArg(\"-?\", _(\"This help message\"), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-conf=<file>\", strprintf(_(\"Specify configuration file. Relative paths will be prefixed by datadir location. (default: %s)\"), BITCOIN_CONF_FILENAME), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-datadir=<dir>\", _(\"Specify data directory\"), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-getinfo\", _(\"Get general information from the remote server. Note that unlike server-side RPC calls, the results of -getinfo is the result of multiple non-atomic requests. Some entries in the result may represent results from different states (e.g. wallet balance may be as of a different block from the chain state reported)\"), false, OptionsCategory::OPTIONS);\n+    SetupChainParamsBaseOptions();\n+    gArgs.AddArg(\"-named\", strprintf(_(\"Pass named instead of positional arguments (default: %s)\"), DEFAULT_NAMED), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-rpcclienttimeout=<n>\", strprintf(_(\"Timeout in seconds during HTTP requests, or 0 for no timeout. (default: %d)\"), DEFAULT_HTTP_CLIENT_TIMEOUT), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-rpcconnect=<ip>\", strprintf(_(\"Send commands to node running on <ip> (default: %s)\"), DEFAULT_RPCCONNECT), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-rpcpassword=<pw>\", _(\"Password for JSON-RPC connections\"), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-rpcport=<port>\", strprintf(_(\"Connect to JSON-RPC on <port> (default: %u or testnet: %u)\"), defaultBaseParams->RPCPort(), testnetBaseParams->RPCPort()), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-rpcuser=<user>\", _(\"Username for JSON-RPC connections\"), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-rpcwait\", _(\"Wait for RPC server to start\"), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-rpcwallet=<walletname>\", _(\"Send RPC for non-default wallet on RPC server (needs to exactly match corresponding -wallet option passed to bitcoind)\"), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-stdin\", _(\"Read extra arguments from standard input, one per line until EOF/Ctrl-D (recommended for sensitive information such as passphrases).  When combined with -stdinrpcpass, the first line from standard input is used for the RPC password.\"), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-stdinrpcpass\", strprintf(_(\"Read RPC password from standard input as a single line.  When combined with -stdin, the first line from standard input is used for the RPC password.\")), false, OptionsCategory::OPTIONS);\n }\n \n //////////////////////////////////////////////////////////////////////////////\n@@ -81,8 +79,9 @@ static int AppInitRPC(int argc, char* argv[])\n     //\n     // Parameters\n     //\n+    SetupCliArgs();\n     gArgs.ParseParameters(argc, argv);\n-    if (argc<2 || gArgs.IsArgSet(\"-?\") || gArgs.IsArgSet(\"-h\") || gArgs.IsArgSet(\"-help\") || gArgs.IsArgSet(\"-version\")) {\n+    if (argc < 2 || HelpRequested(gArgs) || gArgs.IsArgSet(\"-version\")) {\n         std::string strUsage = strprintf(_(\"%s RPC client version\"), _(PACKAGE_NAME)) + \" \" + FormatFullVersion() + \"\\n\";\n         if (!gArgs.IsArgSet(\"-version\")) {\n             strUsage += \"\\n\" + _(\"Usage:\") + \"\\n\" +\n@@ -91,7 +90,7 @@ static int AppInitRPC(int argc, char* argv[])\n                   \"  bitcoin-cli [options] help                \" + _(\"List commands\") + \"\\n\" +\n                   \"  bitcoin-cli [options] help <command>      \" + _(\"Get help for a command\") + \"\\n\";\n \n-            strUsage += \"\\n\" + HelpMessageCli();\n+            strUsage += \"\\n\" + gArgs.GetHelpMessage();\n         }\n \n         fprintf(stdout, \"%s\", strUsage.c_str());\n@@ -106,14 +105,14 @@ static int AppInitRPC(int argc, char* argv[])\n         return EXIT_FAILURE;\n     }\n     try {\n-        gArgs.ReadConfigFile(gArgs.GetArg(\"-conf\", BITCOIN_CONF_FILENAME));\n+        gArgs.ReadConfigFiles();\n     } catch (const std::exception& e) {\n         fprintf(stderr,\"Error reading configuration file: %s\\n\", e.what());\n         return EXIT_FAILURE;\n     }\n     // Check for -testnet or -regtest parameter (BaseParams() calls are only valid after this clause)\n     try {\n-        SelectBaseParams(ChainNameFromCommandLine());\n+        SelectBaseParams(gArgs.GetChainName());\n     } catch (const std::exception& e) {\n         fprintf(stderr, \"Error: %s\\n\", e.what());\n         return EXIT_FAILURE;\n@@ -137,7 +136,7 @@ struct HTTPReply\n     std::string body;\n };\n \n-const char *http_errorstring(int code)\n+static const char *http_errorstring(int code)\n {\n     switch(code) {\n #if LIBEVENT_VERSION_NUMBER >= 0x02010300\n@@ -386,7 +385,7 @@ static UniValue CallRPC(BaseRequestHandler *rh, const std::string& strMethod, co\n     return reply;\n }\n \n-int CommandLineRPC(int argc, char *argv[])\n+static int CommandLineRPC(int argc, char *argv[])\n {\n     std::string strPrint;\n     int nRet = 0;"
      },
      {
        "sha": "bf42307df5350a740de348ecae1552a4da6ee854",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 45,
        "deletions": 50,
        "changes": 95,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -22,6 +22,7 @@\n #include <utilmoneystr.h>\n #include <utilstrencodings.h>\n \n+#include <memory>\n #include <stdio.h>\n \n #include <boost/algorithm/string.hpp>\n@@ -30,6 +31,41 @@ static bool fCreateBlank;\n static std::map<std::string,UniValue> registers;\n static const int CONTINUE_EXECUTION=-1;\n \n+static void SetupBitcoinTxArgs()\n+{\n+    gArgs.AddArg(\"-?\", _(\"This help message\"), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-create\", _(\"Create new, empty TX.\"), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-json\", _(\"Select JSON output\"), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-txid\", _(\"Output only the hex-encoded transaction id of the resultant transaction.\"), false, OptionsCategory::OPTIONS);\n+    SetupChainParamsBaseOptions();\n+\n+    gArgs.AddArg(\"delin=N\", _(\"Delete input N from TX\"), false, OptionsCategory::COMMANDS);\n+    gArgs.AddArg(\"delout=N\", _(\"Delete output N from TX\"), false, OptionsCategory::COMMANDS);\n+    gArgs.AddArg(\"in=TXID:VOUT(:SEQUENCE_NUMBER)\", _(\"Add input to TX\"), false, OptionsCategory::COMMANDS);\n+    gArgs.AddArg(\"locktime=N\", _(\"Set TX lock time to N\"), false, OptionsCategory::COMMANDS);\n+    gArgs.AddArg(\"nversion=N\", _(\"Set TX version to N\"), false, OptionsCategory::COMMANDS);\n+    gArgs.AddArg(\"outaddr=VALUE:ADDRESS\", _(\"Add address-based output to TX\"), false, OptionsCategory::COMMANDS);\n+    gArgs.AddArg(\"outdata=[VALUE:]DATA\", _(\"Add data-based output to TX\"), false, OptionsCategory::COMMANDS);\n+    gArgs.AddArg(\"outmultisig=VALUE:REQUIRED:PUBKEYS:PUBKEY1:PUBKEY2:....[:FLAGS]\", _(\"Add Pay To n-of-m Multi-sig output to TX. n = REQUIRED, m = PUBKEYS\") + \". \" +\n+        _(\"Optionally add the \\\"W\\\" flag to produce a pay-to-witness-script-hash output\") + \". \" +\n+        _(\"Optionally add the \\\"S\\\" flag to wrap the output in a pay-to-script-hash.\"), false, OptionsCategory::COMMANDS);\n+    gArgs.AddArg(\"outpubkey=VALUE:PUBKEY[:FLAGS]\", _(\"Add pay-to-pubkey output to TX\") + \". \" +\n+        _(\"Optionally add the \\\"W\\\" flag to produce a pay-to-witness-pubkey-hash output\") + \". \" +\n+        _(\"Optionally add the \\\"S\\\" flag to wrap the output in a pay-to-script-hash.\"), false, OptionsCategory::COMMANDS);\n+    gArgs.AddArg(\"outscript=VALUE:SCRIPT[:FLAGS]\", _(\"Add raw script output to TX\") + \". \" +\n+        _(\"Optionally add the \\\"W\\\" flag to produce a pay-to-witness-script-hash output\") + \". \" +\n+        _(\"Optionally add the \\\"S\\\" flag to wrap the output in a pay-to-script-hash.\"), false, OptionsCategory::COMMANDS);\n+    gArgs.AddArg(\"replaceable(=N)\", _(\"Set RBF opt-in sequence number for input N (if not provided, opt-in all available inputs)\"), false, OptionsCategory::COMMANDS);\n+    gArgs.AddArg(\"sign=SIGHASH-FLAGS\", _(\"Add zero or more signatures to transaction\") + \". \" +\n+        _(\"This command requires JSON registers:\") +\n+        _(\"prevtxs=JSON object\") + \", \" +\n+        _(\"privatekeys=JSON object\") + \". \" +\n+        _(\"See signrawtransaction docs for format of sighash flags, JSON objects.\"), false, OptionsCategory::COMMANDS);\n+\n+    gArgs.AddArg(\"load=NAME:FILENAME\", _(\"Load JSON file FILENAME into register NAME\"), false, OptionsCategory::REGISTER_COMMANDS);\n+    gArgs.AddArg(\"set=NAME:JSON-STRING\", _(\"Set register NAME to given JSON-STRING\"), false, OptionsCategory::REGISTER_COMMANDS);\n+}\n+\n //\n // This function returns either one of EXIT_ codes when it's expected to stop the process or\n // CONTINUE_EXECUTION when it's expected to continue further.\n@@ -39,68 +75,30 @@ static int AppInitRawTx(int argc, char* argv[])\n     //\n     // Parameters\n     //\n+    SetupBitcoinTxArgs();\n     gArgs.ParseParameters(argc, argv);\n \n     // Check for -testnet or -regtest parameter (Params() calls are only valid after this clause)\n     try {\n-        SelectParams(ChainNameFromCommandLine());\n+        SelectParams(gArgs.GetChainName());\n     } catch (const std::exception& e) {\n         fprintf(stderr, \"Error: %s\\n\", e.what());\n         return EXIT_FAILURE;\n     }\n \n     fCreateBlank = gArgs.GetBoolArg(\"-create\", false);\n \n-    if (argc<2 || gArgs.IsArgSet(\"-?\") || gArgs.IsArgSet(\"-h\") || gArgs.IsArgSet(\"-help\"))\n-    {\n+    if (argc < 2 || HelpRequested(gArgs)) {\n         // First part of help message is specific to this utility\n         std::string strUsage = strprintf(_(\"%s bitcoin-tx utility version\"), _(PACKAGE_NAME)) + \" \" + FormatFullVersion() + \"\\n\\n\" +\n             _(\"Usage:\") + \"\\n\" +\n               \"  bitcoin-tx [options] <hex-tx> [commands]  \" + _(\"Update hex-encoded bitcoin transaction\") + \"\\n\" +\n               \"  bitcoin-tx [options] -create [commands]   \" + _(\"Create hex-encoded bitcoin transaction\") + \"\\n\" +\n               \"\\n\";\n+        strUsage += gArgs.GetHelpMessage();\n \n         fprintf(stdout, \"%s\", strUsage.c_str());\n \n-        strUsage = HelpMessageGroup(_(\"Options:\"));\n-        strUsage += HelpMessageOpt(\"-?\", _(\"This help message\"));\n-        strUsage += HelpMessageOpt(\"-create\", _(\"Create new, empty TX.\"));\n-        strUsage += HelpMessageOpt(\"-json\", _(\"Select JSON output\"));\n-        strUsage += HelpMessageOpt(\"-txid\", _(\"Output only the hex-encoded transaction id of the resultant transaction.\"));\n-        AppendParamsHelpMessages(strUsage);\n-\n-        fprintf(stdout, \"%s\", strUsage.c_str());\n-\n-        strUsage = HelpMessageGroup(_(\"Commands:\"));\n-        strUsage += HelpMessageOpt(\"delin=N\", _(\"Delete input N from TX\"));\n-        strUsage += HelpMessageOpt(\"delout=N\", _(\"Delete output N from TX\"));\n-        strUsage += HelpMessageOpt(\"in=TXID:VOUT(:SEQUENCE_NUMBER)\", _(\"Add input to TX\"));\n-        strUsage += HelpMessageOpt(\"locktime=N\", _(\"Set TX lock time to N\"));\n-        strUsage += HelpMessageOpt(\"nversion=N\", _(\"Set TX version to N\"));\n-        strUsage += HelpMessageOpt(\"outaddr=VALUE:ADDRESS\", _(\"Add address-based output to TX\"));\n-        strUsage += HelpMessageOpt(\"outdata=[VALUE:]DATA\", _(\"Add data-based output to TX\"));\n-        strUsage += HelpMessageOpt(\"outmultisig=VALUE:REQUIRED:PUBKEYS:PUBKEY1:PUBKEY2:....[:FLAGS]\", _(\"Add Pay To n-of-m Multi-sig output to TX. n = REQUIRED, m = PUBKEYS\") + \". \" +\n-            _(\"Optionally add the \\\"W\\\" flag to produce a pay-to-witness-script-hash output\") + \". \" +\n-            _(\"Optionally add the \\\"S\\\" flag to wrap the output in a pay-to-script-hash.\"));\n-        strUsage += HelpMessageOpt(\"outpubkey=VALUE:PUBKEY[:FLAGS]\", _(\"Add pay-to-pubkey output to TX\") + \". \" +\n-            _(\"Optionally add the \\\"W\\\" flag to produce a pay-to-witness-pubkey-hash output\") + \". \" +\n-            _(\"Optionally add the \\\"S\\\" flag to wrap the output in a pay-to-script-hash.\"));\n-        strUsage += HelpMessageOpt(\"outscript=VALUE:SCRIPT[:FLAGS]\", _(\"Add raw script output to TX\") + \". \" +\n-            _(\"Optionally add the \\\"W\\\" flag to produce a pay-to-witness-script-hash output\") + \". \" +\n-            _(\"Optionally add the \\\"S\\\" flag to wrap the output in a pay-to-script-hash.\"));\n-        strUsage += HelpMessageOpt(\"replaceable(=N)\", _(\"Set RBF opt-in sequence number for input N (if not provided, opt-in all available inputs)\"));\n-        strUsage += HelpMessageOpt(\"sign=SIGHASH-FLAGS\", _(\"Add zero or more signatures to transaction\") + \". \" +\n-            _(\"This command requires JSON registers:\") +\n-            _(\"prevtxs=JSON object\") + \", \" +\n-            _(\"privatekeys=JSON object\") + \". \" +\n-            _(\"See signrawtransaction docs for format of sighash flags, JSON objects.\"));\n-        fprintf(stdout, \"%s\", strUsage.c_str());\n-\n-        strUsage = HelpMessageGroup(_(\"Register Commands:\"));\n-        strUsage += HelpMessageOpt(\"load=NAME:FILENAME\", _(\"Load JSON file FILENAME into register NAME\"));\n-        strUsage += HelpMessageOpt(\"set=NAME:JSON-STRING\", _(\"Set register NAME to given JSON-STRING\"));\n-        fprintf(stdout, \"%s\", strUsage.c_str());\n-\n         if (argc < 2) {\n             fprintf(stderr, \"Error: too few parameters\\n\");\n             return EXIT_FAILURE;\n@@ -545,12 +543,10 @@ static void MutateTxSign(CMutableTransaction& tx, const std::string& flagStr)\n         if (!findSighashFlags(nHashType, flagStr))\n             throw std::runtime_error(\"unknown sighash flag/sign option\");\n \n-    std::vector<CTransaction> txVariants;\n-    txVariants.push_back(tx);\n-\n     // mergedTx will end up with all the signatures; it\n     // starts as a clone of the raw tx:\n-    CMutableTransaction mergedTx(txVariants[0]);\n+    CMutableTransaction mergedTx{tx};\n+    const CTransaction txv{tx};\n     CCoinsView viewDummy;\n     CCoinsViewCache view(&viewDummy);\n \n@@ -633,7 +629,7 @@ static void MutateTxSign(CMutableTransaction& tx, const std::string& flagStr)\n \n     // Sign what we can:\n     for (unsigned int i = 0; i < mergedTx.vin.size(); i++) {\n-        CTxIn& txin = mergedTx.vin[i];\n+        const CTxIn& txin = mergedTx.vin[i];\n         const Coin& coin = view.AccessCoin(txin.prevout);\n         if (coin.IsSpent()) {\n             continue;\n@@ -644,11 +640,10 @@ static void MutateTxSign(CMutableTransaction& tx, const std::string& flagStr)\n         SignatureData sigdata;\n         // Only sign SIGHASH_SINGLE if there's a corresponding output:\n         if (!fHashSingle || (i < mergedTx.vout.size()))\n-            ProduceSignature(MutableTransactionSignatureCreator(&keystore, &mergedTx, i, amount, nHashType), prevPubKey, sigdata);\n+            ProduceSignature(keystore, MutableTransactionSignatureCreator(&mergedTx, i, amount, nHashType), prevPubKey, sigdata);\n \n         // ... and merge in other signatures:\n-        for (const CTransaction& txv : txVariants)\n-            sigdata = CombineSignatures(prevPubKey, MutableTransactionSignatureChecker(&mergedTx, i, amount), sigdata, DataFromTransaction(txv, i));\n+        sigdata = CombineSignatures(prevPubKey, MutableTransactionSignatureChecker(&mergedTx, i, amount), sigdata, DataFromTransaction(txv, i));\n         UpdateTransaction(mergedTx, i, sigdata);\n     }\n "
      },
      {
        "sha": "1539e4025a16f0b611f81f4e2b86bc0665e09fbe",
        "filename": "src/bitcoind.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 11,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/bitcoind.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/bitcoind.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoind.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -18,6 +18,7 @@\n #include <httpserver.h>\n #include <httprpc.h>\n #include <utilstrencodings.h>\n+#include <walletinitinterface.h>\n \n #include <boost/thread.hpp>\n \n@@ -39,14 +40,11 @@\n  * Use the buttons <code>Namespaces</code>, <code>Classes</code> or <code>Files</code> at the top of the page to start navigating the code.\n  */\n \n-void WaitForShutdown()\n+static void WaitForShutdown()\n {\n-    bool fShutdown = ShutdownRequested();\n-    // Tell the main threads to shutdown.\n-    while (!fShutdown)\n+    while (!ShutdownRequested())\n     {\n         MilliSleep(200);\n-        fShutdown = ShutdownRequested();\n     }\n     Interrupt();\n }\n@@ -55,19 +53,22 @@ void WaitForShutdown()\n //\n // Start\n //\n-bool AppInit(int argc, char* argv[])\n+static bool AppInit(int argc, char* argv[])\n {\n     bool fRet = false;\n \n     //\n     // Parameters\n     //\n     // If Qt is used, parameters/bitcoin.conf are parsed in qt/bitcoin.cpp's main()\n+    SetupServerArgs();\n+#if HAVE_DECL_DAEMON\n+    gArgs.AddArg(\"-daemon\", _(\"Run in the background as a daemon and accept commands\"), false, OptionsCategory::OPTIONS);\n+#endif\n     gArgs.ParseParameters(argc, argv);\n \n     // Process help and version before taking care about datadir\n-    if (gArgs.IsArgSet(\"-?\") || gArgs.IsArgSet(\"-h\") ||  gArgs.IsArgSet(\"-help\") || gArgs.IsArgSet(\"-version\"))\n-    {\n+    if (HelpRequested(gArgs) || gArgs.IsArgSet(\"-version\")) {\n         std::string strUsage = strprintf(_(\"%s Daemon\"), _(PACKAGE_NAME)) + \" \" + _(\"version\") + \" \" + FormatFullVersion() + \"\\n\";\n \n         if (gArgs.IsArgSet(\"-version\"))\n@@ -79,7 +80,7 @@ bool AppInit(int argc, char* argv[])\n             strUsage += \"\\n\" + _(\"Usage:\") + \"\\n\" +\n                   \"  bitcoind [options]                     \" + strprintf(_(\"Start %s Daemon\"), _(PACKAGE_NAME)) + \"\\n\";\n \n-            strUsage += \"\\n\" + HelpMessage(HMM_BITCOIND);\n+            strUsage += \"\\n\" + gArgs.GetHelpMessage();\n         }\n \n         fprintf(stdout, \"%s\", strUsage.c_str());\n@@ -95,14 +96,14 @@ bool AppInit(int argc, char* argv[])\n         }\n         try\n         {\n-            gArgs.ReadConfigFile(gArgs.GetArg(\"-conf\", BITCOIN_CONF_FILENAME));\n+            gArgs.ReadConfigFiles();\n         } catch (const std::exception& e) {\n             fprintf(stderr,\"Error reading configuration file: %s\\n\", e.what());\n             return false;\n         }\n         // Check for -testnet or -regtest parameter (Params() calls are only valid after this clause)\n         try {\n-            SelectParams(ChainNameFromCommandLine());\n+            SelectParams(gArgs.GetChainName());\n         } catch (const std::exception& e) {\n             fprintf(stderr, \"Error: %s\\n\", e.what());\n             return false;\n@@ -139,13 +140,20 @@ bool AppInit(int argc, char* argv[])\n         if (gArgs.GetBoolArg(\"-daemon\", false))\n         {\n #if HAVE_DECL_DAEMON\n+#if defined(MAC_OSX)\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n+#endif\n             fprintf(stdout, \"Bitcoin server starting\\n\");\n \n             // Daemonize\n             if (daemon(1, 0)) { // don't chdir (1), do close FDs (0)\n                 fprintf(stderr, \"Error: daemon() failed: %s\\n\", strerror(errno));\n                 return false;\n             }\n+#if defined(MAC_OSX)\n+#pragma GCC diagnostic pop\n+#endif\n #else\n             fprintf(stderr, \"Error: -daemon is not supported on this operating system\\n\");\n             return false;"
      },
      {
        "sha": "3a0828b307f0eebbc8db041f08cc9a1d53429fd0",
        "filename": "src/blockencodings.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/blockencodings.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/blockencodings.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockencodings.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -2,8 +2,8 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#ifndef BITCOIN_BLOCK_ENCODINGS_H\n-#define BITCOIN_BLOCK_ENCODINGS_H\n+#ifndef BITCOIN_BLOCKENCODINGS_H\n+#define BITCOIN_BLOCKENCODINGS_H\n \n #include <primitives/block.h>\n \n@@ -206,4 +206,4 @@ class PartiallyDownloadedBlock {\n     ReadStatus FillBlock(CBlock& block, const std::vector<CTransactionRef>& vtx_missing);\n };\n \n-#endif\n+#endif // BITCOIN_BLOCKENCODINGS_H"
      },
      {
        "sha": "71762158f021c193a0855ec08682e3702165e2df",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -75,7 +75,7 @@ class CMainParams : public CChainParams {\n     CMainParams() {\n         strNetworkID = \"main\";\n         consensus.nSubsidyHalvingInterval = 210000;\n-        consensus.BIP16Height = 173805; // 00000000000000ce80a7e057163a4db1d5ad7b20fb6f598c9597b9665c8fb0d4 - April 1, 2012\n+        consensus.BIP16Exception = uint256S(\"0x00000000000002dc756eebf4f49723ed8d30cc28a5f108eb94b1ba88ac4f9c22\");\n         consensus.BIP34Height = 227931;\n         consensus.BIP34Hash = uint256S(\"0x000000000000024b89b42a942fe0d9fea3bb44ab7bd1b19115dd6a759c0808b8\");\n         consensus.BIP65Height = 388381; // 000000000000000004c2b624ed5d7756c508d90fd0da2c7c679febfa6c4735f0\n@@ -135,6 +135,7 @@ class CMainParams : public CChainParams {\n         vSeeds.emplace_back(\"seed.bitcoinstats.com\"); // Christian Decker, supports x1 - xf\n         vSeeds.emplace_back(\"seed.bitcoin.jonasschnelli.ch\"); // Jonas Schnelli, only supports x1, x5, x9, and xd\n         vSeeds.emplace_back(\"seed.btc.petertodd.org\"); // Peter Todd, only supports x1, x5, x9, and xd\n+        vSeeds.emplace_back(\"seed.bitcoin.sprovoost.nl\"); // Sjors Provoost\n \n         base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,0);\n         base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,5);\n@@ -172,7 +173,7 @@ class CMainParams : public CChainParams {\n             // Data as of block 0000000000000000002d6cca6761c99b3c2e936f9a0e304b7c7651a993f461de (height 506081).\n             1516903077, // * UNIX timestamp of last known number of transactions\n             295363220,  // * total number of transactions between genesis and that timestamp\n-                        //   (the tx=... number in the SetBestChain debug.log lines)\n+                        //   (the tx=... number in the ChainStateFlushed debug.log lines)\n             3.5         // * estimated number of transactions per second after that timestamp\n         };\n \n@@ -189,7 +190,7 @@ class CTestNetParams : public CChainParams {\n     CTestNetParams() {\n         strNetworkID = \"test\";\n         consensus.nSubsidyHalvingInterval = 210000;\n-        consensus.BIP16Height = 514; // 00000000040b4e986385315e14bee30ad876d8b47f748025b26683116d21aa65\n+        consensus.BIP16Exception = uint256S(\"0x00000000dd30457c001f4095d208cc1296b0eed002427aa599874af7a432b105\");\n         consensus.BIP34Height = 21111;\n         consensus.BIP34Hash = uint256S(\"0x0000000023b3a96d3484e5abb3755c413e7d41500f8e2a5c3f0dd01299cd8ef8\");\n         consensus.BIP65Height = 581885; // 00000000007f6655f22f98e72ed80d8b06dc761d5da09df0fa1dc4be4f861eb6\n@@ -282,7 +283,7 @@ class CRegTestParams : public CChainParams {\n     CRegTestParams() {\n         strNetworkID = \"regtest\";\n         consensus.nSubsidyHalvingInterval = 150;\n-        consensus.BIP16Height = 0; // always enforce P2SH BIP16 on regtest\n+        consensus.BIP16Exception = uint256();\n         consensus.BIP34Height = 100000000; // BIP34 has not activated on regtest (far in the future so block v1 are not rejected in tests)\n         consensus.BIP34Hash = uint256();\n         consensus.BIP65Height = 1351; // BIP65 activated on regtest (Used in rpc activation tests)"
      },
      {
        "sha": "dd029b9d5b8e76bfcbc1fa298fa25d32743cfdc8",
        "filename": "src/chainparams.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/chainparams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/chainparams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -25,6 +25,12 @@ struct CCheckpointData {\n     MapCheckpoints mapCheckpoints;\n };\n \n+/**\n+ * Holds various statistics on transactions within a chain. Used to estimate\n+ * verification progress during chain sync.\n+ *\n+ * See also: CChainParams::TxData, GuessVerificationProgress.\n+ */\n struct ChainTxData {\n     int64_t nTime;\n     int64_t nTxCount;"
      },
      {
        "sha": "91ba3ac9d93b4efca266848570d07c445fe04aec",
        "filename": "src/chainparamsbase.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 21,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/chainparamsbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/chainparamsbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparamsbase.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -14,14 +14,11 @@ const std::string CBaseChainParams::MAIN = \"main\";\n const std::string CBaseChainParams::TESTNET = \"test\";\n const std::string CBaseChainParams::REGTEST = \"regtest\";\n \n-void AppendParamsHelpMessages(std::string& strUsage, bool debugHelp)\n+void SetupChainParamsBaseOptions()\n {\n-    strUsage += HelpMessageGroup(_(\"Chain selection options:\"));\n-    if (debugHelp) {\n-        strUsage += HelpMessageOpt(\"-regtest\", \"Enter regression test mode, which uses a special chain in which blocks can be solved instantly. \"\n-                                   \"This is intended for regression testing tools and app development.\");\n-    }\n-    strUsage += HelpMessageOpt(\"-testnet\", _(\"Use the test chain\"));\n+    gArgs.AddArg(\"-regtest\", \"Enter regression test mode, which uses a special chain in which blocks can be solved instantly. \"\n+                                   \"This is intended for regression testing tools and app development.\", true, OptionsCategory::CHAINPARAMS);\n+    gArgs.AddArg(\"-testnet\", _(\"Use the test chain\"), false, OptionsCategory::CHAINPARAMS);\n }\n \n static std::unique_ptr<CBaseChainParams> globalChainBaseParams;\n@@ -47,18 +44,5 @@ std::unique_ptr<CBaseChainParams> CreateBaseChainParams(const std::string& chain\n void SelectBaseParams(const std::string& chain)\n {\n     globalChainBaseParams = CreateBaseChainParams(chain);\n-}\n-\n-std::string ChainNameFromCommandLine()\n-{\n-    bool fRegTest = gArgs.GetBoolArg(\"-regtest\", false);\n-    bool fTestNet = gArgs.GetBoolArg(\"-testnet\", false);\n-\n-    if (fTestNet && fRegTest)\n-        throw std::runtime_error(\"Invalid combination of -regtest and -testnet.\");\n-    if (fRegTest)\n-        return CBaseChainParams::REGTEST;\n-    if (fTestNet)\n-        return CBaseChainParams::TESTNET;\n-    return CBaseChainParams::MAIN;\n+    gArgs.SelectConfigNetwork(chain);\n }"
      },
      {
        "sha": "9f8bbafcd583aef63c8f306e272bb002a0d7db7c",
        "filename": "src/chainparamsbase.h",
        "status": "modified",
        "additions": 2,
        "deletions": 9,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/chainparamsbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/chainparamsbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparamsbase.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -40,10 +40,9 @@ class CBaseChainParams\n std::unique_ptr<CBaseChainParams> CreateBaseChainParams(const std::string& chain);\n \n /**\n- * Append the help messages for the chainparams options to the\n- * parameter string.\n+ *Set the arguments for chainparams\n  */\n-void AppendParamsHelpMessages(std::string& strUsage, bool debugHelp=true);\n+void SetupChainParamsBaseOptions();\n \n /**\n  * Return the currently selected parameters. This won't change after app\n@@ -54,10 +53,4 @@ const CBaseChainParams& BaseParams();\n /** Sets the params returned by Params() to those for the given network. */\n void SelectBaseParams(const std::string& chain);\n \n-/**\n- * Looks for -regtest, -testnet and returns the appropriate BIP70 chain name.\n- * @return CBaseChainParams::MAX_NETWORK_TYPES if an invalid combination is given. CBaseChainParams::MAIN by default.\n- */\n-std::string ChainNameFromCommandLine();\n-\n #endif // BITCOIN_CHAINPARAMSBASE_H"
      },
      {
        "sha": "920b3f776d166993990fe3b582b5291a916e8798",
        "filename": "src/compat.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/compat.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/compat.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -96,6 +96,12 @@ typedef int32_t ssize_t;\n size_t strnlen( const char *start, size_t max_len);\n #endif // HAVE_DECL_STRNLEN\n \n+#ifndef WIN32\n+typedef void* sockopt_arg_type;\n+#else\n+typedef char* sockopt_arg_type;\n+#endif\n+\n bool static inline IsSelectableSocket(const SOCKET& s) {\n #ifdef WIN32\n     return true;"
      },
      {
        "sha": "4f244c39303da5c008954ddac347e6d075087974",
        "filename": "src/compat/endian.h",
        "status": "modified",
        "additions": 45,
        "deletions": 0,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/compat/endian.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/compat/endian.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat/endian.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -19,6 +19,51 @@\n #include <sys/endian.h>\n #endif\n \n+#ifndef HAVE_CONFIG_H\n+// While not technically a supported configuration, defaulting to defining these\n+// DECLs when we were compiled without autotools makes it easier for other build\n+// systems to build things like libbitcoinconsensus for strange targets.\n+#ifdef htobe16\n+#define HAVE_DECL_HTOBE16 1\n+#endif\n+#ifdef htole16\n+#define HAVE_DECL_HTOLE16 1\n+#endif\n+#ifdef be16toh\n+#define HAVE_DECL_BE16TOH 1\n+#endif\n+#ifdef le16toh\n+#define HAVE_DECL_LE16TOH 1\n+#endif\n+\n+#ifdef htobe32\n+#define HAVE_DECL_HTOBE32 1\n+#endif\n+#ifdef htole32\n+#define HAVE_DECL_HTOLE32 1\n+#endif\n+#ifdef be32toh\n+#define HAVE_DECL_BE32TOH 1\n+#endif\n+#ifdef le32toh\n+#define HAVE_DECL_LE32TOH 1\n+#endif\n+\n+#ifdef htobe64\n+#define HAVE_DECL_HTOBE64 1\n+#endif\n+#ifdef htole64\n+#define HAVE_DECL_HTOLE64 1\n+#endif\n+#ifdef be64toh\n+#define HAVE_DECL_BE64TOH 1\n+#endif\n+#ifdef le64toh\n+#define HAVE_DECL_LE64TOH 1\n+#endif\n+\n+#endif // HAVE_CONFIG_H\n+\n #if defined(WORDS_BIGENDIAN)\n \n #if HAVE_DECL_HTOBE16 == 0"
      },
      {
        "sha": "da639a01af40d840a51557a05d0846d6a6c16e02",
        "filename": "src/compressor.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 11,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/compressor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/compressor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compressor.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -9,7 +9,15 @@\n #include <pubkey.h>\n #include <script/standard.h>\n \n-bool CScriptCompressor::IsToKeyID(CKeyID &hash) const\n+/*\n+ * These check for scripts for which a special case with a shorter encoding is defined.\n+ * They are implemented separately from the CScript test, as these test for exact byte\n+ * sequence correspondences, and are more strict. For example, IsToPubKey also verifies\n+ * whether the public key is valid (as invalid ones cannot be represented in compressed\n+ * form).\n+ */\n+\n+static bool IsToKeyID(const CScript& script, CKeyID &hash)\n {\n     if (script.size() == 25 && script[0] == OP_DUP && script[1] == OP_HASH160\n                             && script[2] == 20 && script[23] == OP_EQUALVERIFY\n@@ -20,7 +28,7 @@ bool CScriptCompressor::IsToKeyID(CKeyID &hash) const\n     return false;\n }\n \n-bool CScriptCompressor::IsToScriptID(CScriptID &hash) const\n+static bool IsToScriptID(const CScript& script, CScriptID &hash)\n {\n     if (script.size() == 23 && script[0] == OP_HASH160 && script[1] == 20\n                             && script[22] == OP_EQUAL) {\n@@ -30,7 +38,7 @@ bool CScriptCompressor::IsToScriptID(CScriptID &hash) const\n     return false;\n }\n \n-bool CScriptCompressor::IsToPubKey(CPubKey &pubkey) const\n+static bool IsToPubKey(const CScript& script, CPubKey &pubkey)\n {\n     if (script.size() == 35 && script[0] == 33 && script[34] == OP_CHECKSIG\n                             && (script[1] == 0x02 || script[1] == 0x03)) {\n@@ -45,24 +53,24 @@ bool CScriptCompressor::IsToPubKey(CPubKey &pubkey) const\n     return false;\n }\n \n-bool CScriptCompressor::Compress(std::vector<unsigned char> &out) const\n+bool CompressScript(const CScript& script, std::vector<unsigned char> &out)\n {\n     CKeyID keyID;\n-    if (IsToKeyID(keyID)) {\n+    if (IsToKeyID(script, keyID)) {\n         out.resize(21);\n         out[0] = 0x00;\n         memcpy(&out[1], &keyID, 20);\n         return true;\n     }\n     CScriptID scriptID;\n-    if (IsToScriptID(scriptID)) {\n+    if (IsToScriptID(script, scriptID)) {\n         out.resize(21);\n         out[0] = 0x01;\n         memcpy(&out[1], &scriptID, 20);\n         return true;\n     }\n     CPubKey pubkey;\n-    if (IsToPubKey(pubkey)) {\n+    if (IsToPubKey(script, pubkey)) {\n         out.resize(33);\n         memcpy(&out[1], &pubkey[1], 32);\n         if (pubkey[0] == 0x02 || pubkey[0] == 0x03) {\n@@ -76,7 +84,7 @@ bool CScriptCompressor::Compress(std::vector<unsigned char> &out) const\n     return false;\n }\n \n-unsigned int CScriptCompressor::GetSpecialSize(unsigned int nSize) const\n+unsigned int GetSpecialScriptSize(unsigned int nSize)\n {\n     if (nSize == 0 || nSize == 1)\n         return 20;\n@@ -85,7 +93,7 @@ unsigned int CScriptCompressor::GetSpecialSize(unsigned int nSize) const\n     return 0;\n }\n \n-bool CScriptCompressor::Decompress(unsigned int nSize, const std::vector<unsigned char> &in)\n+bool DecompressScript(CScript& script, unsigned int nSize, const std::vector<unsigned char> &in)\n {\n     switch(nSize) {\n     case 0x00:\n@@ -139,7 +147,7 @@ bool CScriptCompressor::Decompress(unsigned int nSize, const std::vector<unsigne\n // * if e==9, we only know the resulting number is not zero, so output 1 + 10*(n - 1) + 9\n // (this is decodable, as d is in [1-9] and e is in [0-9])\n \n-uint64_t CTxOutCompressor::CompressAmount(uint64_t n)\n+uint64_t CompressAmount(uint64_t n)\n {\n     if (n == 0)\n         return 0;\n@@ -158,7 +166,7 @@ uint64_t CTxOutCompressor::CompressAmount(uint64_t n)\n     }\n }\n \n-uint64_t CTxOutCompressor::DecompressAmount(uint64_t x)\n+uint64_t DecompressAmount(uint64_t x)\n {\n     // x = 0  OR  x = 1+10*(9*n + d - 1) + e  OR  x = 1+10*(n - 1) + 9\n     if (x == 0)"
      },
      {
        "sha": "6bd68529d41c3f19e6f77c70c9d761383a47d3c6",
        "filename": "src/compressor.h",
        "status": "modified",
        "additions": 15,
        "deletions": 25,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/compressor.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/compressor.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compressor.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -9,11 +9,19 @@\n #include <primitives/transaction.h>\n #include <script/script.h>\n #include <serialize.h>\n+#include <span.h>\n \n class CKeyID;\n class CPubKey;\n class CScriptID;\n \n+bool CompressScript(const CScript& script, std::vector<unsigned char> &out);\n+unsigned int GetSpecialScriptSize(unsigned int nSize);\n+bool DecompressScript(CScript& script, unsigned int nSize, const std::vector<unsigned char> &out);\n+\n+uint64_t CompressAmount(uint64_t nAmount);\n+uint64_t DecompressAmount(uint64_t nAmount);\n+\n /** Compact serializer for scripts.\n  *\n  *  It detects common cases and encodes them much more efficiently.\n@@ -37,44 +45,29 @@ class CScriptCompressor\n     static const unsigned int nSpecialScripts = 6;\n \n     CScript &script;\n-protected:\n-    /**\n-     * These check for scripts for which a special case with a shorter encoding is defined.\n-     * They are implemented separately from the CScript test, as these test for exact byte\n-     * sequence correspondences, and are more strict. For example, IsToPubKey also verifies\n-     * whether the public key is valid (as invalid ones cannot be represented in compressed\n-     * form).\n-     */\n-    bool IsToKeyID(CKeyID &hash) const;\n-    bool IsToScriptID(CScriptID &hash) const;\n-    bool IsToPubKey(CPubKey &pubkey) const;\n-\n-    bool Compress(std::vector<unsigned char> &out) const;\n-    unsigned int GetSpecialSize(unsigned int nSize) const;\n-    bool Decompress(unsigned int nSize, const std::vector<unsigned char> &out);\n public:\n     explicit CScriptCompressor(CScript &scriptIn) : script(scriptIn) { }\n \n     template<typename Stream>\n     void Serialize(Stream &s) const {\n         std::vector<unsigned char> compr;\n-        if (Compress(compr)) {\n-            s << CFlatData(compr);\n+        if (CompressScript(script, compr)) {\n+            s << MakeSpan(compr);\n             return;\n         }\n         unsigned int nSize = script.size() + nSpecialScripts;\n         s << VARINT(nSize);\n-        s << CFlatData(script);\n+        s << MakeSpan(script);\n     }\n \n     template<typename Stream>\n     void Unserialize(Stream &s) {\n         unsigned int nSize = 0;\n         s >> VARINT(nSize);\n         if (nSize < nSpecialScripts) {\n-            std::vector<unsigned char> vch(GetSpecialSize(nSize), 0x00);\n-            s >> CFlatData(vch);\n-            Decompress(nSize, vch);\n+            std::vector<unsigned char> vch(GetSpecialScriptSize(nSize), 0x00);\n+            s >> MakeSpan(vch);\n+            DecompressScript(script, nSize, vch);\n             return;\n         }\n         nSize -= nSpecialScripts;\n@@ -84,7 +77,7 @@ class CScriptCompressor\n             s.ignore(nSize);\n         } else {\n             script.resize(nSize);\n-            s >> CFlatData(script);\n+            s >> MakeSpan(script);\n         }\n     }\n };\n@@ -96,9 +89,6 @@ class CTxOutCompressor\n     CTxOut &txout;\n \n public:\n-    static uint64_t CompressAmount(uint64_t nAmount);\n-    static uint64_t DecompressAmount(uint64_t nAmount);\n-\n     explicit CTxOutCompressor(CTxOut &txoutIn) : txout(txoutIn) { }\n \n     ADD_SERIALIZE_METHODS;"
      },
      {
        "sha": "0afb73adb5c1b8caa07dd2dd2216f4a8203adc09",
        "filename": "src/consensus/merkle.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/consensus/merkle.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/consensus/merkle.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/merkle.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -2,8 +2,8 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#ifndef BITCOIN_MERKLE\n-#define BITCOIN_MERKLE\n+#ifndef BITCOIN_CONSENSUS_MERKLE_H\n+#define BITCOIN_CONSENSUS_MERKLE_H\n \n #include <stdint.h>\n #include <vector>\n@@ -35,4 +35,4 @@ uint256 BlockWitnessMerkleRoot(const CBlock& block, bool* mutated = nullptr);\n  */\n std::vector<uint256> BlockMerkleBranch(const CBlock& block, uint32_t position);\n \n-#endif\n+#endif // BITCOIN_CONSENSUS_MERKLE_H"
      },
      {
        "sha": "0559304fc2d54f36fe620eb326d1c6aab7773b9b",
        "filename": "src/consensus/params.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/consensus/params.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/consensus/params.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/params.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -49,8 +49,8 @@ struct BIP9Deployment {\n struct Params {\n     uint256 hashGenesisBlock;\n     int nSubsidyHalvingInterval;\n-    /** Block height at which BIP16 becomes active */\n-    int BIP16Height;\n+    /* Block hash that is excepted from BIP16 enforcement */\n+    uint256 BIP16Exception;\n     /** Block height and hash at which BIP34 becomes active */\n     int BIP34Height;\n     uint256 BIP34Hash;"
      },
      {
        "sha": "aade7e21ca57af2aef505f7f7a678d6fcda00290",
        "filename": "src/core_read.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/core_read.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/core_read.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_read.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -88,7 +88,7 @@ CScript ParseScript(const std::string& s)\n }\n \n // Check that all of the input and output scripts of a transaction contains valid opcodes\n-bool CheckTxScriptsSanity(const CMutableTransaction& tx)\n+static bool CheckTxScriptsSanity(const CMutableTransaction& tx)\n {\n     // Check input scripts for non-coinbase txs\n     if (!CTransaction(tx).IsCoinBase()) {"
      },
      {
        "sha": "ee6737201bb66cdcdbd8d695a2cd86f67b992725",
        "filename": "src/core_write.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/core_write.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/core_write.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_write.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -34,7 +34,7 @@ std::string FormatScript(const CScript& script)\n     while (it != script.end()) {\n         CScript::const_iterator it2 = it;\n         std::vector<unsigned char> vch;\n-        if (script.GetOp2(it, op, &vch)) {\n+        if (script.GetOp(it, op, vch)) {\n             if (op == OP_0) {\n                 ret += \"0 \";\n                 continue;\n@@ -161,6 +161,7 @@ void TxToUniv(const CTransaction& tx, const uint256& hashBlock, UniValue& entry,\n     entry.pushKV(\"version\", tx.nVersion);\n     entry.pushKV(\"size\", (int)::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION));\n     entry.pushKV(\"vsize\", (GetTransactionWeight(tx) + WITNESS_SCALE_FACTOR - 1) / WITNESS_SCALE_FACTOR);\n+    entry.pushKV(\"weight\", GetTransactionWeight(tx));\n     entry.pushKV(\"locktime\", (int64_t)tx.nLockTime);\n \n     UniValue vin(UniValue::VARR);"
      },
      {
        "sha": "15f687396128169d5554bac860961e1e31a38c2d",
        "filename": "src/cuckoocache.h",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/cuckoocache.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/cuckoocache.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/cuckoocache.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -242,14 +242,14 @@ class cache\n      */\n     inline std::array<uint32_t, 8> compute_hashes(const Element& e) const\n     {\n-        return {{(uint32_t)((hash_function.template operator()<0>(e) * (uint64_t)size) >> 32),\n-                 (uint32_t)((hash_function.template operator()<1>(e) * (uint64_t)size) >> 32),\n-                 (uint32_t)((hash_function.template operator()<2>(e) * (uint64_t)size) >> 32),\n-                 (uint32_t)((hash_function.template operator()<3>(e) * (uint64_t)size) >> 32),\n-                 (uint32_t)((hash_function.template operator()<4>(e) * (uint64_t)size) >> 32),\n-                 (uint32_t)((hash_function.template operator()<5>(e) * (uint64_t)size) >> 32),\n-                 (uint32_t)((hash_function.template operator()<6>(e) * (uint64_t)size) >> 32),\n-                 (uint32_t)((hash_function.template operator()<7>(e) * (uint64_t)size) >> 32)}};\n+        return {{(uint32_t)(((uint64_t)hash_function.template operator()<0>(e) * (uint64_t)size) >> 32),\n+                 (uint32_t)(((uint64_t)hash_function.template operator()<1>(e) * (uint64_t)size) >> 32),\n+                 (uint32_t)(((uint64_t)hash_function.template operator()<2>(e) * (uint64_t)size) >> 32),\n+                 (uint32_t)(((uint64_t)hash_function.template operator()<3>(e) * (uint64_t)size) >> 32),\n+                 (uint32_t)(((uint64_t)hash_function.template operator()<4>(e) * (uint64_t)size) >> 32),\n+                 (uint32_t)(((uint64_t)hash_function.template operator()<5>(e) * (uint64_t)size) >> 32),\n+                 (uint32_t)(((uint64_t)hash_function.template operator()<6>(e) * (uint64_t)size) >> 32),\n+                 (uint32_t)(((uint64_t)hash_function.template operator()<7>(e) * (uint64_t)size) >> 32)}};\n     }\n \n     /* end"
      },
      {
        "sha": "e401b5fb1b5b039bfe6b8a9b44a06d014d2cda34",
        "filename": "src/dbwrapper.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 4,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/dbwrapper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/dbwrapper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/dbwrapper.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -4,6 +4,7 @@\n \n #include <dbwrapper.h>\n \n+#include <memory>\n #include <random.h>\n \n #include <leveldb/cache.h>\n@@ -62,7 +63,7 @@ class CBitcoinLevelDBLogger : public leveldb::Logger {\n \n                 assert(p <= limit);\n                 base[std::min(bufsize - 1, (int)(p - base))] = '\\0';\n-                LogPrintf(\"leveldb: %s\", base);\n+                LogPrintf(\"leveldb: %s\", base);  /* Continued */\n                 if (base != buffer) {\n                     delete[] base;\n                 }\n@@ -71,20 +72,45 @@ class CBitcoinLevelDBLogger : public leveldb::Logger {\n     }\n };\n \n+static void SetMaxOpenFiles(leveldb::Options *options) {\n+    // On most platforms the default setting of max_open_files (which is 1000)\n+    // is optimal. On Windows using a large file count is OK because the handles\n+    // do not interfere with select() loops. On 64-bit Unix hosts this value is\n+    // also OK, because up to that amount LevelDB will use an mmap\n+    // implementation that does not use extra file descriptors (the fds are\n+    // closed after being mmaped).\n+    //\n+    // Increasing the value beyond the default is dangerous because LevelDB will\n+    // fall back to a non-mmap implementation when the file count is too large.\n+    // On 32-bit Unix host we should decrease the value because the handles use\n+    // up real fds, and we want to avoid fd exhaustion issues.\n+    //\n+    // See PR #12495 for further discussion.\n+\n+    int default_open_files = options->max_open_files;\n+#ifndef WIN32\n+    if (sizeof(void*) < 8) {\n+        options->max_open_files = 64;\n+    }\n+#endif\n+    LogPrint(BCLog::LEVELDB, \"LevelDB using max_open_files=%d (default=%d)\\n\",\n+             options->max_open_files, default_open_files);\n+}\n+\n static leveldb::Options GetOptions(size_t nCacheSize)\n {\n     leveldb::Options options;\n     options.block_cache = leveldb::NewLRUCache(nCacheSize / 2);\n     options.write_buffer_size = nCacheSize / 4; // up to two write buffers may be held in memory simultaneously\n     options.filter_policy = leveldb::NewBloomFilterPolicy(10);\n     options.compression = leveldb::kNoCompression;\n-    options.max_open_files = 64;\n     options.info_log = new CBitcoinLevelDBLogger();\n     if (leveldb::kMajorVersion > 1 || (leveldb::kMajorVersion == 1 && leveldb::kMinorVersion >= 16)) {\n         // LevelDB versions before 1.16 consider short writes to be corruption. Only trigger error\n         // on corruption in later versions.\n         options.paranoid_checks = true;\n     }\n+    SetMaxOpenFiles(&options);\n     return options;\n }\n \n@@ -159,12 +185,12 @@ bool CDBWrapper::WriteBatch(CDBBatch& batch, bool fSync)\n     const bool log_memory = LogAcceptCategory(BCLog::LEVELDB);\n     double mem_before = 0;\n     if (log_memory) {\n-        mem_before = DynamicMemoryUsage() / 1024 / 1024;\n+        mem_before = DynamicMemoryUsage() / 1024.0 / 1024;\n     }\n     leveldb::Status status = pdb->Write(fSync ? syncoptions : writeoptions, &batch.batch);\n     dbwrapper_private::HandleError(status);\n     if (log_memory) {\n-        double mem_after = DynamicMemoryUsage() / 1024 / 1024;\n+        double mem_after = DynamicMemoryUsage() / 1024.0 / 1024;\n         LogPrint(BCLog::LEVELDB, \"WriteBatch memory usage: db=%s, before=%.1fMiB, after=%.1fMiB\\n\",\n                  m_name, mem_before, mem_after);\n     }"
      },
      {
        "sha": "2a5e0cab00ced037b191cf0c625cbd83909665af",
        "filename": "src/dbwrapper.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/dbwrapper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/dbwrapper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/dbwrapper.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -224,6 +224,9 @@ class CDBWrapper\n     CDBWrapper(const fs::path& path, size_t nCacheSize, bool fMemory = false, bool fWipe = false, bool obfuscate = false);\n     ~CDBWrapper();\n \n+    CDBWrapper(const CDBWrapper&) = delete;\n+    CDBWrapper& operator=(const CDBWrapper&) = delete;\n+\n     template <typename K, typename V>\n     bool Read(const K& key, V& value) const\n     {"
      },
      {
        "sha": "de2437943e083918e8c5fff9e932d5cc36d2dc2e",
        "filename": "src/httprpc.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/httprpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/httprpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httprpc.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -17,6 +17,8 @@\n #include <crypto/hmac_sha256.h>\n #include <stdio.h>\n \n+#include <memory>\n+\n #include <boost/algorithm/string.hpp> // boost::trim\n \n /** WWW-Authenticate to present with 401 Unauthorized response */\n@@ -158,8 +160,9 @@ static bool HTTPReq_JSONRPC(HTTPRequest* req, const std::string &)\n     }\n \n     JSONRPCRequest jreq;\n+    jreq.peerAddr = req->GetPeer().ToString();\n     if (!RPCAuthorized(authHeader.second, jreq.authUser)) {\n-        LogPrintf(\"ThreadRPCServer incorrect password attempt from %s\\n\", req->GetPeer().ToString());\n+        LogPrintf(\"ThreadRPCServer incorrect password attempt from %s\\n\", jreq.peerAddr);\n \n         /* Deter brute-forcing\n            If this results in a DoS the user really\n@@ -252,6 +255,9 @@ void StopHTTPRPC()\n {\n     LogPrint(BCLog::RPC, \"Stopping HTTP RPC server\\n\");\n     UnregisterHTTPHandler(\"/\", true);\n+#ifdef ENABLE_WALLET\n+    UnregisterHTTPHandler(\"/wallet/\", false);\n+#endif\n     if (httpRPCTimerInterface) {\n         RPCUnsetTimerInterface(httpRPCTimerInterface.get());\n         httpRPCTimerInterface.reset();"
      },
      {
        "sha": "bd08b04c0f4af71c94deffb5595b0987947a5aee",
        "filename": "src/httpserver.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/httpserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/httpserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -13,6 +13,7 @@\n #include <sync.h>\n #include <ui_interface.h>\n \n+#include <memory>\n #include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\n@@ -363,8 +364,8 @@ bool InitHTTPServer()\n     // Update libevent's log handling. Returns false if our version of\n     // libevent doesn't support debug logging, in which case we should\n     // clear the BCLog::LIBEVENT flag.\n-    if (!UpdateHTTPServerLogging(logCategories & BCLog::LIBEVENT)) {\n-        logCategories &= ~BCLog::LIBEVENT;\n+    if (!UpdateHTTPServerLogging(g_logger->WillLogCategory(BCLog::LIBEVENT))) {\n+        g_logger->DisableCategory(BCLog::LIBEVENT);\n     }\n \n #ifdef WIN32"
      },
      {
        "sha": "8132c887b5e280aa7e8cb15aa20a35bebdf59031",
        "filename": "src/httpserver.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/httpserver.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/httpserver.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -32,7 +32,7 @@ void InterruptHTTPServer();\n /** Stop HTTP server */\n void StopHTTPServer();\n \n-/** Change logging level for libevent. Removes BCLog::LIBEVENT from logCategories if\n+/** Change logging level for libevent. Removes BCLog::LIBEVENT from log categories if\n  * libevent doesn't support debug logging.*/\n bool UpdateHTTPServerLogging(bool enable);\n "
      },
      {
        "sha": "5b6e0f99800da28fc8dcb95c11792d57c025174d",
        "filename": "src/index/txindex.cpp",
        "status": "added",
        "additions": 311,
        "deletions": 0,
        "changes": 311,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/index/txindex.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/index/txindex.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/txindex.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -0,0 +1,311 @@\n+// Copyright (c) 2017-2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <index/txindex.h>\n+#include <init.h>\n+#include <tinyformat.h>\n+#include <ui_interface.h>\n+#include <util.h>\n+#include <validation.h>\n+#include <warnings.h>\n+\n+constexpr int64_t SYNC_LOG_INTERVAL = 30; // seconds\n+constexpr int64_t SYNC_LOCATOR_WRITE_INTERVAL = 30; // seconds\n+\n+std::unique_ptr<TxIndex> g_txindex;\n+\n+template<typename... Args>\n+static void FatalError(const char* fmt, const Args&... args)\n+{\n+    std::string strMessage = tfm::format(fmt, args...);\n+    SetMiscWarning(strMessage);\n+    LogPrintf(\"*** %s\\n\", strMessage);\n+    uiInterface.ThreadSafeMessageBox(\n+        \"Error: A fatal internal error occurred, see debug.log for details\",\n+        \"\", CClientUIInterface::MSG_ERROR);\n+    StartShutdown();\n+}\n+\n+TxIndex::TxIndex(std::unique_ptr<TxIndexDB> db) :\n+    m_db(std::move(db)), m_synced(false), m_best_block_index(nullptr)\n+{}\n+\n+TxIndex::~TxIndex()\n+{\n+    Interrupt();\n+    Stop();\n+}\n+\n+bool TxIndex::Init()\n+{\n+    LOCK(cs_main);\n+\n+    // Attempt to migrate txindex from the old database to the new one. Even if\n+    // chain_tip is null, the node could be reindexing and we still want to\n+    // delete txindex records in the old database.\n+    if (!m_db->MigrateData(*pblocktree, chainActive.GetLocator())) {\n+        return false;\n+    }\n+\n+    CBlockLocator locator;\n+    if (!m_db->ReadBestBlock(locator)) {\n+        locator.SetNull();\n+    }\n+\n+    m_best_block_index = FindForkInGlobalIndex(chainActive, locator);\n+    m_synced = m_best_block_index.load() == chainActive.Tip();\n+    return true;\n+}\n+\n+static const CBlockIndex* NextSyncBlock(const CBlockIndex* pindex_prev)\n+{\n+    AssertLockHeld(cs_main);\n+\n+    if (!pindex_prev) {\n+        return chainActive.Genesis();\n+    }\n+\n+    const CBlockIndex* pindex = chainActive.Next(pindex_prev);\n+    if (pindex) {\n+        return pindex;\n+    }\n+\n+    return chainActive.Next(chainActive.FindFork(pindex_prev));\n+}\n+\n+void TxIndex::ThreadSync()\n+{\n+    const CBlockIndex* pindex = m_best_block_index.load();\n+    if (!m_synced) {\n+        auto& consensus_params = Params().GetConsensus();\n+\n+        int64_t last_log_time = 0;\n+        int64_t last_locator_write_time = 0;\n+        while (true) {\n+            if (m_interrupt) {\n+                WriteBestBlock(pindex);\n+                return;\n+            }\n+\n+            {\n+                LOCK(cs_main);\n+                const CBlockIndex* pindex_next = NextSyncBlock(pindex);\n+                if (!pindex_next) {\n+                    WriteBestBlock(pindex);\n+                    m_best_block_index = pindex;\n+                    m_synced = true;\n+                    break;\n+                }\n+                pindex = pindex_next;\n+            }\n+\n+            int64_t current_time = GetTime();\n+            if (last_log_time + SYNC_LOG_INTERVAL < current_time) {\n+                LogPrintf(\"Syncing txindex with block chain from height %d\\n\", pindex->nHeight);\n+                last_log_time = current_time;\n+            }\n+\n+            if (last_locator_write_time + SYNC_LOCATOR_WRITE_INTERVAL < current_time) {\n+                WriteBestBlock(pindex);\n+                last_locator_write_time = current_time;\n+            }\n+\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, pindex, consensus_params)) {\n+                FatalError(\"%s: Failed to read block %s from disk\",\n+                           __func__, pindex->GetBlockHash().ToString());\n+                return;\n+            }\n+            if (!WriteBlock(block, pindex)) {\n+                FatalError(\"%s: Failed to write block %s to tx index database\",\n+                           __func__, pindex->GetBlockHash().ToString());\n+                return;\n+            }\n+        }\n+    }\n+\n+    if (pindex) {\n+        LogPrintf(\"txindex is enabled at height %d\\n\", pindex->nHeight);\n+    } else {\n+        LogPrintf(\"txindex is enabled\\n\");\n+    }\n+}\n+\n+bool TxIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)\n+{\n+    CDiskTxPos pos(pindex->GetBlockPos(), GetSizeOfCompactSize(block.vtx.size()));\n+    std::vector<std::pair<uint256, CDiskTxPos>> vPos;\n+    vPos.reserve(block.vtx.size());\n+    for (const auto& tx : block.vtx) {\n+        vPos.emplace_back(tx->GetHash(), pos);\n+        pos.nTxOffset += ::GetSerializeSize(*tx, SER_DISK, CLIENT_VERSION);\n+    }\n+    return m_db->WriteTxs(vPos);\n+}\n+\n+bool TxIndex::WriteBestBlock(const CBlockIndex* block_index)\n+{\n+    LOCK(cs_main);\n+    if (!m_db->WriteBestBlock(chainActive.GetLocator(block_index))) {\n+        return error(\"%s: Failed to write locator to disk\", __func__);\n+    }\n+    return true;\n+}\n+\n+void TxIndex::BlockConnected(const std::shared_ptr<const CBlock>& block, const CBlockIndex* pindex,\n+                    const std::vector<CTransactionRef>& txn_conflicted)\n+{\n+    if (!m_synced) {\n+        return;\n+    }\n+\n+    const CBlockIndex* best_block_index = m_best_block_index.load();\n+    if (!best_block_index) {\n+        if (pindex->nHeight != 0) {\n+            FatalError(\"%s: First block connected is not the genesis block (height=%d)\",\n+                       __func__, pindex->nHeight);\n+            return;\n+        }\n+    } else {\n+        // Ensure block connects to an ancestor of the current best block. This should be the case\n+        // most of the time, but may not be immediately after the the sync thread catches up and sets\n+        // m_synced. Consider the case where there is a reorg and the blocks on the stale branch are\n+        // in the ValidationInterface queue backlog even after the sync thread has caught up to the\n+        // new chain tip. In this unlikely event, log a warning and let the queue clear.\n+        if (best_block_index->GetAncestor(pindex->nHeight - 1) != pindex->pprev) {\n+            LogPrintf(\"%s: WARNING: Block %s does not connect to an ancestor of \" /* Continued */\n+                      \"known best chain (tip=%s); not updating txindex\\n\",\n+                      __func__, pindex->GetBlockHash().ToString(),\n+                      best_block_index->GetBlockHash().ToString());\n+            return;\n+        }\n+    }\n+\n+    if (WriteBlock(*block, pindex)) {\n+        m_best_block_index = pindex;\n+    } else {\n+        FatalError(\"%s: Failed to write block %s to txindex\",\n+                   __func__, pindex->GetBlockHash().ToString());\n+        return;\n+    }\n+}\n+\n+void TxIndex::ChainStateFlushed(const CBlockLocator& locator)\n+{\n+    if (!m_synced) {\n+        return;\n+    }\n+\n+    const uint256& locator_tip_hash = locator.vHave.front();\n+    const CBlockIndex* locator_tip_index;\n+    {\n+        LOCK(cs_main);\n+        locator_tip_index = LookupBlockIndex(locator_tip_hash);\n+    }\n+\n+    if (!locator_tip_index) {\n+        FatalError(\"%s: First block (hash=%s) in locator was not found\",\n+                   __func__, locator_tip_hash.ToString());\n+        return;\n+    }\n+\n+    // This checks that ChainStateFlushed callbacks are received after BlockConnected. The check may fail\n+    // immediately after the the sync thread catches up and sets m_synced. Consider the case where\n+    // there is a reorg and the blocks on the stale branch are in the ValidationInterface queue\n+    // backlog even after the sync thread has caught up to the new chain tip. In this unlikely\n+    // event, log a warning and let the queue clear.\n+    const CBlockIndex* best_block_index = m_best_block_index.load();\n+    if (best_block_index->GetAncestor(locator_tip_index->nHeight) != locator_tip_index) {\n+        LogPrintf(\"%s: WARNING: Locator contains block (hash=%s) not on known best \" /* Continued */\n+                  \"chain (tip=%s); not writing txindex locator\\n\",\n+                  __func__, locator_tip_hash.ToString(),\n+                  best_block_index->GetBlockHash().ToString());\n+        return;\n+    }\n+\n+    if (!m_db->WriteBestBlock(locator)) {\n+        error(\"%s: Failed to write locator to disk\", __func__);\n+    }\n+}\n+\n+bool TxIndex::BlockUntilSyncedToCurrentChain()\n+{\n+    AssertLockNotHeld(cs_main);\n+\n+    if (!m_synced) {\n+        return false;\n+    }\n+\n+    {\n+        // Skip the queue-draining stuff if we know we're caught up with\n+        // chainActive.Tip().\n+        LOCK(cs_main);\n+        const CBlockIndex* chain_tip = chainActive.Tip();\n+        const CBlockIndex* best_block_index = m_best_block_index.load();\n+        if (best_block_index->GetAncestor(chain_tip->nHeight) == chain_tip) {\n+            return true;\n+        }\n+    }\n+\n+    LogPrintf(\"%s: txindex is catching up on block notifications\\n\", __func__);\n+    SyncWithValidationInterfaceQueue();\n+    return true;\n+}\n+\n+bool TxIndex::FindTx(const uint256& tx_hash, uint256& block_hash, CTransactionRef& tx) const\n+{\n+    CDiskTxPos postx;\n+    if (!m_db->ReadTxPos(tx_hash, postx)) {\n+        return false;\n+    }\n+\n+    CAutoFile file(OpenBlockFile(postx, true), SER_DISK, CLIENT_VERSION);\n+    if (file.IsNull()) {\n+        return error(\"%s: OpenBlockFile failed\", __func__);\n+    }\n+    CBlockHeader header;\n+    try {\n+        file >> header;\n+        if (fseek(file.Get(), postx.nTxOffset, SEEK_CUR)) {\n+            return error(\"%s: fseek(...) failed\", __func__);\n+        }\n+        file >> tx;\n+    } catch (const std::exception& e) {\n+        return error(\"%s: Deserialize or I/O error - %s\", __func__, e.what());\n+    }\n+    if (tx->GetHash() != tx_hash) {\n+        return error(\"%s: txid mismatch\", __func__);\n+    }\n+    block_hash = header.GetHash();\n+    return true;\n+}\n+\n+void TxIndex::Interrupt()\n+{\n+    m_interrupt();\n+}\n+\n+void TxIndex::Start()\n+{\n+    // Need to register this ValidationInterface before running Init(), so that\n+    // callbacks are not missed if Init sets m_synced to true.\n+    RegisterValidationInterface(this);\n+    if (!Init()) {\n+        FatalError(\"%s: txindex failed to initialize\", __func__);\n+        return;\n+    }\n+\n+    m_thread_sync = std::thread(&TraceThread<std::function<void()>>, \"txindex\",\n+                                std::bind(&TxIndex::ThreadSync, this));\n+}\n+\n+void TxIndex::Stop()\n+{\n+    UnregisterValidationInterface(this);\n+\n+    if (m_thread_sync.joinable()) {\n+        m_thread_sync.join();\n+    }\n+}"
      },
      {
        "sha": "4937bd64e9f8972bf9052d9cc2845e26c8b44661",
        "filename": "src/index/txindex.h",
        "status": "added",
        "additions": 94,
        "deletions": 0,
        "changes": 94,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/index/txindex.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/index/txindex.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/txindex.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -0,0 +1,94 @@\n+// Copyright (c) 2017-2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INDEX_TXINDEX_H\n+#define BITCOIN_INDEX_TXINDEX_H\n+\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <threadinterrupt.h>\n+#include <txdb.h>\n+#include <uint256.h>\n+#include <validationinterface.h>\n+\n+class CBlockIndex;\n+\n+/**\n+ * TxIndex is used to look up transactions included in the blockchain by hash.\n+ * The index is written to a LevelDB database and records the filesystem\n+ * location of each transaction by transaction hash.\n+ */\n+class TxIndex final : public CValidationInterface\n+{\n+private:\n+    const std::unique_ptr<TxIndexDB> m_db;\n+\n+    /// Whether the index is in sync with the main chain. The flag is flipped\n+    /// from false to true once, after which point this starts processing\n+    /// ValidationInterface notifications to stay in sync.\n+    std::atomic<bool> m_synced;\n+\n+    /// The last block in the chain that the TxIndex is in sync with.\n+    std::atomic<const CBlockIndex*> m_best_block_index;\n+\n+    std::thread m_thread_sync;\n+    CThreadInterrupt m_interrupt;\n+\n+    /// Initialize internal state from the database and block index.\n+    bool Init();\n+\n+    /// Sync the tx index with the block index starting from the current best\n+    /// block. Intended to be run in its own thread, m_thread_sync, and can be\n+    /// interrupted with m_interrupt. Once the txindex gets in sync, the\n+    /// m_synced flag is set and the BlockConnected ValidationInterface callback\n+    /// takes over and the sync thread exits.\n+    void ThreadSync();\n+\n+    /// Write update index entries for a newly connected block.\n+    bool WriteBlock(const CBlock& block, const CBlockIndex* pindex);\n+\n+    /// Write the current chain block locator to the DB.\n+    bool WriteBestBlock(const CBlockIndex* block_index);\n+\n+protected:\n+    void BlockConnected(const std::shared_ptr<const CBlock>& block, const CBlockIndex* pindex,\n+                        const std::vector<CTransactionRef>& txn_conflicted) override;\n+\n+    void ChainStateFlushed(const CBlockLocator& locator) override;\n+\n+public:\n+    /// Constructs the TxIndex, which becomes available to be queried.\n+    explicit TxIndex(std::unique_ptr<TxIndexDB> db);\n+\n+    /// Destructor interrupts sync thread if running and blocks until it exits.\n+    ~TxIndex();\n+\n+    /// Blocks the current thread until the transaction index is caught up to\n+    /// the current state of the block chain. This only blocks if the index has gotten in sync once\n+    /// and only needs to process blocks in the ValidationInterface queue. If the index is catching\n+    /// up from far behind, this method does not block and immediately returns false.\n+    bool BlockUntilSyncedToCurrentChain();\n+\n+    /// Look up a transaction by hash.\n+    ///\n+    /// @param[in]   tx_hash  The hash of the transaction to be returned.\n+    /// @param[out]  block_hash  The hash of the block the transaction is found in.\n+    /// @param[out]  tx  The transaction itself.\n+    /// @return  true if transaction is found, false otherwise\n+    bool FindTx(const uint256& tx_hash, uint256& block_hash, CTransactionRef& tx) const;\n+\n+    void Interrupt();\n+\n+    /// Start initializes the sync state and registers the instance as a\n+    /// ValidationInterface so that it stays in sync with blockchain updates.\n+    void Start();\n+\n+    /// Stops the instance from staying in sync with blockchain updates.\n+    void Stop();\n+};\n+\n+/// The global transaction index, used in GetTransaction. May be null.\n+extern std::unique_ptr<TxIndex> g_txindex;\n+\n+#endif // BITCOIN_INDEX_TXINDEX_H"
      },
      {
        "sha": "4ad68b73f2cddcd2181861e669b7099fa26ff97f",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 255,
        "deletions": 271,
        "changes": 526,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -19,6 +19,7 @@\n #include <fs.h>\n #include <httpserver.h>\n #include <httprpc.h>\n+#include <index/txindex.h>\n #include <key.h>\n #include <validation.h>\n #include <miner.h>\n@@ -30,7 +31,6 @@\n #include <policy/policy.h>\n #include <rpc/server.h>\n #include <rpc/register.h>\n-#include <rpc/safemode.h>\n #include <rpc/blockchain.h>\n #include <script/standard.h>\n #include <script/sigcache.h>\n@@ -43,13 +43,10 @@\n #include <util.h>\n #include <utilmoneystr.h>\n #include <validationinterface.h>\n-#ifdef ENABLE_WALLET\n-#include <wallet/init.h>\n-#endif\n #include <warnings.h>\n+#include <walletinitinterface.h>\n #include <stdint.h>\n #include <stdio.h>\n-#include <memory>\n \n #ifndef WIN32\n #include <signal.h>\n@@ -75,6 +72,24 @@ static const bool DEFAULT_STOPAFTERBLOCKIMPORT = false;\n std::unique_ptr<CConnman> g_connman;\n std::unique_ptr<PeerLogicValidation> peerLogic;\n \n+#if !(ENABLE_WALLET)\n+class DummyWalletInit : public WalletInitInterface {\n+public:\n+\n+    void AddWalletOptions() const override {}\n+    bool ParameterInteraction() const override {return true;}\n+    void RegisterRPC(CRPCTable &) const override {}\n+    bool Verify() const override {return true;}\n+    bool Open() const override {LogPrintf(\"No wallet support compiled in!\\n\"); return true;}\n+    void Start(CScheduler& scheduler) const override {}\n+    void Flush() const override {}\n+    void Stop() const override {}\n+    void Close() const override {}\n+};\n+\n+const WalletInitInterface& g_wallet_init_interface = DummyWalletInit();\n+#endif\n+\n #if ENABLE_ZMQ\n static CZMQNotificationInterface* pzmqNotificationInterface = nullptr;\n #endif\n@@ -116,7 +131,6 @@ static const char* FEE_ESTIMATES_FILENAME=\"fee_estimates.dat\";\n //\n \n std::atomic<bool> fRequestShutdown(false);\n-std::atomic<bool> fDumpMempoolLater(false);\n \n void StartShutdown()\n {\n@@ -168,6 +182,9 @@ void Interrupt()\n     InterruptMapPort();\n     if (g_connman)\n         g_connman->Interrupt();\n+    if (g_txindex) {\n+        g_txindex->Interrupt();\n+    }\n }\n \n void Shutdown()\n@@ -189,9 +206,7 @@ void Shutdown()\n     StopREST();\n     StopRPC();\n     StopHTTPServer();\n-#ifdef ENABLE_WALLET\n-    FlushWallets();\n-#endif\n+    g_wallet_init_interface.Flush();\n     StopMapPort();\n \n     // Because these depend on each-other, we make sure that neither can be\n@@ -200,6 +215,9 @@ void Shutdown()\n     if (g_connman) g_connman->Stop();\n     peerLogic.reset();\n     g_connman.reset();\n+    if (g_txindex) {\n+        g_txindex.reset();\n+    }\n \n     StopTorControl();\n \n@@ -208,7 +226,7 @@ void Shutdown()\n     threadGroup.interrupt_all();\n     threadGroup.join_all();\n \n-    if (fDumpMempoolLater && gArgs.GetArg(\"-persistmempool\", DEFAULT_PERSIST_MEMPOOL)) {\n+    if (g_is_mempool_loaded && gArgs.GetArg(\"-persistmempool\", DEFAULT_PERSIST_MEMPOOL)) {\n         DumpMempool();\n     }\n \n@@ -224,7 +242,7 @@ void Shutdown()\n         fFeeEstimatesInitialized = false;\n     }\n \n-    // FlushStateToDisk generates a SetBestChain callback, which we should avoid missing\n+    // FlushStateToDisk generates a ChainStateFlushed callback, which we should avoid missing\n     if (pcoinsTip != nullptr) {\n         FlushStateToDisk();\n     }\n@@ -249,9 +267,7 @@ void Shutdown()\n         pcoinsdbview.reset();\n         pblocktree.reset();\n     }\n-#ifdef ENABLE_WALLET\n-    StopWallets();\n-#endif\n+    g_wallet_init_interface.Stop();\n \n #if ENABLE_ZMQ\n     if (pzmqNotificationInterface) {\n@@ -271,9 +287,7 @@ void Shutdown()\n     UnregisterAllValidationInterfaces();\n     GetMainSignals().UnregisterBackgroundSignalScheduler();\n     GetMainSignals().UnregisterWithMempoolSignals(mempool);\n-#ifdef ENABLE_WALLET\n-    CloseWallets();\n-#endif\n+    g_wallet_init_interface.Close();\n     globalVerifyHandle.reset();\n     ECC_Stop();\n     LogPrintf(\"%s: done\\n\", __func__);\n@@ -284,15 +298,24 @@ void Shutdown()\n  * The execution context the handler is invoked in is not guaranteed,\n  * so we restrict handler operations to just touching variables:\n  */\n+#ifndef WIN32\n static void HandleSIGTERM(int)\n {\n     fRequestShutdown = true;\n }\n \n static void HandleSIGHUP(int)\n {\n-    fReopenDebugLog = true;\n+    g_logger->m_reopen_file = true;\n }\n+#else\n+static BOOL WINAPI consoleCtrlHandler(DWORD dwCtrlType)\n+{\n+    fRequestShutdown = true;\n+    Sleep(INFINITE);\n+    return true;\n+}\n+#endif\n \n #ifndef WIN32\n static void registerSignalHandler(int signal, void(*handler)(int))\n@@ -305,217 +328,177 @@ static void registerSignalHandler(int signal, void(*handler)(int))\n }\n #endif\n \n-void OnRPCStarted()\n+static void OnRPCStarted()\n {\n     uiInterface.NotifyBlockTip.connect(&RPCNotifyBlockChange);\n }\n \n-void OnRPCStopped()\n+static void OnRPCStopped()\n {\n     uiInterface.NotifyBlockTip.disconnect(&RPCNotifyBlockChange);\n     RPCNotifyBlockChange(false, nullptr);\n-    cvBlockChange.notify_all();\n+    g_best_block_cv.notify_all();\n     LogPrint(BCLog::RPC, \"RPC stopped.\\n\");\n }\n \n-std::string HelpMessage(HelpMessageMode mode)\n+void SetupServerArgs()\n {\n     const auto defaultBaseParams = CreateBaseChainParams(CBaseChainParams::MAIN);\n     const auto testnetBaseParams = CreateBaseChainParams(CBaseChainParams::TESTNET);\n     const auto defaultChainParams = CreateChainParams(CBaseChainParams::MAIN);\n     const auto testnetChainParams = CreateChainParams(CBaseChainParams::TESTNET);\n-    const bool showDebug = gArgs.GetBoolArg(\"-help-debug\", false);\n \n+    // Set all of the args and their help\n     // When adding new options to the categories, please keep and ensure alphabetical ordering.\n     // Do not translate _(...) -help-debug options, Many technical terms, and only a very small audience, so is unnecessary stress to translators.\n-    std::string strUsage = HelpMessageGroup(_(\"Options:\"));\n-    strUsage += HelpMessageOpt(\"-?\", _(\"Print this help message and exit\"));\n-    strUsage += HelpMessageOpt(\"-version\", _(\"Print version and exit\"));\n-    strUsage += HelpMessageOpt(\"-alertnotify=<cmd>\", _(\"Execute command when a relevant alert is received or we see a really long fork (%s in cmd is replaced by message)\"));\n-    strUsage +=HelpMessageOpt(\"-assumevalid=<hex>\", strprintf(_(\"If this block is in the chain assume that it and its ancestors are valid and potentially skip their script verification (0 to verify all, default: %s, testnet: %s)\"), defaultChainParams->GetConsensus().defaultAssumeValid.GetHex(), testnetChainParams->GetConsensus().defaultAssumeValid.GetHex()));\n-    strUsage += HelpMessageOpt(\"-blocknotify=<cmd>\", _(\"Execute command when the best block changes (%s in cmd is replaced by block hash)\"));\n-    strUsage += HelpMessageOpt(\"-blockreconstructionextratxn=<n>\", strprintf(_(\"Extra transactions to keep in memory for compact block reconstructions (default: %u)\"), DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN));\n-    if (showDebug)\n-        strUsage += HelpMessageOpt(\"-blocksonly\", strprintf(_(\"Whether to operate in a blocks only mode (default: %u)\"), DEFAULT_BLOCKSONLY));\n-    strUsage += HelpMessageOpt(\"-conf=<file>\", strprintf(_(\"Specify configuration file. Relative paths will be prefixed by datadir location. (default: %s)\"), BITCOIN_CONF_FILENAME));\n-    if (mode == HMM_BITCOIND)\n-    {\n-#if HAVE_DECL_DAEMON\n-        strUsage += HelpMessageOpt(\"-daemon\", _(\"Run in the background as a daemon and accept commands\"));\n-#endif\n-    }\n-    strUsage += HelpMessageOpt(\"-datadir=<dir>\", _(\"Specify data directory\"));\n-    if (showDebug) {\n-        strUsage += HelpMessageOpt(\"-dbbatchsize\", strprintf(\"Maximum database write batch size in bytes (default: %u)\", nDefaultDbBatchSize));\n-    }\n-    strUsage += HelpMessageOpt(\"-dbcache=<n>\", strprintf(_(\"Set database cache size in megabytes (%d to %d, default: %d)\"), nMinDbCache, nMaxDbCache, nDefaultDbCache));\n-    strUsage += HelpMessageOpt(\"-debuglogfile=<file>\", strprintf(_(\"Specify location of debug log file. Relative paths will be prefixed by a net-specific datadir location. (default: %s)\"), DEFAULT_DEBUGLOGFILE));\n-    if (showDebug)\n-        strUsage += HelpMessageOpt(\"-feefilter\", strprintf(\"Tell other nodes to filter invs to us by our mempool min fee (default: %u)\", DEFAULT_FEEFILTER));\n-    strUsage += HelpMessageOpt(\"-loadblock=<file>\", _(\"Imports blocks from external blk000??.dat file on startup\"));\n-    strUsage += HelpMessageOpt(\"-maxmempool=<n>\", strprintf(_(\"Keep the transaction memory pool below <n> megabytes (default: %u)\"), DEFAULT_MAX_MEMPOOL_SIZE));\n-    strUsage += HelpMessageOpt(\"-maxorphantx=<n>\", strprintf(_(\"Keep at most <n> unconnectable transactions in memory (default: %u)\"), DEFAULT_MAX_ORPHAN_TRANSACTIONS));\n-    strUsage += HelpMessageOpt(\"-mempoolexpiry=<n>\", strprintf(_(\"Do not keep transactions in the mempool longer than <n> hours (default: %u)\"), DEFAULT_MEMPOOL_EXPIRY));\n-    if (showDebug) {\n-        strUsage += HelpMessageOpt(\"-minimumchainwork=<hex>\", strprintf(\"Minimum work assumed to exist on a valid chain in hex (default: %s, testnet: %s)\", defaultChainParams->GetConsensus().nMinimumChainWork.GetHex(), testnetChainParams->GetConsensus().nMinimumChainWork.GetHex()));\n-    }\n-    strUsage += HelpMessageOpt(\"-par=<n>\", strprintf(_(\"Set the number of script verification threads (%u to %d, 0 = auto, <0 = leave that many cores free, default: %d)\"),\n-        -GetNumCores(), MAX_SCRIPTCHECK_THREADS, DEFAULT_SCRIPTCHECK_THREADS));\n-    strUsage += HelpMessageOpt(\"-persistmempool\", strprintf(_(\"Whether to save the mempool on shutdown and load on restart (default: %u)\"), DEFAULT_PERSIST_MEMPOOL));\n+    gArgs.AddArg(\"-?\", _(\"Print this help message and exit\"), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-version\", _(\"Print version and exit\"), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-alertnotify=<cmd>\", _(\"Execute command when a relevant alert is received or we see a really long fork (%s in cmd is replaced by message)\"), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-assumevalid=<hex>\", strprintf(_(\"If this block is in the chain assume that it and its ancestors are valid and potentially skip their script verification (0 to verify all, default: %s, testnet: %s)\"), defaultChainParams->GetConsensus().defaultAssumeValid.GetHex(), testnetChainParams->GetConsensus().defaultAssumeValid.GetHex()), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-blocksdir=<dir>\", _(\"Specify blocks directory (default: <datadir>/blocks)\"), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-blocknotify=<cmd>\", _(\"Execute command when the best block changes (%s in cmd is replaced by block hash)\"), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-blockreconstructionextratxn=<n>\", strprintf(_(\"Extra transactions to keep in memory for compact block reconstructions (default: %u)\"), DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-blocksonly\", strprintf(_(\"Whether to operate in a blocks only mode (default: %u)\"), DEFAULT_BLOCKSONLY), true, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-conf=<file>\", strprintf(_(\"Specify configuration file. Relative paths will be prefixed by datadir location. (default: %s)\"), BITCOIN_CONF_FILENAME), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-datadir=<dir>\", _(\"Specify data directory\"), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-dbbatchsize\", strprintf(\"Maximum database write batch size in bytes (default: %u)\", nDefaultDbBatchSize), true, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-dbcache=<n>\", strprintf(_(\"Set database cache size in megabytes (%d to %d, default: %d)\"), nMinDbCache, nMaxDbCache, nDefaultDbCache), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-debuglogfile=<file>\", strprintf(_(\"Specify location of debug log file. Relative paths will be prefixed by a net-specific datadir location. (default: %s)\"), DEFAULT_DEBUGLOGFILE), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-feefilter\", strprintf(\"Tell other nodes to filter invs to us by our mempool min fee (default: %u)\", DEFAULT_FEEFILTER), true, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-includeconf=<file>\", _(\"Specify additional configuration file, relative to the -datadir path (only useable from configuration file, not command line)\"), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-loadblock=<file>\", _(\"Imports blocks from external blk000??.dat file on startup\"), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-maxmempool=<n>\", strprintf(_(\"Keep the transaction memory pool below <n> megabytes (default: %u)\"), DEFAULT_MAX_MEMPOOL_SIZE), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-maxorphantx=<n>\", strprintf(_(\"Keep at most <n> unconnectable transactions in memory (default: %u)\"), DEFAULT_MAX_ORPHAN_TRANSACTIONS), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-mempoolexpiry=<n>\", strprintf(_(\"Do not keep transactions in the mempool longer than <n> hours (default: %u)\"), DEFAULT_MEMPOOL_EXPIRY), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-minimumchainwork=<hex>\", strprintf(\"Minimum work assumed to exist on a valid chain in hex (default: %s, testnet: %s)\", defaultChainParams->GetConsensus().nMinimumChainWork.GetHex(), testnetChainParams->GetConsensus().nMinimumChainWork.GetHex()), true, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-par=<n>\", strprintf(_(\"Set the number of script verification threads (%u to %d, 0 = auto, <0 = leave that many cores free, default: %d)\"),\n+        -GetNumCores(), MAX_SCRIPTCHECK_THREADS, DEFAULT_SCRIPTCHECK_THREADS), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-persistmempool\", strprintf(_(\"Whether to save the mempool on shutdown and load on restart (default: %u)\"), DEFAULT_PERSIST_MEMPOOL), false, OptionsCategory::OPTIONS);\n #ifndef WIN32\n-    strUsage += HelpMessageOpt(\"-pid=<file>\", strprintf(_(\"Specify pid file. Relative paths will be prefixed by a net-specific datadir location. (default: %s)\"), BITCOIN_PID_FILENAME));\n+    gArgs.AddArg(\"-pid=<file>\", strprintf(_(\"Specify pid file. Relative paths will be prefixed by a net-specific datadir location. (default: %s)\"), BITCOIN_PID_FILENAME), false, OptionsCategory::OPTIONS);\n #endif\n-    strUsage += HelpMessageOpt(\"-prune=<n>\", strprintf(_(\"Reduce storage requirements by enabling pruning (deleting) of old blocks. This allows the pruneblockchain RPC to be called to delete specific blocks, and enables automatic pruning of old blocks if a target size in MiB is provided. This mode is incompatible with -txindex and -rescan. \"\n+    gArgs.AddArg(\"-prune=<n>\", strprintf(_(\"Reduce storage requirements by enabling pruning (deleting) of old blocks. This allows the pruneblockchain RPC to be called to delete specific blocks, and enables automatic pruning of old blocks if a target size in MiB is provided. This mode is incompatible with -txindex and -rescan. \"\n             \"Warning: Reverting this setting requires re-downloading the entire blockchain. \"\n-            \"(default: 0 = disable pruning blocks, 1 = allow manual pruning via RPC, >%u = automatically prune block files to stay under the specified target size in MiB)\"), MIN_DISK_SPACE_FOR_BLOCK_FILES / 1024 / 1024));\n-    strUsage += HelpMessageOpt(\"-reindex\", _(\"Rebuild chain state and block index from the blk*.dat files on disk\"));\n-    strUsage += HelpMessageOpt(\"-reindex-chainstate\", _(\"Rebuild chain state from the currently indexed blocks\"));\n+            \"(default: 0 = disable pruning blocks, 1 = allow manual pruning via RPC, >%u = automatically prune block files to stay under the specified target size in MiB)\"), MIN_DISK_SPACE_FOR_BLOCK_FILES / 1024 / 1024), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-reindex\", _(\"Rebuild chain state and block index from the blk*.dat files on disk\"), false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-reindex-chainstate\", _(\"Rebuild chain state from the currently indexed blocks\"), false, OptionsCategory::OPTIONS);\n #ifndef WIN32\n-    strUsage += HelpMessageOpt(\"-sysperms\", _(\"Create new files with system default permissions, instead of umask 077 (only effective with disabled wallet functionality)\"));\n+    gArgs.AddArg(\"-sysperms\", _(\"Create new files with system default permissions, instead of umask 077 (only effective with disabled wallet functionality)\"), false, OptionsCategory::OPTIONS);\n #endif\n-    strUsage += HelpMessageOpt(\"-txindex\", strprintf(_(\"Maintain a full transaction index, used by the getrawtransaction rpc call (default: %u)\"), DEFAULT_TXINDEX));\n-\n-    strUsage += HelpMessageGroup(_(\"Connection options:\"));\n-    strUsage += HelpMessageOpt(\"-addnode=<ip>\", _(\"Add a node to connect to and attempt to keep the connection open (see the `addnode` RPC command help for more info)\"));\n-    strUsage += HelpMessageOpt(\"-banscore=<n>\", strprintf(_(\"Threshold for disconnecting misbehaving peers (default: %u)\"), DEFAULT_BANSCORE_THRESHOLD));\n-    strUsage += HelpMessageOpt(\"-bantime=<n>\", strprintf(_(\"Number of seconds to keep misbehaving peers from reconnecting (default: %u)\"), DEFAULT_MISBEHAVING_BANTIME));\n-    strUsage += HelpMessageOpt(\"-bind=<addr>\", _(\"Bind to given address and always listen on it. Use [host]:port notation for IPv6\"));\n-    strUsage += HelpMessageOpt(\"-connect=<ip>\", _(\"Connect only to the specified node(s); -connect=0 disables automatic connections (the rules for this peer are the same as for -addnode)\"));\n-    strUsage += HelpMessageOpt(\"-discover\", _(\"Discover own IP addresses (default: 1 when listening and no -externalip or -proxy)\"));\n-    strUsage += HelpMessageOpt(\"-dns\", _(\"Allow DNS lookups for -addnode, -seednode and -connect\") + \" \" + strprintf(_(\"(default: %u)\"), DEFAULT_NAME_LOOKUP));\n-    strUsage += HelpMessageOpt(\"-dnsseed\", _(\"Query for peer addresses via DNS lookup, if low on addresses (default: 1 unless -connect used)\"));\n-    strUsage += HelpMessageOpt(\"-externalip=<ip>\", _(\"Specify your own public address\"));\n-    strUsage += HelpMessageOpt(\"-forcednsseed\", strprintf(_(\"Always query for peer addresses via DNS lookup (default: %u)\"), DEFAULT_FORCEDNSSEED));\n-    strUsage += HelpMessageOpt(\"-listen\", _(\"Accept connections from outside (default: 1 if no -proxy or -connect)\"));\n-    strUsage += HelpMessageOpt(\"-listenonion\", strprintf(_(\"Automatically create Tor hidden service (default: %d)\"), DEFAULT_LISTEN_ONION));\n-    strUsage += HelpMessageOpt(\"-maxconnections=<n>\", strprintf(_(\"Maintain at most <n> connections to peers (default: %u)\"), DEFAULT_MAX_PEER_CONNECTIONS));\n-    strUsage += HelpMessageOpt(\"-maxreceivebuffer=<n>\", strprintf(_(\"Maximum per-connection receive buffer, <n>*1000 bytes (default: %u)\"), DEFAULT_MAXRECEIVEBUFFER));\n-    strUsage += HelpMessageOpt(\"-maxsendbuffer=<n>\", strprintf(_(\"Maximum per-connection send buffer, <n>*1000 bytes (default: %u)\"), DEFAULT_MAXSENDBUFFER));\n-    strUsage += HelpMessageOpt(\"-maxtimeadjustment\", strprintf(_(\"Maximum allowed median peer time offset adjustment. Local perspective of time may be influenced by peers forward or backward by this amount. (default: %u seconds)\"), DEFAULT_MAX_TIME_ADJUSTMENT));\n-    strUsage += HelpMessageOpt(\"-maxuploadtarget=<n>\", strprintf(_(\"Tries to keep outbound traffic under the given target (in MiB per 24h), 0 = no limit (default: %d)\"), DEFAULT_MAX_UPLOAD_TARGET));\n-    strUsage += HelpMessageOpt(\"-onion=<ip:port>\", strprintf(_(\"Use separate SOCKS5 proxy to reach peers via Tor hidden services (default: %s)\"), \"-proxy\"));\n-    strUsage += HelpMessageOpt(\"-onlynet=<net>\", _(\"Only connect to nodes in network <net> (ipv4, ipv6 or onion)\"));\n-    strUsage += HelpMessageOpt(\"-peerbloomfilters\", strprintf(_(\"Support filtering of blocks and transaction with bloom filters (default: %u)\"), DEFAULT_PEERBLOOMFILTERS));\n-    strUsage += HelpMessageOpt(\"-permitbaremultisig\", strprintf(_(\"Relay non-P2SH multisig (default: %u)\"), DEFAULT_PERMIT_BAREMULTISIG));\n-    strUsage += HelpMessageOpt(\"-port=<port>\", strprintf(_(\"Listen for connections on <port> (default: %u or testnet: %u)\"), defaultChainParams->GetDefaultPort(), testnetChainParams->GetDefaultPort()));\n-    strUsage += HelpMessageOpt(\"-proxy=<ip:port>\", _(\"Connect through SOCKS5 proxy\"));\n-    strUsage += HelpMessageOpt(\"-proxyrandomize\", strprintf(_(\"Randomize credentials for every proxy connection. This enables Tor stream isolation (default: %u)\"), DEFAULT_PROXYRANDOMIZE));\n-    strUsage += HelpMessageOpt(\"-seednode=<ip>\", _(\"Connect to a node to retrieve peer addresses, and disconnect\"));\n-    strUsage += HelpMessageOpt(\"-timeout=<n>\", strprintf(_(\"Specify connection timeout in milliseconds (minimum: 1, default: %d)\"), DEFAULT_CONNECT_TIMEOUT));\n-    strUsage += HelpMessageOpt(\"-torcontrol=<ip>:<port>\", strprintf(_(\"Tor control port to use if onion listening enabled (default: %s)\"), DEFAULT_TOR_CONTROL));\n-    strUsage += HelpMessageOpt(\"-torpassword=<pass>\", _(\"Tor control port password (default: empty)\"));\n+    gArgs.AddArg(\"-txindex\", strprintf(_(\"Maintain a full transaction index, used by the getrawtransaction rpc call (default: %u)\"), DEFAULT_TXINDEX), false, OptionsCategory::OPTIONS);\n+\n+    gArgs.AddArg(\"-addnode=<ip>\", _(\"Add a node to connect to and attempt to keep the connection open (see the `addnode` RPC command help for more info)\"), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-banscore=<n>\", strprintf(_(\"Threshold for disconnecting misbehaving peers (default: %u)\"), DEFAULT_BANSCORE_THRESHOLD), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-bantime=<n>\", strprintf(_(\"Number of seconds to keep misbehaving peers from reconnecting (default: %u)\"), DEFAULT_MISBEHAVING_BANTIME), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-bind=<addr>\", _(\"Bind to given address and always listen on it. Use [host]:port notation for IPv6\"), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-connect=<ip>\", _(\"Connect only to the specified node(s); -connect=0 disables automatic connections (the rules for this peer are the same as for -addnode)\"), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-discover\", _(\"Discover own IP addresses (default: 1 when listening and no -externalip or -proxy)\"), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-dns\", _(\"Allow DNS lookups for -addnode, -seednode and -connect\") + \" \" + strprintf(_(\"(default: %u)\"), DEFAULT_NAME_LOOKUP), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-dnsseed\", _(\"Query for peer addresses via DNS lookup, if low on addresses (default: 1 unless -connect used)\"), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-externalip=<ip>\", _(\"Specify your own public address\"), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-forcednsseed\", strprintf(_(\"Always query for peer addresses via DNS lookup (default: %u)\"), DEFAULT_FORCEDNSSEED), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-listen\", _(\"Accept connections from outside (default: 1 if no -proxy or -connect)\"), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-listenonion\", strprintf(_(\"Automatically create Tor hidden service (default: %d)\"), DEFAULT_LISTEN_ONION), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-maxconnections=<n>\", strprintf(_(\"Maintain at most <n> connections to peers (default: %u)\"), DEFAULT_MAX_PEER_CONNECTIONS), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-maxreceivebuffer=<n>\", strprintf(_(\"Maximum per-connection receive buffer, <n>*1000 bytes (default: %u)\"), DEFAULT_MAXRECEIVEBUFFER), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-maxsendbuffer=<n>\", strprintf(_(\"Maximum per-connection send buffer, <n>*1000 bytes (default: %u)\"), DEFAULT_MAXSENDBUFFER), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-maxtimeadjustment\", strprintf(_(\"Maximum allowed median peer time offset adjustment. Local perspective of time may be influenced by peers forward or backward by this amount. (default: %u seconds)\"), DEFAULT_MAX_TIME_ADJUSTMENT), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-maxuploadtarget=<n>\", strprintf(_(\"Tries to keep outbound traffic under the given target (in MiB per 24h), 0 = no limit (default: %d)\"), DEFAULT_MAX_UPLOAD_TARGET), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-onion=<ip:port>\", strprintf(_(\"Use separate SOCKS5 proxy to reach peers via Tor hidden services (default: %s)\"), \"-proxy\"), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-onlynet=<net>\", _(\"Only connect to nodes in network <net> (ipv4, ipv6 or onion)\"), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-peerbloomfilters\", strprintf(_(\"Support filtering of blocks and transaction with bloom filters (default: %u)\"), DEFAULT_PEERBLOOMFILTERS), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-permitbaremultisig\", strprintf(_(\"Relay non-P2SH multisig (default: %u)\"), DEFAULT_PERMIT_BAREMULTISIG), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-port=<port>\", strprintf(_(\"Listen for connections on <port> (default: %u or testnet: %u)\"), defaultChainParams->GetDefaultPort(), testnetChainParams->GetDefaultPort()), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-proxy=<ip:port>\", _(\"Connect through SOCKS5 proxy\"), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-proxyrandomize\", strprintf(_(\"Randomize credentials for every proxy connection. This enables Tor stream isolation (default: %u)\"), DEFAULT_PROXYRANDOMIZE), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-seednode=<ip>\", _(\"Connect to a node to retrieve peer addresses, and disconnect\"), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-timeout=<n>\", strprintf(_(\"Specify connection timeout in milliseconds (minimum: 1, default: %d)\"), DEFAULT_CONNECT_TIMEOUT), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-torcontrol=<ip>:<port>\", strprintf(_(\"Tor control port to use if onion listening enabled (default: %s)\"), DEFAULT_TOR_CONTROL), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-torpassword=<pass>\", _(\"Tor control port password (default: empty)\"), false, OptionsCategory::CONNECTION);\n #ifdef USE_UPNP\n #if USE_UPNP\n-    strUsage += HelpMessageOpt(\"-upnp\", _(\"Use UPnP to map the listening port (default: 1 when listening and no -proxy)\"));\n+    gArgs.AddArg(\"-upnp\", _(\"Use UPnP to map the listening port (default: 1 when listening and no -proxy)\"), false, OptionsCategory::CONNECTION);\n #else\n-    strUsage += HelpMessageOpt(\"-upnp\", strprintf(_(\"Use UPnP to map the listening port (default: %u)\"), 0));\n+    gArgs.AddArg(\"-upnp\", strprintf(_(\"Use UPnP to map the listening port (default: %u)\"), 0), false, OptionsCategory::CONNECTION);\n #endif\n #endif\n-    strUsage += HelpMessageOpt(\"-whitebind=<addr>\", _(\"Bind to given address and whitelist peers connecting to it. Use [host]:port notation for IPv6\"));\n-    strUsage += HelpMessageOpt(\"-whitelist=<IP address or network>\", _(\"Whitelist peers connecting from the given IP address (e.g. 1.2.3.4) or CIDR notated network (e.g. 1.2.3.0/24). Can be specified multiple times.\") +\n-        \" \" + _(\"Whitelisted peers cannot be DoS banned and their transactions are always relayed, even if they are already in the mempool, useful e.g. for a gateway\"));\n+    gArgs.AddArg(\"-whitebind=<addr>\", _(\"Bind to given address and whitelist peers connecting to it. Use [host]:port notation for IPv6\"), false, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-whitelist=<IP address or network>\", _(\"Whitelist peers connecting from the given IP address (e.g. 1.2.3.4) or CIDR notated network (e.g. 1.2.3.0/24). Can be specified multiple times.\") +\n+        \" \" + _(\"Whitelisted peers cannot be DoS banned and their transactions are always relayed, even if they are already in the mempool, useful e.g. for a gateway\"), false, OptionsCategory::CONNECTION);\n \n-#ifdef ENABLE_WALLET\n-    strUsage += GetWalletHelpString(showDebug);\n-#endif\n+    g_wallet_init_interface.AddWalletOptions();\n \n #if ENABLE_ZMQ\n-    strUsage += HelpMessageGroup(_(\"ZeroMQ notification options:\"));\n-    strUsage += HelpMessageOpt(\"-zmqpubhashblock=<address>\", _(\"Enable publish hash block in <address>\"));\n-    strUsage += HelpMessageOpt(\"-zmqpubhashtx=<address>\", _(\"Enable publish hash transaction in <address>\"));\n-    strUsage += HelpMessageOpt(\"-zmqpubrawblock=<address>\", _(\"Enable publish raw block in <address>\"));\n-    strUsage += HelpMessageOpt(\"-zmqpubrawtx=<address>\", _(\"Enable publish raw transaction in <address>\"));\n+    gArgs.AddArg(\"-zmqpubhashblock=<address>\", _(\"Enable publish hash block in <address>\"), false, OptionsCategory::ZMQ);\n+    gArgs.AddArg(\"-zmqpubhashtx=<address>\", _(\"Enable publish hash transaction in <address>\"), false, OptionsCategory::ZMQ);\n+    gArgs.AddArg(\"-zmqpubrawblock=<address>\", _(\"Enable publish raw block in <address>\"), false, OptionsCategory::ZMQ);\n+    gArgs.AddArg(\"-zmqpubrawtx=<address>\", _(\"Enable publish raw transaction in <address>\"), false, OptionsCategory::ZMQ);\n #endif\n \n-    strUsage += HelpMessageGroup(_(\"Debugging/Testing options:\"));\n-    if (showDebug)\n-    {\n-        strUsage += HelpMessageOpt(\"-checkblocks=<n>\", strprintf(_(\"How many blocks to check at startup (default: %u, 0 = all)\"), DEFAULT_CHECKBLOCKS));\n-        strUsage += HelpMessageOpt(\"-checklevel=<n>\", strprintf(_(\"How thorough the block verification of -checkblocks is (0-4, default: %u)\"), DEFAULT_CHECKLEVEL));\n-        strUsage += HelpMessageOpt(\"-checkblockindex\", strprintf(\"Do a full consistency check for mapBlockIndex, setBlockIndexCandidates, chainActive and mapBlocksUnlinked occasionally. Also sets -checkmempool (default: %u)\", defaultChainParams->DefaultConsistencyChecks()));\n-        strUsage += HelpMessageOpt(\"-checkmempool=<n>\", strprintf(\"Run checks every <n> transactions (default: %u)\", defaultChainParams->DefaultConsistencyChecks()));\n-        strUsage += HelpMessageOpt(\"-checkpoints\", strprintf(\"Disable expensive verification for known chain history (default: %u)\", DEFAULT_CHECKPOINTS_ENABLED));\n-        strUsage += HelpMessageOpt(\"-disablesafemode\", strprintf(\"Disable safemode, override a real safe mode event (default: %u)\", DEFAULT_DISABLE_SAFEMODE));\n-        strUsage += HelpMessageOpt(\"-deprecatedrpc=<method>\", \"Allows deprecated RPC method(s) to be used\");\n-        strUsage += HelpMessageOpt(\"-testsafemode\", strprintf(\"Force safe mode (default: %u)\", DEFAULT_TESTSAFEMODE));\n-        strUsage += HelpMessageOpt(\"-dropmessagestest=<n>\", \"Randomly drop 1 of every <n> network messages\");\n-        strUsage += HelpMessageOpt(\"-fuzzmessagestest=<n>\", \"Randomly fuzz 1 of every <n> network messages\");\n-        strUsage += HelpMessageOpt(\"-stopafterblockimport\", strprintf(\"Stop running after importing blocks from disk (default: %u)\", DEFAULT_STOPAFTERBLOCKIMPORT));\n-        strUsage += HelpMessageOpt(\"-stopatheight\", strprintf(\"Stop running after reaching the given height in the main chain (default: %u)\", DEFAULT_STOPATHEIGHT));\n-\n-        strUsage += HelpMessageOpt(\"-limitancestorcount=<n>\", strprintf(\"Do not accept transactions if number of in-mempool ancestors is <n> or more (default: %u)\", DEFAULT_ANCESTOR_LIMIT));\n-        strUsage += HelpMessageOpt(\"-limitancestorsize=<n>\", strprintf(\"Do not accept transactions whose size with all in-mempool ancestors exceeds <n> kilobytes (default: %u)\", DEFAULT_ANCESTOR_SIZE_LIMIT));\n-        strUsage += HelpMessageOpt(\"-limitdescendantcount=<n>\", strprintf(\"Do not accept transactions if any ancestor would have <n> or more in-mempool descendants (default: %u)\", DEFAULT_DESCENDANT_LIMIT));\n-        strUsage += HelpMessageOpt(\"-limitdescendantsize=<n>\", strprintf(\"Do not accept transactions if any ancestor would have more than <n> kilobytes of in-mempool descendants (default: %u).\", DEFAULT_DESCENDANT_SIZE_LIMIT));\n-        strUsage += HelpMessageOpt(\"-vbparams=deployment:start:end\", \"Use given start/end times for specified version bits deployment (regtest-only)\");\n-        strUsage += HelpMessageOpt(\"-addrmantest\", \"Allows to test address relay on localhost\");\n-    }\n-    strUsage += HelpMessageOpt(\"-debug=<category>\", strprintf(_(\"Output debugging information (default: %u, supplying <category> is optional)\"), 0) + \". \" +\n-        _(\"If <category> is not supplied or if <category> = 1, output all debugging information.\") + \" \" + _(\"<category> can be:\") + \" \" + ListLogCategories() + \".\");\n-    strUsage += HelpMessageOpt(\"-debugexclude=<category>\", strprintf(_(\"Exclude debugging information for a category. Can be used in conjunction with -debug=1 to output debug logs for all categories except one or more specified categories.\")));\n-    strUsage += HelpMessageOpt(\"-help-debug\", _(\"Show all debugging options (usage: --help -help-debug)\"));\n-    strUsage += HelpMessageOpt(\"-logips\", strprintf(_(\"Include IP addresses in debug output (default: %u)\"), DEFAULT_LOGIPS));\n-    strUsage += HelpMessageOpt(\"-logtimestamps\", strprintf(_(\"Prepend debug output with timestamp (default: %u)\"), DEFAULT_LOGTIMESTAMPS));\n-    if (showDebug)\n-    {\n-        strUsage += HelpMessageOpt(\"-logtimemicros\", strprintf(\"Add microsecond precision to debug timestamps (default: %u)\", DEFAULT_LOGTIMEMICROS));\n-        strUsage += HelpMessageOpt(\"-mocktime=<n>\", \"Replace actual time with <n> seconds since epoch (default: 0)\");\n-        strUsage += HelpMessageOpt(\"-maxsigcachesize=<n>\", strprintf(\"Limit sum of signature cache and script execution cache sizes to <n> MiB (default: %u)\", DEFAULT_MAX_SIG_CACHE_SIZE));\n-        strUsage += HelpMessageOpt(\"-maxtipage=<n>\", strprintf(\"Maximum tip age in seconds to consider node in initial block download (default: %u)\", DEFAULT_MAX_TIP_AGE));\n-    }\n-    strUsage += HelpMessageOpt(\"-maxtxfee=<amt>\", strprintf(_(\"Maximum total fees (in %s) to use in a single wallet transaction or raw transaction; setting this too low may abort large transactions (default: %s)\"),\n-        CURRENCY_UNIT, FormatMoney(DEFAULT_TRANSACTION_MAXFEE)));\n-    if (showDebug)\n-    {\n-        strUsage += HelpMessageOpt(\"-printpriority\", strprintf(\"Log transaction fee per kB when mining blocks (default: %u)\", DEFAULT_PRINTPRIORITY));\n-    }\n-    strUsage += HelpMessageOpt(\"-printtoconsole\", _(\"Send trace/debug info to console instead of debug.log file\"));\n-    strUsage += HelpMessageOpt(\"-shrinkdebugfile\", _(\"Shrink debug.log file on client startup (default: 1 when no -debug)\"));\n-    strUsage += HelpMessageOpt(\"-uacomment=<cmt>\", _(\"Append comment to the user agent string\"));\n-\n-    AppendParamsHelpMessages(strUsage, showDebug);\n-\n-    strUsage += HelpMessageGroup(_(\"Node relay options:\"));\n-    if (showDebug) {\n-        strUsage += HelpMessageOpt(\"-acceptnonstdtxn\", strprintf(\"Relay and mine \\\"non-standard\\\" transactions (%sdefault: %u)\", \"testnet/regtest only; \", !testnetChainParams->RequireStandard()));\n-        strUsage += HelpMessageOpt(\"-incrementalrelayfee=<amt>\", strprintf(\"Fee rate (in %s/kB) used to define cost of relay, used for mempool limiting and BIP 125 replacement. (default: %s)\", CURRENCY_UNIT, FormatMoney(DEFAULT_INCREMENTAL_RELAY_FEE)));\n-        strUsage += HelpMessageOpt(\"-dustrelayfee=<amt>\", strprintf(\"Fee rate (in %s/kB) used to defined dust, the value of an output such that it will cost more than its value in fees at this fee rate to spend it. (default: %s)\", CURRENCY_UNIT, FormatMoney(DUST_RELAY_TX_FEE)));\n-    }\n-    strUsage += HelpMessageOpt(\"-bytespersigop\", strprintf(_(\"Equivalent bytes per sigop in transactions for relay and mining (default: %u)\"), DEFAULT_BYTES_PER_SIGOP));\n-    strUsage += HelpMessageOpt(\"-datacarrier\", strprintf(_(\"Relay and mine data carrier transactions (default: %u)\"), DEFAULT_ACCEPT_DATACARRIER));\n-    strUsage += HelpMessageOpt(\"-datacarriersize\", strprintf(_(\"Maximum size of data in data carrier transactions we relay and mine (default: %u)\"), MAX_OP_RETURN_RELAY));\n-    strUsage += HelpMessageOpt(\"-mempoolreplacement\", strprintf(_(\"Enable transaction replacement in the memory pool (default: %u)\"), DEFAULT_ENABLE_REPLACEMENT));\n-    strUsage += HelpMessageOpt(\"-minrelaytxfee=<amt>\", strprintf(_(\"Fees (in %s/kB) smaller than this are considered zero fee for relaying, mining and transaction creation (default: %s)\"),\n-        CURRENCY_UNIT, FormatMoney(DEFAULT_MIN_RELAY_TX_FEE)));\n-    strUsage += HelpMessageOpt(\"-whitelistforcerelay\", strprintf(_(\"Force relay of transactions from whitelisted peers even if they violate local relay policy (default: %d)\"), DEFAULT_WHITELISTFORCERELAY));\n-    strUsage += HelpMessageOpt(\"-whitelistrelay\", strprintf(_(\"Accept relayed transactions received from whitelisted peers even when not relaying transactions (default: %d)\"), DEFAULT_WHITELISTRELAY));\n-\n-    strUsage += HelpMessageGroup(_(\"Block creation options:\"));\n-    if (showDebug)\n-        strUsage += HelpMessageOpt(\"-blockmaxsize=<n>\", \"Set maximum BIP141 block weight to this * 4. Deprecated, use blockmaxweight\");\n-    strUsage += HelpMessageOpt(\"-blockmaxweight=<n>\", strprintf(_(\"Set maximum BIP141 block weight (default: %d)\"), DEFAULT_BLOCK_MAX_WEIGHT));\n-    strUsage += HelpMessageOpt(\"-blockmintxfee=<amt>\", strprintf(_(\"Set lowest fee rate (in %s/kB) for transactions to be included in block creation. (default: %s)\"), CURRENCY_UNIT, FormatMoney(DEFAULT_BLOCK_MIN_TX_FEE)));\n-    if (showDebug)\n-        strUsage += HelpMessageOpt(\"-blockversion=<n>\", \"Override block version to test forking scenarios\");\n-\n-    strUsage += HelpMessageGroup(_(\"RPC server options:\"));\n-    strUsage += HelpMessageOpt(\"-rest\", strprintf(_(\"Accept public REST requests (default: %u)\"), DEFAULT_REST_ENABLE));\n-    strUsage += HelpMessageOpt(\"-rpcallowip=<ip>\", _(\"Allow JSON-RPC connections from specified source. Valid for <ip> are a single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24). This option can be specified multiple times\"));\n-    strUsage += HelpMessageOpt(\"-rpcauth=<userpw>\", _(\"Username and hashed password for JSON-RPC connections. The field <userpw> comes in the format: <USERNAME>:<SALT>$<HASH>. A canonical python script is included in share/rpcuser. The client then connects normally using the rpcuser=<USERNAME>/rpcpassword=<PASSWORD> pair of arguments. This option can be specified multiple times\"));\n-    strUsage += HelpMessageOpt(\"-rpcbind=<addr>[:port]\", _(\"Bind to given address to listen for JSON-RPC connections. This option is ignored unless -rpcallowip is also passed. Port is optional and overrides -rpcport. Use [host]:port notation for IPv6. This option can be specified multiple times (default: 127.0.0.1 and ::1 i.e., localhost, or if -rpcallowip has been specified, 0.0.0.0 and :: i.e., all addresses)\"));\n-    strUsage += HelpMessageOpt(\"-rpccookiefile=<loc>\", _(\"Location of the auth cookie. Relative paths will be prefixed by a net-specific datadir location. (default: data dir)\"));\n-    strUsage += HelpMessageOpt(\"-rpcpassword=<pw>\", _(\"Password for JSON-RPC connections\"));\n-    strUsage += HelpMessageOpt(\"-rpcport=<port>\", strprintf(_(\"Listen for JSON-RPC connections on <port> (default: %u or testnet: %u)\"), defaultBaseParams->RPCPort(), testnetBaseParams->RPCPort()));\n-    strUsage += HelpMessageOpt(\"-rpcserialversion\", strprintf(_(\"Sets the serialization of raw transaction or block hex returned in non-verbose mode, non-segwit(0) or segwit(1) (default: %d)\"), DEFAULT_RPC_SERIALIZE_VERSION));\n-    if (showDebug)\n-        strUsage += HelpMessageOpt(\"-rpcservertimeout=<n>\", strprintf(\"Timeout during HTTP requests (default: %d)\", DEFAULT_HTTP_SERVER_TIMEOUT));\n-    strUsage += HelpMessageOpt(\"-rpcthreads=<n>\", strprintf(_(\"Set the number of threads to service RPC calls (default: %d)\"), DEFAULT_HTTP_THREADS));\n-    strUsage += HelpMessageOpt(\"-rpcuser=<user>\", _(\"Username for JSON-RPC connections\"));\n-    if (showDebug)\n-        strUsage += HelpMessageOpt(\"-rpcworkqueue=<n>\", strprintf(\"Set the depth of the work queue to service RPC calls (default: %d)\", DEFAULT_HTTP_WORKQUEUE));\n-    strUsage += HelpMessageOpt(\"-server\", _(\"Accept command line and JSON-RPC commands\"));\n-\n-    return strUsage;\n+    gArgs.AddArg(\"-checkblocks=<n>\", strprintf(_(\"How many blocks to check at startup (default: %u, 0 = all)\"), DEFAULT_CHECKBLOCKS), true, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-checklevel=<n>\", strprintf(_(\"How thorough the block verification of -checkblocks is (0-4, default: %u)\"), DEFAULT_CHECKLEVEL), true, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-checkblockindex\", strprintf(\"Do a full consistency check for mapBlockIndex, setBlockIndexCandidates, chainActive and mapBlocksUnlinked occasionally. (default: %u)\", defaultChainParams->DefaultConsistencyChecks()), true, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-checkmempool=<n>\", strprintf(\"Run checks every <n> transactions (default: %u)\", defaultChainParams->DefaultConsistencyChecks()), true, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-checkpoints\", strprintf(\"Disable expensive verification for known chain history (default: %u)\", DEFAULT_CHECKPOINTS_ENABLED), true, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-deprecatedrpc=<method>\", \"Allows deprecated RPC method(s) to be used\", true, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-dropmessagestest=<n>\", \"Randomly drop 1 of every <n> network messages\", true, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-stopafterblockimport\", strprintf(\"Stop running after importing blocks from disk (default: %u)\", DEFAULT_STOPAFTERBLOCKIMPORT), true, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-stopatheight\", strprintf(\"Stop running after reaching the given height in the main chain (default: %u)\", DEFAULT_STOPATHEIGHT), true, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-limitancestorcount=<n>\", strprintf(\"Do not accept transactions if number of in-mempool ancestors is <n> or more (default: %u)\", DEFAULT_ANCESTOR_LIMIT), true, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-limitancestorsize=<n>\", strprintf(\"Do not accept transactions whose size with all in-mempool ancestors exceeds <n> kilobytes (default: %u)\", DEFAULT_ANCESTOR_SIZE_LIMIT), true, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-limitdescendantcount=<n>\", strprintf(\"Do not accept transactions if any ancestor would have <n> or more in-mempool descendants (default: %u)\", DEFAULT_DESCENDANT_LIMIT), true, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-limitdescendantsize=<n>\", strprintf(\"Do not accept transactions if any ancestor would have more than <n> kilobytes of in-mempool descendants (default: %u).\", DEFAULT_DESCENDANT_SIZE_LIMIT), true, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-vbparams=deployment:start:end\", \"Use given start/end times for specified version bits deployment (regtest-only)\", true, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-addrmantest\", \"Allows to test address relay on localhost\", true, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-debug=<category>\", strprintf(_(\"Output debugging information (default: %u, supplying <category> is optional)\"), 0) + \". \" +\n+        _(\"If <category> is not supplied or if <category> = 1, output all debugging information.\") + \" \" + _(\"<category> can be:\") + \" \" + ListLogCategories() + \".\", false, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-debugexclude=<category>\", strprintf(_(\"Exclude debugging information for a category. Can be used in conjunction with -debug=1 to output debug logs for all categories except one or more specified categories.\")), false, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-help-debug\", _(\"Show all debugging options (usage: --help -help-debug)\"), false, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-logips\", strprintf(_(\"Include IP addresses in debug output (default: %u)\"), DEFAULT_LOGIPS), false, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-logtimestamps\", strprintf(_(\"Prepend debug output with timestamp (default: %u)\"), DEFAULT_LOGTIMESTAMPS), false, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-logtimemicros\", strprintf(\"Add microsecond precision to debug timestamps (default: %u)\", DEFAULT_LOGTIMEMICROS), true, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-mocktime=<n>\", \"Replace actual time with <n> seconds since epoch (default: 0)\", true, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-maxsigcachesize=<n>\", strprintf(\"Limit sum of signature cache and script execution cache sizes to <n> MiB (default: %u)\", DEFAULT_MAX_SIG_CACHE_SIZE), true, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-maxtipage=<n>\", strprintf(\"Maximum tip age in seconds to consider node in initial block download (default: %u)\", DEFAULT_MAX_TIP_AGE), true, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-maxtxfee=<amt>\", strprintf(_(\"Maximum total fees (in %s) to use in a single wallet transaction or raw transaction; setting this too low may abort large transactions (default: %s)\"),\n+        CURRENCY_UNIT, FormatMoney(DEFAULT_TRANSACTION_MAXFEE)), false, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-printpriority\", strprintf(\"Log transaction fee per kB when mining blocks (default: %u)\", DEFAULT_PRINTPRIORITY), true, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-printtoconsole\", _(\"Send trace/debug info to console instead of debug.log file\"), false, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-shrinkdebugfile\", _(\"Shrink debug.log file on client startup (default: 1 when no -debug)\"), false, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-uacomment=<cmt>\", _(\"Append comment to the user agent string\"), false, OptionsCategory::DEBUG_TEST);\n+\n+    SetupChainParamsBaseOptions();\n+\n+    gArgs.AddArg(\"-acceptnonstdtxn\", strprintf(\"Relay and mine \\\"non-standard\\\" transactions (%sdefault: %u)\", \"testnet/regtest only; \", !testnetChainParams->RequireStandard()), true, OptionsCategory::NODE_RELAY);\n+    gArgs.AddArg(\"-incrementalrelayfee=<amt>\", strprintf(\"Fee rate (in %s/kB) used to define cost of relay, used for mempool limiting and BIP 125 replacement. (default: %s)\", CURRENCY_UNIT, FormatMoney(DEFAULT_INCREMENTAL_RELAY_FEE)), true, OptionsCategory::NODE_RELAY);\n+    gArgs.AddArg(\"-dustrelayfee=<amt>\", strprintf(\"Fee rate (in %s/kB) used to defined dust, the value of an output such that it will cost more than its value in fees at this fee rate to spend it. (default: %s)\", CURRENCY_UNIT, FormatMoney(DUST_RELAY_TX_FEE)), true, OptionsCategory::NODE_RELAY);\n+    gArgs.AddArg(\"-bytespersigop\", strprintf(_(\"Equivalent bytes per sigop in transactions for relay and mining (default: %u)\"), DEFAULT_BYTES_PER_SIGOP), false, OptionsCategory::NODE_RELAY);\n+    gArgs.AddArg(\"-datacarrier\", strprintf(_(\"Relay and mine data carrier transactions (default: %u)\"), DEFAULT_ACCEPT_DATACARRIER), false, OptionsCategory::NODE_RELAY);\n+    gArgs.AddArg(\"-datacarriersize\", strprintf(_(\"Maximum size of data in data carrier transactions we relay and mine (default: %u)\"), MAX_OP_RETURN_RELAY), false, OptionsCategory::NODE_RELAY);\n+    gArgs.AddArg(\"-mempoolreplacement\", strprintf(_(\"Enable transaction replacement in the memory pool (default: %u)\"), DEFAULT_ENABLE_REPLACEMENT), false, OptionsCategory::NODE_RELAY);\n+    gArgs.AddArg(\"-minrelaytxfee=<amt>\", strprintf(_(\"Fees (in %s/kB) smaller than this are considered zero fee for relaying, mining and transaction creation (default: %s)\"),\n+        CURRENCY_UNIT, FormatMoney(DEFAULT_MIN_RELAY_TX_FEE)), false, OptionsCategory::NODE_RELAY);\n+    gArgs.AddArg(\"-whitelistforcerelay\", strprintf(_(\"Force relay of transactions from whitelisted peers even if they violate local relay policy (default: %d)\"), DEFAULT_WHITELISTFORCERELAY), false, OptionsCategory::NODE_RELAY);\n+    gArgs.AddArg(\"-whitelistrelay\", strprintf(_(\"Accept relayed transactions received from whitelisted peers even when not relaying transactions (default: %d)\"), DEFAULT_WHITELISTRELAY), false, OptionsCategory::NODE_RELAY);\n+\n+\n+    gArgs.AddArg(\"-blockmaxweight=<n>\", strprintf(_(\"Set maximum BIP141 block weight (default: %d)\"), DEFAULT_BLOCK_MAX_WEIGHT), false, OptionsCategory::BLOCK_CREATION);\n+    gArgs.AddArg(\"-blockmintxfee=<amt>\", strprintf(_(\"Set lowest fee rate (in %s/kB) for transactions to be included in block creation. (default: %s)\"), CURRENCY_UNIT, FormatMoney(DEFAULT_BLOCK_MIN_TX_FEE)), false, OptionsCategory::BLOCK_CREATION);\n+    gArgs.AddArg(\"-blockversion=<n>\", \"Override block version to test forking scenarios\", true, OptionsCategory::BLOCK_CREATION);\n+\n+    gArgs.AddArg(\"-rest\", strprintf(_(\"Accept public REST requests (default: %u)\"), DEFAULT_REST_ENABLE), false, OptionsCategory::RPC);\n+    gArgs.AddArg(\"-rpcallowip=<ip>\", _(\"Allow JSON-RPC connections from specified source. Valid for <ip> are a single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24). This option can be specified multiple times\"), false, OptionsCategory::RPC);\n+    gArgs.AddArg(\"-rpcauth=<userpw>\", _(\"Username and hashed password for JSON-RPC connections. The field <userpw> comes in the format: <USERNAME>:<SALT>$<HASH>. A canonical python script is included in share/rpcuser. The client then connects normally using the rpcuser=<USERNAME>/rpcpassword=<PASSWORD> pair of arguments. This option can be specified multiple times\"), false, OptionsCategory::RPC);\n+    gArgs.AddArg(\"-rpcbind=<addr>[:port]\", _(\"Bind to given address to listen for JSON-RPC connections. This option is ignored unless -rpcallowip is also passed. Port is optional and overrides -rpcport. Use [host]:port notation for IPv6. This option can be specified multiple times (default: 127.0.0.1 and ::1 i.e., localhost, or if -rpcallowip has been specified, 0.0.0.0 and :: i.e., all addresses)\"), false, OptionsCategory::RPC);\n+    gArgs.AddArg(\"-rpccookiefile=<loc>\", _(\"Location of the auth cookie. Relative paths will be prefixed by a net-specific datadir location. (default: data dir)\"), false, OptionsCategory::RPC);\n+    gArgs.AddArg(\"-rpcpassword=<pw>\", _(\"Password for JSON-RPC connections\"), false, OptionsCategory::RPC);\n+    gArgs.AddArg(\"-rpcport=<port>\", strprintf(_(\"Listen for JSON-RPC connections on <port> (default: %u or testnet: %u)\"), defaultBaseParams->RPCPort(), testnetBaseParams->RPCPort()), false, OptionsCategory::RPC);\n+    gArgs.AddArg(\"-rpcserialversion\", strprintf(_(\"Sets the serialization of raw transaction or block hex returned in non-verbose mode, non-segwit(0) or segwit(1) (default: %d)\"), DEFAULT_RPC_SERIALIZE_VERSION), false, OptionsCategory::RPC);\n+    gArgs.AddArg(\"-rpcservertimeout=<n>\", strprintf(\"Timeout during HTTP requests (default: %d)\", DEFAULT_HTTP_SERVER_TIMEOUT), true, OptionsCategory::RPC);\n+    gArgs.AddArg(\"-rpcthreads=<n>\", strprintf(_(\"Set the number of threads to service RPC calls (default: %d)\"), DEFAULT_HTTP_THREADS), false, OptionsCategory::RPC);\n+    gArgs.AddArg(\"-rpcuser=<user>\", _(\"Username for JSON-RPC connections\"), false, OptionsCategory::RPC);\n+    gArgs.AddArg(\"-rpcworkqueue=<n>\", strprintf(\"Set the depth of the work queue to service RPC calls (default: %d)\", DEFAULT_HTTP_WORKQUEUE), true, OptionsCategory::RPC);\n+    gArgs.AddArg(\"-server\", _(\"Accept command line and JSON-RPC commands\"), false, OptionsCategory::RPC);\n }\n \n std::string LicenseInfo()\n@@ -588,15 +571,15 @@ struct CImportingNow\n // rev files since they'll be rewritten by the reindex anyway.  This ensures that vinfoBlockFile\n // is in sync with what's actually on disk by the time we start downloading, so that pruning\n // works correctly.\n-void CleanupBlockRevFiles()\n+static void CleanupBlockRevFiles()\n {\n     std::map<std::string, fs::path> mapBlockFiles;\n \n     // Glob all blk?????.dat and rev?????.dat files from the blocks directory.\n     // Remove the rev files immediately and insert the blk file paths into an\n     // ordered map keyed by block file index.\n     LogPrintf(\"Removing unusable blk?????.dat and rev?????.dat files for -reindex with -prune\\n\");\n-    fs::path blocksdir = GetDataDir() / \"blocks\";\n+    fs::path blocksdir = GetBlocksDir();\n     for (fs::directory_iterator it(blocksdir); it != fs::directory_iterator(); it++) {\n         if (fs::is_regular_file(*it) &&\n             it->path().filename().string().length() == 12 &&\n@@ -623,10 +606,11 @@ void CleanupBlockRevFiles()\n     }\n }\n \n-void ThreadImport(std::vector<fs::path> vImportFiles)\n+static void ThreadImport(std::vector<fs::path> vImportFiles)\n {\n     const CChainParams& chainparams = Params();\n     RenameThread(\"bitcoin-loadblk\");\n+    ScheduleBatchPriority();\n \n     {\n     CImportingNow imp;\n@@ -680,7 +664,7 @@ void ThreadImport(std::vector<fs::path> vImportFiles)\n     // scan for better chains in the block chain database, that are not yet connected in the active best chain\n     CValidationState state;\n     if (!ActivateBestChain(state, chainparams)) {\n-        LogPrintf(\"Failed to connect best block\");\n+        LogPrintf(\"Failed to connect best block (%s)\\n\", FormatStateMessage(state));\n         StartShutdown();\n         return;\n     }\n@@ -693,15 +677,15 @@ void ThreadImport(std::vector<fs::path> vImportFiles)\n     } // End scope of CImportingNow\n     if (gArgs.GetArg(\"-persistmempool\", DEFAULT_PERSIST_MEMPOOL)) {\n         LoadMempool();\n-        fDumpMempoolLater = !fRequestShutdown;\n     }\n+    g_is_mempool_loaded = !fRequestShutdown;\n }\n \n /** Sanity checks\n  *  Ensure that Bitcoin is running in a usable environment with all\n  *  necessary library support.\n  */\n-bool InitSanityCheck(void)\n+static bool InitSanityCheck(void)\n {\n     if(!ECC_InitSanityCheck()) {\n         InitError(\"Elliptic curve cryptography sanity check failure. Aborting.\");\n@@ -719,7 +703,7 @@ bool InitSanityCheck(void)\n     return true;\n }\n \n-bool AppInitServers()\n+static bool AppInitServers()\n {\n     RPCServer::OnStarted(&OnRPCStarted);\n     RPCServer::OnStopped(&OnRPCStopped);\n@@ -799,29 +783,39 @@ void InitParameterInteraction()\n             LogPrintf(\"%s: parameter interaction: -whitelistforcerelay=1 -> setting -whitelistrelay=1\\n\", __func__);\n     }\n \n-    if (gArgs.IsArgSet(\"-blockmaxsize\")) {\n-        unsigned int max_size = gArgs.GetArg(\"-blockmaxsize\", 0);\n-        if (gArgs.SoftSetArg(\"blockmaxweight\", strprintf(\"%d\", max_size * WITNESS_SCALE_FACTOR))) {\n-            LogPrintf(\"%s: parameter interaction: -blockmaxsize=%d -> setting -blockmaxweight=%d (-blockmaxsize is deprecated!)\\n\", __func__, max_size, max_size * WITNESS_SCALE_FACTOR);\n-        } else {\n-            LogPrintf(\"%s: Ignoring blockmaxsize setting which is overridden by blockmaxweight\", __func__);\n-        }\n-    }\n+    // Warn if network-specific options (-addnode, -connect, etc) are\n+    // specified in default section of config file, but not overridden\n+    // on the command line or in this network's section of the config file.\n+    gArgs.WarnForSectionOnlyArgs();\n }\n \n static std::string ResolveErrMsg(const char * const optname, const std::string& strBind)\n {\n     return strprintf(_(\"Cannot resolve -%s address: '%s'\"), optname, strBind);\n }\n \n+/**\n+ * Initialize global loggers.\n+ *\n+ * Note that this is called very early in the process lifetime, so you should be\n+ * careful about what global state you rely on here.\n+ */\n void InitLogging()\n {\n-    fPrintToConsole = gArgs.GetBoolArg(\"-printtoconsole\", false);\n-    fLogTimestamps = gArgs.GetBoolArg(\"-logtimestamps\", DEFAULT_LOGTIMESTAMPS);\n-    fLogTimeMicros = gArgs.GetBoolArg(\"-logtimemicros\", DEFAULT_LOGTIMEMICROS);\n+    g_logger->m_print_to_file = !gArgs.IsArgNegated(\"-debuglogfile\");\n+    g_logger->m_file_path = AbsPathForConfigVal(gArgs.GetArg(\"-debuglogfile\", DEFAULT_DEBUGLOGFILE));\n+\n+    // Add newlines to the logfile to distinguish this execution from the last\n+    // one; called before console logging is set up, so this is only sent to\n+    // debug.log.\n+    LogPrintf(\"\\n\\n\\n\\n\\n\");\n+\n+    g_logger->m_print_to_console = gArgs.GetBoolArg(\"-printtoconsole\", !gArgs.GetBoolArg(\"-daemon\", false));\n+    g_logger->m_log_timestamps = gArgs.GetBoolArg(\"-logtimestamps\", DEFAULT_LOGTIMESTAMPS);\n+    g_logger->m_log_time_micros = gArgs.GetBoolArg(\"-logtimemicros\", DEFAULT_LOGTIMEMICROS);\n+\n     fLogIPs = gArgs.GetBoolArg(\"-logips\", DEFAULT_LOGIPS);\n \n-    LogPrintf(\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\");\n     std::string version_string = FormatFullVersion();\n #ifdef DEBUG\n     version_string += \" (debug build)\";\n@@ -894,6 +888,8 @@ bool AppInitBasicSetup()\n \n     // Ignore SIGPIPE, otherwise it will bring the daemon down if the client closes unexpectedly\n     signal(SIGPIPE, SIG_IGN);\n+#else\n+    SetConsoleCtrlHandler(consoleCtrlHandler, true);\n #endif\n \n     std::set_new_handler(new_handler_terminate);\n@@ -908,6 +904,10 @@ bool AppInitParameterInteraction()\n \n     // also see: InitParameterInteraction()\n \n+    if (!fs::is_directory(GetBlocksDir(false))) {\n+        return InitError(strprintf(_(\"Specified blocks directory \\\"%s\\\" does not exist.\\n\"), gArgs.GetArg(\"-blocksdir\", \"\").c_str()));\n+    }\n+\n     // if using block pruning, then disallow txindex\n     if (gArgs.GetArg(\"-prune\", 0)) {\n         if (gArgs.GetBoolArg(\"-txindex\", DEFAULT_TXINDEX))\n@@ -943,24 +943,18 @@ bool AppInitParameterInteraction()\n         if (std::none_of(categories.begin(), categories.end(),\n             [](std::string cat){return cat == \"0\" || cat == \"none\";})) {\n             for (const auto& cat : categories) {\n-                uint32_t flag = 0;\n-                if (!GetLogCategory(&flag, &cat)) {\n+                if (!g_logger->EnableCategory(cat)) {\n                     InitWarning(strprintf(_(\"Unsupported logging category %s=%s.\"), \"-debug\", cat));\n-                    continue;\n                 }\n-                logCategories |= flag;\n             }\n         }\n     }\n \n     // Now remove the logging categories which were explicitly excluded\n     for (const std::string& cat : gArgs.GetArgs(\"-debugexclude\")) {\n-        uint32_t flag = 0;\n-        if (!GetLogCategory(&flag, &cat)) {\n+        if (!g_logger->DisableCategory(cat)) {\n             InitWarning(strprintf(_(\"Unsupported logging category %s=%s.\"), \"-debugexclude\", cat));\n-            continue;\n         }\n-        logCategories &= ~flag;\n     }\n \n     // Check for -debugnet\n@@ -1093,10 +1087,7 @@ bool AppInitParameterInteraction()\n         return InitError(strprintf(\"acceptnonstdtxn is not currently supported for %s chain\", chainparams.NetworkIDString()));\n     nBytesPerSigOp = gArgs.GetArg(\"-bytespersigop\", nBytesPerSigOp);\n \n-#ifdef ENABLE_WALLET\n-    if (!WalletParameterInteraction())\n-        return false;\n-#endif\n+    if (!g_wallet_init_interface.ParameterInteraction()) return false;\n \n     fIsBareMultisigStd = gArgs.GetBoolArg(\"-permitbaremultisig\", DEFAULT_PERMIT_BAREMULTISIG);\n     fAcceptDatacarrier = gArgs.GetBoolArg(\"-datacarrier\", DEFAULT_ACCEPT_DATACARRIER);\n@@ -1214,19 +1205,19 @@ bool AppInitMain()\n #ifndef WIN32\n     CreatePidFile(GetPidFile(), getpid());\n #endif\n-    if (gArgs.GetBoolArg(\"-shrinkdebugfile\", logCategories == BCLog::NONE)) {\n-        // Do this first since it both loads a bunch of debug.log into memory,\n-        // and because this needs to happen before any other debug.log printing\n-        ShrinkDebugFile();\n-    }\n-\n-    if (fPrintToDebugLog) {\n-        if (!OpenDebugLog()) {\n-            return InitError(strprintf(\"Could not open debug log file %s\", GetDebugLogPath().string()));\n+    if (g_logger->m_print_to_file) {\n+        if (gArgs.GetBoolArg(\"-shrinkdebugfile\", g_logger->DefaultShrinkDebugFile())) {\n+            // Do this first since it both loads a bunch of debug.log into memory,\n+            // and because this needs to happen before any other debug.log printing\n+            g_logger->ShrinkDebugFile();\n+        }\n+        if (!g_logger->OpenDebugLog()) {\n+            return InitError(strprintf(\"Could not open debug log file %s\",\n+                                       g_logger->m_file_path.string()));\n         }\n     }\n \n-    if (!fLogTimestamps)\n+    if (!g_logger->m_log_timestamps)\n         LogPrintf(\"Startup time: %s\\n\", FormatISO8601DateTime(GetTime()));\n     LogPrintf(\"Default data directory %s\\n\", GetDefaultDataDir().string());\n     LogPrintf(\"Using data directory %s\\n\", GetDataDir().string());\n@@ -1235,7 +1226,7 @@ bool AppInitMain()\n \n     // Warn about relative -datadir path.\n     if (gArgs.IsArgSet(\"-datadir\") && !fs::path(gArgs.GetArg(\"-datadir\", \"\")).is_absolute()) {\n-        LogPrintf(\"Warning: relative datadir option '%s' specified, which will be interpreted relative to the \"\n+        LogPrintf(\"Warning: relative datadir option '%s' specified, which will be interpreted relative to the \" /* Continued */\n                   \"current working directory '%s'. This is fragile, because if bitcoin is started in the future \"\n                   \"from a different location, it will be unable to locate the current data files. There could \"\n                   \"also be data loss if bitcoin is started while in a temporary directory.\\n\",\n@@ -1262,9 +1253,7 @@ bool AppInitMain()\n      * available in the GUI RPC console even if external calls are disabled.\n      */\n     RegisterAllCoreRPCCommands(tableRPC);\n-#ifdef ENABLE_WALLET\n-    RegisterWalletRPC(tableRPC);\n-#endif\n+    g_wallet_init_interface.RegisterRPC(tableRPC);\n \n     /* Start the RPC server already.  It will be started in \"warmup\" mode\n      * and not really process calls already (but it will signify connections\n@@ -1281,10 +1270,8 @@ bool AppInitMain()\n     int64_t nStart;\n \n     // ********************************************************* Step 5: verify wallet database integrity\n-#ifdef ENABLE_WALLET\n-    if (!VerifyWallets())\n-        return false;\n-#endif\n+    if (!g_wallet_init_interface.Verify()) return false;\n+\n     // ********************************************************* Step 6: network initialization\n     // Note that we absolutely cannot open any actual connections\n     // until the very end (\"start node\") as the UTXO/block state\n@@ -1407,16 +1394,20 @@ bool AppInitMain()\n     int64_t nTotalCache = (gArgs.GetArg(\"-dbcache\", nDefaultDbCache) << 20);\n     nTotalCache = std::max(nTotalCache, nMinDbCache << 20); // total cache cannot be less than nMinDbCache\n     nTotalCache = std::min(nTotalCache, nMaxDbCache << 20); // total cache cannot be greater than nMaxDbcache\n-    int64_t nBlockTreeDBCache = nTotalCache / 8;\n-    nBlockTreeDBCache = std::min(nBlockTreeDBCache, (gArgs.GetBoolArg(\"-txindex\", DEFAULT_TXINDEX) ? nMaxBlockDBAndTxIndexCache : nMaxBlockDBCache) << 20);\n+    int64_t nBlockTreeDBCache = std::min(nTotalCache / 8, nMaxBlockDBCache << 20);\n     nTotalCache -= nBlockTreeDBCache;\n+    int64_t nTxIndexCache = std::min(nTotalCache / 8, gArgs.GetBoolArg(\"-txindex\", DEFAULT_TXINDEX) ? nMaxTxIndexCache << 20 : 0);\n+    nTotalCache -= nTxIndexCache;\n     int64_t nCoinDBCache = std::min(nTotalCache / 2, (nTotalCache / 4) + (1 << 23)); // use 25%-50% of the remainder for disk cache\n     nCoinDBCache = std::min(nCoinDBCache, nMaxCoinsDBCache << 20); // cap total coins db cache\n     nTotalCache -= nCoinDBCache;\n     nCoinCacheUsage = nTotalCache; // the rest goes to in-memory cache\n     int64_t nMempoolSizeMax = gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;\n     LogPrintf(\"Cache configuration:\\n\");\n     LogPrintf(\"* Using %.1fMiB for block index database\\n\", nBlockTreeDBCache * (1.0 / 1024 / 1024));\n+    if (gArgs.GetBoolArg(\"-txindex\", DEFAULT_TXINDEX)) {\n+        LogPrintf(\"* Using %.1fMiB for transaction index database\\n\", nTxIndexCache * (1.0 / 1024 / 1024));\n+    }\n     LogPrintf(\"* Using %.1fMiB for chain state database\\n\", nCoinDBCache * (1.0 / 1024 / 1024));\n     LogPrintf(\"* Using %.1fMiB for in-memory UTXO set (plus up to %.1fMiB of unused mempool space)\\n\", nCoinCacheUsage * (1.0 / 1024 / 1024), nMempoolSizeMax * (1.0 / 1024 / 1024));\n \n@@ -1450,9 +1441,8 @@ bool AppInitMain()\n \n                 if (fRequestShutdown) break;\n \n-                // LoadBlockIndex will load fTxIndex from the db, or set it if\n-                // we're reindexing. It will also load fHavePruned if we've\n-                // ever removed a block file from disk.\n+                // LoadBlockIndex will load fHavePruned if we've ever removed a\n+                // block file from disk.\n                 // Note that it also sets fReindex based on the disk flag!\n                 // From here on out fReindex and fReset mean something different!\n                 if (!LoadBlockIndex(chainparams)) {\n@@ -1466,12 +1456,6 @@ bool AppInitMain()\n                     return InitError(_(\"Incorrect or no genesis block found. Wrong datadir for network?\"));\n                 }\n \n-                // Check for changed -txindex state\n-                if (fTxIndex != gArgs.GetBoolArg(\"-txindex\", DEFAULT_TXINDEX)) {\n-                    strLoadError = _(\"You need to rebuild the database using -reindex to change -txindex\");\n-                    break;\n-                }\n-\n                 // Check for changed -prune state.  What we are concerned about is a user who has pruned blocks\n                 // in the past, but is now trying to run unpruned.\n                 if (fHavePruned && !fPruneMode) {\n@@ -1601,15 +1585,17 @@ bool AppInitMain()\n         ::feeEstimator.Read(est_filein);\n     fFeeEstimatesInitialized = true;\n \n-    // ********************************************************* Step 8: load wallet\n-#ifdef ENABLE_WALLET\n-    if (!OpenWallets())\n-        return false;\n-#else\n-    LogPrintf(\"No wallet support compiled in!\\n\");\n-#endif\n+    // ********************************************************* Step 8: start indexers\n+    if (gArgs.GetBoolArg(\"-txindex\", DEFAULT_TXINDEX)) {\n+        auto txindex_db = MakeUnique<TxIndexDB>(nTxIndexCache, false, fReindex);\n+        g_txindex = MakeUnique<TxIndex>(std::move(txindex_db));\n+        g_txindex->Start();\n+    }\n+\n+    // ********************************************************* Step 9: load wallet\n+    if (!g_wallet_init_interface.Open()) return false;\n \n-    // ********************************************************* Step 9: data directory maintenance\n+    // ********************************************************* Step 10: data directory maintenance\n \n     // if pruning, unset the service bit and perform the initial blockstore prune\n     // after any wallet rescanning has taken place.\n@@ -1631,9 +1617,9 @@ bool AppInitMain()\n         nLocalServices = ServiceFlags(nLocalServices | NODE_WITNESS);\n     }\n \n-    // ********************************************************* Step 10: import blocks\n+    // ********************************************************* Step 11: import blocks\n \n-    if (!CheckDiskSpace())\n+    if (!CheckDiskSpace() && !CheckDiskSpace(0, true))\n         return false;\n \n     // Either install a handler to notify us when genesis activates, or set fHaveGenesis directly.\n@@ -1670,7 +1656,7 @@ bool AppInitMain()\n         return false;\n     }\n \n-    // ********************************************************* Step 11: start node\n+    // ********************************************************* Step 12: start node\n \n     int chain_active_height;\n \n@@ -1748,14 +1734,12 @@ bool AppInitMain()\n         return false;\n     }\n \n-    // ********************************************************* Step 12: finished\n+    // ********************************************************* Step 13: finished\n \n     SetRPCWarmupFinished();\n     uiInterface.InitMessage(_(\"Done loading\"));\n \n-#ifdef ENABLE_WALLET\n-    StartWallets(scheduler);\n-#endif\n+    g_wallet_init_interface.Start(scheduler);\n \n     return true;\n }"
      },
      {
        "sha": "5423a042a668a69c6f8493297ed7e99a121c2db1",
        "filename": "src/init.h",
        "status": "modified",
        "additions": 9,
        "deletions": 7,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/init.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/init.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -6,11 +6,16 @@\n #ifndef BITCOIN_INIT_H\n #define BITCOIN_INIT_H\n \n+#include <memory>\n #include <string>\n+#include <util.h>\n \n class CScheduler;\n class CWallet;\n \n+class WalletInitInterface;\n+extern const WalletInitInterface& g_wallet_init_interface;\n+\n namespace boost\n {\n class thread_group;\n@@ -56,14 +61,11 @@ bool AppInitLockDataDirectory();\n  */\n bool AppInitMain();\n \n-/** The help message mode determines what help message to show */\n-enum HelpMessageMode {\n-    HMM_BITCOIND,\n-    HMM_BITCOIN_QT\n-};\n+/**\n+ * Setup the arguments for gArgs\n+ */\n+void SetupServerArgs();\n \n-/** Help for options shared between UI and daemon (for -help) */\n-std::string HelpMessage(HelpMessageMode mode);\n /** Returns licensing information (for -version) */\n std::string LicenseInfo();\n "
      },
      {
        "sha": "e93b91d23ceadcc929bd720a5a612cf10aec845e",
        "filename": "src/interfaces/README.md",
        "status": "added",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/interfaces/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/interfaces/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/README.md?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -0,0 +1,17 @@\n+# Internal c++ interfaces\n+\n+The following interfaces are defined here:\n+\n+* [`Chain`](chain.h) \u2014 used by wallet to access blockchain and mempool state. Added in [#10973](https://github.com/bitcoin/bitcoin/pull/10973).\n+\n+* [`Chain::Client`](chain.h) \u2014 used by node to start & stop `Chain` clients. Added in [#10973](https://github.com/bitcoin/bitcoin/pull/10973).\n+\n+* [`Node`](node.h) \u2014 used by GUI to start & stop bitcoin node. Added in [#10244](https://github.com/bitcoin/bitcoin/pull/10244).\n+\n+* [`Wallet`](wallet.h) \u2014 used by GUI to access wallets. Added in [#10244](https://github.com/bitcoin/bitcoin/pull/10244).\n+\n+* [`Handler`](handler.h) \u2014 returned by `handleEvent` methods on interfaces above and used to manage lifetimes of event handlers.\n+\n+* [`Init`](init.h) \u2014 used by multiprocess code to access interfaces above on startup. Added in [#10102](https://github.com/bitcoin/bitcoin/pull/10102).\n+\n+The interfaces above define boundaries between major components of bitcoin code (node, wallet, and gui), making it possible for them to run in different processes, and be tested, developed, and understood independently. These interfaces are not currently designed to be stable or to be used externally."
      },
      {
        "sha": "8e45faa2a51f91eda20ee7b0fb9667631d441713",
        "filename": "src/interfaces/handler.cpp",
        "status": "added",
        "additions": 32,
        "deletions": 0,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/interfaces/handler.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/interfaces/handler.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/handler.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -0,0 +1,32 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <interfaces/handler.h>\n+\n+#include <util.h>\n+\n+#include <boost/signals2/connection.hpp>\n+#include <utility>\n+\n+namespace interfaces {\n+namespace {\n+\n+class HandlerImpl : public Handler\n+{\n+public:\n+    HandlerImpl(boost::signals2::connection connection) : m_connection(std::move(connection)) {}\n+\n+    void disconnect() override { m_connection.disconnect(); }\n+\n+    boost::signals2::scoped_connection m_connection;\n+};\n+\n+} // namespace\n+\n+std::unique_ptr<Handler> MakeHandler(boost::signals2::connection connection)\n+{\n+    return MakeUnique<HandlerImpl>(std::move(connection));\n+}\n+\n+} // namespace interfaces"
      },
      {
        "sha": "c4c674cac5aebcb842585cf163bdd2a31f0424c9",
        "filename": "src/interfaces/handler.h",
        "status": "added",
        "additions": 35,
        "deletions": 0,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/interfaces/handler.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/interfaces/handler.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/handler.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -0,0 +1,35 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INTERFACES_HANDLER_H\n+#define BITCOIN_INTERFACES_HANDLER_H\n+\n+#include <memory>\n+\n+namespace boost {\n+namespace signals2 {\n+class connection;\n+} // namespace signals2\n+} // namespace boost\n+\n+namespace interfaces {\n+\n+//! Generic interface for managing an event handler or callback function\n+//! registered with another interface. Has a single disconnect method to cancel\n+//! the registration and prevent any future notifications.\n+class Handler\n+{\n+public:\n+    virtual ~Handler() {}\n+\n+    //! Disconnect the handler.\n+    virtual void disconnect() = 0;\n+};\n+\n+//! Return handler wrapping a boost signal connection.\n+std::unique_ptr<Handler> MakeHandler(boost::signals2::connection connection);\n+\n+} // namespace interfaces\n+\n+#endif // BITCOIN_INTERFACES_HANDLER_H"
      },
      {
        "sha": "73657d4f5a60d407728bd27dd908c586245d7a3f",
        "filename": "src/interfaces/node.cpp",
        "status": "added",
        "additions": 291,
        "deletions": 0,
        "changes": 291,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/interfaces/node.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/interfaces/node.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/node.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -0,0 +1,291 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <interfaces/node.h>\n+\n+#include <addrdb.h>\n+#include <amount.h>\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <init.h>\n+#include <interfaces/handler.h>\n+#include <interfaces/wallet.h>\n+#include <net.h>\n+#include <net_processing.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <policy/feerate.h>\n+#include <policy/fees.h>\n+#include <policy/policy.h>\n+#include <primitives/block.h>\n+#include <rpc/server.h>\n+#include <scheduler.h>\n+#include <sync.h>\n+#include <txmempool.h>\n+#include <ui_interface.h>\n+#include <util.h>\n+#include <validation.h>\n+#include <warnings.h>\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+#ifdef ENABLE_WALLET\n+#include <wallet/fees.h>\n+#include <wallet/wallet.h>\n+#define CHECK_WALLET(x) x\n+#else\n+#define CHECK_WALLET(x) throw std::logic_error(\"Wallet function called in non-wallet build.\")\n+#endif\n+\n+#include <atomic>\n+#include <boost/thread/thread.hpp>\n+#include <univalue.h>\n+\n+namespace interfaces {\n+namespace {\n+\n+class NodeImpl : public Node\n+{\n+    void parseParameters(int argc, const char* const argv[]) override\n+    {\n+        gArgs.ParseParameters(argc, argv);\n+    }\n+    void readConfigFiles() override { gArgs.ReadConfigFiles(); }\n+    bool softSetArg(const std::string& arg, const std::string& value) override { return gArgs.SoftSetArg(arg, value); }\n+    bool softSetBoolArg(const std::string& arg, bool value) override { return gArgs.SoftSetBoolArg(arg, value); }\n+    void selectParams(const std::string& network) override { SelectParams(network); }\n+    std::string getNetwork() override { return Params().NetworkIDString(); }\n+    void initLogging() override { InitLogging(); }\n+    void initParameterInteraction() override { InitParameterInteraction(); }\n+    std::string getWarnings(const std::string& type) override { return GetWarnings(type); }\n+    uint32_t getLogCategories() override { return g_logger->GetCategoryMask(); }\n+    bool baseInitialize() override\n+    {\n+        return AppInitBasicSetup() && AppInitParameterInteraction() && AppInitSanityChecks() &&\n+               AppInitLockDataDirectory();\n+    }\n+    bool appInitMain() override { return AppInitMain(); }\n+    void appShutdown() override\n+    {\n+        Interrupt();\n+        Shutdown();\n+    }\n+    void startShutdown() override { StartShutdown(); }\n+    bool shutdownRequested() override { return ShutdownRequested(); }\n+    void mapPort(bool use_upnp) override\n+    {\n+        if (use_upnp) {\n+            StartMapPort();\n+        } else {\n+            InterruptMapPort();\n+            StopMapPort();\n+        }\n+    }\n+    void setupServerArgs() override { return SetupServerArgs(); }\n+    bool getProxy(Network net, proxyType& proxy_info) override { return GetProxy(net, proxy_info); }\n+    size_t getNodeCount(CConnman::NumConnections flags) override\n+    {\n+        return g_connman ? g_connman->GetNodeCount(flags) : 0;\n+    }\n+    bool getNodesStats(NodesStats& stats) override\n+    {\n+        stats.clear();\n+\n+        if (g_connman) {\n+            std::vector<CNodeStats> stats_temp;\n+            g_connman->GetNodeStats(stats_temp);\n+\n+            stats.reserve(stats_temp.size());\n+            for (auto& node_stats_temp : stats_temp) {\n+                stats.emplace_back(std::move(node_stats_temp), false, CNodeStateStats());\n+            }\n+\n+            // Try to retrieve the CNodeStateStats for each node.\n+            TRY_LOCK(::cs_main, lockMain);\n+            if (lockMain) {\n+                for (auto& node_stats : stats) {\n+                    std::get<1>(node_stats) =\n+                        GetNodeStateStats(std::get<0>(node_stats).nodeid, std::get<2>(node_stats));\n+                }\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+    bool getBanned(banmap_t& banmap) override\n+    {\n+        if (g_connman) {\n+            g_connman->GetBanned(banmap);\n+            return true;\n+        }\n+        return false;\n+    }\n+    bool ban(const CNetAddr& net_addr, BanReason reason, int64_t ban_time_offset) override\n+    {\n+        if (g_connman) {\n+            g_connman->Ban(net_addr, reason, ban_time_offset);\n+            return true;\n+        }\n+        return false;\n+    }\n+    bool unban(const CSubNet& ip) override\n+    {\n+        if (g_connman) {\n+            g_connman->Unban(ip);\n+            return true;\n+        }\n+        return false;\n+    }\n+    bool disconnect(NodeId id) override\n+    {\n+        if (g_connman) {\n+            return g_connman->DisconnectNode(id);\n+        }\n+        return false;\n+    }\n+    int64_t getTotalBytesRecv() override { return g_connman ? g_connman->GetTotalBytesRecv() : 0; }\n+    int64_t getTotalBytesSent() override { return g_connman ? g_connman->GetTotalBytesSent() : 0; }\n+    size_t getMempoolSize() override { return ::mempool.size(); }\n+    size_t getMempoolDynamicUsage() override { return ::mempool.DynamicMemoryUsage(); }\n+    bool getHeaderTip(int& height, int64_t& block_time) override\n+    {\n+        LOCK(::cs_main);\n+        if (::pindexBestHeader) {\n+            height = ::pindexBestHeader->nHeight;\n+            block_time = ::pindexBestHeader->GetBlockTime();\n+            return true;\n+        }\n+        return false;\n+    }\n+    int getNumBlocks() override\n+    {\n+        LOCK(::cs_main);\n+        return ::chainActive.Height();\n+    }\n+    int64_t getLastBlockTime() override\n+    {\n+        LOCK(::cs_main);\n+        if (::chainActive.Tip()) {\n+            return ::chainActive.Tip()->GetBlockTime();\n+        }\n+        return Params().GenesisBlock().GetBlockTime(); // Genesis block's time of current network\n+    }\n+    double getVerificationProgress() override\n+    {\n+        const CBlockIndex* tip;\n+        {\n+            LOCK(::cs_main);\n+            tip = ::chainActive.Tip();\n+        }\n+        return GuessVerificationProgress(Params().TxData(), tip);\n+    }\n+    bool isInitialBlockDownload() override { return IsInitialBlockDownload(); }\n+    bool getReindex() override { return ::fReindex; }\n+    bool getImporting() override { return ::fImporting; }\n+    void setNetworkActive(bool active) override\n+    {\n+        if (g_connman) {\n+            g_connman->SetNetworkActive(active);\n+        }\n+    }\n+    bool getNetworkActive() override { return g_connman && g_connman->GetNetworkActive(); }\n+    CAmount getMaxTxFee() override { return ::maxTxFee; }\n+    CFeeRate estimateSmartFee(int num_blocks, bool conservative, int* returned_target = nullptr) override\n+    {\n+        FeeCalculation fee_calc;\n+        CFeeRate result = ::feeEstimator.estimateSmartFee(num_blocks, &fee_calc, conservative);\n+        if (returned_target) {\n+            *returned_target = fee_calc.returnedTarget;\n+        }\n+        return result;\n+    }\n+    CFeeRate getDustRelayFee() override { return ::dustRelayFee; }\n+    UniValue executeRpc(const std::string& command, const UniValue& params, const std::string& uri) override\n+    {\n+        JSONRPCRequest req;\n+        req.params = params;\n+        req.strMethod = command;\n+        req.URI = uri;\n+        return ::tableRPC.execute(req);\n+    }\n+    std::vector<std::string> listRpcCommands() override { return ::tableRPC.listCommands(); }\n+    void rpcSetTimerInterfaceIfUnset(RPCTimerInterface* iface) override { RPCSetTimerInterfaceIfUnset(iface); }\n+    void rpcUnsetTimerInterface(RPCTimerInterface* iface) override { RPCUnsetTimerInterface(iface); }\n+    bool getUnspentOutput(const COutPoint& output, Coin& coin) override\n+    {\n+        LOCK(::cs_main);\n+        return ::pcoinsTip->GetCoin(output, coin);\n+    }\n+    std::vector<std::unique_ptr<Wallet>> getWallets() override\n+    {\n+#ifdef ENABLE_WALLET\n+        std::vector<std::unique_ptr<Wallet>> wallets;\n+        for (CWallet* wallet : GetWallets()) {\n+            wallets.emplace_back(MakeWallet(*wallet));\n+        }\n+        return wallets;\n+#else\n+        throw std::logic_error(\"Node::getWallets() called in non-wallet build.\");\n+#endif\n+    }\n+    std::unique_ptr<Handler> handleInitMessage(InitMessageFn fn) override\n+    {\n+        return MakeHandler(::uiInterface.InitMessage.connect(fn));\n+    }\n+    std::unique_ptr<Handler> handleMessageBox(MessageBoxFn fn) override\n+    {\n+        return MakeHandler(::uiInterface.ThreadSafeMessageBox.connect(fn));\n+    }\n+    std::unique_ptr<Handler> handleQuestion(QuestionFn fn) override\n+    {\n+        return MakeHandler(::uiInterface.ThreadSafeQuestion.connect(fn));\n+    }\n+    std::unique_ptr<Handler> handleShowProgress(ShowProgressFn fn) override\n+    {\n+        return MakeHandler(::uiInterface.ShowProgress.connect(fn));\n+    }\n+    std::unique_ptr<Handler> handleLoadWallet(LoadWalletFn fn) override\n+    {\n+        CHECK_WALLET(\n+            return MakeHandler(::uiInterface.LoadWallet.connect([fn](CWallet* wallet) { fn(MakeWallet(*wallet)); })));\n+    }\n+    std::unique_ptr<Handler> handleNotifyNumConnectionsChanged(NotifyNumConnectionsChangedFn fn) override\n+    {\n+        return MakeHandler(::uiInterface.NotifyNumConnectionsChanged.connect(fn));\n+    }\n+    std::unique_ptr<Handler> handleNotifyNetworkActiveChanged(NotifyNetworkActiveChangedFn fn) override\n+    {\n+        return MakeHandler(::uiInterface.NotifyNetworkActiveChanged.connect(fn));\n+    }\n+    std::unique_ptr<Handler> handleNotifyAlertChanged(NotifyAlertChangedFn fn) override\n+    {\n+        return MakeHandler(::uiInterface.NotifyAlertChanged.connect(fn));\n+    }\n+    std::unique_ptr<Handler> handleBannedListChanged(BannedListChangedFn fn) override\n+    {\n+        return MakeHandler(::uiInterface.BannedListChanged.connect(fn));\n+    }\n+    std::unique_ptr<Handler> handleNotifyBlockTip(NotifyBlockTipFn fn) override\n+    {\n+        return MakeHandler(::uiInterface.NotifyBlockTip.connect([fn](bool initial_download, const CBlockIndex* block) {\n+            fn(initial_download, block->nHeight, block->GetBlockTime(),\n+                GuessVerificationProgress(Params().TxData(), block));\n+        }));\n+    }\n+    std::unique_ptr<Handler> handleNotifyHeaderTip(NotifyHeaderTipFn fn) override\n+    {\n+        return MakeHandler(\n+            ::uiInterface.NotifyHeaderTip.connect([fn](bool initial_download, const CBlockIndex* block) {\n+                fn(initial_download, block->nHeight, block->GetBlockTime(),\n+                    GuessVerificationProgress(Params().TxData(), block));\n+            }));\n+    }\n+};\n+\n+} // namespace\n+\n+std::unique_ptr<Node> MakeNode() { return MakeUnique<NodeImpl>(); }\n+\n+} // namespace interfaces"
      },
      {
        "sha": "2a1a8152dfccf96c281f716e21487ce5f064cd1d",
        "filename": "src/interfaces/node.h",
        "status": "added",
        "additions": 235,
        "deletions": 0,
        "changes": 235,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/interfaces/node.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/interfaces/node.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/node.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -0,0 +1,235 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INTERFACES_NODE_H\n+#define BITCOIN_INTERFACES_NODE_H\n+\n+#include <addrdb.h>     // For banmap_t\n+#include <amount.h>     // For CAmount\n+#include <net.h>        // For CConnman::NumConnections\n+#include <netaddress.h> // For Network\n+\n+#include <functional>\n+#include <memory>\n+#include <stddef.h>\n+#include <stdint.h>\n+#include <string>\n+#include <tuple>\n+#include <vector>\n+\n+class CCoinControl;\n+class CFeeRate;\n+class CNodeStats;\n+class Coin;\n+class RPCTimerInterface;\n+class UniValue;\n+class proxyType;\n+struct CNodeStateStats;\n+\n+namespace interfaces {\n+class Handler;\n+class Wallet;\n+\n+//! Top-level interface for a bitcoin node (bitcoind process).\n+class Node\n+{\n+public:\n+    virtual ~Node() {}\n+\n+    //! Set command line arguments.\n+    virtual void parseParameters(int argc, const char* const argv[]) = 0;\n+\n+    //! Set a command line argument if it doesn't already have a value\n+    virtual bool softSetArg(const std::string& arg, const std::string& value) = 0;\n+\n+    //! Set a command line boolean argument if it doesn't already have a value\n+    virtual bool softSetBoolArg(const std::string& arg, bool value) = 0;\n+\n+    //! Load settings from configuration file.\n+    virtual void readConfigFiles() = 0;\n+\n+    //! Choose network parameters.\n+    virtual void selectParams(const std::string& network) = 0;\n+\n+    //! Get network name.\n+    virtual std::string getNetwork() = 0;\n+\n+    //! Init logging.\n+    virtual void initLogging() = 0;\n+\n+    //! Init parameter interaction.\n+    virtual void initParameterInteraction() = 0;\n+\n+    //! Get warnings.\n+    virtual std::string getWarnings(const std::string& type) = 0;\n+\n+    // Get log flags.\n+    virtual uint32_t getLogCategories() = 0;\n+\n+    //! Initialize app dependencies.\n+    virtual bool baseInitialize() = 0;\n+\n+    //! Start node.\n+    virtual bool appInitMain() = 0;\n+\n+    //! Stop node.\n+    virtual void appShutdown() = 0;\n+\n+    //! Start shutdown.\n+    virtual void startShutdown() = 0;\n+\n+    //! Return whether shutdown was requested.\n+    virtual bool shutdownRequested() = 0;\n+\n+    //! Setup arguments\n+    virtual void setupServerArgs() = 0;\n+\n+    //! Map port.\n+    virtual void mapPort(bool use_upnp) = 0;\n+\n+    //! Get proxy.\n+    virtual bool getProxy(Network net, proxyType& proxy_info) = 0;\n+\n+    //! Get number of connections.\n+    virtual size_t getNodeCount(CConnman::NumConnections flags) = 0;\n+\n+    //! Get stats for connected nodes.\n+    using NodesStats = std::vector<std::tuple<CNodeStats, bool, CNodeStateStats>>;\n+    virtual bool getNodesStats(NodesStats& stats) = 0;\n+\n+    //! Get ban map entries.\n+    virtual bool getBanned(banmap_t& banmap) = 0;\n+\n+    //! Ban node.\n+    virtual bool ban(const CNetAddr& net_addr, BanReason reason, int64_t ban_time_offset) = 0;\n+\n+    //! Unban node.\n+    virtual bool unban(const CSubNet& ip) = 0;\n+\n+    //! Disconnect node.\n+    virtual bool disconnect(NodeId id) = 0;\n+\n+    //! Get total bytes recv.\n+    virtual int64_t getTotalBytesRecv() = 0;\n+\n+    //! Get total bytes sent.\n+    virtual int64_t getTotalBytesSent() = 0;\n+\n+    //! Get mempool size.\n+    virtual size_t getMempoolSize() = 0;\n+\n+    //! Get mempool dynamic usage.\n+    virtual size_t getMempoolDynamicUsage() = 0;\n+\n+    //! Get header tip height and time.\n+    virtual bool getHeaderTip(int& height, int64_t& block_time) = 0;\n+\n+    //! Get num blocks.\n+    virtual int getNumBlocks() = 0;\n+\n+    //! Get last block time.\n+    virtual int64_t getLastBlockTime() = 0;\n+\n+    //! Get verification progress.\n+    virtual double getVerificationProgress() = 0;\n+\n+    //! Is initial block download.\n+    virtual bool isInitialBlockDownload() = 0;\n+\n+    //! Get reindex.\n+    virtual bool getReindex() = 0;\n+\n+    //! Get importing.\n+    virtual bool getImporting() = 0;\n+\n+    //! Set network active.\n+    virtual void setNetworkActive(bool active) = 0;\n+\n+    //! Get network active.\n+    virtual bool getNetworkActive() = 0;\n+\n+    //! Get max tx fee.\n+    virtual CAmount getMaxTxFee() = 0;\n+\n+    //! Estimate smart fee.\n+    virtual CFeeRate estimateSmartFee(int num_blocks, bool conservative, int* returned_target = nullptr) = 0;\n+\n+    //! Get dust relay fee.\n+    virtual CFeeRate getDustRelayFee() = 0;\n+\n+    //! Execute rpc command.\n+    virtual UniValue executeRpc(const std::string& command, const UniValue& params, const std::string& uri) = 0;\n+\n+    //! List rpc commands.\n+    virtual std::vector<std::string> listRpcCommands() = 0;\n+\n+    //! Set RPC timer interface if unset.\n+    virtual void rpcSetTimerInterfaceIfUnset(RPCTimerInterface* iface) = 0;\n+\n+    //! Unset RPC timer interface.\n+    virtual void rpcUnsetTimerInterface(RPCTimerInterface* iface) = 0;\n+\n+    //! Get unspent outputs associated with a transaction.\n+    virtual bool getUnspentOutput(const COutPoint& output, Coin& coin) = 0;\n+\n+    //! Return interfaces for accessing wallets (if any).\n+    virtual std::vector<std::unique_ptr<Wallet>> getWallets() = 0;\n+\n+    //! Register handler for init messages.\n+    using InitMessageFn = std::function<void(const std::string& message)>;\n+    virtual std::unique_ptr<Handler> handleInitMessage(InitMessageFn fn) = 0;\n+\n+    //! Register handler for message box messages.\n+    using MessageBoxFn =\n+        std::function<bool(const std::string& message, const std::string& caption, unsigned int style)>;\n+    virtual std::unique_ptr<Handler> handleMessageBox(MessageBoxFn fn) = 0;\n+\n+    //! Register handler for question messages.\n+    using QuestionFn = std::function<bool(const std::string& message,\n+        const std::string& non_interactive_message,\n+        const std::string& caption,\n+        unsigned int style)>;\n+    virtual std::unique_ptr<Handler> handleQuestion(QuestionFn fn) = 0;\n+\n+    //! Register handler for progress messages.\n+    using ShowProgressFn = std::function<void(const std::string& title, int progress, bool resume_possible)>;\n+    virtual std::unique_ptr<Handler> handleShowProgress(ShowProgressFn fn) = 0;\n+\n+    //! Register handler for load wallet messages.\n+    using LoadWalletFn = std::function<void(std::unique_ptr<Wallet> wallet)>;\n+    virtual std::unique_ptr<Handler> handleLoadWallet(LoadWalletFn fn) = 0;\n+\n+    //! Register handler for number of connections changed messages.\n+    using NotifyNumConnectionsChangedFn = std::function<void(int new_num_connections)>;\n+    virtual std::unique_ptr<Handler> handleNotifyNumConnectionsChanged(NotifyNumConnectionsChangedFn fn) = 0;\n+\n+    //! Register handler for network active messages.\n+    using NotifyNetworkActiveChangedFn = std::function<void(bool network_active)>;\n+    virtual std::unique_ptr<Handler> handleNotifyNetworkActiveChanged(NotifyNetworkActiveChangedFn fn) = 0;\n+\n+    //! Register handler for notify alert messages.\n+    using NotifyAlertChangedFn = std::function<void()>;\n+    virtual std::unique_ptr<Handler> handleNotifyAlertChanged(NotifyAlertChangedFn fn) = 0;\n+\n+    //! Register handler for ban list messages.\n+    using BannedListChangedFn = std::function<void()>;\n+    virtual std::unique_ptr<Handler> handleBannedListChanged(BannedListChangedFn fn) = 0;\n+\n+    //! Register handler for block tip messages.\n+    using NotifyBlockTipFn =\n+        std::function<void(bool initial_download, int height, int64_t block_time, double verification_progress)>;\n+    virtual std::unique_ptr<Handler> handleNotifyBlockTip(NotifyBlockTipFn fn) = 0;\n+\n+    //! Register handler for header tip messages.\n+    using NotifyHeaderTipFn =\n+        std::function<void(bool initial_download, int height, int64_t block_time, double verification_progress)>;\n+    virtual std::unique_ptr<Handler> handleNotifyHeaderTip(NotifyHeaderTipFn fn) = 0;\n+};\n+\n+//! Return implementation of Node interface.\n+std::unique_ptr<Node> MakeNode();\n+\n+} // namespace interfaces\n+\n+#endif // BITCOIN_INTERFACES_NODE_H"
      },
      {
        "sha": "63b9d80a92ce5501f6b46bf368f4e7158ff86a74",
        "filename": "src/interfaces/wallet.cpp",
        "status": "added",
        "additions": 463,
        "deletions": 0,
        "changes": 463,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/interfaces/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/interfaces/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/wallet.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -0,0 +1,463 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <interfaces/wallet.h>\n+\n+#include <amount.h>\n+#include <chain.h>\n+#include <consensus/validation.h>\n+#include <interfaces/handler.h>\n+#include <net.h>\n+#include <policy/feerate.h>\n+#include <policy/fees.h>\n+#include <policy/policy.h>\n+#include <primitives/transaction.h>\n+#include <script/ismine.h>\n+#include <script/standard.h>\n+#include <support/allocators/secure.h>\n+#include <sync.h>\n+#include <timedata.h>\n+#include <ui_interface.h>\n+#include <uint256.h>\n+#include <validation.h>\n+#include <wallet/feebumper.h>\n+#include <wallet/fees.h>\n+#include <wallet/wallet.h>\n+\n+namespace interfaces {\n+namespace {\n+\n+class PendingWalletTxImpl : public PendingWalletTx\n+{\n+public:\n+    PendingWalletTxImpl(CWallet& wallet) : m_wallet(wallet), m_key(&wallet) {}\n+\n+    const CTransaction& get() override { return *m_tx; }\n+\n+    int64_t getVirtualSize() override { return GetVirtualTransactionSize(*m_tx); }\n+\n+    bool commit(WalletValueMap value_map,\n+        WalletOrderForm order_form,\n+        std::string from_account,\n+        std::string& reject_reason) override\n+    {\n+        LOCK2(cs_main, m_wallet.cs_wallet);\n+        CValidationState state;\n+        if (!m_wallet.CommitTransaction(m_tx, std::move(value_map), std::move(order_form), std::move(from_account), m_key, g_connman.get(), state)) {\n+            reject_reason = state.GetRejectReason();\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    CTransactionRef m_tx;\n+    CWallet& m_wallet;\n+    CReserveKey m_key;\n+};\n+\n+//! Construct wallet tx struct.\n+WalletTx MakeWalletTx(CWallet& wallet, const CWalletTx& wtx)\n+{\n+    WalletTx result;\n+    result.tx = wtx.tx;\n+    result.txin_is_mine.reserve(wtx.tx->vin.size());\n+    for (const auto& txin : wtx.tx->vin) {\n+        result.txin_is_mine.emplace_back(wallet.IsMine(txin));\n+    }\n+    result.txout_is_mine.reserve(wtx.tx->vout.size());\n+    result.txout_address.reserve(wtx.tx->vout.size());\n+    result.txout_address_is_mine.reserve(wtx.tx->vout.size());\n+    for (const auto& txout : wtx.tx->vout) {\n+        result.txout_is_mine.emplace_back(wallet.IsMine(txout));\n+        result.txout_address.emplace_back();\n+        result.txout_address_is_mine.emplace_back(ExtractDestination(txout.scriptPubKey, result.txout_address.back()) ?\n+                                                      IsMine(wallet, result.txout_address.back()) :\n+                                                      ISMINE_NO);\n+    }\n+    result.credit = wtx.GetCredit(ISMINE_ALL);\n+    result.debit = wtx.GetDebit(ISMINE_ALL);\n+    result.change = wtx.GetChange();\n+    result.time = wtx.GetTxTime();\n+    result.value_map = wtx.mapValue;\n+    result.is_coinbase = wtx.IsCoinBase();\n+    return result;\n+}\n+\n+//! Construct wallet tx status struct.\n+WalletTxStatus MakeWalletTxStatus(const CWalletTx& wtx)\n+{\n+    WalletTxStatus result;\n+    auto mi = ::mapBlockIndex.find(wtx.hashBlock);\n+    CBlockIndex* block = mi != ::mapBlockIndex.end() ? mi->second : nullptr;\n+    result.block_height = (block ? block->nHeight : std::numeric_limits<int>::max()),\n+    result.blocks_to_maturity = wtx.GetBlocksToMaturity();\n+    result.depth_in_main_chain = wtx.GetDepthInMainChain();\n+    result.request_count = wtx.GetRequestCount();\n+    result.time_received = wtx.nTimeReceived;\n+    result.lock_time = wtx.tx->nLockTime;\n+    result.is_final = CheckFinalTx(*wtx.tx);\n+    result.is_trusted = wtx.IsTrusted();\n+    result.is_abandoned = wtx.isAbandoned();\n+    result.is_coinbase = wtx.IsCoinBase();\n+    result.is_in_main_chain = wtx.IsInMainChain();\n+    return result;\n+}\n+\n+//! Construct wallet TxOut struct.\n+WalletTxOut MakeWalletTxOut(CWallet& wallet, const CWalletTx& wtx, int n, int depth)\n+{\n+    WalletTxOut result;\n+    result.txout = wtx.tx->vout[n];\n+    result.time = wtx.GetTxTime();\n+    result.depth_in_main_chain = depth;\n+    result.is_spent = wallet.IsSpent(wtx.GetHash(), n);\n+    return result;\n+}\n+\n+class WalletImpl : public Wallet\n+{\n+public:\n+    WalletImpl(CWallet& wallet) : m_wallet(wallet) {}\n+\n+    bool encryptWallet(const SecureString& wallet_passphrase) override\n+    {\n+        return m_wallet.EncryptWallet(wallet_passphrase);\n+    }\n+    bool isCrypted() override { return m_wallet.IsCrypted(); }\n+    bool lock() override { return m_wallet.Lock(); }\n+    bool unlock(const SecureString& wallet_passphrase) override { return m_wallet.Unlock(wallet_passphrase); }\n+    bool isLocked() override { return m_wallet.IsLocked(); }\n+    bool changeWalletPassphrase(const SecureString& old_wallet_passphrase,\n+        const SecureString& new_wallet_passphrase) override\n+    {\n+        return m_wallet.ChangeWalletPassphrase(old_wallet_passphrase, new_wallet_passphrase);\n+    }\n+    void abortRescan() override { m_wallet.AbortRescan(); }\n+    bool backupWallet(const std::string& filename) override { return m_wallet.BackupWallet(filename); }\n+    std::string getWalletName() override { return m_wallet.GetName(); }\n+    bool getKeyFromPool(bool internal, CPubKey& pub_key) override\n+    {\n+        return m_wallet.GetKeyFromPool(pub_key, internal);\n+    }\n+    bool getPubKey(const CKeyID& address, CPubKey& pub_key) override { return m_wallet.GetPubKey(address, pub_key); }\n+    bool getPrivKey(const CKeyID& address, CKey& key) override { return m_wallet.GetKey(address, key); }\n+    bool isSpendable(const CTxDestination& dest) override { return IsMine(m_wallet, dest) & ISMINE_SPENDABLE; }\n+    bool haveWatchOnly() override { return m_wallet.HaveWatchOnly(); };\n+    bool setAddressBook(const CTxDestination& dest, const std::string& name, const std::string& purpose) override\n+    {\n+        return m_wallet.SetAddressBook(dest, name, purpose);\n+    }\n+    bool delAddressBook(const CTxDestination& dest) override\n+    {\n+        return m_wallet.DelAddressBook(dest);\n+    }\n+    bool getAddress(const CTxDestination& dest,\n+        std::string* name,\n+        isminetype* is_mine,\n+        std::string* purpose) override\n+    {\n+        LOCK(m_wallet.cs_wallet);\n+        auto it = m_wallet.mapAddressBook.find(dest);\n+        if (it == m_wallet.mapAddressBook.end()) {\n+            return false;\n+        }\n+        if (name) {\n+            *name = it->second.name;\n+        }\n+        if (is_mine) {\n+            *is_mine = IsMine(m_wallet, dest);\n+        }\n+        if (purpose) {\n+            *purpose = it->second.purpose;\n+        }\n+        return true;\n+    }\n+    std::vector<WalletAddress> getAddresses() override\n+    {\n+        LOCK(m_wallet.cs_wallet);\n+        std::vector<WalletAddress> result;\n+        for (const auto& item : m_wallet.mapAddressBook) {\n+            result.emplace_back(item.first, IsMine(m_wallet, item.first), item.second.name, item.second.purpose);\n+        }\n+        return result;\n+    }\n+    void learnRelatedScripts(const CPubKey& key, OutputType type) override { m_wallet.LearnRelatedScripts(key, type); }\n+    bool addDestData(const CTxDestination& dest, const std::string& key, const std::string& value) override\n+    {\n+        LOCK(m_wallet.cs_wallet);\n+        return m_wallet.AddDestData(dest, key, value);\n+    }\n+    bool eraseDestData(const CTxDestination& dest, const std::string& key) override\n+    {\n+        LOCK(m_wallet.cs_wallet);\n+        return m_wallet.EraseDestData(dest, key);\n+    }\n+    std::vector<std::string> getDestValues(const std::string& prefix) override\n+    {\n+        return m_wallet.GetDestValues(prefix);\n+    }\n+    void lockCoin(const COutPoint& output) override\n+    {\n+        LOCK2(cs_main, m_wallet.cs_wallet);\n+        return m_wallet.LockCoin(output);\n+    }\n+    void unlockCoin(const COutPoint& output) override\n+    {\n+        LOCK2(cs_main, m_wallet.cs_wallet);\n+        return m_wallet.UnlockCoin(output);\n+    }\n+    bool isLockedCoin(const COutPoint& output) override\n+    {\n+        LOCK2(cs_main, m_wallet.cs_wallet);\n+        return m_wallet.IsLockedCoin(output.hash, output.n);\n+    }\n+    void listLockedCoins(std::vector<COutPoint>& outputs) override\n+    {\n+        LOCK2(cs_main, m_wallet.cs_wallet);\n+        return m_wallet.ListLockedCoins(outputs);\n+    }\n+    std::unique_ptr<PendingWalletTx> createTransaction(const std::vector<CRecipient>& recipients,\n+        const CCoinControl& coin_control,\n+        bool sign,\n+        int& change_pos,\n+        CAmount& fee,\n+        std::string& fail_reason) override\n+    {\n+        LOCK2(cs_main, m_wallet.cs_wallet);\n+        auto pending = MakeUnique<PendingWalletTxImpl>(m_wallet);\n+        if (!m_wallet.CreateTransaction(recipients, pending->m_tx, pending->m_key, fee, change_pos,\n+                fail_reason, coin_control, sign)) {\n+            return {};\n+        }\n+        return std::move(pending);\n+    }\n+    bool transactionCanBeAbandoned(const uint256& txid) override { return m_wallet.TransactionCanBeAbandoned(txid); }\n+    bool abandonTransaction(const uint256& txid) override\n+    {\n+        LOCK2(cs_main, m_wallet.cs_wallet);\n+        return m_wallet.AbandonTransaction(txid);\n+    }\n+    bool transactionCanBeBumped(const uint256& txid) override\n+    {\n+        return feebumper::TransactionCanBeBumped(&m_wallet, txid);\n+    }\n+    bool createBumpTransaction(const uint256& txid,\n+        const CCoinControl& coin_control,\n+        CAmount total_fee,\n+        std::vector<std::string>& errors,\n+        CAmount& old_fee,\n+        CAmount& new_fee,\n+        CMutableTransaction& mtx) override\n+    {\n+        return feebumper::CreateTransaction(&m_wallet, txid, coin_control, total_fee, errors, old_fee, new_fee, mtx) ==\n+               feebumper::Result::OK;\n+    }\n+    bool signBumpTransaction(CMutableTransaction& mtx) override { return feebumper::SignTransaction(&m_wallet, mtx); }\n+    bool commitBumpTransaction(const uint256& txid,\n+        CMutableTransaction&& mtx,\n+        std::vector<std::string>& errors,\n+        uint256& bumped_txid) override\n+    {\n+        return feebumper::CommitTransaction(&m_wallet, txid, std::move(mtx), errors, bumped_txid) ==\n+               feebumper::Result::OK;\n+    }\n+    CTransactionRef getTx(const uint256& txid) override\n+    {\n+        LOCK2(::cs_main, m_wallet.cs_wallet);\n+        auto mi = m_wallet.mapWallet.find(txid);\n+        if (mi != m_wallet.mapWallet.end()) {\n+            return mi->second.tx;\n+        }\n+        return {};\n+    }\n+    WalletTx getWalletTx(const uint256& txid) override\n+    {\n+        LOCK2(::cs_main, m_wallet.cs_wallet);\n+        auto mi = m_wallet.mapWallet.find(txid);\n+        if (mi != m_wallet.mapWallet.end()) {\n+            return MakeWalletTx(m_wallet, mi->second);\n+        }\n+        return {};\n+    }\n+    std::vector<WalletTx> getWalletTxs() override\n+    {\n+        LOCK2(::cs_main, m_wallet.cs_wallet);\n+        std::vector<WalletTx> result;\n+        result.reserve(m_wallet.mapWallet.size());\n+        for (const auto& entry : m_wallet.mapWallet) {\n+            result.emplace_back(MakeWalletTx(m_wallet, entry.second));\n+        }\n+        return result;\n+    }\n+    bool tryGetTxStatus(const uint256& txid,\n+        interfaces::WalletTxStatus& tx_status,\n+        int& num_blocks,\n+        int64_t& adjusted_time) override\n+    {\n+        TRY_LOCK(::cs_main, locked_chain);\n+        if (!locked_chain) {\n+            return false;\n+        }\n+        TRY_LOCK(m_wallet.cs_wallet, locked_wallet);\n+        if (!locked_wallet) {\n+            return false;\n+        }\n+        auto mi = m_wallet.mapWallet.find(txid);\n+        if (mi == m_wallet.mapWallet.end()) {\n+            return false;\n+        }\n+        num_blocks = ::chainActive.Height();\n+        adjusted_time = GetAdjustedTime();\n+        tx_status = MakeWalletTxStatus(mi->second);\n+        return true;\n+    }\n+    WalletTx getWalletTxDetails(const uint256& txid,\n+        WalletTxStatus& tx_status,\n+        WalletOrderForm& order_form,\n+        bool& in_mempool,\n+        int& num_blocks,\n+        int64_t& adjusted_time) override\n+    {\n+        LOCK2(::cs_main, m_wallet.cs_wallet);\n+        auto mi = m_wallet.mapWallet.find(txid);\n+        if (mi != m_wallet.mapWallet.end()) {\n+            num_blocks = ::chainActive.Height();\n+            adjusted_time = GetAdjustedTime();\n+            in_mempool = mi->second.InMempool();\n+            order_form = mi->second.vOrderForm;\n+            tx_status = MakeWalletTxStatus(mi->second);\n+            return MakeWalletTx(m_wallet, mi->second);\n+        }\n+        return {};\n+    }\n+    WalletBalances getBalances() override\n+    {\n+        WalletBalances result;\n+        result.balance = m_wallet.GetBalance();\n+        result.unconfirmed_balance = m_wallet.GetUnconfirmedBalance();\n+        result.immature_balance = m_wallet.GetImmatureBalance();\n+        result.have_watch_only = m_wallet.HaveWatchOnly();\n+        if (result.have_watch_only) {\n+            result.watch_only_balance = m_wallet.GetWatchOnlyBalance();\n+            result.unconfirmed_watch_only_balance = m_wallet.GetUnconfirmedWatchOnlyBalance();\n+            result.immature_watch_only_balance = m_wallet.GetImmatureWatchOnlyBalance();\n+        }\n+        return result;\n+    }\n+    bool tryGetBalances(WalletBalances& balances, int& num_blocks) override\n+    {\n+        TRY_LOCK(cs_main, locked_chain);\n+        if (!locked_chain) return false;\n+        TRY_LOCK(m_wallet.cs_wallet, locked_wallet);\n+        if (!locked_wallet) {\n+            return false;\n+        }\n+        balances = getBalances();\n+        num_blocks = ::chainActive.Height();\n+        return true;\n+    }\n+    CAmount getBalance() override { return m_wallet.GetBalance(); }\n+    CAmount getAvailableBalance(const CCoinControl& coin_control) override\n+    {\n+        return m_wallet.GetAvailableBalance(&coin_control);\n+    }\n+    isminetype txinIsMine(const CTxIn& txin) override\n+    {\n+        LOCK2(::cs_main, m_wallet.cs_wallet);\n+        return m_wallet.IsMine(txin);\n+    }\n+    isminetype txoutIsMine(const CTxOut& txout) override\n+    {\n+        LOCK2(::cs_main, m_wallet.cs_wallet);\n+        return m_wallet.IsMine(txout);\n+    }\n+    CAmount getDebit(const CTxIn& txin, isminefilter filter) override\n+    {\n+        LOCK2(::cs_main, m_wallet.cs_wallet);\n+        return m_wallet.GetDebit(txin, filter);\n+    }\n+    CAmount getCredit(const CTxOut& txout, isminefilter filter) override\n+    {\n+        LOCK2(::cs_main, m_wallet.cs_wallet);\n+        return m_wallet.GetCredit(txout, filter);\n+    }\n+    CoinsList listCoins() override\n+    {\n+        LOCK2(::cs_main, m_wallet.cs_wallet);\n+        CoinsList result;\n+        for (const auto& entry : m_wallet.ListCoins()) {\n+            auto& group = result[entry.first];\n+            for (const auto& coin : entry.second) {\n+                group.emplace_back(\n+                    COutPoint(coin.tx->GetHash(), coin.i), MakeWalletTxOut(m_wallet, *coin.tx, coin.i, coin.nDepth));\n+            }\n+        }\n+        return result;\n+    }\n+    std::vector<WalletTxOut> getCoins(const std::vector<COutPoint>& outputs) override\n+    {\n+        LOCK2(::cs_main, m_wallet.cs_wallet);\n+        std::vector<WalletTxOut> result;\n+        result.reserve(outputs.size());\n+        for (const auto& output : outputs) {\n+            result.emplace_back();\n+            auto it = m_wallet.mapWallet.find(output.hash);\n+            if (it != m_wallet.mapWallet.end()) {\n+                int depth = it->second.GetDepthInMainChain();\n+                if (depth >= 0) {\n+                    result.back() = MakeWalletTxOut(m_wallet, it->second, output.n, depth);\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+    CAmount getRequiredFee(unsigned int tx_bytes) override { return GetRequiredFee(m_wallet, tx_bytes); }\n+    CAmount getMinimumFee(unsigned int tx_bytes,\n+        const CCoinControl& coin_control,\n+        int* returned_target,\n+        FeeReason* reason) override\n+    {\n+        FeeCalculation fee_calc;\n+        CAmount result;\n+        result = GetMinimumFee(m_wallet, tx_bytes, coin_control, ::mempool, ::feeEstimator, &fee_calc);\n+        if (returned_target) *returned_target = fee_calc.returnedTarget;\n+        if (reason) *reason = fee_calc.reason;\n+        return result;\n+    }\n+    unsigned int getConfirmTarget() override { return m_wallet.m_confirm_target; }\n+    bool hdEnabled() override { return m_wallet.IsHDEnabled(); }\n+    OutputType getDefaultAddressType() override { return m_wallet.m_default_address_type; }\n+    OutputType getDefaultChangeType() override { return m_wallet.m_default_change_type; }\n+    std::unique_ptr<Handler> handleShowProgress(ShowProgressFn fn) override\n+    {\n+        return MakeHandler(m_wallet.ShowProgress.connect(fn));\n+    }\n+    std::unique_ptr<Handler> handleStatusChanged(StatusChangedFn fn) override\n+    {\n+        return MakeHandler(m_wallet.NotifyStatusChanged.connect([fn](CCryptoKeyStore*) { fn(); }));\n+    }\n+    std::unique_ptr<Handler> handleAddressBookChanged(AddressBookChangedFn fn) override\n+    {\n+        return MakeHandler(m_wallet.NotifyAddressBookChanged.connect(\n+            [fn](CWallet*, const CTxDestination& address, const std::string& label, bool is_mine,\n+                const std::string& purpose, ChangeType status) { fn(address, label, is_mine, purpose, status); }));\n+    }\n+    std::unique_ptr<Handler> handleTransactionChanged(TransactionChangedFn fn) override\n+    {\n+        return MakeHandler(m_wallet.NotifyTransactionChanged.connect(\n+            [fn](CWallet*, const uint256& txid, ChangeType status) { fn(txid, status); }));\n+    }\n+    std::unique_ptr<Handler> handleWatchOnlyChanged(WatchOnlyChangedFn fn) override\n+    {\n+        return MakeHandler(m_wallet.NotifyWatchonlyChanged.connect(fn));\n+    }\n+\n+    CWallet& m_wallet;\n+};\n+\n+} // namespace\n+\n+std::unique_ptr<Wallet> MakeWallet(CWallet& wallet) { return MakeUnique<WalletImpl>(wallet); }\n+\n+} // namespace interfaces"
      },
      {
        "sha": "ff779cd0ad57796c96723d073085e09dac48b065",
        "filename": "src/interfaces/wallet.h",
        "status": "added",
        "additions": 370,
        "deletions": 0,
        "changes": 370,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/interfaces/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/interfaces/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/wallet.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -0,0 +1,370 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INTERFACES_WALLET_H\n+#define BITCOIN_INTERFACES_WALLET_H\n+\n+#include <amount.h>                    // For CAmount\n+#include <pubkey.h>                    // For CKeyID and CScriptID (definitions needed in CTxDestination instantiation)\n+#include <script/ismine.h>             // For isminefilter, isminetype\n+#include <script/standard.h>           // For CTxDestination\n+#include <support/allocators/secure.h> // For SecureString\n+#include <ui_interface.h>              // For ChangeType\n+\n+#include <functional>\n+#include <map>\n+#include <memory>\n+#include <stdint.h>\n+#include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+class CCoinControl;\n+class CFeeRate;\n+class CKey;\n+class CWallet;\n+enum class FeeReason;\n+enum class OutputType;\n+struct CRecipient;\n+\n+namespace interfaces {\n+\n+class Handler;\n+class PendingWalletTx;\n+struct WalletAddress;\n+struct WalletBalances;\n+struct WalletTx;\n+struct WalletTxOut;\n+struct WalletTxStatus;\n+\n+using WalletOrderForm = std::vector<std::pair<std::string, std::string>>;\n+using WalletValueMap = std::map<std::string, std::string>;\n+\n+//! Interface for accessing a wallet.\n+class Wallet\n+{\n+public:\n+    virtual ~Wallet() {}\n+\n+    //! Encrypt wallet.\n+    virtual bool encryptWallet(const SecureString& wallet_passphrase) = 0;\n+\n+    //! Return whether wallet is encrypted.\n+    virtual bool isCrypted() = 0;\n+\n+    //! Lock wallet.\n+    virtual bool lock() = 0;\n+\n+    //! Unlock wallet.\n+    virtual bool unlock(const SecureString& wallet_passphrase) = 0;\n+\n+    //! Return whether wallet is locked.\n+    virtual bool isLocked() = 0;\n+\n+    //! Change wallet passphrase.\n+    virtual bool changeWalletPassphrase(const SecureString& old_wallet_passphrase,\n+        const SecureString& new_wallet_passphrase) = 0;\n+\n+    //! Abort a rescan.\n+    virtual void abortRescan() = 0;\n+\n+    //! Back up wallet.\n+    virtual bool backupWallet(const std::string& filename) = 0;\n+\n+    //! Get wallet name.\n+    virtual std::string getWalletName() = 0;\n+\n+    // Get key from pool.\n+    virtual bool getKeyFromPool(bool internal, CPubKey& pub_key) = 0;\n+\n+    //! Get public key.\n+    virtual bool getPubKey(const CKeyID& address, CPubKey& pub_key) = 0;\n+\n+    //! Get private key.\n+    virtual bool getPrivKey(const CKeyID& address, CKey& key) = 0;\n+\n+    //! Return whether wallet has private key.\n+    virtual bool isSpendable(const CTxDestination& dest) = 0;\n+\n+    //! Return whether wallet has watch only keys.\n+    virtual bool haveWatchOnly() = 0;\n+\n+    //! Add or update address.\n+    virtual bool setAddressBook(const CTxDestination& dest, const std::string& name, const std::string& purpose) = 0;\n+\n+    // Remove address.\n+    virtual bool delAddressBook(const CTxDestination& dest) = 0;\n+\n+    //! Look up address in wallet, return whether exists.\n+    virtual bool getAddress(const CTxDestination& dest,\n+        std::string* name,\n+        isminetype* is_mine,\n+        std::string* purpose) = 0;\n+\n+    //! Get wallet address list.\n+    virtual std::vector<WalletAddress> getAddresses() = 0;\n+\n+    //! Add scripts to key store so old so software versions opening the wallet\n+    //! database can detect payments to newer address types.\n+    virtual void learnRelatedScripts(const CPubKey& key, OutputType type) = 0;\n+\n+    //! Add dest data.\n+    virtual bool addDestData(const CTxDestination& dest, const std::string& key, const std::string& value) = 0;\n+\n+    //! Erase dest data.\n+    virtual bool eraseDestData(const CTxDestination& dest, const std::string& key) = 0;\n+\n+    //! Get dest values with prefix.\n+    virtual std::vector<std::string> getDestValues(const std::string& prefix) = 0;\n+\n+    //! Lock coin.\n+    virtual void lockCoin(const COutPoint& output) = 0;\n+\n+    //! Unlock coin.\n+    virtual void unlockCoin(const COutPoint& output) = 0;\n+\n+    //! Return whether coin is locked.\n+    virtual bool isLockedCoin(const COutPoint& output) = 0;\n+\n+    //! List locked coins.\n+    virtual void listLockedCoins(std::vector<COutPoint>& outputs) = 0;\n+\n+    //! Create transaction.\n+    virtual std::unique_ptr<PendingWalletTx> createTransaction(const std::vector<CRecipient>& recipients,\n+        const CCoinControl& coin_control,\n+        bool sign,\n+        int& change_pos,\n+        CAmount& fee,\n+        std::string& fail_reason) = 0;\n+\n+    //! Return whether transaction can be abandoned.\n+    virtual bool transactionCanBeAbandoned(const uint256& txid) = 0;\n+\n+    //! Abandon transaction.\n+    virtual bool abandonTransaction(const uint256& txid) = 0;\n+\n+    //! Return whether transaction can be bumped.\n+    virtual bool transactionCanBeBumped(const uint256& txid) = 0;\n+\n+    //! Create bump transaction.\n+    virtual bool createBumpTransaction(const uint256& txid,\n+        const CCoinControl& coin_control,\n+        CAmount total_fee,\n+        std::vector<std::string>& errors,\n+        CAmount& old_fee,\n+        CAmount& new_fee,\n+        CMutableTransaction& mtx) = 0;\n+\n+    //! Sign bump transaction.\n+    virtual bool signBumpTransaction(CMutableTransaction& mtx) = 0;\n+\n+    //! Commit bump transaction.\n+    virtual bool commitBumpTransaction(const uint256& txid,\n+        CMutableTransaction&& mtx,\n+        std::vector<std::string>& errors,\n+        uint256& bumped_txid) = 0;\n+\n+    //! Get a transaction.\n+    virtual CTransactionRef getTx(const uint256& txid) = 0;\n+\n+    //! Get transaction information.\n+    virtual WalletTx getWalletTx(const uint256& txid) = 0;\n+\n+    //! Get list of all wallet transactions.\n+    virtual std::vector<WalletTx> getWalletTxs() = 0;\n+\n+    //! Try to get updated status for a particular transaction, if possible without blocking.\n+    virtual bool tryGetTxStatus(const uint256& txid,\n+        WalletTxStatus& tx_status,\n+        int& num_blocks,\n+        int64_t& adjusted_time) = 0;\n+\n+    //! Get transaction details.\n+    virtual WalletTx getWalletTxDetails(const uint256& txid,\n+        WalletTxStatus& tx_status,\n+        WalletOrderForm& order_form,\n+        bool& in_mempool,\n+        int& num_blocks,\n+        int64_t& adjusted_time) = 0;\n+\n+    //! Get balances.\n+    virtual WalletBalances getBalances() = 0;\n+\n+    //! Get balances if possible without blocking.\n+    virtual bool tryGetBalances(WalletBalances& balances, int& num_blocks) = 0;\n+\n+    //! Get balance.\n+    virtual CAmount getBalance() = 0;\n+\n+    //! Get available balance.\n+    virtual CAmount getAvailableBalance(const CCoinControl& coin_control) = 0;\n+\n+    //! Return whether transaction input belongs to wallet.\n+    virtual isminetype txinIsMine(const CTxIn& txin) = 0;\n+\n+    //! Return whether transaction output belongs to wallet.\n+    virtual isminetype txoutIsMine(const CTxOut& txout) = 0;\n+\n+    //! Return debit amount if transaction input belongs to wallet.\n+    virtual CAmount getDebit(const CTxIn& txin, isminefilter filter) = 0;\n+\n+    //! Return credit amount if transaction input belongs to wallet.\n+    virtual CAmount getCredit(const CTxOut& txout, isminefilter filter) = 0;\n+\n+    //! Return AvailableCoins + LockedCoins grouped by wallet address.\n+    //! (put change in one group with wallet address)\n+    using CoinsList = std::map<CTxDestination, std::vector<std::tuple<COutPoint, WalletTxOut>>>;\n+    virtual CoinsList listCoins() = 0;\n+\n+    //! Return wallet transaction output information.\n+    virtual std::vector<WalletTxOut> getCoins(const std::vector<COutPoint>& outputs) = 0;\n+\n+    //! Get required fee.\n+    virtual CAmount getRequiredFee(unsigned int tx_bytes) = 0;\n+\n+    //! Get minimum fee.\n+    virtual CAmount getMinimumFee(unsigned int tx_bytes,\n+        const CCoinControl& coin_control,\n+        int* returned_target,\n+        FeeReason* reason) = 0;\n+\n+    //! Get tx confirm target.\n+    virtual unsigned int getConfirmTarget() = 0;\n+\n+    // Return whether HD enabled.\n+    virtual bool hdEnabled() = 0;\n+\n+    // Get default address type.\n+    virtual OutputType getDefaultAddressType() = 0;\n+\n+    // Get default change type.\n+    virtual OutputType getDefaultChangeType() = 0;\n+\n+    //! Register handler for show progress messages.\n+    using ShowProgressFn = std::function<void(const std::string& title, int progress)>;\n+    virtual std::unique_ptr<Handler> handleShowProgress(ShowProgressFn fn) = 0;\n+\n+    //! Register handler for status changed messages.\n+    using StatusChangedFn = std::function<void()>;\n+    virtual std::unique_ptr<Handler> handleStatusChanged(StatusChangedFn fn) = 0;\n+\n+    //! Register handler for address book changed messages.\n+    using AddressBookChangedFn = std::function<void(const CTxDestination& address,\n+        const std::string& label,\n+        bool is_mine,\n+        const std::string& purpose,\n+        ChangeType status)>;\n+    virtual std::unique_ptr<Handler> handleAddressBookChanged(AddressBookChangedFn fn) = 0;\n+\n+    //! Register handler for transaction changed messages.\n+    using TransactionChangedFn = std::function<void(const uint256& txid, ChangeType status)>;\n+    virtual std::unique_ptr<Handler> handleTransactionChanged(TransactionChangedFn fn) = 0;\n+\n+    //! Register handler for watchonly changed messages.\n+    using WatchOnlyChangedFn = std::function<void(bool have_watch_only)>;\n+    virtual std::unique_ptr<Handler> handleWatchOnlyChanged(WatchOnlyChangedFn fn) = 0;\n+};\n+\n+//! Tracking object returned by CreateTransaction and passed to CommitTransaction.\n+class PendingWalletTx\n+{\n+public:\n+    virtual ~PendingWalletTx() {}\n+\n+    //! Get transaction data.\n+    virtual const CTransaction& get() = 0;\n+\n+    //! Get virtual transaction size.\n+    virtual int64_t getVirtualSize() = 0;\n+\n+    //! Send pending transaction and commit to wallet.\n+    virtual bool commit(WalletValueMap value_map,\n+        WalletOrderForm order_form,\n+        std::string from_account,\n+        std::string& reject_reason) = 0;\n+};\n+\n+//! Information about one wallet address.\n+struct WalletAddress\n+{\n+    CTxDestination dest;\n+    isminetype is_mine;\n+    std::string name;\n+    std::string purpose;\n+\n+    WalletAddress(CTxDestination dest, isminetype is_mine, std::string name, std::string purpose)\n+        : dest(std::move(dest)), is_mine(is_mine), name(std::move(name)), purpose(std::move(purpose))\n+    {\n+    }\n+};\n+\n+//! Collection of wallet balances.\n+struct WalletBalances\n+{\n+    CAmount balance = 0;\n+    CAmount unconfirmed_balance = 0;\n+    CAmount immature_balance = 0;\n+    bool have_watch_only = false;\n+    CAmount watch_only_balance = 0;\n+    CAmount unconfirmed_watch_only_balance = 0;\n+    CAmount immature_watch_only_balance = 0;\n+\n+    bool balanceChanged(const WalletBalances& prev) const\n+    {\n+        return balance != prev.balance || unconfirmed_balance != prev.unconfirmed_balance ||\n+               immature_balance != prev.immature_balance || watch_only_balance != prev.watch_only_balance ||\n+               unconfirmed_watch_only_balance != prev.unconfirmed_watch_only_balance ||\n+               immature_watch_only_balance != prev.immature_watch_only_balance;\n+    }\n+};\n+\n+// Wallet transaction information.\n+struct WalletTx\n+{\n+    CTransactionRef tx;\n+    std::vector<isminetype> txin_is_mine;\n+    std::vector<isminetype> txout_is_mine;\n+    std::vector<CTxDestination> txout_address;\n+    std::vector<isminetype> txout_address_is_mine;\n+    CAmount credit;\n+    CAmount debit;\n+    CAmount change;\n+    int64_t time;\n+    std::map<std::string, std::string> value_map;\n+    bool is_coinbase;\n+};\n+\n+//! Updated transaction status.\n+struct WalletTxStatus\n+{\n+    int block_height;\n+    int blocks_to_maturity;\n+    int depth_in_main_chain;\n+    int request_count;\n+    unsigned int time_received;\n+    uint32_t lock_time;\n+    bool is_final;\n+    bool is_trusted;\n+    bool is_abandoned;\n+    bool is_coinbase;\n+    bool is_in_main_chain;\n+};\n+\n+//! Wallet transaction output.\n+struct WalletTxOut\n+{\n+    CTxOut txout;\n+    int64_t time;\n+    int depth_in_main_chain = -1;\n+    bool is_spent = false;\n+};\n+\n+//! Return implementation of Wallet interface. This function will be undefined\n+//! in builds where ENABLE_WALLET is false.\n+std::unique_ptr<Wallet> MakeWallet(CWallet& wallet);\n+\n+} // namespace interfaces\n+\n+#endif // BITCOIN_INTERFACES_WALLET_H"
      },
      {
        "sha": "d75b5b31c82d70eb8e8e28587b720f60c0bec305",
        "filename": "src/key_io.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/key_io.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/key_io.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key_io.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -3,8 +3,8 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#ifndef BITCOIN_KEYIO_H\n-#define BITCOIN_KEYIO_H\n+#ifndef BITCOIN_KEY_IO_H\n+#define BITCOIN_KEY_IO_H\n \n #include <chainparams.h>\n #include <key.h>\n@@ -26,4 +26,4 @@ CTxDestination DecodeDestination(const std::string& str);\n bool IsValidDestinationString(const std::string& str);\n bool IsValidDestinationString(const std::string& str, const CChainParams& params);\n \n-#endif // BITCOIN_KEYIO_H\n+#endif // BITCOIN_KEY_IO_H"
      },
      {
        "sha": "e69d518890f8a7e9fa85ace01d0496a49e935499",
        "filename": "src/keystore.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 5,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/keystore.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/keystore.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -7,10 +7,6 @@\n \n #include <util.h>\n \n-bool CKeyStore::AddKey(const CKey &key) {\n-    return AddKeyPubKey(key, key.GetPubKey());\n-}\n-\n void CBasicKeyStore::ImplicitlyLearnRelatedKeyScripts(const CPubKey& pubkey)\n {\n     AssertLockHeld(cs_KeyStore);\n@@ -131,7 +127,7 @@ static bool ExtractPubKey(const CScript &dest, CPubKey& pubKeyOut)\n     CScript::const_iterator pc = dest.begin();\n     opcodetype opcode;\n     std::vector<unsigned char> vch;\n-    if (!dest.GetOp(pc, opcode, vch) || vch.size() < 33 || vch.size() > 65)\n+    if (!dest.GetOp(pc, opcode, vch) || !CPubKey::ValidSize(vch))\n         return false;\n     pubKeyOut = CPubKey(vch);\n     if (!pubKeyOut.IsFullyValid())"
      },
      {
        "sha": "c56e4751de8a0514c3ef7131d4c6b5cf2e88ede5",
        "filename": "src/keystore.h",
        "status": "modified",
        "additions": 6,
        "deletions": 11,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/keystore.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/keystore.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -9,35 +9,27 @@\n #include <key.h>\n #include <pubkey.h>\n #include <script/script.h>\n+#include <script/sign.h>\n #include <script/standard.h>\n #include <sync.h>\n \n #include <boost/signals2/signal.hpp>\n \n /** A virtual base class for key stores */\n-class CKeyStore\n+class CKeyStore : public SigningProvider\n {\n-protected:\n-    mutable CCriticalSection cs_KeyStore;\n-\n public:\n-    virtual ~CKeyStore() {}\n-\n     //! Add a key to the store.\n     virtual bool AddKeyPubKey(const CKey &key, const CPubKey &pubkey) =0;\n-    virtual bool AddKey(const CKey &key);\n \n     //! Check whether a key corresponding to a given address is present in the store.\n     virtual bool HaveKey(const CKeyID &address) const =0;\n-    virtual bool GetKey(const CKeyID &address, CKey& keyOut) const =0;\n     virtual std::set<CKeyID> GetKeys() const =0;\n-    virtual bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const =0;\n \n     //! Support for BIP 0013 : see https://github.com/bitcoin/bips/blob/master/bip-0013.mediawiki\n     virtual bool AddCScript(const CScript& redeemScript) =0;\n     virtual bool HaveCScript(const CScriptID &hash) const =0;\n     virtual std::set<CScriptID> GetCScripts() const =0;\n-    virtual bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const =0;\n \n     //! Support for Watch-only addresses\n     virtual bool AddWatchOnly(const CScript &dest) =0;\n@@ -55,15 +47,18 @@ typedef std::set<CScript> WatchOnlySet;\n class CBasicKeyStore : public CKeyStore\n {\n protected:\n+    mutable CCriticalSection cs_KeyStore;\n+\n     KeyMap mapKeys;\n     WatchKeyMap mapWatchKeys;\n     ScriptMap mapScripts;\n     WatchOnlySet setWatchOnly;\n \n-    void ImplicitlyLearnRelatedKeyScripts(const CPubKey& pubkey);\n+    void ImplicitlyLearnRelatedKeyScripts(const CPubKey& pubkey) EXCLUSIVE_LOCKS_REQUIRED(cs_KeyStore);\n \n public:\n     bool AddKeyPubKey(const CKey& key, const CPubKey &pubkey) override;\n+    bool AddKey(const CKey &key) { return AddKeyPubKey(key, key.GetPubKey()); }\n     bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const override;\n     bool HaveKey(const CKeyID &address) const override;\n     std::set<CKeyID> GetKeys() const override;"
      },
      {
        "sha": "e8e22cbf97e850dd666203c5fbc803ab1935b361",
        "filename": "src/logging.cpp",
        "status": "added",
        "additions": 273,
        "deletions": 0,
        "changes": 273,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/logging.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/logging.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logging.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -0,0 +1,273 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <logging.h>\n+#include <utiltime.h>\n+\n+const char * const DEFAULT_DEBUGLOGFILE = \"debug.log\";\n+\n+/**\n+ * NOTE: the logger instances is leaked on exit. This is ugly, but will be\n+ * cleaned up by the OS/libc. Defining a logger as a global object doesn't work\n+ * since the order of destruction of static/global objects is undefined.\n+ * Consider if the logger gets destroyed, and then some later destructor calls\n+ * LogPrintf, maybe indirectly, and you get a core dump at shutdown trying to\n+ * access the logger. When the shutdown sequence is fully audited and tested,\n+ * explicit destruction of these objects can be implemented by changing this\n+ * from a raw pointer to a std::unique_ptr.\n+ *\n+ * This method of initialization was originally introduced in\n+ * ee3374234c60aba2cc4c5cd5cac1c0aefc2d817c.\n+ */\n+BCLog::Logger* const g_logger = new BCLog::Logger();\n+\n+bool fLogIPs = DEFAULT_LOGIPS;\n+\n+static int FileWriteStr(const std::string &str, FILE *fp)\n+{\n+    return fwrite(str.data(), 1, str.size(), fp);\n+}\n+\n+bool BCLog::Logger::OpenDebugLog()\n+{\n+    std::lock_guard<std::mutex> scoped_lock(m_file_mutex);\n+\n+    assert(m_fileout == nullptr);\n+    assert(!m_file_path.empty());\n+\n+    m_fileout = fsbridge::fopen(m_file_path, \"a\");\n+    if (!m_fileout) {\n+        return false;\n+    }\n+\n+    setbuf(m_fileout, nullptr); // unbuffered\n+    // dump buffered messages from before we opened the log\n+    while (!m_msgs_before_open.empty()) {\n+        FileWriteStr(m_msgs_before_open.front(), m_fileout);\n+        m_msgs_before_open.pop_front();\n+    }\n+\n+    return true;\n+}\n+\n+void BCLog::Logger::EnableCategory(BCLog::LogFlags flag)\n+{\n+    m_categories |= flag;\n+}\n+\n+bool BCLog::Logger::EnableCategory(const std::string& str)\n+{\n+    BCLog::LogFlags flag;\n+    if (!GetLogCategory(flag, str)) return false;\n+    EnableCategory(flag);\n+    return true;\n+}\n+\n+void BCLog::Logger::DisableCategory(BCLog::LogFlags flag)\n+{\n+    m_categories &= ~flag;\n+}\n+\n+bool BCLog::Logger::DisableCategory(const std::string& str)\n+{\n+    BCLog::LogFlags flag;\n+    if (!GetLogCategory(flag, str)) return false;\n+    DisableCategory(flag);\n+    return true;\n+}\n+\n+bool BCLog::Logger::WillLogCategory(BCLog::LogFlags category) const\n+{\n+    return (m_categories.load(std::memory_order_relaxed) & category) != 0;\n+}\n+\n+bool BCLog::Logger::DefaultShrinkDebugFile() const\n+{\n+    return m_categories == BCLog::NONE;\n+}\n+\n+struct CLogCategoryDesc\n+{\n+    BCLog::LogFlags flag;\n+    std::string category;\n+};\n+\n+const CLogCategoryDesc LogCategories[] =\n+{\n+    {BCLog::NONE, \"0\"},\n+    {BCLog::NONE, \"none\"},\n+    {BCLog::NET, \"net\"},\n+    {BCLog::TOR, \"tor\"},\n+    {BCLog::MEMPOOL, \"mempool\"},\n+    {BCLog::HTTP, \"http\"},\n+    {BCLog::BENCH, \"bench\"},\n+    {BCLog::ZMQ, \"zmq\"},\n+    {BCLog::DB, \"db\"},\n+    {BCLog::RPC, \"rpc\"},\n+    {BCLog::ESTIMATEFEE, \"estimatefee\"},\n+    {BCLog::ADDRMAN, \"addrman\"},\n+    {BCLog::SELECTCOINS, \"selectcoins\"},\n+    {BCLog::REINDEX, \"reindex\"},\n+    {BCLog::CMPCTBLOCK, \"cmpctblock\"},\n+    {BCLog::RAND, \"rand\"},\n+    {BCLog::PRUNE, \"prune\"},\n+    {BCLog::PROXY, \"proxy\"},\n+    {BCLog::MEMPOOLREJ, \"mempoolrej\"},\n+    {BCLog::LIBEVENT, \"libevent\"},\n+    {BCLog::COINDB, \"coindb\"},\n+    {BCLog::QT, \"qt\"},\n+    {BCLog::LEVELDB, \"leveldb\"},\n+    {BCLog::ALL, \"1\"},\n+    {BCLog::ALL, \"all\"},\n+};\n+\n+bool GetLogCategory(BCLog::LogFlags& flag, const std::string& str)\n+{\n+    if (str == \"\") {\n+        flag = BCLog::ALL;\n+        return true;\n+    }\n+    for (const CLogCategoryDesc& category_desc : LogCategories) {\n+        if (category_desc.category == str) {\n+            flag = category_desc.flag;\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+std::string ListLogCategories()\n+{\n+    std::string ret;\n+    int outcount = 0;\n+    for (const CLogCategoryDesc& category_desc : LogCategories) {\n+        // Omit the special cases.\n+        if (category_desc.flag != BCLog::NONE && category_desc.flag != BCLog::ALL) {\n+            if (outcount != 0) ret += \", \";\n+            ret += category_desc.category;\n+            outcount++;\n+        }\n+    }\n+    return ret;\n+}\n+\n+std::vector<CLogCategoryActive> ListActiveLogCategories()\n+{\n+    std::vector<CLogCategoryActive> ret;\n+    for (const CLogCategoryDesc& category_desc : LogCategories) {\n+        // Omit the special cases.\n+        if (category_desc.flag != BCLog::NONE && category_desc.flag != BCLog::ALL) {\n+            CLogCategoryActive catActive;\n+            catActive.category = category_desc.category;\n+            catActive.active = LogAcceptCategory(category_desc.flag);\n+            ret.push_back(catActive);\n+        }\n+    }\n+    return ret;\n+}\n+\n+std::string BCLog::Logger::LogTimestampStr(const std::string &str)\n+{\n+    std::string strStamped;\n+\n+    if (!m_log_timestamps)\n+        return str;\n+\n+    if (m_started_new_line) {\n+        int64_t nTimeMicros = GetTimeMicros();\n+        strStamped = FormatISO8601DateTime(nTimeMicros/1000000);\n+        if (m_log_time_micros) {\n+            strStamped.pop_back();\n+            strStamped += strprintf(\".%06dZ\", nTimeMicros%1000000);\n+        }\n+        int64_t mocktime = GetMockTime();\n+        if (mocktime) {\n+            strStamped += \" (mocktime: \" + FormatISO8601DateTime(mocktime) + \")\";\n+        }\n+        strStamped += ' ' + str;\n+    } else\n+        strStamped = str;\n+\n+    if (!str.empty() && str[str.size()-1] == '\\n')\n+        m_started_new_line = true;\n+    else\n+        m_started_new_line = false;\n+\n+    return strStamped;\n+}\n+\n+void BCLog::Logger::LogPrintStr(const std::string &str)\n+{\n+    std::string strTimestamped = LogTimestampStr(str);\n+\n+    if (m_print_to_console) {\n+        // print to console\n+        fwrite(strTimestamped.data(), 1, strTimestamped.size(), stdout);\n+        fflush(stdout);\n+    }\n+    if (m_print_to_file) {\n+        std::lock_guard<std::mutex> scoped_lock(m_file_mutex);\n+\n+        // buffer if we haven't opened the log yet\n+        if (m_fileout == nullptr) {\n+            m_msgs_before_open.push_back(strTimestamped);\n+        }\n+        else\n+        {\n+            // reopen the log file, if requested\n+            if (m_reopen_file) {\n+                m_reopen_file = false;\n+                m_fileout = fsbridge::freopen(m_file_path, \"a\", m_fileout);\n+                if (!m_fileout) {\n+                    return;\n+                }\n+                setbuf(m_fileout, nullptr); // unbuffered\n+            }\n+\n+            FileWriteStr(strTimestamped, m_fileout);\n+        }\n+    }\n+}\n+\n+void BCLog::Logger::ShrinkDebugFile()\n+{\n+    // Amount of debug.log to save at end when shrinking (must fit in memory)\n+    constexpr size_t RECENT_DEBUG_HISTORY_SIZE = 10 * 1000000;\n+\n+    assert(!m_file_path.empty());\n+\n+    // Scroll debug.log if it's getting too big\n+    FILE* file = fsbridge::fopen(m_file_path, \"r\");\n+\n+    // Special files (e.g. device nodes) may not have a size.\n+    size_t log_size = 0;\n+    try {\n+        log_size = fs::file_size(m_file_path);\n+    } catch (boost::filesystem::filesystem_error &) {}\n+\n+    // If debug.log file is more than 10% bigger the RECENT_DEBUG_HISTORY_SIZE\n+    // trim it down by saving only the last RECENT_DEBUG_HISTORY_SIZE bytes\n+    if (file && log_size > 11 * (RECENT_DEBUG_HISTORY_SIZE / 10))\n+    {\n+        // Restart the file with some of the end\n+        std::vector<char> vch(RECENT_DEBUG_HISTORY_SIZE, 0);\n+        if (fseek(file, -((long)vch.size()), SEEK_END)) {\n+            LogPrintf(\"Failed to shrink debug log file: fseek(...) failed\\n\");\n+            fclose(file);\n+            return;\n+        }\n+        int nBytes = fread(vch.data(), 1, vch.size(), file);\n+        fclose(file);\n+\n+        file = fsbridge::fopen(m_file_path, \"w\");\n+        if (file)\n+        {\n+            fwrite(vch.data(), 1, nBytes, file);\n+            fclose(file);\n+        }\n+    }\n+    else if (file != nullptr)\n+        fclose(file);\n+}"
      },
      {
        "sha": "6400b131c2d6b20f6996fb85d3e2be2e8059b908",
        "filename": "src/logging.h",
        "status": "added",
        "additions": 166,
        "deletions": 0,
        "changes": 166,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/logging.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/logging.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logging.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -0,0 +1,166 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_LOGGING_H\n+#define BITCOIN_LOGGING_H\n+\n+#include <fs.h>\n+#include <tinyformat.h>\n+\n+#include <atomic>\n+#include <cstdint>\n+#include <list>\n+#include <mutex>\n+#include <string>\n+#include <vector>\n+\n+static const bool DEFAULT_LOGTIMEMICROS = false;\n+static const bool DEFAULT_LOGIPS        = false;\n+static const bool DEFAULT_LOGTIMESTAMPS = true;\n+extern const char * const DEFAULT_DEBUGLOGFILE;\n+\n+extern bool fLogIPs;\n+\n+struct CLogCategoryActive\n+{\n+    std::string category;\n+    bool active;\n+};\n+\n+namespace BCLog {\n+    enum LogFlags : uint32_t {\n+        NONE        = 0,\n+        NET         = (1 <<  0),\n+        TOR         = (1 <<  1),\n+        MEMPOOL     = (1 <<  2),\n+        HTTP        = (1 <<  3),\n+        BENCH       = (1 <<  4),\n+        ZMQ         = (1 <<  5),\n+        DB          = (1 <<  6),\n+        RPC         = (1 <<  7),\n+        ESTIMATEFEE = (1 <<  8),\n+        ADDRMAN     = (1 <<  9),\n+        SELECTCOINS = (1 << 10),\n+        REINDEX     = (1 << 11),\n+        CMPCTBLOCK  = (1 << 12),\n+        RAND        = (1 << 13),\n+        PRUNE       = (1 << 14),\n+        PROXY       = (1 << 15),\n+        MEMPOOLREJ  = (1 << 16),\n+        LIBEVENT    = (1 << 17),\n+        COINDB      = (1 << 18),\n+        QT          = (1 << 19),\n+        LEVELDB     = (1 << 20),\n+        ALL         = ~(uint32_t)0,\n+    };\n+\n+    class Logger\n+    {\n+    private:\n+        FILE* m_fileout = nullptr;\n+        std::mutex m_file_mutex;\n+        std::list<std::string> m_msgs_before_open;\n+\n+        /**\n+         * m_started_new_line is a state variable that will suppress printing of\n+         * the timestamp when multiple calls are made that don't end in a\n+         * newline.\n+         */\n+        std::atomic_bool m_started_new_line{true};\n+\n+        /** Log categories bitfield. */\n+        std::atomic<uint32_t> m_categories{0};\n+\n+        std::string LogTimestampStr(const std::string& str);\n+\n+    public:\n+        bool m_print_to_console = false;\n+        bool m_print_to_file = false;\n+\n+        bool m_log_timestamps = DEFAULT_LOGTIMESTAMPS;\n+        bool m_log_time_micros = DEFAULT_LOGTIMEMICROS;\n+\n+        fs::path m_file_path;\n+        std::atomic<bool> m_reopen_file{false};\n+\n+        /** Send a string to the log output */\n+        void LogPrintStr(const std::string &str);\n+\n+        /** Returns whether logs will be written to any output */\n+        bool Enabled() const { return m_print_to_console || m_print_to_file; }\n+\n+        bool OpenDebugLog();\n+        void ShrinkDebugFile();\n+\n+        uint32_t GetCategoryMask() const { return m_categories.load(); }\n+\n+        void EnableCategory(LogFlags flag);\n+        bool EnableCategory(const std::string& str);\n+        void DisableCategory(LogFlags flag);\n+        bool DisableCategory(const std::string& str);\n+\n+        bool WillLogCategory(LogFlags category) const;\n+\n+        bool DefaultShrinkDebugFile() const;\n+    };\n+\n+} // namespace BCLog\n+\n+extern BCLog::Logger* const g_logger;\n+\n+/** Return true if log accepts specified category */\n+static inline bool LogAcceptCategory(BCLog::LogFlags category)\n+{\n+    return g_logger->WillLogCategory(category);\n+}\n+\n+/** Returns a string with the log categories. */\n+std::string ListLogCategories();\n+\n+/** Returns a vector of the active log categories. */\n+std::vector<CLogCategoryActive> ListActiveLogCategories();\n+\n+/** Return true if str parses as a log category and set the flag */\n+bool GetLogCategory(BCLog::LogFlags& flag, const std::string& str);\n+\n+/** Get format string from VA_ARGS for error reporting */\n+template<typename... Args> std::string FormatStringFromLogArgs(const char *fmt, const Args&... args) { return fmt; }\n+\n+static inline void MarkUsed() {}\n+template<typename T, typename... Args> static inline void MarkUsed(const T& t, const Args&... args)\n+{\n+    (void)t;\n+    MarkUsed(args...);\n+}\n+\n+// Be conservative when using LogPrintf/error or other things which\n+// unconditionally log to debug.log! It should not be the case that an inbound\n+// peer can fill up a user's disk with debug.log entries.\n+\n+#ifdef USE_COVERAGE\n+#define LogPrintf(...) do { MarkUsed(__VA_ARGS__); } while(0)\n+#define LogPrint(category, ...) do { MarkUsed(__VA_ARGS__); } while(0)\n+#else\n+#define LogPrintf(...) do { \\\n+    if (g_logger->Enabled()) { \\\n+        std::string _log_msg_; /* Unlikely name to avoid shadowing variables */ \\\n+        try { \\\n+            _log_msg_ = tfm::format(__VA_ARGS__); \\\n+        } catch (tinyformat::format_error &fmterr) { \\\n+            /* Original format string will have newline so don't add one here */ \\\n+            _log_msg_ = \"Error \\\"\" + std::string(fmterr.what()) + \"\\\" while formatting log message: \" + FormatStringFromLogArgs(__VA_ARGS__); \\\n+        } \\\n+        g_logger->LogPrintStr(_log_msg_); \\\n+    } \\\n+} while(0)\n+\n+#define LogPrint(category, ...) do { \\\n+    if (LogAcceptCategory((category))) { \\\n+        LogPrintf(__VA_ARGS__); \\\n+    } \\\n+} while(0)\n+#endif\n+\n+#endif // BITCOIN_LOGGING_H"
      },
      {
        "sha": "0b92e53b4866e7a002405f47769934ca8ae327c4",
        "filename": "src/memusage.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/memusage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/memusage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/memusage.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -10,6 +10,7 @@\n #include <stdlib.h>\n \n #include <map>\n+#include <memory>\n #include <set>\n #include <vector>\n #include <unordered_map>"
      },
      {
        "sha": "0660df928c28b35bf78593cd5f6a467495e122ed",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -68,9 +68,7 @@ BlockAssembler::BlockAssembler(const CChainParams& params, const Options& option\n static BlockAssembler::Options DefaultOptions(const CChainParams& params)\n {\n     // Block resource limits\n-    // If neither -blockmaxsize or -blockmaxweight is given, limit to DEFAULT_BLOCK_MAX_*\n-    // If only one is given, only restrict the specified resource.\n-    // If both are given, restrict both.\n+    // If -blockmaxweight is not given, limit to DEFAULT_BLOCK_MAX_WEIGHT\n     BlockAssembler::Options options;\n     options.nBlockMaxWeight = gArgs.GetArg(\"-blockmaxweight\", DEFAULT_BLOCK_MAX_WEIGHT);\n     if (gArgs.IsArgSet(\"-blockmintxfee\")) {"
      },
      {
        "sha": "55043ffe30cb5a4d139d64d73a5002011aad387d",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 23,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -124,7 +124,7 @@ bool GetLocal(CService& addr, const CNetAddr *paddrPeer)\n     return nBestScore >= 0;\n }\n \n-//! Convert the pnSeeds6 array into usable address objects.\n+//! Convert the pnSeed6 array into usable address objects.\n static std::vector<CAddress> convertSeed6(const std::vector<SeedSpec6> &vSeedsIn)\n {\n     // It'll only connect to one or two seed nodes because once it connects,\n@@ -160,7 +160,7 @@ CAddress GetLocalAddress(const CNetAddr *paddrPeer, ServiceFlags nLocalServices)\n     return ret;\n }\n \n-int GetnScore(const CService& addr)\n+static int GetnScore(const CService& addr)\n {\n     LOCK(cs_mapLocalHost);\n     if (mapLocalHost.count(addr) == LOCAL_NONE)\n@@ -368,7 +368,7 @@ static CAddress GetBindAddress(SOCKET sock)\n     return addr_bind;\n }\n \n-CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure)\n+CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure, bool manual_connection)\n {\n     if (pszDest == nullptr) {\n         if (IsLocal(addrConnect))\n@@ -395,7 +395,7 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\n         if (Lookup(pszDest, resolved,  default_port, fNameLookup && !HaveNameProxy(), 256) && !resolved.empty()) {\n             addrConnect = CAddress(resolved[GetRand(resolved.size())], NODE_NONE);\n             if (!addrConnect.IsValid()) {\n-                LogPrint(BCLog::NET, \"Resolver returned invalid address %s for %s\", addrConnect.ToString(), pszDest);\n+                LogPrint(BCLog::NET, \"Resolver returned invalid address %s for %s\\n\", addrConnect.ToString(), pszDest);\n                 return nullptr;\n             }\n             // It is possible that we already have a connection to the IP/port pszDest resolved to.\n@@ -432,7 +432,7 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\n             if (hSocket == INVALID_SOCKET) {\n                 return nullptr;\n             }\n-            connected = ConnectSocketDirectly(addrConnect, hSocket, nConnectTimeout);\n+            connected = ConnectSocketDirectly(addrConnect, hSocket, nConnectTimeout, manual_connection);\n         }\n         if (!proxyConnectionFailed) {\n             // If a connection to the node was attempted, and failure (if any) is not caused by a problem connecting to\n@@ -1466,7 +1466,7 @@ void CConnman::WakeMessageHandler()\n #ifdef USE_UPNP\n static CThreadInterrupt g_upnp_interrupt;\n static std::thread g_upnp_thread;\n-void ThreadMapPort()\n+static void ThreadMapPort()\n {\n     std::string port = strprintf(\"%u\", GetListenPort());\n     const char * multicastif = nullptr;\n@@ -1923,23 +1923,25 @@ std::vector<AddedNodeInfo> CConnman::GetAddedNodeInfo()\n \n     for (const std::string& strAddNode : lAddresses) {\n         CService service(LookupNumeric(strAddNode.c_str(), Params().GetDefaultPort()));\n+        AddedNodeInfo addedNode{strAddNode, CService(), false, false};\n         if (service.IsValid()) {\n             // strAddNode is an IP:port\n             auto it = mapConnected.find(service);\n             if (it != mapConnected.end()) {\n-                ret.push_back(AddedNodeInfo{strAddNode, service, true, it->second});\n-            } else {\n-                ret.push_back(AddedNodeInfo{strAddNode, CService(), false, false});\n+                addedNode.resolvedAddress = service;\n+                addedNode.fConnected = true;\n+                addedNode.fInbound = it->second;\n             }\n         } else {\n             // strAddNode is a name\n             auto it = mapConnectedByName.find(strAddNode);\n             if (it != mapConnectedByName.end()) {\n-                ret.push_back(AddedNodeInfo{strAddNode, it->second.second, true, it->second.first});\n-            } else {\n-                ret.push_back(AddedNodeInfo{strAddNode, CService(), false, false});\n+                addedNode.resolvedAddress = it->second.second;\n+                addedNode.fConnected = true;\n+                addedNode.fInbound = it->second.first;\n             }\n         }\n+        ret.emplace_back(std::move(addedNode));\n     }\n \n     return ret;\n@@ -1992,7 +1994,7 @@ void CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFai\n     } else if (FindNode(std::string(pszDest)))\n         return;\n \n-    CNode* pnode = ConnectNode(addrConnect, pszDest, fCountFailure);\n+    CNode* pnode = ConnectNode(addrConnect, pszDest, fCountFailure, manual_connection);\n \n     if (!pnode)\n         return;\n@@ -2088,23 +2090,16 @@ bool CConnman::BindListenPort(const CService &addrBind, std::string& strError, b\n         LogPrintf(\"%s\\n\", strError);\n         return false;\n     }\n-#ifndef WIN32\n+\n     // Allow binding if the port is still in TIME_WAIT state after\n     // the program was closed and restarted.\n-    setsockopt(hListenSocket, SOL_SOCKET, SO_REUSEADDR, (void*)&nOne, sizeof(int));\n-#else\n-    setsockopt(hListenSocket, SOL_SOCKET, SO_REUSEADDR, (const char*)&nOne, sizeof(int));\n-#endif\n+    setsockopt(hListenSocket, SOL_SOCKET, SO_REUSEADDR, (sockopt_arg_type)&nOne, sizeof(int));\n \n     // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n     // and enable it by default or not. Try to enable it, if possible.\n     if (addrBind.IsIPv6()) {\n #ifdef IPV6_V6ONLY\n-#ifdef WIN32\n-        setsockopt(hListenSocket, IPPROTO_IPV6, IPV6_V6ONLY, (const char*)&nOne, sizeof(int));\n-#else\n-        setsockopt(hListenSocket, IPPROTO_IPV6, IPV6_V6ONLY, (void*)&nOne, sizeof(int));\n-#endif\n+        setsockopt(hListenSocket, IPPROTO_IPV6, IPV6_V6ONLY, (sockopt_arg_type)&nOne, sizeof(int));\n #endif\n #ifdef WIN32\n         int nProtLevel = PROTECTION_LEVEL_UNRESTRICTED;"
      },
      {
        "sha": "1bcc3cbb44eca66205465a591857eec823b0da27",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -338,7 +338,7 @@ class CConnman\n     CNode* FindNode(const CService& addr);\n \n     bool AttemptToEvictConnection();\n-    CNode* ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure);\n+    CNode* ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure, bool manual_connection);\n     bool IsWhitelistedRange(const CNetAddr &addr);\n \n     void DeleteNode(CNode* pnode);"
      },
      {
        "sha": "ed2fb598d24de4b639eaa4fe5411ab4aa0f1e07f",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 20,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -30,6 +30,8 @@\n #include <utilmoneystr.h>\n #include <utilstrencodings.h>\n \n+#include <memory>\n+\n #if defined(NDEBUG)\n # error \"Bitcoin cannot be compiled without assertions.\"\n #endif\n@@ -275,7 +277,7 @@ CNodeState *State(NodeId pnode) {\n     return &it->second;\n }\n \n-void UpdatePreferredDownload(CNode* node, CNodeState* state)\n+static void UpdatePreferredDownload(CNode* node, CNodeState* state)\n {\n     nPreferredDownload -= state->fPreferredDownload;\n \n@@ -285,7 +287,7 @@ void UpdatePreferredDownload(CNode* node, CNodeState* state)\n     nPreferredDownload += state->fPreferredDownload;\n }\n \n-void PushNodeVersion(CNode *pnode, CConnman* connman, int64_t nTime)\n+static void PushNodeVersion(CNode *pnode, CConnman* connman, int64_t nTime)\n {\n     ServiceFlags nLocalNodeServices = pnode->GetLocalServices();\n     uint64_t nonce = pnode->GetLocalNonce();\n@@ -309,7 +311,7 @@ void PushNodeVersion(CNode *pnode, CConnman* connman, int64_t nTime)\n // Requires cs_main.\n // Returns a bool indicating whether we requested this block.\n // Also used if a block was /not/ received and timed out or started with another peer\n-bool MarkBlockAsReceived(const uint256& hash) {\n+static bool MarkBlockAsReceived(const uint256& hash) {\n     std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n     if (itInFlight != mapBlocksInFlight.end()) {\n         CNodeState *state = State(itInFlight->second.first);\n@@ -335,7 +337,7 @@ bool MarkBlockAsReceived(const uint256& hash) {\n // Requires cs_main.\n // returns false, still setting pit, if the block was already in flight from the same peer\n // pit will only be valid as long as the same cs_main lock is being held\n-bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const CBlockIndex* pindex = nullptr, std::list<QueuedBlock>::iterator** pit = nullptr) {\n+static bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const CBlockIndex* pindex = nullptr, std::list<QueuedBlock>::iterator** pit = nullptr) {\n     CNodeState *state = State(nodeid);\n     assert(state != nullptr);\n \n@@ -369,7 +371,7 @@ bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const CBlockIndex*\n }\n \n /** Check whether the last unknown block a peer advertised is not yet known. */\n-void ProcessBlockAvailability(NodeId nodeid) {\n+static void ProcessBlockAvailability(NodeId nodeid) {\n     CNodeState *state = State(nodeid);\n     assert(state != nullptr);\n \n@@ -385,7 +387,7 @@ void ProcessBlockAvailability(NodeId nodeid) {\n }\n \n /** Update tracking information about which blocks a peer is assumed to have. */\n-void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) {\n+static void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) {\n     CNodeState *state = State(nodeid);\n     assert(state != nullptr);\n \n@@ -409,7 +411,7 @@ void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) {\n  * lNodesAnnouncingHeaderAndIDs, and keeping that list under a certain size by\n  * removing the first element if necessary.\n  */\n-void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman* connman) {\n+static void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman* connman) {\n     AssertLockHeld(cs_main);\n     CNodeState* nodestate = State(nodeid);\n     if (!nodestate || !nodestate->fSupportsDesiredCmpctVersion) {\n@@ -442,7 +444,7 @@ void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman* connman) {\n     }\n }\n \n-bool TipMayBeStale(const Consensus::Params &consensusParams)\n+static bool TipMayBeStale(const Consensus::Params &consensusParams)\n {\n     AssertLockHeld(cs_main);\n     if (g_last_tip_update == 0) {\n@@ -452,13 +454,13 @@ bool TipMayBeStale(const Consensus::Params &consensusParams)\n }\n \n // Requires cs_main\n-bool CanDirectFetch(const Consensus::Params &consensusParams)\n+static bool CanDirectFetch(const Consensus::Params &consensusParams)\n {\n     return chainActive.Tip()->GetBlockTime() > GetAdjustedTime() - consensusParams.nPowTargetSpacing * 20;\n }\n \n // Requires cs_main\n-bool PeerHasHeader(CNodeState *state, const CBlockIndex *pindex)\n+static bool PeerHasHeader(CNodeState *state, const CBlockIndex *pindex)\n {\n     if (state->pindexBestKnownBlock && pindex == state->pindexBestKnownBlock->GetAncestor(pindex->nHeight))\n         return true;\n@@ -469,7 +471,7 @@ bool PeerHasHeader(CNodeState *state, const CBlockIndex *pindex)\n \n /** Update pindexLastCommonBlock and add not-in-flight missing successors to vBlocks, until it has\n  *  at most count entries. */\n-void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, NodeId& nodeStaller, const Consensus::Params& consensusParams) {\n+static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, NodeId& nodeStaller, const Consensus::Params& consensusParams) {\n     if (count == 0)\n         return;\n \n@@ -568,7 +570,7 @@ void UpdateLastBlockAnnounceTime(NodeId node, int64_t time_in_seconds)\n \n // Returns true for outbound peers, excluding manual connections, feelers, and\n // one-shots\n-bool IsOutboundDisconnectionCandidate(const CNode *node)\n+static bool IsOutboundDisconnectionCandidate(const CNode *node)\n {\n     return !(node->fInbound || node->m_manual_connection || node->fFeeler || node->fOneShot);\n }\n@@ -640,7 +642,7 @@ bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats) {\n // mapOrphanTransactions\n //\n \n-void AddToCompactExtraTransactions(const CTransactionRef& tx) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans)\n+static void AddToCompactExtraTransactions(const CTransactionRef& tx) EXCLUSIVE_LOCKS_REQUIRED(g_cs_orphans)\n {\n     size_t max_extra_txn = gArgs.GetArg(\"-blockreconstructionextratxn\", DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN);\n     if (max_extra_txn <= 0)\n@@ -1098,8 +1100,10 @@ void static ProcessGetBlockData(CNode* pfrom, const Consensus::Params& consensus\n         }\n     } // release cs_main before calling ActivateBestChain\n     if (need_activate_chain) {\n-        CValidationState dummy;\n-        ActivateBestChain(dummy, Params(), a_recent_block);\n+        CValidationState state;\n+        if (!ActivateBestChain(state, Params(), a_recent_block)) {\n+            LogPrint(BCLog::NET, \"failed to activate chain (%s)\\n\", FormatStateMessage(state));\n+        }\n     }\n \n     LOCK(cs_main);\n@@ -1276,7 +1280,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n     }\n }\n \n-uint32_t GetFetchFlags(CNode* pfrom) {\n+static uint32_t GetFetchFlags(CNode* pfrom) {\n     uint32_t nFetchFlags = 0;\n     if ((pfrom->GetLocalServices() & NODE_WITNESS) && State(pfrom->GetId())->fHaveWitness) {\n         nFetchFlags |= MSG_WITNESS_FLAG;\n@@ -1567,6 +1571,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 LogPrint(BCLog::NET, \"Unparseable reject message received\\n\");\n             }\n         }\n+        return true;\n     }\n \n     else if (strCommand == NetMsgType::VERSION)\n@@ -1990,8 +1995,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 LOCK(cs_most_recent_block);\n                 a_recent_block = most_recent_block;\n             }\n-            CValidationState dummy;\n-            ActivateBestChain(dummy, Params(), a_recent_block);\n+            CValidationState state;\n+            if (!ActivateBestChain(state, Params(), a_recent_block)) {\n+                LogPrint(BCLog::NET, \"failed to activate chain (%s)\\n\", FormatStateMessage(state));\n+            }\n         }\n \n         LOCK(cs_main);\n@@ -2053,7 +2060,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         const CBlockIndex* pindex = LookupBlockIndex(req.blockhash);\n         if (!pindex || !(pindex->nStatus & BLOCK_HAVE_DATA)) {\n-            LogPrint(BCLog::NET, \"Peer %d sent us a getblocktxn for a block we don't have\", pfrom->GetId());\n+            LogPrint(BCLog::NET, \"Peer %d sent us a getblocktxn for a block we don't have\\n\", pfrom->GetId());\n             return true;\n         }\n \n@@ -2065,7 +2072,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // might maliciously send lots of getblocktxn requests to trigger\n             // expensive disk reads, because it will require the peer to\n             // actually receive all the data read from disk over the network.\n-            LogPrint(BCLog::NET, \"Peer %d sent us a getblocktxn for a block > %i deep\", pfrom->GetId(), MAX_BLOCKTXN_DEPTH);\n+            LogPrint(BCLog::NET, \"Peer %d sent us a getblocktxn for a block > %i deep\\n\", pfrom->GetId(), MAX_BLOCKTXN_DEPTH);\n             CInv inv;\n             inv.type = State(pfrom->GetId())->fWantsCmpctWitness ? MSG_WITNESS_BLOCK : MSG_BLOCK;\n             inv.hash = req.blockhash;"
      },
      {
        "sha": "195d0d203349f544b92ee17ada38a71edc23622c",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -86,9 +86,9 @@ class PeerLogicValidation final : public CValidationInterface, public NetEventsI\n };\n \n struct CNodeStateStats {\n-    int nMisbehavior;\n-    int nSyncHeight;\n-    int nCommonHeight;\n+    int nMisbehavior = 0;\n+    int nSyncHeight = -1;\n+    int nCommonHeight = -1;\n     std::vector<int> vHeightInFlight;\n };\n "
      },
      {
        "sha": "18d5948f8575ed8e97856b414e74a19e0c57d483",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 38,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -14,7 +14,7 @@ static const unsigned char pchOnionCat[] = {0xFD,0x87,0xD8,0x7E,0xEB,0x43};\n // 0xFD + sha256(\"bitcoin\")[0:5]\n static const unsigned char g_internal_prefix[] = { 0xFD, 0x6B, 0x88, 0xC0, 0x87, 0x24 };\n \n-void CNetAddr::Init()\n+CNetAddr::CNetAddr()\n {\n     memset(ip, 0, sizeof(ip));\n     scopeId = 0;\n@@ -67,11 +67,6 @@ bool CNetAddr::SetSpecial(const std::string &strName)\n     return false;\n }\n \n-CNetAddr::CNetAddr()\n-{\n-    Init();\n-}\n-\n CNetAddr::CNetAddr(const struct in_addr& ipv4Addr)\n {\n     SetRaw(NET_IPV4, (const uint8_t*)&ipv4Addr);\n@@ -290,11 +285,6 @@ bool operator==(const CNetAddr& a, const CNetAddr& b)\n     return (memcmp(a.ip, b.ip, 16) == 0);\n }\n \n-bool operator!=(const CNetAddr& a, const CNetAddr& b)\n-{\n-    return (memcmp(a.ip, b.ip, 16) != 0);\n-}\n-\n bool operator<(const CNetAddr& a, const CNetAddr& b)\n {\n     return (memcmp(a.ip, b.ip, 16) < 0);\n@@ -469,14 +459,8 @@ int CNetAddr::GetReachabilityFrom(const CNetAddr *paddrPartner) const\n     }\n }\n \n-void CService::Init()\n+CService::CService() : port(0)\n {\n-    port = 0;\n-}\n-\n-CService::CService()\n-{\n-    Init();\n }\n \n CService::CService(const CNetAddr& cip, unsigned short portIn) : CNetAddr(cip), port(portIn)\n@@ -525,11 +509,6 @@ bool operator==(const CService& a, const CService& b)\n     return static_cast<CNetAddr>(a) == static_cast<CNetAddr>(b) && a.port == b.port;\n }\n \n-bool operator!=(const CService& a, const CService& b)\n-{\n-    return static_cast<CNetAddr>(a) != static_cast<CNetAddr>(b) || a.port != b.port;\n-}\n-\n bool operator<(const CService& a, const CService& b)\n {\n     return static_cast<CNetAddr>(a) < static_cast<CNetAddr>(b) || (static_cast<CNetAddr>(a) == static_cast<CNetAddr>(b) && a.port < b.port);\n@@ -663,16 +642,16 @@ bool CSubNet::Match(const CNetAddr &addr) const\n static inline int NetmaskBits(uint8_t x)\n {\n     switch(x) {\n-    case 0x00: return 0; break;\n-    case 0x80: return 1; break;\n-    case 0xc0: return 2; break;\n-    case 0xe0: return 3; break;\n-    case 0xf0: return 4; break;\n-    case 0xf8: return 5; break;\n-    case 0xfc: return 6; break;\n-    case 0xfe: return 7; break;\n-    case 0xff: return 8; break;\n-    default: return -1; break;\n+    case 0x00: return 0;\n+    case 0x80: return 1;\n+    case 0xc0: return 2;\n+    case 0xe0: return 3;\n+    case 0xf0: return 4;\n+    case 0xf8: return 5;\n+    case 0xfc: return 6;\n+    case 0xfe: return 7;\n+    case 0xff: return 8;\n+    default: return -1;\n     }\n }\n \n@@ -724,11 +703,6 @@ bool operator==(const CSubNet& a, const CSubNet& b)\n     return a.valid == b.valid && a.network == b.network && !memcmp(a.netmask, b.netmask, 16);\n }\n \n-bool operator!=(const CSubNet& a, const CSubNet& b)\n-{\n-    return !(a==b);\n-}\n-\n bool operator<(const CSubNet& a, const CSubNet& b)\n {\n     return (a.network < b.network || (a.network == b.network && memcmp(a.netmask, b.netmask, 16) < 0));"
      },
      {
        "sha": "f8f2ab99ff26eaf5d47127501ef3b71ebfbc63d7",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 12,
        "deletions": 14,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -11,6 +11,7 @@\n \n #include <compat.h>\n #include <serialize.h>\n+#include <span.h>\n \n #include <stdint.h>\n #include <string>\n@@ -37,15 +38,16 @@ class CNetAddr\n     public:\n         CNetAddr();\n         explicit CNetAddr(const struct in_addr& ipv4Addr);\n-        void Init();\n         void SetIP(const CNetAddr& ip);\n \n+    private:\n         /**\n          * Set raw IPv4 or IPv6 address (in network byte order)\n          * @note Only NET_IPV4 and NET_IPV6 are allowed for network.\n          */\n         void SetRaw(Network network, const uint8_t *data);\n \n+    public:\n         /**\n           * Transform an arbitrary string into a non-routable ipv6 address.\n           * Useful for mapping resolved addresses back to their source.\n@@ -86,14 +88,14 @@ class CNetAddr\n         bool GetIn6Addr(struct in6_addr* pipv6Addr) const;\n \n         friend bool operator==(const CNetAddr& a, const CNetAddr& b);\n-        friend bool operator!=(const CNetAddr& a, const CNetAddr& b);\n+        friend bool operator!=(const CNetAddr& a, const CNetAddr& b) { return !(a == b); }\n         friend bool operator<(const CNetAddr& a, const CNetAddr& b);\n \n         ADD_SERIALIZE_METHODS;\n \n         template <typename Stream, typename Operation>\n         inline void SerializationOp(Stream& s, Operation ser_action) {\n-            READWRITE(FLATDATA(ip));\n+            READWRITE(ip);\n         }\n \n         friend class CSubNet;\n@@ -123,36 +125,35 @@ class CSubNet\n         bool IsValid() const;\n \n         friend bool operator==(const CSubNet& a, const CSubNet& b);\n-        friend bool operator!=(const CSubNet& a, const CSubNet& b);\n+        friend bool operator!=(const CSubNet& a, const CSubNet& b) { return !(a == b); }\n         friend bool operator<(const CSubNet& a, const CSubNet& b);\n \n         ADD_SERIALIZE_METHODS;\n \n         template <typename Stream, typename Operation>\n         inline void SerializationOp(Stream& s, Operation ser_action) {\n             READWRITE(network);\n-            READWRITE(FLATDATA(netmask));\n-            READWRITE(FLATDATA(valid));\n+            READWRITE(netmask);\n+            READWRITE(valid);\n         }\n };\n \n /** A combination of a network address (CNetAddr) and a (TCP) port */\n class CService : public CNetAddr\n {\n     protected:\n-        unsigned short port; // host order\n+        uint16_t port; // host order\n \n     public:\n         CService();\n         CService(const CNetAddr& ip, unsigned short port);\n         CService(const struct in_addr& ipv4Addr, unsigned short port);\n         explicit CService(const struct sockaddr_in& addr);\n-        void Init();\n         unsigned short GetPort() const;\n         bool GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const;\n         bool SetSockAddr(const struct sockaddr* paddr);\n         friend bool operator==(const CService& a, const CService& b);\n-        friend bool operator!=(const CService& a, const CService& b);\n+        friend bool operator!=(const CService& a, const CService& b) { return !(a == b); }\n         friend bool operator<(const CService& a, const CService& b);\n         std::vector<unsigned char> GetKey() const;\n         std::string ToString() const;\n@@ -166,11 +167,8 @@ class CService : public CNetAddr\n \n         template <typename Stream, typename Operation>\n         inline void SerializationOp(Stream& s, Operation ser_action) {\n-            READWRITE(FLATDATA(ip));\n-            unsigned short portN = htons(port);\n-            READWRITE(FLATDATA(portN));\n-            if (ser_action.ForRead())\n-                 port = ntohs(portN);\n+            READWRITE(ip);\n+            READWRITE(WrapBigEndian(port));\n         }\n };\n "
      },
      {
        "sha": "15f9016be8e102ff447d29f651754aa4c8e00ee6",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 10,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -9,6 +9,7 @@\n #include <sync.h>\n #include <uint256.h>\n #include <random.h>\n+#include <tinyformat.h>\n #include <util.h>\n #include <utilstrencodings.h>\n \n@@ -288,7 +289,7 @@ struct ProxyCredentials\n };\n \n /** Convert SOCKS5 reply to an error message */\n-std::string Socks5ErrorString(uint8_t err)\n+static std::string Socks5ErrorString(uint8_t err)\n {\n     switch(err) {\n         case SOCKS5Reply::GENFAILURE:\n@@ -468,7 +469,17 @@ SOCKET CreateSocket(const CService &addrConnect)\n     return hSocket;\n }\n \n-bool ConnectSocketDirectly(const CService &addrConnect, const SOCKET& hSocket, int nTimeout)\n+template<typename... Args>\n+static void LogConnectFailure(bool manual_connection, const char* fmt, const Args&... args) {\n+    std::string error_message = tfm::format(fmt, args...);\n+    if (manual_connection) {\n+        LogPrintf(\"%s\\n\", error_message);\n+    } else {\n+        LogPrint(BCLog::NET, \"%s\\n\", error_message);\n+    }\n+}\n+\n+bool ConnectSocketDirectly(const CService &addrConnect, const SOCKET& hSocket, int nTimeout, bool manual_connection)\n {\n     struct sockaddr_storage sockaddr;\n     socklen_t len = sizeof(sockaddr);\n@@ -502,18 +513,14 @@ bool ConnectSocketDirectly(const CService &addrConnect, const SOCKET& hSocket, i\n                 return false;\n             }\n             socklen_t nRetSize = sizeof(nRet);\n-#ifdef WIN32\n-            if (getsockopt(hSocket, SOL_SOCKET, SO_ERROR, (char*)(&nRet), &nRetSize) == SOCKET_ERROR)\n-#else\n-            if (getsockopt(hSocket, SOL_SOCKET, SO_ERROR, &nRet, &nRetSize) == SOCKET_ERROR)\n-#endif\n+            if (getsockopt(hSocket, SOL_SOCKET, SO_ERROR, (sockopt_arg_type)&nRet, &nRetSize) == SOCKET_ERROR)\n             {\n                 LogPrintf(\"getsockopt() for %s failed: %s\\n\", addrConnect.ToString(), NetworkErrorString(WSAGetLastError()));\n                 return false;\n             }\n             if (nRet != 0)\n             {\n-                LogPrintf(\"connect() to %s failed after select(): %s\\n\", addrConnect.ToString(), NetworkErrorString(nRet));\n+                LogConnectFailure(manual_connection, \"connect() to %s failed after select(): %s\", addrConnect.ToString(), NetworkErrorString(nRet));\n                 return false;\n             }\n         }\n@@ -523,7 +530,7 @@ bool ConnectSocketDirectly(const CService &addrConnect, const SOCKET& hSocket, i\n         else\n #endif\n         {\n-            LogPrintf(\"connect() to %s failed: %s\\n\", addrConnect.ToString(), NetworkErrorString(WSAGetLastError()));\n+            LogConnectFailure(manual_connection, \"connect() to %s failed: %s\", addrConnect.ToString(), NetworkErrorString(WSAGetLastError()));\n             return false;\n         }\n     }\n@@ -581,7 +588,7 @@ bool IsProxy(const CNetAddr &addr) {\n bool ConnectThroughProxy(const proxyType &proxy, const std::string& strDest, int port, const SOCKET& hSocket, int nTimeout, bool *outProxyConnectionFailed)\n {\n     // first connect to proxy server\n-    if (!ConnectSocketDirectly(proxy.proxy, hSocket, nTimeout)) {\n+    if (!ConnectSocketDirectly(proxy.proxy, hSocket, nTimeout, true)) {\n         if (outProxyConnectionFailed)\n             *outProxyConnectionFailed = true;\n         return false;\n@@ -601,6 +608,7 @@ bool ConnectThroughProxy(const proxyType &proxy, const std::string& strDest, int\n     }\n     return true;\n }\n+\n bool LookupSubNet(const char* pszName, CSubNet& ret)\n {\n     std::string strSubnet(pszName);"
      },
      {
        "sha": "50d4bc54faeef4ff8f788727c48a11da346e2daf",
        "filename": "src/netbase.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/netbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/netbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -52,7 +52,7 @@ bool Lookup(const char *pszName, std::vector<CService>& vAddr, int portDefault,\n CService LookupNumeric(const char *pszName, int portDefault = 0);\n bool LookupSubNet(const char *pszName, CSubNet& subnet);\n SOCKET CreateSocket(const CService &addrConnect);\n-bool ConnectSocketDirectly(const CService &addrConnect, const SOCKET& hSocketRet, int nTimeout);\n+bool ConnectSocketDirectly(const CService &addrConnect, const SOCKET& hSocketRet, int nTimeout, bool manual_connection);\n bool ConnectThroughProxy(const proxyType &proxy, const std::string& strDest, int port, const SOCKET& hSocketRet, int nTimeout, bool *outProxyConnectionFailed);\n /** Return readable error string for a network error code */\n std::string NetworkErrorString(int err);"
      },
      {
        "sha": "8c34bee23735445b7120205d72c2f01654bd4c17",
        "filename": "src/policy/fees.h",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/policy/fees.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/policy/fees.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/fees.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -2,8 +2,8 @@\n // Copyright (c) 2009-2017 The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-#ifndef BITCOIN_POLICYESTIMATOR_H\n-#define BITCOIN_POLICYESTIMATOR_H\n+#ifndef BITCOIN_POLICY_FEES_H\n+#define BITCOIN_POLICY_FEES_H\n \n #include <amount.h>\n #include <policy/feerate.h>\n@@ -12,6 +12,7 @@\n #include <sync.h>\n \n #include <map>\n+#include <memory>\n #include <string>\n #include <vector>\n \n@@ -68,7 +69,7 @@ class TxConfirmStats;\n \n /* Identifier for each of the 3 different TxConfirmStats which will track\n  * history over different time horizons. */\n-enum FeeEstimateHorizon {\n+enum class FeeEstimateHorizon {\n     SHORT_HALFLIFE = 0,\n     MED_HALFLIFE = 1,\n     LONG_HALFLIFE = 2\n@@ -294,4 +295,4 @@ class FeeFilterRounder\n     FastRandomContext insecure_rand;\n };\n \n-#endif /*BITCOIN_POLICYESTIMATOR_H */\n+#endif // BITCOIN_POLICY_FEES_H"
      },
      {
        "sha": "5963bf371abe6bf7e02b1fd0ee7b8b6fc3b74a3b",
        "filename": "src/policy/policy.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/policy/policy.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/policy/policy.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -179,7 +179,7 @@ bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n         {\n             std::vector<std::vector<unsigned char> > stack;\n             // convert the scriptSig into a stack, so we can inspect the redeemScript\n-            if (!EvalScript(stack, tx.vin[i].scriptSig, SCRIPT_VERIFY_NONE, BaseSignatureChecker(), SIGVERSION_BASE))\n+            if (!EvalScript(stack, tx.vin[i].scriptSig, SCRIPT_VERIFY_NONE, BaseSignatureChecker(), SigVersion::BASE))\n                 return false;\n             if (stack.empty())\n                 return false;\n@@ -215,7 +215,7 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n             // If the scriptPubKey is P2SH, we try to extract the redeemScript casually by converting the scriptSig\n             // into a stack. We do not check IsPushOnly nor compare the hash as these will be done later anyway.\n             // If the check fails at this stage, we know that this txid must be a bad one.\n-            if (!EvalScript(stack, tx.vin[i].scriptSig, SCRIPT_VERIFY_NONE, BaseSignatureChecker(), SIGVERSION_BASE))\n+            if (!EvalScript(stack, tx.vin[i].scriptSig, SCRIPT_VERIFY_NONE, BaseSignatureChecker(), SigVersion::BASE))\n                 return false;\n             if (stack.empty())\n                 return false;\n@@ -230,7 +230,7 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n             return false;\n \n         // Check P2WSH standard limits\n-        if (witnessversion == 0 && witnessprogram.size() == 32) {\n+        if (witnessversion == 0 && witnessprogram.size() == WITNESS_V0_SCRIPTHASH_SIZE) {\n             if (tx.vin[i].scriptWitness.stack.back().size() > MAX_STANDARD_P2WSH_SCRIPT_SIZE)\n                 return false;\n             size_t sizeWitnessStack = tx.vin[i].scriptWitness.stack.size() - 1;"
      },
      {
        "sha": "81b2a7fadc5a8ad944a8a9bdeb52dcd6119cefc0",
        "filename": "src/policy/rbf.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/policy/rbf.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/policy/rbf.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/rbf.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -22,13 +22,13 @@ RBFTransactionState IsRBFOptIn(const CTransaction &tx, CTxMemPool &pool)\n \n     // First check the transaction itself.\n     if (SignalsOptInRBF(tx)) {\n-        return RBF_TRANSACTIONSTATE_REPLACEABLE_BIP125;\n+        return RBFTransactionState::REPLACEABLE_BIP125;\n     }\n \n     // If this transaction is not in our mempool, then we can't be sure\n     // we will know about all its inputs.\n     if (!pool.exists(tx.GetHash())) {\n-        return RBF_TRANSACTIONSTATE_UNKNOWN;\n+        return RBFTransactionState::UNKNOWN;\n     }\n \n     // If all the inputs have nSequence >= maxint-1, it still might be\n@@ -40,8 +40,8 @@ RBFTransactionState IsRBFOptIn(const CTransaction &tx, CTxMemPool &pool)\n \n     for (CTxMemPool::txiter it : setAncestors) {\n         if (SignalsOptInRBF(it->GetTx())) {\n-            return RBF_TRANSACTIONSTATE_REPLACEABLE_BIP125;\n+            return RBFTransactionState::REPLACEABLE_BIP125;\n         }\n     }\n-    return RBF_TRANSACTIONSTATE_FINAL;\n+    return RBFTransactionState::FINAL;\n }"
      },
      {
        "sha": "c0a25f75b58faa80c0f98aeacc2cf1d7bc5459c9",
        "filename": "src/policy/rbf.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/policy/rbf.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/policy/rbf.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/rbf.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -9,10 +9,10 @@\n \n static const uint32_t MAX_BIP125_RBF_SEQUENCE = 0xfffffffd;\n \n-enum RBFTransactionState {\n-    RBF_TRANSACTIONSTATE_UNKNOWN,\n-    RBF_TRANSACTIONSTATE_REPLACEABLE_BIP125,\n-    RBF_TRANSACTIONSTATE_FINAL\n+enum class RBFTransactionState {\n+    UNKNOWN,\n+    REPLACEABLE_BIP125,\n+    FINAL\n };\n \n // Check whether the sequence numbers on this transaction are signaling\n@@ -23,6 +23,6 @@ bool SignalsOptInRBF(const CTransaction &tx);\n // according to BIP 125\n // This involves checking sequence numbers of the transaction, as well\n // as the sequence numbers of all in-mempool ancestors.\n-RBFTransactionState IsRBFOptIn(const CTransaction &tx, CTxMemPool &pool);\n+RBFTransactionState IsRBFOptIn(const CTransaction &tx, CTxMemPool &pool) EXCLUSIVE_LOCKS_REQUIRED(pool.cs);\n \n #endif // BITCOIN_POLICY_RBF_H"
      },
      {
        "sha": "1fca55d91043537522f592771d4081637f24a0ca",
        "filename": "src/primitives/block.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/primitives/block.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/primitives/block.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/block.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -93,7 +93,7 @@ class CBlock : public CBlockHeader\n \n     template <typename Stream, typename Operation>\n     inline void SerializationOp(Stream& s, Operation ser_action) {\n-        READWRITE(*static_cast<CBlockHeader*>(this));\n+        READWRITEAS(CBlockHeader, *this);\n         READWRITE(vtx);\n     }\n "
      },
      {
        "sha": "3a9b2d2561bb3a470c7950a56b90b56093bcb513",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -48,10 +48,10 @@ class CMessageHeader\n     template <typename Stream, typename Operation>\n     inline void SerializationOp(Stream& s, Operation ser_action)\n     {\n-        READWRITE(FLATDATA(pchMessageStart));\n-        READWRITE(FLATDATA(pchCommand));\n+        READWRITE(pchMessageStart);\n+        READWRITE(pchCommand);\n         READWRITE(nMessageSize);\n-        READWRITE(FLATDATA(pchChecksum));\n+        READWRITE(pchChecksum);\n     }\n \n     char pchMessageStart[MESSAGE_START_SIZE];\n@@ -349,7 +349,7 @@ class CAddress : public CService\n         uint64_t nServicesInt = nServices;\n         READWRITE(nServicesInt);\n         nServices = static_cast<ServiceFlags>(nServicesInt);\n-        READWRITE(*static_cast<CService*>(this));\n+        READWRITEAS(CService, *this);\n     }\n \n     // TODO: make private (improves encapsulation)"
      },
      {
        "sha": "9c6c6b085ed030c362425b1f0d35e61bc596a0d4",
        "filename": "src/pubkey.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/pubkey.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/pubkey.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -70,6 +70,11 @@ class CPubKey\n     }\n \n public:\n+\n+    bool static ValidSize(const std::vector<unsigned char> &vch) {\n+      return vch.size() > 0 && GetLen(vch[0]) == vch.size();\n+    }\n+\n     //! Construct an invalid public key.\n     CPubKey()\n     {"
      },
      {
        "sha": "d8acf96ceb290b3dfc2bfd4c6ffa02481687c16e",
        "filename": "src/qt/README.md",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/README.md?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -1,6 +1,6 @@\n-This directory contains the BitcoinQT graphical user interface (GUI). It uses the cross platform framework [QT](https://www1.qt.io/developers/).\n+This directory contains the BitcoinQT graphical user interface (GUI). It uses the cross-platform framework [Qt](https://www1.qt.io/developers/).\n \n-The current precise version for QT 5 is specified in [qt.mk](/depends/packages/qt.mk). QT 4 is also supported (see [#8263](https://github.com/bitcoin/bitcoin/issues/8263)).\n+The current precise version for Qt 5 is specified in [qt.mk](/depends/packages/qt.mk). Qt 4 is also supported (see [#8263](https://github.com/bitcoin/bitcoin/issues/8263)).\n \n ## Compile and run\n \n@@ -16,7 +16,7 @@ To run:\n \n ### forms\n \n-Contains [Designer UI](http://doc.qt.io/qt-5.9/designer-using-a-ui-file.html) files. They are created with [Qt Creator](#use-qt-Creator-as IDE), but can be edited using any text editor.\n+Contains [Designer UI](http://doc.qt.io/qt-5.9/designer-using-a-ui-file.html) files. They are created with [Qt Creator](#using-qt-creator-as-ide), but can be edited using any text editor.\n \n ### locale\n \n@@ -36,7 +36,7 @@ Represents the main window of the Bitcoin UI.\n \n ### \\*model.(h/cpp)\n \n-The model. When it has a corresponding controller, it generally inherits from  [QAbstractTableModel](http://doc.qt.io/qt-5/qabstracttablemodel.html). Models that are used by controllers as helpers inherit from other QT classes like [QValidator](http://doc.qt.io/qt-5/qvalidator.html).\n+The model. When it has a corresponding controller, it generally inherits from  [QAbstractTableModel](http://doc.qt.io/qt-5/qabstracttablemodel.html). Models that are used by controllers as helpers inherit from other Qt classes like [QValidator](http://doc.qt.io/qt-5/qvalidator.html).\n \n ClientModel is used by the main application `bitcoingui` and several models like `peertablemodel`.\n \n@@ -69,7 +69,7 @@ Represents the view to a single wallet.\n \n ## Contribute\n \n-See [CONTRIBUTING.md](/CONTRIBUTING.md) for general guidelines. Specifically for QT:\n+See [CONTRIBUTING.md](/CONTRIBUTING.md) for general guidelines. Specifically for Qt:\n \n * don't change `local/bitcoin_en.ts`; this happens [automatically](/doc/translation_process.md#writing-code-with-translations)\n \n@@ -83,7 +83,7 @@ Uncheck everything except Qt Creator during the installation process.\n \n Instructions for OSX:\n \n-1. Make sure you installed everything through Homebrew mentioned in the [OSX build instructions](/docs/build-osx.md)\n+1. Make sure you installed everything through Homebrew mentioned in the [OSX build instructions](/doc/build-osx.md)\n 2. Use `./configure` with the `--enable-debug` flag\n 3. In Qt Creator do \"New Project\" -> Import Project -> Import Existing Project\n 4. Enter \"bitcoin-qt\" as project name, enter src/qt as location"
      },
      {
        "sha": "ba420c5e152dc91d05234b9ef9ee5e45588aff1b",
        "filename": "src/qt/addressbookpage.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/addressbookpage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/addressbookpage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/addressbookpage.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -38,7 +38,7 @@ class AddressBookPage : public QDialog\n         ForEditing  /**< Open address book for editing */\n     };\n \n-    explicit AddressBookPage(const PlatformStyle *platformStyle, Mode mode, Tabs tab, QWidget *parent);\n+    explicit AddressBookPage(const PlatformStyle *platformStyle, Mode mode, Tabs tab, QWidget *parent = 0);\n     ~AddressBookPage();\n \n     void setModel(AddressTableModel *model);"
      },
      {
        "sha": "25b615e6f8571dbd4ed4e615eff8a6065e6e25e8",
        "filename": "src/qt/addresstablemodel.cpp",
        "status": "modified",
        "additions": 44,
        "deletions": 39,
        "changes": 83,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/addresstablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/addresstablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/addresstablemodel.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -7,6 +7,7 @@\n #include <qt/guiutil.h>\n #include <qt/walletmodel.h>\n \n+#include <interfaces/node.h>\n #include <key_io.h>\n #include <wallet/wallet.h>\n \n@@ -67,28 +68,23 @@ static AddressTableEntry::Type translateTransactionType(const QString &strPurpos\n class AddressTablePriv\n {\n public:\n-    CWallet *wallet;\n     QList<AddressTableEntry> cachedAddressTable;\n     AddressTableModel *parent;\n \n-    AddressTablePriv(CWallet *_wallet, AddressTableModel *_parent):\n-        wallet(_wallet), parent(_parent) {}\n+    AddressTablePriv(AddressTableModel *_parent):\n+        parent(_parent) {}\n \n-    void refreshAddressTable()\n+    void refreshAddressTable(interfaces::Wallet& wallet)\n     {\n         cachedAddressTable.clear();\n         {\n-            LOCK(wallet->cs_wallet);\n-            for (const std::pair<CTxDestination, CAddressBookData>& item : wallet->mapAddressBook)\n+            for (const auto& address : wallet.getAddresses())\n             {\n-                const CTxDestination& address = item.first;\n-                bool fMine = IsMine(*wallet, address);\n                 AddressTableEntry::Type addressType = translateTransactionType(\n-                        QString::fromStdString(item.second.purpose), fMine);\n-                const std::string& strName = item.second.name;\n+                        QString::fromStdString(address.purpose), address.is_mine);\n                 cachedAddressTable.append(AddressTableEntry(addressType,\n-                                  QString::fromStdString(strName),\n-                                  QString::fromStdString(EncodeDestination(address))));\n+                                  QString::fromStdString(address.name),\n+                                  QString::fromStdString(EncodeDestination(address.dest))));\n             }\n         }\n         // qLowerBound() and qUpperBound() require our cachedAddressTable list to be sorted in asc order\n@@ -162,12 +158,12 @@ class AddressTablePriv\n     }\n };\n \n-AddressTableModel::AddressTableModel(CWallet *_wallet, WalletModel *parent) :\n-    QAbstractTableModel(parent),walletModel(parent),wallet(_wallet),priv(0)\n+AddressTableModel::AddressTableModel(WalletModel *parent) :\n+    QAbstractTableModel(parent), walletModel(parent)\n {\n     columns << tr(\"Label\") << tr(\"Address\");\n-    priv = new AddressTablePriv(wallet, this);\n-    priv->refreshAddressTable();\n+    priv = new AddressTablePriv(this);\n+    priv->refreshAddressTable(parent->wallet());\n }\n \n AddressTableModel::~AddressTableModel()\n@@ -244,7 +240,6 @@ bool AddressTableModel::setData(const QModelIndex &index, const QVariant &value,\n \n     if(role == Qt::EditRole)\n     {\n-        LOCK(wallet->cs_wallet); /* For SetAddressBook / DelAddressBook */\n         CTxDestination curAddress = DecodeDestination(rec->address.toStdString());\n         if(index.column() == Label)\n         {\n@@ -254,7 +249,7 @@ bool AddressTableModel::setData(const QModelIndex &index, const QVariant &value,\n                 editStatus = NO_CHANGES;\n                 return false;\n             }\n-            wallet->SetAddressBook(curAddress, value.toString().toStdString(), strPurpose);\n+            walletModel->wallet().setAddressBook(curAddress, value.toString().toStdString(), strPurpose);\n         } else if(index.column() == Address) {\n             CTxDestination newAddress = DecodeDestination(value.toString().toStdString());\n             // Refuse to set invalid address, set error status and return false\n@@ -271,7 +266,8 @@ bool AddressTableModel::setData(const QModelIndex &index, const QVariant &value,\n             }\n             // Check for duplicate addresses to prevent accidental deletion of addresses, if you try\n             // to paste an existing address over another address (with a different label)\n-            else if(wallet->mapAddressBook.count(newAddress))\n+            if (walletModel->wallet().getAddress(\n+                    newAddress, /* name= */ nullptr, /* is_mine= */ nullptr, /* purpose= */ nullptr))\n             {\n                 editStatus = DUPLICATE_ADDRESS;\n                 return false;\n@@ -280,9 +276,9 @@ bool AddressTableModel::setData(const QModelIndex &index, const QVariant &value,\n             else if(rec->type == AddressTableEntry::Sending)\n             {\n                 // Remove old entry\n-                wallet->DelAddressBook(curAddress);\n+                walletModel->wallet().delAddressBook(curAddress);\n                 // Add new entry with new address\n-                wallet->SetAddressBook(newAddress, rec->label.toStdString(), strPurpose);\n+                walletModel->wallet().setAddressBook(newAddress, value.toString().toStdString(), strPurpose);\n             }\n         }\n         return true;\n@@ -356,8 +352,8 @@ QString AddressTableModel::addRow(const QString &type, const QString &label, con\n         }\n         // Check for duplicate addresses\n         {\n-            LOCK(wallet->cs_wallet);\n-            if(wallet->mapAddressBook.count(DecodeDestination(strAddress)))\n+            if (walletModel->wallet().getAddress(\n+                    DecodeDestination(strAddress), /* name= */ nullptr, /* is_mine= */ nullptr, /* purpose= */ nullptr))\n             {\n                 editStatus = DUPLICATE_ADDRESS;\n                 return QString();\n@@ -368,7 +364,7 @@ QString AddressTableModel::addRow(const QString &type, const QString &label, con\n     {\n         // Generate a new address to associate with given label\n         CPubKey newKey;\n-        if(!wallet->GetKeyFromPool(newKey))\n+        if(!walletModel->wallet().getKeyFromPool(false /* internal */, newKey))\n         {\n             WalletModel::UnlockContext ctx(walletModel->requestUnlock());\n             if(!ctx.isValid())\n@@ -377,13 +373,13 @@ QString AddressTableModel::addRow(const QString &type, const QString &label, con\n                 editStatus = WALLET_UNLOCK_FAILURE;\n                 return QString();\n             }\n-            if(!wallet->GetKeyFromPool(newKey))\n+            if(!walletModel->wallet().getKeyFromPool(false /* internal */, newKey))\n             {\n                 editStatus = KEY_GENERATION_FAILURE;\n                 return QString();\n             }\n         }\n-        wallet->LearnRelatedScripts(newKey, address_type);\n+        walletModel->wallet().learnRelatedScripts(newKey, address_type);\n         strAddress = EncodeDestination(GetDestinationForKey(newKey, address_type));\n     }\n     else\n@@ -392,7 +388,7 @@ QString AddressTableModel::addRow(const QString &type, const QString &label, con\n     }\n \n     // Add entry\n-    wallet->SetAddressBook(DecodeDestination(strAddress), strLabel,\n+    walletModel->wallet().setAddressBook(DecodeDestination(strAddress), strLabel,\n                            (type == Send ? \"send\" : \"receive\"));\n     return QString::fromStdString(strAddress);\n }\n@@ -407,26 +403,35 @@ bool AddressTableModel::removeRows(int row, int count, const QModelIndex &parent\n         // Also refuse to remove receiving addresses.\n         return false;\n     }\n-    wallet->DelAddressBook(DecodeDestination(rec->address.toStdString()));\n+    walletModel->wallet().delAddressBook(DecodeDestination(rec->address.toStdString()));\n     return true;\n }\n \n-/* Look up label for address in address book, if not found return empty string.\n- */\n QString AddressTableModel::labelForAddress(const QString &address) const\n {\n-    {\n-        LOCK(wallet->cs_wallet);\n-        CTxDestination destination = DecodeDestination(address.toStdString());\n-        std::map<CTxDestination, CAddressBookData>::iterator mi = wallet->mapAddressBook.find(destination);\n-        if (mi != wallet->mapAddressBook.end())\n-        {\n-            return QString::fromStdString(mi->second.name);\n-        }\n+    std::string name;\n+    if (getAddressData(address, &name, /* purpose= */ nullptr)) {\n+        return QString::fromStdString(name);\n+    }\n+    return QString();\n+}\n+\n+QString AddressTableModel::purposeForAddress(const QString &address) const\n+{\n+    std::string purpose;\n+    if (getAddressData(address, /* name= */ nullptr, &purpose)) {\n+        return QString::fromStdString(purpose);\n     }\n     return QString();\n }\n \n+bool AddressTableModel::getAddressData(const QString &address,\n+        std::string* name,\n+        std::string* purpose) const {\n+    CTxDestination destination = DecodeDestination(address.toStdString());\n+    return walletModel->wallet().getAddress(destination, name, /* is_mine= */ nullptr, purpose);\n+}\n+\n int AddressTableModel::lookupAddress(const QString &address) const\n {\n     QModelIndexList lst = match(index(0, Address, QModelIndex()),\n@@ -441,7 +446,7 @@ int AddressTableModel::lookupAddress(const QString &address) const\n     }\n }\n \n-OutputType AddressTableModel::GetDefaultAddressType() const { return wallet->m_default_address_type; };\n+OutputType AddressTableModel::GetDefaultAddressType() const { return walletModel->wallet().getDefaultAddressType(); };\n \n void AddressTableModel::emitDataChanged(int idx)\n {"
      },
      {
        "sha": "6e1b53b0498c00e36c6e9eb634d878579e0b8eee",
        "filename": "src/qt/addresstablemodel.h",
        "status": "modified",
        "additions": 14,
        "deletions": 8,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/addresstablemodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/addresstablemodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/addresstablemodel.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -13,7 +13,9 @@ enum class OutputType;\n class AddressTablePriv;\n class WalletModel;\n \n-class CWallet;\n+namespace interfaces {\n+class Wallet;\n+}\n \n /**\n    Qt model of the address book in the core. This allows views to access and modify the address book.\n@@ -23,7 +25,7 @@ class AddressTableModel : public QAbstractTableModel\n     Q_OBJECT\n \n public:\n-    explicit AddressTableModel(CWallet *wallet, WalletModel *parent = 0);\n+    explicit AddressTableModel(WalletModel *parent = 0);\n     ~AddressTableModel();\n \n     enum ColumnIndex {\n@@ -65,10 +67,12 @@ class AddressTableModel : public QAbstractTableModel\n      */\n     QString addRow(const QString &type, const QString &label, const QString &address, const OutputType address_type);\n \n-    /* Look up label for address in address book, if not found return empty string.\n-     */\n+    /** Look up label for address in address book, if not found return empty string. */\n     QString labelForAddress(const QString &address) const;\n \n+    /** Look up purpose for address in address book, if not found return empty string. */\n+    QString purposeForAddress(const QString &address) const;\n+\n     /* Look up row index of an address in the model.\n        Return -1 if not found.\n      */\n@@ -79,11 +83,13 @@ class AddressTableModel : public QAbstractTableModel\n     OutputType GetDefaultAddressType() const;\n \n private:\n-    WalletModel *walletModel;\n-    CWallet *wallet;\n-    AddressTablePriv *priv;\n+    WalletModel* const walletModel;\n+    AddressTablePriv *priv = nullptr;\n     QStringList columns;\n-    EditStatus editStatus;\n+    EditStatus editStatus = OK;\n+\n+    /** Look up address book data given an address string. */\n+    bool getAddressData(const QString &address, std::string* name, std::string* purpose) const;\n \n     /** Notify listeners that data changed. */\n     void emitDataChanged(int index);"
      },
      {
        "sha": "26cb03c2c7e4b4635b280f7c5e141868c9e16712",
        "filename": "src/qt/bantablemodel.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 5,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/bantablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/bantablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bantablemodel.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -8,6 +8,7 @@\n #include <qt/guiconstants.h>\n #include <qt/guiutil.h>\n \n+#include <interfaces/node.h>\n #include <sync.h>\n #include <utiltime.h>\n \n@@ -45,11 +46,10 @@ class BanTablePriv\n     Qt::SortOrder sortOrder;\n \n     /** Pull a full list of banned nodes from CNode into our cache */\n-    void refreshBanlist()\n+    void refreshBanlist(interfaces::Node& node)\n     {\n         banmap_t banMap;\n-        if(g_connman)\n-            g_connman->GetBanned(banMap);\n+        node.getBanned(banMap);\n \n         cachedBanlist.clear();\n #if QT_VERSION >= 0x040700\n@@ -82,8 +82,9 @@ class BanTablePriv\n     }\n };\n \n-BanTableModel::BanTableModel(ClientModel *parent) :\n+BanTableModel::BanTableModel(interfaces::Node& node, ClientModel *parent) :\n     QAbstractTableModel(parent),\n+    m_node(node),\n     clientModel(parent)\n {\n     columns << tr(\"IP/Netmask\") << tr(\"Banned Until\");\n@@ -168,7 +169,7 @@ QModelIndex BanTableModel::index(int row, int column, const QModelIndex &parent)\n void BanTableModel::refresh()\n {\n     Q_EMIT layoutAboutToBeChanged();\n-    priv->refreshBanlist();\n+    priv->refreshBanlist(m_node);\n     Q_EMIT layoutChanged();\n }\n "
      },
      {
        "sha": "d6c8dbf6dd3b39529b7ac964c30030d728e521a1",
        "filename": "src/qt/bantablemodel.h",
        "status": "modified",
        "additions": 8,
        "deletions": 1,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/bantablemodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/bantablemodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bantablemodel.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -7,12 +7,18 @@\n \n #include <net.h>\n \n+#include <memory>\n+\n #include <QAbstractTableModel>\n #include <QStringList>\n \n class ClientModel;\n class BanTablePriv;\n \n+namespace interfaces {\n+    class Node;\n+}\n+\n struct CCombinedBan {\n     CSubNet subnet;\n     CBanEntry banEntry;\n@@ -39,7 +45,7 @@ class BanTableModel : public QAbstractTableModel\n     Q_OBJECT\n \n public:\n-    explicit BanTableModel(ClientModel *parent = 0);\n+    explicit BanTableModel(interfaces::Node& node, ClientModel *parent = 0);\n     ~BanTableModel();\n     void startAutoRefresh();\n     void stopAutoRefresh();\n@@ -65,6 +71,7 @@ public Q_SLOTS:\n     void refresh();\n \n private:\n+    interfaces::Node& m_node;\n     ClientModel *clientModel;\n     QStringList columns;\n     std::unique_ptr<BanTablePriv> priv;"
      },
      {
        "sha": "91783176017b6ae33952cb165bb412b08bd08291",
        "filename": "src/qt/bitcoin.cpp",
        "status": "modified",
        "additions": 79,
        "deletions": 73,
        "changes": 152,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoin.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -27,16 +27,17 @@\n #endif\n \n #include <init.h>\n+#include <interfaces/handler.h>\n+#include <interfaces/node.h>\n #include <rpc/server.h>\n #include <ui_interface.h>\n #include <uint256.h>\n #include <util.h>\n #include <warnings.h>\n \n-#ifdef ENABLE_WALLET\n-#include <wallet/wallet.h>\n-#endif\n+#include <walletinitinterface.h>\n \n+#include <memory>\n #include <stdint.h>\n \n #include <boost/thread.hpp>\n@@ -178,11 +179,7 @@ class BitcoinCore: public QObject\n {\n     Q_OBJECT\n public:\n-    explicit BitcoinCore();\n-    /** Basic initialization, before starting initialization/shutdown thread.\n-     * Return true on success.\n-     */\n-    static bool baseInitialize();\n+    explicit BitcoinCore(interfaces::Node& node);\n \n public Q_SLOTS:\n     void initialize();\n@@ -194,17 +191,18 @@ public Q_SLOTS:\n     void runawayException(const QString &message);\n \n private:\n-\n     /// Pass fatal exception message to UI thread\n     void handleRunawayException(const std::exception *e);\n+\n+    interfaces::Node& m_node;\n };\n \n /** Main Bitcoin application object */\n class BitcoinApplication: public QApplication\n {\n     Q_OBJECT\n public:\n-    explicit BitcoinApplication(int &argc, char **argv);\n+    explicit BitcoinApplication(interfaces::Node& node, int &argc, char **argv);\n     ~BitcoinApplication();\n \n #ifdef ENABLE_WALLET\n@@ -245,13 +243,14 @@ public Q_SLOTS:\n \n private:\n     QThread *coreThread;\n+    interfaces::Node& m_node;\n     OptionsModel *optionsModel;\n     ClientModel *clientModel;\n     BitcoinGUI *window;\n     QTimer *pollShutdownTimer;\n #ifdef ENABLE_WALLET\n     PaymentServer* paymentServer;\n-    WalletModel *walletModel;\n+    std::vector<WalletModel*> m_wallet_models;\n #endif\n     int returnValue;\n     const PlatformStyle *platformStyle;\n@@ -262,44 +261,23 @@ public Q_SLOTS:\n \n #include <qt/bitcoin.moc>\n \n-BitcoinCore::BitcoinCore():\n-    QObject()\n+BitcoinCore::BitcoinCore(interfaces::Node& node) :\n+    QObject(), m_node(node)\n {\n }\n \n void BitcoinCore::handleRunawayException(const std::exception *e)\n {\n     PrintExceptionContinue(e, \"Runaway exception\");\n-    Q_EMIT runawayException(QString::fromStdString(GetWarnings(\"gui\")));\n-}\n-\n-bool BitcoinCore::baseInitialize()\n-{\n-    if (!AppInitBasicSetup())\n-    {\n-        return false;\n-    }\n-    if (!AppInitParameterInteraction())\n-    {\n-        return false;\n-    }\n-    if (!AppInitSanityChecks())\n-    {\n-        return false;\n-    }\n-    if (!AppInitLockDataDirectory())\n-    {\n-        return false;\n-    }\n-    return true;\n+    Q_EMIT runawayException(QString::fromStdString(m_node.getWarnings(\"gui\")));\n }\n \n void BitcoinCore::initialize()\n {\n     try\n     {\n         qDebug() << __func__ << \": Running initialization in thread\";\n-        bool rv = AppInitMain();\n+        bool rv = m_node.appInitMain();\n         Q_EMIT initializeResult(rv);\n     } catch (const std::exception& e) {\n         handleRunawayException(&e);\n@@ -313,8 +291,7 @@ void BitcoinCore::shutdown()\n     try\n     {\n         qDebug() << __func__ << \": Running Shutdown in thread\";\n-        Interrupt();\n-        Shutdown();\n+        m_node.appShutdown();\n         qDebug() << __func__ << \": Shutdown finished\";\n         Q_EMIT shutdownResult();\n     } catch (const std::exception& e) {\n@@ -324,16 +301,17 @@ void BitcoinCore::shutdown()\n     }\n }\n \n-BitcoinApplication::BitcoinApplication(int &argc, char **argv):\n+BitcoinApplication::BitcoinApplication(interfaces::Node& node, int &argc, char **argv):\n     QApplication(argc, argv),\n     coreThread(0),\n+    m_node(node),\n     optionsModel(0),\n     clientModel(0),\n     window(0),\n     pollShutdownTimer(0),\n #ifdef ENABLE_WALLET\n     paymentServer(0),\n-    walletModel(0),\n+    m_wallet_models(),\n #endif\n     returnValue(0)\n {\n@@ -381,20 +359,20 @@ void BitcoinApplication::createPaymentServer()\n \n void BitcoinApplication::createOptionsModel(bool resetSettings)\n {\n-    optionsModel = new OptionsModel(nullptr, resetSettings);\n+    optionsModel = new OptionsModel(m_node, nullptr, resetSettings);\n }\n \n void BitcoinApplication::createWindow(const NetworkStyle *networkStyle)\n {\n-    window = new BitcoinGUI(platformStyle, networkStyle, 0);\n+    window = new BitcoinGUI(m_node, platformStyle, networkStyle, 0);\n \n     pollShutdownTimer = new QTimer(window);\n     connect(pollShutdownTimer, SIGNAL(timeout()), window, SLOT(detectShutdown()));\n }\n \n void BitcoinApplication::createSplashScreen(const NetworkStyle *networkStyle)\n {\n-    SplashScreen *splash = new SplashScreen(0, networkStyle);\n+    SplashScreen *splash = new SplashScreen(m_node, 0, networkStyle);\n     // We don't hold a direct pointer to the splash screen after creation, but the splash\n     // screen will take care of deleting itself when slotFinish happens.\n     splash->show();\n@@ -407,7 +385,7 @@ void BitcoinApplication::startThread()\n     if(coreThread)\n         return;\n     coreThread = new QThread(this);\n-    BitcoinCore *executor = new BitcoinCore();\n+    BitcoinCore *executor = new BitcoinCore(m_node);\n     executor->moveToThread(coreThread);\n \n     /*  communication to and from thread */\n@@ -425,8 +403,12 @@ void BitcoinApplication::startThread()\n \n void BitcoinApplication::parameterSetup()\n {\n-    InitLogging();\n-    InitParameterInteraction();\n+    // Default printtoconsole to false for the GUI. GUI programs should not\n+    // print to the console unnecessarily.\n+    gArgs.SoftSetBoolArg(\"-printtoconsole\", false);\n+\n+    m_node.initLogging();\n+    m_node.initParameterInteraction();\n }\n \n void BitcoinApplication::requestInitialize()\n@@ -451,13 +433,15 @@ void BitcoinApplication::requestShutdown()\n \n #ifdef ENABLE_WALLET\n     window->removeAllWallets();\n-    delete walletModel;\n-    walletModel = 0;\n+    for (WalletModel *walletModel : m_wallet_models) {\n+        delete walletModel;\n+    }\n+    m_wallet_models.clear();\n #endif\n     delete clientModel;\n     clientModel = 0;\n \n-    StartShutdown();\n+    m_node.startShutdown();\n \n     // Request shutdown from core thread\n     Q_EMIT requestedShutdown();\n@@ -477,20 +461,25 @@ void BitcoinApplication::initializeResult(bool success)\n         paymentServer->setOptionsModel(optionsModel);\n #endif\n \n-        clientModel = new ClientModel(optionsModel);\n+        clientModel = new ClientModel(m_node, optionsModel);\n         window->setClientModel(clientModel);\n \n #ifdef ENABLE_WALLET\n-        // TODO: Expose secondary wallets\n-        if (!vpwallets.empty())\n-        {\n-            walletModel = new WalletModel(platformStyle, vpwallets[0], optionsModel);\n+        bool fFirstWallet = true;\n+        auto wallets = m_node.getWallets();\n+        for (auto& wallet : wallets) {\n+            WalletModel * const walletModel = new WalletModel(std::move(wallet), m_node, platformStyle, optionsModel);\n+\n+            window->addWallet(walletModel);\n+            if (fFirstWallet) {\n+                window->setCurrentWallet(walletModel->getWalletName());\n+                fFirstWallet = false;\n+            }\n \n-            window->addWallet(BitcoinGUI::DEFAULT_WALLET, walletModel);\n-            window->setCurrentWallet(BitcoinGUI::DEFAULT_WALLET);\n+            connect(walletModel, SIGNAL(coinsSent(WalletModel*,SendCoinsRecipient,QByteArray)),\n+                             paymentServer, SLOT(fetchPaymentACK(WalletModel*,const SendCoinsRecipient&,QByteArray)));\n \n-            connect(walletModel, SIGNAL(coinsSent(CWallet*,SendCoinsRecipient,QByteArray)),\n-                             paymentServer, SLOT(fetchPaymentACK(CWallet*,const SendCoinsRecipient&,QByteArray)));\n+            m_wallet_models.push_back(walletModel);\n         }\n #endif\n \n@@ -542,14 +531,32 @@ WId BitcoinApplication::getMainWinId() const\n     return window->winId();\n }\n \n+static void SetupUIArgs()\n+{\n+#ifdef ENABLE_WALLET\n+    gArgs.AddArg(\"-allowselfsignedrootcertificates\", strprintf(\"Allow self signed root certificates (default: %u)\", DEFAULT_SELFSIGNED_ROOTCERTS), true, OptionsCategory::GUI);\n+#endif\n+    gArgs.AddArg(\"-choosedatadir\", strprintf(QObject::tr(\"Choose data directory on startup (default: %u)\").toStdString(), DEFAULT_CHOOSE_DATADIR), false, OptionsCategory::GUI);\n+    gArgs.AddArg(\"-lang=<lang>\", QObject::tr(\"Set language, for example \\\"de_DE\\\" (default: system locale)\").toStdString(), false, OptionsCategory::GUI);\n+    gArgs.AddArg(\"-min\", QObject::tr(\"Start minimized\").toStdString(), false, OptionsCategory::GUI);\n+    gArgs.AddArg(\"-resetguisettings\", QObject::tr(\"Reset all settings changed in the GUI\").toStdString(), false, OptionsCategory::GUI);\n+    gArgs.AddArg(\"-rootcertificates=<file>\", QObject::tr(\"Set SSL root certificates for payment request (default: -system-)\").toStdString(), false, OptionsCategory::GUI);\n+    gArgs.AddArg(\"-splash\", strprintf(QObject::tr(\"Show splash screen on startup (default: %u)\").toStdString(), DEFAULT_SPLASHSCREEN), false, OptionsCategory::GUI);\n+    gArgs.AddArg(\"-uiplatform\", strprintf(\"Select platform to customize UI for (one of windows, macosx, other; default: %s)\", BitcoinGUI::DEFAULT_UIPLATFORM), true, OptionsCategory::GUI);\n+}\n+\n #ifndef BITCOIN_QT_TEST\n int main(int argc, char *argv[])\n {\n     SetupEnvironment();\n \n+    std::unique_ptr<interfaces::Node> node = interfaces::MakeNode();\n+\n     /// 1. Parse command-line options. These take precedence over anything else.\n     // Command-line options take precedence:\n-    gArgs.ParseParameters(argc, argv);\n+    node->setupServerArgs();\n+    SetupUIArgs();\n+    node->parseParameters(argc, argv);\n \n     // Do not refer to data directory yet, this can be overridden by Intro::pickDataDirectory\n \n@@ -563,7 +570,7 @@ int main(int argc, char *argv[])\n     Q_INIT_RESOURCE(bitcoin);\n     Q_INIT_RESOURCE(bitcoin_locale);\n \n-    BitcoinApplication app(argc, argv);\n+    BitcoinApplication app(*node, argc, argv);\n #if QT_VERSION > 0x050100\n     // Generate high-dpi pixmaps\n     QApplication::setAttribute(Qt::AA_UseHighDpiPixmaps);\n@@ -605,19 +612,18 @@ int main(int argc, char *argv[])\n \n     // Show help message immediately after parsing command-line options (for \"-lang\") and setting locale,\n     // but before showing splash screen.\n-    if (gArgs.IsArgSet(\"-?\") || gArgs.IsArgSet(\"-h\") || gArgs.IsArgSet(\"-help\") || gArgs.IsArgSet(\"-version\"))\n-    {\n-        HelpMessageDialog help(nullptr, gArgs.IsArgSet(\"-version\"));\n+    if (HelpRequested(gArgs) || gArgs.IsArgSet(\"-version\")) {\n+        HelpMessageDialog help(*node, nullptr, gArgs.IsArgSet(\"-version\"));\n         help.showOrPrint();\n         return EXIT_SUCCESS;\n     }\n \n     /// 5. Now that settings and translations are available, ask user for data directory\n     // User language is set up: pick a data directory\n-    if (!Intro::pickDataDirectory())\n+    if (!Intro::pickDataDirectory(*node))\n         return EXIT_SUCCESS;\n \n-    /// 6. Determine availability of data directory and parse bitcoin.conf\n+    /// 6. Determine availability of data and blocks directory and parse bitcoin.conf\n     /// - Do not call GetDataDir(true) before this step finishes\n     if (!fs::is_directory(GetDataDir(false)))\n     {\n@@ -626,7 +632,7 @@ int main(int argc, char *argv[])\n         return EXIT_FAILURE;\n     }\n     try {\n-        gArgs.ReadConfigFile(gArgs.GetArg(\"-conf\", BITCOIN_CONF_FILENAME));\n+        node->readConfigFiles();\n     } catch (const std::exception& e) {\n         QMessageBox::critical(0, QObject::tr(PACKAGE_NAME),\n                               QObject::tr(\"Error: Cannot parse configuration file: %1. Only use key=value syntax.\").arg(e.what()));\n@@ -641,14 +647,14 @@ int main(int argc, char *argv[])\n \n     // Check for -testnet or -regtest parameter (Params() calls are only valid after this clause)\n     try {\n-        SelectParams(ChainNameFromCommandLine());\n+        node->selectParams(gArgs.GetChainName());\n     } catch(std::exception &e) {\n         QMessageBox::critical(0, QObject::tr(PACKAGE_NAME), QObject::tr(\"Error: %1\").arg(e.what()));\n         return EXIT_FAILURE;\n     }\n #ifdef ENABLE_WALLET\n     // Parse URIs on command line -- this can affect Params()\n-    PaymentServer::ipcParseCommandLine(argc, argv);\n+    PaymentServer::ipcParseCommandLine(*node, argc, argv);\n #endif\n \n     QScopedPointer<const NetworkStyle> networkStyle(NetworkStyle::instantiate(QString::fromStdString(Params().NetworkIDString())));\n@@ -690,10 +696,10 @@ int main(int argc, char *argv[])\n     // Allow parameter interaction before we create the options model\n     app.parameterSetup();\n     // Load GUI settings from QSettings\n-    app.createOptionsModel(gArgs.IsArgSet(\"-resetguisettings\"));\n+    app.createOptionsModel(gArgs.GetBoolArg(\"-resetguisettings\", false));\n \n     // Subscribe to global signals from core\n-    uiInterface.InitMessage.connect(InitMessage);\n+    std::unique_ptr<interfaces::Handler> handler = node->handleInitMessage(InitMessage);\n \n     if (gArgs.GetBoolArg(\"-splash\", DEFAULT_SPLASHSCREEN) && !gArgs.GetBoolArg(\"-min\", false))\n         app.createSplashScreen(networkStyle.data());\n@@ -705,7 +711,7 @@ int main(int argc, char *argv[])\n         // Perform base initialization before spinning up initialization/shutdown thread\n         // This is acceptable because this function only contains steps that are quick to execute,\n         // so the GUI thread won't be held up.\n-        if (BitcoinCore::baseInitialize()) {\n+        if (node->baseInitialize()) {\n             app.requestInitialize();\n #if defined(Q_OS_WIN) && QT_VERSION >= 0x050000\n             WinShutdownMonitor::registerShutdownBlockReason(QObject::tr(\"%1 didn't yet exit safely...\").arg(QObject::tr(PACKAGE_NAME)), (HWND)app.getMainWinId());\n@@ -720,10 +726,10 @@ int main(int argc, char *argv[])\n         }\n     } catch (const std::exception& e) {\n         PrintExceptionContinue(&e, \"Runaway exception\");\n-        app.handleRunawayException(QString::fromStdString(GetWarnings(\"gui\")));\n+        app.handleRunawayException(QString::fromStdString(node->getWarnings(\"gui\")));\n     } catch (...) {\n         PrintExceptionContinue(nullptr, \"Runaway exception\");\n-        app.handleRunawayException(QString::fromStdString(GetWarnings(\"gui\")));\n+        app.handleRunawayException(QString::fromStdString(node->getWarnings(\"gui\")));\n     }\n     return rv;\n }"
      },
      {
        "sha": "aed5374a7d5b4983114159b5c8d66ecfa1612da1",
        "filename": "src/qt/bitcoingui.cpp",
        "status": "modified",
        "additions": 69,
        "deletions": 27,
        "changes": 96,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/bitcoingui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/bitcoingui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -21,6 +21,7 @@\n #ifdef ENABLE_WALLET\n #include <qt/walletframe.h>\n #include <qt/walletmodel.h>\n+#include <qt/walletview.h>\n #endif // ENABLE_WALLET\n \n #ifdef Q_OS_MAC\n@@ -29,13 +30,16 @@\n \n #include <chainparams.h>\n #include <init.h>\n+#include <interfaces/handler.h>\n+#include <interfaces/node.h>\n #include <ui_interface.h>\n #include <util.h>\n \n #include <iostream>\n \n #include <QAction>\n #include <QApplication>\n+#include <QComboBox>\n #include <QDateTime>\n #include <QDesktopWidget>\n #include <QDragEnterEvent>\n@@ -70,13 +74,10 @@ const std::string BitcoinGUI::DEFAULT_UIPLATFORM =\n #endif\n         ;\n \n-/** Display name for default wallet name. Uses tilde to avoid name\n- * collisions in the future with additional wallets */\n-const QString BitcoinGUI::DEFAULT_WALLET = \"~Default\";\n-\n-BitcoinGUI::BitcoinGUI(const PlatformStyle *_platformStyle, const NetworkStyle *networkStyle, QWidget *parent) :\n+BitcoinGUI::BitcoinGUI(interfaces::Node& node, const PlatformStyle *_platformStyle, const NetworkStyle *networkStyle, QWidget *parent) :\n     QMainWindow(parent),\n     enableWallet(false),\n+    m_node(node),\n     clientModel(0),\n     walletFrame(0),\n     unitDisplayControl(0),\n@@ -88,6 +89,7 @@ BitcoinGUI::BitcoinGUI(const PlatformStyle *_platformStyle, const NetworkStyle *\n     progressBar(0),\n     progressDialog(0),\n     appMenuBar(0),\n+    appToolBar(0),\n     overviewAction(0),\n     historyAction(0),\n     quitAction(0),\n@@ -150,8 +152,8 @@ BitcoinGUI::BitcoinGUI(const PlatformStyle *_platformStyle, const NetworkStyle *\n     setUnifiedTitleAndToolBarOnMac(true);\n #endif\n \n-    rpcConsole = new RPCConsole(_platformStyle, 0);\n-    helpMessageDialog = new HelpMessageDialog(this, false);\n+    rpcConsole = new RPCConsole(node, _platformStyle, 0);\n+    helpMessageDialog = new HelpMessageDialog(node, this, false);\n #ifdef ENABLE_WALLET\n     if(enableWallet)\n     {\n@@ -455,6 +457,7 @@ void BitcoinGUI::createToolBars()\n     if(walletFrame)\n     {\n         QToolBar *toolbar = addToolBar(tr(\"Tabs toolbar\"));\n+        appToolBar = toolbar;\n         toolbar->setContextMenuPolicy(Qt::PreventContextMenu);\n         toolbar->setMovable(false);\n         toolbar->setToolButtonStyle(Qt::ToolButtonTextBesideIcon);\n@@ -463,6 +466,15 @@ void BitcoinGUI::createToolBars()\n         toolbar->addAction(receiveCoinsAction);\n         toolbar->addAction(historyAction);\n         overviewAction->setChecked(true);\n+\n+#ifdef ENABLE_WALLET\n+        QWidget *spacer = new QWidget();\n+        spacer->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);\n+        toolbar->addWidget(spacer);\n+\n+        m_wallet_selector = new QComboBox();\n+        connect(m_wallet_selector, SIGNAL(currentIndexChanged(const QString&)), this, SLOT(setCurrentWallet(const QString&)));\n+#endif\n     }\n }\n \n@@ -481,7 +493,7 @@ void BitcoinGUI::setClientModel(ClientModel *_clientModel)\n         connect(_clientModel, SIGNAL(networkActiveChanged(bool)), this, SLOT(setNetworkActive(bool)));\n \n         modalOverlay->setKnownBestHeight(_clientModel->getHeaderTipHeight(), QDateTime::fromTime_t(_clientModel->getHeaderTipTime()));\n-        setNumBlocks(_clientModel->getNumBlocks(), _clientModel->getLastBlockDate(), _clientModel->getVerificationProgress(nullptr), false);\n+        setNumBlocks(m_node.getNumBlocks(), QDateTime::fromTime_t(m_node.getLastBlockTime()), m_node.getVerificationProgress(), false);\n         connect(_clientModel, SIGNAL(numBlocksChanged(int,QDateTime,double,bool)), this, SLOT(setNumBlocks(int,QDateTime,double,bool)));\n \n         // Receive and report messages from client model\n@@ -529,12 +541,22 @@ void BitcoinGUI::setClientModel(ClientModel *_clientModel)\n }\n \n #ifdef ENABLE_WALLET\n-bool BitcoinGUI::addWallet(const QString& name, WalletModel *walletModel)\n+bool BitcoinGUI::addWallet(WalletModel *walletModel)\n {\n     if(!walletFrame)\n         return false;\n+    const QString name = walletModel->getWalletName();\n     setWalletActionsEnabled(true);\n-    return walletFrame->addWallet(name, walletModel);\n+    m_wallet_selector->addItem(name);\n+    if (m_wallet_selector->count() == 2) {\n+        m_wallet_selector_label = new QLabel();\n+        m_wallet_selector_label->setText(tr(\"Wallet:\") + \" \");\n+        m_wallet_selector_label->setBuddy(m_wallet_selector);\n+        appToolBar->addWidget(m_wallet_selector_label);\n+        appToolBar->addWidget(m_wallet_selector);\n+    }\n+    rpcConsole->addWallet(walletModel);\n+    return walletFrame->addWallet(walletModel);\n }\n \n bool BitcoinGUI::setCurrentWallet(const QString& name)\n@@ -646,7 +668,7 @@ void BitcoinGUI::aboutClicked()\n     if(!clientModel)\n         return;\n \n-    HelpMessageDialog dlg(this, true);\n+    HelpMessageDialog dlg(m_node, this, true);\n     dlg.exec();\n }\n \n@@ -729,7 +751,7 @@ void BitcoinGUI::updateNetworkState()\n \n     QString tooltip;\n \n-    if (clientModel->getNetworkActive()) {\n+    if (m_node.getNetworkActive()) {\n         tooltip = tr(\"%n active connection(s) to Bitcoin network\", \"\", count) + QString(\".<br>\") + tr(\"Click to disable network activity.\");\n     } else {\n         tooltip = tr(\"Network activity disabled.\") + QString(\"<br>\") + tr(\"Click to enable network activity again.\");\n@@ -780,25 +802,25 @@ void BitcoinGUI::setNumBlocks(int count, const QDateTime& blockDate, double nVer\n     // Acquire current block source\n     enum BlockSource blockSource = clientModel->getBlockSource();\n     switch (blockSource) {\n-        case BLOCK_SOURCE_NETWORK:\n+        case BlockSource::NETWORK:\n             if (header) {\n                 updateHeadersSyncProgressLabel();\n                 return;\n             }\n             progressBarLabel->setText(tr(\"Synchronizing with network...\"));\n             updateHeadersSyncProgressLabel();\n             break;\n-        case BLOCK_SOURCE_DISK:\n+        case BlockSource::DISK:\n             if (header) {\n                 progressBarLabel->setText(tr(\"Indexing blocks on disk...\"));\n             } else {\n                 progressBarLabel->setText(tr(\"Processing blocks on disk...\"));\n             }\n             break;\n-        case BLOCK_SOURCE_REINDEX:\n+        case BlockSource::REINDEX:\n             progressBarLabel->setText(tr(\"Reindexing blocks on disk...\"));\n             break;\n-        case BLOCK_SOURCE_NONE:\n+        case BlockSource::NONE:\n             if (header) {\n                 return;\n             }\n@@ -946,6 +968,11 @@ void BitcoinGUI::changeEvent(QEvent *e)\n                 QTimer::singleShot(0, this, SLOT(hide()));\n                 e->ignore();\n             }\n+            else if((wsevt->oldState() & Qt::WindowMinimized) && !isMinimized())\n+            {\n+                QTimer::singleShot(0, this, SLOT(show()));\n+                e->ignore();\n+            }\n         }\n     }\n #endif\n@@ -983,12 +1010,15 @@ void BitcoinGUI::showEvent(QShowEvent *event)\n }\n \n #ifdef ENABLE_WALLET\n-void BitcoinGUI::incomingTransaction(const QString& date, int unit, const CAmount& amount, const QString& type, const QString& address, const QString& label)\n+void BitcoinGUI::incomingTransaction(const QString& date, int unit, const CAmount& amount, const QString& type, const QString& address, const QString& label, const QString& walletName)\n {\n     // On new transaction, make an info balloon\n     QString msg = tr(\"Date: %1\\n\").arg(date) +\n-                  tr(\"Amount: %1\\n\").arg(BitcoinUnits::formatWithUnit(unit, amount, true)) +\n-                  tr(\"Type: %1\\n\").arg(type);\n+                  tr(\"Amount: %1\\n\").arg(BitcoinUnits::formatWithUnit(unit, amount, true));\n+    if (m_node.getWallets().size() > 1 && !walletName.isEmpty()) {\n+        msg += tr(\"Wallet: %1\\n\").arg(walletName);\n+    }\n+    msg += tr(\"Type: %1\\n\").arg(type);\n     if (!label.isEmpty())\n         msg += tr(\"Label: %1\\n\").arg(label);\n     else if (!address.isEmpty())\n@@ -1079,6 +1109,20 @@ void BitcoinGUI::setEncryptionStatus(int status)\n         break;\n     }\n }\n+\n+void BitcoinGUI::updateWalletStatus()\n+{\n+    if (!walletFrame) {\n+        return;\n+    }\n+    WalletView * const walletView = walletFrame->currentWalletView();\n+    if (!walletView) {\n+        return;\n+    }\n+    WalletModel * const walletModel = walletView->getWalletModel();\n+    setEncryptionStatus(walletModel->getEncryptionStatus());\n+    setHDStatus(walletModel->wallet().hdEnabled());\n+}\n #endif // ENABLE_WALLET\n \n void BitcoinGUI::showNormalIfMinimized(bool fToggleHidden)\n@@ -1113,7 +1157,7 @@ void BitcoinGUI::toggleHidden()\n \n void BitcoinGUI::detectShutdown()\n {\n-    if (ShutdownRequested())\n+    if (m_node.shutdownRequested())\n     {\n         if(rpcConsole)\n             rpcConsole->hide();\n@@ -1178,22 +1222,20 @@ static bool ThreadSafeMessageBox(BitcoinGUI *gui, const std::string& message, co\n void BitcoinGUI::subscribeToCoreSignals()\n {\n     // Connect signals to client\n-    uiInterface.ThreadSafeMessageBox.connect(boost::bind(ThreadSafeMessageBox, this, _1, _2, _3));\n-    uiInterface.ThreadSafeQuestion.connect(boost::bind(ThreadSafeMessageBox, this, _1, _3, _4));\n+    m_handler_message_box = m_node.handleMessageBox(boost::bind(ThreadSafeMessageBox, this, _1, _2, _3));\n+    m_handler_question = m_node.handleQuestion(boost::bind(ThreadSafeMessageBox, this, _1, _3, _4));\n }\n \n void BitcoinGUI::unsubscribeFromCoreSignals()\n {\n     // Disconnect signals from client\n-    uiInterface.ThreadSafeMessageBox.disconnect(boost::bind(ThreadSafeMessageBox, this, _1, _2, _3));\n-    uiInterface.ThreadSafeQuestion.disconnect(boost::bind(ThreadSafeMessageBox, this, _1, _3, _4));\n+    m_handler_message_box->disconnect();\n+    m_handler_question->disconnect();\n }\n \n void BitcoinGUI::toggleNetworkActive()\n {\n-    if (clientModel) {\n-        clientModel->setNetworkActive(!clientModel->getNetworkActive());\n-    }\n+    m_node.setNetworkActive(!m_node.getNetworkActive());\n }\n \n UnitDisplayStatusBarControl::UnitDisplayStatusBarControl(const PlatformStyle *platformStyle) :"
      },
      {
        "sha": "e59c71cd4f41481c17f653945b5e2243e18004d2",
        "filename": "src/qt/bitcoingui.h",
        "status": "modified",
        "additions": 25,
        "deletions": 5,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/bitcoingui.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/bitcoingui.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -18,6 +18,8 @@\n #include <QPoint>\n #include <QSystemTrayIcon>\n \n+#include <memory>\n+\n class ClientModel;\n class NetworkStyle;\n class Notificator;\n@@ -31,8 +33,14 @@ class WalletModel;\n class HelpMessageDialog;\n class ModalOverlay;\n \n+namespace interfaces {\n+class Handler;\n+class Node;\n+}\n+\n QT_BEGIN_NAMESPACE\n class QAction;\n+class QComboBox;\n class QProgressBar;\n class QProgressDialog;\n QT_END_NAMESPACE\n@@ -46,10 +54,9 @@ class BitcoinGUI : public QMainWindow\n     Q_OBJECT\n \n public:\n-    static const QString DEFAULT_WALLET;\n     static const std::string DEFAULT_UIPLATFORM;\n \n-    explicit BitcoinGUI(const PlatformStyle *platformStyle, const NetworkStyle *networkStyle, QWidget *parent = 0);\n+    explicit BitcoinGUI(interfaces::Node& node, const PlatformStyle *platformStyle, const NetworkStyle *networkStyle, QWidget *parent = 0);\n     ~BitcoinGUI();\n \n     /** Set the client model.\n@@ -62,8 +69,7 @@ class BitcoinGUI : public QMainWindow\n         The wallet model represents a bitcoin wallet, and offers access to the list of transactions, address book and sending\n         functionality.\n     */\n-    bool addWallet(const QString& name, WalletModel *walletModel);\n-    bool setCurrentWallet(const QString& name);\n+    bool addWallet(WalletModel *walletModel);\n     void removeAllWallets();\n #endif // ENABLE_WALLET\n     bool enableWallet;\n@@ -77,6 +83,9 @@ class BitcoinGUI : public QMainWindow\n     bool eventFilter(QObject *object, QEvent *event);\n \n private:\n+    interfaces::Node& m_node;\n+    std::unique_ptr<interfaces::Handler> m_handler_message_box;\n+    std::unique_ptr<interfaces::Handler> m_handler_question;\n     ClientModel *clientModel;\n     WalletFrame *walletFrame;\n \n@@ -90,6 +99,7 @@ class BitcoinGUI : public QMainWindow\n     QProgressDialog *progressDialog;\n \n     QMenuBar *appMenuBar;\n+    QToolBar *appToolBar;\n     QAction *overviewAction;\n     QAction *historyAction;\n     QAction *quitAction;\n@@ -112,6 +122,9 @@ class BitcoinGUI : public QMainWindow\n     QAction *openAction;\n     QAction *showHelpMessageAction;\n \n+    QLabel *m_wallet_selector_label;\n+    QComboBox *m_wallet_selector;\n+\n     QSystemTrayIcon *trayIcon;\n     QMenu *trayIconMenu;\n     Notificator *notificator;\n@@ -171,6 +184,12 @@ public Q_SLOTS:\n     void message(const QString &title, const QString &message, unsigned int style, bool *ret = nullptr);\n \n #ifdef ENABLE_WALLET\n+    bool setCurrentWallet(const QString& name);\n+    /** Set the UI status indicators based on the currently selected wallet.\n+    */\n+    void updateWalletStatus();\n+\n+private:\n     /** Set the encryption status as shown in the UI.\n        @param[in] status            current encryption status\n        @see WalletModel::EncryptionStatus\n@@ -183,10 +202,11 @@ public Q_SLOTS:\n      */\n     void setHDStatus(int hdEnabled);\n \n+public Q_SLOTS:\n     bool handlePaymentRequest(const SendCoinsRecipient& recipient);\n \n     /** Show incoming transaction notification for new transactions. */\n-    void incomingTransaction(const QString& date, int unit, const CAmount& amount, const QString& type, const QString& address, const QString& label);\n+    void incomingTransaction(const QString& date, int unit, const CAmount& amount, const QString& type, const QString& address, const QString& label, const QString& walletName);\n #endif // ENABLE_WALLET\n \n private Q_SLOTS:"
      },
      {
        "sha": "37fd06ccc91f5bc948f7d8bd9baf8646e2b36eb2",
        "filename": "src/qt/clientmodel.cpp",
        "status": "modified",
        "additions": 46,
        "deletions": 114,
        "changes": 160,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/clientmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/clientmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -13,6 +13,8 @@\n #include <chainparams.h>\n #include <checkpoints.h>\n #include <clientversion.h>\n+#include <interfaces/handler.h>\n+#include <interfaces/node.h>\n #include <validation.h>\n #include <net.h>\n #include <txmempool.h>\n@@ -30,17 +32,18 @@ class CBlockIndex;\n static int64_t nLastHeaderTipUpdateNotification = 0;\n static int64_t nLastBlockTipUpdateNotification = 0;\n \n-ClientModel::ClientModel(OptionsModel *_optionsModel, QObject *parent) :\n+ClientModel::ClientModel(interfaces::Node& node, OptionsModel *_optionsModel, QObject *parent) :\n     QObject(parent),\n+    m_node(node),\n     optionsModel(_optionsModel),\n     peerTableModel(0),\n     banTableModel(0),\n     pollTimer(0)\n {\n     cachedBestHeaderHeight = -1;\n     cachedBestHeaderTime = -1;\n-    peerTableModel = new PeerTableModel(this);\n-    banTableModel = new BanTableModel(this);\n+    peerTableModel = new PeerTableModel(m_node, this);\n+    banTableModel = new BanTableModel(m_node, this);\n     pollTimer = new QTimer(this);\n     connect(pollTimer, SIGNAL(timeout()), this, SLOT(updateTimer()));\n     pollTimer->start(MODEL_UPDATE_DELAY);\n@@ -64,26 +67,19 @@ int ClientModel::getNumConnections(unsigned int flags) const\n     else if (flags == CONNECTIONS_ALL)\n         connections = CConnman::CONNECTIONS_ALL;\n \n-    if(g_connman)\n-         return g_connman->GetNodeCount(connections);\n-    return 0;\n-}\n-\n-int ClientModel::getNumBlocks() const\n-{\n-    LOCK(cs_main);\n-    return chainActive.Height();\n+    return m_node.getNodeCount(connections);\n }\n \n int ClientModel::getHeaderTipHeight() const\n {\n     if (cachedBestHeaderHeight == -1) {\n         // make sure we initially populate the cache via a cs_main lock\n         // otherwise we need to wait for a tip update\n-        LOCK(cs_main);\n-        if (pindexBestHeader) {\n-            cachedBestHeaderHeight = pindexBestHeader->nHeight;\n-            cachedBestHeaderTime = pindexBestHeader->GetBlockTime();\n+        int height;\n+        int64_t blockTime;\n+        if (m_node.getHeaderTip(height, blockTime)) {\n+            cachedBestHeaderHeight = height;\n+            cachedBestHeaderTime = blockTime;\n         }\n     }\n     return cachedBestHeaderHeight;\n@@ -92,66 +88,22 @@ int ClientModel::getHeaderTipHeight() const\n int64_t ClientModel::getHeaderTipTime() const\n {\n     if (cachedBestHeaderTime == -1) {\n-        LOCK(cs_main);\n-        if (pindexBestHeader) {\n-            cachedBestHeaderHeight = pindexBestHeader->nHeight;\n-            cachedBestHeaderTime = pindexBestHeader->GetBlockTime();\n+        int height;\n+        int64_t blockTime;\n+        if (m_node.getHeaderTip(height, blockTime)) {\n+            cachedBestHeaderHeight = height;\n+            cachedBestHeaderTime = blockTime;\n         }\n     }\n     return cachedBestHeaderTime;\n }\n \n-quint64 ClientModel::getTotalBytesRecv() const\n-{\n-    if(!g_connman)\n-        return 0;\n-    return g_connman->GetTotalBytesRecv();\n-}\n-\n-quint64 ClientModel::getTotalBytesSent() const\n-{\n-    if(!g_connman)\n-        return 0;\n-    return g_connman->GetTotalBytesSent();\n-}\n-\n-QDateTime ClientModel::getLastBlockDate() const\n-{\n-    LOCK(cs_main);\n-\n-    if (chainActive.Tip())\n-        return QDateTime::fromTime_t(chainActive.Tip()->GetBlockTime());\n-\n-    return QDateTime::fromTime_t(Params().GenesisBlock().GetBlockTime()); // Genesis block's time of current network\n-}\n-\n-long ClientModel::getMempoolSize() const\n-{\n-    return mempool.size();\n-}\n-\n-size_t ClientModel::getMempoolDynamicUsage() const\n-{\n-    return mempool.DynamicMemoryUsage();\n-}\n-\n-double ClientModel::getVerificationProgress(const CBlockIndex *tipIn) const\n-{\n-    CBlockIndex *tip = const_cast<CBlockIndex *>(tipIn);\n-    LOCK(cs_main);\n-    if (!tip)\n-    {\n-        tip = chainActive.Tip();\n-    }\n-    return GuessVerificationProgress(Params().TxData(), tip);\n-}\n-\n void ClientModel::updateTimer()\n {\n     // no locking required at this point\n     // the following calls will acquire the required lock\n-    Q_EMIT mempoolSizeChanged(getMempoolSize(), getMempoolDynamicUsage());\n-    Q_EMIT bytesChanged(getTotalBytesRecv(), getTotalBytesSent());\n+    Q_EMIT mempoolSizeChanged(m_node.getMempoolSize(), m_node.getMempoolDynamicUsage());\n+    Q_EMIT bytesChanged(m_node.getTotalBytesRecv(), m_node.getTotalBytesSent());\n }\n \n void ClientModel::updateNumConnections(int numConnections)\n@@ -169,41 +121,21 @@ void ClientModel::updateAlert()\n     Q_EMIT alertsChanged(getStatusBarWarnings());\n }\n \n-bool ClientModel::inInitialBlockDownload() const\n-{\n-    return IsInitialBlockDownload();\n-}\n-\n enum BlockSource ClientModel::getBlockSource() const\n {\n-    if (fReindex)\n-        return BLOCK_SOURCE_REINDEX;\n-    else if (fImporting)\n-        return BLOCK_SOURCE_DISK;\n+    if (m_node.getReindex())\n+        return BlockSource::REINDEX;\n+    else if (m_node.getImporting())\n+        return BlockSource::DISK;\n     else if (getNumConnections() > 0)\n-        return BLOCK_SOURCE_NETWORK;\n+        return BlockSource::NETWORK;\n \n-    return BLOCK_SOURCE_NONE;\n-}\n-\n-void ClientModel::setNetworkActive(bool active)\n-{\n-    if (g_connman) {\n-         g_connman->SetNetworkActive(active);\n-    }\n-}\n-\n-bool ClientModel::getNetworkActive() const\n-{\n-    if (g_connman) {\n-        return g_connman->GetNetworkActive();\n-    }\n-    return false;\n+    return BlockSource::NONE;\n }\n \n QString ClientModel::getStatusBarWarnings() const\n {\n-    return QString::fromStdString(GetWarnings(\"gui\"));\n+    return QString::fromStdString(m_node.getWarnings(\"gui\"));\n }\n \n OptionsModel *ClientModel::getOptionsModel()\n@@ -285,7 +217,7 @@ static void BannedListChanged(ClientModel *clientmodel)\n     QMetaObject::invokeMethod(clientmodel, \"updateBanlist\", Qt::QueuedConnection);\n }\n \n-static void BlockTipChanged(ClientModel *clientmodel, bool initialSync, const CBlockIndex *pIndex, bool fHeader)\n+static void BlockTipChanged(ClientModel *clientmodel, bool initialSync, int height, int64_t blockTime, double verificationProgress, bool fHeader)\n {\n     // lock free async UI updates in case we have a new block tip\n     // during initial sync, only update the UI if the last update\n@@ -298,16 +230,16 @@ static void BlockTipChanged(ClientModel *clientmodel, bool initialSync, const CB\n \n     if (fHeader) {\n         // cache best headers time and height to reduce future cs_main locks\n-        clientmodel->cachedBestHeaderHeight = pIndex->nHeight;\n-        clientmodel->cachedBestHeaderTime = pIndex->GetBlockTime();\n+        clientmodel->cachedBestHeaderHeight = height;\n+        clientmodel->cachedBestHeaderTime = blockTime;\n     }\n     // if we are in-sync, update the UI regardless of last update time\n     if (!initialSync || now - nLastUpdateNotification > MODEL_UPDATE_DELAY) {\n         //pass an async signal to the UI thread\n         QMetaObject::invokeMethod(clientmodel, \"numBlocksChanged\", Qt::QueuedConnection,\n-                                  Q_ARG(int, pIndex->nHeight),\n-                                  Q_ARG(QDateTime, QDateTime::fromTime_t(pIndex->GetBlockTime())),\n-                                  Q_ARG(double, clientmodel->getVerificationProgress(pIndex)),\n+                                  Q_ARG(int, height),\n+                                  Q_ARG(QDateTime, QDateTime::fromTime_t(blockTime)),\n+                                  Q_ARG(double, verificationProgress),\n                                   Q_ARG(bool, fHeader));\n         nLastUpdateNotification = now;\n     }\n@@ -316,23 +248,23 @@ static void BlockTipChanged(ClientModel *clientmodel, bool initialSync, const CB\n void ClientModel::subscribeToCoreSignals()\n {\n     // Connect signals to client\n-    uiInterface.ShowProgress.connect(boost::bind(ShowProgress, this, _1, _2));\n-    uiInterface.NotifyNumConnectionsChanged.connect(boost::bind(NotifyNumConnectionsChanged, this, _1));\n-    uiInterface.NotifyNetworkActiveChanged.connect(boost::bind(NotifyNetworkActiveChanged, this, _1));\n-    uiInterface.NotifyAlertChanged.connect(boost::bind(NotifyAlertChanged, this));\n-    uiInterface.BannedListChanged.connect(boost::bind(BannedListChanged, this));\n-    uiInterface.NotifyBlockTip.connect(boost::bind(BlockTipChanged, this, _1, _2, false));\n-    uiInterface.NotifyHeaderTip.connect(boost::bind(BlockTipChanged, this, _1, _2, true));\n+    m_handler_show_progress = m_node.handleShowProgress(boost::bind(ShowProgress, this, _1, _2));\n+    m_handler_notify_num_connections_changed = m_node.handleNotifyNumConnectionsChanged(boost::bind(NotifyNumConnectionsChanged, this, _1));\n+    m_handler_notify_network_active_changed = m_node.handleNotifyNetworkActiveChanged(boost::bind(NotifyNetworkActiveChanged, this, _1));\n+    m_handler_notify_alert_changed = m_node.handleNotifyAlertChanged(boost::bind(NotifyAlertChanged, this));\n+    m_handler_banned_list_changed = m_node.handleBannedListChanged(boost::bind(BannedListChanged, this));\n+    m_handler_notify_block_tip = m_node.handleNotifyBlockTip(boost::bind(BlockTipChanged, this, _1, _2, _3, _4, false));\n+    m_handler_notify_header_tip = m_node.handleNotifyHeaderTip(boost::bind(BlockTipChanged, this, _1, _2, _3, _4, true));\n }\n \n void ClientModel::unsubscribeFromCoreSignals()\n {\n     // Disconnect signals from client\n-    uiInterface.ShowProgress.disconnect(boost::bind(ShowProgress, this, _1, _2));\n-    uiInterface.NotifyNumConnectionsChanged.disconnect(boost::bind(NotifyNumConnectionsChanged, this, _1));\n-    uiInterface.NotifyNetworkActiveChanged.disconnect(boost::bind(NotifyNetworkActiveChanged, this, _1));\n-    uiInterface.NotifyAlertChanged.disconnect(boost::bind(NotifyAlertChanged, this));\n-    uiInterface.BannedListChanged.disconnect(boost::bind(BannedListChanged, this));\n-    uiInterface.NotifyBlockTip.disconnect(boost::bind(BlockTipChanged, this, _1, _2, false));\n-    uiInterface.NotifyHeaderTip.disconnect(boost::bind(BlockTipChanged, this, _1, _2, true));\n+    m_handler_show_progress->disconnect();\n+    m_handler_notify_num_connections_changed->disconnect();\n+    m_handler_notify_network_active_changed->disconnect();\n+    m_handler_notify_alert_changed->disconnect();\n+    m_handler_banned_list_changed->disconnect();\n+    m_handler_notify_block_tip->disconnect();\n+    m_handler_notify_header_tip->disconnect();\n }"
      },
      {
        "sha": "a609222f7db46b1ba8ea35d071992c29378078ee",
        "filename": "src/qt/clientmodel.h",
        "status": "modified",
        "additions": 22,
        "deletions": 24,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/clientmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/clientmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -9,22 +9,28 @@\n #include <QDateTime>\n \n #include <atomic>\n+#include <memory>\n \n class BanTableModel;\n class OptionsModel;\n class PeerTableModel;\n \n class CBlockIndex;\n \n+namespace interfaces {\n+class Handler;\n+class Node;\n+}\n+\n QT_BEGIN_NAMESPACE\n class QTimer;\n QT_END_NAMESPACE\n \n-enum BlockSource {\n-    BLOCK_SOURCE_NONE,\n-    BLOCK_SOURCE_REINDEX,\n-    BLOCK_SOURCE_DISK,\n-    BLOCK_SOURCE_NETWORK\n+enum class BlockSource {\n+    NONE,\n+    REINDEX,\n+    DISK,\n+    NETWORK\n };\n \n enum NumConnections {\n@@ -40,37 +46,21 @@ class ClientModel : public QObject\n     Q_OBJECT\n \n public:\n-    explicit ClientModel(OptionsModel *optionsModel, QObject *parent = 0);\n+    explicit ClientModel(interfaces::Node& node, OptionsModel *optionsModel, QObject *parent = 0);\n     ~ClientModel();\n \n+    interfaces::Node& node() const { return m_node; }\n     OptionsModel *getOptionsModel();\n     PeerTableModel *getPeerTableModel();\n     BanTableModel *getBanTableModel();\n \n     //! Return number of connections, default is in- and outbound (total)\n     int getNumConnections(unsigned int flags = CONNECTIONS_ALL) const;\n-    int getNumBlocks() const;\n     int getHeaderTipHeight() const;\n     int64_t getHeaderTipTime() const;\n-    //! Return number of transactions in the mempool\n-    long getMempoolSize() const;\n-    //! Return the dynamic memory usage of the mempool\n-    size_t getMempoolDynamicUsage() const;\n-    \n-    quint64 getTotalBytesRecv() const;\n-    quint64 getTotalBytesSent() const;\n-\n-    double getVerificationProgress(const CBlockIndex *tip) const;\n-    QDateTime getLastBlockDate() const;\n-\n-    //! Return true if core is doing initial block download\n-    bool inInitialBlockDownload() const;\n+\n     //! Returns enum BlockSource of the current importing/syncing state\n     enum BlockSource getBlockSource() const;\n-    //! Return true if network activity in core is enabled\n-    bool getNetworkActive() const;\n-    //! Toggle network activity state in core\n-    void setNetworkActive(bool active);\n     //! Return warnings to be displayed in status bar\n     QString getStatusBarWarnings() const;\n \n@@ -85,6 +75,14 @@ class ClientModel : public QObject\n     mutable std::atomic<int64_t> cachedBestHeaderTime;\n \n private:\n+    interfaces::Node& m_node;\n+    std::unique_ptr<interfaces::Handler> m_handler_show_progress;\n+    std::unique_ptr<interfaces::Handler> m_handler_notify_num_connections_changed;\n+    std::unique_ptr<interfaces::Handler> m_handler_notify_network_active_changed;\n+    std::unique_ptr<interfaces::Handler> m_handler_notify_alert_changed;\n+    std::unique_ptr<interfaces::Handler> m_handler_banned_list_changed;\n+    std::unique_ptr<interfaces::Handler> m_handler_notify_block_tip;\n+    std::unique_ptr<interfaces::Handler> m_handler_notify_header_tip;\n     OptionsModel *optionsModel;\n     PeerTableModel *peerTableModel;\n     BanTableModel *banTableModel;"
      },
      {
        "sha": "b08de27041ae5ab05171340cad2c449e2a5c4a16",
        "filename": "src/qt/coincontroldialog.cpp",
        "status": "modified",
        "additions": 36,
        "deletions": 39,
        "changes": 75,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/coincontroldialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/coincontroldialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/coincontroldialog.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -14,7 +14,7 @@\n #include <qt/walletmodel.h>\n \n #include <wallet/coincontrol.h>\n-#include <init.h>\n+#include <interfaces/node.h>\n #include <key_io.h>\n #include <policy/fees.h>\n #include <policy/policy.h>\n@@ -209,7 +209,7 @@ void CoinControlDialog::showMenu(const QPoint &point)\n         if (item->text(COLUMN_TXHASH).length() == 64) // transaction hash is 64 characters (this means it is a child node, so it is not a parent node in tree mode)\n         {\n             copyTransactionHashAction->setEnabled(true);\n-            if (model->isLockedCoin(uint256S(item->text(COLUMN_TXHASH).toStdString()), item->text(COLUMN_VOUT_INDEX).toUInt()))\n+            if (model->wallet().isLockedCoin(COutPoint(uint256S(item->text(COLUMN_TXHASH).toStdString()), item->text(COLUMN_VOUT_INDEX).toUInt())))\n             {\n                 lockAction->setEnabled(false);\n                 unlockAction->setEnabled(true);\n@@ -269,7 +269,7 @@ void CoinControlDialog::lockCoin()\n         contextMenuItem->setCheckState(COLUMN_CHECKBOX, Qt::Unchecked);\n \n     COutPoint outpt(uint256S(contextMenuItem->text(COLUMN_TXHASH).toStdString()), contextMenuItem->text(COLUMN_VOUT_INDEX).toUInt());\n-    model->lockCoin(outpt);\n+    model->wallet().lockCoin(outpt);\n     contextMenuItem->setDisabled(true);\n     contextMenuItem->setIcon(COLUMN_CHECKBOX, platformStyle->SingleColorIcon(\":/icons/lock_closed\"));\n     updateLabelLocked();\n@@ -279,7 +279,7 @@ void CoinControlDialog::lockCoin()\n void CoinControlDialog::unlockCoin()\n {\n     COutPoint outpt(uint256S(contextMenuItem->text(COLUMN_TXHASH).toStdString()), contextMenuItem->text(COLUMN_VOUT_INDEX).toUInt());\n-    model->unlockCoin(outpt);\n+    model->wallet().unlockCoin(outpt);\n     contextMenuItem->setDisabled(false);\n     contextMenuItem->setIcon(COLUMN_CHECKBOX, QIcon());\n     updateLabelLocked();\n@@ -405,7 +405,7 @@ void CoinControlDialog::viewItemChanged(QTreeWidgetItem* item, int column)\n void CoinControlDialog::updateLabelLocked()\n {\n     std::vector<COutPoint> vOutpts;\n-    model->listLockedCoins(vOutpts);\n+    model->wallet().listLockedCoins(vOutpts);\n     if (vOutpts.size() > 0)\n     {\n        ui->labelLocked->setText(tr(\"(%1 locked)\").arg(vOutpts.size()));\n@@ -431,7 +431,7 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n         {\n             CTxOut txout(amount, static_cast<CScript>(std::vector<unsigned char>(24, 0)));\n             txDummy.vout.push_back(txout);\n-            fDust |= IsDust(txout, ::dustRelayFee);\n+            fDust |= IsDust(txout, model->node().getDustRelayFee());\n         }\n     }\n \n@@ -445,16 +445,16 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n     bool fWitness               = false;\n \n     std::vector<COutPoint> vCoinControl;\n-    std::vector<COutput>   vOutputs;\n     coinControl()->ListSelected(vCoinControl);\n-    model->getOutputs(vCoinControl, vOutputs);\n \n-    for (const COutput& out : vOutputs) {\n+    size_t i = 0;\n+    for (const auto& out : model->wallet().getCoins(vCoinControl)) {\n+        if (out.depth_in_main_chain < 0) continue;\n+\n         // unselect already spent, very unlikely scenario, this could happen\n         // when selected are spent elsewhere, like rpc or another computer\n-        uint256 txhash = out.tx->GetHash();\n-        COutPoint outpt(txhash, out.i);\n-        if (model->isSpent(outpt))\n+        const COutPoint& outpt = vCoinControl[i++];\n+        if (out.is_spent)\n         {\n             coinControl()->UnSelect(outpt);\n             continue;\n@@ -464,22 +464,22 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n         nQuantity++;\n \n         // Amount\n-        nAmount += out.tx->tx->vout[out.i].nValue;\n+        nAmount += out.txout.nValue;\n \n         // Bytes\n         CTxDestination address;\n         int witnessversion = 0;\n         std::vector<unsigned char> witnessprogram;\n-        if (out.tx->tx->vout[out.i].scriptPubKey.IsWitnessProgram(witnessversion, witnessprogram))\n+        if (out.txout.scriptPubKey.IsWitnessProgram(witnessversion, witnessprogram))\n         {\n             nBytesInputs += (32 + 4 + 1 + (107 / WITNESS_SCALE_FACTOR) + 4);\n             fWitness = true;\n         }\n-        else if(ExtractDestination(out.tx->tx->vout[out.i].scriptPubKey, address))\n+        else if(ExtractDestination(out.txout.scriptPubKey, address))\n         {\n             CPubKey pubkey;\n             CKeyID *keyid = boost::get<CKeyID>(&address);\n-            if (keyid && model->getPubKey(*keyid, pubkey))\n+            if (keyid && model->wallet().getPubKey(*keyid, pubkey))\n             {\n                 nBytesInputs += (pubkey.IsCompressed() ? 148 : 180);\n             }\n@@ -509,7 +509,7 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n                 nBytes -= 34;\n \n         // Fee\n-        nPayFee = GetMinimumFee(nBytes, *coinControl(), ::mempool, ::feeEstimator, nullptr /* FeeCalculation */);\n+        nPayFee = model->wallet().getMinimumFee(nBytes, *coinControl(), nullptr /* returned_target */, nullptr /* reason */);\n \n         if (nPayAmount > 0)\n         {\n@@ -521,7 +521,7 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n             if (nChange > 0 && nChange < MIN_CHANGE)\n             {\n                 CTxOut txout(nChange, static_cast<CScript>(std::vector<unsigned char>(24, 0)));\n-                if (IsDust(txout, ::dustRelayFee))\n+                if (IsDust(txout, model->node().getDustRelayFee()))\n                 {\n                     nPayFee += nChange;\n                     nChange = 0;\n@@ -621,13 +621,10 @@ void CoinControlDialog::updateView()\n \n     int nDisplayUnit = model->getOptionsModel()->getDisplayUnit();\n \n-    std::map<QString, std::vector<COutput> > mapCoins;\n-    model->listCoins(mapCoins);\n-\n-    for (const std::pair<QString, std::vector<COutput>>& coins : mapCoins) {\n+    for (const auto& coins : model->wallet().listCoins()) {\n         CCoinControlWidgetItem *itemWalletAddress = new CCoinControlWidgetItem();\n         itemWalletAddress->setCheckState(COLUMN_CHECKBOX, Qt::Unchecked);\n-        QString sWalletAddress = coins.first;\n+        QString sWalletAddress = QString::fromStdString(EncodeDestination(coins.first));\n         QString sWalletLabel = model->getAddressTableModel()->labelForAddress(sWalletAddress);\n         if (sWalletLabel.isEmpty())\n             sWalletLabel = tr(\"(no label)\");\n@@ -649,8 +646,10 @@ void CoinControlDialog::updateView()\n \n         CAmount nSum = 0;\n         int nChildren = 0;\n-        for (const COutput& out : coins.second) {\n-            nSum += out.tx->tx->vout[out.i].nValue;\n+        for (const auto& outpair : coins.second) {\n+            const COutPoint& output = std::get<0>(outpair);\n+            const interfaces::WalletTxOut& out = std::get<1>(outpair);\n+            nSum += out.txout.nValue;\n             nChildren++;\n \n             CCoinControlWidgetItem *itemOutput;\n@@ -662,7 +661,7 @@ void CoinControlDialog::updateView()\n             // address\n             CTxDestination outputAddress;\n             QString sAddress = \"\";\n-            if(ExtractDestination(out.tx->tx->vout[out.i].scriptPubKey, outputAddress))\n+            if(ExtractDestination(out.txout.scriptPubKey, outputAddress))\n             {\n                 sAddress = QString::fromStdString(EncodeDestination(outputAddress));\n \n@@ -687,35 +686,33 @@ void CoinControlDialog::updateView()\n             }\n \n             // amount\n-            itemOutput->setText(COLUMN_AMOUNT, BitcoinUnits::format(nDisplayUnit, out.tx->tx->vout[out.i].nValue));\n-            itemOutput->setData(COLUMN_AMOUNT, Qt::UserRole, QVariant((qlonglong)out.tx->tx->vout[out.i].nValue)); // padding so that sorting works correctly\n+            itemOutput->setText(COLUMN_AMOUNT, BitcoinUnits::format(nDisplayUnit, out.txout.nValue));\n+            itemOutput->setData(COLUMN_AMOUNT, Qt::UserRole, QVariant((qlonglong)out.txout.nValue)); // padding so that sorting works correctly\n \n             // date\n-            itemOutput->setText(COLUMN_DATE, GUIUtil::dateTimeStr(out.tx->GetTxTime()));\n-            itemOutput->setData(COLUMN_DATE, Qt::UserRole, QVariant((qlonglong)out.tx->GetTxTime()));\n+            itemOutput->setText(COLUMN_DATE, GUIUtil::dateTimeStr(out.time));\n+            itemOutput->setData(COLUMN_DATE, Qt::UserRole, QVariant((qlonglong)out.time));\n \n             // confirmations\n-            itemOutput->setText(COLUMN_CONFIRMATIONS, QString::number(out.nDepth));\n-            itemOutput->setData(COLUMN_CONFIRMATIONS, Qt::UserRole, QVariant((qlonglong)out.nDepth));\n+            itemOutput->setText(COLUMN_CONFIRMATIONS, QString::number(out.depth_in_main_chain));\n+            itemOutput->setData(COLUMN_CONFIRMATIONS, Qt::UserRole, QVariant((qlonglong)out.depth_in_main_chain));\n \n             // transaction hash\n-            uint256 txhash = out.tx->GetHash();\n-            itemOutput->setText(COLUMN_TXHASH, QString::fromStdString(txhash.GetHex()));\n+            itemOutput->setText(COLUMN_TXHASH, QString::fromStdString(output.hash.GetHex()));\n \n             // vout index\n-            itemOutput->setText(COLUMN_VOUT_INDEX, QString::number(out.i));\n+            itemOutput->setText(COLUMN_VOUT_INDEX, QString::number(output.n));\n \n              // disable locked coins\n-            if (model->isLockedCoin(txhash, out.i))\n+            if (model->wallet().isLockedCoin(output))\n             {\n-                COutPoint outpt(txhash, out.i);\n-                coinControl()->UnSelect(outpt); // just to be sure\n+                coinControl()->UnSelect(output); // just to be sure\n                 itemOutput->setDisabled(true);\n                 itemOutput->setIcon(COLUMN_CHECKBOX, platformStyle->SingleColorIcon(\":/icons/lock_closed\"));\n             }\n \n             // set checkbox\n-            if (coinControl()->IsSelected(COutPoint(txhash, out.i)))\n+            if (coinControl()->IsSelected(output))\n                 itemOutput->setCheckState(COLUMN_CHECKBOX, Qt::Checked);\n         }\n "
      },
      {
        "sha": "f26a31158e2ac5bdf3bfdefd95d67b776e3ef0c8",
        "filename": "src/qt/editaddressdialog.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 1,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/editaddressdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/editaddressdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/editaddressdialog.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -109,7 +109,7 @@ void EditAddressDialog::accept()\n             break;\n         case AddressTableModel::DUPLICATE_ADDRESS:\n             QMessageBox::warning(this, windowTitle(),\n-                tr(\"The entered address \\\"%1\\\" is already in the address book.\").arg(ui->addressEdit->text()),\n+                getDuplicateAddressWarning(),\n                 QMessageBox::Ok, QMessageBox::Ok);\n             break;\n         case AddressTableModel::WALLET_UNLOCK_FAILURE:\n@@ -129,6 +129,25 @@ void EditAddressDialog::accept()\n     QDialog::accept();\n }\n \n+QString EditAddressDialog::getDuplicateAddressWarning() const\n+{\n+    QString dup_address = ui->addressEdit->text();\n+    QString existing_label = model->labelForAddress(dup_address);\n+    QString existing_purpose = model->purposeForAddress(dup_address);\n+\n+    if (existing_purpose == \"receive\" &&\n+            (mode == NewSendingAddress || mode == EditSendingAddress)) {\n+        return tr(\n+            \"Address \\\"%1\\\" already exists as a receiving address with label \"\n+            \"\\\"%2\\\" and so cannot be added as a sending address.\"\n+            ).arg(dup_address).arg(existing_label);\n+    }\n+    return tr(\n+        \"The entered address \\\"%1\\\" is already in the address book with \"\n+        \"label \\\"%2\\\".\"\n+        ).arg(dup_address).arg(existing_label);\n+}\n+\n QString EditAddressDialog::getAddress() const\n {\n     return address;"
      },
      {
        "sha": "3aba74bf088a19293923ced48871d26296b73c49",
        "filename": "src/qt/editaddressdialog.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/editaddressdialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/editaddressdialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/editaddressdialog.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -30,7 +30,7 @@ class EditAddressDialog : public QDialog\n         EditSendingAddress\n     };\n \n-    explicit EditAddressDialog(Mode mode, QWidget *parent);\n+    explicit EditAddressDialog(Mode mode, QWidget *parent = 0);\n     ~EditAddressDialog();\n \n     void setModel(AddressTableModel *model);\n@@ -45,6 +45,9 @@ public Q_SLOTS:\n private:\n     bool saveCurrentRow();\n \n+    /** Return a descriptive string when adding an already-existing address fails. */\n+    QString getDuplicateAddressWarning() const;\n+\n     Ui::EditAddressDialog *ui;\n     QDataWidgetMapper *mapper;\n     Mode mode;"
      },
      {
        "sha": "695ed61228a4007283da4f7d3be95b21be0c02e0",
        "filename": "src/qt/forms/debugwindow.ui",
        "status": "modified",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/forms/debugwindow.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/forms/debugwindow.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/debugwindow.ui?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -412,6 +412,22 @@\n          <property name=\"spacing\">\n           <number>4</number>\n          </property>\n+         <item>\n+          <widget class=\"QLabel\" name=\"WalletSelectorLabel\">\n+           <property name=\"text\">\n+            <string>Wallet: </string>\n+           </property>\n+          </widget>\n+         </item>\n+         <item>\n+          <widget class=\"QComboBox\" name=\"WalletSelector\">\n+           <item>\n+            <property name=\"text\">\n+             <string>(none)</string>\n+            </property>\n+           </item>\n+          </widget>\n+         </item>\n          <item>\n           <spacer name=\"horizontalSpacer\">\n            <property name=\"orientation\">"
      },
      {
        "sha": "563f930decbfa779131ad17c7b018e54b1503f82",
        "filename": "src/qt/guiutil.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 15,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/guiutil.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/guiutil.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiutil.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -13,7 +13,7 @@\n #include <chainparams.h>\n #include <primitives/transaction.h>\n #include <key_io.h>\n-#include <init.h>\n+#include <interfaces/node.h>\n #include <policy/policy.h>\n #include <protocol.h>\n #include <script/script.h>\n@@ -137,15 +137,6 @@ void setupAddressWidget(QValidatedLineEdit *widget, QWidget *parent)\n     widget->setCheckValidator(new BitcoinAddressCheckValidator(parent));\n }\n \n-void setupAmountWidget(QLineEdit *widget, QWidget *parent)\n-{\n-    QDoubleValidator *amountValidator = new QDoubleValidator(parent);\n-    amountValidator->setDecimals(8);\n-    amountValidator->setBottom(0.0);\n-    widget->setValidator(amountValidator);\n-    widget->setAlignment(Qt::AlignRight|Qt::AlignVCenter);\n-}\n-\n bool parseBitcoinURI(const QUrl &uri, SendCoinsRecipient *out)\n {\n     // return if URI is not valid or is no bitcoin: URI\n@@ -241,12 +232,12 @@ QString formatBitcoinURI(const SendCoinsRecipient &info)\n     return ret;\n }\n \n-bool isDust(const QString& address, const CAmount& amount)\n+bool isDust(interfaces::Node& node, const QString& address, const CAmount& amount)\n {\n     CTxDestination dest = DecodeDestination(address.toStdString());\n     CScript script = GetScriptForDestination(dest);\n     CTxOut txOut(amount, script);\n-    return IsDust(txOut, ::dustRelayFee);\n+    return IsDust(txOut, node.getDustRelayFee());\n }\n \n QString HtmlEscape(const QString& str, bool fMultiLine)\n@@ -608,7 +599,7 @@ TableViewLastColumnResizingFixer::TableViewLastColumnResizingFixer(QTableView* t\n #ifdef WIN32\n fs::path static StartupShortcutPath()\n {\n-    std::string chain = ChainNameFromCommandLine();\n+    std::string chain = gArgs.GetChainName();\n     if (chain == CBaseChainParams::MAIN)\n         return GetSpecialFolderPath(CSIDL_STARTUP) / \"Bitcoin.lnk\";\n     if (chain == CBaseChainParams::TESTNET) // Remove this special case when CBaseChainParams::TESTNET = \"testnet4\"\n@@ -706,7 +697,7 @@ fs::path static GetAutostartDir()\n \n fs::path static GetAutostartFilePath()\n {\n-    std::string chain = ChainNameFromCommandLine();\n+    std::string chain = gArgs.GetChainName();\n     if (chain == CBaseChainParams::MAIN)\n         return GetAutostartDir() / \"bitcoin.desktop\";\n     return GetAutostartDir() / strprintf(\"bitcoin-%s.lnk\", chain);\n@@ -748,7 +739,7 @@ bool SetStartOnSystemStartup(bool fAutoStart)\n         fs::ofstream optionFile(GetAutostartFilePath(), std::ios_base::out|std::ios_base::trunc);\n         if (!optionFile.good())\n             return false;\n-        std::string chain = ChainNameFromCommandLine();\n+        std::string chain = gArgs.GetChainName();\n         // Write a bitcoin.desktop file to the autostart directory:\n         optionFile << \"[Desktop Entry]\\n\";\n         optionFile << \"Type=Application\\n\";"
      },
      {
        "sha": "4a269640981dfab2a3134483e378e86c1096bee5",
        "filename": "src/qt/guiutil.h",
        "status": "modified",
        "additions": 7,
        "deletions": 3,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/guiutil.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/guiutil.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiutil.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -20,6 +20,11 @@\n class QValidatedLineEdit;\n class SendCoinsRecipient;\n \n+namespace interfaces\n+{\n+    class Node;\n+}\n+\n QT_BEGIN_NAMESPACE\n class QAbstractItemView;\n class QDateTime;\n@@ -40,17 +45,16 @@ namespace GUIUtil\n     // Return a monospace font\n     QFont fixedPitchFont();\n \n-    // Set up widgets for address and amounts\n+    // Set up widget for address\n     void setupAddressWidget(QValidatedLineEdit *widget, QWidget *parent);\n-    void setupAmountWidget(QLineEdit *widget, QWidget *parent);\n \n     // Parse \"bitcoin:\" URI into recipient object, return true on successful parsing\n     bool parseBitcoinURI(const QUrl &uri, SendCoinsRecipient *out);\n     bool parseBitcoinURI(QString uri, SendCoinsRecipient *out);\n     QString formatBitcoinURI(const SendCoinsRecipient &info);\n \n     // Returns true if given address+amount meets \"dust\" definition\n-    bool isDust(const QString& address, const CAmount& amount);\n+    bool isDust(interfaces::Node& node, const QString& address, const CAmount& amount);\n \n     // HTML escaping for rich text controls\n     QString HtmlEscape(const QString& str, bool fMultiLine=false);"
      },
      {
        "sha": "8c00ca036378791582f54d37b31a3f38a262095b",
        "filename": "src/qt/intro.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/intro.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/intro.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/intro.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -12,6 +12,7 @@\n \n #include <qt/guiutil.h>\n \n+#include <interfaces/node.h>\n #include <util.h>\n \n #include <QFileDialog>\n@@ -186,7 +187,7 @@ QString Intro::getDefaultDataDirectory()\n     return GUIUtil::boostPathToQString(GetDefaultDataDir());\n }\n \n-bool Intro::pickDataDirectory()\n+bool Intro::pickDataDirectory(interfaces::Node& node)\n {\n     QSettings settings;\n     /* If data directory provided on command line, no need to look at settings\n@@ -233,8 +234,9 @@ bool Intro::pickDataDirectory()\n      * override -datadir in the bitcoin.conf file in the default data directory\n      * (to be consistent with bitcoind behavior)\n      */\n-    if(dataDir != getDefaultDataDirectory())\n-        gArgs.SoftSetArg(\"-datadir\", GUIUtil::qstringToBoostPath(dataDir).string()); // use OS locale for path setting\n+    if(dataDir != getDefaultDataDirectory()) {\n+        node.softSetArg(\"-datadir\", GUIUtil::qstringToBoostPath(dataDir).string()); // use OS locale for path setting\n+    }\n     return true;\n }\n "
      },
      {
        "sha": "b0937aedcb3d0a457d1fa7de51290b9fd1705812",
        "filename": "src/qt/intro.h",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/intro.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/intro.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/intro.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -13,6 +13,10 @@ static const bool DEFAULT_CHOOSE_DATADIR = false;\n \n class FreespaceChecker;\n \n+namespace interfaces {\n+    class Node;\n+}\n+\n namespace Ui {\n     class Intro;\n }\n@@ -41,7 +45,7 @@ class Intro : public QDialog\n      * @note do NOT call global GetDataDir() before calling this function, this\n      * will cause the wrong path to be cached.\n      */\n-    static bool pickDataDirectory();\n+    static bool pickDataDirectory(interfaces::Node& node);\n \n     /**\n      * Determine default data directory for operating system."
      },
      {
        "sha": "c0ddb89b404ed7255b9f09c23dd2f3ff62e0a39c",
        "filename": "src/qt/optionsdialog.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/optionsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/optionsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsdialog.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -13,6 +13,7 @@\n #include <qt/guiutil.h>\n #include <qt/optionsmodel.h>\n \n+#include <interfaces/node.h>\n #include <validation.h> // for DEFAULT_SCRIPTCHECK_THREADS and MAX_SCRIPTCHECK_THREADS\n #include <netbase.h>\n #include <txdb.h> // for -dbcache defaults\n@@ -313,17 +314,17 @@ void OptionsDialog::updateDefaultProxyNets()\n     std::string strProxy;\n     QString strDefaultProxyGUI;\n \n-    GetProxy(NET_IPV4, proxy);\n+    model->node().getProxy(NET_IPV4, proxy);\n     strProxy = proxy.proxy.ToStringIP() + \":\" + proxy.proxy.ToStringPort();\n     strDefaultProxyGUI = ui->proxyIp->text() + \":\" + ui->proxyPort->text();\n     (strProxy == strDefaultProxyGUI.toStdString()) ? ui->proxyReachIPv4->setChecked(true) : ui->proxyReachIPv4->setChecked(false);\n \n-    GetProxy(NET_IPV6, proxy);\n+    model->node().getProxy(NET_IPV6, proxy);\n     strProxy = proxy.proxy.ToStringIP() + \":\" + proxy.proxy.ToStringPort();\n     strDefaultProxyGUI = ui->proxyIp->text() + \":\" + ui->proxyPort->text();\n     (strProxy == strDefaultProxyGUI.toStdString()) ? ui->proxyReachIPv6->setChecked(true) : ui->proxyReachIPv6->setChecked(false);\n \n-    GetProxy(NET_TOR, proxy);\n+    model->node().getProxy(NET_TOR, proxy);\n     strProxy = proxy.proxy.ToStringIP() + \":\" + proxy.proxy.ToStringPort();\n     strDefaultProxyGUI = ui->proxyIp->text() + \":\" + ui->proxyPort->text();\n     (strProxy == strDefaultProxyGUI.toStdString()) ? ui->proxyReachTor->setChecked(true) : ui->proxyReachTor->setChecked(false);"
      },
      {
        "sha": "cae9dace4c329ecdfc59a9901bf79902c24d6497",
        "filename": "src/qt/optionsmodel.cpp",
        "status": "modified",
        "additions": 34,
        "deletions": 25,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/optionsmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/optionsmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsmodel.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -11,26 +11,23 @@\n #include <qt/bitcoinunits.h>\n #include <qt/guiutil.h>\n \n-#include <init.h>\n+#include <interfaces/node.h>\n #include <validation.h> // For DEFAULT_SCRIPTCHECK_THREADS\n #include <net.h>\n #include <netbase.h>\n #include <txdb.h> // for -dbcache defaults\n #include <qt/intro.h>\n \n-#ifdef ENABLE_WALLET\n-#include <wallet/wallet.h>\n-#include <wallet/walletdb.h>\n-#endif\n-\n #include <QNetworkProxy>\n #include <QSettings>\n #include <QStringList>\n \n const char *DEFAULT_GUI_PROXY_HOST = \"127.0.0.1\";\n \n-OptionsModel::OptionsModel(QObject *parent, bool resetSettings) :\n-    QAbstractListModel(parent)\n+static const QString GetDefaultProxyAddress();\n+\n+OptionsModel::OptionsModel(interfaces::Node& node, QObject *parent, bool resetSettings) :\n+    QAbstractListModel(parent), m_node(node)\n {\n     Init(resetSettings);\n }\n@@ -93,12 +90,12 @@ void OptionsModel::Init(bool resetSettings)\n     // Main\n     if (!settings.contains(\"nDatabaseCache\"))\n         settings.setValue(\"nDatabaseCache\", (qint64)nDefaultDbCache);\n-    if (!gArgs.SoftSetArg(\"-dbcache\", settings.value(\"nDatabaseCache\").toString().toStdString()))\n+    if (!m_node.softSetArg(\"-dbcache\", settings.value(\"nDatabaseCache\").toString().toStdString()))\n         addOverriddenOption(\"-dbcache\");\n \n     if (!settings.contains(\"nThreadsScriptVerif\"))\n         settings.setValue(\"nThreadsScriptVerif\", DEFAULT_SCRIPTCHECK_THREADS);\n-    if (!gArgs.SoftSetArg(\"-par\", settings.value(\"nThreadsScriptVerif\").toString().toStdString()))\n+    if (!m_node.softSetArg(\"-par\", settings.value(\"nThreadsScriptVerif\").toString().toStdString()))\n         addOverriddenOption(\"-par\");\n \n     if (!settings.contains(\"strDataDir\"))\n@@ -108,45 +105,45 @@ void OptionsModel::Init(bool resetSettings)\n #ifdef ENABLE_WALLET\n     if (!settings.contains(\"bSpendZeroConfChange\"))\n         settings.setValue(\"bSpendZeroConfChange\", true);\n-    if (!gArgs.SoftSetBoolArg(\"-spendzeroconfchange\", settings.value(\"bSpendZeroConfChange\").toBool()))\n+    if (!m_node.softSetBoolArg(\"-spendzeroconfchange\", settings.value(\"bSpendZeroConfChange\").toBool()))\n         addOverriddenOption(\"-spendzeroconfchange\");\n #endif\n \n     // Network\n     if (!settings.contains(\"fUseUPnP\"))\n         settings.setValue(\"fUseUPnP\", DEFAULT_UPNP);\n-    if (!gArgs.SoftSetBoolArg(\"-upnp\", settings.value(\"fUseUPnP\").toBool()))\n+    if (!m_node.softSetBoolArg(\"-upnp\", settings.value(\"fUseUPnP\").toBool()))\n         addOverriddenOption(\"-upnp\");\n \n     if (!settings.contains(\"fListen\"))\n         settings.setValue(\"fListen\", DEFAULT_LISTEN);\n-    if (!gArgs.SoftSetBoolArg(\"-listen\", settings.value(\"fListen\").toBool()))\n+    if (!m_node.softSetBoolArg(\"-listen\", settings.value(\"fListen\").toBool()))\n         addOverriddenOption(\"-listen\");\n \n     if (!settings.contains(\"fUseProxy\"))\n         settings.setValue(\"fUseProxy\", false);\n     if (!settings.contains(\"addrProxy\"))\n-        settings.setValue(\"addrProxy\", QString(\"%1:%2\").arg(DEFAULT_GUI_PROXY_HOST, DEFAULT_GUI_PROXY_PORT));\n+        settings.setValue(\"addrProxy\", GetDefaultProxyAddress());\n     // Only try to set -proxy, if user has enabled fUseProxy\n-    if (settings.value(\"fUseProxy\").toBool() && !gArgs.SoftSetArg(\"-proxy\", settings.value(\"addrProxy\").toString().toStdString()))\n+    if (settings.value(\"fUseProxy\").toBool() && !m_node.softSetArg(\"-proxy\", settings.value(\"addrProxy\").toString().toStdString()))\n         addOverriddenOption(\"-proxy\");\n     else if(!settings.value(\"fUseProxy\").toBool() && !gArgs.GetArg(\"-proxy\", \"\").empty())\n         addOverriddenOption(\"-proxy\");\n \n     if (!settings.contains(\"fUseSeparateProxyTor\"))\n         settings.setValue(\"fUseSeparateProxyTor\", false);\n     if (!settings.contains(\"addrSeparateProxyTor\"))\n-        settings.setValue(\"addrSeparateProxyTor\", QString(\"%1:%2\").arg(DEFAULT_GUI_PROXY_HOST, DEFAULT_GUI_PROXY_PORT));\n+        settings.setValue(\"addrSeparateProxyTor\", GetDefaultProxyAddress());\n     // Only try to set -onion, if user has enabled fUseSeparateProxyTor\n-    if (settings.value(\"fUseSeparateProxyTor\").toBool() && !gArgs.SoftSetArg(\"-onion\", settings.value(\"addrSeparateProxyTor\").toString().toStdString()))\n+    if (settings.value(\"fUseSeparateProxyTor\").toBool() && !m_node.softSetArg(\"-onion\", settings.value(\"addrSeparateProxyTor\").toString().toStdString()))\n         addOverriddenOption(\"-onion\");\n     else if(!settings.value(\"fUseSeparateProxyTor\").toBool() && !gArgs.GetArg(\"-onion\", \"\").empty())\n         addOverriddenOption(\"-onion\");\n \n     // Display\n     if (!settings.contains(\"language\"))\n         settings.setValue(\"language\", \"\");\n-    if (!gArgs.SoftSetArg(\"-lang\", settings.value(\"language\").toString().toStdString()))\n+    if (!m_node.softSetArg(\"-lang\", settings.value(\"language\").toString().toStdString()))\n         addOverriddenOption(\"-lang\");\n \n     language = settings.value(\"language\").toString();\n@@ -228,6 +225,11 @@ static void SetProxySetting(QSettings &settings, const QString &name, const Prox\n     settings.setValue(name, ip_port.ip + \":\" + ip_port.port);\n }\n \n+static const QString GetDefaultProxyAddress()\n+{\n+    return QString(\"%1:%2\").arg(DEFAULT_GUI_PROXY_HOST).arg(DEFAULT_GUI_PROXY_PORT);\n+}\n+\n // read QSettings values and return them\n QVariant OptionsModel::data(const QModelIndex & index, int role) const\n {\n@@ -315,12 +317,7 @@ bool OptionsModel::setData(const QModelIndex & index, const QVariant & value, in\n             break;\n         case MapPortUPnP: // core option - can be changed on-the-fly\n             settings.setValue(\"fUseUPnP\", value.toBool());\n-            if (value.toBool()) {\n-                StartMapPort();\n-            } else {\n-                InterruptMapPort();\n-                StopMapPort();\n-            }\n+            m_node.mapPort(value.toBool());\n             break;\n         case MinimizeOnClose:\n             fMinimizeOnClose = value.toBool();\n@@ -453,7 +450,7 @@ bool OptionsModel::getProxySettings(QNetworkProxy& proxy) const\n     // Directly query current base proxy, because\n     // GUI settings can be overridden with -proxy.\n     proxyType curProxy;\n-    if (GetProxy(NET_IPV4, curProxy)) {\n+    if (m_node.getProxy(NET_IPV4, curProxy)) {\n         proxy.setType(QNetworkProxy::Socks5Proxy);\n         proxy.setHostName(QString::fromStdString(curProxy.proxy.ToStringIP()));\n         proxy.setPort(curProxy.proxy.GetPort());\n@@ -495,4 +492,16 @@ void OptionsModel::checkAndMigrate()\n \n         settings.setValue(strSettingsVersionKey, CLIENT_VERSION);\n     }\n+\n+    // Overwrite the 'addrProxy' setting in case it has been set to an illegal\n+    // default value (see issue #12623; PR #12650).\n+    if (settings.contains(\"addrProxy\") && settings.value(\"addrProxy\").toString().endsWith(\"%2\")) {\n+        settings.setValue(\"addrProxy\", GetDefaultProxyAddress());\n+    }\n+\n+    // Overwrite the 'addrSeparateProxyTor' setting in case it has been set to an illegal\n+    // default value (see issue #12623; PR #12650).\n+    if (settings.contains(\"addrSeparateProxyTor\") && settings.value(\"addrSeparateProxyTor\").toString().endsWith(\"%2\")) {\n+        settings.setValue(\"addrSeparateProxyTor\", GetDefaultProxyAddress());\n+    }\n }"
      },
      {
        "sha": "fc1d119a710fad0011044a3ecd88b7daa486e955",
        "filename": "src/qt/optionsmodel.h",
        "status": "modified",
        "additions": 8,
        "deletions": 1,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/optionsmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/optionsmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsmodel.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -9,6 +9,10 @@\n \n #include <QAbstractListModel>\n \n+namespace interfaces {\n+class Node;\n+}\n+\n QT_BEGIN_NAMESPACE\n class QNetworkProxy;\n QT_END_NAMESPACE\n@@ -27,7 +31,7 @@ class OptionsModel : public QAbstractListModel\n     Q_OBJECT\n \n public:\n-    explicit OptionsModel(QObject *parent = 0, bool resetSettings = false);\n+    explicit OptionsModel(interfaces::Node& node, QObject *parent = 0, bool resetSettings = false);\n \n     enum OptionID {\n         StartAtStartup,         // bool\n@@ -75,7 +79,10 @@ class OptionsModel : public QAbstractListModel\n     void setRestartRequired(bool fRequired);\n     bool isRestartRequired() const;\n \n+    interfaces::Node& node() const { return m_node; }\n+\n private:\n+    interfaces::Node& m_node;\n     /* Qt-only settings */\n     bool fHideTrayIcon;\n     bool fMinimizeToTray;"
      },
      {
        "sha": "8e8788dad3aafd3cd1eb63ff4a4fbcbb86e48913",
        "filename": "src/qt/overviewpage.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 30,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/overviewpage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/overviewpage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/overviewpage.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -21,6 +21,8 @@\n #define DECORATION_SIZE 54\n #define NUM_ITEMS 5\n \n+Q_DECLARE_METATYPE(interfaces::WalletBalances)\n+\n class TxViewDelegate : public QAbstractItemDelegate\n {\n     Q_OBJECT\n@@ -113,16 +115,12 @@ OverviewPage::OverviewPage(const PlatformStyle *platformStyle, QWidget *parent)\n     ui(new Ui::OverviewPage),\n     clientModel(0),\n     walletModel(0),\n-    currentBalance(-1),\n-    currentUnconfirmedBalance(-1),\n-    currentImmatureBalance(-1),\n-    currentWatchOnlyBalance(-1),\n-    currentWatchUnconfBalance(-1),\n-    currentWatchImmatureBalance(-1),\n     txdelegate(new TxViewDelegate(platformStyle, this))\n {\n     ui->setupUi(this);\n \n+    m_balances.balance = -1;\n+\n     // use a SingleColorIcon for the \"out of sync warning\" icon\n     QIcon icon = platformStyle->SingleColorIcon(\":/icons/warning\");\n     icon.addPixmap(icon.pixmap(QSize(64,64), QIcon::Normal), QIcon::Disabled); // also set the disabled icon because we are using a disabled QPushButton to work around missing HiDPI support of QLabel (https://bugreports.qt.io/browse/QTBUG-42503)\n@@ -159,28 +157,23 @@ OverviewPage::~OverviewPage()\n     delete ui;\n }\n \n-void OverviewPage::setBalance(const CAmount& balance, const CAmount& unconfirmedBalance, const CAmount& immatureBalance, const CAmount& watchOnlyBalance, const CAmount& watchUnconfBalance, const CAmount& watchImmatureBalance)\n+void OverviewPage::setBalance(const interfaces::WalletBalances& balances)\n {\n     int unit = walletModel->getOptionsModel()->getDisplayUnit();\n-    currentBalance = balance;\n-    currentUnconfirmedBalance = unconfirmedBalance;\n-    currentImmatureBalance = immatureBalance;\n-    currentWatchOnlyBalance = watchOnlyBalance;\n-    currentWatchUnconfBalance = watchUnconfBalance;\n-    currentWatchImmatureBalance = watchImmatureBalance;\n-    ui->labelBalance->setText(BitcoinUnits::formatWithUnit(unit, balance, false, BitcoinUnits::separatorAlways));\n-    ui->labelUnconfirmed->setText(BitcoinUnits::formatWithUnit(unit, unconfirmedBalance, false, BitcoinUnits::separatorAlways));\n-    ui->labelImmature->setText(BitcoinUnits::formatWithUnit(unit, immatureBalance, false, BitcoinUnits::separatorAlways));\n-    ui->labelTotal->setText(BitcoinUnits::formatWithUnit(unit, balance + unconfirmedBalance + immatureBalance, false, BitcoinUnits::separatorAlways));\n-    ui->labelWatchAvailable->setText(BitcoinUnits::formatWithUnit(unit, watchOnlyBalance, false, BitcoinUnits::separatorAlways));\n-    ui->labelWatchPending->setText(BitcoinUnits::formatWithUnit(unit, watchUnconfBalance, false, BitcoinUnits::separatorAlways));\n-    ui->labelWatchImmature->setText(BitcoinUnits::formatWithUnit(unit, watchImmatureBalance, false, BitcoinUnits::separatorAlways));\n-    ui->labelWatchTotal->setText(BitcoinUnits::formatWithUnit(unit, watchOnlyBalance + watchUnconfBalance + watchImmatureBalance, false, BitcoinUnits::separatorAlways));\n+    m_balances = balances;\n+    ui->labelBalance->setText(BitcoinUnits::formatWithUnit(unit, balances.balance, false, BitcoinUnits::separatorAlways));\n+    ui->labelUnconfirmed->setText(BitcoinUnits::formatWithUnit(unit, balances.unconfirmed_balance, false, BitcoinUnits::separatorAlways));\n+    ui->labelImmature->setText(BitcoinUnits::formatWithUnit(unit, balances.immature_balance, false, BitcoinUnits::separatorAlways));\n+    ui->labelTotal->setText(BitcoinUnits::formatWithUnit(unit, balances.balance + balances.unconfirmed_balance + balances.immature_balance, false, BitcoinUnits::separatorAlways));\n+    ui->labelWatchAvailable->setText(BitcoinUnits::formatWithUnit(unit, balances.watch_only_balance, false, BitcoinUnits::separatorAlways));\n+    ui->labelWatchPending->setText(BitcoinUnits::formatWithUnit(unit, balances.unconfirmed_watch_only_balance, false, BitcoinUnits::separatorAlways));\n+    ui->labelWatchImmature->setText(BitcoinUnits::formatWithUnit(unit, balances.immature_watch_only_balance, false, BitcoinUnits::separatorAlways));\n+    ui->labelWatchTotal->setText(BitcoinUnits::formatWithUnit(unit, balances.watch_only_balance + balances.unconfirmed_watch_only_balance + balances.immature_watch_only_balance, false, BitcoinUnits::separatorAlways));\n \n     // only show immature (newly mined) balance if it's non-zero, so as not to complicate things\n     // for the non-mining users\n-    bool showImmature = immatureBalance != 0;\n-    bool showWatchOnlyImmature = watchImmatureBalance != 0;\n+    bool showImmature = balances.immature_balance != 0;\n+    bool showWatchOnlyImmature = balances.immature_watch_only_balance != 0;\n \n     // for symmetry reasons also show immature label when the watch-only one is shown\n     ui->labelImmature->setVisible(showImmature || showWatchOnlyImmature);\n@@ -231,13 +224,14 @@ void OverviewPage::setWalletModel(WalletModel *model)\n         ui->listTransactions->setModelColumn(TransactionTableModel::ToAddress);\n \n         // Keep up to date with wallet\n-        setBalance(model->getBalance(), model->getUnconfirmedBalance(), model->getImmatureBalance(),\n-                   model->getWatchBalance(), model->getWatchUnconfirmedBalance(), model->getWatchImmatureBalance());\n-        connect(model, SIGNAL(balanceChanged(CAmount,CAmount,CAmount,CAmount,CAmount,CAmount)), this, SLOT(setBalance(CAmount,CAmount,CAmount,CAmount,CAmount,CAmount)));\n+        interfaces::Wallet& wallet = model->wallet();\n+        interfaces::WalletBalances balances = wallet.getBalances();\n+        setBalance(balances);\n+        connect(model, SIGNAL(balanceChanged(interfaces::WalletBalances)), this, SLOT(setBalance(interfaces::WalletBalances)));\n \n         connect(model->getOptionsModel(), SIGNAL(displayUnitChanged(int)), this, SLOT(updateDisplayUnit()));\n \n-        updateWatchOnlyLabels(model->haveWatchOnly());\n+        updateWatchOnlyLabels(wallet.haveWatchOnly());\n         connect(model, SIGNAL(notifyWatchonlyChanged(bool)), this, SLOT(updateWatchOnlyLabels(bool)));\n     }\n \n@@ -249,9 +243,9 @@ void OverviewPage::updateDisplayUnit()\n {\n     if(walletModel && walletModel->getOptionsModel())\n     {\n-        if(currentBalance != -1)\n-            setBalance(currentBalance, currentUnconfirmedBalance, currentImmatureBalance,\n-                       currentWatchOnlyBalance, currentWatchUnconfBalance, currentWatchImmatureBalance);\n+        if (m_balances.balance != -1) {\n+            setBalance(m_balances);\n+        }\n \n         // Update txdelegate->unit with the current unit\n         txdelegate->unit = walletModel->getOptionsModel()->getDisplayUnit();"
      },
      {
        "sha": "d519eca43a379a7265d60cca247b16c5362d78d2",
        "filename": "src/qt/overviewpage.h",
        "status": "modified",
        "additions": 3,
        "deletions": 9,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/overviewpage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/overviewpage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/overviewpage.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -5,7 +5,7 @@\n #ifndef BITCOIN_QT_OVERVIEWPAGE_H\n #define BITCOIN_QT_OVERVIEWPAGE_H\n \n-#include <amount.h>\n+#include <interfaces/wallet.h>\n \n #include <QWidget>\n #include <memory>\n@@ -38,8 +38,7 @@ class OverviewPage : public QWidget\n     void showOutOfSyncWarning(bool fShow);\n \n public Q_SLOTS:\n-    void setBalance(const CAmount& balance, const CAmount& unconfirmedBalance, const CAmount& immatureBalance,\n-                    const CAmount& watchOnlyBalance, const CAmount& watchUnconfBalance, const CAmount& watchImmatureBalance);\n+    void setBalance(const interfaces::WalletBalances& balances);\n \n Q_SIGNALS:\n     void transactionClicked(const QModelIndex &index);\n@@ -49,12 +48,7 @@ public Q_SLOTS:\n     Ui::OverviewPage *ui;\n     ClientModel *clientModel;\n     WalletModel *walletModel;\n-    CAmount currentBalance;\n-    CAmount currentUnconfirmedBalance;\n-    CAmount currentImmatureBalance;\n-    CAmount currentWatchOnlyBalance;\n-    CAmount currentWatchUnconfBalance;\n-    CAmount currentWatchImmatureBalance;\n+    interfaces::WalletBalances m_balances;\n \n     TxViewDelegate *txdelegate;\n     std::unique_ptr<TransactionFilterProxy> filter;"
      },
      {
        "sha": "b0ef475b356c6349d8b854bfee3f1dae97e84462",
        "filename": "src/qt/paymentrequestplus.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/paymentrequestplus.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/paymentrequestplus.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentrequestplus.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -9,7 +9,6 @@\n \n #include <qt/paymentrequestplus.h>\n \n-#include <script/script.h>\n #include <util.h>\n \n #include <stdexcept>"
      },
      {
        "sha": "59bb5d5bb67c584ade15ce7e57554a79c7dbe18f",
        "filename": "src/qt/paymentserver.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 15,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/paymentserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/paymentserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentserver.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -9,13 +9,15 @@\n #include <qt/optionsmodel.h>\n \n #include <chainparams.h>\n+#include <interfaces/node.h>\n #include <policy/policy.h>\n #include <key_io.h>\n #include <ui_interface.h>\n #include <util.h>\n #include <wallet/wallet.h>\n \n #include <cstdlib>\n+#include <memory>\n \n #include <openssl/x509_vfy.h>\n \n@@ -199,7 +201,7 @@ void PaymentServer::LoadRootCAs(X509_STORE* _store)\n // Warning: ipcSendCommandLine() is called early in init,\n // so don't use \"Q_EMIT message()\", but \"QMessageBox::\"!\n //\n-void PaymentServer::ipcParseCommandLine(int argc, char* argv[])\n+void PaymentServer::ipcParseCommandLine(interfaces::Node& node, int argc, char* argv[])\n {\n     for (int i = 1; i < argc; i++)\n     {\n@@ -221,11 +223,11 @@ void PaymentServer::ipcParseCommandLine(int argc, char* argv[])\n                 auto tempChainParams = CreateChainParams(CBaseChainParams::MAIN);\n \n                 if (IsValidDestinationString(r.address.toStdString(), *tempChainParams)) {\n-                    SelectParams(CBaseChainParams::MAIN);\n+                    node.selectParams(CBaseChainParams::MAIN);\n                 } else {\n                     tempChainParams = CreateChainParams(CBaseChainParams::TESTNET);\n                     if (IsValidDestinationString(r.address.toStdString(), *tempChainParams)) {\n-                        SelectParams(CBaseChainParams::TESTNET);\n+                        node.selectParams(CBaseChainParams::TESTNET);\n                     }\n                 }\n             }\n@@ -239,11 +241,11 @@ void PaymentServer::ipcParseCommandLine(int argc, char* argv[])\n             {\n                 if (request.getDetails().network() == \"main\")\n                 {\n-                    SelectParams(CBaseChainParams::MAIN);\n+                    node.selectParams(CBaseChainParams::MAIN);\n                 }\n                 else if (request.getDetails().network() == \"test\")\n                 {\n-                    SelectParams(CBaseChainParams::TESTNET);\n+                    node.selectParams(CBaseChainParams::TESTNET);\n                 }\n             }\n         }\n@@ -526,7 +528,7 @@ bool PaymentServer::processPaymentRequest(const PaymentRequestPlus& request, Sen\n \n     if (request.IsInitialized()) {\n         // Payment request network matches client network?\n-        if (!verifyNetwork(request.getDetails())) {\n+        if (!verifyNetwork(optionsModel->node(), request.getDetails())) {\n             Q_EMIT message(tr(\"Payment request rejected\"), tr(\"Payment request network doesn't match client network.\"),\n                 CClientUIInterface::MSG_ERROR);\n \n@@ -583,7 +585,7 @@ bool PaymentServer::processPaymentRequest(const PaymentRequestPlus& request, Sen\n \n         // Extract and check amounts\n         CTxOut txOut(sendingTo.second, sendingTo.first);\n-        if (IsDust(txOut, ::dustRelayFee)) {\n+        if (IsDust(txOut, optionsModel->node().getDustRelayFee())) {\n             Q_EMIT message(tr(\"Payment request error\"), tr(\"Requested payment amount of %1 is too small (considered dust).\")\n                 .arg(BitcoinUnits::formatWithUnit(optionsModel->getDisplayUnit(), sendingTo.second)),\n                 CClientUIInterface::MSG_ERROR);\n@@ -621,7 +623,7 @@ void PaymentServer::fetchRequest(const QUrl& url)\n     netManager->get(netRequest);\n }\n \n-void PaymentServer::fetchPaymentACK(CWallet* wallet, const SendCoinsRecipient& recipient, QByteArray transaction)\n+void PaymentServer::fetchPaymentACK(WalletModel* walletModel, const SendCoinsRecipient& recipient, QByteArray transaction)\n {\n     const payments::PaymentDetails& details = recipient.paymentRequest.getDetails();\n     if (!details.has_payment_url())\n@@ -640,17 +642,17 @@ void PaymentServer::fetchPaymentACK(CWallet* wallet, const SendCoinsRecipient& r\n \n     // Create a new refund address, or re-use:\n     CPubKey newKey;\n-    if (wallet->GetKeyFromPool(newKey)) {\n+    if (walletModel->wallet().getKeyFromPool(false /* internal */, newKey)) {\n         // BIP70 requests encode the scriptPubKey directly, so we are not restricted to address\n         // types supported by the receiver. As a result, we choose the address format we also\n         // use for change. Despite an actual payment and not change, this is a close match:\n         // it's the output type we use subject to privacy issues, but not restricted by what\n         // other software supports.\n-        const OutputType change_type = wallet->m_default_change_type != OutputType::NONE ? wallet->m_default_change_type : wallet->m_default_address_type;\n-        wallet->LearnRelatedScripts(newKey, change_type);\n+        const OutputType change_type = walletModel->wallet().getDefaultChangeType() != OutputType::CHANGE_AUTO ? walletModel->wallet().getDefaultChangeType() : walletModel->wallet().getDefaultAddressType();\n+        walletModel->wallet().learnRelatedScripts(newKey, change_type);\n         CTxDestination dest = GetDestinationForKey(newKey, change_type);\n         std::string label = tr(\"Refund from %1\").arg(recipient.authenticatedMerchant).toStdString();\n-        wallet->SetAddressBook(dest, label, \"refund\");\n+        walletModel->wallet().setAddressBook(dest, label, \"refund\");\n \n         CScript s = GetScriptForDestination(dest);\n         payments::Output* refund_to = payment.add_refund_to();\n@@ -758,14 +760,14 @@ void PaymentServer::handlePaymentACK(const QString& paymentACKMsg)\n     Q_EMIT message(tr(\"Payment acknowledged\"), paymentACKMsg, CClientUIInterface::ICON_INFORMATION | CClientUIInterface::MODAL);\n }\n \n-bool PaymentServer::verifyNetwork(const payments::PaymentDetails& requestDetails)\n+bool PaymentServer::verifyNetwork(interfaces::Node& node, const payments::PaymentDetails& requestDetails)\n {\n-    bool fVerified = requestDetails.network() == Params().NetworkIDString();\n+    bool fVerified = requestDetails.network() == node.getNetwork();\n     if (!fVerified) {\n         qWarning() << QString(\"PaymentServer::%1: Payment request network \\\"%2\\\" doesn't match client network \\\"%3\\\".\")\n             .arg(__func__)\n             .arg(QString::fromStdString(requestDetails.network()))\n-            .arg(QString::fromStdString(Params().NetworkIDString()));\n+            .arg(QString::fromStdString(node.getNetwork()));\n     }\n     return fVerified;\n }"
      },
      {
        "sha": "511fc5bd6ee9fbd3e885fd710e0e6bda84502022",
        "filename": "src/qt/paymentserver.h",
        "status": "modified",
        "additions": 3,
        "deletions": 5,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/paymentserver.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/paymentserver.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentserver.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -40,8 +40,6 @@\n \n class OptionsModel;\n \n-class CWallet;\n-\n QT_BEGIN_NAMESPACE\n class QApplication;\n class QByteArray;\n@@ -62,7 +60,7 @@ class PaymentServer : public QObject\n public:\n     // Parse URIs on command line\n     // Returns false on error\n-    static void ipcParseCommandLine(int argc, char *argv[]);\n+    static void ipcParseCommandLine(interfaces::Node& node, int argc, char *argv[]);\n \n     // Returns true if there were URIs on the command line\n     // which were successfully sent to an already-running\n@@ -89,7 +87,7 @@ class PaymentServer : public QObject\n     void setOptionsModel(OptionsModel *optionsModel);\n \n     // Verify that the payment request network matches the client network\n-    static bool verifyNetwork(const payments::PaymentDetails& requestDetails);\n+    static bool verifyNetwork(interfaces::Node& node, const payments::PaymentDetails& requestDetails);\n     // Verify if the payment request is expired\n     static bool verifyExpired(const payments::PaymentDetails& requestDetails);\n     // Verify the payment request size is valid as per BIP70\n@@ -113,7 +111,7 @@ public Q_SLOTS:\n     void uiReady();\n \n     // Submit Payment message to a merchant, get back PaymentACK:\n-    void fetchPaymentACK(CWallet* wallet, const SendCoinsRecipient& recipient, QByteArray transaction);\n+    void fetchPaymentACK(WalletModel* walletModel, const SendCoinsRecipient& recipient, QByteArray transaction);\n \n     // Handle an incoming URI, URI with local file scheme or file\n     void handleURIOrFile(const QString& s);"
      },
      {
        "sha": "7e318e3035aac309862f04ebdbc4c6080a42062d",
        "filename": "src/qt/peertablemodel.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 23,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/peertablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/peertablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/peertablemodel.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -8,6 +8,7 @@\n #include <qt/guiconstants.h>\n #include <qt/guiutil.h>\n \n+#include <interfaces/node.h>\n #include <validation.h> // for cs_main\n #include <sync.h>\n \n@@ -56,38 +57,26 @@ class PeerTablePriv\n     std::map<NodeId, int> mapNodeRows;\n \n     /** Pull a full list of peers from vNodes into our cache */\n-    void refreshPeers()\n+    void refreshPeers(interfaces::Node& node)\n     {\n         {\n             cachedNodeStats.clear();\n-            std::vector<CNodeStats> vstats;\n-            if(g_connman)\n-                g_connman->GetNodeStats(vstats);\n+\n+            interfaces::Node::NodesStats nodes_stats;\n+            node.getNodesStats(nodes_stats);\n #if QT_VERSION >= 0x040700\n-            cachedNodeStats.reserve(vstats.size());\n+            cachedNodeStats.reserve(nodes_stats.size());\n #endif\n-            for (const CNodeStats& nodestats : vstats)\n+            for (auto& node_stats : nodes_stats)\n             {\n                 CNodeCombinedStats stats;\n-                stats.nodeStateStats.nMisbehavior = 0;\n-                stats.nodeStateStats.nSyncHeight = -1;\n-                stats.nodeStateStats.nCommonHeight = -1;\n-                stats.fNodeStateStatsAvailable = false;\n-                stats.nodeStats = nodestats;\n+                stats.nodeStats = std::get<0>(node_stats);\n+                stats.fNodeStateStatsAvailable = std::get<1>(node_stats);\n+                stats.nodeStateStats = std::get<2>(node_stats);\n                 cachedNodeStats.append(stats);\n             }\n         }\n \n-        // Try to retrieve the CNodeStateStats for each node.\n-        {\n-            TRY_LOCK(cs_main, lockMain);\n-            if (lockMain)\n-            {\n-                for (CNodeCombinedStats &stats : cachedNodeStats)\n-                    stats.fNodeStateStatsAvailable = GetNodeStateStats(stats.nodeStats.nodeid, stats.nodeStateStats);\n-            }\n-        }\n-\n         if (sortColumn >= 0)\n             // sort cacheNodeStats (use stable sort to prevent rows jumping around unnecessarily)\n             qStableSort(cachedNodeStats.begin(), cachedNodeStats.end(), NodeLessThan(sortColumn, sortOrder));\n@@ -113,8 +102,9 @@ class PeerTablePriv\n     }\n };\n \n-PeerTableModel::PeerTableModel(ClientModel *parent) :\n+PeerTableModel::PeerTableModel(interfaces::Node& node, ClientModel *parent) :\n     QAbstractTableModel(parent),\n+    m_node(node),\n     clientModel(parent),\n     timer(0)\n {\n@@ -235,7 +225,7 @@ const CNodeCombinedStats *PeerTableModel::getNodeStats(int idx)\n void PeerTableModel::refresh()\n {\n     Q_EMIT layoutAboutToBeChanged();\n-    priv->refreshPeers();\n+    priv->refreshPeers(m_node);\n     Q_EMIT layoutChanged();\n }\n "
      },
      {
        "sha": "69c9744c8fb1ecc2e8149ac2a20c52da3c5635bc",
        "filename": "src/qt/peertablemodel.h",
        "status": "modified",
        "additions": 8,
        "deletions": 1,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/peertablemodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/peertablemodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/peertablemodel.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -8,12 +8,18 @@\n #include <net_processing.h> // For CNodeStateStats\n #include <net.h>\n \n+#include <memory>\n+\n #include <QAbstractTableModel>\n #include <QStringList>\n \n class ClientModel;\n class PeerTablePriv;\n \n+namespace interfaces {\n+class Node;\n+}\n+\n QT_BEGIN_NAMESPACE\n class QTimer;\n QT_END_NAMESPACE\n@@ -45,7 +51,7 @@ class PeerTableModel : public QAbstractTableModel\n     Q_OBJECT\n \n public:\n-    explicit PeerTableModel(ClientModel *parent = 0);\n+    explicit PeerTableModel(interfaces::Node& node, ClientModel *parent = 0);\n     ~PeerTableModel();\n     const CNodeCombinedStats *getNodeStats(int idx);\n     int getRowByNodeId(NodeId nodeid);\n@@ -76,6 +82,7 @@ public Q_SLOTS:\n     void refresh();\n \n private:\n+    interfaces::Node& m_node;\n     ClientModel *clientModel;\n     QStringList columns;\n     std::unique_ptr<PeerTablePriv> priv;"
      },
      {
        "sha": "70e11f0296273c9edb753ee5bbd448509516eb91",
        "filename": "src/qt/receivecoinsdialog.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/receivecoinsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/receivecoinsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/receivecoinsdialog.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -95,13 +95,13 @@ void ReceiveCoinsDialog::setModel(WalletModel *_model)\n         columnResizingFixer = new GUIUtil::TableViewLastColumnResizingFixer(tableView, AMOUNT_MINIMUM_COLUMN_WIDTH, DATE_COLUMN_WIDTH, this);\n \n         // configure bech32 checkbox, disable if launched with legacy as default:\n-        if (model->getDefaultAddressType() == OutputType::BECH32) {\n+        if (model->wallet().getDefaultAddressType() == OutputType::BECH32) {\n             ui->useBech32->setCheckState(Qt::Checked);\n         } else {\n             ui->useBech32->setCheckState(Qt::Unchecked);\n         }\n \n-        ui->useBech32->setVisible(model->getDefaultAddressType() != OutputType::LEGACY);\n+        ui->useBech32->setVisible(model->wallet().getDefaultAddressType() != OutputType::LEGACY);\n     }\n }\n \n@@ -144,7 +144,7 @@ void ReceiveCoinsDialog::on_receiveButton_clicked()\n     QString address;\n     QString label = ui->reqLabel->text();\n     /* Generate new receiving address */\n-    OutputType address_type = model->getDefaultAddressType();\n+    OutputType address_type = model->wallet().getDefaultAddressType();\n     if (address_type != OutputType::LEGACY) {\n         address_type = ui->useBech32->isChecked() ? OutputType::BECH32 : OutputType::P2SH_SEGWIT;\n     }\n@@ -153,7 +153,7 @@ void ReceiveCoinsDialog::on_receiveButton_clicked()\n         ui->reqAmount->value(), ui->reqMessage->text());\n     ReceiveRequestDialog *dialog = new ReceiveRequestDialog(this);\n     dialog->setAttribute(Qt::WA_DeleteOnClose);\n-    dialog->setModel(model->getOptionsModel());\n+    dialog->setModel(model);\n     dialog->setInfo(info);\n     dialog->show();\n     clear();\n@@ -166,7 +166,7 @@ void ReceiveCoinsDialog::on_recentRequestsView_doubleClicked(const QModelIndex &\n {\n     const RecentRequestsTableModel *submodel = model->getRecentRequestsTableModel();\n     ReceiveRequestDialog *dialog = new ReceiveRequestDialog(this);\n-    dialog->setModel(model->getOptionsModel());\n+    dialog->setModel(model);\n     dialog->setInfo(submodel->entry(index.row()).recipient);\n     dialog->setAttribute(Qt::WA_DeleteOnClose);\n     dialog->show();"
      },
      {
        "sha": "75146e22141b911508cbdb46de19e826f5b484a7",
        "filename": "src/qt/receiverequestdialog.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 3,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/receiverequestdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/receiverequestdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/receiverequestdialog.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -108,12 +108,12 @@ ReceiveRequestDialog::~ReceiveRequestDialog()\n     delete ui;\n }\n \n-void ReceiveRequestDialog::setModel(OptionsModel *_model)\n+void ReceiveRequestDialog::setModel(WalletModel *_model)\n {\n     this->model = _model;\n \n     if (_model)\n-        connect(_model, SIGNAL(displayUnitChanged(int)), this, SLOT(update()));\n+        connect(_model->getOptionsModel(), SIGNAL(displayUnitChanged(int)), this, SLOT(update()));\n \n     // update the display unit if necessary\n     update();\n@@ -143,11 +143,14 @@ void ReceiveRequestDialog::update()\n     html += \"<a href=\\\"\"+uri+\"\\\">\" + GUIUtil::HtmlEscape(uri) + \"</a><br>\";\n     html += \"<b>\"+tr(\"Address\")+\"</b>: \" + GUIUtil::HtmlEscape(info.address) + \"<br>\";\n     if(info.amount)\n-        html += \"<b>\"+tr(\"Amount\")+\"</b>: \" + BitcoinUnits::formatHtmlWithUnit(model->getDisplayUnit(), info.amount) + \"<br>\";\n+        html += \"<b>\"+tr(\"Amount\")+\"</b>: \" + BitcoinUnits::formatHtmlWithUnit(model->getOptionsModel()->getDisplayUnit(), info.amount) + \"<br>\";\n     if(!info.label.isEmpty())\n         html += \"<b>\"+tr(\"Label\")+\"</b>: \" + GUIUtil::HtmlEscape(info.label) + \"<br>\";\n     if(!info.message.isEmpty())\n         html += \"<b>\"+tr(\"Message\")+\"</b>: \" + GUIUtil::HtmlEscape(info.message) + \"<br>\";\n+    if(model->isMultiwallet()) {\n+        html += \"<b>\"+tr(\"Wallet\")+\"</b>: \" + GUIUtil::HtmlEscape(model->getWalletName()) + \"<br>\";\n+    }\n     ui->outUri->setText(html);\n \n #ifdef USE_QRCODE"
      },
      {
        "sha": "23c5529535c1938bdc211530fb8127fceda08722",
        "filename": "src/qt/receiverequestdialog.h",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/receiverequestdialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/receiverequestdialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/receiverequestdialog.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -12,8 +12,6 @@\n #include <QLabel>\n #include <QPainter>\n \n-class OptionsModel;\n-\n namespace Ui {\n     class ReceiveRequestDialog;\n }\n@@ -53,7 +51,7 @@ class ReceiveRequestDialog : public QDialog\n     explicit ReceiveRequestDialog(QWidget *parent = 0);\n     ~ReceiveRequestDialog();\n \n-    void setModel(OptionsModel *model);\n+    void setModel(WalletModel *model);\n     void setInfo(const SendCoinsRecipient &info);\n \n private Q_SLOTS:\n@@ -64,7 +62,7 @@ private Q_SLOTS:\n \n private:\n     Ui::ReceiveRequestDialog *ui;\n-    OptionsModel *model;\n+    WalletModel *model;\n     SendCoinsRecipient info;\n };\n "
      },
      {
        "sha": "1c910926d4ddf313982cfac75990736a0b630db4",
        "filename": "src/qt/recentrequeststablemodel.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/recentrequeststablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/recentrequeststablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/recentrequeststablemodel.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -12,10 +12,9 @@\n #include <streams.h>\n \n \n-RecentRequestsTableModel::RecentRequestsTableModel(CWallet *wallet, WalletModel *parent) :\n+RecentRequestsTableModel::RecentRequestsTableModel(WalletModel *parent) :\n     QAbstractTableModel(parent), walletModel(parent)\n {\n-    Q_UNUSED(wallet);\n     nReceiveRequestsMaxId = 0;\n \n     // Load entries from wallet\n@@ -139,10 +138,9 @@ bool RecentRequestsTableModel::removeRows(int row, int count, const QModelIndex\n \n     if(count > 0 && row >= 0 && (row+count) <= list.size())\n     {\n-        const RecentRequestEntry *rec;\n         for (int i = 0; i < count; ++i)\n         {\n-            rec = &list[row+i];\n+            const RecentRequestEntry* rec = &list[row+i];\n             if (!walletModel->saveReceiveRequest(rec->recipient.address.toStdString(), rec->id, \"\"))\n                 return false;\n         }"
      },
      {
        "sha": "80c7834a196db80e0919b76d9e896d8813a06b64",
        "filename": "src/qt/recentrequeststablemodel.h",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/recentrequeststablemodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/recentrequeststablemodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/recentrequeststablemodel.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -11,8 +11,6 @@\n #include <QStringList>\n #include <QDateTime>\n \n-class CWallet;\n-\n class RecentRequestEntry\n {\n public:\n@@ -60,7 +58,7 @@ class RecentRequestsTableModel: public QAbstractTableModel\n     Q_OBJECT\n \n public:\n-    explicit RecentRequestsTableModel(CWallet *wallet, WalletModel *parent);\n+    explicit RecentRequestsTableModel(WalletModel *parent);\n     ~RecentRequestsTableModel();\n \n     enum ColumnIndex {"
      },
      {
        "sha": "7924840d0b21c41d44dd1854de5a7ea02c31f4bd",
        "filename": "src/qt/rpcconsole.cpp",
        "status": "modified",
        "additions": 77,
        "deletions": 38,
        "changes": 115,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/rpcconsole.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/rpcconsole.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -12,7 +12,9 @@\n #include <qt/bantablemodel.h>\n #include <qt/clientmodel.h>\n #include <qt/platformstyle.h>\n+#include <qt/walletmodel.h>\n #include <chainparams.h>\n+#include <interfaces/node.h>\n #include <netbase.h>\n #include <rpc/server.h>\n #include <rpc/client.h>\n@@ -82,12 +84,17 @@ const QStringList historyFilter = QStringList()\n class RPCExecutor : public QObject\n {\n     Q_OBJECT\n+public:\n+    RPCExecutor(interfaces::Node& node) : m_node(node) {}\n \n public Q_SLOTS:\n-    void request(const QString &command);\n+    void request(const QString &command, const QString &walletID);\n \n Q_SIGNALS:\n     void reply(int category, const QString &command);\n+\n+private:\n+    interfaces::Node& m_node;\n };\n \n /** Class for handling RPC timers\n@@ -139,13 +146,14 @@ class QtRPCTimerInterface: public RPCTimerInterface\n  *   - Within double quotes, only escape \\c \" and backslashes before a \\c \" or another backslash\n  *   - Within single quotes, no escaping is possible and no special interpretation takes place\n  *\n+ * @param[in]    node    optional node to execute command on\n  * @param[out]   result      stringified Result from the executed command(chain)\n  * @param[in]    strCommand  Command line to split\n  * @param[in]    fExecute    set true if you want the command to be executed\n  * @param[out]   pstrFilteredOut  Command line, filtered to remove any sensitive data\n  */\n \n-bool RPCConsole::RPCParseCommandLine(std::string &strResult, const std::string &strCommand, const bool fExecute, std::string * const pstrFilteredOut)\n+bool RPCConsole::RPCParseCommandLine(interfaces::Node* node, std::string &strResult, const std::string &strCommand, const bool fExecute, std::string * const pstrFilteredOut, const std::string *walletID)\n {\n     std::vector< std::vector<std::string> > stack;\n     stack.push_back(std::vector<std::string>());\n@@ -299,18 +307,17 @@ bool RPCConsole::RPCParseCommandLine(std::string &strResult, const std::string &\n                         if (fExecute) {\n                             // Convert argument list to JSON objects in method-dependent way,\n                             // and pass it along with the method name to the dispatcher.\n-                            JSONRPCRequest req;\n-                            req.params = RPCConvertValues(stack.back()[0], std::vector<std::string>(stack.back().begin() + 1, stack.back().end()));\n-                            req.strMethod = stack.back()[0];\n+                            UniValue params = RPCConvertValues(stack.back()[0], std::vector<std::string>(stack.back().begin() + 1, stack.back().end()));\n+                            std::string method = stack.back()[0];\n+                            std::string uri;\n #ifdef ENABLE_WALLET\n-                            // TODO: Move this logic to WalletModel\n-                            if (!vpwallets.empty()) {\n-                                // in Qt, use always the wallet with index 0 when running with multiple wallets\n-                                QByteArray encodedName = QUrl::toPercentEncoding(QString::fromStdString(vpwallets[0]->GetName()));\n-                                req.URI = \"/wallet/\"+std::string(encodedName.constData(), encodedName.length());\n+                            if (walletID && !walletID->empty()) {\n+                                QByteArray encodedName = QUrl::toPercentEncoding(QString::fromStdString(*walletID));\n+                                uri = \"/wallet/\"+std::string(encodedName.constData(), encodedName.length());\n                             }\n #endif\n-                            lastResult = tableRPC.execute(req);\n+                            assert(node);\n+                            lastResult = node->executeRpc(method, params, uri);\n                         }\n \n                         state = STATE_COMMAND_EXECUTED;\n@@ -385,7 +392,7 @@ bool RPCConsole::RPCParseCommandLine(std::string &strResult, const std::string &\n     }\n }\n \n-void RPCExecutor::request(const QString &command)\n+void RPCExecutor::request(const QString &command, const QString &walletID)\n {\n     try\n     {\n@@ -416,7 +423,8 @@ void RPCExecutor::request(const QString &command)\n                 \"   example:    getblock(getblockhash(0),true)[tx][0]\\n\\n\")));\n             return;\n         }\n-        if(!RPCConsole::RPCExecuteCommandLine(result, executableCommand))\n+        std::string wallet_id = walletID.toStdString();\n+        if(!RPCConsole::RPCExecuteCommandLine(m_node, result, executableCommand, nullptr, &wallet_id))\n         {\n             Q_EMIT reply(RPCConsole::CMD_ERROR, QString(\"Parse error: unbalanced ' or \\\"\"));\n             return;\n@@ -443,15 +451,11 @@ void RPCExecutor::request(const QString &command)\n     }\n }\n \n-RPCConsole::RPCConsole(const PlatformStyle *_platformStyle, QWidget *parent) :\n+RPCConsole::RPCConsole(interfaces::Node& node, const PlatformStyle *_platformStyle, QWidget *parent) :\n     QWidget(parent),\n+    m_node(node),\n     ui(new Ui::RPCConsole),\n-    clientModel(0),\n-    historyPtr(0),\n-    platformStyle(_platformStyle),\n-    peersTableContextMenu(0),\n-    banTableContextMenu(0),\n-    consoleFontSize(0)\n+    platformStyle(_platformStyle)\n {\n     ui->setupUi(this);\n     QSettings settings;\n@@ -478,6 +482,10 @@ RPCConsole::RPCConsole(const PlatformStyle *_platformStyle, QWidget *parent) :\n     connect(ui->fontSmallerButton, SIGNAL(clicked()), this, SLOT(fontSmaller()));\n     connect(ui->btnClearTrafficGraph, SIGNAL(clicked()), ui->trafficGraph, SLOT(clear()));\n \n+    // disable the wallet selector by default\n+    ui->WalletSelector->setVisible(false);\n+    ui->WalletSelectorLabel->setVisible(false);\n+\n     // set library version labels\n #ifdef ENABLE_WALLET\n     ui->berkeleyDBVersion->setText(DbEnv::version(0, 0, 0));\n@@ -489,7 +497,7 @@ RPCConsole::RPCConsole(const PlatformStyle *_platformStyle, QWidget *parent) :\n     rpcTimerInterface = new QtRPCTimerInterface();\n     // avoid accidentally overwriting an existing, non QTThread\n     // based timer interface\n-    RPCSetTimerInterfaceIfUnset(rpcTimerInterface);\n+    m_node.rpcSetTimerInterfaceIfUnset(rpcTimerInterface);\n \n     setTrafficGraphRange(INITIAL_TRAFFIC_GRAPH_MINS);\n \n@@ -504,7 +512,7 @@ RPCConsole::~RPCConsole()\n {\n     QSettings settings;\n     settings.setValue(\"RPCConsoleWindowGeometry\", saveGeometry());\n-    RPCUnsetTimerInterface(rpcTimerInterface);\n+    m_node.rpcUnsetTimerInterface(rpcTimerInterface);\n     delete rpcTimerInterface;\n     delete ui;\n }\n@@ -562,13 +570,14 @@ void RPCConsole::setClientModel(ClientModel *model)\n         setNumConnections(model->getNumConnections());\n         connect(model, SIGNAL(numConnectionsChanged(int)), this, SLOT(setNumConnections(int)));\n \n-        setNumBlocks(model->getNumBlocks(), model->getLastBlockDate(), model->getVerificationProgress(nullptr), false);\n+        interfaces::Node& node = clientModel->node();\n+        setNumBlocks(node.getNumBlocks(), QDateTime::fromTime_t(node.getLastBlockTime()), node.getVerificationProgress(), false);\n         connect(model, SIGNAL(numBlocksChanged(int,QDateTime,double,bool)), this, SLOT(setNumBlocks(int,QDateTime,double,bool)));\n \n         updateNetworkState();\n         connect(model, SIGNAL(networkActiveChanged(bool)), this, SLOT(setNetworkActive(bool)));\n \n-        updateTrafficStats(model->getTotalBytesRecv(), model->getTotalBytesSent());\n+        updateTrafficStats(node.getTotalBytesRecv(), node.getTotalBytesSent());\n         connect(model, SIGNAL(bytesChanged(quint64,quint64)), this, SLOT(updateTrafficStats(quint64, quint64)));\n \n         connect(model, SIGNAL(mempoolSizeChanged(long,size_t)), this, SLOT(setMempoolSize(long,size_t)));\n@@ -663,7 +672,7 @@ void RPCConsole::setClientModel(ClientModel *model)\n \n         //Setup autocomplete and attach it\n         QStringList wordList;\n-        std::vector<std::string> commandList = tableRPC.listCommands();\n+        std::vector<std::string> commandList = m_node.listRpcCommands();\n         for (size_t i = 0; i < commandList.size(); ++i)\n         {\n             wordList << commandList[i].c_str();\n@@ -687,6 +696,23 @@ void RPCConsole::setClientModel(ClientModel *model)\n     }\n }\n \n+#ifdef ENABLE_WALLET\n+void RPCConsole::addWallet(WalletModel * const walletModel)\n+{\n+    const QString name = walletModel->getWalletName();\n+    // use name for text and internal data object (to allow to move to a wallet id later)\n+    ui->WalletSelector->addItem(name, name);\n+    if (ui->WalletSelector->count() == 2 && !isVisible()) {\n+        // First wallet added, set to default so long as the window isn't presently visible (and potentially in use)\n+        ui->WalletSelector->setCurrentIndex(1);\n+    }\n+    if (ui->WalletSelector->count() > 2) {\n+        ui->WalletSelector->setVisible(true);\n+        ui->WalletSelectorLabel->setVisible(true);\n+    }\n+}\n+#endif\n+\n static QString categoryClass(int category)\n {\n     switch(category)\n@@ -814,7 +840,7 @@ void RPCConsole::updateNetworkState()\n     connections += tr(\"In:\") + \" \" + QString::number(clientModel->getNumConnections(CONNECTIONS_IN)) + \" / \";\n     connections += tr(\"Out:\") + \" \" + QString::number(clientModel->getNumConnections(CONNECTIONS_OUT)) + \")\";\n \n-    if(!clientModel->getNetworkActive()) {\n+    if(!clientModel->node().getNetworkActive()) {\n         connections += \" (\" + tr(\"Network activity disabled\") + \")\";\n     }\n \n@@ -861,7 +887,7 @@ void RPCConsole::on_lineEdit_returnPressed()\n         std::string strFilteredCmd;\n         try {\n             std::string dummy;\n-            if (!RPCParseCommandLine(dummy, cmd.toStdString(), false, &strFilteredCmd)) {\n+            if (!RPCParseCommandLine(nullptr, dummy, cmd.toStdString(), false, &strFilteredCmd)) {\n                 // Failed to parse command, so we cannot even filter it for the history\n                 throw std::runtime_error(\"Invalid command line\");\n             }\n@@ -874,8 +900,25 @@ void RPCConsole::on_lineEdit_returnPressed()\n \n         cmdBeforeBrowsing = QString();\n \n+        QString walletID;\n+#ifdef ENABLE_WALLET\n+        const int wallet_index = ui->WalletSelector->currentIndex();\n+        if (wallet_index > 0) {\n+            walletID = (QString)ui->WalletSelector->itemData(wallet_index).value<QString>();\n+        }\n+\n+        if (m_last_wallet_id != walletID) {\n+            if (walletID.isEmpty()) {\n+                message(CMD_REQUEST, tr(\"Executing command without any wallet\"));\n+            } else {\n+                message(CMD_REQUEST, tr(\"Executing command using \\\"%1\\\" wallet\").arg(walletID));\n+            }\n+            m_last_wallet_id = walletID;\n+        }\n+#endif\n+\n         message(CMD_REQUEST, QString::fromStdString(strFilteredCmd));\n-        Q_EMIT cmdRequest(cmd);\n+        Q_EMIT cmdRequest(cmd, walletID);\n \n         cmd = QString::fromStdString(strFilteredCmd);\n \n@@ -917,13 +960,13 @@ void RPCConsole::browseHistory(int offset)\n \n void RPCConsole::startExecutor()\n {\n-    RPCExecutor *executor = new RPCExecutor();\n+    RPCExecutor *executor = new RPCExecutor(m_node);\n     executor->moveToThread(&thread);\n \n     // Replies from executor object must go to this object\n     connect(executor, SIGNAL(reply(int,QString)), this, SLOT(message(int,QString)));\n     // Requests from this object must go to executor\n-    connect(this, SIGNAL(cmdRequest(QString)), executor, SLOT(request(QString)));\n+    connect(this, SIGNAL(cmdRequest(QString, QString)), executor, SLOT(request(QString, QString)));\n \n     // On stopExecutor signal\n     // - quit the Qt event loop in the execution thread\n@@ -1143,24 +1186,21 @@ void RPCConsole::showBanTableContextMenu(const QPoint& point)\n \n void RPCConsole::disconnectSelectedNode()\n {\n-    if(!g_connman)\n-        return;\n-\n     // Get selected peer addresses\n     QList<QModelIndex> nodes = GUIUtil::getEntryData(ui->peerWidget, PeerTableModel::NetNodeId);\n     for(int i = 0; i < nodes.count(); i++)\n     {\n         // Get currently selected peer address\n         NodeId id = nodes.at(i).data().toLongLong();\n         // Find the node, disconnect it and clear the selected node\n-        if(g_connman->DisconnectNode(id))\n+        if(m_node.disconnect(id))\n             clearSelectedNode();\n     }\n }\n \n void RPCConsole::banSelectedNode(int bantime)\n {\n-    if (!clientModel || !g_connman)\n+    if (!clientModel)\n         return;\n \n     // Get selected peer addresses\n@@ -1178,7 +1218,7 @@ void RPCConsole::banSelectedNode(int bantime)\n \t// Find possible nodes, ban it and clear the selected node\n \tconst CNodeCombinedStats *stats = clientModel->getPeerTableModel()->getNodeStats(detailNodeRow);\n \tif(stats) {\n-\t    g_connman->Ban(stats->nodeStats.addr, BanReasonManuallyAdded, bantime);\n+            m_node.ban(stats->nodeStats.addr, BanReasonManuallyAdded, bantime);\n \t}\n     }\n     clearSelectedNode();\n@@ -1199,9 +1239,8 @@ void RPCConsole::unbanSelectedNode()\n         CSubNet possibleSubnet;\n \n         LookupSubNet(strNode.toStdString().c_str(), possibleSubnet);\n-        if (possibleSubnet.IsValid() && g_connman)\n+        if (possibleSubnet.IsValid() && m_node.unban(possibleSubnet))\n         {\n-            g_connman->Unban(possibleSubnet);\n             clientModel->getBanTableModel()->refresh();\n         }\n     }"
      },
      {
        "sha": "a53c4c24f912433eb096fefa8dbb25ec2780d6f4",
        "filename": "src/qt/rpcconsole.h",
        "status": "modified",
        "additions": 22,
        "deletions": 14,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/rpcconsole.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/rpcconsole.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -17,6 +17,11 @@\n class ClientModel;\n class PlatformStyle;\n class RPCTimerInterface;\n+class WalletModel;\n+\n+namespace interfaces {\n+    class Node;\n+}\n \n namespace Ui {\n     class RPCConsole;\n@@ -33,15 +38,16 @@ class RPCConsole: public QWidget\n     Q_OBJECT\n \n public:\n-    explicit RPCConsole(const PlatformStyle *platformStyle, QWidget *parent);\n+    explicit RPCConsole(interfaces::Node& node, const PlatformStyle *platformStyle, QWidget *parent);\n     ~RPCConsole();\n \n-    static bool RPCParseCommandLine(std::string &strResult, const std::string &strCommand, bool fExecute, std::string * const pstrFilteredOut = nullptr);\n-    static bool RPCExecuteCommandLine(std::string &strResult, const std::string &strCommand, std::string * const pstrFilteredOut = nullptr) {\n-        return RPCParseCommandLine(strResult, strCommand, true, pstrFilteredOut);\n+    static bool RPCParseCommandLine(interfaces::Node* node, std::string &strResult, const std::string &strCommand, bool fExecute, std::string * const pstrFilteredOut = nullptr, const std::string *walletID = nullptr);\n+    static bool RPCExecuteCommandLine(interfaces::Node& node, std::string &strResult, const std::string &strCommand, std::string * const pstrFilteredOut = nullptr, const std::string *walletID = nullptr) {\n+        return RPCParseCommandLine(&node, strResult, strCommand, true, pstrFilteredOut, walletID);\n     }\n \n     void setClientModel(ClientModel *model);\n+    void addWallet(WalletModel * const walletModel);\n \n     enum MessageClass {\n         MC_ERROR,\n@@ -120,7 +126,7 @@ public Q_SLOTS:\n Q_SIGNALS:\n     // For RPC command executor\n     void stopExecutor();\n-    void cmdRequest(const QString &command);\n+    void cmdRequest(const QString &command, const QString &walletID);\n \n private:\n     void startExecutor();\n@@ -138,19 +144,21 @@ public Q_SLOTS:\n \n     };\n \n-    Ui::RPCConsole *ui;\n-    ClientModel *clientModel;\n+    interfaces::Node& m_node;\n+    Ui::RPCConsole* const ui;\n+    ClientModel *clientModel = nullptr;\n     QStringList history;\n-    int historyPtr;\n+    int historyPtr = 0;\n     QString cmdBeforeBrowsing;\n     QList<NodeId> cachedNodeids;\n-    const PlatformStyle *platformStyle;\n-    RPCTimerInterface *rpcTimerInterface;\n-    QMenu *peersTableContextMenu;\n-    QMenu *banTableContextMenu;\n-    int consoleFontSize;\n-    QCompleter *autoCompleter;\n+    const PlatformStyle* const platformStyle;\n+    RPCTimerInterface *rpcTimerInterface = nullptr;\n+    QMenu *peersTableContextMenu = nullptr;\n+    QMenu *banTableContextMenu = nullptr;\n+    int consoleFontSize = 0;\n+    QCompleter *autoCompleter = nullptr;\n     QThread thread;\n+    QString m_last_wallet_id;\n \n     /** Update UI with latest network info from model. */\n     void updateNetworkState();"
      },
      {
        "sha": "261ab7a948e67e25782030d59aeacee61f0b028f",
        "filename": "src/qt/sendcoinsdialog.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 30,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/sendcoinsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/sendcoinsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsdialog.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -15,9 +15,9 @@\n #include <qt/sendcoinsentry.h>\n \n #include <chainparams.h>\n+#include <interfaces/node.h>\n #include <key_io.h>\n #include <wallet/coincontrol.h>\n-#include <validation.h> // mempool and minRelayTxFee\n #include <ui_interface.h>\n #include <txmempool.h>\n #include <policy/fees.h>\n@@ -114,7 +114,7 @@ SendCoinsDialog::SendCoinsDialog(const PlatformStyle *_platformStyle, QWidget *p\n     if (!settings.contains(\"nSmartFeeSliderPosition\"))\n         settings.setValue(\"nSmartFeeSliderPosition\", 0);\n     if (!settings.contains(\"nTransactionFee\"))\n-        settings.setValue(\"nTransactionFee\", (qint64)DEFAULT_TRANSACTION_FEE);\n+        settings.setValue(\"nTransactionFee\", (qint64)DEFAULT_PAY_TX_FEE);\n     if (!settings.contains(\"fPayOnlyMinFee\"))\n         settings.setValue(\"fPayOnlyMinFee\", false);\n     ui->groupFee->setId(ui->radioSmartFee, 0);\n@@ -149,9 +149,9 @@ void SendCoinsDialog::setModel(WalletModel *_model)\n             }\n         }\n \n-        setBalance(_model->getBalance(), _model->getUnconfirmedBalance(), _model->getImmatureBalance(),\n-                   _model->getWatchBalance(), _model->getWatchUnconfirmedBalance(), _model->getWatchImmatureBalance());\n-        connect(_model, SIGNAL(balanceChanged(CAmount,CAmount,CAmount,CAmount,CAmount,CAmount)), this, SLOT(setBalance(CAmount,CAmount,CAmount,CAmount,CAmount,CAmount)));\n+        interfaces::WalletBalances balances = _model->wallet().getBalances();\n+        setBalance(balances);\n+        connect(_model, SIGNAL(balanceChanged(interfaces::WalletBalances)), this, SLOT(setBalance(interfaces::WalletBalances)));\n         connect(_model->getOptionsModel(), SIGNAL(displayUnitChanged(int)), this, SLOT(updateDisplayUnit()));\n         updateDisplayUnit();\n \n@@ -175,7 +175,7 @@ void SendCoinsDialog::setModel(WalletModel *_model)\n         connect(ui->checkBoxMinimumFee, SIGNAL(stateChanged(int)), this, SLOT(coinControlUpdateLabels()));\n         connect(ui->optInRBF, SIGNAL(stateChanged(int)), this, SLOT(updateSmartFeeLabel()));\n         connect(ui->optInRBF, SIGNAL(stateChanged(int)), this, SLOT(coinControlUpdateLabels()));\n-        ui->customFee->setSingleStep(GetRequiredFee(1000));\n+        ui->customFee->setSingleStep(model->wallet().getRequiredFee(1000));\n         updateFeeSectionControls();\n         updateMinFeeLabel();\n         updateSmartFeeLabel();\n@@ -193,7 +193,7 @@ void SendCoinsDialog::setModel(WalletModel *_model)\n             settings.remove(\"nSmartFeeSliderPosition\");\n         }\n         if (settings.value(\"nConfTarget\").toInt() == 0)\n-            ui->confTargetSelector->setCurrentIndex(getIndexForConfTarget(model->getDefaultConfirmTarget()));\n+            ui->confTargetSelector->setCurrentIndex(getIndexForConfTarget(model->wallet().getConfirmTarget()));\n         else\n             ui->confTargetSelector->setCurrentIndex(getIndexForConfTarget(settings.value(\"nConfTarget\").toInt()));\n     }\n@@ -224,7 +224,7 @@ void SendCoinsDialog::on_sendButton_clicked()\n         SendCoinsEntry *entry = qobject_cast<SendCoinsEntry*>(ui->entries->itemAt(i)->widget());\n         if(entry)\n         {\n-            if(entry->validate())\n+            if(entry->validate(model->node()))\n             {\n                 recipients.append(entry->getValue());\n             }\n@@ -277,8 +277,11 @@ void SendCoinsDialog::on_sendButton_clicked()\n     QStringList formatted;\n     for (const SendCoinsRecipient &rcp : currentTransaction.getRecipients())\n     {\n-        // generate bold amount string\n+        // generate bold amount string with wallet name in case of multiwallet\n         QString amount = \"<b>\" + BitcoinUnits::formatHtmlWithUnit(model->getOptionsModel()->getDisplayUnit(), rcp.amount);\n+        if (model->isMultiwallet()) {\n+            amount.append(\" <u>\"+tr(\"from wallet %1\").arg(GUIUtil::HtmlEscape(model->getWalletName()))+\"</u> \");\n+        }\n         amount.append(\"</b>\");\n         // generate monospace address string\n         QString address = \"<span style='font-family: monospace;'>\" + rcp.address;\n@@ -369,7 +372,7 @@ void SendCoinsDialog::on_sendButton_clicked()\n         accept();\n         CoinControlDialog::coinControl()->UnSelectAll();\n         coinControlUpdateLabels();\n-        Q_EMIT coinsSent(currentTransaction.getTransaction()->GetHash());\n+        Q_EMIT coinsSent(currentTransaction.getWtx()->get().GetHash());\n     }\n     fNewRecipientAllowed = true;\n }\n@@ -512,24 +515,17 @@ bool SendCoinsDialog::handlePaymentRequest(const SendCoinsRecipient &rv)\n     return true;\n }\n \n-void SendCoinsDialog::setBalance(const CAmount& balance, const CAmount& unconfirmedBalance, const CAmount& immatureBalance,\n-                                 const CAmount& watchBalance, const CAmount& watchUnconfirmedBalance, const CAmount& watchImmatureBalance)\n+void SendCoinsDialog::setBalance(const interfaces::WalletBalances& balances)\n {\n-    Q_UNUSED(unconfirmedBalance);\n-    Q_UNUSED(immatureBalance);\n-    Q_UNUSED(watchBalance);\n-    Q_UNUSED(watchUnconfirmedBalance);\n-    Q_UNUSED(watchImmatureBalance);\n-\n     if(model && model->getOptionsModel())\n     {\n-        ui->labelBalance->setText(BitcoinUnits::formatWithUnit(model->getOptionsModel()->getDisplayUnit(), balance));\n+        ui->labelBalance->setText(BitcoinUnits::formatWithUnit(model->getOptionsModel()->getDisplayUnit(), balances.balance));\n     }\n }\n \n void SendCoinsDialog::updateDisplayUnit()\n {\n-    setBalance(model->getBalance(), 0, 0, 0, 0, 0);\n+    setBalance(model->wallet().getBalances());\n     ui->customFee->setDisplayUnit(model->getOptionsModel()->getDisplayUnit());\n     updateMinFeeLabel();\n     updateSmartFeeLabel();\n@@ -570,7 +566,7 @@ void SendCoinsDialog::processSendCoinsReturn(const WalletModel::SendCoinsReturn\n         msgParams.second = CClientUIInterface::MSG_ERROR;\n         break;\n     case WalletModel::AbsurdFee:\n-        msgParams.first = tr(\"A fee higher than %1 is considered an absurdly high fee.\").arg(BitcoinUnits::formatWithUnit(model->getOptionsModel()->getDisplayUnit(), maxTxFee));\n+        msgParams.first = tr(\"A fee higher than %1 is considered an absurdly high fee.\").arg(BitcoinUnits::formatWithUnit(model->getOptionsModel()->getDisplayUnit(), model->node().getMaxTxFee()));\n         break;\n     case WalletModel::PaymentRequestExpired:\n         msgParams.first = tr(\"Payment request expired.\");\n@@ -615,7 +611,7 @@ void SendCoinsDialog::useAvailableBalance(SendCoinsEntry* entry)\n     }\n \n     // Calculate available amount to send.\n-    CAmount amount = model->getBalance(&coin_control);\n+    CAmount amount = model->wallet().getAvailableBalance(coin_control);\n     for (int i = 0; i < ui->entries->count(); ++i) {\n         SendCoinsEntry* e = qobject_cast<SendCoinsEntry*>(ui->entries->itemAt(i)->widget());\n         if (e && !e->isHidden() && e != entry) {\n@@ -633,7 +629,7 @@ void SendCoinsDialog::useAvailableBalance(SendCoinsEntry* entry)\n \n void SendCoinsDialog::setMinimumFee()\n {\n-    ui->customFee->setValue(GetRequiredFee(1000));\n+    ui->customFee->setValue(model->wallet().getRequiredFee(1000));\n }\n \n void SendCoinsDialog::updateFeeSectionControls()\n@@ -665,7 +661,7 @@ void SendCoinsDialog::updateMinFeeLabel()\n {\n     if (model && model->getOptionsModel())\n         ui->checkBoxMinimumFee->setText(tr(\"Pay only the required fee of %1\").arg(\n-            BitcoinUnits::formatWithUnit(model->getOptionsModel()->getDisplayUnit(), GetRequiredFee(1000)) + \"/kB\")\n+            BitcoinUnits::formatWithUnit(model->getOptionsModel()->getDisplayUnit(), model->wallet().getRequiredFee(1000)) + \"/kB\")\n         );\n }\n \n@@ -679,7 +675,7 @@ void SendCoinsDialog::updateCoinControlState(CCoinControl& ctrl)\n     // Avoid using global defaults when sending money from the GUI\n     // Either custom fee will be used or if not selected, the confirmation target from dropdown box\n     ctrl.m_confirm_target = getConfTargetForIndex(ui->confTargetSelector->currentIndex());\n-    ctrl.signalRbf = ui->optInRBF->isChecked();\n+    ctrl.m_signal_bip125_rbf = ui->optInRBF->isChecked();\n }\n \n void SendCoinsDialog::updateSmartFeeLabel()\n@@ -689,12 +685,13 @@ void SendCoinsDialog::updateSmartFeeLabel()\n     CCoinControl coin_control;\n     updateCoinControlState(coin_control);\n     coin_control.m_feerate.reset(); // Explicitly use only fee estimation rate for smart fee labels\n-    FeeCalculation feeCalc;\n-    CFeeRate feeRate = CFeeRate(GetMinimumFee(1000, coin_control, ::mempool, ::feeEstimator, &feeCalc));\n+    int returned_target;\n+    FeeReason reason;\n+    CFeeRate feeRate = CFeeRate(model->wallet().getMinimumFee(1000, coin_control, &returned_target, &reason));\n \n     ui->labelSmartFee->setText(BitcoinUnits::formatWithUnit(model->getOptionsModel()->getDisplayUnit(), feeRate.GetFeePerK()) + \"/kB\");\n \n-    if (feeCalc.reason == FeeReason::FALLBACK) {\n+    if (reason == FeeReason::FALLBACK) {\n         ui->labelSmartFee2->show(); // (Smart fee not initialized yet. This usually takes a few blocks...)\n         ui->labelFeeEstimation->setText(\"\");\n         ui->fallbackFeeWarningLabel->setVisible(true);\n@@ -706,7 +703,7 @@ void SendCoinsDialog::updateSmartFeeLabel()\n     else\n     {\n         ui->labelSmartFee2->hide();\n-        ui->labelFeeEstimation->setText(tr(\"Estimated to begin confirmation within %n block(s).\", \"\", feeCalc.returnedTarget));\n+        ui->labelFeeEstimation->setText(tr(\"Estimated to begin confirmation within %n block(s).\", \"\", returned_target));\n         ui->fallbackFeeWarningLabel->setVisible(false);\n     }\n \n@@ -811,7 +808,7 @@ void SendCoinsDialog::coinControlChangeEdited(const QString& text)\n         }\n         else // Valid address\n         {\n-            if (!model->IsSpendable(dest)) {\n+            if (!model->wallet().isSpendable(dest)) {\n                 ui->labelCoinControlChangeLabel->setText(tr(\"Warning: Unknown change address\"));\n \n                 // confirmation dialog"
      },
      {
        "sha": "40a1d10c2bbd01874eb4be7dc01b7c207fc9641e",
        "filename": "src/qt/sendcoinsdialog.h",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/sendcoinsdialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/sendcoinsdialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsdialog.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -51,8 +51,7 @@ public Q_SLOTS:\n     void accept();\n     SendCoinsEntry *addEntry();\n     void updateTabsAndLabels();\n-    void setBalance(const CAmount& balance, const CAmount& unconfirmedBalance, const CAmount& immatureBalance,\n-                    const CAmount& watchOnlyBalance, const CAmount& watchUnconfBalance, const CAmount& watchImmatureBalance);\n+    void setBalance(const interfaces::WalletBalances& balances);\n \n Q_SIGNALS:\n     void coinsSent(const uint256& txid);"
      },
      {
        "sha": "977425f7e367168b2dc8a6c6da5fd0d763ec9895",
        "filename": "src/qt/sendcoinsentry.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/sendcoinsentry.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/sendcoinsentry.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsentry.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -127,7 +127,7 @@ void SendCoinsEntry::useAvailableBalanceClicked()\n     Q_EMIT useAvailableBalance(this);\n }\n \n-bool SendCoinsEntry::validate()\n+bool SendCoinsEntry::validate(interfaces::Node& node)\n {\n     if (!model)\n         return false;\n@@ -158,7 +158,7 @@ bool SendCoinsEntry::validate()\n     }\n \n     // Reject dust outputs:\n-    if (retval && GUIUtil::isDust(ui->payTo->text(), ui->payAmount->value())) {\n+    if (retval && GUIUtil::isDust(node, ui->payTo->text(), ui->payAmount->value())) {\n         ui->payAmount->setValid(false);\n         retval = false;\n     }"
      },
      {
        "sha": "76f96c61e087d4446669f9c7c9837ca2cd8030e9",
        "filename": "src/qt/sendcoinsentry.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/sendcoinsentry.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/sendcoinsentry.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsentry.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -30,7 +30,7 @@ class SendCoinsEntry : public QStackedWidget\n     ~SendCoinsEntry();\n \n     void setModel(WalletModel *model);\n-    bool validate();\n+    bool validate(interfaces::Node& node);\n     SendCoinsRecipient getValue();\n \n     /** Return whether the entry is still empty and unedited */"
      },
      {
        "sha": "94a3ad7987b713e902f56e992a92e3ab9fafc7fb",
        "filename": "src/qt/signverifymessagedialog.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/signverifymessagedialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/signverifymessagedialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/signverifymessagedialog.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -140,7 +140,7 @@ void SignVerifyMessageDialog::on_signMessageButton_SM_clicked()\n     }\n \n     CKey key;\n-    if (!model->getPrivKey(*keyID, key))\n+    if (!model->wallet().getPrivKey(*keyID, key))\n     {\n         ui->statusLabel_SM->setStyleSheet(\"QLabel { color: red; }\");\n         ui->statusLabel_SM->setText(tr(\"Private key for the entered address is not available.\"));"
      },
      {
        "sha": "4d972b431cf5ece4b4825dd685570c4fff4bac92",
        "filename": "src/qt/splashscreen.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 21,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/splashscreen.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/splashscreen.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/splashscreen.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -12,22 +12,21 @@\n \n #include <clientversion.h>\n #include <init.h>\n+#include <interfaces/handler.h>\n+#include <interfaces/node.h>\n+#include <interfaces/wallet.h>\n #include <util.h>\n #include <ui_interface.h>\n #include <version.h>\n \n-#ifdef ENABLE_WALLET\n-#include <wallet/wallet.h>\n-#endif\n-\n #include <QApplication>\n #include <QCloseEvent>\n #include <QDesktopWidget>\n #include <QPainter>\n #include <QRadialGradient>\n \n-SplashScreen::SplashScreen(Qt::WindowFlags f, const NetworkStyle *networkStyle) :\n-    QWidget(0, f), curAlignment(0)\n+SplashScreen::SplashScreen(interfaces::Node& node, Qt::WindowFlags f, const NetworkStyle *networkStyle) :\n+    QWidget(0, f), curAlignment(0), m_node(node)\n {\n     // set reference point, paddings\n     int paddingRight            = 50;\n@@ -143,7 +142,7 @@ bool SplashScreen::eventFilter(QObject * obj, QEvent * ev) {\n     if (ev->type() == QEvent::KeyPress) {\n         QKeyEvent *keyEvent = static_cast<QKeyEvent *>(ev);\n         if(keyEvent->text()[0] == 'q') {\n-            StartShutdown();\n+            m_node.startShutdown();\n         }\n     }\n     return QObject::eventFilter(obj, ev);\n@@ -177,35 +176,34 @@ static void ShowProgress(SplashScreen *splash, const std::string &title, int nPr\n                                 : _(\"press q to shutdown\")) +\n             strprintf(\"\\n%d\", nProgress) + \"%\");\n }\n-\n #ifdef ENABLE_WALLET\n-void SplashScreen::ConnectWallet(CWallet* wallet)\n+void SplashScreen::ConnectWallet(std::unique_ptr<interfaces::Wallet> wallet)\n {\n-    wallet->ShowProgress.connect(boost::bind(ShowProgress, this, _1, _2, false));\n-    connectedWallets.push_back(wallet);\n+    m_connected_wallet_handlers.emplace_back(wallet->handleShowProgress(boost::bind(ShowProgress, this, _1, _2, false)));\n+    m_connected_wallets.emplace_back(std::move(wallet));\n }\n #endif\n \n void SplashScreen::subscribeToCoreSignals()\n {\n     // Connect signals to client\n-    uiInterface.InitMessage.connect(boost::bind(InitMessage, this, _1));\n-    uiInterface.ShowProgress.connect(boost::bind(ShowProgress, this, _1, _2, _3));\n+    m_handler_init_message = m_node.handleInitMessage(boost::bind(InitMessage, this, _1));\n+    m_handler_show_progress = m_node.handleShowProgress(boost::bind(ShowProgress, this, _1, _2, _3));\n #ifdef ENABLE_WALLET\n-    uiInterface.LoadWallet.connect(boost::bind(&SplashScreen::ConnectWallet, this, _1));\n+    m_handler_load_wallet = m_node.handleLoadWallet([this](std::unique_ptr<interfaces::Wallet> wallet) { ConnectWallet(std::move(wallet)); });\n #endif\n }\n \n void SplashScreen::unsubscribeFromCoreSignals()\n {\n     // Disconnect signals from client\n-    uiInterface.InitMessage.disconnect(boost::bind(InitMessage, this, _1));\n-    uiInterface.ShowProgress.disconnect(boost::bind(ShowProgress, this, _1, _2, _3));\n-#ifdef ENABLE_WALLET\n-    for (CWallet* const & pwallet : connectedWallets) {\n-        pwallet->ShowProgress.disconnect(boost::bind(ShowProgress, this, _1, _2, false));\n+    m_handler_init_message->disconnect();\n+    m_handler_show_progress->disconnect();\n+    for (auto& handler : m_connected_wallet_handlers) {\n+        handler->disconnect();\n     }\n-#endif\n+    m_connected_wallet_handlers.clear();\n+    m_connected_wallets.clear();\n }\n \n void SplashScreen::showMessage(const QString &message, int alignment, const QColor &color)\n@@ -227,6 +225,6 @@ void SplashScreen::paintEvent(QPaintEvent *event)\n \n void SplashScreen::closeEvent(QCloseEvent *event)\n {\n-    StartShutdown(); // allows an \"emergency\" shutdown during startup\n+    m_node.startShutdown(); // allows an \"emergency\" shutdown during startup\n     event->ignore();\n }"
      },
      {
        "sha": "9ef19675d82788823cf67618604a5f066bdbc5e8",
        "filename": "src/qt/splashscreen.h",
        "status": "modified",
        "additions": 16,
        "deletions": 4,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/splashscreen.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/splashscreen.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/splashscreen.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -8,9 +8,16 @@\n #include <functional>\n #include <QSplashScreen>\n \n-class CWallet;\n+#include <memory>\n+\n class NetworkStyle;\n \n+namespace interfaces {\n+class Handler;\n+class Node;\n+class Wallet;\n+};\n+\n /** Class for the splashscreen with information of the running client.\n  *\n  * @note this is intentionally not a QSplashScreen. Bitcoin Core initialization\n@@ -22,7 +29,7 @@ class SplashScreen : public QWidget\n     Q_OBJECT\n \n public:\n-    explicit SplashScreen(Qt::WindowFlags f, const NetworkStyle *networkStyle);\n+    explicit SplashScreen(interfaces::Node& node, Qt::WindowFlags f, const NetworkStyle *networkStyle);\n     ~SplashScreen();\n \n protected:\n@@ -45,14 +52,19 @@ public Q_SLOTS:\n     /** Disconnect core signals to splash screen */\n     void unsubscribeFromCoreSignals();\n     /** Connect wallet signals to splash screen */\n-    void ConnectWallet(CWallet*);\n+    void ConnectWallet(std::unique_ptr<interfaces::Wallet> wallet);\n \n     QPixmap pixmap;\n     QString curMessage;\n     QColor curColor;\n     int curAlignment;\n \n-    QList<CWallet*> connectedWallets;\n+    interfaces::Node& m_node;\n+    std::unique_ptr<interfaces::Handler> m_handler_init_message;\n+    std::unique_ptr<interfaces::Handler> m_handler_show_progress;\n+    std::unique_ptr<interfaces::Handler> m_handler_load_wallet;\n+    std::list<std::unique_ptr<interfaces::Wallet>> m_connected_wallets;\n+    std::list<std::unique_ptr<interfaces::Handler>> m_connected_wallet_handlers;\n };\n \n #endif // BITCOIN_QT_SPLASHSCREEN_H"
      },
      {
        "sha": "0c2e7ae71dd6b0b8044e968ad3a55804689db753",
        "filename": "src/qt/test/addressbooktests.cpp",
        "status": "added",
        "additions": 143,
        "deletions": 0,
        "changes": 143,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/test/addressbooktests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/test/addressbooktests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/addressbooktests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -0,0 +1,143 @@\n+#include <qt/test/addressbooktests.h>\n+#include <qt/test/util.h>\n+#include <test/test_bitcoin.h>\n+\n+#include <interfaces/node.h>\n+#include <qt/addressbookpage.h>\n+#include <qt/addresstablemodel.h>\n+#include <qt/editaddressdialog.h>\n+#include <qt/callback.h>\n+#include <qt/optionsmodel.h>\n+#include <qt/platformstyle.h>\n+#include <qt/qvalidatedlineedit.h>\n+#include <qt/walletmodel.h>\n+\n+#include <key.h>\n+#include <pubkey.h>\n+#include <key_io.h>\n+#include <wallet/wallet.h>\n+\n+#include <QTimer>\n+#include <QMessageBox>\n+\n+namespace\n+{\n+\n+/**\n+ * Fill the edit address dialog box with data, submit it, and ensure that\n+ * the resulting message meets expectations.\n+ */\n+void EditAddressAndSubmit(\n+        EditAddressDialog* dialog,\n+        const QString& label, const QString& address, QString expected_msg)\n+{\n+    QString warning_text;\n+\n+    dialog->findChild<QLineEdit*>(\"labelEdit\")->setText(label);\n+    dialog->findChild<QValidatedLineEdit*>(\"addressEdit\")->setText(address);\n+\n+    ConfirmMessage(&warning_text, 5);\n+    dialog->accept();\n+    QCOMPARE(warning_text, expected_msg);\n+}\n+\n+/**\n+ * Test adding various send addresses to the address book.\n+ *\n+ * There are three cases tested:\n+ *\n+ *   - new_address: a new address which should add as a send address successfully.\n+ *   - existing_s_address: an existing sending address which won't add successfully.\n+ *   - existing_r_address: an existing receiving address which won't add successfully.\n+ *\n+ * In each case, verify the resulting state of the address book and optionally\n+ * the warning message presented to the user.\n+ */\n+void TestAddAddressesToSendBook()\n+{\n+    TestChain100Setup test;\n+    CWallet wallet(\"mock\", WalletDatabase::CreateMock());\n+    bool firstRun;\n+    wallet.LoadWallet(firstRun);\n+\n+    auto build_address = [&wallet]() {\n+        CKey key;\n+        key.MakeNewKey(true);\n+        CTxDestination dest(GetDestinationForKey(\n+            key.GetPubKey(), wallet.m_default_address_type));\n+\n+        return std::make_pair(dest, QString::fromStdString(EncodeDestination(dest)));\n+    };\n+\n+    CTxDestination r_key_dest, s_key_dest;\n+\n+    // Add a preexisting \"receive\" entry in the address book.\n+    QString preexisting_r_address;\n+    QString r_label(\"already here (r)\");\n+\n+    // Add a preexisting \"send\" entry in the address book.\n+    QString preexisting_s_address;\n+    QString s_label(\"already here (s)\");\n+\n+    // Define a new address (which should add to the address book successfully).\n+    QString new_address;\n+\n+    std::tie(r_key_dest, preexisting_r_address) = build_address();\n+    std::tie(s_key_dest, preexisting_s_address) = build_address();\n+    std::tie(std::ignore, new_address) = build_address();\n+\n+    {\n+        LOCK(wallet.cs_wallet);\n+        wallet.SetAddressBook(r_key_dest, r_label.toStdString(), \"receive\");\n+        wallet.SetAddressBook(s_key_dest, s_label.toStdString(), \"send\");\n+    }\n+\n+    auto check_addbook_size = [&wallet](int expected_size) {\n+        QCOMPARE(static_cast<int>(wallet.mapAddressBook.size()), expected_size);\n+    };\n+\n+    // We should start with the two addresses we added earlier and nothing else.\n+    check_addbook_size(2);\n+\n+    // Initialize relevant QT models.\n+    std::unique_ptr<const PlatformStyle> platformStyle(PlatformStyle::instantiate(\"other\"));\n+    auto node = interfaces::MakeNode();\n+    OptionsModel optionsModel(*node);\n+    AddWallet(&wallet);\n+    WalletModel walletModel(std::move(node->getWallets()[0]), *node, platformStyle.get(), &optionsModel);\n+    RemoveWallet(&wallet);\n+    EditAddressDialog editAddressDialog(EditAddressDialog::NewSendingAddress);\n+    editAddressDialog.setModel(walletModel.getAddressTableModel());\n+\n+    EditAddressAndSubmit(\n+        &editAddressDialog, QString(\"uhoh\"), preexisting_r_address,\n+        QString(\n+            \"Address \\\"%1\\\" already exists as a receiving address with label \"\n+            \"\\\"%2\\\" and so cannot be added as a sending address.\"\n+            ).arg(preexisting_r_address).arg(r_label));\n+\n+    check_addbook_size(2);\n+\n+    EditAddressAndSubmit(\n+        &editAddressDialog, QString(\"uhoh, different\"), preexisting_s_address,\n+        QString(\n+            \"The entered address \\\"%1\\\" is already in the address book with \"\n+            \"label \\\"%2\\\".\"\n+            ).arg(preexisting_s_address).arg(s_label));\n+\n+    check_addbook_size(2);\n+\n+    // Submit a new address which should add successfully - we expect the\n+    // warning message to be blank.\n+    EditAddressAndSubmit(\n+        &editAddressDialog, QString(\"new\"), new_address, QString(\"\"));\n+\n+    check_addbook_size(3);\n+}\n+\n+} // namespace\n+\n+void AddressBookTests::addressBookTests()\n+{\n+    TestAddAddressesToSendBook();\n+}"
      },
      {
        "sha": "beeb9e76a980f3473cd5378b5f1934ff23d5749a",
        "filename": "src/qt/test/addressbooktests.h",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/test/addressbooktests.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/test/addressbooktests.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/addressbooktests.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -0,0 +1,15 @@\n+#ifndef BITCOIN_QT_TEST_ADDRESSBOOKTESTS_H\n+#define BITCOIN_QT_TEST_ADDRESSBOOKTESTS_H\n+\n+#include <QObject>\n+#include <QTest>\n+\n+class AddressBookTests : public QObject\n+{\n+    Q_OBJECT\n+\n+private Q_SLOTS:\n+    void addressBookTests();\n+};\n+\n+#endif // BITCOIN_QT_TEST_ADDRESSBOOKTESTS_H"
      },
      {
        "sha": "8e5a259f68ea9a45ee4ade5335cafa79cd7c1923",
        "filename": "src/qt/test/paymentrequestdata.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/test/paymentrequestdata.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/test/paymentrequestdata.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/paymentrequestdata.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -2,6 +2,9 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#ifndef BITCOIN_QT_TEST_PAYMENTREQUESTDATA_H\n+#define BITCOIN_QT_TEST_PAYMENTREQUESTDATA_H\n+\n //\n // Data for paymentservertests.cpp\n //\n@@ -458,3 +461,5 @@ iEBFUrBDJZU+UEezGwr7/zoECjo5ZY3PmtZcM2sILNjyweJF6XVzGqTxUw6pN6sW\\\n XR2T3Gy2LzRvhVA25QgGqpz0/juS2BtmNbsZPkN9gMMwKimgzc+PuCzmEKwPK9cQ\\\n YQ==\\\n \";\n+\n+#endif // BITCOIN_QT_TEST_PAYMENTREQUESTDATA_H"
      },
      {
        "sha": "83484b5ce700a2dc6ae96224912a5c4e7df9b444",
        "filename": "src/qt/test/paymentservertests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/test/paymentservertests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/test/paymentservertests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/paymentservertests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -9,6 +9,7 @@\n \n #include <amount.h>\n #include <chainparams.h>\n+#include <interfaces/node.h>\n #include <random.h>\n #include <script/script.h>\n #include <script/standard.h>\n@@ -66,7 +67,8 @@ static SendCoinsRecipient handleRequest(PaymentServer* server, std::vector<unsig\n void PaymentServerTests::paymentServerTests()\n {\n     SelectParams(CBaseChainParams::MAIN);\n-    OptionsModel optionsModel;\n+    auto node = interfaces::MakeNode();\n+    OptionsModel optionsModel(*node);\n     PaymentServer* server = new PaymentServer(nullptr, false);\n     X509_STORE* caStore = X509_STORE_new();\n     X509_STORE_add_cert(caStore, parse_b64der_cert(caCert1_BASE64));\n@@ -145,7 +147,7 @@ void PaymentServerTests::paymentServerTests()\n     // Ensure the request is initialized, because network \"main\" is default, even for\n     // uninitialized payment requests and that will fail our test here.\n     QVERIFY(r.paymentRequest.IsInitialized());\n-    QCOMPARE(PaymentServer::verifyNetwork(r.paymentRequest.getDetails()), false);\n+    QCOMPARE(PaymentServer::verifyNetwork(*node, r.paymentRequest.getDetails()), false);\n \n     // Expired payment request (expires is set to 1 = 1970-01-01 00:00:01):\n     data = DecodeBase64(paymentrequest2_cert2_BASE64);"
      },
      {
        "sha": "974e7831c45e4c0c47d711e0f9ae5b1d44a61a97",
        "filename": "src/qt/test/rpcnestedtests.cpp",
        "status": "modified",
        "additions": 43,
        "deletions": 41,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/test/rpcnestedtests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/test/rpcnestedtests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/rpcnestedtests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -7,6 +7,7 @@\n #include <chainparams.h>\n #include <consensus/validation.h>\n #include <fs.h>\n+#include <interfaces/node.h>\n #include <validation.h>\n #include <rpc/register.h>\n #include <rpc/server.h>\n@@ -45,89 +46,90 @@ void RPCNestedTests::rpcNestedTests()\n     std::string result;\n     std::string result2;\n     std::string filtered;\n-    RPCConsole::RPCExecuteCommandLine(result, \"getblockchaininfo()[chain]\", &filtered); //simple result filtering with path\n+    auto node = interfaces::MakeNode();\n+    RPCConsole::RPCExecuteCommandLine(*node, result, \"getblockchaininfo()[chain]\", &filtered); //simple result filtering with path\n     QVERIFY(result==\"main\");\n     QVERIFY(filtered == \"getblockchaininfo()[chain]\");\n \n-    RPCConsole::RPCExecuteCommandLine(result, \"getblock(getbestblockhash())\"); //simple 2 level nesting\n-    RPCConsole::RPCExecuteCommandLine(result, \"getblock(getblock(getbestblockhash())[hash], true)\");\n+    RPCConsole::RPCExecuteCommandLine(*node, result, \"getblock(getbestblockhash())\"); //simple 2 level nesting\n+    RPCConsole::RPCExecuteCommandLine(*node, result, \"getblock(getblock(getbestblockhash())[hash], true)\");\n \n-    RPCConsole::RPCExecuteCommandLine(result, \"getblock( getblock( getblock(getbestblockhash())[hash] )[hash], true)\"); //4 level nesting with whitespace, filtering path and boolean parameter\n+    RPCConsole::RPCExecuteCommandLine(*node, result, \"getblock( getblock( getblock(getbestblockhash())[hash] )[hash], true)\"); //4 level nesting with whitespace, filtering path and boolean parameter\n \n-    RPCConsole::RPCExecuteCommandLine(result, \"getblockchaininfo\");\n+    RPCConsole::RPCExecuteCommandLine(*node, result, \"getblockchaininfo\");\n     QVERIFY(result.substr(0,1) == \"{\");\n \n-    RPCConsole::RPCExecuteCommandLine(result, \"getblockchaininfo()\");\n+    RPCConsole::RPCExecuteCommandLine(*node, result, \"getblockchaininfo()\");\n     QVERIFY(result.substr(0,1) == \"{\");\n \n-    RPCConsole::RPCExecuteCommandLine(result, \"getblockchaininfo \"); //whitespace at the end will be tolerated\n+    RPCConsole::RPCExecuteCommandLine(*node, result, \"getblockchaininfo \"); //whitespace at the end will be tolerated\n     QVERIFY(result.substr(0,1) == \"{\");\n \n-    (RPCConsole::RPCExecuteCommandLine(result, \"getblockchaininfo()[\\\"chain\\\"]\")); //Quote path identifier are allowed, but look after a child containing the quotes in the key\n+    (RPCConsole::RPCExecuteCommandLine(*node, result, \"getblockchaininfo()[\\\"chain\\\"]\")); //Quote path identifier are allowed, but look after a child containing the quotes in the key\n     QVERIFY(result == \"null\");\n \n-    (RPCConsole::RPCExecuteCommandLine(result, \"createrawtransaction [] {} 0\")); //parameter not in brackets are allowed\n-    (RPCConsole::RPCExecuteCommandLine(result2, \"createrawtransaction([],{},0)\")); //parameter in brackets are allowed\n+    (RPCConsole::RPCExecuteCommandLine(*node, result, \"createrawtransaction [] {} 0\")); //parameter not in brackets are allowed\n+    (RPCConsole::RPCExecuteCommandLine(*node, result2, \"createrawtransaction([],{},0)\")); //parameter in brackets are allowed\n     QVERIFY(result == result2);\n-    (RPCConsole::RPCExecuteCommandLine(result2, \"createrawtransaction( [],  {} , 0   )\")); //whitespace between parameters is allowed\n+    (RPCConsole::RPCExecuteCommandLine(*node, result2, \"createrawtransaction( [],  {} , 0   )\")); //whitespace between parameters is allowed\n     QVERIFY(result == result2);\n \n-    RPCConsole::RPCExecuteCommandLine(result, \"getblock(getbestblockhash())[tx][0]\", &filtered);\n+    RPCConsole::RPCExecuteCommandLine(*node, result, \"getblock(getbestblockhash())[tx][0]\", &filtered);\n     QVERIFY(result == \"4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b\");\n     QVERIFY(filtered == \"getblock(getbestblockhash())[tx][0]\");\n \n-    RPCConsole::RPCParseCommandLine(result, \"importprivkey\", false, &filtered);\n+    RPCConsole::RPCParseCommandLine(nullptr, result, \"importprivkey\", false, &filtered);\n     QVERIFY(filtered == \"importprivkey(\u2026)\");\n-    RPCConsole::RPCParseCommandLine(result, \"signmessagewithprivkey abc\", false, &filtered);\n+    RPCConsole::RPCParseCommandLine(nullptr, result, \"signmessagewithprivkey abc\", false, &filtered);\n     QVERIFY(filtered == \"signmessagewithprivkey(\u2026)\");\n-    RPCConsole::RPCParseCommandLine(result, \"signmessagewithprivkey abc,def\", false, &filtered);\n+    RPCConsole::RPCParseCommandLine(nullptr, result, \"signmessagewithprivkey abc,def\", false, &filtered);\n     QVERIFY(filtered == \"signmessagewithprivkey(\u2026)\");\n-    RPCConsole::RPCParseCommandLine(result, \"signrawtransactionwithkey(abc)\", false, &filtered);\n+    RPCConsole::RPCParseCommandLine(nullptr, result, \"signrawtransactionwithkey(abc)\", false, &filtered);\n     QVERIFY(filtered == \"signrawtransactionwithkey(\u2026)\");\n-    RPCConsole::RPCParseCommandLine(result, \"walletpassphrase(help())\", false, &filtered);\n+    RPCConsole::RPCParseCommandLine(nullptr, result, \"walletpassphrase(help())\", false, &filtered);\n     QVERIFY(filtered == \"walletpassphrase(\u2026)\");\n-    RPCConsole::RPCParseCommandLine(result, \"walletpassphrasechange(help(walletpassphrasechange(abc)))\", false, &filtered);\n+    RPCConsole::RPCParseCommandLine(nullptr, result, \"walletpassphrasechange(help(walletpassphrasechange(abc)))\", false, &filtered);\n     QVERIFY(filtered == \"walletpassphrasechange(\u2026)\");\n-    RPCConsole::RPCParseCommandLine(result, \"help(encryptwallet(abc, def))\", false, &filtered);\n+    RPCConsole::RPCParseCommandLine(nullptr, result, \"help(encryptwallet(abc, def))\", false, &filtered);\n     QVERIFY(filtered == \"help(encryptwallet(\u2026))\");\n-    RPCConsole::RPCParseCommandLine(result, \"help(importprivkey())\", false, &filtered);\n+    RPCConsole::RPCParseCommandLine(nullptr, result, \"help(importprivkey())\", false, &filtered);\n     QVERIFY(filtered == \"help(importprivkey(\u2026))\");\n-    RPCConsole::RPCParseCommandLine(result, \"help(importprivkey(help()))\", false, &filtered);\n+    RPCConsole::RPCParseCommandLine(nullptr, result, \"help(importprivkey(help()))\", false, &filtered);\n     QVERIFY(filtered == \"help(importprivkey(\u2026))\");\n-    RPCConsole::RPCParseCommandLine(result, \"help(importprivkey(abc), walletpassphrase(def))\", false, &filtered);\n+    RPCConsole::RPCParseCommandLine(nullptr, result, \"help(importprivkey(abc), walletpassphrase(def))\", false, &filtered);\n     QVERIFY(filtered == \"help(importprivkey(\u2026), walletpassphrase(\u2026))\");\n \n-    RPCConsole::RPCExecuteCommandLine(result, \"rpcNestedTest\");\n+    RPCConsole::RPCExecuteCommandLine(*node, result, \"rpcNestedTest\");\n     QVERIFY(result == \"[]\");\n-    RPCConsole::RPCExecuteCommandLine(result, \"rpcNestedTest ''\");\n+    RPCConsole::RPCExecuteCommandLine(*node, result, \"rpcNestedTest ''\");\n     QVERIFY(result == \"[\\\"\\\"]\");\n-    RPCConsole::RPCExecuteCommandLine(result, \"rpcNestedTest \\\"\\\"\");\n+    RPCConsole::RPCExecuteCommandLine(*node, result, \"rpcNestedTest \\\"\\\"\");\n     QVERIFY(result == \"[\\\"\\\"]\");\n-    RPCConsole::RPCExecuteCommandLine(result, \"rpcNestedTest '' abc\");\n+    RPCConsole::RPCExecuteCommandLine(*node, result, \"rpcNestedTest '' abc\");\n     QVERIFY(result == \"[\\\"\\\",\\\"abc\\\"]\");\n-    RPCConsole::RPCExecuteCommandLine(result, \"rpcNestedTest abc '' abc\");\n+    RPCConsole::RPCExecuteCommandLine(*node, result, \"rpcNestedTest abc '' abc\");\n     QVERIFY(result == \"[\\\"abc\\\",\\\"\\\",\\\"abc\\\"]\");\n-    RPCConsole::RPCExecuteCommandLine(result, \"rpcNestedTest abc  abc\");\n+    RPCConsole::RPCExecuteCommandLine(*node, result, \"rpcNestedTest abc  abc\");\n     QVERIFY(result == \"[\\\"abc\\\",\\\"abc\\\"]\");\n-    RPCConsole::RPCExecuteCommandLine(result, \"rpcNestedTest abc\\t\\tabc\");\n+    RPCConsole::RPCExecuteCommandLine(*node, result, \"rpcNestedTest abc\\t\\tabc\");\n     QVERIFY(result == \"[\\\"abc\\\",\\\"abc\\\"]\");\n-    RPCConsole::RPCExecuteCommandLine(result, \"rpcNestedTest(abc )\");\n+    RPCConsole::RPCExecuteCommandLine(*node, result, \"rpcNestedTest(abc )\");\n     QVERIFY(result == \"[\\\"abc\\\"]\");\n-    RPCConsole::RPCExecuteCommandLine(result, \"rpcNestedTest( abc )\");\n+    RPCConsole::RPCExecuteCommandLine(*node, result, \"rpcNestedTest( abc )\");\n     QVERIFY(result == \"[\\\"abc\\\"]\");\n-    RPCConsole::RPCExecuteCommandLine(result, \"rpcNestedTest(   abc   ,   cba )\");\n+    RPCConsole::RPCExecuteCommandLine(*node, result, \"rpcNestedTest(   abc   ,   cba )\");\n     QVERIFY(result == \"[\\\"abc\\\",\\\"cba\\\"]\");\n \n #if QT_VERSION >= 0x050300\n     // do the QVERIFY_EXCEPTION_THROWN checks only with Qt5.3 and higher (QVERIFY_EXCEPTION_THROWN was introduced in Qt5.3)\n-    QVERIFY_EXCEPTION_THROWN(RPCConsole::RPCExecuteCommandLine(result, \"getblockchaininfo() .\\n\"), std::runtime_error); //invalid syntax\n-    QVERIFY_EXCEPTION_THROWN(RPCConsole::RPCExecuteCommandLine(result, \"getblockchaininfo() getblockchaininfo()\"), std::runtime_error); //invalid syntax\n-    (RPCConsole::RPCExecuteCommandLine(result, \"getblockchaininfo(\")); //tolerate non closing brackets if we have no arguments\n-    (RPCConsole::RPCExecuteCommandLine(result, \"getblockchaininfo()()()\")); //tolerate non command brackts\n-    QVERIFY_EXCEPTION_THROWN(RPCConsole::RPCExecuteCommandLine(result, \"getblockchaininfo(True)\"), UniValue); //invalid argument\n-    QVERIFY_EXCEPTION_THROWN(RPCConsole::RPCExecuteCommandLine(result, \"a(getblockchaininfo(True))\"), UniValue); //method not found\n-    QVERIFY_EXCEPTION_THROWN(RPCConsole::RPCExecuteCommandLine(result, \"rpcNestedTest abc,,abc\"), std::runtime_error); //don't tollerate empty arguments when using ,\n-    QVERIFY_EXCEPTION_THROWN(RPCConsole::RPCExecuteCommandLine(result, \"rpcNestedTest(abc,,abc)\"), std::runtime_error); //don't tollerate empty arguments when using ,\n-    QVERIFY_EXCEPTION_THROWN(RPCConsole::RPCExecuteCommandLine(result, \"rpcNestedTest(abc,,)\"), std::runtime_error); //don't tollerate empty arguments when using ,\n+    QVERIFY_EXCEPTION_THROWN(RPCConsole::RPCExecuteCommandLine(*node, result, \"getblockchaininfo() .\\n\"), std::runtime_error); //invalid syntax\n+    QVERIFY_EXCEPTION_THROWN(RPCConsole::RPCExecuteCommandLine(*node, result, \"getblockchaininfo() getblockchaininfo()\"), std::runtime_error); //invalid syntax\n+    (RPCConsole::RPCExecuteCommandLine(*node, result, \"getblockchaininfo(\")); //tolerate non closing brackets if we have no arguments\n+    (RPCConsole::RPCExecuteCommandLine(*node, result, \"getblockchaininfo()()()\")); //tolerate non command brackts\n+    QVERIFY_EXCEPTION_THROWN(RPCConsole::RPCExecuteCommandLine(*node, result, \"getblockchaininfo(True)\"), UniValue); //invalid argument\n+    QVERIFY_EXCEPTION_THROWN(RPCConsole::RPCExecuteCommandLine(*node, result, \"a(getblockchaininfo(True))\"), UniValue); //method not found\n+    QVERIFY_EXCEPTION_THROWN(RPCConsole::RPCExecuteCommandLine(*node, result, \"rpcNestedTest abc,,abc\"), std::runtime_error); //don't tollerate empty arguments when using ,\n+    QVERIFY_EXCEPTION_THROWN(RPCConsole::RPCExecuteCommandLine(*node, result, \"rpcNestedTest(abc,,abc)\"), std::runtime_error); //don't tollerate empty arguments when using ,\n+    QVERIFY_EXCEPTION_THROWN(RPCConsole::RPCExecuteCommandLine(*node, result, \"rpcNestedTest(abc,,)\"), std::runtime_error); //don't tollerate empty arguments when using ,\n #endif\n }"
      },
      {
        "sha": "7b3b38f62e3914c1d2b7c13c3dc7229e9f560b10",
        "filename": "src/qt/test/rpcnestedtests.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/test/rpcnestedtests.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/test/rpcnestedtests.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/rpcnestedtests.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -2,8 +2,8 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#ifndef BITCOIN_QT_TEST_RPC_NESTED_TESTS_H\n-#define BITCOIN_QT_TEST_RPC_NESTED_TESTS_H\n+#ifndef BITCOIN_QT_TEST_RPCNESTEDTESTS_H\n+#define BITCOIN_QT_TEST_RPCNESTEDTESTS_H\n \n #include <QObject>\n #include <QTest>\n@@ -19,4 +19,4 @@ class RPCNestedTests : public QObject\n     void rpcNestedTests();\n };\n \n-#endif // BITCOIN_QT_TEST_RPC_NESTED_TESTS_H\n+#endif // BITCOIN_QT_TEST_RPCNESTEDTESTS_H"
      },
      {
        "sha": "56d4d3e4577cd2e3816ef84c82bd97adc2194184",
        "filename": "src/qt/test/test_main.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/test/test_main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/test/test_main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/test_main.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -13,6 +13,7 @@\n #include <qt/test/compattests.h>\n \n #ifdef ENABLE_WALLET\n+#include <qt/test/addressbooktests.h>\n #include <qt/test/paymentservertests.h>\n #include <qt/test/wallettests.h>\n #endif\n@@ -99,6 +100,10 @@ int main(int argc, char *argv[])\n     if (QTest::qExec(&test5) != 0) {\n         fInvalid = true;\n     }\n+    AddressBookTests test6;\n+    if (QTest::qExec(&test6) != 0) {\n+        fInvalid = true;\n+    }\n #endif\n \n     fs::remove_all(pathTemp);"
      },
      {
        "sha": "261caaaee5334faf6f651de53afd2a5430ce84c6",
        "filename": "src/qt/test/util.cpp",
        "status": "added",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/test/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/test/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/util.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -0,0 +1,22 @@\n+#include <qt/callback.h>\n+\n+#include <QApplication>\n+#include <QMessageBox>\n+#include <QTimer>\n+#include <QString>\n+#include <QPushButton>\n+#include <QWidget>\n+\n+void ConfirmMessage(QString* text, int msec)\n+{\n+    QTimer::singleShot(msec, makeCallback([text](Callback* callback) {\n+        for (QWidget* widget : QApplication::topLevelWidgets()) {\n+            if (widget->inherits(\"QMessageBox\")) {\n+                QMessageBox* messageBox = qobject_cast<QMessageBox*>(widget);\n+                if (text) *text = messageBox->text();\n+                messageBox->defaultButton()->click();\n+            }\n+        }\n+        delete callback;\n+    }), SLOT(call()));\n+}"
      },
      {
        "sha": "324386c139ae821287ea422cbaed747683ace1eb",
        "filename": "src/qt/test/util.h",
        "status": "added",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/test/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/test/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/util.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -0,0 +1,12 @@\n+#ifndef BITCOIN_QT_TEST_UTIL_H\n+#define BITCOIN_QT_TEST_UTIL_H\n+\n+/**\n+ * Press \"Ok\" button in message box dialog.\n+ *\n+ * @param text - Optionally store dialog text.\n+ * @param msec - Number of miliseconds to pause before triggering the callback.\n+ */\n+void ConfirmMessage(QString* text = nullptr, int msec = 0);\n+\n+#endif // BITCOIN_QT_TEST_UTIL_H"
      },
      {
        "sha": "a09d98dfe558251a8eb9e0b4fc5a979807470282",
        "filename": "src/qt/test/wallettests.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 20,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/test/wallettests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/test/wallettests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/wallettests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -1,5 +1,7 @@\n #include <qt/test/wallettests.h>\n+#include <qt/test/util.h>\n \n+#include <interfaces/node.h>\n #include <qt/bitcoinamountfield.h>\n #include <qt/callback.h>\n #include <qt/optionsmodel.h>\n@@ -19,6 +21,8 @@\n #include <qt/recentrequeststablemodel.h>\n #include <qt/receiverequestdialog.h>\n \n+#include <memory>\n+\n #include <QAbstractButton>\n #include <QAction>\n #include <QApplication>\n@@ -32,21 +36,6 @@\n \n namespace\n {\n-//! Press \"Ok\" button in message box dialog.\n-void ConfirmMessage(QString* text = nullptr)\n-{\n-    QTimer::singleShot(0, makeCallback([text](Callback* callback) {\n-        for (QWidget* widget : QApplication::topLevelWidgets()) {\n-            if (widget->inherits(\"QMessageBox\")) {\n-                QMessageBox* messageBox = qobject_cast<QMessageBox*>(widget);\n-                if (text) *text = messageBox->text();\n-                messageBox->defaultButton()->click();\n-            }\n-        }\n-        delete callback;\n-    }), SLOT(call()));\n-}\n-\n //! Press \"Yes\" or \"Cancel\" buttons in modal send confirmation dialog.\n void ConfirmSend(QString* text = nullptr, bool cancel = false)\n {\n@@ -155,7 +144,7 @@ void TestGUI()\n     for (int i = 0; i < 5; ++i) {\n         test.CreateAndProcessBlock({}, GetScriptForRawPubKey(test.coinbaseKey.GetPubKey()));\n     }\n-    CWallet wallet(\"mock\", CWalletDBWrapper::CreateMock());\n+    CWallet wallet(\"mock\", WalletDatabase::CreateMock());\n     bool firstRun;\n     wallet.LoadWallet(firstRun);\n     {\n@@ -175,8 +164,11 @@ void TestGUI()\n     std::unique_ptr<const PlatformStyle> platformStyle(PlatformStyle::instantiate(\"other\"));\n     SendCoinsDialog sendCoinsDialog(platformStyle.get());\n     TransactionView transactionView(platformStyle.get());\n-    OptionsModel optionsModel;\n-    WalletModel walletModel(platformStyle.get(), &wallet, &optionsModel);\n+    auto node = interfaces::MakeNode();\n+    OptionsModel optionsModel(*node);\n+    AddWallet(&wallet);\n+    WalletModel walletModel(std::move(node->getWallets().back()), *node, platformStyle.get(), &optionsModel);\n+    RemoveWallet(&wallet);\n     sendCoinsDialog.setModel(&walletModel);\n     transactionView.setModel(&walletModel);\n \n@@ -201,7 +193,7 @@ void TestGUI()\n     QLabel* balanceLabel = overviewPage.findChild<QLabel*>(\"labelBalance\");\n     QString balanceText = balanceLabel->text();\n     int unit = walletModel.getOptionsModel()->getDisplayUnit();\n-    CAmount balance = walletModel.getBalance();\n+    CAmount balance = walletModel.wallet().getBalance();\n     QString balanceComparison = BitcoinUnits::formatWithUnit(unit, balance, false, BitcoinUnits::separatorAlways);\n     QCOMPARE(balanceText, balanceComparison);\n \n@@ -258,7 +250,7 @@ void TestGUI()\n     QCOMPARE(requestTableModel->rowCount({}), currentRowCount-1);\n }\n \n-}\n+} // namespace\n \n void WalletTests::walletTests()\n {"
      },
      {
        "sha": "5a3b645f651a558966afb1a6b47fbb2c4b399811",
        "filename": "src/qt/trafficgraphwidget.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 6,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/trafficgraphwidget.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/trafficgraphwidget.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/trafficgraphwidget.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -2,6 +2,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include <interfaces/node.h>\n #include <qt/trafficgraphwidget.h>\n #include <qt/clientmodel.h>\n \n@@ -35,8 +36,8 @@ void TrafficGraphWidget::setClientModel(ClientModel *model)\n {\n     clientModel = model;\n     if(model) {\n-        nLastBytesIn = model->getTotalBytesRecv();\n-        nLastBytesOut = model->getTotalBytesSent();\n+        nLastBytesIn = model->node().getTotalBytesRecv();\n+        nLastBytesOut = model->node().getTotalBytesSent();\n     }\n }\n \n@@ -123,8 +124,8 @@ void TrafficGraphWidget::updateRates()\n {\n     if(!clientModel) return;\n \n-    quint64 bytesIn = clientModel->getTotalBytesRecv(),\n-            bytesOut = clientModel->getTotalBytesSent();\n+    quint64 bytesIn = clientModel->node().getTotalBytesRecv(),\n+            bytesOut = clientModel->node().getTotalBytesSent();\n     float inRate = (bytesIn - nLastBytesIn) / 1024.0f * 1000 / timer->interval();\n     float outRate = (bytesOut - nLastBytesOut) / 1024.0f * 1000 / timer->interval();\n     vSamplesIn.push_front(inRate);\n@@ -169,8 +170,8 @@ void TrafficGraphWidget::clear()\n     fMax = 0.0f;\n \n     if(clientModel) {\n-        nLastBytesIn = clientModel->getTotalBytesRecv();\n-        nLastBytesOut = clientModel->getTotalBytesSent();\n+        nLastBytesIn = clientModel->node().getTotalBytesRecv();\n+        nLastBytesOut = clientModel->node().getTotalBytesSent();\n     }\n     timer->start();\n }"
      },
      {
        "sha": "2cb446c45965430a428848f6dc9aa80a2fd3a19c",
        "filename": "src/qt/transactiondesc.cpp",
        "status": "modified",
        "additions": 79,
        "deletions": 61,
        "changes": 140,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/transactiondesc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/transactiondesc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiondesc.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -10,6 +10,7 @@\n #include <qt/transactionrecord.h>\n \n #include <consensus/consensus.h>\n+#include <interfaces/node.h>\n #include <key_io.h>\n #include <validation.h>\n #include <script/script.h>\n@@ -22,47 +23,52 @@\n #include <stdint.h>\n #include <string>\n \n-QString TransactionDesc::FormatTxStatus(const CWalletTx& wtx)\n+QString TransactionDesc::FormatTxStatus(const interfaces::WalletTx& wtx, const interfaces::WalletTxStatus& status, bool inMempool, int numBlocks, int64_t adjustedTime)\n {\n-    AssertLockHeld(cs_main);\n-    if (!CheckFinalTx(*wtx.tx))\n+    if (!status.is_final)\n     {\n         if (wtx.tx->nLockTime < LOCKTIME_THRESHOLD)\n-            return tr(\"Open for %n more block(s)\", \"\", wtx.tx->nLockTime - chainActive.Height());\n+            return tr(\"Open for %n more block(s)\", \"\", wtx.tx->nLockTime - numBlocks);\n         else\n             return tr(\"Open until %1\").arg(GUIUtil::dateTimeStr(wtx.tx->nLockTime));\n     }\n     else\n     {\n-        int nDepth = wtx.GetDepthInMainChain();\n+        int nDepth = status.depth_in_main_chain;\n         if (nDepth < 0)\n             return tr(\"conflicted with a transaction with %1 confirmations\").arg(-nDepth);\n-        else if (GetAdjustedTime() - wtx.nTimeReceived > 2 * 60 && wtx.GetRequestCount() == 0)\n+        else if (adjustedTime - status.time_received > 2 * 60 && status.request_count == 0)\n             return tr(\"%1/offline\").arg(nDepth);\n         else if (nDepth == 0)\n-            return tr(\"0/unconfirmed, %1\").arg((wtx.InMempool() ? tr(\"in memory pool\") : tr(\"not in memory pool\"))) + (wtx.isAbandoned() ? \", \"+tr(\"abandoned\") : \"\");\n+            return tr(\"0/unconfirmed, %1\").arg((inMempool ? tr(\"in memory pool\") : tr(\"not in memory pool\"))) + (status.is_abandoned ? \", \"+tr(\"abandoned\") : \"\");\n         else if (nDepth < 6)\n             return tr(\"%1/unconfirmed\").arg(nDepth);\n         else\n             return tr(\"%1 confirmations\").arg(nDepth);\n     }\n }\n \n-QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionRecord *rec, int unit)\n+QString TransactionDesc::toHTML(interfaces::Node& node, interfaces::Wallet& wallet, TransactionRecord *rec, int unit)\n {\n+    int numBlocks;\n+    int64_t adjustedTime;\n+    interfaces::WalletTxStatus status;\n+    interfaces::WalletOrderForm orderForm;\n+    bool inMempool;\n+    interfaces::WalletTx wtx = wallet.getWalletTxDetails(rec->hash, status, orderForm, inMempool, numBlocks, adjustedTime);\n+\n     QString strHTML;\n \n-    LOCK2(cs_main, wallet->cs_wallet);\n     strHTML.reserve(4000);\n     strHTML += \"<html><font face='verdana, arial, helvetica, sans-serif'>\";\n \n-    int64_t nTime = wtx.GetTxTime();\n-    CAmount nCredit = wtx.GetCredit(ISMINE_ALL);\n-    CAmount nDebit = wtx.GetDebit(ISMINE_ALL);\n+    int64_t nTime = wtx.time;\n+    CAmount nCredit = wtx.credit;\n+    CAmount nDebit = wtx.debit;\n     CAmount nNet = nCredit - nDebit;\n \n-    strHTML += \"<b>\" + tr(\"Status\") + \":</b> \" + FormatTxStatus(wtx);\n-    int nRequests = wtx.GetRequestCount();\n+    strHTML += \"<b>\" + tr(\"Status\") + \":</b> \" + FormatTxStatus(wtx, status, inMempool, numBlocks, adjustedTime);\n+    int nRequests = status.request_count;\n     if (nRequests != -1)\n     {\n         if (nRequests == 0)\n@@ -77,14 +83,14 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n     //\n     // From\n     //\n-    if (wtx.IsCoinBase())\n+    if (wtx.is_coinbase)\n     {\n         strHTML += \"<b>\" + tr(\"Source\") + \":</b> \" + tr(\"Generated\") + \"<br>\";\n     }\n-    else if (wtx.mapValue.count(\"from\") && !wtx.mapValue[\"from\"].empty())\n+    else if (wtx.value_map.count(\"from\") && !wtx.value_map[\"from\"].empty())\n     {\n         // Online transaction\n-        strHTML += \"<b>\" + tr(\"From\") + \":</b> \" + GUIUtil::HtmlEscape(wtx.mapValue[\"from\"]) + \"<br>\";\n+        strHTML += \"<b>\" + tr(\"From\") + \":</b> \" + GUIUtil::HtmlEscape(wtx.value_map[\"from\"]) + \"<br>\";\n     }\n     else\n     {\n@@ -94,14 +100,16 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n             // Credit\n             CTxDestination address = DecodeDestination(rec->address);\n             if (IsValidDestination(address)) {\n-                if (wallet->mapAddressBook.count(address))\n+                std::string name;\n+                isminetype ismine;\n+                if (wallet.getAddress(address, &name, &ismine, /* purpose= */ nullptr))\n                 {\n                     strHTML += \"<b>\" + tr(\"From\") + \":</b> \" + tr(\"unknown\") + \"<br>\";\n                     strHTML += \"<b>\" + tr(\"To\") + \":</b> \";\n                     strHTML += GUIUtil::HtmlEscape(rec->address);\n-                    QString addressOwned = (::IsMine(*wallet, address) == ISMINE_SPENDABLE) ? tr(\"own address\") : tr(\"watch-only\");\n-                    if (!wallet->mapAddressBook[address].name.empty())\n-                        strHTML += \" (\" + addressOwned + \", \" + tr(\"label\") + \": \" + GUIUtil::HtmlEscape(wallet->mapAddressBook[address].name) + \")\";\n+                    QString addressOwned = ismine == ISMINE_SPENDABLE ? tr(\"own address\") : tr(\"watch-only\");\n+                    if (!name.empty())\n+                        strHTML += \" (\" + addressOwned + \", \" + tr(\"label\") + \": \" + GUIUtil::HtmlEscape(name) + \")\";\n                     else\n                         strHTML += \" (\" + addressOwned + \")\";\n                     strHTML += \"<br>\";\n@@ -113,31 +121,33 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n     //\n     // To\n     //\n-    if (wtx.mapValue.count(\"to\") && !wtx.mapValue[\"to\"].empty())\n+    if (wtx.value_map.count(\"to\") && !wtx.value_map[\"to\"].empty())\n     {\n         // Online transaction\n-        std::string strAddress = wtx.mapValue[\"to\"];\n+        std::string strAddress = wtx.value_map[\"to\"];\n         strHTML += \"<b>\" + tr(\"To\") + \":</b> \";\n         CTxDestination dest = DecodeDestination(strAddress);\n-        if (wallet->mapAddressBook.count(dest) && !wallet->mapAddressBook[dest].name.empty())\n-            strHTML += GUIUtil::HtmlEscape(wallet->mapAddressBook[dest].name) + \" \";\n+        std::string name;\n+        if (wallet.getAddress(\n+                dest, &name, /* is_mine= */ nullptr, /* purpose= */ nullptr) && !name.empty())\n+            strHTML += GUIUtil::HtmlEscape(name) + \" \";\n         strHTML += GUIUtil::HtmlEscape(strAddress) + \"<br>\";\n     }\n \n     //\n     // Amount\n     //\n-    if (wtx.IsCoinBase() && nCredit == 0)\n+    if (wtx.is_coinbase && nCredit == 0)\n     {\n         //\n         // Coinbase\n         //\n         CAmount nUnmatured = 0;\n         for (const CTxOut& txout : wtx.tx->vout)\n-            nUnmatured += wallet->GetCredit(txout, ISMINE_ALL);\n+            nUnmatured += wallet.getCredit(txout, ISMINE_ALL);\n         strHTML += \"<b>\" + tr(\"Credit\") + \":</b> \";\n-        if (wtx.IsInMainChain())\n-            strHTML += BitcoinUnits::formatHtmlWithUnit(unit, nUnmatured)+ \" (\" + tr(\"matures in %n more block(s)\", \"\", wtx.GetBlocksToMaturity()) + \")\";\n+        if (status.is_in_main_chain)\n+            strHTML += BitcoinUnits::formatHtmlWithUnit(unit, nUnmatured)+ \" (\" + tr(\"matures in %n more block(s)\", \"\", status.blocks_to_maturity) + \")\";\n         else\n             strHTML += \"(\" + tr(\"not accepted\") + \")\";\n         strHTML += \"<br>\";\n@@ -152,16 +162,14 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n     else\n     {\n         isminetype fAllFromMe = ISMINE_SPENDABLE;\n-        for (const CTxIn& txin : wtx.tx->vin)\n+        for (isminetype mine : wtx.txin_is_mine)\n         {\n-            isminetype mine = wallet->IsMine(txin);\n             if(fAllFromMe > mine) fAllFromMe = mine;\n         }\n \n         isminetype fAllToMe = ISMINE_SPENDABLE;\n-        for (const CTxOut& txout : wtx.tx->vout)\n+        for (isminetype mine : wtx.txout_is_mine)\n         {\n-            isminetype mine = wallet->IsMine(txout);\n             if(fAllToMe > mine) fAllToMe = mine;\n         }\n \n@@ -173,22 +181,25 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n             //\n             // Debit\n             //\n+            auto mine = wtx.txout_is_mine.begin();\n             for (const CTxOut& txout : wtx.tx->vout)\n             {\n                 // Ignore change\n-                isminetype toSelf = wallet->IsMine(txout);\n+                isminetype toSelf = *(mine++);\n                 if ((toSelf == ISMINE_SPENDABLE) && (fAllFromMe == ISMINE_SPENDABLE))\n                     continue;\n \n-                if (!wtx.mapValue.count(\"to\") || wtx.mapValue[\"to\"].empty())\n+                if (!wtx.value_map.count(\"to\") || wtx.value_map[\"to\"].empty())\n                 {\n                     // Offline transaction\n                     CTxDestination address;\n                     if (ExtractDestination(txout.scriptPubKey, address))\n                     {\n                         strHTML += \"<b>\" + tr(\"To\") + \":</b> \";\n-                        if (wallet->mapAddressBook.count(address) && !wallet->mapAddressBook[address].name.empty())\n-                            strHTML += GUIUtil::HtmlEscape(wallet->mapAddressBook[address].name) + \" \";\n+                        std::string name;\n+                        if (wallet.getAddress(\n+                                address, &name, /* is_mine= */ nullptr, /* purpose= */ nullptr) && !name.empty())\n+                            strHTML += GUIUtil::HtmlEscape(name) + \" \";\n                         strHTML += GUIUtil::HtmlEscape(EncodeDestination(address));\n                         if(toSelf == ISMINE_SPENDABLE)\n                             strHTML += \" (own address)\";\n@@ -206,7 +217,7 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n             if (fAllToMe)\n             {\n                 // Payment to self\n-                CAmount nChange = wtx.GetChange();\n+                CAmount nChange = wtx.change;\n                 CAmount nValue = nCredit - nChange;\n                 strHTML += \"<b>\" + tr(\"Total debit\") + \":</b> \" + BitcoinUnits::formatHtmlWithUnit(unit, -nValue) + \"<br>\";\n                 strHTML += \"<b>\" + tr(\"Total credit\") + \":</b> \" + BitcoinUnits::formatHtmlWithUnit(unit, nValue) + \"<br>\";\n@@ -221,12 +232,18 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n             //\n             // Mixed debit transaction\n             //\n-            for (const CTxIn& txin : wtx.tx->vin)\n-                if (wallet->IsMine(txin))\n-                    strHTML += \"<b>\" + tr(\"Debit\") + \":</b> \" + BitcoinUnits::formatHtmlWithUnit(unit, -wallet->GetDebit(txin, ISMINE_ALL)) + \"<br>\";\n-            for (const CTxOut& txout : wtx.tx->vout)\n-                if (wallet->IsMine(txout))\n-                    strHTML += \"<b>\" + tr(\"Credit\") + \":</b> \" + BitcoinUnits::formatHtmlWithUnit(unit, wallet->GetCredit(txout, ISMINE_ALL)) + \"<br>\";\n+            auto mine = wtx.txin_is_mine.begin();\n+            for (const CTxIn& txin : wtx.tx->vin) {\n+                if (*(mine++)) {\n+                    strHTML += \"<b>\" + tr(\"Debit\") + \":</b> \" + BitcoinUnits::formatHtmlWithUnit(unit, -wallet.getDebit(txin, ISMINE_ALL)) + \"<br>\";\n+                }\n+            }\n+            mine = wtx.txout_is_mine.begin();\n+            for (const CTxOut& txout : wtx.tx->vout) {\n+                if (*(mine++)) {\n+                    strHTML += \"<b>\" + tr(\"Credit\") + \":</b> \" + BitcoinUnits::formatHtmlWithUnit(unit, wallet.getCredit(txout, ISMINE_ALL)) + \"<br>\";\n+                }\n+            }\n         }\n     }\n \n@@ -235,25 +252,25 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n     //\n     // Message\n     //\n-    if (wtx.mapValue.count(\"message\") && !wtx.mapValue[\"message\"].empty())\n-        strHTML += \"<br><b>\" + tr(\"Message\") + \":</b><br>\" + GUIUtil::HtmlEscape(wtx.mapValue[\"message\"], true) + \"<br>\";\n-    if (wtx.mapValue.count(\"comment\") && !wtx.mapValue[\"comment\"].empty())\n-        strHTML += \"<br><b>\" + tr(\"Comment\") + \":</b><br>\" + GUIUtil::HtmlEscape(wtx.mapValue[\"comment\"], true) + \"<br>\";\n+    if (wtx.value_map.count(\"message\") && !wtx.value_map[\"message\"].empty())\n+        strHTML += \"<br><b>\" + tr(\"Message\") + \":</b><br>\" + GUIUtil::HtmlEscape(wtx.value_map[\"message\"], true) + \"<br>\";\n+    if (wtx.value_map.count(\"comment\") && !wtx.value_map[\"comment\"].empty())\n+        strHTML += \"<br><b>\" + tr(\"Comment\") + \":</b><br>\" + GUIUtil::HtmlEscape(wtx.value_map[\"comment\"], true) + \"<br>\";\n \n     strHTML += \"<b>\" + tr(\"Transaction ID\") + \":</b> \" + rec->getTxHash() + \"<br>\";\n     strHTML += \"<b>\" + tr(\"Transaction total size\") + \":</b> \" + QString::number(wtx.tx->GetTotalSize()) + \" bytes<br>\";\n     strHTML += \"<b>\" + tr(\"Transaction virtual size\") + \":</b> \" + QString::number(GetVirtualTransactionSize(*wtx.tx)) + \" bytes<br>\";\n     strHTML += \"<b>\" + tr(\"Output index\") + \":</b> \" + QString::number(rec->getOutputIndex()) + \"<br>\";\n \n     // Message from normal bitcoin:URI (bitcoin:123...?message=example)\n-    for (const std::pair<std::string, std::string>& r : wtx.vOrderForm)\n+    for (const std::pair<std::string, std::string>& r : orderForm)\n         if (r.first == \"Message\")\n             strHTML += \"<br><b>\" + tr(\"Message\") + \":</b><br>\" + GUIUtil::HtmlEscape(r.second, true) + \"<br>\";\n \n     //\n     // PaymentRequest info:\n     //\n-    for (const std::pair<std::string, std::string>& r : wtx.vOrderForm)\n+    for (const std::pair<std::string, std::string>& r : orderForm)\n     {\n         if (r.first == \"PaymentRequest\")\n         {\n@@ -265,7 +282,7 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n         }\n     }\n \n-    if (wtx.IsCoinBase())\n+    if (wtx.is_coinbase)\n     {\n         quint32 numBlocksToMaturity = COINBASE_MATURITY +  1;\n         strHTML += \"<br>\" + tr(\"Generated coins must mature %1 blocks before they can be spent. When you generated this block, it was broadcast to the network to be added to the block chain. If it fails to get into the chain, its state will change to \\\"not accepted\\\" and it won't be spendable. This may occasionally happen if another node generates a block within a few seconds of yours.\").arg(QString::number(numBlocksToMaturity)) + \"<br>\";\n@@ -274,15 +291,15 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n     //\n     // Debug view\n     //\n-    if (logCategories != BCLog::NONE)\n+    if (node.getLogCategories() != BCLog::NONE)\n     {\n         strHTML += \"<hr><br>\" + tr(\"Debug information\") + \"<br><br>\";\n         for (const CTxIn& txin : wtx.tx->vin)\n-            if(wallet->IsMine(txin))\n-                strHTML += \"<b>\" + tr(\"Debit\") + \":</b> \" + BitcoinUnits::formatHtmlWithUnit(unit, -wallet->GetDebit(txin, ISMINE_ALL)) + \"<br>\";\n+            if(wallet.txinIsMine(txin))\n+                strHTML += \"<b>\" + tr(\"Debit\") + \":</b> \" + BitcoinUnits::formatHtmlWithUnit(unit, -wallet.getDebit(txin, ISMINE_ALL)) + \"<br>\";\n         for (const CTxOut& txout : wtx.tx->vout)\n-            if(wallet->IsMine(txout))\n-                strHTML += \"<b>\" + tr(\"Credit\") + \":</b> \" + BitcoinUnits::formatHtmlWithUnit(unit, wallet->GetCredit(txout, ISMINE_ALL)) + \"<br>\";\n+            if(wallet.txoutIsMine(txout))\n+                strHTML += \"<b>\" + tr(\"Credit\") + \":</b> \" + BitcoinUnits::formatHtmlWithUnit(unit, wallet.getCredit(txout, ISMINE_ALL)) + \"<br>\";\n \n         strHTML += \"<br><b>\" + tr(\"Transaction\") + \":</b><br>\";\n         strHTML += GUIUtil::HtmlEscape(wtx.tx->ToString(), true);\n@@ -295,21 +312,22 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n             COutPoint prevout = txin.prevout;\n \n             Coin prev;\n-            if(pcoinsTip->GetCoin(prevout, prev))\n+            if(node.getUnspentOutput(prevout, prev))\n             {\n                 {\n                     strHTML += \"<li>\";\n                     const CTxOut &vout = prev.out;\n                     CTxDestination address;\n                     if (ExtractDestination(vout.scriptPubKey, address))\n                     {\n-                        if (wallet->mapAddressBook.count(address) && !wallet->mapAddressBook[address].name.empty())\n-                            strHTML += GUIUtil::HtmlEscape(wallet->mapAddressBook[address].name) + \" \";\n+                        std::string name;\n+                        if (wallet.getAddress(address, &name, /* is_mine= */ nullptr, /* purpose= */ nullptr) && !name.empty())\n+                            strHTML += GUIUtil::HtmlEscape(name) + \" \";\n                         strHTML += QString::fromStdString(EncodeDestination(address));\n                     }\n                     strHTML = strHTML + \" \" + tr(\"Amount\") + \"=\" + BitcoinUnits::formatHtmlWithUnit(unit, vout.nValue);\n-                    strHTML = strHTML + \" IsMine=\" + (wallet->IsMine(vout) & ISMINE_SPENDABLE ? tr(\"true\") : tr(\"false\")) + \"</li>\";\n-                    strHTML = strHTML + \" IsWatchOnly=\" + (wallet->IsMine(vout) & ISMINE_WATCH_ONLY ? tr(\"true\") : tr(\"false\")) + \"</li>\";\n+                    strHTML = strHTML + \" IsMine=\" + (wallet.txoutIsMine(vout) & ISMINE_SPENDABLE ? tr(\"true\") : tr(\"false\")) + \"</li>\";\n+                    strHTML = strHTML + \" IsWatchOnly=\" + (wallet.txoutIsMine(vout) & ISMINE_WATCH_ONLY ? tr(\"true\") : tr(\"false\")) + \"</li>\";\n                 }\n             }\n         }"
      },
      {
        "sha": "cb8453cb81e95f9a51a45abb027686675d0525ea",
        "filename": "src/qt/transactiondesc.h",
        "status": "modified",
        "additions": 8,
        "deletions": 4,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/transactiondesc.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/transactiondesc.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiondesc.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -10,8 +10,12 @@\n \n class TransactionRecord;\n \n-class CWallet;\n-class CWalletTx;\n+namespace interfaces {\n+class Node;\n+class Wallet;\n+struct WalletTx;\n+struct WalletTxStatus;\n+}\n \n /** Provide a human-readable extended HTML description of a transaction.\n  */\n@@ -20,12 +24,12 @@ class TransactionDesc: public QObject\n     Q_OBJECT\n \n public:\n-    static QString toHTML(CWallet *wallet, CWalletTx &wtx, TransactionRecord *rec, int unit);\n+    static QString toHTML(interfaces::Node& node, interfaces::Wallet& wallet, TransactionRecord *rec, int unit);\n \n private:\n     TransactionDesc() {}\n \n-    static QString FormatTxStatus(const CWalletTx& wtx);\n+    static QString FormatTxStatus(const interfaces::WalletTx& wtx, const interfaces::WalletTxStatus& status, bool inMempool, int numBlocks, int64_t adjustedTime);\n };\n \n #endif // BITCOIN_QT_TRANSACTIONDESC_H"
      },
      {
        "sha": "b6ed66ad96eae913a3031c76021e46b72c3ac6db",
        "filename": "src/qt/transactionrecord.cpp",
        "status": "modified",
        "additions": 39,
        "deletions": 47,
        "changes": 86,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/transactionrecord.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/transactionrecord.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionrecord.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -5,17 +5,17 @@\n #include <qt/transactionrecord.h>\n \n #include <consensus/consensus.h>\n+#include <interfaces/wallet.h>\n #include <key_io.h>\n-#include <validation.h>\n #include <timedata.h>\n-#include <wallet/wallet.h>\n+#include <validation.h>\n \n #include <stdint.h>\n \n \n /* Return positive answer if transaction should be shown in list.\n  */\n-bool TransactionRecord::showTransaction(const CWalletTx &wtx)\n+bool TransactionRecord::showTransaction()\n {\n     // There are currently no cases where we hide transactions, but\n     // we may want to use this in the future for things like RBF.\n@@ -25,45 +25,45 @@ bool TransactionRecord::showTransaction(const CWalletTx &wtx)\n /*\n  * Decompose CWallet transaction to model transaction records.\n  */\n-QList<TransactionRecord> TransactionRecord::decomposeTransaction(const CWallet *wallet, const CWalletTx &wtx)\n+QList<TransactionRecord> TransactionRecord::decomposeTransaction(const interfaces::WalletTx& wtx)\n {\n     QList<TransactionRecord> parts;\n-    int64_t nTime = wtx.GetTxTime();\n-    CAmount nCredit = wtx.GetCredit(ISMINE_ALL);\n-    CAmount nDebit = wtx.GetDebit(ISMINE_ALL);\n+    int64_t nTime = wtx.time;\n+    CAmount nCredit = wtx.credit;\n+    CAmount nDebit = wtx.debit;\n     CAmount nNet = nCredit - nDebit;\n-    uint256 hash = wtx.GetHash();\n-    std::map<std::string, std::string> mapValue = wtx.mapValue;\n+    uint256 hash = wtx.tx->GetHash();\n+    std::map<std::string, std::string> mapValue = wtx.value_map;\n \n-    if (nNet > 0 || wtx.IsCoinBase())\n+    if (nNet > 0 || wtx.is_coinbase)\n     {\n         //\n         // Credit\n         //\n         for(unsigned int i = 0; i < wtx.tx->vout.size(); i++)\n         {\n             const CTxOut& txout = wtx.tx->vout[i];\n-            isminetype mine = wallet->IsMine(txout);\n+            isminetype mine = wtx.txout_is_mine[i];\n             if(mine)\n             {\n                 TransactionRecord sub(hash, nTime);\n                 CTxDestination address;\n                 sub.idx = i; // vout index\n                 sub.credit = txout.nValue;\n                 sub.involvesWatchAddress = mine & ISMINE_WATCH_ONLY;\n-                if (ExtractDestination(txout.scriptPubKey, address) && IsMine(*wallet, address))\n+                if (wtx.txout_address_is_mine[i])\n                 {\n                     // Received by Bitcoin Address\n                     sub.type = TransactionRecord::RecvWithAddress;\n-                    sub.address = EncodeDestination(address);\n+                    sub.address = EncodeDestination(wtx.txout_address[i]);\n                 }\n                 else\n                 {\n                     // Received by IP connection (deprecated features), or a multisignature or other non-simple transaction\n                     sub.type = TransactionRecord::RecvFromOther;\n                     sub.address = mapValue[\"from\"];\n                 }\n-                if (wtx.IsCoinBase())\n+                if (wtx.is_coinbase)\n                 {\n                     // Generated\n                     sub.type = TransactionRecord::Generated;\n@@ -77,25 +77,23 @@ QList<TransactionRecord> TransactionRecord::decomposeTransaction(const CWallet *\n     {\n         bool involvesWatchAddress = false;\n         isminetype fAllFromMe = ISMINE_SPENDABLE;\n-        for (const CTxIn& txin : wtx.tx->vin)\n+        for (isminetype mine : wtx.txin_is_mine)\n         {\n-            isminetype mine = wallet->IsMine(txin);\n             if(mine & ISMINE_WATCH_ONLY) involvesWatchAddress = true;\n             if(fAllFromMe > mine) fAllFromMe = mine;\n         }\n \n         isminetype fAllToMe = ISMINE_SPENDABLE;\n-        for (const CTxOut& txout : wtx.tx->vout)\n+        for (isminetype mine : wtx.txout_is_mine)\n         {\n-            isminetype mine = wallet->IsMine(txout);\n             if(mine & ISMINE_WATCH_ONLY) involvesWatchAddress = true;\n             if(fAllToMe > mine) fAllToMe = mine;\n         }\n \n         if (fAllFromMe && fAllToMe)\n         {\n             // Payment to self\n-            CAmount nChange = wtx.GetChange();\n+            CAmount nChange = wtx.change;\n \n             parts.append(TransactionRecord(hash, nTime, TransactionRecord::SendToSelf, \"\",\n                             -(nDebit - nChange), nCredit - nChange));\n@@ -115,19 +113,18 @@ QList<TransactionRecord> TransactionRecord::decomposeTransaction(const CWallet *\n                 sub.idx = nOut;\n                 sub.involvesWatchAddress = involvesWatchAddress;\n \n-                if(wallet->IsMine(txout))\n+                if(wtx.txout_is_mine[nOut])\n                 {\n                     // Ignore parts sent to self, as this is usually the change\n                     // from a transaction sent back to our own address.\n                     continue;\n                 }\n \n-                CTxDestination address;\n-                if (ExtractDestination(txout.scriptPubKey, address))\n+                if (!boost::get<CNoDestination>(&wtx.txout_address[nOut]))\n                 {\n                     // Sent to Bitcoin Address\n                     sub.type = TransactionRecord::SendToAddress;\n-                    sub.address = EncodeDestination(address);\n+                    sub.address = EncodeDestination(wtx.txout_address[nOut]);\n                 }\n                 else\n                 {\n@@ -161,50 +158,46 @@ QList<TransactionRecord> TransactionRecord::decomposeTransaction(const CWallet *\n     return parts;\n }\n \n-void TransactionRecord::updateStatus(const CWalletTx &wtx)\n+void TransactionRecord::updateStatus(const interfaces::WalletTxStatus& wtx, int numBlocks, int64_t adjustedTime)\n {\n-    AssertLockHeld(cs_main);\n     // Determine transaction status\n \n-    // Find the block the tx is in\n-    const CBlockIndex* pindex = LookupBlockIndex(wtx.hashBlock);\n-\n     // Sort order, unrecorded transactions sort to the top\n     status.sortKey = strprintf(\"%010d-%01d-%010u-%03d\",\n-        (pindex ? pindex->nHeight : std::numeric_limits<int>::max()),\n-        (wtx.IsCoinBase() ? 1 : 0),\n-        wtx.nTimeReceived,\n+        wtx.block_height,\n+        wtx.is_coinbase ? 1 : 0,\n+        wtx.time_received,\n         idx);\n-    status.countsForBalance = wtx.IsTrusted() && !(wtx.GetBlocksToMaturity() > 0);\n-    status.depth = wtx.GetDepthInMainChain();\n-    status.cur_num_blocks = chainActive.Height();\n+    status.countsForBalance = wtx.is_trusted && !(wtx.blocks_to_maturity > 0);\n+    status.depth = wtx.depth_in_main_chain;\n+    status.cur_num_blocks = numBlocks;\n \n-    if (!CheckFinalTx(*wtx.tx))\n+    if (!wtx.is_final)\n     {\n-        if (wtx.tx->nLockTime < LOCKTIME_THRESHOLD)\n+        if (wtx.lock_time < LOCKTIME_THRESHOLD)\n         {\n             status.status = TransactionStatus::OpenUntilBlock;\n-            status.open_for = wtx.tx->nLockTime - chainActive.Height();\n+            status.open_for = wtx.lock_time - numBlocks;\n         }\n         else\n         {\n             status.status = TransactionStatus::OpenUntilDate;\n-            status.open_for = wtx.tx->nLockTime;\n+            status.open_for = wtx.lock_time;\n         }\n     }\n     // For generated transactions, determine maturity\n     else if(type == TransactionRecord::Generated)\n     {\n-        if (wtx.GetBlocksToMaturity() > 0)\n+        if (wtx.blocks_to_maturity > 0)\n         {\n             status.status = TransactionStatus::Immature;\n \n-            if (wtx.IsInMainChain())\n+            if (wtx.is_in_main_chain)\n             {\n-                status.matures_in = wtx.GetBlocksToMaturity();\n+                status.matures_in = wtx.blocks_to_maturity;\n \n                 // Check if the block was requested by anyone\n-                if (GetAdjustedTime() - wtx.nTimeReceived > 2 * 60 && wtx.GetRequestCount() == 0)\n+                if (adjustedTime - wtx.time_received > 2 * 60 && wtx.request_count == 0)\n                     status.status = TransactionStatus::MaturesWarning;\n             }\n             else\n@@ -223,14 +216,14 @@ void TransactionRecord::updateStatus(const CWalletTx &wtx)\n         {\n             status.status = TransactionStatus::Conflicted;\n         }\n-        else if (GetAdjustedTime() - wtx.nTimeReceived > 2 * 60 && wtx.GetRequestCount() == 0)\n+        else if (adjustedTime - wtx.time_received > 2 * 60 && wtx.request_count == 0)\n         {\n             status.status = TransactionStatus::Offline;\n         }\n         else if (status.depth == 0)\n         {\n             status.status = TransactionStatus::Unconfirmed;\n-            if (wtx.isAbandoned())\n+            if (wtx.is_abandoned)\n                 status.status = TransactionStatus::Abandoned;\n         }\n         else if (status.depth < RecommendedNumConfirmations)\n@@ -245,10 +238,9 @@ void TransactionRecord::updateStatus(const CWalletTx &wtx)\n     status.needsUpdate = false;\n }\n \n-bool TransactionRecord::statusUpdateNeeded() const\n+bool TransactionRecord::statusUpdateNeeded(int numBlocks) const\n {\n-    AssertLockHeld(cs_main);\n-    return status.cur_num_blocks != chainActive.Height() || status.needsUpdate;\n+    return status.cur_num_blocks != numBlocks || status.needsUpdate;\n }\n \n QString TransactionRecord::getTxHash() const"
      },
      {
        "sha": "62961434edb3d5202b4bebb2e299eb7ab3e23d37",
        "filename": "src/qt/transactionrecord.h",
        "status": "modified",
        "additions": 10,
        "deletions": 6,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/transactionrecord.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/transactionrecord.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionrecord.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -11,8 +11,12 @@\n #include <QList>\n #include <QString>\n \n-class CWallet;\n-class CWalletTx;\n+namespace interfaces {\n+class Node;\n+class Wallet;\n+struct WalletTx;\n+struct WalletTxStatus;\n+}\n \n /** UI model for transaction status. The transaction status is the part of a transaction that will change over time.\n  */\n@@ -106,8 +110,8 @@ class TransactionRecord\n \n     /** Decompose CWallet transaction to model transaction records.\n      */\n-    static bool showTransaction(const CWalletTx &wtx);\n-    static QList<TransactionRecord> decomposeTransaction(const CWallet *wallet, const CWalletTx &wtx);\n+    static bool showTransaction();\n+    static QList<TransactionRecord> decomposeTransaction(const interfaces::WalletTx& wtx);\n \n     /** @name Immutable transaction attributes\n       @{*/\n@@ -136,11 +140,11 @@ class TransactionRecord\n \n     /** Update status from core wallet tx.\n      */\n-    void updateStatus(const CWalletTx &wtx);\n+    void updateStatus(const interfaces::WalletTxStatus& wtx, int numBlocks, int64_t adjustedTime);\n \n     /** Return whether a status update is needed.\n      */\n-    bool statusUpdateNeeded() const;\n+    bool statusUpdateNeeded(int numBlocks) const;\n };\n \n #endif // BITCOIN_QT_TRANSACTIONRECORD_H"
      },
      {
        "sha": "46169a91d14ed48d7cf45d68218697e2bbd31b0e",
        "filename": "src/qt/transactiontablemodel.cpp",
        "status": "modified",
        "additions": 38,
        "deletions": 62,
        "changes": 100,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/transactiontablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/transactiontablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiontablemodel.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -14,11 +14,12 @@\n #include <qt/walletmodel.h>\n \n #include <core_io.h>\n+#include <interfaces/handler.h>\n+#include <interfaces/node.h>\n #include <validation.h>\n #include <sync.h>\n #include <uint256.h>\n #include <util.h>\n-#include <wallet/wallet.h>\n \n #include <QColor>\n #include <QDateTime>\n@@ -57,13 +58,11 @@ struct TxLessThan\n class TransactionTablePriv\n {\n public:\n-    TransactionTablePriv(CWallet *_wallet, TransactionTableModel *_parent) :\n-        wallet(_wallet),\n+    TransactionTablePriv(TransactionTableModel *_parent) :\n         parent(_parent)\n     {\n     }\n \n-    CWallet *wallet;\n     TransactionTableModel *parent;\n \n     /* Local cache of wallet.\n@@ -74,16 +73,15 @@ class TransactionTablePriv\n \n     /* Query entire wallet anew from core.\n      */\n-    void refreshWallet()\n+    void refreshWallet(interfaces::Wallet& wallet)\n     {\n         qDebug() << \"TransactionTablePriv::refreshWallet\";\n         cachedWallet.clear();\n         {\n-            LOCK2(cs_main, wallet->cs_wallet);\n-            for (const auto& entry : wallet->mapWallet)\n-            {\n-                if (TransactionRecord::showTransaction(entry.second))\n-                    cachedWallet.append(TransactionRecord::decomposeTransaction(wallet, entry.second));\n+            for (const auto& wtx : wallet.getWalletTxs()) {\n+                if (TransactionRecord::showTransaction()) {\n+                    cachedWallet.append(TransactionRecord::decomposeTransaction(wtx));\n+                }\n             }\n         }\n     }\n@@ -93,7 +91,7 @@ class TransactionTablePriv\n \n        Call with transaction that was added, removed or changed.\n      */\n-    void updateWallet(const uint256 &hash, int status, bool showTransaction)\n+    void updateWallet(interfaces::Wallet& wallet, const uint256 &hash, int status, bool showTransaction)\n     {\n         qDebug() << \"TransactionTablePriv::updateWallet: \" + QString::fromStdString(hash.ToString()) + \" \" + QString::number(status);\n \n@@ -128,17 +126,16 @@ class TransactionTablePriv\n             }\n             if(showTransaction)\n             {\n-                LOCK2(cs_main, wallet->cs_wallet);\n                 // Find transaction in wallet\n-                std::map<uint256, CWalletTx>::iterator mi = wallet->mapWallet.find(hash);\n-                if(mi == wallet->mapWallet.end())\n+                interfaces::WalletTx wtx = wallet.getWalletTx(hash);\n+                if(!wtx.tx)\n                 {\n                     qWarning() << \"TransactionTablePriv::updateWallet: Warning: Got CT_NEW, but transaction is not in wallet\";\n                     break;\n                 }\n                 // Added -- insert at the right position\n                 QList<TransactionRecord> toInsert =\n-                        TransactionRecord::decomposeTransaction(wallet, mi->second);\n+                        TransactionRecord::decomposeTransaction(wtx);\n                 if(!toInsert.isEmpty()) /* only if something to insert */\n                 {\n                     parent->beginInsertRows(QModelIndex(), lowerIndex, lowerIndex+toInsert.size()-1);\n@@ -179,7 +176,7 @@ class TransactionTablePriv\n         return cachedWallet.size();\n     }\n \n-    TransactionRecord *index(int idx)\n+    TransactionRecord *index(interfaces::Wallet& wallet, int idx)\n     {\n         if(idx >= 0 && idx < cachedWallet.size())\n         {\n@@ -192,61 +189,42 @@ class TransactionTablePriv\n             // If a status update is needed (blocks came in since last check),\n             //  update the status of this transaction from the wallet. Otherwise,\n             // simply re-use the cached status.\n-            TRY_LOCK(cs_main, lockMain);\n-            if(lockMain)\n-            {\n-                TRY_LOCK(wallet->cs_wallet, lockWallet);\n-                if(lockWallet && rec->statusUpdateNeeded())\n-                {\n-                    std::map<uint256, CWalletTx>::iterator mi = wallet->mapWallet.find(rec->hash);\n-\n-                    if(mi != wallet->mapWallet.end())\n-                    {\n-                        rec->updateStatus(mi->second);\n-                    }\n-                }\n+            interfaces::WalletTxStatus wtx;\n+            int numBlocks;\n+            int64_t adjustedTime;\n+            if (wallet.tryGetTxStatus(rec->hash, wtx, numBlocks, adjustedTime) && rec->statusUpdateNeeded(numBlocks)) {\n+                rec->updateStatus(wtx, numBlocks, adjustedTime);\n             }\n             return rec;\n         }\n         return 0;\n     }\n \n-    QString describe(TransactionRecord *rec, int unit)\n+    QString describe(interfaces::Node& node, interfaces::Wallet& wallet, TransactionRecord *rec, int unit)\n     {\n-        {\n-            LOCK2(cs_main, wallet->cs_wallet);\n-            std::map<uint256, CWalletTx>::iterator mi = wallet->mapWallet.find(rec->hash);\n-            if(mi != wallet->mapWallet.end())\n-            {\n-                return TransactionDesc::toHTML(wallet, mi->second, rec, unit);\n-            }\n-        }\n-        return QString();\n+        return TransactionDesc::toHTML(node, wallet, rec, unit);\n     }\n \n-    QString getTxHex(TransactionRecord *rec)\n+    QString getTxHex(interfaces::Wallet& wallet, TransactionRecord *rec)\n     {\n-        LOCK2(cs_main, wallet->cs_wallet);\n-        std::map<uint256, CWalletTx>::iterator mi = wallet->mapWallet.find(rec->hash);\n-        if(mi != wallet->mapWallet.end())\n-        {\n-            std::string strHex = EncodeHexTx(*mi->second.tx);\n+        auto tx = wallet.getTx(rec->hash);\n+        if (tx) {\n+            std::string strHex = EncodeHexTx(*tx);\n             return QString::fromStdString(strHex);\n         }\n         return QString();\n     }\n };\n \n-TransactionTableModel::TransactionTableModel(const PlatformStyle *_platformStyle, CWallet* _wallet, WalletModel *parent):\n+TransactionTableModel::TransactionTableModel(const PlatformStyle *_platformStyle, WalletModel *parent):\n         QAbstractTableModel(parent),\n-        wallet(_wallet),\n         walletModel(parent),\n-        priv(new TransactionTablePriv(_wallet, this)),\n+        priv(new TransactionTablePriv(this)),\n         fProcessingQueuedTransactions(false),\n         platformStyle(_platformStyle)\n {\n     columns << QString() << QString() << tr(\"Date\") << tr(\"Type\") << tr(\"Label\") << BitcoinUnits::getAmountColumnTitle(walletModel->getOptionsModel()->getDisplayUnit());\n-    priv->refreshWallet();\n+    priv->refreshWallet(walletModel->wallet());\n \n     connect(walletModel->getOptionsModel(), SIGNAL(displayUnitChanged(int)), this, SLOT(updateDisplayUnit()));\n \n@@ -271,7 +249,7 @@ void TransactionTableModel::updateTransaction(const QString &hash, int status, b\n     uint256 updated;\n     updated.SetHex(hash.toStdString());\n \n-    priv->updateWallet(updated, status, showTransaction);\n+    priv->updateWallet(walletModel->wallet(), updated, status, showTransaction);\n }\n \n void TransactionTableModel::updateConfirmations()\n@@ -608,7 +586,7 @@ QVariant TransactionTableModel::data(const QModelIndex &index, int role) const\n     case WatchonlyDecorationRole:\n         return txWatchonlyDecoration(rec);\n     case LongDescriptionRole:\n-        return priv->describe(rec, walletModel->getOptionsModel()->getDisplayUnit());\n+        return priv->describe(walletModel->node(), walletModel->wallet(), rec, walletModel->getOptionsModel()->getDisplayUnit());\n     case AddressRole:\n         return QString::fromStdString(rec->address);\n     case LabelRole:\n@@ -618,7 +596,7 @@ QVariant TransactionTableModel::data(const QModelIndex &index, int role) const\n     case TxHashRole:\n         return rec->getTxHash();\n     case TxHexRole:\n-        return priv->getTxHex(rec);\n+        return priv->getTxHex(walletModel->wallet(), rec);\n     case TxPlainTextRole:\n         {\n             QString details;\n@@ -694,10 +672,10 @@ QVariant TransactionTableModel::headerData(int section, Qt::Orientation orientat\n QModelIndex TransactionTableModel::index(int row, int column, const QModelIndex &parent) const\n {\n     Q_UNUSED(parent);\n-    TransactionRecord *data = priv->index(row);\n+    TransactionRecord *data = priv->index(walletModel->wallet(), row);\n     if(data)\n     {\n-        return createIndex(row, column, priv->index(row));\n+        return createIndex(row, column, priv->index(walletModel->wallet(), row));\n     }\n     return QModelIndex();\n }\n@@ -735,13 +713,11 @@ struct TransactionNotification\n static bool fQueueNotifications = false;\n static std::vector< TransactionNotification > vQueueNotifications;\n \n-static void NotifyTransactionChanged(TransactionTableModel *ttm, CWallet *wallet, const uint256 &hash, ChangeType status)\n+static void NotifyTransactionChanged(TransactionTableModel *ttm, const uint256 &hash, ChangeType status)\n {\n     // Find transaction in wallet\n-    std::map<uint256, CWalletTx>::iterator mi = wallet->mapWallet.find(hash);\n     // Determine whether to show transaction or not (determine this here so that no relocking is needed in GUI thread)\n-    bool inWallet = mi != wallet->mapWallet.end();\n-    bool showTransaction = (inWallet && TransactionRecord::showTransaction(mi->second));\n+    bool showTransaction = TransactionRecord::showTransaction();\n \n     TransactionNotification notification(hash, status, showTransaction);\n \n@@ -777,13 +753,13 @@ static void ShowProgress(TransactionTableModel *ttm, const std::string &title, i\n void TransactionTableModel::subscribeToCoreSignals()\n {\n     // Connect signals to wallet\n-    wallet->NotifyTransactionChanged.connect(boost::bind(NotifyTransactionChanged, this, _1, _2, _3));\n-    wallet->ShowProgress.connect(boost::bind(ShowProgress, this, _1, _2));\n+    m_handler_transaction_changed = walletModel->wallet().handleTransactionChanged(boost::bind(NotifyTransactionChanged, this, _1, _2));\n+    m_handler_show_progress = walletModel->wallet().handleShowProgress(boost::bind(ShowProgress, this, _1, _2));\n }\n \n void TransactionTableModel::unsubscribeFromCoreSignals()\n {\n     // Disconnect signals from wallet\n-    wallet->NotifyTransactionChanged.disconnect(boost::bind(NotifyTransactionChanged, this, _1, _2, _3));\n-    wallet->ShowProgress.disconnect(boost::bind(ShowProgress, this, _1, _2));\n+    m_handler_transaction_changed->disconnect();\n+    m_handler_show_progress->disconnect();\n }"
      },
      {
        "sha": "8b029be5f546d74b3254761c1491c4a39908ce1a",
        "filename": "src/qt/transactiontablemodel.h",
        "status": "modified",
        "additions": 9,
        "deletions": 4,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/transactiontablemodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/transactiontablemodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiontablemodel.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -10,21 +10,25 @@\n #include <QAbstractTableModel>\n #include <QStringList>\n \n+#include <memory>\n+\n+namespace interfaces {\n+class Handler;\n+}\n+\n class PlatformStyle;\n class TransactionRecord;\n class TransactionTablePriv;\n class WalletModel;\n \n-class CWallet;\n-\n /** UI model for the transaction table of a wallet.\n  */\n class TransactionTableModel : public QAbstractTableModel\n {\n     Q_OBJECT\n \n public:\n-    explicit TransactionTableModel(const PlatformStyle *platformStyle, CWallet* wallet, WalletModel *parent = 0);\n+    explicit TransactionTableModel(const PlatformStyle *platformStyle, WalletModel *parent = 0);\n     ~TransactionTableModel();\n \n     enum ColumnIndex {\n@@ -80,8 +84,9 @@ class TransactionTableModel : public QAbstractTableModel\n     bool processingQueuedTransactions() const { return fProcessingQueuedTransactions; }\n \n private:\n-    CWallet* wallet;\n     WalletModel *walletModel;\n+    std::unique_ptr<interfaces::Handler> m_handler_transaction_changed;\n+    std::unique_ptr<interfaces::Handler> m_handler_show_progress;\n     QStringList columns;\n     TransactionTablePriv *priv;\n     bool fProcessingQueuedTransactions;"
      },
      {
        "sha": "aa6444245a9875c70fbf11c898745de5ddbd2d55",
        "filename": "src/qt/transactionview.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/transactionview.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/transactionview.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionview.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -254,7 +254,7 @@ void TransactionView::setModel(WalletModel *_model)\n         }\n \n         // show/hide column Watch-only\n-        updateWatchOnlyColumn(_model->haveWatchOnly());\n+        updateWatchOnlyColumn(_model->wallet().haveWatchOnly());\n \n         // Watch-only signal\n         connect(_model, SIGNAL(notifyWatchonlyChanged(bool)), this, SLOT(updateWatchOnlyColumn(bool)));\n@@ -364,7 +364,7 @@ void TransactionView::exportClicked()\n     // name, column, role\n     writer.setModel(transactionProxyModel);\n     writer.addColumn(tr(\"Confirmed\"), 0, TransactionTableModel::ConfirmedRole);\n-    if (model->haveWatchOnly())\n+    if (model->wallet().haveWatchOnly())\n         writer.addColumn(tr(\"Watch-only\"), TransactionTableModel::Watchonly);\n     writer.addColumn(tr(\"Date\"), 0, TransactionTableModel::DateRole);\n     writer.addColumn(tr(\"Type\"), TransactionTableModel::Type, Qt::EditRole);\n@@ -393,8 +393,8 @@ void TransactionView::contextualMenu(const QPoint &point)\n     // check if transaction can be abandoned, disable context menu action in case it doesn't\n     uint256 hash;\n     hash.SetHex(selection.at(0).data(TransactionTableModel::TxHashRole).toString().toStdString());\n-    abandonAction->setEnabled(model->transactionCanBeAbandoned(hash));\n-    bumpFeeAction->setEnabled(model->transactionCanBeBumped(hash));\n+    abandonAction->setEnabled(model->wallet().transactionCanBeAbandoned(hash));\n+    bumpFeeAction->setEnabled(model->wallet().transactionCanBeBumped(hash));\n \n     if(index.isValid())\n     {\n@@ -414,7 +414,7 @@ void TransactionView::abandonTx()\n     hash.SetHex(hashQStr.toStdString());\n \n     // Abandon the wallet transaction over the walletModel\n-    model->abandonTransaction(hash);\n+    model->wallet().abandonTransaction(hash);\n \n     // Update the table\n     model->getTransactionTableModel()->updateTransaction(hashQStr, CT_UPDATED, false);"
      },
      {
        "sha": "993d7454d628dd5cccb0b518e563877894b866f9",
        "filename": "src/qt/utilitydialog.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 16,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/utilitydialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/utilitydialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/utilitydialog.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -19,6 +19,7 @@\n \n #include <clientversion.h>\n #include <init.h>\n+#include <interfaces/node.h>\n #include <util.h>\n \n #include <stdio.h>\n@@ -31,7 +32,7 @@\n #include <QVBoxLayout>\n \n /** \"Help message\" or \"About\" dialog box */\n-HelpMessageDialog::HelpMessageDialog(QWidget *parent, bool about) :\n+HelpMessageDialog::HelpMessageDialog(interfaces::Node& node, QWidget *parent, bool about) :\n     QDialog(parent),\n     ui(new Ui::HelpMessageDialog)\n {\n@@ -77,21 +78,7 @@ HelpMessageDialog::HelpMessageDialog(QWidget *parent, bool about) :\n         cursor.insertText(header);\n         cursor.insertBlock();\n \n-        std::string strUsage = HelpMessage(HMM_BITCOIN_QT);\n-        const bool showDebug = gArgs.GetBoolArg(\"-help-debug\", false);\n-        strUsage += HelpMessageGroup(tr(\"UI Options:\").toStdString());\n-        if (showDebug) {\n-            strUsage += HelpMessageOpt(\"-allowselfsignedrootcertificates\", strprintf(\"Allow self signed root certificates (default: %u)\", DEFAULT_SELFSIGNED_ROOTCERTS));\n-        }\n-        strUsage += HelpMessageOpt(\"-choosedatadir\", strprintf(tr(\"Choose data directory on startup (default: %u)\").toStdString(), DEFAULT_CHOOSE_DATADIR));\n-        strUsage += HelpMessageOpt(\"-lang=<lang>\", tr(\"Set language, for example \\\"de_DE\\\" (default: system locale)\").toStdString());\n-        strUsage += HelpMessageOpt(\"-min\", tr(\"Start minimized\").toStdString());\n-        strUsage += HelpMessageOpt(\"-resetguisettings\", tr(\"Reset all settings changed in the GUI\").toStdString());\n-        strUsage += HelpMessageOpt(\"-rootcertificates=<file>\", tr(\"Set SSL root certificates for payment request (default: -system-)\").toStdString());\n-        strUsage += HelpMessageOpt(\"-splash\", strprintf(tr(\"Show splash screen on startup (default: %u)\").toStdString(), DEFAULT_SPLASHSCREEN));\n-        if (showDebug) {\n-            strUsage += HelpMessageOpt(\"-uiplatform\", strprintf(\"Select platform to customize UI for (one of windows, macosx, other; default: %s)\", BitcoinGUI::DEFAULT_UIPLATFORM));\n-        }\n+        std::string strUsage = gArgs.GetHelpMessage();\n         QString coreOptions = QString::fromStdString(strUsage);\n         text = version + \"\\n\" + header + \"\\n\" + coreOptions;\n "
      },
      {
        "sha": "f5c8af43626ecbc0f6b03a02485467bef2bdf9c9",
        "filename": "src/qt/utilitydialog.h",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/utilitydialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/utilitydialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/utilitydialog.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -10,6 +10,10 @@\n \n class BitcoinGUI;\n \n+namespace interfaces {\n+    class Node;\n+}\n+\n namespace Ui {\n     class HelpMessageDialog;\n }\n@@ -20,7 +24,7 @@ class HelpMessageDialog : public QDialog\n     Q_OBJECT\n \n public:\n-    explicit HelpMessageDialog(QWidget *parent, bool about);\n+    explicit HelpMessageDialog(interfaces::Node& node, QWidget *parent, bool about);\n     ~HelpMessageDialog();\n \n     void printToConsole();"
      },
      {
        "sha": "5b13353d7bfc37cb654329381c8fe3332f40efab",
        "filename": "src/qt/walletframe.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 2,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/walletframe.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/walletframe.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletframe.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -3,6 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <qt/walletframe.h>\n+#include <qt/walletmodel.h>\n \n #include <qt/bitcoingui.h>\n #include <qt/walletview.h>\n@@ -39,10 +40,16 @@ void WalletFrame::setClientModel(ClientModel *_clientModel)\n     this->clientModel = _clientModel;\n }\n \n-bool WalletFrame::addWallet(const QString& name, WalletModel *walletModel)\n+bool WalletFrame::addWallet(WalletModel *walletModel)\n {\n-    if (!gui || !clientModel || !walletModel || mapWalletViews.count(name) > 0)\n+    if (!gui || !clientModel || !walletModel) {\n         return false;\n+    }\n+\n+    const QString name = walletModel->getWalletName();\n+    if (mapWalletViews.count(name) > 0) {\n+        return false;\n+    }\n \n     WalletView *walletView = new WalletView(platformStyle, this);\n     walletView->setBitcoinGUI(gui);"
      },
      {
        "sha": "6eedcf370c60c0a6046e5070a164367d471464ed",
        "filename": "src/qt/walletframe.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/walletframe.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/walletframe.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletframe.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -36,7 +36,7 @@ class WalletFrame : public QFrame\n \n     void setClientModel(ClientModel *clientModel);\n \n-    bool addWallet(const QString& name, WalletModel *walletModel);\n+    bool addWallet(WalletModel *walletModel);\n     bool setCurrentWallet(const QString& name);\n     bool removeWallet(const QString &name);\n     void removeAllWallets();\n@@ -59,6 +59,7 @@ class WalletFrame : public QFrame\n \n     const PlatformStyle *platformStyle;\n \n+public:\n     WalletView *currentWalletView();\n \n public Q_SLOTS:"
      },
      {
        "sha": "3418b1f1a9ce30ab087f4c28038075c70be91d98",
        "filename": "src/qt/walletmodel.cpp",
        "status": "modified",
        "additions": 77,
        "deletions": 261,
        "changes": 338,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/walletmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/walletmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -5,29 +5,20 @@\n #include <qt/walletmodel.h>\n \n #include <qt/addresstablemodel.h>\n-#include <consensus/validation.h>\n #include <qt/guiconstants.h>\n-#include <qt/guiutil.h>\n #include <qt/optionsmodel.h>\n #include <qt/paymentserver.h>\n #include <qt/recentrequeststablemodel.h>\n #include <qt/sendcoinsdialog.h>\n #include <qt/transactiontablemodel.h>\n \n-#include <chain.h>\n+#include <interfaces/handler.h>\n+#include <interfaces/node.h>\n #include <key_io.h>\n-#include <keystore.h>\n-#include <validation.h>\n-#include <net.h> // for g_connman\n-#include <policy/fees.h>\n-#include <policy/rbf.h>\n-#include <sync.h>\n #include <ui_interface.h>\n #include <util.h> // for GetBoolArg\n #include <wallet/coincontrol.h>\n-#include <wallet/feebumper.h>\n #include <wallet/wallet.h>\n-#include <wallet/walletdb.h> // for BackupWallet\n \n #include <stdint.h>\n \n@@ -37,21 +28,19 @@\n #include <QTimer>\n \n \n-WalletModel::WalletModel(const PlatformStyle *platformStyle, CWallet *_wallet, OptionsModel *_optionsModel, QObject *parent) :\n-    QObject(parent), wallet(_wallet), optionsModel(_optionsModel), addressTableModel(0),\n+WalletModel::WalletModel(std::unique_ptr<interfaces::Wallet> wallet, interfaces::Node& node, const PlatformStyle *platformStyle, OptionsModel *_optionsModel, QObject *parent) :\n+    QObject(parent), m_wallet(std::move(wallet)), m_node(node), optionsModel(_optionsModel), addressTableModel(0),\n     transactionTableModel(0),\n     recentRequestsTableModel(0),\n-    cachedBalance(0), cachedUnconfirmedBalance(0), cachedImmatureBalance(0),\n-    cachedWatchOnlyBalance{0}, cachedWatchUnconfBalance{0}, cachedWatchImmatureBalance{0},\n     cachedEncryptionStatus(Unencrypted),\n     cachedNumBlocks(0)\n {\n-    fHaveWatchOnly = wallet->HaveWatchOnly();\n+    fHaveWatchOnly = m_wallet->haveWatchOnly();\n     fForceCheckBalanceChanged = false;\n \n-    addressTableModel = new AddressTableModel(wallet, this);\n-    transactionTableModel = new TransactionTableModel(platformStyle, wallet, this);\n-    recentRequestsTableModel = new RecentRequestsTableModel(wallet, this);\n+    addressTableModel = new AddressTableModel(this);\n+    transactionTableModel = new TransactionTableModel(platformStyle, this);\n+    recentRequestsTableModel = new RecentRequestsTableModel(this);\n \n     // This timer will be fired repeatedly to update the balance\n     pollTimer = new QTimer(this);\n@@ -66,105 +55,45 @@ WalletModel::~WalletModel()\n     unsubscribeFromCoreSignals();\n }\n \n-CAmount WalletModel::getBalance(const CCoinControl *coinControl) const\n-{\n-    if (coinControl)\n-    {\n-        return wallet->GetAvailableBalance(coinControl);\n-    }\n-\n-    return wallet->GetBalance();\n-}\n-\n-CAmount WalletModel::getUnconfirmedBalance() const\n-{\n-    return wallet->GetUnconfirmedBalance();\n-}\n-\n-CAmount WalletModel::getImmatureBalance() const\n-{\n-    return wallet->GetImmatureBalance();\n-}\n-\n-bool WalletModel::haveWatchOnly() const\n-{\n-    return fHaveWatchOnly;\n-}\n-\n-CAmount WalletModel::getWatchBalance() const\n-{\n-    return wallet->GetWatchOnlyBalance();\n-}\n-\n-CAmount WalletModel::getWatchUnconfirmedBalance() const\n-{\n-    return wallet->GetUnconfirmedWatchOnlyBalance();\n-}\n-\n-CAmount WalletModel::getWatchImmatureBalance() const\n-{\n-    return wallet->GetImmatureWatchOnlyBalance();\n-}\n-\n void WalletModel::updateStatus()\n {\n     EncryptionStatus newEncryptionStatus = getEncryptionStatus();\n \n-    if(cachedEncryptionStatus != newEncryptionStatus)\n-        Q_EMIT encryptionStatusChanged(newEncryptionStatus);\n+    if(cachedEncryptionStatus != newEncryptionStatus) {\n+        Q_EMIT encryptionStatusChanged();\n+    }\n }\n \n void WalletModel::pollBalanceChanged()\n {\n-    // Get required locks upfront. This avoids the GUI from getting stuck on\n-    // periodical polls if the core is holding the locks for a longer time -\n-    // for example, during a wallet rescan.\n-    TRY_LOCK(cs_main, lockMain);\n-    if(!lockMain)\n-        return;\n-    TRY_LOCK(wallet->cs_wallet, lockWallet);\n-    if(!lockWallet)\n+    // Try to get balances and return early if locks can't be acquired. This\n+    // avoids the GUI from getting stuck on periodical polls if the core is\n+    // holding the locks for a longer time - for example, during a wallet\n+    // rescan.\n+    interfaces::WalletBalances new_balances;\n+    int numBlocks = -1;\n+    if (!m_wallet->tryGetBalances(new_balances, numBlocks)) {\n         return;\n+    }\n \n-    if(fForceCheckBalanceChanged || chainActive.Height() != cachedNumBlocks)\n+    if(fForceCheckBalanceChanged || m_node.getNumBlocks() != cachedNumBlocks)\n     {\n         fForceCheckBalanceChanged = false;\n \n         // Balance and number of transactions might have changed\n-        cachedNumBlocks = chainActive.Height();\n+        cachedNumBlocks = m_node.getNumBlocks();\n \n-        checkBalanceChanged();\n+        checkBalanceChanged(new_balances);\n         if(transactionTableModel)\n             transactionTableModel->updateConfirmations();\n     }\n }\n \n-void WalletModel::checkBalanceChanged()\n+void WalletModel::checkBalanceChanged(const interfaces::WalletBalances& new_balances)\n {\n-    CAmount newBalance = getBalance();\n-    CAmount newUnconfirmedBalance = getUnconfirmedBalance();\n-    CAmount newImmatureBalance = getImmatureBalance();\n-    CAmount newWatchOnlyBalance = 0;\n-    CAmount newWatchUnconfBalance = 0;\n-    CAmount newWatchImmatureBalance = 0;\n-    if (haveWatchOnly())\n-    {\n-        newWatchOnlyBalance = getWatchBalance();\n-        newWatchUnconfBalance = getWatchUnconfirmedBalance();\n-        newWatchImmatureBalance = getWatchImmatureBalance();\n-    }\n-\n-    if(cachedBalance != newBalance || cachedUnconfirmedBalance != newUnconfirmedBalance || cachedImmatureBalance != newImmatureBalance ||\n-        cachedWatchOnlyBalance != newWatchOnlyBalance || cachedWatchUnconfBalance != newWatchUnconfBalance || cachedWatchImmatureBalance != newWatchImmatureBalance)\n-    {\n-        cachedBalance = newBalance;\n-        cachedUnconfirmedBalance = newUnconfirmedBalance;\n-        cachedImmatureBalance = newImmatureBalance;\n-        cachedWatchOnlyBalance = newWatchOnlyBalance;\n-        cachedWatchUnconfBalance = newWatchUnconfBalance;\n-        cachedWatchImmatureBalance = newWatchImmatureBalance;\n-        Q_EMIT balanceChanged(newBalance, newUnconfirmedBalance, newImmatureBalance,\n-                            newWatchOnlyBalance, newWatchUnconfBalance, newWatchImmatureBalance);\n+    if(new_balances.balanceChanged(m_cached_balances)) {\n+        m_cached_balances = new_balances;\n+        Q_EMIT balanceChanged(new_balances);\n     }\n }\n \n@@ -259,30 +188,25 @@ WalletModel::SendCoinsReturn WalletModel::prepareTransaction(WalletModelTransact\n         return DuplicateAddress;\n     }\n \n-    CAmount nBalance = getBalance(&coinControl);\n+    CAmount nBalance = m_wallet->getAvailableBalance(coinControl);\n \n     if(total > nBalance)\n     {\n         return AmountExceedsBalance;\n     }\n \n     {\n-        LOCK2(cs_main, wallet->cs_wallet);\n-\n-        transaction.newPossibleKeyChange(wallet);\n-\n         CAmount nFeeRequired = 0;\n         int nChangePosRet = -1;\n         std::string strFailReason;\n \n-        CTransactionRef& newTx = transaction.getTransaction();\n-        CReserveKey *keyChange = transaction.getPossibleKeyChange();\n-        bool fCreated = wallet->CreateTransaction(vecSend, newTx, *keyChange, nFeeRequired, nChangePosRet, strFailReason, coinControl);\n+        auto& newTx = transaction.getWtx();\n+        newTx = m_wallet->createTransaction(vecSend, coinControl, true /* sign */, nChangePosRet, nFeeRequired, strFailReason);\n         transaction.setTransactionFee(nFeeRequired);\n-        if (fSubtractFeeFromAmount && fCreated)\n+        if (fSubtractFeeFromAmount && newTx)\n             transaction.reassignAmounts(nChangePosRet);\n \n-        if(!fCreated)\n+        if(!newTx)\n         {\n             if(!fSubtractFeeFromAmount && (total + nFeeRequired) > nBalance)\n             {\n@@ -296,7 +220,7 @@ WalletModel::SendCoinsReturn WalletModel::prepareTransaction(WalletModelTransact\n         // reject absurdly high fee. (This can never happen because the\n         // wallet caps the fee at maxTxFee. This merely serves as a\n         // belt-and-suspenders check)\n-        if (nFeeRequired > maxTxFee)\n+        if (nFeeRequired > m_node.getMaxTxFee())\n             return AbsurdFee;\n     }\n \n@@ -308,8 +232,6 @@ WalletModel::SendCoinsReturn WalletModel::sendCoins(WalletModelTransaction &tran\n     QByteArray transaction_array; /* store serialized transaction */\n \n     {\n-        LOCK2(cs_main, wallet->cs_wallet);\n-\n         std::vector<std::pair<std::string, std::string>> vOrderForm;\n         for (const SendCoinsRecipient &rcp : transaction.getRecipients())\n         {\n@@ -329,14 +251,13 @@ WalletModel::SendCoinsReturn WalletModel::sendCoins(WalletModelTransaction &tran\n                 vOrderForm.emplace_back(\"Message\", rcp.message.toStdString());\n         }\n \n-        CTransactionRef& newTx = transaction.getTransaction();\n-        CReserveKey *keyChange = transaction.getPossibleKeyChange();\n-        CValidationState state;\n-        if (!wallet->CommitTransaction(newTx, {} /* mapValue */, std::move(vOrderForm), {} /* fromAccount */, *keyChange, g_connman.get(), state))\n-            return SendCoinsReturn(TransactionCommitFailed, QString::fromStdString(state.GetRejectReason()));\n+        auto& newTx = transaction.getWtx();\n+        std::string rejectReason;\n+        if (!newTx->commit({} /* mapValue */, std::move(vOrderForm), {} /* fromAccount */, rejectReason))\n+            return SendCoinsReturn(TransactionCommitFailed, QString::fromStdString(rejectReason));\n \n         CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n-        ssTx << newTx;\n+        ssTx << newTx->get();\n         transaction_array.append(&(ssTx[0]), ssTx.size());\n     }\n \n@@ -351,24 +272,23 @@ WalletModel::SendCoinsReturn WalletModel::sendCoins(WalletModelTransaction &tran\n             CTxDestination dest = DecodeDestination(strAddress);\n             std::string strLabel = rcp.label.toStdString();\n             {\n-                LOCK(wallet->cs_wallet);\n-\n-                std::map<CTxDestination, CAddressBookData>::iterator mi = wallet->mapAddressBook.find(dest);\n-\n                 // Check if we have a new address or an updated label\n-                if (mi == wallet->mapAddressBook.end())\n+                std::string name;\n+                if (!m_wallet->getAddress(\n+                     dest, &name, /* is_mine= */ nullptr, /* purpose= */ nullptr))\n                 {\n-                    wallet->SetAddressBook(dest, strLabel, \"send\");\n+                    m_wallet->setAddressBook(dest, strLabel, \"send\");\n                 }\n-                else if (mi->second.name != strLabel)\n+                else if (name != strLabel)\n                 {\n-                    wallet->SetAddressBook(dest, strLabel, \"\"); // \"\" means don't change purpose\n+                    m_wallet->setAddressBook(dest, strLabel, \"\"); // \"\" means don't change purpose\n                 }\n             }\n         }\n-        Q_EMIT coinsSent(wallet, rcp, transaction_array);\n+        Q_EMIT coinsSent(this, rcp, transaction_array);\n     }\n-    checkBalanceChanged(); // update balance immediately, otherwise there could be a short noticeable delay until pollBalanceChanged hits\n+\n+    checkBalanceChanged(m_wallet->getBalances()); // update balance immediately, otherwise there could be a short noticeable delay until pollBalanceChanged hits\n \n     return SendCoinsReturn(OK);\n }\n@@ -395,11 +315,11 @@ RecentRequestsTableModel *WalletModel::getRecentRequestsTableModel()\n \n WalletModel::EncryptionStatus WalletModel::getEncryptionStatus() const\n {\n-    if(!wallet->IsCrypted())\n+    if(!m_wallet->isCrypted())\n     {\n         return Unencrypted;\n     }\n-    else if(wallet->IsLocked())\n+    else if(m_wallet->isLocked())\n     {\n         return Locked;\n     }\n@@ -414,7 +334,7 @@ bool WalletModel::setWalletEncrypted(bool encrypted, const SecureString &passphr\n     if(encrypted)\n     {\n         // Encrypt\n-        return wallet->EncryptWallet(passphrase);\n+        return m_wallet->encryptWallet(passphrase);\n     }\n     else\n     {\n@@ -428,39 +348,29 @@ bool WalletModel::setWalletLocked(bool locked, const SecureString &passPhrase)\n     if(locked)\n     {\n         // Lock\n-        return wallet->Lock();\n+        return m_wallet->lock();\n     }\n     else\n     {\n         // Unlock\n-        return wallet->Unlock(passPhrase);\n+        return m_wallet->unlock(passPhrase);\n     }\n }\n \n bool WalletModel::changePassphrase(const SecureString &oldPass, const SecureString &newPass)\n {\n-    bool retval;\n-    {\n-        LOCK(wallet->cs_wallet);\n-        wallet->Lock(); // Make sure wallet is locked before attempting pass change\n-        retval = wallet->ChangeWalletPassphrase(oldPass, newPass);\n-    }\n-    return retval;\n-}\n-\n-bool WalletModel::backupWallet(const QString &filename)\n-{\n-    return wallet->BackupWallet(filename.toLocal8Bit().data());\n+    m_wallet->lock(); // Make sure wallet is locked before attempting pass change\n+    return m_wallet->changeWalletPassphrase(oldPass, newPass);\n }\n \n // Handlers for core signals\n-static void NotifyKeyStoreStatusChanged(WalletModel *walletmodel, CCryptoKeyStore *wallet)\n+static void NotifyKeyStoreStatusChanged(WalletModel *walletmodel)\n {\n     qDebug() << \"NotifyKeyStoreStatusChanged\";\n     QMetaObject::invokeMethod(walletmodel, \"updateStatus\", Qt::QueuedConnection);\n }\n \n-static void NotifyAddressBookChanged(WalletModel *walletmodel, CWallet *wallet,\n+static void NotifyAddressBookChanged(WalletModel *walletmodel,\n         const CTxDestination &address, const std::string &label, bool isMine,\n         const std::string &purpose, ChangeType status)\n {\n@@ -477,9 +387,8 @@ static void NotifyAddressBookChanged(WalletModel *walletmodel, CWallet *wallet,\n                               Q_ARG(int, status));\n }\n \n-static void NotifyTransactionChanged(WalletModel *walletmodel, CWallet *wallet, const uint256 &hash, ChangeType status)\n+static void NotifyTransactionChanged(WalletModel *walletmodel, const uint256 &hash, ChangeType status)\n {\n-    Q_UNUSED(wallet);\n     Q_UNUSED(hash);\n     Q_UNUSED(status);\n     QMetaObject::invokeMethod(walletmodel, \"updateTransaction\", Qt::QueuedConnection);\n@@ -502,21 +411,21 @@ static void NotifyWatchonlyChanged(WalletModel *walletmodel, bool fHaveWatchonly\n void WalletModel::subscribeToCoreSignals()\n {\n     // Connect signals to wallet\n-    wallet->NotifyStatusChanged.connect(boost::bind(&NotifyKeyStoreStatusChanged, this, _1));\n-    wallet->NotifyAddressBookChanged.connect(boost::bind(NotifyAddressBookChanged, this, _1, _2, _3, _4, _5, _6));\n-    wallet->NotifyTransactionChanged.connect(boost::bind(NotifyTransactionChanged, this, _1, _2, _3));\n-    wallet->ShowProgress.connect(boost::bind(ShowProgress, this, _1, _2));\n-    wallet->NotifyWatchonlyChanged.connect(boost::bind(NotifyWatchonlyChanged, this, _1));\n+    m_handler_status_changed = m_wallet->handleStatusChanged(boost::bind(&NotifyKeyStoreStatusChanged, this));\n+    m_handler_address_book_changed = m_wallet->handleAddressBookChanged(boost::bind(NotifyAddressBookChanged, this, _1, _2, _3, _4, _5));\n+    m_handler_transaction_changed = m_wallet->handleTransactionChanged(boost::bind(NotifyTransactionChanged, this, _1, _2));\n+    m_handler_show_progress = m_wallet->handleShowProgress(boost::bind(ShowProgress, this, _1, _2));\n+    m_handler_watch_only_changed = m_wallet->handleWatchOnlyChanged(boost::bind(NotifyWatchonlyChanged, this, _1));\n }\n \n void WalletModel::unsubscribeFromCoreSignals()\n {\n     // Disconnect signals from wallet\n-    wallet->NotifyStatusChanged.disconnect(boost::bind(&NotifyKeyStoreStatusChanged, this, _1));\n-    wallet->NotifyAddressBookChanged.disconnect(boost::bind(NotifyAddressBookChanged, this, _1, _2, _3, _4, _5, _6));\n-    wallet->NotifyTransactionChanged.disconnect(boost::bind(NotifyTransactionChanged, this, _1, _2, _3));\n-    wallet->ShowProgress.disconnect(boost::bind(ShowProgress, this, _1, _2));\n-    wallet->NotifyWatchonlyChanged.disconnect(boost::bind(NotifyWatchonlyChanged, this, _1));\n+    m_handler_status_changed->disconnect();\n+    m_handler_address_book_changed->disconnect();\n+    m_handler_transaction_changed->disconnect();\n+    m_handler_show_progress->disconnect();\n+    m_handler_watch_only_changed->disconnect();\n }\n \n // WalletModel::UnlockContext implementation\n@@ -556,80 +465,9 @@ void WalletModel::UnlockContext::CopyFrom(const UnlockContext& rhs)\n     rhs.relock = false;\n }\n \n-bool WalletModel::getPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const\n-{\n-    return wallet->GetPubKey(address, vchPubKeyOut);\n-}\n-\n-bool WalletModel::IsSpendable(const CTxDestination& dest) const\n-{\n-    return IsMine(*wallet, dest) & ISMINE_SPENDABLE;\n-}\n-\n-bool WalletModel::getPrivKey(const CKeyID &address, CKey& vchPrivKeyOut) const\n-{\n-    return wallet->GetKey(address, vchPrivKeyOut);\n-}\n-\n-// returns a list of COutputs from COutPoints\n-void WalletModel::getOutputs(const std::vector<COutPoint>& vOutpoints, std::vector<COutput>& vOutputs)\n-{\n-    LOCK2(cs_main, wallet->cs_wallet);\n-    for (const COutPoint& outpoint : vOutpoints)\n-    {\n-        auto it = wallet->mapWallet.find(outpoint.hash);\n-        if (it == wallet->mapWallet.end()) continue;\n-        int nDepth = it->second.GetDepthInMainChain();\n-        if (nDepth < 0) continue;\n-        COutput out(&it->second, outpoint.n, nDepth, true /* spendable */, true /* solvable */, true /* safe */);\n-        vOutputs.push_back(out);\n-    }\n-}\n-\n-bool WalletModel::isSpent(const COutPoint& outpoint) const\n-{\n-    LOCK2(cs_main, wallet->cs_wallet);\n-    return wallet->IsSpent(outpoint.hash, outpoint.n);\n-}\n-\n-// AvailableCoins + LockedCoins grouped by wallet address (put change in one group with wallet address)\n-void WalletModel::listCoins(std::map<QString, std::vector<COutput> >& mapCoins) const\n-{\n-    for (auto& group : wallet->ListCoins()) {\n-        auto& resultGroup = mapCoins[QString::fromStdString(EncodeDestination(group.first))];\n-        for (auto& coin : group.second) {\n-            resultGroup.emplace_back(std::move(coin));\n-        }\n-    }\n-}\n-\n-bool WalletModel::isLockedCoin(uint256 hash, unsigned int n) const\n-{\n-    LOCK2(cs_main, wallet->cs_wallet);\n-    return wallet->IsLockedCoin(hash, n);\n-}\n-\n-void WalletModel::lockCoin(COutPoint& output)\n-{\n-    LOCK2(cs_main, wallet->cs_wallet);\n-    wallet->LockCoin(output);\n-}\n-\n-void WalletModel::unlockCoin(COutPoint& output)\n-{\n-    LOCK2(cs_main, wallet->cs_wallet);\n-    wallet->UnlockCoin(output);\n-}\n-\n-void WalletModel::listLockedCoins(std::vector<COutPoint>& vOutpts)\n-{\n-    LOCK2(cs_main, wallet->cs_wallet);\n-    wallet->ListLockedCoins(vOutpts);\n-}\n-\n void WalletModel::loadReceiveRequests(std::vector<std::string>& vReceiveRequests)\n {\n-    vReceiveRequests = wallet->GetDestValues(\"rr\"); // receive request\n+    vReceiveRequests = m_wallet->getDestValues(\"rr\"); // receive request\n }\n \n bool WalletModel::saveReceiveRequest(const std::string &sAddress, const int64_t nId, const std::string &sRequest)\n@@ -640,38 +478,21 @@ bool WalletModel::saveReceiveRequest(const std::string &sAddress, const int64_t\n     ss << nId;\n     std::string key = \"rr\" + ss.str(); // \"rr\" prefix = \"receive request\" in destdata\n \n-    LOCK(wallet->cs_wallet);\n     if (sRequest.empty())\n-        return wallet->EraseDestData(dest, key);\n+        return m_wallet->eraseDestData(dest, key);\n     else\n-        return wallet->AddDestData(dest, key, sRequest);\n-}\n-\n-bool WalletModel::transactionCanBeAbandoned(uint256 hash) const\n-{\n-    return wallet->TransactionCanBeAbandoned(hash);\n-}\n-\n-bool WalletModel::abandonTransaction(uint256 hash) const\n-{\n-    LOCK2(cs_main, wallet->cs_wallet);\n-    return wallet->AbandonTransaction(hash);\n-}\n-\n-bool WalletModel::transactionCanBeBumped(uint256 hash) const\n-{\n-    return feebumper::TransactionCanBeBumped(wallet, hash);\n+        return m_wallet->addDestData(dest, key, sRequest);\n }\n \n bool WalletModel::bumpFee(uint256 hash)\n {\n     CCoinControl coin_control;\n-    coin_control.signalRbf = true;\n+    coin_control.m_signal_bip125_rbf = true;\n     std::vector<std::string> errors;\n     CAmount old_fee;\n     CAmount new_fee;\n     CMutableTransaction mtx;\n-    if (feebumper::CreateTransaction(wallet, hash, coin_control, 0 /* totalFee */, errors, old_fee, new_fee, mtx) != feebumper::Result::OK) {\n+    if (!m_wallet->createBumpTransaction(hash, coin_control, 0 /* totalFee */, errors, old_fee, new_fee, mtx)) {\n         QMessageBox::critical(0, tr(\"Fee bump error\"), tr(\"Increasing transaction fee failed\") + \"<br />(\" +\n             (errors.size() ? QString::fromStdString(errors[0]) : \"\") +\")\");\n          return false;\n@@ -710,13 +531,13 @@ bool WalletModel::bumpFee(uint256 hash)\n     }\n \n     // sign bumped transaction\n-    if (!feebumper::SignTransaction(wallet, mtx)) {\n+    if (!m_wallet->signBumpTransaction(mtx)) {\n         QMessageBox::critical(0, tr(\"Fee bump error\"), tr(\"Can't sign transaction.\"));\n         return false;\n     }\n     // commit the bumped transaction\n     uint256 txid;\n-    if (feebumper::CommitTransaction(wallet, hash, std::move(mtx), errors, txid) != feebumper::Result::OK) {\n+    if(!m_wallet->commitBumpTransaction(hash, std::move(mtx), errors, txid)) {\n         QMessageBox::critical(0, tr(\"Fee bump error\"), tr(\"Could not commit transaction\") + \"<br />(\" +\n             QString::fromStdString(errors[0])+\")\");\n          return false;\n@@ -729,17 +550,12 @@ bool WalletModel::isWalletEnabled()\n    return !gArgs.GetBoolArg(\"-disablewallet\", DEFAULT_DISABLE_WALLET);\n }\n \n-bool WalletModel::hdEnabled() const\n-{\n-    return wallet->IsHDEnabled();\n-}\n-\n-OutputType WalletModel::getDefaultAddressType() const\n+QString WalletModel::getWalletName() const\n {\n-    return wallet->m_default_address_type;\n+    return QString::fromStdString(m_wallet->getWalletName());\n }\n \n-int WalletModel::getDefaultConfirmTarget() const\n+bool WalletModel::isMultiwallet()\n {\n-    return nTxConfirmTarget;\n+    return m_node.getWallets().size() > 1;\n }"
      },
      {
        "sha": "9173fcae52db11cf0bc42bec0578316c313467a3",
        "filename": "src/qt/walletmodel.h",
        "status": "modified",
        "additions": 24,
        "deletions": 42,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/walletmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/walletmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -13,6 +13,7 @@\n #include <qt/paymentrequestplus.h>\n #include <qt/walletmodeltransaction.h>\n \n+#include <interfaces/wallet.h>\n #include <support/allocators/secure.h>\n \n #include <map>\n@@ -34,9 +35,12 @@ class CKeyID;\n class COutPoint;\n class COutput;\n class CPubKey;\n-class CWallet;\n class uint256;\n \n+namespace interfaces {\n+class Node;\n+} // namespace interfaces\n+\n QT_BEGIN_NAMESPACE\n class QTimer;\n QT_END_NAMESPACE\n@@ -107,7 +111,7 @@ class WalletModel : public QObject\n     Q_OBJECT\n \n public:\n-    explicit WalletModel(const PlatformStyle *platformStyle, CWallet *wallet, OptionsModel *optionsModel, QObject *parent = 0);\n+    explicit WalletModel(std::unique_ptr<interfaces::Wallet> wallet, interfaces::Node& node, const PlatformStyle *platformStyle, OptionsModel *optionsModel, QObject *parent = 0);\n     ~WalletModel();\n \n     enum StatusCode // Returned by sendCoins\n@@ -136,13 +140,6 @@ class WalletModel : public QObject\n     TransactionTableModel *getTransactionTableModel();\n     RecentRequestsTableModel *getRecentRequestsTableModel();\n \n-    CAmount getBalance(const CCoinControl *coinControl = nullptr) const;\n-    CAmount getUnconfirmedBalance() const;\n-    CAmount getImmatureBalance() const;\n-    bool haveWatchOnly() const;\n-    CAmount getWatchBalance() const;\n-    CAmount getWatchUnconfirmedBalance() const;\n-    CAmount getWatchImmatureBalance() const;\n     EncryptionStatus getEncryptionStatus() const;\n \n     // Check address for validity\n@@ -171,8 +168,6 @@ class WalletModel : public QObject\n     // Passphrase only needed when unlocking\n     bool setWalletLocked(bool locked, const SecureString &passPhrase=SecureString());\n     bool changePassphrase(const SecureString &oldPass, const SecureString &newPass);\n-    // Wallet backup\n-    bool backupWallet(const QString &filename);\n \n     // RAI object for unlocking wallet, returned by requestUnlock()\n     class UnlockContext\n@@ -196,37 +191,30 @@ class WalletModel : public QObject\n \n     UnlockContext requestUnlock();\n \n-    bool getPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const;\n-    bool IsSpendable(const CTxDestination& dest) const;\n-    bool getPrivKey(const CKeyID &address, CKey& vchPrivKeyOut) const;\n-    void getOutputs(const std::vector<COutPoint>& vOutpoints, std::vector<COutput>& vOutputs);\n-    bool isSpent(const COutPoint& outpoint) const;\n-    void listCoins(std::map<QString, std::vector<COutput> >& mapCoins) const;\n-\n-    bool isLockedCoin(uint256 hash, unsigned int n) const;\n-    void lockCoin(COutPoint& output);\n-    void unlockCoin(COutPoint& output);\n-    void listLockedCoins(std::vector<COutPoint>& vOutpts);\n-\n     void loadReceiveRequests(std::vector<std::string>& vReceiveRequests);\n     bool saveReceiveRequest(const std::string &sAddress, const int64_t nId, const std::string &sRequest);\n \n-    bool transactionCanBeAbandoned(uint256 hash) const;\n-    bool abandonTransaction(uint256 hash) const;\n-\n-    bool transactionCanBeBumped(uint256 hash) const;\n     bool bumpFee(uint256 hash);\n \n     static bool isWalletEnabled();\n \n-    bool hdEnabled() const;\n+    interfaces::Node& node() const { return m_node; }\n+    interfaces::Wallet& wallet() const { return *m_wallet; }\n \n-    OutputType getDefaultAddressType() const;\n+    QString getWalletName() const;\n \n-    int getDefaultConfirmTarget() const;\n+    bool isMultiwallet();\n \n+    AddressTableModel* getAddressTableModel() const { return addressTableModel; }\n private:\n-    CWallet *wallet;\n+    std::unique_ptr<interfaces::Wallet> m_wallet;\n+    std::unique_ptr<interfaces::Handler> m_handler_status_changed;\n+    std::unique_ptr<interfaces::Handler> m_handler_address_book_changed;\n+    std::unique_ptr<interfaces::Handler> m_handler_transaction_changed;\n+    std::unique_ptr<interfaces::Handler> m_handler_show_progress;\n+    std::unique_ptr<interfaces::Handler> m_handler_watch_only_changed;\n+    interfaces::Node& m_node;\n+\n     bool fHaveWatchOnly;\n     bool fForceCheckBalanceChanged;\n \n@@ -239,28 +227,22 @@ class WalletModel : public QObject\n     RecentRequestsTableModel *recentRequestsTableModel;\n \n     // Cache some values to be able to detect changes\n-    CAmount cachedBalance;\n-    CAmount cachedUnconfirmedBalance;\n-    CAmount cachedImmatureBalance;\n-    CAmount cachedWatchOnlyBalance;\n-    CAmount cachedWatchUnconfBalance;\n-    CAmount cachedWatchImmatureBalance;\n+    interfaces::WalletBalances m_cached_balances;\n     EncryptionStatus cachedEncryptionStatus;\n     int cachedNumBlocks;\n \n     QTimer *pollTimer;\n \n     void subscribeToCoreSignals();\n     void unsubscribeFromCoreSignals();\n-    void checkBalanceChanged();\n+    void checkBalanceChanged(const interfaces::WalletBalances& new_balances);\n \n Q_SIGNALS:\n     // Signal that balance in wallet changed\n-    void balanceChanged(const CAmount& balance, const CAmount& unconfirmedBalance, const CAmount& immatureBalance,\n-                        const CAmount& watchOnlyBalance, const CAmount& watchUnconfBalance, const CAmount& watchImmatureBalance);\n+    void balanceChanged(const interfaces::WalletBalances& balances);\n \n     // Encryption status of wallet changed\n-    void encryptionStatusChanged(int status);\n+    void encryptionStatusChanged();\n \n     // Signal emitted when wallet needs to be unlocked\n     // It is valid behaviour for listeners to keep the wallet locked after this signal;\n@@ -271,7 +253,7 @@ class WalletModel : public QObject\n     void message(const QString &title, const QString &message, unsigned int style);\n \n     // Coins sent: from wallet, to recipient, in (serialized) transaction:\n-    void coinsSent(CWallet* wallet, SendCoinsRecipient recipient, QByteArray transaction);\n+    void coinsSent(WalletModel* wallet, SendCoinsRecipient recipient, QByteArray transaction);\n \n     // Show progress dialog e.g. for rescan\n     void showProgress(const QString &title, int nProgress);"
      },
      {
        "sha": "d5187d6634e87d8061e603483135159a55f3bdc6",
        "filename": "src/qt/walletmodeltransaction.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 15,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/walletmodeltransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/walletmodeltransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodeltransaction.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -4,12 +4,11 @@\n \n #include <qt/walletmodeltransaction.h>\n \n+#include <interfaces/node.h>\n #include <policy/policy.h>\n-#include <wallet/wallet.h>\n \n WalletModelTransaction::WalletModelTransaction(const QList<SendCoinsRecipient> &_recipients) :\n     recipients(_recipients),\n-    walletTransaction(0),\n     fee(0)\n {\n }\n@@ -19,14 +18,14 @@ QList<SendCoinsRecipient> WalletModelTransaction::getRecipients() const\n     return recipients;\n }\n \n-CTransactionRef& WalletModelTransaction::getTransaction()\n+std::unique_ptr<interfaces::PendingWalletTx>& WalletModelTransaction::getWtx()\n {\n-    return walletTransaction;\n+    return wtx;\n }\n \n unsigned int WalletModelTransaction::getTransactionSize()\n {\n-    return (!walletTransaction ? 0 : ::GetVirtualTransactionSize(*walletTransaction));\n+    return wtx ? wtx->getVirtualSize() : 0;\n }\n \n CAmount WalletModelTransaction::getTransactionFee() const\n@@ -41,6 +40,7 @@ void WalletModelTransaction::setTransactionFee(const CAmount& newFee)\n \n void WalletModelTransaction::reassignAmounts(int nChangePosRet)\n {\n+    const CTransaction* walletTransaction = &wtx->get();\n     int i = 0;\n     for (QList<SendCoinsRecipient>::iterator it = recipients.begin(); it != recipients.end(); ++it)\n     {\n@@ -80,13 +80,3 @@ CAmount WalletModelTransaction::getTotalTransactionAmount() const\n     }\n     return totalTransactionAmount;\n }\n-\n-void WalletModelTransaction::newPossibleKeyChange(CWallet *wallet)\n-{\n-    keyChange.reset(new CReserveKey(wallet));\n-}\n-\n-CReserveKey *WalletModelTransaction::getPossibleKeyChange()\n-{\n-    return keyChange.get();\n-}"
      },
      {
        "sha": "9f9132610998d648c4ead4c878676d8aabba02f1",
        "filename": "src/qt/walletmodeltransaction.h",
        "status": "modified",
        "additions": 8,
        "deletions": 9,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/walletmodeltransaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/walletmodeltransaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodeltransaction.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -7,13 +7,16 @@\n \n #include <qt/walletmodel.h>\n \n+#include <memory>\n+\n #include <QObject>\n \n class SendCoinsRecipient;\n \n-class CReserveKey;\n-class CWallet;\n-class CWalletTx;\n+namespace interfaces {\n+class Node;\n+class PendingWalletTx;\n+}\n \n /** Data model for a walletmodel transaction. */\n class WalletModelTransaction\n@@ -23,23 +26,19 @@ class WalletModelTransaction\n \n     QList<SendCoinsRecipient> getRecipients() const;\n \n-    CTransactionRef& getTransaction();\n+    std::unique_ptr<interfaces::PendingWalletTx>& getWtx();\n     unsigned int getTransactionSize();\n \n     void setTransactionFee(const CAmount& newFee);\n     CAmount getTransactionFee() const;\n \n     CAmount getTotalTransactionAmount() const;\n \n-    void newPossibleKeyChange(CWallet *wallet);\n-    CReserveKey *getPossibleKeyChange();\n-\n     void reassignAmounts(int nChangePosRet); // needed for the subtract-fee-from-amount feature\n \n private:\n     QList<SendCoinsRecipient> recipients;\n-    CTransactionRef walletTransaction;\n-    std::unique_ptr<CReserveKey> keyChange;\n+    std::unique_ptr<interfaces::PendingWalletTx> wtx;\n     CAmount fee;\n };\n "
      },
      {
        "sha": "d529595dec22070e03d58bc752a8cb8438f68091",
        "filename": "src/qt/walletview.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 12,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/walletview.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/walletview.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletview.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -19,6 +19,7 @@\n #include <qt/transactionview.h>\n #include <qt/walletmodel.h>\n \n+#include <interfaces/node.h>\n #include <ui_interface.h>\n \n #include <QAction>\n@@ -101,13 +102,13 @@ void WalletView::setBitcoinGUI(BitcoinGUI *gui)\n         connect(this, SIGNAL(message(QString,QString,unsigned int)), gui, SLOT(message(QString,QString,unsigned int)));\n \n         // Pass through encryption status changed signals\n-        connect(this, SIGNAL(encryptionStatusChanged(int)), gui, SLOT(setEncryptionStatus(int)));\n+        connect(this, SIGNAL(encryptionStatusChanged()), gui, SLOT(updateWalletStatus()));\n \n         // Pass through transaction notifications\n-        connect(this, SIGNAL(incomingTransaction(QString,int,CAmount,QString,QString,QString)), gui, SLOT(incomingTransaction(QString,int,CAmount,QString,QString,QString)));\n+        connect(this, SIGNAL(incomingTransaction(QString,int,CAmount,QString,QString,QString,QString)), gui, SLOT(incomingTransaction(QString,int,CAmount,QString,QString,QString,QString)));\n \n         // Connect HD enabled state signal \n-        connect(this, SIGNAL(hdEnabledStatusChanged(int)), gui, SLOT(setHDStatus(int)));\n+        connect(this, SIGNAL(hdEnabledStatusChanged()), gui, SLOT(updateWalletStatus()));\n     }\n }\n \n@@ -137,11 +138,11 @@ void WalletView::setWalletModel(WalletModel *_walletModel)\n         connect(_walletModel, SIGNAL(message(QString,QString,unsigned int)), this, SIGNAL(message(QString,QString,unsigned int)));\n \n         // Handle changes in encryption status\n-        connect(_walletModel, SIGNAL(encryptionStatusChanged(int)), this, SIGNAL(encryptionStatusChanged(int)));\n+        connect(_walletModel, SIGNAL(encryptionStatusChanged()), this, SIGNAL(encryptionStatusChanged()));\n         updateEncryptionStatus();\n \n         // update HD status\n-        Q_EMIT hdEnabledStatusChanged(_walletModel->hdEnabled());\n+        Q_EMIT hdEnabledStatusChanged();\n \n         // Balloon pop-up for new transaction\n         connect(_walletModel->getTransactionTableModel(), SIGNAL(rowsInserted(QModelIndex,int,int)),\n@@ -158,7 +159,7 @@ void WalletView::setWalletModel(WalletModel *_walletModel)\n void WalletView::processNewTransaction(const QModelIndex& parent, int start, int /*end*/)\n {\n     // Prevent balloon-spam when initial block download is in progress\n-    if (!walletModel || !clientModel || clientModel->inInitialBlockDownload())\n+    if (!walletModel || !clientModel || clientModel->node().isInitialBlockDownload())\n         return;\n \n     TransactionTableModel *ttm = walletModel->getTransactionTableModel();\n@@ -172,7 +173,7 @@ void WalletView::processNewTransaction(const QModelIndex& parent, int start, int\n     QString address = ttm->data(index, TransactionTableModel::AddressRole).toString();\n     QString label = ttm->data(index, TransactionTableModel::LabelRole).toString();\n \n-    Q_EMIT incomingTransaction(date, walletModel->getOptionsModel()->getDisplayUnit(), amount, type, address, label);\n+    Q_EMIT incomingTransaction(date, walletModel->getOptionsModel()->getDisplayUnit(), amount, type, address, label, walletModel->getWalletName());\n }\n \n void WalletView::gotoOverviewPage()\n@@ -234,7 +235,7 @@ void WalletView::showOutOfSyncWarning(bool fShow)\n \n void WalletView::updateEncryptionStatus()\n {\n-    Q_EMIT encryptionStatusChanged(walletModel->getEncryptionStatus());\n+    Q_EMIT encryptionStatusChanged();\n }\n \n void WalletView::encryptWallet(bool status)\n@@ -257,7 +258,7 @@ void WalletView::backupWallet()\n     if (filename.isEmpty())\n         return;\n \n-    if (!walletModel->backupWallet(filename)) {\n+    if (!walletModel->wallet().backupWallet(filename.toLocal8Bit().data())) {\n         Q_EMIT message(tr(\"Backup Failed\"), tr(\"There was an error trying to save the wallet data to %1.\").arg(filename),\n             CClientUIInterface::MSG_ERROR);\n         }\n@@ -314,9 +315,9 @@ void WalletView::showProgress(const QString &title, int nProgress)\n         progressDialog = new QProgressDialog(title, \"\", 0, 100);\n         progressDialog->setWindowModality(Qt::ApplicationModal);\n         progressDialog->setMinimumDuration(0);\n-        progressDialog->setCancelButton(0);\n         progressDialog->setAutoClose(false);\n         progressDialog->setValue(0);\n+        progressDialog->setCancelButtonText(tr(\"Cancel\"));\n     }\n     else if (nProgress == 100)\n     {\n@@ -326,8 +327,13 @@ void WalletView::showProgress(const QString &title, int nProgress)\n             progressDialog->deleteLater();\n         }\n     }\n-    else if (progressDialog)\n-        progressDialog->setValue(nProgress);\n+    else if (progressDialog) {\n+        if (progressDialog->wasCanceled()) {\n+            getWalletModel()->wallet().abortRescan();\n+        } else {\n+            progressDialog->setValue(nProgress);\n+        }\n+    }\n }\n \n void WalletView::requestedSyncWarningInfo()"
      },
      {
        "sha": "878a5966d607dde258f295b9527e0864d847a195",
        "filename": "src/qt/walletview.h",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/walletview.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/qt/walletview.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletview.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -44,6 +44,7 @@ class WalletView : public QStackedWidget\n         The client model represents the part of the core that communicates with the P2P network, and is wallet-agnostic.\n     */\n     void setClientModel(ClientModel *clientModel);\n+    WalletModel *getWalletModel() { return walletModel; }\n     /** Set the wallet model.\n         The wallet model represents a bitcoin wallet, and offers access to the list of transactions, address book and sending\n         functionality.\n@@ -119,11 +120,11 @@ public Q_SLOTS:\n     /**  Fired when a message should be reported to the user */\n     void message(const QString &title, const QString &message, unsigned int style);\n     /** Encryption status of wallet changed */\n-    void encryptionStatusChanged(int status);\n+    void encryptionStatusChanged();\n     /** HD-Enabled status of wallet changed (only possible during startup) */\n-    void hdEnabledStatusChanged(int hdEnabled);\n+    void hdEnabledStatusChanged();\n     /** Notify that a new transaction appeared */\n-    void incomingTransaction(const QString& date, int unit, const CAmount& amount, const QString& type, const QString& address, const QString& label);\n+    void incomingTransaction(const QString& date, int unit, const CAmount& amount, const QString& type, const QString& address, const QString& label, const QString& walletName);\n     /** Notify that the out of sync warning icon has been pressed */\n     void outOfSyncWarningClicked();\n };"
      },
      {
        "sha": "4ba86e4e7ac5a957ef2c7a9b03a9fc17a456f3cc",
        "filename": "src/random.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/random.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/random.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/random.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -15,7 +15,6 @@\n #include <utilstrencodings.h> // for GetTime()\n \n #include <stdlib.h>\n-#include <limits>\n #include <chrono>\n #include <thread>\n \n@@ -179,7 +178,7 @@ static void RandAddSeedPerfmon()\n /** Fallback: get 32 bytes of system entropy from /dev/urandom. The most\n  * compatible way to get cryptographic randomness on UNIX-ish platforms.\n  */\n-void GetDevURandom(unsigned char *ent32)\n+static void GetDevURandom(unsigned char *ent32)\n {\n     int f = open(\"/dev/urandom\", O_RDONLY);\n     if (f == -1) {"
      },
      {
        "sha": "ffa75c241f0be60f02bd2e6d1b11874008e95d05",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 54,
        "deletions": 47,
        "changes": 101,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -6,6 +6,7 @@\n #include <chain.h>\n #include <chainparams.h>\n #include <core_io.h>\n+#include <index/txindex.h>\n #include <primitives/block.h>\n #include <primitives/transaction.h>\n #include <validation.h>\n@@ -24,21 +25,21 @@\n \n static const size_t MAX_GETUTXOS_OUTPOINTS = 15; //allow a max of 15 outpoints to be queried at once\n \n-enum RetFormat {\n-    RF_UNDEF,\n-    RF_BINARY,\n-    RF_HEX,\n-    RF_JSON,\n+enum class RetFormat {\n+    UNDEF,\n+    BINARY,\n+    HEX,\n+    JSON,\n };\n \n static const struct {\n-    enum RetFormat rf;\n+    RetFormat rf;\n     const char* name;\n } rf_names[] = {\n-      {RF_UNDEF, \"\"},\n-      {RF_BINARY, \"bin\"},\n-      {RF_HEX, \"hex\"},\n-      {RF_JSON, \"json\"},\n+      {RetFormat::UNDEF, \"\"},\n+      {RetFormat::BINARY, \"bin\"},\n+      {RetFormat::HEX, \"hex\"},\n+      {RetFormat::JSON, \"json\"},\n };\n \n struct CCoin {\n@@ -67,7 +68,7 @@ static bool RESTERR(HTTPRequest* req, enum HTTPStatusCode status, std::string me\n     return false;\n }\n \n-static enum RetFormat ParseDataFormat(std::string& param, const std::string& strReq)\n+static RetFormat ParseDataFormat(std::string& param, const std::string& strReq)\n {\n     const std::string::size_type pos = strReq.rfind('.');\n     if (pos == std::string::npos)\n@@ -162,20 +163,20 @@ static bool rest_headers(HTTPRequest* req,\n     }\n \n     switch (rf) {\n-    case RF_BINARY: {\n+    case RetFormat::BINARY: {\n         std::string binaryHeader = ssHeader.str();\n         req->WriteHeader(\"Content-Type\", \"application/octet-stream\");\n         req->WriteReply(HTTP_OK, binaryHeader);\n         return true;\n     }\n \n-    case RF_HEX: {\n+    case RetFormat::HEX: {\n         std::string strHex = HexStr(ssHeader.begin(), ssHeader.end()) + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"text/plain\");\n         req->WriteReply(HTTP_OK, strHex);\n         return true;\n     }\n-    case RF_JSON: {\n+    case RetFormat::JSON: {\n         UniValue jsonHeaders(UniValue::VARR);\n         {\n             LOCK(cs_main);\n@@ -227,21 +228,21 @@ static bool rest_block(HTTPRequest* req,\n     ssBlock << block;\n \n     switch (rf) {\n-    case RF_BINARY: {\n+    case RetFormat::BINARY: {\n         std::string binaryBlock = ssBlock.str();\n         req->WriteHeader(\"Content-Type\", \"application/octet-stream\");\n         req->WriteReply(HTTP_OK, binaryBlock);\n         return true;\n     }\n \n-    case RF_HEX: {\n+    case RetFormat::HEX: {\n         std::string strHex = HexStr(ssBlock.begin(), ssBlock.end()) + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"text/plain\");\n         req->WriteReply(HTTP_OK, strHex);\n         return true;\n     }\n \n-    case RF_JSON: {\n+    case RetFormat::JSON: {\n         UniValue objBlock;\n         {\n             LOCK(cs_main);\n@@ -280,7 +281,7 @@ static bool rest_chaininfo(HTTPRequest* req, const std::string& strURIPart)\n     const RetFormat rf = ParseDataFormat(param, strURIPart);\n \n     switch (rf) {\n-    case RF_JSON: {\n+    case RetFormat::JSON: {\n         JSONRPCRequest jsonRequest;\n         jsonRequest.params = UniValue(UniValue::VARR);\n         UniValue chainInfoObject = getblockchaininfo(jsonRequest);\n@@ -303,7 +304,7 @@ static bool rest_mempool_info(HTTPRequest* req, const std::string& strURIPart)\n     const RetFormat rf = ParseDataFormat(param, strURIPart);\n \n     switch (rf) {\n-    case RF_JSON: {\n+    case RetFormat::JSON: {\n         UniValue mempoolInfoObject = mempoolInfoToJSON();\n \n         std::string strJSON = mempoolInfoObject.write() + \"\\n\";\n@@ -325,7 +326,7 @@ static bool rest_mempool_contents(HTTPRequest* req, const std::string& strURIPar\n     const RetFormat rf = ParseDataFormat(param, strURIPart);\n \n     switch (rf) {\n-    case RF_JSON: {\n+    case RetFormat::JSON: {\n         UniValue mempoolObject = mempoolToJSON(true);\n \n         std::string strJSON = mempoolObject.write() + \"\\n\";\n@@ -350,6 +351,10 @@ static bool rest_tx(HTTPRequest* req, const std::string& strURIPart)\n     if (!ParseHashStr(hashStr, hash))\n         return RESTERR(req, HTTP_BAD_REQUEST, \"Invalid hash: \" + hashStr);\n \n+    if (g_txindex) {\n+        g_txindex->BlockUntilSyncedToCurrentChain();\n+    }\n+\n     CTransactionRef tx;\n     uint256 hashBlock = uint256();\n     if (!GetTransaction(hash, tx, Params().GetConsensus(), hashBlock, true))\n@@ -359,21 +364,21 @@ static bool rest_tx(HTTPRequest* req, const std::string& strURIPart)\n     ssTx << tx;\n \n     switch (rf) {\n-    case RF_BINARY: {\n+    case RetFormat::BINARY: {\n         std::string binaryTx = ssTx.str();\n         req->WriteHeader(\"Content-Type\", \"application/octet-stream\");\n         req->WriteReply(HTTP_OK, binaryTx);\n         return true;\n     }\n \n-    case RF_HEX: {\n+    case RetFormat::HEX: {\n         std::string strHex = HexStr(ssTx.begin(), ssTx.end()) + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"text/plain\");\n         req->WriteReply(HTTP_OK, strHex);\n         return true;\n     }\n \n-    case RF_JSON: {\n+    case RetFormat::JSON: {\n         UniValue objTx(UniValue::VOBJ);\n         TxToUniv(*tx, hashBlock, objTx);\n         std::string strJSON = objTx.write() + \"\\n\";\n@@ -440,13 +445,13 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n     }\n \n     switch (rf) {\n-    case RF_HEX: {\n+    case RetFormat::HEX: {\n         // convert hex to bin, continue then with bin part\n         std::vector<unsigned char> strRequestV = ParseHex(strRequestMutable);\n         strRequestMutable.assign(strRequestV.begin(), strRequestV.end());\n     }\n \n-    case RF_BINARY: {\n+    case RetFormat::BINARY: {\n         try {\n             //deserialize only if user sent a request\n             if (strRequestMutable.size() > 0)\n@@ -466,7 +471,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n         break;\n     }\n \n-    case RF_JSON: {\n+    case RetFormat::JSON: {\n         if (!fInputParsed)\n             return RESTERR(req, HTTP_BAD_REQUEST, \"Error: empty request\");\n         break;\n@@ -487,33 +492,35 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n     std::vector<bool> hits;\n     bitmap.resize((vOutPoints.size() + 7) / 8);\n     {\n-        LOCK2(cs_main, mempool.cs);\n-\n-        CCoinsView viewDummy;\n-        CCoinsViewCache view(&viewDummy);\n-\n-        CCoinsViewCache& viewChain = *pcoinsTip;\n-        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n-\n-        if (fCheckMemPool)\n-            view.SetBackend(viewMempool); // switch cache backend to db+mempool in case user likes to query mempool\n-\n-        for (size_t i = 0; i < vOutPoints.size(); i++) {\n-            bool hit = false;\n-            Coin coin;\n-            if (view.GetCoin(vOutPoints[i], coin) && !mempool.isSpent(vOutPoints[i])) {\n-                hit = true;\n-                outs.emplace_back(std::move(coin));\n+        auto process_utxos = [&vOutPoints, &outs, &hits](const CCoinsView& view, const CTxMemPool& mempool) {\n+            for (const COutPoint& vOutPoint : vOutPoints) {\n+                Coin coin;\n+                bool hit = !mempool.isSpent(vOutPoint) && view.GetCoin(vOutPoint, coin);\n+                hits.push_back(hit);\n+                if (hit) outs.emplace_back(std::move(coin));\n             }\n+        };\n+\n+        if (fCheckMemPool) {\n+            // use db+mempool as cache backend in case user likes to query mempool\n+            LOCK2(cs_main, mempool.cs);\n+            CCoinsViewCache& viewChain = *pcoinsTip;\n+            CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+            process_utxos(viewMempool, mempool);\n+        } else {\n+            LOCK(cs_main);  // no need to lock mempool!\n+            process_utxos(*pcoinsTip, CTxMemPool());\n+        }\n \n-            hits.push_back(hit);\n+        for (size_t i = 0; i < hits.size(); ++i) {\n+            const bool hit = hits[i];\n             bitmapStringRepresentation.append(hit ? \"1\" : \"0\"); // form a binary string representation (human-readable for json output)\n             bitmap[i / 8] |= ((uint8_t)hit) << (i % 8);\n         }\n     }\n \n     switch (rf) {\n-    case RF_BINARY: {\n+    case RetFormat::BINARY: {\n         // serialize data\n         // use exact same output as mentioned in Bip64\n         CDataStream ssGetUTXOResponse(SER_NETWORK, PROTOCOL_VERSION);\n@@ -525,7 +532,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n         return true;\n     }\n \n-    case RF_HEX: {\n+    case RetFormat::HEX: {\n         CDataStream ssGetUTXOResponse(SER_NETWORK, PROTOCOL_VERSION);\n         ssGetUTXOResponse << chainActive.Height() << chainActive.Tip()->GetBlockHash() << bitmap << outs;\n         std::string strHex = HexStr(ssGetUTXOResponse.begin(), ssGetUTXOResponse.end()) + \"\\n\";\n@@ -535,7 +542,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n         return true;\n     }\n \n-    case RF_JSON: {\n+    case RetFormat::JSON: {\n         UniValue objGetUTXOResponse(UniValue::VOBJ);\n \n         // pack in some essentials"
      },
      {
        "sha": "238d8c9d95d39dde7a8dab679c2440a4e8577dc6",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 62,
        "deletions": 46,
        "changes": 108,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -33,6 +33,7 @@\n \n #include <boost/thread/thread.hpp> // boost::thread::interrupt\n \n+#include <memory>\n #include <mutex>\n #include <condition_variable>\n \n@@ -46,8 +47,6 @@ static std::mutex cs_blockchange;\n static std::condition_variable cond_blockchange;\n static CUpdatedBlock latestblock;\n \n-extern void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue& entry);\n-\n /* Calculate the difficulty for a given block index,\n  * or the block index of the given chain.\n  */\n@@ -158,7 +157,7 @@ UniValue blockToJSON(const CBlock& block, const CBlockIndex* blockindex, bool tx\n     return result;\n }\n \n-UniValue getblockcount(const JSONRPCRequest& request)\n+static UniValue getblockcount(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n         throw std::runtime_error(\n@@ -175,7 +174,7 @@ UniValue getblockcount(const JSONRPCRequest& request)\n     return chainActive.Height();\n }\n \n-UniValue getbestblockhash(const JSONRPCRequest& request)\n+static UniValue getbestblockhash(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n         throw std::runtime_error(\n@@ -202,7 +201,7 @@ void RPCNotifyBlockChange(bool ibd, const CBlockIndex * pindex)\n     cond_blockchange.notify_all();\n }\n \n-UniValue waitfornewblock(const JSONRPCRequest& request)\n+static UniValue waitfornewblock(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() > 1)\n         throw std::runtime_error(\n@@ -240,7 +239,7 @@ UniValue waitfornewblock(const JSONRPCRequest& request)\n     return ret;\n }\n \n-UniValue waitforblock(const JSONRPCRequest& request)\n+static UniValue waitforblock(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n         throw std::runtime_error(\n@@ -282,7 +281,7 @@ UniValue waitforblock(const JSONRPCRequest& request)\n     return ret;\n }\n \n-UniValue waitforblockheight(const JSONRPCRequest& request)\n+static UniValue waitforblockheight(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n         throw std::runtime_error(\n@@ -324,7 +323,7 @@ UniValue waitforblockheight(const JSONRPCRequest& request)\n     return ret;\n }\n \n-UniValue syncwithvalidationinterfacequeue(const JSONRPCRequest& request)\n+static UniValue syncwithvalidationinterfacequeue(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() > 0) {\n         throw std::runtime_error(\n@@ -339,7 +338,7 @@ UniValue syncwithvalidationinterfacequeue(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n-UniValue getdifficulty(const JSONRPCRequest& request)\n+static UniValue getdifficulty(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n         throw std::runtime_error(\n@@ -356,20 +355,26 @@ UniValue getdifficulty(const JSONRPCRequest& request)\n     return GetDifficulty();\n }\n \n-std::string EntryDescriptionString()\n+static std::string EntryDescriptionString()\n {\n     return \"    \\\"size\\\" : n,             (numeric) virtual transaction size as defined in BIP 141. This is different from actual serialized size for witness transactions as witness data is discounted.\\n\"\n-           \"    \\\"fee\\\" : n,              (numeric) transaction fee in \" + CURRENCY_UNIT + \"\\n\"\n-           \"    \\\"modifiedfee\\\" : n,      (numeric) transaction fee with fee deltas used for mining priority\\n\"\n+           \"    \\\"fee\\\" : n,              (numeric) transaction fee in \" + CURRENCY_UNIT + \" (DEPRECATED)\\n\"\n+           \"    \\\"modifiedfee\\\" : n,      (numeric) transaction fee with fee deltas used for mining priority (DEPRECATED)\\n\"\n            \"    \\\"time\\\" : n,             (numeric) local time transaction entered pool in seconds since 1 Jan 1970 GMT\\n\"\n            \"    \\\"height\\\" : n,           (numeric) block height when transaction entered pool\\n\"\n            \"    \\\"descendantcount\\\" : n,  (numeric) number of in-mempool descendant transactions (including this one)\\n\"\n            \"    \\\"descendantsize\\\" : n,   (numeric) virtual transaction size of in-mempool descendants (including this one)\\n\"\n-           \"    \\\"descendantfees\\\" : n,   (numeric) modified fees (see above) of in-mempool descendants (including this one)\\n\"\n+           \"    \\\"descendantfees\\\" : n,   (numeric) modified fees (see above) of in-mempool descendants (including this one) (DEPRECATED)\\n\"\n            \"    \\\"ancestorcount\\\" : n,    (numeric) number of in-mempool ancestor transactions (including this one)\\n\"\n            \"    \\\"ancestorsize\\\" : n,     (numeric) virtual transaction size of in-mempool ancestors (including this one)\\n\"\n-           \"    \\\"ancestorfees\\\" : n,     (numeric) modified fees (see above) of in-mempool ancestors (including this one)\\n\"\n+           \"    \\\"ancestorfees\\\" : n,     (numeric) modified fees (see above) of in-mempool ancestors (including this one) (DEPRECATED)\\n\"\n            \"    \\\"wtxid\\\" : hash,         (string) hash of serialized transaction, including witness data\\n\"\n+           \"    \\\"fees\\\" : {\\n\"\n+           \"        \\\"base\\\" : n,         (numeric) transaction fee in \" + CURRENCY_UNIT + \"\\n\"\n+           \"        \\\"modified\\\" : n,     (numeric) transaction fee with fee deltas used for mining priority in \" + CURRENCY_UNIT + \"\\n\"\n+           \"        \\\"ancestor\\\" : n,     (numeric) modified fees (see above) of in-mempool ancestors (including this one) in \" + CURRENCY_UNIT + \"\\n\"\n+           \"        \\\"descendant\\\" : n,   (numeric) modified fees (see above) of in-mempool descendants (including this one) in \" + CURRENCY_UNIT + \"\\n\"\n+           \"    }\\n\"\n            \"    \\\"depends\\\" : [           (array) unconfirmed transactions used as inputs for this transaction\\n\"\n            \"        \\\"transactionid\\\",    (string) parent transaction id\\n\"\n            \"       ... ]\\n\"\n@@ -378,10 +383,17 @@ std::string EntryDescriptionString()\n            \"       ... ]\\n\";\n }\n \n-void entryToJSON(UniValue &info, const CTxMemPoolEntry &e)\n+static void entryToJSON(UniValue &info, const CTxMemPoolEntry &e) EXCLUSIVE_LOCKS_REQUIRED(::mempool.cs)\n {\n     AssertLockHeld(mempool.cs);\n \n+    UniValue fees(UniValue::VOBJ);\n+    fees.pushKV(\"base\", ValueFromAmount(e.GetFee()));\n+    fees.pushKV(\"modified\", ValueFromAmount(e.GetModifiedFee()));\n+    fees.pushKV(\"ancestor\", ValueFromAmount(e.GetModFeesWithAncestors()));\n+    fees.pushKV(\"descendant\", ValueFromAmount(e.GetModFeesWithDescendants()));\n+    info.pushKV(\"fees\", fees);\n+\n     info.pushKV(\"size\", (int)e.GetTxSize());\n     info.pushKV(\"fee\", ValueFromAmount(e.GetFee()));\n     info.pushKV(\"modifiedfee\", ValueFromAmount(e.GetModifiedFee()));\n@@ -448,7 +460,7 @@ UniValue mempoolToJSON(bool fVerbose)\n     }\n }\n \n-UniValue getrawmempool(const JSONRPCRequest& request)\n+static UniValue getrawmempool(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() > 1)\n         throw std::runtime_error(\n@@ -480,7 +492,7 @@ UniValue getrawmempool(const JSONRPCRequest& request)\n     return mempoolToJSON(fVerbose);\n }\n \n-UniValue getmempoolancestors(const JSONRPCRequest& request)\n+static UniValue getmempoolancestors(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2) {\n         throw std::runtime_error(\n@@ -544,7 +556,7 @@ UniValue getmempoolancestors(const JSONRPCRequest& request)\n     }\n }\n \n-UniValue getmempooldescendants(const JSONRPCRequest& request)\n+static UniValue getmempooldescendants(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2) {\n         throw std::runtime_error(\n@@ -608,7 +620,7 @@ UniValue getmempooldescendants(const JSONRPCRequest& request)\n     }\n }\n \n-UniValue getmempoolentry(const JSONRPCRequest& request)\n+static UniValue getmempoolentry(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1) {\n         throw std::runtime_error(\n@@ -641,7 +653,7 @@ UniValue getmempoolentry(const JSONRPCRequest& request)\n     return info;\n }\n \n-UniValue getblockhash(const JSONRPCRequest& request)\n+static UniValue getblockhash(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n         throw std::runtime_error(\n@@ -666,7 +678,7 @@ UniValue getblockhash(const JSONRPCRequest& request)\n     return pblockindex->GetBlockHash().GetHex();\n }\n \n-UniValue getblockheader(const JSONRPCRequest& request)\n+static UniValue getblockheader(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n         throw std::runtime_error(\n@@ -725,7 +737,7 @@ UniValue getblockheader(const JSONRPCRequest& request)\n     return blockheaderToJSON(pblockindex);\n }\n \n-UniValue getblock(const JSONRPCRequest& request)\n+static UniValue getblock(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n         throw std::runtime_error(\n@@ -887,7 +899,7 @@ static bool GetUTXOStats(CCoinsView *view, CCoinsStats &stats)\n     return true;\n }\n \n-UniValue pruneblockchain(const JSONRPCRequest& request)\n+static UniValue pruneblockchain(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n         throw std::runtime_error(\n@@ -928,15 +940,15 @@ UniValue pruneblockchain(const JSONRPCRequest& request)\n     else if (height > chainHeight)\n         throw JSONRPCError(RPC_INVALID_PARAMETER, \"Blockchain is shorter than the attempted prune height.\");\n     else if (height > chainHeight - MIN_BLOCKS_TO_KEEP) {\n-        LogPrint(BCLog::RPC, \"Attempt to prune blocks close to the tip.  Retaining the minimum number of blocks.\");\n+        LogPrint(BCLog::RPC, \"Attempt to prune blocks close to the tip.  Retaining the minimum number of blocks.\\n\");\n         height = chainHeight - MIN_BLOCKS_TO_KEEP;\n     }\n \n     PruneBlockFilesManual(height);\n     return uint64_t(height);\n }\n \n-UniValue gettxoutsetinfo(const JSONRPCRequest& request)\n+static UniValue gettxoutsetinfo(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n         throw std::runtime_error(\n@@ -946,9 +958,9 @@ UniValue gettxoutsetinfo(const JSONRPCRequest& request)\n             \"\\nResult:\\n\"\n             \"{\\n\"\n             \"  \\\"height\\\":n,     (numeric) The current block height (index)\\n\"\n-            \"  \\\"bestblock\\\": \\\"hex\\\",   (string) the best block hash hex\\n\"\n-            \"  \\\"transactions\\\": n,      (numeric) The number of transactions\\n\"\n-            \"  \\\"txouts\\\": n,            (numeric) The number of output transactions\\n\"\n+            \"  \\\"bestblock\\\": \\\"hex\\\",   (string) The hash of the block at the tip of the chain\\n\"\n+            \"  \\\"transactions\\\": n,      (numeric) The number of transactions with unspent outputs\\n\"\n+            \"  \\\"txouts\\\": n,            (numeric) The number of unspent transaction outputs\\n\"\n             \"  \\\"bogosize\\\": n,          (numeric) A meaningless metric for UTXO set size\\n\"\n             \"  \\\"hash_serialized_2\\\": \\\"hash\\\", (string) The serialized hash\\n\"\n             \"  \\\"disk_size\\\": n,         (numeric) The estimated size of the chainstate on disk\\n\"\n@@ -991,7 +1003,7 @@ UniValue gettxout(const JSONRPCRequest& request)\n             \"     Note that an unspent output that is spent in the mempool won't appear.\\n\"\n             \"\\nResult:\\n\"\n             \"{\\n\"\n-            \"  \\\"bestblock\\\" : \\\"hash\\\",    (string) the block hash\\n\"\n+            \"  \\\"bestblock\\\":  \\\"hash\\\",    (string) The hash of the block at the tip of the chain\\n\"\n             \"  \\\"confirmations\\\" : n,       (numeric) The number of confirmations\\n\"\n             \"  \\\"value\\\" : x.xxx,           (numeric) The transaction value in \" + CURRENCY_UNIT + \"\\n\"\n             \"  \\\"scriptPubKey\\\" : {         (json object)\\n\"\n@@ -1057,7 +1069,7 @@ UniValue gettxout(const JSONRPCRequest& request)\n     return ret;\n }\n \n-UniValue verifychain(const JSONRPCRequest& request)\n+static UniValue verifychain(const JSONRPCRequest& request)\n {\n     int nCheckLevel = gArgs.GetArg(\"-checklevel\", DEFAULT_CHECKLEVEL);\n     int nCheckDepth = gArgs.GetArg(\"-checkblocks\", DEFAULT_CHECKBLOCKS);\n@@ -1120,20 +1132,20 @@ static UniValue BIP9SoftForkDesc(const Consensus::Params& consensusParams, Conse\n     UniValue rv(UniValue::VOBJ);\n     const ThresholdState thresholdState = VersionBitsTipState(consensusParams, id);\n     switch (thresholdState) {\n-    case THRESHOLD_DEFINED: rv.pushKV(\"status\", \"defined\"); break;\n-    case THRESHOLD_STARTED: rv.pushKV(\"status\", \"started\"); break;\n-    case THRESHOLD_LOCKED_IN: rv.pushKV(\"status\", \"locked_in\"); break;\n-    case THRESHOLD_ACTIVE: rv.pushKV(\"status\", \"active\"); break;\n-    case THRESHOLD_FAILED: rv.pushKV(\"status\", \"failed\"); break;\n+    case ThresholdState::DEFINED: rv.pushKV(\"status\", \"defined\"); break;\n+    case ThresholdState::STARTED: rv.pushKV(\"status\", \"started\"); break;\n+    case ThresholdState::LOCKED_IN: rv.pushKV(\"status\", \"locked_in\"); break;\n+    case ThresholdState::ACTIVE: rv.pushKV(\"status\", \"active\"); break;\n+    case ThresholdState::FAILED: rv.pushKV(\"status\", \"failed\"); break;\n     }\n-    if (THRESHOLD_STARTED == thresholdState)\n+    if (ThresholdState::STARTED == thresholdState)\n     {\n         rv.pushKV(\"bit\", consensusParams.vDeployments[id].bit);\n     }\n     rv.pushKV(\"startTime\", consensusParams.vDeployments[id].nStartTime);\n     rv.pushKV(\"timeout\", consensusParams.vDeployments[id].nTimeout);\n     rv.pushKV(\"since\", VersionBitsTipStateSinceHeight(consensusParams, id));\n-    if (THRESHOLD_STARTED == thresholdState)\n+    if (ThresholdState::STARTED == thresholdState)\n     {\n         UniValue statsUV(UniValue::VOBJ);\n         BIP9Stats statsStruct = VersionBitsTipStatistics(consensusParams, id);\n@@ -1147,7 +1159,7 @@ static UniValue BIP9SoftForkDesc(const Consensus::Params& consensusParams, Conse\n     return rv;\n }\n \n-void BIP9SoftForkDescPushBack(UniValue& bip9_softforks, const Consensus::Params& consensusParams, Consensus::DeploymentPos id)\n+static void BIP9SoftForkDescPushBack(UniValue& bip9_softforks, const Consensus::Params& consensusParams, Consensus::DeploymentPos id)\n {\n     // Deployments with timeout value of 0 are hidden.\n     // A timeout value of 0 guarantees a softfork will never be activated.\n@@ -1273,7 +1285,7 @@ struct CompareBlocksByHeight\n     }\n };\n \n-UniValue getchaintips(const JSONRPCRequest& request)\n+static UniValue getchaintips(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n         throw std::runtime_error(\n@@ -1390,7 +1402,7 @@ UniValue mempoolInfoToJSON()\n     return ret;\n }\n \n-UniValue getmempoolinfo(const JSONRPCRequest& request)\n+static UniValue getmempoolinfo(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n         throw std::runtime_error(\n@@ -1413,7 +1425,7 @@ UniValue getmempoolinfo(const JSONRPCRequest& request)\n     return mempoolInfoToJSON();\n }\n \n-UniValue preciousblock(const JSONRPCRequest& request)\n+static UniValue preciousblock(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n         throw std::runtime_error(\n@@ -1451,7 +1463,7 @@ UniValue preciousblock(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n-UniValue invalidateblock(const JSONRPCRequest& request)\n+static UniValue invalidateblock(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n         throw std::runtime_error(\n@@ -1490,7 +1502,7 @@ UniValue invalidateblock(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n-UniValue reconsiderblock(const JSONRPCRequest& request)\n+static UniValue reconsiderblock(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n         throw std::runtime_error(\n@@ -1528,7 +1540,7 @@ UniValue reconsiderblock(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n-UniValue getchaintxstats(const JSONRPCRequest& request)\n+static UniValue getchaintxstats(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() > 2)\n         throw std::runtime_error(\n@@ -1602,18 +1614,22 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n-UniValue savemempool(const JSONRPCRequest& request)\n+static UniValue savemempool(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0) {\n         throw std::runtime_error(\n             \"savemempool\\n\"\n-            \"\\nDumps the mempool to disk.\\n\"\n+            \"\\nDumps the mempool to disk. It will fail until the previous dump is fully loaded.\\n\"\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"savemempool\", \"\")\n             + HelpExampleRpc(\"savemempool\", \"\")\n         );\n     }\n \n+    if (!g_is_mempool_loaded) {\n+        throw JSONRPCError(RPC_MISC_ERROR, \"The mempool was not loaded yet\");\n+    }\n+\n     if (!DumpMempool()) {\n         throw JSONRPCError(RPC_MISC_ERROR, \"Unable to dump mempool to disk\");\n     }"
      },
      {
        "sha": "34c41b3b6be001d74a38dd97662657dd376628ab",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -51,6 +51,7 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"listreceivedbylabel\", 0, \"minconf\" },\n     { \"listreceivedbylabel\", 1, \"include_empty\" },\n     { \"listreceivedbylabel\", 2, \"include_watchonly\" },\n+    { \"getlabeladdress\", 1, \"force\" },\n     { \"getbalance\", 1, \"minconf\" },\n     { \"getbalance\", 2, \"include_watchonly\" },\n     { \"getblockhash\", 0, \"height\" },\n@@ -103,6 +104,8 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"signrawtransactionwithkey\", 2, \"prevtxs\" },\n     { \"signrawtransactionwithwallet\", 1, \"prevtxs\" },\n     { \"sendrawtransaction\", 1, \"allowhighfees\" },\n+    { \"testmempoolaccept\", 0, \"rawtxs\" },\n+    { \"testmempoolaccept\", 1, \"allowhighfees\" },\n     { \"combinerawtransaction\", 0, \"txs\" },\n     { \"fundrawtransaction\", 1, \"options\" },\n     { \"fundrawtransaction\", 2, \"iswitness\" },"
      },
      {
        "sha": "e09e1dedf37ac9ee69617a7d01ec9a8e52b4661b",
        "filename": "src/rpc/client.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/rpc/client.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/rpc/client.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -3,8 +3,8 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#ifndef BITCOIN_RPCCLIENT_H\n-#define BITCOIN_RPCCLIENT_H\n+#ifndef BITCOIN_RPC_CLIENT_H\n+#define BITCOIN_RPC_CLIENT_H\n \n #include <univalue.h>\n \n@@ -19,4 +19,4 @@ UniValue RPCConvertNamedValues(const std::string& strMethod, const std::vector<s\n  */\n UniValue ParseNonRFCJSONValue(const std::string& strVal);\n \n-#endif // BITCOIN_RPCCLIENT_H\n+#endif // BITCOIN_RPC_CLIENT_H"
      },
      {
        "sha": "45ec501b9d26e7f7f1cc63323ac5ee9b62ccc119",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 21,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -44,7 +44,7 @@ unsigned int ParseConfirmTarget(const UniValue& value)\n  * or from the last difficulty change if 'lookup' is nonpositive.\n  * If 'height' is nonnegative, compute the estimate at the time when a given block was found.\n  */\n-UniValue GetNetworkHashPS(int lookup, int height) {\n+static UniValue GetNetworkHashPS(int lookup, int height) {\n     CBlockIndex *pb = chainActive.Tip();\n \n     if (height >= 0 && height < chainActive.Height())\n@@ -81,7 +81,7 @@ UniValue GetNetworkHashPS(int lookup, int height) {\n     return workDiff.getdouble() / timeDiff;\n }\n \n-UniValue getnetworkhashps(const JSONRPCRequest& request)\n+static UniValue getnetworkhashps(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() > 2)\n         throw std::runtime_error(\n@@ -116,7 +116,7 @@ UniValue generateBlocks(std::shared_ptr<CReserveScript> coinbaseScript, int nGen\n     }\n     unsigned int nExtraNonce = 0;\n     UniValue blockHashes(UniValue::VARR);\n-    while (nHeight < nHeightEnd)\n+    while (nHeight < nHeightEnd && !ShutdownRequested())\n     {\n         std::unique_ptr<CBlockTemplate> pblocktemplate(BlockAssembler(Params()).CreateNewBlock(coinbaseScript->reserveScript));\n         if (!pblocktemplate.get())\n@@ -151,7 +151,7 @@ UniValue generateBlocks(std::shared_ptr<CReserveScript> coinbaseScript, int nGen\n     return blockHashes;\n }\n \n-UniValue generatetoaddress(const JSONRPCRequest& request)\n+static UniValue generatetoaddress(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n         throw std::runtime_error(\n@@ -185,7 +185,7 @@ UniValue generatetoaddress(const JSONRPCRequest& request)\n     return generateBlocks(coinbaseScript, nGenerate, nMaxTries, false);\n }\n \n-UniValue getmininginfo(const JSONRPCRequest& request)\n+static UniValue getmininginfo(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n         throw std::runtime_error(\n@@ -224,7 +224,7 @@ UniValue getmininginfo(const JSONRPCRequest& request)\n \n \n // NOTE: Unlike wallet RPC (which use BTC values), mining RPCs follow GBT (BIP 22) in using satoshi amounts\n-UniValue prioritisetransaction(const JSONRPCRequest& request)\n+static UniValue prioritisetransaction(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 3)\n         throw std::runtime_error(\n@@ -235,6 +235,7 @@ UniValue prioritisetransaction(const JSONRPCRequest& request)\n             \"2. dummy          (numeric, optional) API-Compatibility for previous API. Must be zero or null.\\n\"\n             \"                  DEPRECATED. For forward compatibility use named arguments and omit this parameter.\\n\"\n             \"3. fee_delta      (numeric, required) The fee value (in satoshis) to add (or subtract, if negative).\\n\"\n+            \"                  Note, that this value is not a fee rate. It is a value to modify absolute fee of the TX.\\n\"\n             \"                  The fee is not actually paid, only the algorithm for selecting transactions into a block\\n\"\n             \"                  considers the transaction as it would have paid a higher (or lower) fee.\\n\"\n             \"\\nResult:\\n\"\n@@ -277,7 +278,7 @@ static UniValue BIP22ValidationResult(const CValidationState& state)\n     return \"valid?\";\n }\n \n-std::string gbt_vb_name(const Consensus::DeploymentPos pos) {\n+static std::string gbt_vb_name(const Consensus::DeploymentPos pos) {\n     const struct VBDeploymentInfo& vbinfo = VersionBitsDeploymentInfo[pos];\n     std::string s = vbinfo.name;\n     if (!vbinfo.gbt_force) {\n@@ -286,7 +287,7 @@ std::string gbt_vb_name(const Consensus::DeploymentPos pos) {\n     return s;\n }\n \n-UniValue getblocktemplate(const JSONRPCRequest& request)\n+static UniValue getblocktemplate(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() > 1)\n         throw std::runtime_error(\n@@ -470,10 +471,10 @@ UniValue getblocktemplate(const JSONRPCRequest& request)\n         {\n             checktxtime = std::chrono::steady_clock::now() + std::chrono::minutes(1);\n \n-            WaitableLock lock(csBestBlock);\n-            while (chainActive.Tip()->GetBlockHash() == hashWatchedChain && IsRPCRunning())\n+            WaitableLock lock(g_best_block_mutex);\n+            while (g_best_block == hashWatchedChain && IsRPCRunning())\n             {\n-                if (cvBlockChange.wait_until(lock, checktxtime) == std::cv_status::timeout)\n+                if (g_best_block_cv.wait_until(lock, checktxtime) == std::cv_status::timeout)\n                 {\n                     // Timeout: Check transactions for update\n                     if (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLastLP)\n@@ -532,7 +533,7 @@ UniValue getblocktemplate(const JSONRPCRequest& request)\n     pblock->nNonce = 0;\n \n     // NOTE: If at some point we support pre-segwit miners post-segwit-activation, this needs to take segwit support into consideration\n-    const bool fPreSegWit = (THRESHOLD_ACTIVE != VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_SEGWIT, versionbitscache));\n+    const bool fPreSegWit = (ThresholdState::ACTIVE != VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_SEGWIT, versionbitscache));\n \n     UniValue aCaps(UniValue::VARR); aCaps.push_back(\"proposal\");\n \n@@ -593,15 +594,15 @@ UniValue getblocktemplate(const JSONRPCRequest& request)\n         Consensus::DeploymentPos pos = Consensus::DeploymentPos(j);\n         ThresholdState state = VersionBitsState(pindexPrev, consensusParams, pos, versionbitscache);\n         switch (state) {\n-            case THRESHOLD_DEFINED:\n-            case THRESHOLD_FAILED:\n+            case ThresholdState::DEFINED:\n+            case ThresholdState::FAILED:\n                 // Not exposed to GBT at all\n                 break;\n-            case THRESHOLD_LOCKED_IN:\n+            case ThresholdState::LOCKED_IN:\n                 // Ensure bit is set in block version\n                 pblock->nVersion |= VersionBitsMask(consensusParams, pos);\n                 // FALL THROUGH to get vbavailable set...\n-            case THRESHOLD_STARTED:\n+            case ThresholdState::STARTED:\n             {\n                 const struct VBDeploymentInfo& vbinfo = VersionBitsDeploymentInfo[pos];\n                 vbavailable.pushKV(gbt_vb_name(pos), consensusParams.vDeployments[pos].bit);\n@@ -613,7 +614,7 @@ UniValue getblocktemplate(const JSONRPCRequest& request)\n                 }\n                 break;\n             }\n-            case THRESHOLD_ACTIVE:\n+            case ThresholdState::ACTIVE:\n             {\n                 // Add to rules only\n                 const struct VBDeploymentInfo& vbinfo = VersionBitsDeploymentInfo[pos];\n@@ -693,7 +694,7 @@ class submitblock_StateCatcher : public CValidationInterface\n     }\n };\n \n-UniValue submitblock(const JSONRPCRequest& request)\n+static UniValue submitblock(const JSONRPCRequest& request)\n {\n     // We allow 2 arguments for compliance with BIP22. Argument 2 is ignored.\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2) {\n@@ -763,13 +764,13 @@ UniValue submitblock(const JSONRPCRequest& request)\n     return BIP22ValidationResult(sc.state);\n }\n \n-UniValue estimatefee(const JSONRPCRequest& request)\n+static UniValue estimatefee(const JSONRPCRequest& request)\n {\n     throw JSONRPCError(RPC_METHOD_DEPRECATED, \"estimatefee was removed in v0.17.\\n\"\n         \"Clients should use estimatesmartfee.\");\n }\n \n-UniValue estimatesmartfee(const JSONRPCRequest& request)\n+static UniValue estimatesmartfee(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n         throw std::runtime_error(\n@@ -830,7 +831,7 @@ UniValue estimatesmartfee(const JSONRPCRequest& request)\n     return result;\n }\n \n-UniValue estimaterawfee(const JSONRPCRequest& request)\n+static UniValue estimaterawfee(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n         throw std::runtime_error("
      },
      {
        "sha": "6772784d3db11a32e82abf7b74ba329c84855359",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 26,
        "changes": 53,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -33,7 +33,7 @@\n \n #include <univalue.h>\n \n-UniValue validateaddress(const JSONRPCRequest& request)\n+static UniValue validateaddress(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n         throw std::runtime_error(\n@@ -69,7 +69,7 @@ UniValue validateaddress(const JSONRPCRequest& request)\n     {\n \n #ifdef ENABLE_WALLET\n-        if (!::vpwallets.empty() && IsDeprecatedRPCEnabled(\"validateaddress\")) {\n+        if (HasWallets() && IsDeprecatedRPCEnabled(\"validateaddress\")) {\n             ret.pushKVs(getaddressinfo(request));\n         }\n #endif\n@@ -90,7 +90,7 @@ UniValue validateaddress(const JSONRPCRequest& request)\n // Needed even with !ENABLE_WALLET, to pass (ignored) pointers around\n class CWallet;\n \n-UniValue createmultisig(const JSONRPCRequest& request)\n+static UniValue createmultisig(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 2 || request.params.size() > 2)\n     {\n@@ -145,7 +145,7 @@ UniValue createmultisig(const JSONRPCRequest& request)\n     return result;\n }\n \n-UniValue verifymessage(const JSONRPCRequest& request)\n+static UniValue verifymessage(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 3)\n         throw std::runtime_error(\n@@ -201,7 +201,7 @@ UniValue verifymessage(const JSONRPCRequest& request)\n     return (pubkey.GetID() == *keyID);\n }\n \n-UniValue signmessagewithprivkey(const JSONRPCRequest& request)\n+static UniValue signmessagewithprivkey(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 2)\n         throw std::runtime_error(\n@@ -240,7 +240,7 @@ UniValue signmessagewithprivkey(const JSONRPCRequest& request)\n     return EncodeBase64(vchSig.data(), vchSig.size());\n }\n \n-UniValue setmocktime(const JSONRPCRequest& request)\n+static UniValue setmocktime(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n         throw std::runtime_error(\n@@ -299,7 +299,7 @@ static std::string RPCMallocInfo()\n }\n #endif\n \n-UniValue getmemoryinfo(const JSONRPCRequest& request)\n+static UniValue getmemoryinfo(const JSONRPCRequest& request)\n {\n     /* Please, avoid using the word \"pool\" here in the RPC interface or help,\n      * as users will undoubtedly confuse it with the other \"memory pool\"\n@@ -346,21 +346,22 @@ UniValue getmemoryinfo(const JSONRPCRequest& request)\n     }\n }\n \n-uint32_t getCategoryMask(UniValue cats) {\n+static void EnableOrDisableLogCategories(UniValue cats, bool enable) {\n     cats = cats.get_array();\n-    uint32_t mask = 0;\n     for (unsigned int i = 0; i < cats.size(); ++i) {\n-        uint32_t flag = 0;\n         std::string cat = cats[i].get_str();\n-        if (!GetLogCategory(&flag, &cat)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"unknown logging category \" + cat);\n+\n+        bool success;\n+        if (enable) {\n+            success = g_logger->EnableCategory(cat);\n+        } else {\n+            success = g_logger->DisableCategory(cat);\n         }\n-        if (flag == BCLog::NONE) {\n-            return 0;\n+\n+        if (!success) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"unknown logging category \" + cat);\n         }\n-        mask |= flag;\n     }\n-    return mask;\n }\n \n UniValue logging(const JSONRPCRequest& request)\n@@ -399,25 +400,25 @@ UniValue logging(const JSONRPCRequest& request)\n         );\n     }\n \n-    uint32_t originalLogCategories = logCategories;\n+    uint32_t original_log_categories = g_logger->GetCategoryMask();\n     if (request.params[0].isArray()) {\n-        logCategories |= getCategoryMask(request.params[0]);\n+        EnableOrDisableLogCategories(request.params[0], true);\n     }\n-\n     if (request.params[1].isArray()) {\n-        logCategories &= ~getCategoryMask(request.params[1]);\n+        EnableOrDisableLogCategories(request.params[1], false);\n     }\n+    uint32_t updated_log_categories = g_logger->GetCategoryMask();\n+    uint32_t changed_log_categories = original_log_categories ^ updated_log_categories;\n \n     // Update libevent logging if BCLog::LIBEVENT has changed.\n     // If the library version doesn't allow it, UpdateHTTPServerLogging() returns false,\n     // in which case we should clear the BCLog::LIBEVENT flag.\n     // Throw an error if the user has explicitly asked to change only the libevent\n     // flag and it failed.\n-    uint32_t changedLogCategories = originalLogCategories ^ logCategories;\n-    if (changedLogCategories & BCLog::LIBEVENT) {\n-        if (!UpdateHTTPServerLogging(logCategories & BCLog::LIBEVENT)) {\n-            logCategories &= ~BCLog::LIBEVENT;\n-            if (changedLogCategories == BCLog::LIBEVENT) {\n+    if (changed_log_categories & BCLog::LIBEVENT) {\n+        if (!UpdateHTTPServerLogging(g_logger->WillLogCategory(BCLog::LIBEVENT))) {\n+            g_logger->DisableCategory(BCLog::LIBEVENT);\n+            if (changed_log_categories == BCLog::LIBEVENT) {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"libevent logging cannot be updated when using libevent before v2.1.1.\");\n             }\n         }\n@@ -432,7 +433,7 @@ UniValue logging(const JSONRPCRequest& request)\n     return result;\n }\n \n-UniValue echo(const JSONRPCRequest& request)\n+static UniValue echo(const JSONRPCRequest& request)\n {\n     if (request.fHelp)\n         throw std::runtime_error("
      },
      {
        "sha": "1530d8578b1c70eaf3165ed3f9c7a91aec602f36",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -23,7 +23,7 @@\n \n #include <univalue.h>\n \n-UniValue getconnectioncount(const JSONRPCRequest& request)\n+static UniValue getconnectioncount(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n         throw std::runtime_error(\n@@ -42,7 +42,7 @@ UniValue getconnectioncount(const JSONRPCRequest& request)\n     return (int)g_connman->GetNodeCount(CConnman::CONNECTIONS_ALL);\n }\n \n-UniValue ping(const JSONRPCRequest& request)\n+static UniValue ping(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n         throw std::runtime_error(\n@@ -65,7 +65,7 @@ UniValue ping(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n-UniValue getpeerinfo(const JSONRPCRequest& request)\n+static UniValue getpeerinfo(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n         throw std::runtime_error(\n@@ -190,7 +190,7 @@ UniValue getpeerinfo(const JSONRPCRequest& request)\n     return ret;\n }\n \n-UniValue addnode(const JSONRPCRequest& request)\n+static UniValue addnode(const JSONRPCRequest& request)\n {\n     std::string strCommand;\n     if (!request.params[1].isNull())\n@@ -237,7 +237,7 @@ UniValue addnode(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n-UniValue disconnectnode(const JSONRPCRequest& request)\n+static UniValue disconnectnode(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() == 0 || request.params.size() >= 3)\n         throw std::runtime_error(\n@@ -280,7 +280,7 @@ UniValue disconnectnode(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n-UniValue getaddednodeinfo(const JSONRPCRequest& request)\n+static UniValue getaddednodeinfo(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() > 1)\n         throw std::runtime_error(\n@@ -347,7 +347,7 @@ UniValue getaddednodeinfo(const JSONRPCRequest& request)\n     return ret;\n }\n \n-UniValue getnettotals(const JSONRPCRequest& request)\n+static UniValue getnettotals(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() > 0)\n         throw std::runtime_error(\n@@ -413,7 +413,7 @@ static UniValue GetNetworksInfo()\n     return networks;\n }\n \n-UniValue getnetworkinfo(const JSONRPCRequest& request)\n+static UniValue getnetworkinfo(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n         throw std::runtime_error(\n@@ -489,7 +489,7 @@ UniValue getnetworkinfo(const JSONRPCRequest& request)\n     return obj;\n }\n \n-UniValue setban(const JSONRPCRequest& request)\n+static UniValue setban(const JSONRPCRequest& request)\n {\n     std::string strCommand;\n     if (!request.params[1].isNull())\n@@ -553,7 +553,7 @@ UniValue setban(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n-UniValue listbanned(const JSONRPCRequest& request)\n+static UniValue listbanned(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n         throw std::runtime_error(\n@@ -586,7 +586,7 @@ UniValue listbanned(const JSONRPCRequest& request)\n     return bannedAddresses;\n }\n \n-UniValue clearbanned(const JSONRPCRequest& request)\n+static UniValue clearbanned(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 0)\n         throw std::runtime_error(\n@@ -604,7 +604,7 @@ UniValue clearbanned(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n-UniValue setnetworkactive(const JSONRPCRequest& request)\n+static UniValue setnetworkactive(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1) {\n         throw std::runtime_error("
      },
      {
        "sha": "6954aed252f2f73aef4cbe004c77cf8473ca99e1",
        "filename": "src/rpc/protocol.h",
        "status": "modified",
        "additions": 6,
        "deletions": 4,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/rpc/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/rpc/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/protocol.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -3,8 +3,8 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#ifndef BITCOIN_RPCPROTOCOL_H\n-#define BITCOIN_RPCPROTOCOL_H\n+#ifndef BITCOIN_RPC_PROTOCOL_H\n+#define BITCOIN_RPC_PROTOCOL_H\n \n #include <fs.h>\n \n@@ -46,7 +46,6 @@ enum RPCErrorCode\n \n     //! General application defined errors\n     RPC_MISC_ERROR                  = -1,  //!< std::exception thrown in command handling\n-    RPC_FORBIDDEN_BY_SAFE_MODE      = -2,  //!< Server is in safe mode, and command is not allowed in safe mode\n     RPC_TYPE_ERROR                  = -3,  //!< Unexpected type was passed as parameter\n     RPC_INVALID_ADDRESS_OR_KEY      = -5,  //!< Invalid address or key\n     RPC_OUT_OF_MEMORY               = -7,  //!< Ran out of memory during operation\n@@ -88,6 +87,9 @@ enum RPCErrorCode\n \n     //! Backwards compatible aliases\n     RPC_WALLET_INVALID_ACCOUNT_NAME = RPC_WALLET_INVALID_LABEL_NAME,\n+\n+    //! Unused reserved codes, kept around for backwards compatibility. Do not reuse.\n+    RPC_FORBIDDEN_BY_SAFE_MODE      = -2,  //!< Server is in safe mode, and command is not allowed in safe mode\n };\n \n UniValue JSONRPCRequestObj(const std::string& strMethod, const UniValue& params, const UniValue& id);\n@@ -104,4 +106,4 @@ void DeleteAuthCookie();\n /** Parse JSON-RPC batch reply into a vector */\n std::vector<UniValue> JSONRPCProcessBatchReply(const UniValue &in, size_t num);\n \n-#endif // BITCOIN_RPCPROTOCOL_H\n+#endif // BITCOIN_RPC_PROTOCOL_H"
      },
      {
        "sha": "c5185ca5990f4236c712ec10dc75b4a2c1021eb2",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 158,
        "deletions": 33,
        "changes": 191,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -7,6 +7,7 @@\n #include <coins.h>\n #include <consensus/validation.h>\n #include <core_io.h>\n+#include <index/txindex.h>\n #include <init.h>\n #include <keystore.h>\n #include <validation.h>\n@@ -18,7 +19,6 @@\n #include <policy/rbf.h>\n #include <primitives/transaction.h>\n #include <rpc/rawtransaction.h>\n-#include <rpc/safemode.h>\n #include <rpc/server.h>\n #include <script/script.h>\n #include <script/script_error.h>\n@@ -37,7 +37,7 @@\n #include <univalue.h>\n \n \n-void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue& entry)\n+static void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue& entry)\n {\n     // Call into TxToUniv() in bitcoin-common to decode the transaction hex.\n     //\n@@ -47,6 +47,8 @@ void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue& entry)\n     TxToUniv(tx, uint256(), entry, true, RPCSerializationFlags());\n \n     if (!hashBlock.IsNull()) {\n+        LOCK(cs_main);\n+\n         entry.pushKV(\"blockhash\", hashBlock.GetHex());\n         CBlockIndex* pindex = LookupBlockIndex(hashBlock);\n         if (pindex) {\n@@ -61,7 +63,7 @@ void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue& entry)\n     }\n }\n \n-UniValue getrawtransaction(const JSONRPCRequest& request)\n+static UniValue getrawtransaction(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n         throw std::runtime_error(\n@@ -94,6 +96,7 @@ UniValue getrawtransaction(const JSONRPCRequest& request)\n             \"  \\\"hash\\\" : \\\"id\\\",        (string) The transaction hash (differs from txid for witness transactions)\\n\"\n             \"  \\\"size\\\" : n,             (numeric) The serialized transaction size\\n\"\n             \"  \\\"vsize\\\" : n,            (numeric) The virtual transaction size (differs from size for witness transactions)\\n\"\n+            \"  \\\"weight\\\" : n,           (numeric) The transaction's weight (between vsize*4-3 and vsize*4)\\n\"\n             \"  \\\"version\\\" : n,          (numeric) The version\\n\"\n             \"  \\\"locktime\\\" : ttt,       (numeric) The lock time\\n\"\n             \"  \\\"vin\\\" : [               (array of json objects)\\n\"\n@@ -140,8 +143,6 @@ UniValue getrawtransaction(const JSONRPCRequest& request)\n             + HelpExampleCli(\"getrawtransaction\", \"\\\"mytxid\\\" true \\\"myblockhash\\\"\")\n         );\n \n-    LOCK(cs_main);\n-\n     bool in_active_chain = true;\n     uint256 hash = ParseHashV(request.params[0], \"parameter 1\");\n     CBlockIndex* blockindex = nullptr;\n@@ -158,6 +159,8 @@ UniValue getrawtransaction(const JSONRPCRequest& request)\n     }\n \n     if (!request.params[2].isNull()) {\n+        LOCK(cs_main);\n+\n         uint256 blockhash = ParseHashV(request.params[2], \"parameter 3\");\n         blockindex = LookupBlockIndex(blockhash);\n         if (!blockindex) {\n@@ -166,6 +169,11 @@ UniValue getrawtransaction(const JSONRPCRequest& request)\n         in_active_chain = chainActive.Contains(blockindex);\n     }\n \n+    bool f_txindex_ready = false;\n+    if (g_txindex && !blockindex) {\n+        f_txindex_ready = g_txindex->BlockUntilSyncedToCurrentChain();\n+    }\n+\n     CTransactionRef tx;\n     uint256 hash_block;\n     if (!GetTransaction(hash, tx, Params().GetConsensus(), hash_block, true, blockindex)) {\n@@ -175,10 +183,12 @@ UniValue getrawtransaction(const JSONRPCRequest& request)\n                 throw JSONRPCError(RPC_MISC_ERROR, \"Block not available\");\n             }\n             errmsg = \"No such transaction found in the provided block\";\n+        } else if (!g_txindex) {\n+            errmsg = \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\";\n+        } else if (!f_txindex_ready) {\n+            errmsg = \"No such mempool transaction. Blockchain transactions are still in the process of being indexed\";\n         } else {\n-            errmsg = fTxIndex\n-              ? \"No such mempool or blockchain transaction\"\n-              : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\";\n+            errmsg = \"No such mempool or blockchain transaction\";\n         }\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, errmsg + \". Use gettransaction for wallet transactions.\");\n     }\n@@ -193,7 +203,7 @@ UniValue getrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n-UniValue gettxoutproof(const JSONRPCRequest& request)\n+static UniValue gettxoutproof(const JSONRPCRequest& request)\n {\n     if (request.fHelp || (request.params.size() != 1 && request.params.size() != 2))\n         throw std::runtime_error(\n@@ -228,19 +238,18 @@ UniValue gettxoutproof(const JSONRPCRequest& request)\n        oneTxid = hash;\n     }\n \n-    LOCK(cs_main);\n-\n     CBlockIndex* pblockindex = nullptr;\n-\n     uint256 hashBlock;\n-    if (!request.params[1].isNull())\n-    {\n+    if (!request.params[1].isNull()) {\n+        LOCK(cs_main);\n         hashBlock = uint256S(request.params[1].get_str());\n         pblockindex = LookupBlockIndex(hashBlock);\n         if (!pblockindex) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n         }\n     } else {\n+        LOCK(cs_main);\n+\n         // Loop through txids and try to find which block they're in. Exit loop once a block is found.\n         for (const auto& tx : setTxids) {\n             const Coin& coin = AccessByTxid(*pcoinsTip, tx);\n@@ -251,6 +260,14 @@ UniValue gettxoutproof(const JSONRPCRequest& request)\n         }\n     }\n \n+\n+    // Allow txindex to catch up if we need to query it and before we acquire cs_main.\n+    if (g_txindex && !pblockindex) {\n+        g_txindex->BlockUntilSyncedToCurrentChain();\n+    }\n+\n+    LOCK(cs_main);\n+\n     if (pblockindex == nullptr)\n     {\n         CTransactionRef tx;\n@@ -280,7 +297,7 @@ UniValue gettxoutproof(const JSONRPCRequest& request)\n     return strHex;\n }\n \n-UniValue verifytxoutproof(const JSONRPCRequest& request)\n+static UniValue verifytxoutproof(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n         throw std::runtime_error(\n@@ -316,7 +333,7 @@ UniValue verifytxoutproof(const JSONRPCRequest& request)\n     return res;\n }\n \n-UniValue createrawtransaction(const JSONRPCRequest& request)\n+static UniValue createrawtransaction(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 2 || request.params.size() > 4) {\n         throw std::runtime_error(\n@@ -476,7 +493,7 @@ UniValue createrawtransaction(const JSONRPCRequest& request)\n     return EncodeHexTx(rawTx);\n }\n \n-UniValue decoderawtransaction(const JSONRPCRequest& request)\n+static UniValue decoderawtransaction(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n         throw std::runtime_error(\n@@ -494,6 +511,7 @@ UniValue decoderawtransaction(const JSONRPCRequest& request)\n             \"  \\\"hash\\\" : \\\"id\\\",        (string) The transaction hash (differs from txid for witness transactions)\\n\"\n             \"  \\\"size\\\" : n,             (numeric) The transaction size\\n\"\n             \"  \\\"vsize\\\" : n,            (numeric) The virtual transaction size (differs from size for witness transactions)\\n\"\n+            \"  \\\"weight\\\" : n,           (numeric) The transaction's weight (between vsize*4 - 3 and vsize*4)\\n\"\n             \"  \\\"version\\\" : n,          (numeric) The version\\n\"\n             \"  \\\"locktime\\\" : ttt,       (numeric) The lock time\\n\"\n             \"  \\\"vin\\\" : [               (array of json objects)\\n\"\n@@ -551,7 +569,7 @@ UniValue decoderawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n-UniValue decodescript(const JSONRPCRequest& request)\n+static UniValue decodescript(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 1)\n         throw std::runtime_error(\n@@ -595,6 +613,38 @@ UniValue decodescript(const JSONRPCRequest& request)\n         // P2SH cannot be wrapped in a P2SH. If this script is already a P2SH,\n         // don't return the address for a P2SH of the P2SH.\n         r.pushKV(\"p2sh\", EncodeDestination(CScriptID(script)));\n+        // P2SH and witness programs cannot be wrapped in P2WSH, if this script\n+        // is a witness program, don't return addresses for a segwit programs.\n+        if (type.get_str() == \"pubkey\" || type.get_str() == \"pubkeyhash\" || type.get_str() == \"multisig\" || type.get_str() == \"nonstandard\") {\n+            txnouttype which_type;\n+            std::vector<std::vector<unsigned char>> solutions_data;\n+            Solver(script, which_type, solutions_data);\n+            // Uncompressed pubkeys cannot be used with segwit checksigs.\n+            // If the script contains an uncompressed pubkey, skip encoding of a segwit program.\n+            if ((which_type == TX_PUBKEY) || (which_type == TX_MULTISIG)) {\n+                for (const auto& solution : solutions_data) {\n+                    if ((solution.size() != 1) && !CPubKey(solution).IsCompressed()) {\n+                        return r;\n+                    }\n+                }\n+            }\n+            UniValue sr(UniValue::VOBJ);\n+            CScript segwitScr;\n+            if (which_type == TX_PUBKEY) {\n+                segwitScr = GetScriptForDestination(WitnessV0KeyHash(Hash160(solutions_data[0].begin(), solutions_data[0].end())));\n+            } else if (which_type == TX_PUBKEYHASH) {\n+                segwitScr = GetScriptForDestination(WitnessV0KeyHash(solutions_data[0]));\n+            } else {\n+                // Scripts that are not fit for P2WPKH are encoded as P2WSH.\n+                // Newer segwit program versions should be considered when then become available.\n+                uint256 scriptHash;\n+                CSHA256().Write(script.data(), script.size()).Finalize(scriptHash.begin());\n+                segwitScr = GetScriptForDestination(WitnessV0ScriptHash(scriptHash));\n+            }\n+            ScriptPubKeyToUniv(segwitScr, sr, true);\n+            sr.pushKV(\"p2sh-segwit\", EncodeDestination(CScriptID(segwitScr)));\n+            r.pushKV(\"segwit\", sr);\n+        }\n     }\n \n     return r;\n@@ -617,7 +667,7 @@ static void TxInErrorToJSON(const CTxIn& txin, UniValue& vErrorsRet, const std::\n     vErrorsRet.push_back(entry);\n }\n \n-UniValue combinerawtransaction(const JSONRPCRequest& request)\n+static UniValue combinerawtransaction(const JSONRPCRequest& request)\n {\n \n     if (request.fHelp || request.params.size() != 1)\n@@ -774,9 +824,6 @@ UniValue SignTransaction(CMutableTransaction& mtx, const UniValue& prevTxsUnival\n             if (is_temp_keystore && (scriptPubKey.IsPayToScriptHash() || scriptPubKey.IsPayToWitnessScriptHash())) {\n                 RPCTypeCheckObj(prevOut,\n                     {\n-                        {\"txid\", UniValueType(UniValue::VSTR)},\n-                        {\"vout\", UniValueType(UniValue::VNUM)},\n-                        {\"scriptPubKey\", UniValueType(UniValue::VSTR)},\n                         {\"redeemScript\", UniValueType(UniValue::VSTR)},\n                     });\n                 UniValue v = find_value(prevOut, \"redeemScript\");\n@@ -831,7 +878,7 @@ UniValue SignTransaction(CMutableTransaction& mtx, const UniValue& prevTxsUnival\n         SignatureData sigdata;\n         // Only sign SIGHASH_SINGLE if there's a corresponding output:\n         if (!fHashSingle || (i < mtx.vout.size())) {\n-            ProduceSignature(MutableTransactionSignatureCreator(keystore, &mtx, i, amount, nHashType), prevPubKey, sigdata);\n+            ProduceSignature(*keystore, MutableTransactionSignatureCreator(&mtx, i, amount, nHashType), prevPubKey, sigdata);\n         }\n         sigdata = CombineSignatures(prevPubKey, TransactionSignatureChecker(&txConst, i, amount), sigdata, DataFromTransaction(mtx, i));\n \n@@ -859,7 +906,7 @@ UniValue SignTransaction(CMutableTransaction& mtx, const UniValue& prevTxsUnival\n     return result;\n }\n \n-UniValue signrawtransactionwithkey(const JSONRPCRequest& request)\n+static UniValue signrawtransactionwithkey(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n         throw std::runtime_error(\n@@ -1023,21 +1070,21 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n         new_request.params.push_back(request.params[1]);\n         new_request.params.push_back(request.params[3]);\n         return signrawtransactionwithkey(new_request);\n-    }\n-    // Otherwise sign with the wallet which does not take a privkeys parameter\n+    } else {\n #ifdef ENABLE_WALLET\n-    else {\n+        // Otherwise sign with the wallet which does not take a privkeys parameter\n         new_request.params.push_back(request.params[0]);\n         new_request.params.push_back(request.params[1]);\n         new_request.params.push_back(request.params[3]);\n         return signrawtransactionwithwallet(new_request);\n-    }\n+#else\n+        // If we have made it this far, then wallet is disabled and no private keys were given, so fail here.\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"No private keys available.\");\n #endif\n-    // If we have made it this far, then wallet is disabled and no private keys were given, so fail here.\n-    throw JSONRPCError(RPC_INVALID_PARAMETER, \"No private keys available.\");\n+    }\n }\n \n-UniValue sendrawtransaction(const JSONRPCRequest& request)\n+static UniValue sendrawtransaction(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n         throw std::runtime_error(\n@@ -1060,8 +1107,6 @@ UniValue sendrawtransaction(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"sendrawtransaction\", \"\\\"signedhex\\\"\")\n         );\n \n-    ObserveSafeMode();\n-\n     std::promise<void> promise;\n \n     RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL});\n@@ -1134,6 +1179,85 @@ UniValue sendrawtransaction(const JSONRPCRequest& request)\n     return hashTx.GetHex();\n }\n \n+static UniValue testmempoolaccept(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2) {\n+        throw std::runtime_error(\n+            // clang-format off\n+            \"testmempoolaccept [\\\"rawtxs\\\"] ( allowhighfees )\\n\"\n+            \"\\nReturns if raw transaction (serialized, hex-encoded) would be accepted by mempool.\\n\"\n+            \"\\nThis checks if the transaction violates the consensus or policy rules.\\n\"\n+            \"\\nSee sendrawtransaction call.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. [\\\"rawtxs\\\"]       (array, required) An array of hex strings of raw transactions.\\n\"\n+            \"                                        Length must be one for now.\\n\"\n+            \"2. allowhighfees    (boolean, optional, default=false) Allow high fees\\n\"\n+            \"\\nResult:\\n\"\n+            \"[                   (array) The result of the mempool acceptance test for each raw transaction in the input array.\\n\"\n+            \"                            Length is exactly one for now.\\n\"\n+            \" {\\n\"\n+            \"  \\\"txid\\\"           (string) The transaction hash in hex\\n\"\n+            \"  \\\"allowed\\\"        (boolean) If the mempool allows this tx to be inserted\\n\"\n+            \"  \\\"reject-reason\\\"  (string) Rejection string (only present when 'allowed' is false)\\n\"\n+            \" }\\n\"\n+            \"]\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nCreate a transaction\\n\"\n+            + HelpExampleCli(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\" : \\\\\\\"mytxid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"{\\\\\\\"myaddress\\\\\\\":0.01}\\\"\") +\n+            \"Sign the transaction, and get back the hex\\n\"\n+            + HelpExampleCli(\"signrawtransaction\", \"\\\"myhex\\\"\") +\n+            \"\\nTest acceptance of the transaction (signed hex)\\n\"\n+            + HelpExampleCli(\"testmempoolaccept\", \"\\\"signedhex\\\"\") +\n+            \"\\nAs a json rpc call\\n\"\n+            + HelpExampleRpc(\"testmempoolaccept\", \"[\\\"signedhex\\\"]\")\n+            // clang-format on\n+            );\n+    }\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL});\n+    if (request.params[0].get_array().size() != 1) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Array must contain exactly one raw transaction for now\");\n+    }\n+\n+    CMutableTransaction mtx;\n+    if (!DecodeHexTx(mtx, request.params[0].get_array()[0].get_str())) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n+    }\n+    CTransactionRef tx(MakeTransactionRef(std::move(mtx)));\n+    const uint256& tx_hash = tx->GetHash();\n+\n+    CAmount max_raw_tx_fee = ::maxTxFee;\n+    if (!request.params[1].isNull() && request.params[1].get_bool()) {\n+        max_raw_tx_fee = 0;\n+    }\n+\n+    UniValue result(UniValue::VARR);\n+    UniValue result_0(UniValue::VOBJ);\n+    result_0.pushKV(\"txid\", tx_hash.GetHex());\n+\n+    CValidationState state;\n+    bool missing_inputs;\n+    bool test_accept_res;\n+    {\n+        LOCK(cs_main);\n+        test_accept_res = AcceptToMemoryPool(mempool, state, std::move(tx), &missing_inputs,\n+            nullptr /* plTxnReplaced */, false /* bypass_limits */, max_raw_tx_fee, /* test_accept */ true);\n+    }\n+    result_0.pushKV(\"allowed\", test_accept_res);\n+    if (!test_accept_res) {\n+        if (state.IsInvalid()) {\n+            result_0.pushKV(\"reject-reason\", strprintf(\"%i: %s\", state.GetRejectCode(), state.GetRejectReason()));\n+        } else if (missing_inputs) {\n+            result_0.pushKV(\"reject-reason\", \"missing-inputs\");\n+        } else {\n+            result_0.pushKV(\"reject-reason\", state.GetRejectReason());\n+        }\n+    }\n+\n+    result.push_back(std::move(result_0));\n+    return result;\n+}\n+\n static const CRPCCommand commands[] =\n { //  category              name                            actor (function)            argNames\n   //  --------------------- ------------------------        -----------------------     ----------\n@@ -1145,6 +1269,7 @@ static const CRPCCommand commands[] =\n     { \"rawtransactions\",    \"combinerawtransaction\",        &combinerawtransaction,     {\"txs\"} },\n     { \"rawtransactions\",    \"signrawtransaction\",           &signrawtransaction,        {\"hexstring\",\"prevtxs\",\"privkeys\",\"sighashtype\"} }, /* uses wallet if enabled */\n     { \"rawtransactions\",    \"signrawtransactionwithkey\",    &signrawtransactionwithkey, {\"hexstring\",\"privkeys\",\"prevtxs\",\"sighashtype\"} },\n+    { \"rawtransactions\",    \"testmempoolaccept\",            &testmempoolaccept,         {\"rawtxs\",\"allowhighfees\"} },\n \n     { \"blockchain\",         \"gettxoutproof\",                &gettxoutproof,             {\"txids\", \"blockhash\"} },\n     { \"blockchain\",         \"verifytxoutproof\",             &verifytxoutproof,          {\"proof\"} },"
      },
      {
        "sha": "b68974068194b33bf2414e34c4492cbd3e678238",
        "filename": "src/rpc/register.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/rpc/register.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/rpc/register.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/register.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -2,8 +2,8 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#ifndef BITCOIN_RPCREGISTER_H\n-#define BITCOIN_RPCREGISTER_H\n+#ifndef BITCOIN_RPC_REGISTER_H\n+#define BITCOIN_RPC_REGISTER_H\n \n /** These are in one header file to avoid creating tons of single-function\n  * headers for everything under src/rpc/ */\n@@ -29,4 +29,4 @@ static inline void RegisterAllCoreRPCCommands(CRPCTable &t)\n     RegisterRawTransactionRPCCommands(t);\n }\n \n-#endif\n+#endif // BITCOIN_RPC_REGISTER_H"
      },
      {
        "sha": "9f3a9d30b8533a7ee58b9cc87f3b22671def247c",
        "filename": "src/rpc/safemode.cpp",
        "status": "removed",
        "additions": 0,
        "deletions": 14,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7466a26cab5d66665991433947964a638f5b957e/src/rpc/safemode.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7466a26cab5d66665991433947964a638f5b957e/src/rpc/safemode.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/safemode.cpp?ref=7466a26cab5d66665991433947964a638f5b957e",
        "patch": "@@ -1,14 +0,0 @@\n-#include <rpc/safemode.h>\n-\n-#include <rpc/protocol.h>\n-#include <util.h>\n-#include <warnings.h>\n-\n-void ObserveSafeMode()\n-{\n-    std::string warning = GetWarnings(\"rpc\");\n-    if (warning != \"\" && !gArgs.GetBoolArg(\"-disablesafemode\", DEFAULT_DISABLE_SAFEMODE)) {\n-        throw JSONRPCError(RPC_FORBIDDEN_BY_SAFE_MODE, std::string(\"Safe mode: \") + warning);\n-    }\n-}\n-"
      },
      {
        "sha": "8466d6b2f975a7b5b39edd0480f6684f08ee54e8",
        "filename": "src/rpc/safemode.h",
        "status": "removed",
        "additions": 0,
        "deletions": 12,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7466a26cab5d66665991433947964a638f5b957e/src/rpc/safemode.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7466a26cab5d66665991433947964a638f5b957e/src/rpc/safemode.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/safemode.h?ref=7466a26cab5d66665991433947964a638f5b957e",
        "patch": "@@ -1,12 +0,0 @@\n-// Copyright (c) 2017 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#ifndef BITCOIN_RPC_SAFEMODE_H\n-#define BITCOIN_RPC_SAFEMODE_H\n-\n-static const bool DEFAULT_DISABLE_SAFEMODE = true;\n-\n-void ObserveSafeMode();\n-\n-#endif // BITCOIN_RPC_SAFEMODE_H"
      },
      {
        "sha": "7edd51d3d7efa710389524e611ad54f5c61e8e45",
        "filename": "src/rpc/server.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 2,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/rpc/server.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/rpc/server.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/server.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -239,7 +239,7 @@ UniValue stop(const JSONRPCRequest& jsonRequest)\n     return \"Bitcoin server stopping\";\n }\n \n-UniValue uptime(const JSONRPCRequest& jsonRequest)\n+static UniValue uptime(const JSONRPCRequest& jsonRequest)\n {\n     if (jsonRequest.fHelp || jsonRequest.params.size() > 1)\n         throw std::runtime_error(\n@@ -367,7 +367,11 @@ void JSONRPCRequest::parse(const UniValue& valRequest)\n     if (!valMethod.isStr())\n         throw JSONRPCError(RPC_INVALID_REQUEST, \"Method must be a string\");\n     strMethod = valMethod.get_str();\n-    LogPrint(BCLog::RPC, \"ThreadRPCServer method=%s\\n\", SanitizeString(strMethod));\n+    if (fLogIPs)\n+        LogPrint(BCLog::RPC, \"ThreadRPCServer method=%s user=%s peeraddr=%s\\n\", SanitizeString(strMethod),\n+            this->authUser, this->peerAddr);\n+    else\n+        LogPrint(BCLog::RPC, \"ThreadRPCServer method=%s user=%s\\n\", SanitizeString(strMethod), this->authUser);\n \n     // Parse params\n     UniValue valParams = find_value(request, \"params\");"
      },
      {
        "sha": "373914885c17ef78daaff5f078288200e86aeab6",
        "filename": "src/rpc/server.h",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/rpc/server.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/rpc/server.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/server.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -3,8 +3,8 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#ifndef BITCOIN_RPCSERVER_H\n-#define BITCOIN_RPCSERVER_H\n+#ifndef BITCOIN_RPC_SERVER_H\n+#define BITCOIN_RPC_SERVER_H\n \n #include <amount.h>\n #include <rpc/protocol.h>\n@@ -45,6 +45,7 @@ class JSONRPCRequest\n     bool fHelp;\n     std::string URI;\n     std::string authUser;\n+    std::string peerAddr;\n \n     JSONRPCRequest() : id(NullUniValue), params(NullUniValue), fHelp(false) {}\n     void parse(const UniValue& valRequest);\n@@ -205,4 +206,4 @@ std::string JSONRPCExecBatch(const JSONRPCRequest& jreq, const UniValue& vReq);\n // Retrieves any serialization flags requested in command line argument\n int RPCSerializationFlags();\n \n-#endif // BITCOIN_RPCSERVER_H\n+#endif // BITCOIN_RPC_SERVER_H"
      },
      {
        "sha": "5973808fa58fe42c6edb339f28a52018e6dba8b0",
        "filename": "src/script/bitcoinconsensus.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/script/bitcoinconsensus.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/script/bitcoinconsensus.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/bitcoinconsensus.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -3,8 +3,8 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#ifndef BITCOIN_BITCOINCONSENSUS_H\n-#define BITCOIN_BITCOINCONSENSUS_H\n+#ifndef BITCOIN_SCRIPT_BITCOINCONSENSUS_H\n+#define BITCOIN_SCRIPT_BITCOINCONSENSUS_H\n \n #include <stdint.h>\n \n@@ -80,4 +80,4 @@ EXPORT_SYMBOL unsigned int bitcoinconsensus_version();\n \n #undef EXPORT_SYMBOL\n \n-#endif // BITCOIN_BITCOINCONSENSUS_H\n+#endif // BITCOIN_SCRIPT_BITCOINCONSENSUS_H"
      },
      {
        "sha": "e0d193fa3801c80ffd19e0962abcf15fb81ff840",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 48,
        "deletions": 20,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -61,17 +61,17 @@ static inline void popstack(std::vector<valtype>& stack)\n }\n \n bool static IsCompressedOrUncompressedPubKey(const valtype &vchPubKey) {\n-    if (vchPubKey.size() < 33) {\n+    if (vchPubKey.size() < CPubKey::COMPRESSED_PUBLIC_KEY_SIZE) {\n         //  Non-canonical public key: too short\n         return false;\n     }\n     if (vchPubKey[0] == 0x04) {\n-        if (vchPubKey.size() != 65) {\n+        if (vchPubKey.size() != CPubKey::PUBLIC_KEY_SIZE) {\n             //  Non-canonical public key: invalid length for uncompressed key\n             return false;\n         }\n     } else if (vchPubKey[0] == 0x02 || vchPubKey[0] == 0x03) {\n-        if (vchPubKey.size() != 33) {\n+        if (vchPubKey.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE) {\n             //  Non-canonical public key: invalid length for compressed key\n             return false;\n         }\n@@ -83,7 +83,7 @@ bool static IsCompressedOrUncompressedPubKey(const valtype &vchPubKey) {\n }\n \n bool static IsCompressedPubKey(const valtype &vchPubKey) {\n-    if (vchPubKey.size() != 33) {\n+    if (vchPubKey.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE) {\n         //  Non-canonical public key: invalid length for compressed key\n         return false;\n     }\n@@ -219,7 +219,7 @@ bool static CheckPubKeyEncoding(const valtype &vchPubKey, unsigned int flags, co\n         return set_error(serror, SCRIPT_ERR_PUBKEYTYPE);\n     }\n     // Only compressed keys are accepted in segwit\n-    if ((flags & SCRIPT_VERIFY_WITNESS_PUBKEYTYPE) != 0 && sigversion == SIGVERSION_WITNESS_V0 && !IsCompressedPubKey(vchPubKey)) {\n+    if ((flags & SCRIPT_VERIFY_WITNESS_PUBKEYTYPE) != 0 && sigversion == SigVersion::WITNESS_V0 && !IsCompressedPubKey(vchPubKey)) {\n         return set_error(serror, SCRIPT_ERR_WITNESS_PUBKEYTYPE);\n     }\n     return true;\n@@ -250,6 +250,34 @@ bool static CheckMinimalPush(const valtype& data, opcodetype opcode) {\n     return true;\n }\n \n+int FindAndDelete(CScript& script, const CScript& b)\n+{\n+    int nFound = 0;\n+    if (b.empty())\n+        return nFound;\n+    CScript result;\n+    CScript::const_iterator pc = script.begin(), pc2 = script.begin(), end = script.end();\n+    opcodetype opcode;\n+    do\n+    {\n+        result.insert(result.end(), pc2, pc);\n+        while (static_cast<size_t>(end - pc) >= b.size() && std::equal(b.begin(), b.end(), pc))\n+        {\n+            pc = pc + b.size();\n+            ++nFound;\n+        }\n+        pc2 = pc;\n+    }\n+    while (script.GetOp(pc, opcode));\n+\n+    if (nFound > 0) {\n+        result.insert(result.end(), pc2, end);\n+        script = std::move(result);\n+    }\n+\n+    return nFound;\n+}\n+\n bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror)\n {\n     static const CScriptNum bnZero(0);\n@@ -443,7 +471,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                         if (stack.size() < 1)\n                             return set_error(serror, SCRIPT_ERR_UNBALANCED_CONDITIONAL);\n                         valtype& vch = stacktop(-1);\n-                        if (sigversion == SIGVERSION_WITNESS_V0 && (flags & SCRIPT_VERIFY_MINIMALIF)) {\n+                        if (sigversion == SigVersion::WITNESS_V0 && (flags & SCRIPT_VERIFY_MINIMALIF)) {\n                             if (vch.size() > 1)\n                                 return set_error(serror, SCRIPT_ERR_MINIMALIF);\n                             if (vch.size() == 1 && vch[0] != 1)\n@@ -890,8 +918,8 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                     CScript scriptCode(pbegincodehash, pend);\n \n                     // Drop the signature in pre-segwit scripts but not segwit scripts\n-                    if (sigversion == SIGVERSION_BASE) {\n-                        scriptCode.FindAndDelete(CScript(vchSig));\n+                    if (sigversion == SigVersion::BASE) {\n+                        FindAndDelete(scriptCode, CScript(vchSig));\n                     }\n \n                     if (!CheckSignatureEncoding(vchSig, flags, serror) || !CheckPubKeyEncoding(vchPubKey, flags, sigversion, serror)) {\n@@ -954,8 +982,8 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                     for (int k = 0; k < nSigsCount; k++)\n                     {\n                         valtype& vchSig = stacktop(-isig-k);\n-                        if (sigversion == SIGVERSION_BASE) {\n-                            scriptCode.FindAndDelete(CScript(vchSig));\n+                        if (sigversion == SigVersion::BASE) {\n+                            FindAndDelete(scriptCode, CScript(vchSig));\n                         }\n                     }\n \n@@ -1182,7 +1210,7 @@ uint256 SignatureHash(const CScript& scriptCode, const CTransaction& txTo, unsig\n {\n     assert(nIn < txTo.vin.size());\n \n-    if (sigversion == SIGVERSION_WITNESS_V0) {\n+    if (sigversion == SigVersion::WITNESS_V0) {\n         uint256 hashPrevouts;\n         uint256 hashSequence;\n         uint256 hashOutputs;\n@@ -1361,7 +1389,7 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n     CScript scriptPubKey;\n \n     if (witversion == 0) {\n-        if (program.size() == 32) {\n+        if (program.size() == WITNESS_V0_SCRIPTHASH_SIZE) {\n             // Version 0 segregated witness program: SHA256(CScript) inside the program, CScript + inputs in witness\n             if (witness.stack.size() == 0) {\n                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY);\n@@ -1373,7 +1401,7 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n             if (memcmp(hashScriptPubKey.begin(), program.data(), 32)) {\n                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH);\n             }\n-        } else if (program.size() == 20) {\n+        } else if (program.size() == WITNESS_V0_KEYHASH_SIZE) {\n             // Special case for pay-to-pubkeyhash; signature + pubkey in witness\n             if (witness.stack.size() != 2) {\n                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH); // 2 items in witness\n@@ -1396,13 +1424,13 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n             return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n     }\n \n-    if (!EvalScript(stack, scriptPubKey, flags, checker, SIGVERSION_WITNESS_V0, serror)) {\n+    if (!EvalScript(stack, scriptPubKey, flags, checker, SigVersion::WITNESS_V0, serror)) {\n         return false;\n     }\n \n     // Scripts inside witness implicitly require cleanstack behaviour\n     if (stack.size() != 1)\n-        return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n+        return set_error(serror, SCRIPT_ERR_CLEANSTACK);\n     if (!CastToBool(stack.back()))\n         return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n     return true;\n@@ -1423,12 +1451,12 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n     }\n \n     std::vector<std::vector<unsigned char> > stack, stackCopy;\n-    if (!EvalScript(stack, scriptSig, flags, checker, SIGVERSION_BASE, serror))\n+    if (!EvalScript(stack, scriptSig, flags, checker, SigVersion::BASE, serror))\n         // serror is set\n         return false;\n     if (flags & SCRIPT_VERIFY_P2SH)\n         stackCopy = stack;\n-    if (!EvalScript(stack, scriptPubKey, flags, checker, SIGVERSION_BASE, serror))\n+    if (!EvalScript(stack, scriptPubKey, flags, checker, SigVersion::BASE, serror))\n         // serror is set\n         return false;\n     if (stack.empty())\n@@ -1474,7 +1502,7 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n         CScript pubKey2(pubKeySerialized.begin(), pubKeySerialized.end());\n         popstack(stack);\n \n-        if (!EvalScript(stack, pubKey2, flags, checker, SIGVERSION_BASE, serror))\n+        if (!EvalScript(stack, pubKey2, flags, checker, SigVersion::BASE, serror))\n             // serror is set\n             return false;\n         if (stack.empty())\n@@ -1530,10 +1558,10 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n size_t static WitnessSigOps(int witversion, const std::vector<unsigned char>& witprogram, const CScriptWitness& witness, int flags)\n {\n     if (witversion == 0) {\n-        if (witprogram.size() == 20)\n+        if (witprogram.size() == WITNESS_V0_KEYHASH_SIZE)\n             return 1;\n \n-        if (witprogram.size() == 32 && witness.stack.size() > 0) {\n+        if (witprogram.size() == WITNESS_V0_SCRIPTHASH_SIZE && witness.stack.size() > 0) {\n             CScript subscript(witness.stack.back().begin(), witness.stack.back().end());\n             return subscript.GetSigOpCount(true);\n         }"
      },
      {
        "sha": "50c747900a0ab9360f8f0c11f7c1cb9d5465ab02",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 9,
        "deletions": 3,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -123,12 +123,16 @@ struct PrecomputedTransactionData\n     explicit PrecomputedTransactionData(const CTransaction& tx);\n };\n \n-enum SigVersion\n+enum class SigVersion\n {\n-    SIGVERSION_BASE = 0,\n-    SIGVERSION_WITNESS_V0 = 1,\n+    BASE = 0,\n+    WITNESS_V0 = 1,\n };\n \n+/** Signature hash sizes */\n+static constexpr size_t WITNESS_V0_SCRIPTHASH_SIZE = 32;\n+static constexpr size_t WITNESS_V0_KEYHASH_SIZE = 20;\n+\n uint256 SignatureHash(const CScript &scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType, const CAmount& amount, SigVersion sigversion, const PrecomputedTransactionData* cache = nullptr);\n \n class BaseSignatureChecker\n@@ -185,4 +189,6 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n \n size_t CountWitnessSigOps(const CScript& scriptSig, const CScript& scriptPubKey, const CScriptWitness* witness, unsigned int flags);\n \n+int FindAndDelete(CScript& script, const CScript& b);\n+\n #endif // BITCOIN_SCRIPT_INTERPRETER_H"
      },
      {
        "sha": "fefa02fdef1c3e3e81ce6ad9fc985fc9c950e5ab",
        "filename": "src/script/ismine.cpp",
        "status": "modified",
        "additions": 52,
        "deletions": 28,
        "changes": 80,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/script/ismine.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/script/ismine.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/ismine.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -13,34 +13,36 @@\n \n typedef std::vector<unsigned char> valtype;\n \n-static bool HaveKeys(const std::vector<valtype>& pubkeys, const CKeyStore& keystore)\n-{\n-    for (const valtype& pubkey : pubkeys) {\n-        CKeyID keyID = CPubKey(pubkey).GetID();\n-        if (!keystore.HaveKey(keyID)) return false;\n-    }\n-    return true;\n-}\n+namespace {\n \n-isminetype IsMine(const CKeyStore& keystore, const CScript& scriptPubKey, SigVersion sigversion)\n+/**\n+ * This is an enum that tracks the execution context of a script, similar to\n+ * SigVersion in script/interpreter. It is separate however because we want to\n+ * distinguish between top-level scriptPubKey execution and P2SH redeemScript\n+ * execution (a distinction that has no impact on consensus rules).\n+ */\n+enum class IsMineSigVersion\n {\n-    bool isInvalid = false;\n-    return IsMine(keystore, scriptPubKey, isInvalid, sigversion);\n-}\n+    TOP = 0,        //! scriptPubKey execution\n+    P2SH = 1,       //! P2SH redeemScript\n+    WITNESS_V0 = 2  //! P2WSH witness script execution\n+};\n \n-isminetype IsMine(const CKeyStore& keystore, const CTxDestination& dest, SigVersion sigversion)\n+bool PermitsUncompressed(IsMineSigVersion sigversion)\n {\n-    bool isInvalid = false;\n-    return IsMine(keystore, dest, isInvalid, sigversion);\n+    return sigversion == IsMineSigVersion::TOP || sigversion == IsMineSigVersion::P2SH;\n }\n \n-isminetype IsMine(const CKeyStore &keystore, const CTxDestination& dest, bool& isInvalid, SigVersion sigversion)\n+bool HaveKeys(const std::vector<valtype>& pubkeys, const CKeyStore& keystore)\n {\n-    CScript script = GetScriptForDestination(dest);\n-    return IsMine(keystore, script, isInvalid, sigversion);\n+    for (const valtype& pubkey : pubkeys) {\n+        CKeyID keyID = CPubKey(pubkey).GetID();\n+        if (!keystore.HaveKey(keyID)) return false;\n+    }\n+    return true;\n }\n \n-isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey, bool& isInvalid, SigVersion sigversion)\n+isminetype IsMineInner(const CKeyStore& keystore, const CScript& scriptPubKey, bool& isInvalid, IsMineSigVersion sigversion)\n {\n     isInvalid = false;\n \n@@ -61,7 +63,7 @@ isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey, bool&\n         break;\n     case TX_PUBKEY:\n         keyID = CPubKey(vSolutions[0]).GetID();\n-        if (sigversion != SIGVERSION_BASE && vSolutions[0].size() != 33) {\n+        if (!PermitsUncompressed(sigversion) && vSolutions[0].size() != 33) {\n             isInvalid = true;\n             return ISMINE_NO;\n         }\n@@ -70,20 +72,20 @@ isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey, bool&\n         break;\n     case TX_WITNESS_V0_KEYHASH:\n     {\n-        if (!keystore.HaveCScript(CScriptID(CScript() << OP_0 << vSolutions[0]))) {\n+        if (sigversion == IsMineSigVersion::TOP && !keystore.HaveCScript(CScriptID(CScript() << OP_0 << vSolutions[0]))) {\n             // We do not support bare witness outputs unless the P2SH version of it would be\n             // acceptable as well. This protects against matching before segwit activates.\n             // This also applies to the P2WSH case.\n             break;\n         }\n-        isminetype ret = ::IsMine(keystore, GetScriptForDestination(CKeyID(uint160(vSolutions[0]))), isInvalid, SIGVERSION_WITNESS_V0);\n+        isminetype ret = IsMineInner(keystore, GetScriptForDestination(CKeyID(uint160(vSolutions[0]))), isInvalid, IsMineSigVersion::WITNESS_V0);\n         if (ret == ISMINE_SPENDABLE || ret == ISMINE_WATCH_SOLVABLE || (ret == ISMINE_NO && isInvalid))\n             return ret;\n         break;\n     }\n     case TX_PUBKEYHASH:\n         keyID = CKeyID(uint160(vSolutions[0]));\n-        if (sigversion != SIGVERSION_BASE) {\n+        if (!PermitsUncompressed(sigversion)) {\n             CPubKey pubkey;\n             if (keystore.GetPubKey(keyID, pubkey) && !pubkey.IsCompressed()) {\n                 isInvalid = true;\n@@ -98,23 +100,23 @@ isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey, bool&\n         CScriptID scriptID = CScriptID(uint160(vSolutions[0]));\n         CScript subscript;\n         if (keystore.GetCScript(scriptID, subscript)) {\n-            isminetype ret = IsMine(keystore, subscript, isInvalid);\n+            isminetype ret = IsMineInner(keystore, subscript, isInvalid, IsMineSigVersion::P2SH);\n             if (ret == ISMINE_SPENDABLE || ret == ISMINE_WATCH_SOLVABLE || (ret == ISMINE_NO && isInvalid))\n                 return ret;\n         }\n         break;\n     }\n     case TX_WITNESS_V0_SCRIPTHASH:\n     {\n-        if (!keystore.HaveCScript(CScriptID(CScript() << OP_0 << vSolutions[0]))) {\n+        if (sigversion == IsMineSigVersion::TOP && !keystore.HaveCScript(CScriptID(CScript() << OP_0 << vSolutions[0]))) {\n             break;\n         }\n         uint160 hash;\n         CRIPEMD160().Write(&vSolutions[0][0], vSolutions[0].size()).Finalize(hash.begin());\n         CScriptID scriptID = CScriptID(hash);\n         CScript subscript;\n         if (keystore.GetCScript(scriptID, subscript)) {\n-            isminetype ret = IsMine(keystore, subscript, isInvalid, SIGVERSION_WITNESS_V0);\n+            isminetype ret = IsMineInner(keystore, subscript, isInvalid, IsMineSigVersion::WITNESS_V0);\n             if (ret == ISMINE_SPENDABLE || ret == ISMINE_WATCH_SOLVABLE || (ret == ISMINE_NO && isInvalid))\n                 return ret;\n         }\n@@ -123,13 +125,16 @@ isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey, bool&\n \n     case TX_MULTISIG:\n     {\n+        // Never treat bare multisig outputs as ours (they can still be made watchonly-though)\n+        if (sigversion == IsMineSigVersion::TOP) break;\n+\n         // Only consider transactions \"mine\" if we own ALL the\n         // keys involved. Multi-signature transactions that are\n         // partially owned (somebody else has a key that can spend\n         // them) enable spend-out-from-under-you attacks, especially\n         // in shared-wallet situations.\n         std::vector<valtype> keys(vSolutions.begin()+1, vSolutions.begin()+vSolutions.size()-1);\n-        if (sigversion != SIGVERSION_BASE) {\n+        if (!PermitsUncompressed(sigversion)) {\n             for (size_t i = 0; i < keys.size(); i++) {\n                 if (keys[i].size() != 33) {\n                     isInvalid = true;\n@@ -146,7 +151,26 @@ isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey, bool&\n     if (keystore.HaveWatchOnly(scriptPubKey)) {\n         // TODO: This could be optimized some by doing some work after the above solver\n         SignatureData sigs;\n-        return ProduceSignature(DummySignatureCreator(&keystore), scriptPubKey, sigs) ? ISMINE_WATCH_SOLVABLE : ISMINE_WATCH_UNSOLVABLE;\n+        return ProduceSignature(keystore, DUMMY_SIGNATURE_CREATOR, scriptPubKey, sigs) ? ISMINE_WATCH_SOLVABLE : ISMINE_WATCH_UNSOLVABLE;\n     }\n     return ISMINE_NO;\n }\n+\n+} // namespace\n+\n+isminetype IsMine(const CKeyStore& keystore, const CScript& scriptPubKey, bool& isInvalid)\n+{\n+    return IsMineInner(keystore, scriptPubKey, isInvalid, IsMineSigVersion::TOP);\n+}\n+\n+isminetype IsMine(const CKeyStore& keystore, const CScript& scriptPubKey)\n+{\n+    bool isInvalid = false;\n+    return IsMine(keystore, scriptPubKey, isInvalid);\n+}\n+\n+isminetype IsMine(const CKeyStore& keystore, const CTxDestination& dest)\n+{\n+    CScript script = GetScriptForDestination(dest);\n+    return IsMine(keystore, script);\n+}"
      },
      {
        "sha": "8573bdfbd248839126c25f6e2a8bd982b492785a",
        "filename": "src/script/ismine.h",
        "status": "modified",
        "additions": 4,
        "deletions": 5,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/script/ismine.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/script/ismine.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/ismine.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -31,11 +31,10 @@ typedef uint8_t isminefilter;\n /* isInvalid becomes true when the script is found invalid by consensus or policy. This will terminate the recursion\n  * and return ISMINE_NO immediately, as an invalid script should never be considered as \"mine\". This is needed as\n  * different SIGVERSION may have different network rules. Currently the only use of isInvalid is indicate uncompressed\n- * keys in SIGVERSION_WITNESS_V0 script, but could also be used in similar cases in the future\n+ * keys in SigVersion::WITNESS_V0 script, but could also be used in similar cases in the future\n  */\n-isminetype IsMine(const CKeyStore& keystore, const CScript& scriptPubKey, bool& isInvalid, SigVersion = SIGVERSION_BASE);\n-isminetype IsMine(const CKeyStore& keystore, const CScript& scriptPubKey, SigVersion = SIGVERSION_BASE);\n-isminetype IsMine(const CKeyStore& keystore, const CTxDestination& dest, bool& isInvalid, SigVersion = SIGVERSION_BASE);\n-isminetype IsMine(const CKeyStore& keystore, const CTxDestination& dest, SigVersion = SIGVERSION_BASE);\n+isminetype IsMine(const CKeyStore& keystore, const CScript& scriptPubKey, bool& isInvalid);\n+isminetype IsMine(const CKeyStore& keystore, const CScript& scriptPubKey);\n+isminetype IsMine(const CKeyStore& keystore, const CTxDestination& dest);\n \n #endif // BITCOIN_SCRIPT_ISMINE_H"
      },
      {
        "sha": "7f25d915a82c5fc793da75383697f3d602dee432",
        "filename": "src/script/script.cpp",
        "status": "modified",
        "additions": 52,
        "deletions": 0,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/script/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/script/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -280,3 +280,55 @@ bool CScript::HasValidOps() const\n     }\n     return true;\n }\n+\n+bool GetScriptOp(CScriptBase::const_iterator& pc, CScriptBase::const_iterator end, opcodetype& opcodeRet, std::vector<unsigned char>* pvchRet)\n+{\n+    opcodeRet = OP_INVALIDOPCODE;\n+    if (pvchRet)\n+        pvchRet->clear();\n+    if (pc >= end)\n+        return false;\n+\n+    // Read instruction\n+    if (end - pc < 1)\n+        return false;\n+    unsigned int opcode = *pc++;\n+\n+    // Immediate operand\n+    if (opcode <= OP_PUSHDATA4)\n+    {\n+        unsigned int nSize = 0;\n+        if (opcode < OP_PUSHDATA1)\n+        {\n+            nSize = opcode;\n+        }\n+        else if (opcode == OP_PUSHDATA1)\n+        {\n+            if (end - pc < 1)\n+                return false;\n+            nSize = *pc++;\n+        }\n+        else if (opcode == OP_PUSHDATA2)\n+        {\n+            if (end - pc < 2)\n+                return false;\n+            nSize = ReadLE16(&pc[0]);\n+            pc += 2;\n+        }\n+        else if (opcode == OP_PUSHDATA4)\n+        {\n+            if (end - pc < 4)\n+                return false;\n+            nSize = ReadLE32(&pc[0]);\n+            pc += 4;\n+        }\n+        if (end - pc < 0 || (unsigned int)(end - pc) < nSize)\n+            return false;\n+        if (pvchRet)\n+            pvchRet->assign(pc, pc + nSize);\n+        pc += nSize;\n+    }\n+\n+    opcodeRet = static_cast<opcodetype>(opcode);\n+    return true;\n+}"
      },
      {
        "sha": "d8b7c06013192f892b3b37a84482de6ed385605f",
        "filename": "src/script/script.h",
        "status": "modified",
        "additions": 5,
        "deletions": 108,
        "changes": 113,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/script/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/script/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -385,6 +385,8 @@ class CScriptNum\n  */\n typedef prevector<28, unsigned char> CScriptBase;\n \n+bool GetScriptOp(CScriptBase::const_iterator& pc, CScriptBase::const_iterator end, opcodetype& opcodeRet, std::vector<unsigned char>* pvchRet);\n+\n /** Serialized script, used inside transaction inputs and outputs */\n class CScript : public CScriptBase\n {\n@@ -415,7 +417,7 @@ class CScript : public CScriptBase\n \n     template <typename Stream, typename Operation>\n     inline void SerializationOp(Stream& s, Operation ser_action) {\n-        READWRITE(static_cast<CScriptBase&>(*this));\n+        READWRITEAS(CScriptBase, *this);\n     }\n \n     CScript& operator+=(const CScript& b)\n@@ -493,84 +495,16 @@ class CScript : public CScriptBase\n     }\n \n \n-    bool GetOp(iterator& pc, opcodetype& opcodeRet, std::vector<unsigned char>& vchRet)\n-    {\n-         // Wrapper so it can be called with either iterator or const_iterator\n-         const_iterator pc2 = pc;\n-         bool fRet = GetOp2(pc2, opcodeRet, &vchRet);\n-         pc = begin() + (pc2 - begin());\n-         return fRet;\n-    }\n-\n-    bool GetOp(iterator& pc, opcodetype& opcodeRet)\n-    {\n-         const_iterator pc2 = pc;\n-         bool fRet = GetOp2(pc2, opcodeRet, nullptr);\n-         pc = begin() + (pc2 - begin());\n-         return fRet;\n-    }\n-\n     bool GetOp(const_iterator& pc, opcodetype& opcodeRet, std::vector<unsigned char>& vchRet) const\n     {\n-        return GetOp2(pc, opcodeRet, &vchRet);\n+        return GetScriptOp(pc, end(), opcodeRet, &vchRet);\n     }\n \n     bool GetOp(const_iterator& pc, opcodetype& opcodeRet) const\n     {\n-        return GetOp2(pc, opcodeRet, nullptr);\n+        return GetScriptOp(pc, end(), opcodeRet, nullptr);\n     }\n \n-    bool GetOp2(const_iterator& pc, opcodetype& opcodeRet, std::vector<unsigned char>* pvchRet) const\n-    {\n-        opcodeRet = OP_INVALIDOPCODE;\n-        if (pvchRet)\n-            pvchRet->clear();\n-        if (pc >= end())\n-            return false;\n-\n-        // Read instruction\n-        if (end() - pc < 1)\n-            return false;\n-        unsigned int opcode = *pc++;\n-\n-        // Immediate operand\n-        if (opcode <= OP_PUSHDATA4)\n-        {\n-            unsigned int nSize = 0;\n-            if (opcode < OP_PUSHDATA1)\n-            {\n-                nSize = opcode;\n-            }\n-            else if (opcode == OP_PUSHDATA1)\n-            {\n-                if (end() - pc < 1)\n-                    return false;\n-                nSize = *pc++;\n-            }\n-            else if (opcode == OP_PUSHDATA2)\n-            {\n-                if (end() - pc < 2)\n-                    return false;\n-                nSize = ReadLE16(&pc[0]);\n-                pc += 2;\n-            }\n-            else if (opcode == OP_PUSHDATA4)\n-            {\n-                if (end() - pc < 4)\n-                    return false;\n-                nSize = ReadLE32(&pc[0]);\n-                pc += 4;\n-            }\n-            if (end() - pc < 0 || (unsigned int)(end() - pc) < nSize)\n-                return false;\n-            if (pvchRet)\n-                pvchRet->assign(pc, pc + nSize);\n-            pc += nSize;\n-        }\n-\n-        opcodeRet = static_cast<opcodetype>(opcode);\n-        return true;\n-    }\n \n     /** Encode/decode small integers: */\n     static int DecodeOP_N(opcodetype opcode)\n@@ -588,43 +522,6 @@ class CScript : public CScriptBase\n         return (opcodetype)(OP_1+n-1);\n     }\n \n-    int FindAndDelete(const CScript& b)\n-    {\n-        int nFound = 0;\n-        if (b.empty())\n-            return nFound;\n-        CScript result;\n-        iterator pc = begin(), pc2 = begin();\n-        opcodetype opcode;\n-        do\n-        {\n-            result.insert(result.end(), pc2, pc);\n-            while (static_cast<size_t>(end() - pc) >= b.size() && std::equal(b.begin(), b.end(), pc))\n-            {\n-                pc = pc + b.size();\n-                ++nFound;\n-            }\n-            pc2 = pc;\n-        }\n-        while (GetOp(pc, opcode));\n-\n-        if (nFound > 0) {\n-            result.insert(result.end(), pc2, end());\n-            *this = result;\n-        }\n-\n-        return nFound;\n-    }\n-    int Find(opcodetype op) const\n-    {\n-        int nFound = 0;\n-        opcodetype opcode;\n-        for (const_iterator pc = begin(); pc != end() && GetOp(pc, opcode);)\n-            if (opcode == op)\n-                ++nFound;\n-        return nFound;\n-    }\n-\n     /**\n      * Pre-version-0.6, Bitcoin always counted CHECKMULTISIGs\n      * as 20 sigops. With pay-to-script-hash, that changed:"
      },
      {
        "sha": "ac35f17f3e1df6df238a7c47ed9f6071431e0270",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 52,
        "deletions": 56,
        "changes": 108,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -6,7 +6,6 @@\n #include <script/sign.h>\n \n #include <key.h>\n-#include <keystore.h>\n #include <policy/policy.h>\n #include <primitives/transaction.h>\n #include <script/standard.h>\n@@ -15,16 +14,16 @@\n \n typedef std::vector<unsigned char> valtype;\n \n-TransactionSignatureCreator::TransactionSignatureCreator(const CKeyStore* keystoreIn, const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn) : BaseSignatureCreator(keystoreIn), txTo(txToIn), nIn(nInIn), nHashType(nHashTypeIn), amount(amountIn), checker(txTo, nIn, amountIn) {}\n+TransactionSignatureCreator::TransactionSignatureCreator(const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn) : txTo(txToIn), nIn(nInIn), nHashType(nHashTypeIn), amount(amountIn), checker(txTo, nIn, amountIn) {}\n \n-bool TransactionSignatureCreator::CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& address, const CScript& scriptCode, SigVersion sigversion) const\n+bool TransactionSignatureCreator::CreateSig(const SigningProvider& provider, std::vector<unsigned char>& vchSig, const CKeyID& address, const CScript& scriptCode, SigVersion sigversion) const\n {\n     CKey key;\n-    if (!keystore->GetKey(address, key))\n+    if (!provider.GetKey(address, key))\n         return false;\n \n     // Signing with uncompressed keys is disabled in witness scripts\n-    if (sigversion == SIGVERSION_WITNESS_V0 && !key.IsCompressed())\n+    if (sigversion == SigVersion::WITNESS_V0 && !key.IsCompressed())\n         return false;\n \n     uint256 hash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion);\n@@ -34,24 +33,24 @@ bool TransactionSignatureCreator::CreateSig(std::vector<unsigned char>& vchSig,\n     return true;\n }\n \n-static bool Sign1(const CKeyID& address, const BaseSignatureCreator& creator, const CScript& scriptCode, std::vector<valtype>& ret, SigVersion sigversion)\n+static bool Sign1(const SigningProvider& provider, const CKeyID& address, const BaseSignatureCreator& creator, const CScript& scriptCode, std::vector<valtype>& ret, SigVersion sigversion)\n {\n     std::vector<unsigned char> vchSig;\n-    if (!creator.CreateSig(vchSig, address, scriptCode, sigversion))\n+    if (!creator.CreateSig(provider, vchSig, address, scriptCode, sigversion))\n         return false;\n     ret.push_back(vchSig);\n     return true;\n }\n \n-static bool SignN(const std::vector<valtype>& multisigdata, const BaseSignatureCreator& creator, const CScript& scriptCode, std::vector<valtype>& ret, SigVersion sigversion)\n+static bool SignN(const SigningProvider& provider, const std::vector<valtype>& multisigdata, const BaseSignatureCreator& creator, const CScript& scriptCode, std::vector<valtype>& ret, SigVersion sigversion)\n {\n     int nSigned = 0;\n     int nRequired = multisigdata.front()[0];\n     for (unsigned int i = 1; i < multisigdata.size()-1 && nSigned < nRequired; i++)\n     {\n         const valtype& pubkey = multisigdata[i];\n         CKeyID keyID = CPubKey(pubkey).GetID();\n-        if (Sign1(keyID, creator, scriptCode, ret, sigversion))\n+        if (Sign1(provider, keyID, creator, scriptCode, ret, sigversion))\n             ++nSigned;\n     }\n     return nSigned==nRequired;\n@@ -63,7 +62,7 @@ static bool SignN(const std::vector<valtype>& multisigdata, const BaseSignatureC\n  * unless whichTypeRet is TX_SCRIPTHASH, in which case scriptSigRet is the redemption script.\n  * Returns false if scriptPubKey could not be completely satisfied.\n  */\n-static bool SignStep(const BaseSignatureCreator& creator, const CScript& scriptPubKey,\n+static bool SignStep(const SigningProvider& provider, const BaseSignatureCreator& creator, const CScript& scriptPubKey,\n                      std::vector<valtype>& ret, txnouttype& whichTypeRet, SigVersion sigversion)\n {\n     CScript scriptRet;\n@@ -83,36 +82,36 @@ static bool SignStep(const BaseSignatureCreator& creator, const CScript& scriptP\n         return false;\n     case TX_PUBKEY:\n         keyID = CPubKey(vSolutions[0]).GetID();\n-        return Sign1(keyID, creator, scriptPubKey, ret, sigversion);\n+        return Sign1(provider, keyID, creator, scriptPubKey, ret, sigversion);\n     case TX_PUBKEYHASH:\n         keyID = CKeyID(uint160(vSolutions[0]));\n-        if (!Sign1(keyID, creator, scriptPubKey, ret, sigversion))\n+        if (!Sign1(provider, keyID, creator, scriptPubKey, ret, sigversion))\n             return false;\n         else\n         {\n             CPubKey vch;\n-            creator.KeyStore().GetPubKey(keyID, vch);\n+            provider.GetPubKey(keyID, vch);\n             ret.push_back(ToByteVector(vch));\n         }\n         return true;\n     case TX_SCRIPTHASH:\n-        if (creator.KeyStore().GetCScript(uint160(vSolutions[0]), scriptRet)) {\n+        if (provider.GetCScript(uint160(vSolutions[0]), scriptRet)) {\n             ret.push_back(std::vector<unsigned char>(scriptRet.begin(), scriptRet.end()));\n             return true;\n         }\n         return false;\n \n     case TX_MULTISIG:\n         ret.push_back(valtype()); // workaround CHECKMULTISIG bug\n-        return (SignN(vSolutions, creator, scriptPubKey, ret, sigversion));\n+        return (SignN(provider, vSolutions, creator, scriptPubKey, ret, sigversion));\n \n     case TX_WITNESS_V0_KEYHASH:\n         ret.push_back(vSolutions[0]);\n         return true;\n \n     case TX_WITNESS_V0_SCRIPTHASH:\n         CRIPEMD160().Write(&vSolutions[0][0], vSolutions[0].size()).Finalize(h160.begin());\n-        if (creator.KeyStore().GetCScript(h160, scriptRet)) {\n+        if (provider.GetCScript(h160, scriptRet)) {\n             ret.push_back(std::vector<unsigned char>(scriptRet.begin(), scriptRet.end()));\n             return true;\n         }\n@@ -138,11 +137,11 @@ static CScript PushAll(const std::vector<valtype>& values)\n     return result;\n }\n \n-bool ProduceSignature(const BaseSignatureCreator& creator, const CScript& fromPubKey, SignatureData& sigdata)\n+bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreator& creator, const CScript& fromPubKey, SignatureData& sigdata)\n {\n     std::vector<valtype> result;\n     txnouttype whichType;\n-    bool solved = SignStep(creator, fromPubKey, result, whichType, SIGVERSION_BASE);\n+    bool solved = SignStep(provider, creator, fromPubKey, result, whichType, SigVersion::BASE);\n     bool P2SH = false;\n     CScript subscript;\n     sigdata.scriptWitness.stack.clear();\n@@ -153,7 +152,7 @@ bool ProduceSignature(const BaseSignatureCreator& creator, const CScript& fromPu\n         // the final scriptSig is the signatures from that\n         // and then the serialized subscript:\n         subscript = CScript(result[0].begin(), result[0].end());\n-        solved = solved && SignStep(creator, subscript, result, whichType, SIGVERSION_BASE) && whichType != TX_SCRIPTHASH;\n+        solved = solved && SignStep(provider, creator, subscript, result, whichType, SigVersion::BASE) && whichType != TX_SCRIPTHASH;\n         P2SH = true;\n     }\n \n@@ -162,15 +161,15 @@ bool ProduceSignature(const BaseSignatureCreator& creator, const CScript& fromPu\n         CScript witnessscript;\n         witnessscript << OP_DUP << OP_HASH160 << ToByteVector(result[0]) << OP_EQUALVERIFY << OP_CHECKSIG;\n         txnouttype subType;\n-        solved = solved && SignStep(creator, witnessscript, result, subType, SIGVERSION_WITNESS_V0);\n+        solved = solved && SignStep(provider, creator, witnessscript, result, subType, SigVersion::WITNESS_V0);\n         sigdata.scriptWitness.stack = result;\n         result.clear();\n     }\n     else if (solved && whichType == TX_WITNESS_V0_SCRIPTHASH)\n     {\n         CScript witnessscript(result[0].begin(), result[0].end());\n         txnouttype subType;\n-        solved = solved && SignStep(creator, witnessscript, result, subType, SIGVERSION_WITNESS_V0) && subType != TX_SCRIPTHASH && subType != TX_WITNESS_V0_SCRIPTHASH && subType != TX_WITNESS_V0_KEYHASH;\n+        solved = solved && SignStep(provider, creator, witnessscript, result, subType, SigVersion::WITNESS_V0) && subType != TX_SCRIPTHASH && subType != TX_WITNESS_V0_SCRIPTHASH && subType != TX_WITNESS_V0_KEYHASH;\n         result.push_back(std::vector<unsigned char>(witnessscript.begin(), witnessscript.end()));\n         sigdata.scriptWitness.stack = result;\n         result.clear();\n@@ -206,27 +205,27 @@ void UpdateTransaction(CMutableTransaction& tx, unsigned int nIn, const Signatur\n     UpdateInput(tx.vin[nIn], data);\n }\n \n-bool SignSignature(const CKeyStore &keystore, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, const CAmount& amount, int nHashType)\n+bool SignSignature(const SigningProvider &provider, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, const CAmount& amount, int nHashType)\n {\n     assert(nIn < txTo.vin.size());\n \n     CTransaction txToConst(txTo);\n-    TransactionSignatureCreator creator(&keystore, &txToConst, nIn, amount, nHashType);\n+    TransactionSignatureCreator creator(&txToConst, nIn, amount, nHashType);\n \n     SignatureData sigdata;\n-    bool ret = ProduceSignature(creator, fromPubKey, sigdata);\n+    bool ret = ProduceSignature(provider, creator, fromPubKey, sigdata);\n     UpdateTransaction(txTo, nIn, sigdata);\n     return ret;\n }\n \n-bool SignSignature(const CKeyStore &keystore, const CTransaction& txFrom, CMutableTransaction& txTo, unsigned int nIn, int nHashType)\n+bool SignSignature(const SigningProvider &provider, const CTransaction& txFrom, CMutableTransaction& txTo, unsigned int nIn, int nHashType)\n {\n     assert(nIn < txTo.vin.size());\n     CTxIn& txin = txTo.vin[nIn];\n     assert(txin.prevout.n < txFrom.vout.size());\n     const CTxOut& txout = txFrom.vout[txin.prevout.n];\n \n-    return SignSignature(keystore, txout.scriptPubKey, txTo, nIn, txout.nValue, nHashType);\n+    return SignSignature(provider, txout.scriptPubKey, txTo, nIn, txout.nValue, nHashType);\n }\n \n static std::vector<valtype> CombineMultisig(const CScript& scriptPubKey, const BaseSignatureChecker& checker,\n@@ -294,7 +293,7 @@ struct Stacks\n     Stacks() {}\n     explicit Stacks(const std::vector<valtype>& scriptSigStack_) : script(scriptSigStack_), witness() {}\n     explicit Stacks(const SignatureData& data) : witness(data.scriptWitness.stack) {\n-        EvalScript(script, data.scriptSig, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker(), SIGVERSION_BASE);\n+        EvalScript(script, data.scriptSig, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker(), SigVersion::BASE);\n     }\n \n     SignatureData Output() const {\n@@ -370,7 +369,7 @@ static Stacks CombineSignatures(const CScript& scriptPubKey, const BaseSignature\n             sigs2.witness.pop_back();\n             sigs2.script = sigs2.witness;\n             sigs2.witness.clear();\n-            Stacks result = CombineSignatures(pubKey2, checker, txType2, vSolutions2, sigs1, sigs2, SIGVERSION_WITNESS_V0);\n+            Stacks result = CombineSignatures(pubKey2, checker, txType2, vSolutions2, sigs1, sigs2, SigVersion::WITNESS_V0);\n             result.witness = result.script;\n             result.script.clear();\n             result.witness.push_back(valtype(pubKey2.begin(), pubKey2.end()));\n@@ -388,59 +387,56 @@ SignatureData CombineSignatures(const CScript& scriptPubKey, const BaseSignature\n     std::vector<std::vector<unsigned char> > vSolutions;\n     Solver(scriptPubKey, txType, vSolutions);\n \n-    return CombineSignatures(scriptPubKey, checker, txType, vSolutions, Stacks(scriptSig1), Stacks(scriptSig2), SIGVERSION_BASE).Output();\n+    return CombineSignatures(scriptPubKey, checker, txType, vSolutions, Stacks(scriptSig1), Stacks(scriptSig2), SigVersion::BASE).Output();\n }\n \n namespace {\n /** Dummy signature checker which accepts all signatures. */\n-class DummySignatureChecker : public BaseSignatureChecker\n+class DummySignatureChecker final : public BaseSignatureChecker\n {\n public:\n     DummySignatureChecker() {}\n+    bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override { return true; }\n+};\n+const DummySignatureChecker DUMMY_CHECKER;\n \n-    bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override\n+class DummySignatureCreator final : public BaseSignatureCreator {\n+public:\n+    DummySignatureCreator() {}\n+    const BaseSignatureChecker& Checker() const override { return DUMMY_CHECKER; }\n+    bool CreateSig(const SigningProvider& provider, std::vector<unsigned char>& vchSig, const CKeyID& keyid, const CScript& scriptCode, SigVersion sigversion) const override\n     {\n+        // Create a dummy signature that is a valid DER-encoding\n+        vchSig.assign(72, '\\000');\n+        vchSig[0] = 0x30;\n+        vchSig[1] = 69;\n+        vchSig[2] = 0x02;\n+        vchSig[3] = 33;\n+        vchSig[4] = 0x01;\n+        vchSig[4 + 33] = 0x02;\n+        vchSig[5 + 33] = 32;\n+        vchSig[6 + 33] = 0x01;\n+        vchSig[6 + 33 + 32] = SIGHASH_ALL;\n         return true;\n     }\n };\n-const DummySignatureChecker dummyChecker;\n-} // namespace\n-\n-const BaseSignatureChecker& DummySignatureCreator::Checker() const\n-{\n-    return dummyChecker;\n }\n \n-bool DummySignatureCreator::CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& keyid, const CScript& scriptCode, SigVersion sigversion) const\n-{\n-    // Create a dummy signature that is a valid DER-encoding\n-    vchSig.assign(72, '\\000');\n-    vchSig[0] = 0x30;\n-    vchSig[1] = 69;\n-    vchSig[2] = 0x02;\n-    vchSig[3] = 33;\n-    vchSig[4] = 0x01;\n-    vchSig[4 + 33] = 0x02;\n-    vchSig[5 + 33] = 32;\n-    vchSig[6 + 33] = 0x01;\n-    vchSig[6 + 33 + 32] = SIGHASH_ALL;\n-    return true;\n-}\n+const BaseSignatureCreator& DUMMY_SIGNATURE_CREATOR = DummySignatureCreator();\n \n-bool IsSolvable(const CKeyStore& store, const CScript& script)\n+bool IsSolvable(const SigningProvider& provider, const CScript& script)\n {\n     // This check is to make sure that the script we created can actually be solved for and signed by us\n     // if we were to have the private keys. This is just to make sure that the script is valid and that,\n     // if found in a transaction, we would still accept and relay that transaction. In particular,\n     // it will reject witness outputs that require signing with an uncompressed public key.\n-    DummySignatureCreator creator(&store);\n     SignatureData sigs;\n     // Make sure that STANDARD_SCRIPT_VERIFY_FLAGS includes SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, the most\n     // important property this function is designed to test for.\n     static_assert(STANDARD_SCRIPT_VERIFY_FLAGS & SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, \"IsSolvable requires standard script flags to include WITNESS_PUBKEYTYPE\");\n-    if (ProduceSignature(creator, script, sigs)) {\n+    if (ProduceSignature(provider, DUMMY_SIGNATURE_CREATOR, script, sigs)) {\n         // VerifyScript check is just defensive, and should never fail.\n-        assert(VerifyScript(sigs.scriptSig, script, &sigs.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, creator.Checker()));\n+        assert(VerifyScript(sigs.scriptSig, script, &sigs.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, DUMMY_CHECKER));\n         return true;\n     }\n     return false;"
      },
      {
        "sha": "cf3651c1de0f6e101b147ad24783406f1690be3a",
        "filename": "src/script/sign.h",
        "status": "modified",
        "additions": 23,
        "deletions": 22,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/script/sign.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/script/sign.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -8,26 +8,32 @@\n \n #include <script/interpreter.h>\n \n+class CKey;\n class CKeyID;\n-class CKeyStore;\n class CScript;\n+class CScriptID;\n class CTransaction;\n \n struct CMutableTransaction;\n \n-/** Virtual base class for signature creators. */\n-class BaseSignatureCreator {\n-protected:\n-    const CKeyStore* keystore;\n+/** An interface to be implemented by keystores that support signing. */\n+class SigningProvider\n+{\n+public:\n+    virtual ~SigningProvider() {}\n+    virtual bool GetCScript(const CScriptID &scriptid, CScript& script) const =0;\n+    virtual bool GetPubKey(const CKeyID &address, CPubKey& pubkey) const =0;\n+    virtual bool GetKey(const CKeyID &address, CKey& key) const =0;\n+};\n \n+/** Interface for signature creators. */\n+class BaseSignatureCreator {\n public:\n-    explicit BaseSignatureCreator(const CKeyStore* keystoreIn) : keystore(keystoreIn) {}\n-    const CKeyStore& KeyStore() const { return *keystore; };\n     virtual ~BaseSignatureCreator() {}\n     virtual const BaseSignatureChecker& Checker() const =0;\n \n     /** Create a singular (non-script) signature. */\n-    virtual bool CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& keyid, const CScript& scriptCode, SigVersion sigversion) const =0;\n+    virtual bool CreateSig(const SigningProvider& provider, std::vector<unsigned char>& vchSig, const CKeyID& keyid, const CScript& scriptCode, SigVersion sigversion) const =0;\n };\n \n /** A signature creator for transactions. */\n@@ -39,25 +45,20 @@ class TransactionSignatureCreator : public BaseSignatureCreator {\n     const TransactionSignatureChecker checker;\n \n public:\n-    TransactionSignatureCreator(const CKeyStore* keystoreIn, const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn=SIGHASH_ALL);\n+    TransactionSignatureCreator(const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn=SIGHASH_ALL);\n     const BaseSignatureChecker& Checker() const override { return checker; }\n-    bool CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& keyid, const CScript& scriptCode, SigVersion sigversion) const override;\n+    bool CreateSig(const SigningProvider& provider, std::vector<unsigned char>& vchSig, const CKeyID& keyid, const CScript& scriptCode, SigVersion sigversion) const override;\n };\n \n class MutableTransactionSignatureCreator : public TransactionSignatureCreator {\n     CTransaction tx;\n \n public:\n-    MutableTransactionSignatureCreator(const CKeyStore* keystoreIn, const CMutableTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn) : TransactionSignatureCreator(keystoreIn, &tx, nInIn, amountIn, nHashTypeIn), tx(*txToIn) {}\n+    MutableTransactionSignatureCreator(const CMutableTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn) : TransactionSignatureCreator(&tx, nInIn, amountIn, nHashTypeIn), tx(*txToIn) {}\n };\n \n /** A signature creator that just produces 72-byte empty signatures. */\n-class DummySignatureCreator : public BaseSignatureCreator {\n-public:\n-    explicit DummySignatureCreator(const CKeyStore* keystoreIn) : BaseSignatureCreator(keystoreIn) {}\n-    const BaseSignatureChecker& Checker() const override;\n-    bool CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& keyid, const CScript& scriptCode, SigVersion sigversion) const override;\n-};\n+extern const BaseSignatureCreator& DUMMY_SIGNATURE_CREATOR;\n \n struct SignatureData {\n     CScript scriptSig;\n@@ -68,11 +69,11 @@ struct SignatureData {\n };\n \n /** Produce a script signature using a generic signature creator. */\n-bool ProduceSignature(const BaseSignatureCreator& creator, const CScript& scriptPubKey, SignatureData& sigdata);\n+bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreator& creator, const CScript& scriptPubKey, SignatureData& sigdata);\n \n /** Produce a script signature for a transaction. */\n-bool SignSignature(const CKeyStore &keystore, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, const CAmount& amount, int nHashType);\n-bool SignSignature(const CKeyStore& keystore, const CTransaction& txFrom, CMutableTransaction& txTo, unsigned int nIn, int nHashType);\n+bool SignSignature(const SigningProvider &provider, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, const CAmount& amount, int nHashType);\n+bool SignSignature(const SigningProvider &provider, const CTransaction& txFrom, CMutableTransaction& txTo, unsigned int nIn, int nHashType);\n \n /** Combine two script signatures using a generic signature checker, intelligently, possibly with OP_0 placeholders. */\n SignatureData CombineSignatures(const CScript& scriptPubKey, const BaseSignatureChecker& checker, const SignatureData& scriptSig1, const SignatureData& scriptSig2);\n@@ -84,8 +85,8 @@ void UpdateInput(CTxIn& input, const SignatureData& data);\n \n /* Check whether we know how to sign for an output like this, assuming we\n  * have all private keys. While this function does not need private keys, the passed\n- * keystore is used to look up public keys and redeemscripts by hash.\n+ * provider is used to look up public keys and redeemscripts by hash.\n  * Solvability is unrelated to whether we consider this output to be ours. */\n-bool IsSolvable(const CKeyStore& store, const CScript& script);\n+bool IsSolvable(const SigningProvider& provider, const CScript& script);\n \n #endif // BITCOIN_SCRIPT_SIGN_H"
      },
      {
        "sha": "76778112aadd97d4f7c0300ea276e3ed15fdcecc",
        "filename": "src/script/standard.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/script/standard.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/script/standard.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standard.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -66,12 +66,12 @@ bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<std::v\n     int witnessversion;\n     std::vector<unsigned char> witnessprogram;\n     if (scriptPubKey.IsWitnessProgram(witnessversion, witnessprogram)) {\n-        if (witnessversion == 0 && witnessprogram.size() == 20) {\n+        if (witnessversion == 0 && witnessprogram.size() == WITNESS_V0_KEYHASH_SIZE) {\n             typeRet = TX_WITNESS_V0_KEYHASH;\n             vSolutionsRet.push_back(witnessprogram);\n             return true;\n         }\n-        if (witnessversion == 0 && witnessprogram.size() == 32) {\n+        if (witnessversion == 0 && witnessprogram.size() == WITNESS_V0_SCRIPTHASH_SIZE) {\n             typeRet = TX_WITNESS_V0_SCRIPTHASH;\n             vSolutionsRet.push_back(witnessprogram);\n             return true;\n@@ -132,7 +132,7 @@ bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<std::v\n             // Template matching opcodes:\n             if (opcode2 == OP_PUBKEYS)\n             {\n-                while (vch1.size() >= 33 && vch1.size() <= 65)\n+                while (CPubKey::ValidSize(vch1))\n                 {\n                     vSolutionsRet.push_back(vch1);\n                     if (!script1.GetOp(pc1, opcode1, vch1))\n@@ -146,7 +146,7 @@ bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<std::v\n \n             if (opcode2 == OP_PUBKEY)\n             {\n-                if (vch1.size() < 33 || vch1.size() > 65)\n+                if (!CPubKey::ValidSize(vch1))\n                     break;\n                 vSolutionsRet.push_back(vch1);\n             }"
      },
      {
        "sha": "4922b7236bd424bcf22b54f856daf83dd9e2c5d9",
        "filename": "src/script/standard.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/script/standard.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/script/standard.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standard.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -23,7 +23,7 @@ class CScriptID : public uint160\n {\n public:\n     CScriptID() : uint160() {}\n-    CScriptID(const CScript& in);\n+    explicit CScriptID(const CScript& in);\n     CScriptID(const uint160& in) : uint160(in) {}\n };\n "
      },
      {
        "sha": "e54c7483d2f796c7fb3f5e85ccba4d28a6dcd670",
        "filename": "src/serialize.h",
        "status": "modified",
        "additions": 66,
        "deletions": 40,
        "changes": 106,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/serialize.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/serialize.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/serialize.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -22,6 +22,7 @@\n #include <vector>\n \n #include <prevector.h>\n+#include <span.h>\n \n static const unsigned int MAX_SIZE = 0x02000000;\n \n@@ -41,7 +42,7 @@ constexpr deserialize_type deserialize {};\n \n /**\n  * Used to bypass the rule against non-const reference to temporary\n- * where it makes sense with wrappers such as CFlatData or CTxDB\n+ * where it makes sense with wrappers.\n  */\n template<typename T>\n inline T& REF(const T& val)\n@@ -59,6 +60,12 @@ inline T* NCONST_PTR(const T* val)\n     return const_cast<T*>(val);\n }\n \n+//! Safely convert odd char pointer types to standard ones.\n+inline char* CharCast(char* c) { return c; }\n+inline char* CharCast(unsigned char* c) { return (char*)c; }\n+inline const char* CharCast(const char* c) { return c; }\n+inline const char* CharCast(const unsigned char* c) { return (const char*)c; }\n+\n /*\n  * Lowest-level serialization and conversion.\n  * @note Sizes of these types are verified in the tests\n@@ -72,6 +79,11 @@ template<typename Stream> inline void ser_writedata16(Stream &s, uint16_t obj)\n     obj = htole16(obj);\n     s.write((char*)&obj, 2);\n }\n+template<typename Stream> inline void ser_writedata16be(Stream &s, uint16_t obj)\n+{\n+    obj = htobe16(obj);\n+    s.write((char*)&obj, 2);\n+}\n template<typename Stream> inline void ser_writedata32(Stream &s, uint32_t obj)\n {\n     obj = htole32(obj);\n@@ -94,6 +106,12 @@ template<typename Stream> inline uint16_t ser_readdata16(Stream &s)\n     s.read((char*)&obj, 2);\n     return le16toh(obj);\n }\n+template<typename Stream> inline uint16_t ser_readdata16be(Stream &s)\n+{\n+    uint16_t obj;\n+    s.read((char*)&obj, 2);\n+    return be16toh(obj);\n+}\n template<typename Stream> inline uint32_t ser_readdata32(Stream &s)\n {\n     uint32_t obj;\n@@ -148,7 +166,12 @@ enum\n     SER_GETHASH         = (1 << 2),\n };\n \n-#define READWRITE(...)      (::SerReadWriteMany(s, ser_action, __VA_ARGS__))\n+//! Convert the reference base type to X, without changing constness or reference type.\n+template<typename X> X& ReadWriteAsHelper(X& x) { return x; }\n+template<typename X> const X& ReadWriteAsHelper(const X& x) { return x; }\n+\n+#define READWRITE(...) (::SerReadWriteMany(s, ser_action, __VA_ARGS__))\n+#define READWRITEAS(type, obj) (::SerReadWriteMany(s, ser_action, ReadWriteAsHelper<type>(obj)))\n \n /** \n  * Implement three methods for serializable objects. These are actually wrappers over\n@@ -177,6 +200,10 @@ template<typename Stream> inline void Serialize(Stream& s, int64_t a ) { ser_wri\n template<typename Stream> inline void Serialize(Stream& s, uint64_t a) { ser_writedata64(s, a); }\n template<typename Stream> inline void Serialize(Stream& s, float a   ) { ser_writedata32(s, ser_float_to_uint32(a)); }\n template<typename Stream> inline void Serialize(Stream& s, double a  ) { ser_writedata64(s, ser_double_to_uint64(a)); }\n+template<typename Stream, int N> inline void Serialize(Stream& s, const char (&a)[N]) { s.write(a, N); }\n+template<typename Stream, int N> inline void Serialize(Stream& s, const unsigned char (&a)[N]) { s.write(CharCast(a), N); }\n+template<typename Stream> inline void Serialize(Stream& s, const Span<const unsigned char>& span) { s.write(CharCast(span.data()), span.size()); }\n+template<typename Stream> inline void Serialize(Stream& s, const Span<unsigned char>& span) { s.write(CharCast(span.data()), span.size()); }\n \n template<typename Stream> inline void Unserialize(Stream& s, char& a    ) { a = ser_readdata8(s); } // TODO Get rid of bare char\n template<typename Stream> inline void Unserialize(Stream& s, int8_t& a  ) { a = ser_readdata8(s); }\n@@ -189,6 +216,9 @@ template<typename Stream> inline void Unserialize(Stream& s, int64_t& a ) { a =\n template<typename Stream> inline void Unserialize(Stream& s, uint64_t& a) { a = ser_readdata64(s); }\n template<typename Stream> inline void Unserialize(Stream& s, float& a   ) { a = ser_uint32_to_float(ser_readdata32(s)); }\n template<typename Stream> inline void Unserialize(Stream& s, double& a  ) { a = ser_uint64_to_double(ser_readdata64(s)); }\n+template<typename Stream, int N> inline void Unserialize(Stream& s, char (&a)[N]) { s.read(a, N); }\n+template<typename Stream, int N> inline void Unserialize(Stream& s, unsigned char (&a)[N]) { s.read(CharCast(a), N); }\n+template<typename Stream> inline void Unserialize(Stream& s, Span<unsigned char>& span) { s.read(CharCast(span.data()), span.size()); }\n \n template<typename Stream> inline void Serialize(Stream& s, bool a)    { char f=a; ser_writedata8(s, f); }\n template<typename Stream> inline void Unserialize(Stream& s, bool& a) { char f=ser_readdata8(s); a=f; }\n@@ -374,67 +404,60 @@ I ReadVarInt(Stream& is)\n     }\n }\n \n-#define FLATDATA(obj) CFlatData((char*)&(obj), (char*)&(obj) + sizeof(obj))\n #define VARINT(obj, ...) WrapVarInt<__VA_ARGS__>(REF(obj))\n #define COMPACTSIZE(obj) CCompactSize(REF(obj))\n #define LIMITED_STRING(obj,n) LimitedString< n >(REF(obj))\n \n-/** \n- * Wrapper for serializing arrays and POD.\n- */\n-class CFlatData\n+template<VarIntMode Mode, typename I>\n+class CVarInt\n {\n protected:\n-    char* pbegin;\n-    char* pend;\n+    I &n;\n public:\n-    CFlatData(void* pbeginIn, void* pendIn) : pbegin((char*)pbeginIn), pend((char*)pendIn) { }\n-    template <class T, class TAl>\n-    explicit CFlatData(std::vector<T,TAl> &v)\n-    {\n-        pbegin = (char*)v.data();\n-        pend = (char*)(v.data() + v.size());\n-    }\n-    template <unsigned int N, typename T, typename S, typename D>\n-    explicit CFlatData(prevector<N, T, S, D> &v)\n-    {\n-        pbegin = (char*)v.data();\n-        pend = (char*)(v.data() + v.size());\n-    }\n-    char* begin() { return pbegin; }\n-    const char* begin() const { return pbegin; }\n-    char* end() { return pend; }\n-    const char* end() const { return pend; }\n+    explicit CVarInt(I& nIn) : n(nIn) { }\n \n     template<typename Stream>\n-    void Serialize(Stream& s) const\n-    {\n-        s.write(pbegin, pend - pbegin);\n+    void Serialize(Stream &s) const {\n+        WriteVarInt<Stream,Mode,I>(s, n);\n     }\n \n     template<typename Stream>\n-    void Unserialize(Stream& s)\n-    {\n-        s.read(pbegin, pend - pbegin);\n+    void Unserialize(Stream& s) {\n+        n = ReadVarInt<Stream,Mode,I>(s);\n     }\n };\n \n-template<VarIntMode Mode, typename I>\n-class CVarInt\n+/** Serialization wrapper class for big-endian integers.\n+ *\n+ * Use this wrapper around integer types that are stored in memory in native\n+ * byte order, but serialized in big endian notation. This is only intended\n+ * to implement serializers that are compatible with existing formats, and\n+ * its use is not recommended for new data structures.\n+ *\n+ * Only 16-bit types are supported for now.\n+ */\n+template<typename I>\n+class BigEndian\n {\n protected:\n-    I &n;\n+    I& m_val;\n public:\n-    explicit CVarInt(I& nIn) : n(nIn) { }\n+    explicit BigEndian(I& val) : m_val(val)\n+    {\n+        static_assert(std::is_unsigned<I>::value, \"BigEndian type must be unsigned integer\");\n+        static_assert(sizeof(I) == 2 && std::numeric_limits<I>::min() == 0 && std::numeric_limits<I>::max() == std::numeric_limits<uint16_t>::max(), \"Unsupported BigEndian size\");\n+    }\n \n     template<typename Stream>\n-    void Serialize(Stream &s) const {\n-        WriteVarInt<Stream,Mode,I>(s, n);\n+    void Serialize(Stream& s) const\n+    {\n+        ser_writedata16be(s, m_val);\n     }\n \n     template<typename Stream>\n-    void Unserialize(Stream& s) {\n-        n = ReadVarInt<Stream,Mode,I>(s);\n+    void Unserialize(Stream& s)\n+    {\n+        m_val = ser_readdata16be(s);\n     }\n };\n \n@@ -488,6 +511,9 @@ class LimitedString\n template<VarIntMode Mode=VarIntMode::DEFAULT, typename I>\n CVarInt<Mode, I> WrapVarInt(I& n) { return CVarInt<Mode, I>{n}; }\n \n+template<typename I>\n+BigEndian<I> WrapBigEndian(I& n) { return BigEndian<I>(n); }\n+\n /**\n  * Forward declarations\n  */"
      },
      {
        "sha": "707fc2191869c7b00d68e96ceaec02f7d58fef98",
        "filename": "src/span.h",
        "status": "added",
        "additions": 40,
        "deletions": 0,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/span.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/span.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/span.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -0,0 +1,40 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SPAN_H\n+#define BITCOIN_SPAN_H\n+\n+#include <type_traits>\n+#include <cstddef>\n+\n+/** A Span is an object that can refer to a contiguous sequence of objects.\n+ *\n+ * It implements a subset of C++20's std::span.\n+ */\n+template<typename C>\n+class Span\n+{\n+    C* m_data;\n+    std::ptrdiff_t m_size;\n+\n+public:\n+    constexpr Span() noexcept : m_data(nullptr), m_size(0) {}\n+    constexpr Span(C* data, std::ptrdiff_t size) noexcept : m_data(data), m_size(size) {}\n+\n+    constexpr C* data() const noexcept { return m_data; }\n+    constexpr std::ptrdiff_t size() const noexcept { return m_size; }\n+};\n+\n+/** Create a span to a container exposing data() and size().\n+ *\n+ * This correctly deals with constness: the returned Span's element type will be\n+ * whatever data() returns a pointer to. If either the passed container is const,\n+ * or its element type is const, the resulting span will have a const element type.\n+ *\n+ * std::span will have a constructor that implements this functionality directly.\n+ */\n+template<typename V>\n+constexpr Span<typename std::remove_pointer<decltype(std::declval<V>().data())>::type> MakeSpan(V& v) { return Span<typename std::remove_pointer<decltype(std::declval<V>().data())>::type>(v.data(), v.size()); }\n+\n+#endif"
      },
      {
        "sha": "a273424b5111523724a7a84496dd1e6d86f84e46",
        "filename": "src/support/lockedpool.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/support/lockedpool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/support/lockedpool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/support/lockedpool.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -141,7 +141,7 @@ Arena::Stats Arena::stats() const\n }\n \n #ifdef ARENA_DEBUG\n-void printchunk(char* base, size_t sz, bool used) {\n+static void printchunk(char* base, size_t sz, bool used) {\n     std::cout <<\n         \"0x\" << std::hex << std::setw(16) << std::setfill('0') << base <<\n         \" 0x\" << std::hex << std::setw(16) << std::setfill('0') << sz <<"
      },
      {
        "sha": "6f21d498ee7f809a620ec6715bd9a41fcd4057d8",
        "filename": "src/sync.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/sync.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/sync.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sync.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -4,6 +4,7 @@\n \n #include <sync.h>\n \n+#include <memory>\n #include <set>\n #include <util.h>\n #include <utilstrencodings.h>\n@@ -80,20 +81,20 @@ static void potential_deadlock_detected(const std::pair<void*, void*>& mismatch,\n     LogPrintf(\"Previous lock order was:\\n\");\n     for (const std::pair<void*, CLockLocation> & i : s2) {\n         if (i.first == mismatch.first) {\n-            LogPrintf(\" (1)\");\n+            LogPrintf(\" (1)\"); /* Continued */\n         }\n         if (i.first == mismatch.second) {\n-            LogPrintf(\" (2)\");\n+            LogPrintf(\" (2)\"); /* Continued */\n         }\n         LogPrintf(\" %s\\n\", i.second.ToString());\n     }\n     LogPrintf(\"Current lock order is:\\n\");\n     for (const std::pair<void*, CLockLocation> & i : s1) {\n         if (i.first == mismatch.first) {\n-            LogPrintf(\" (1)\");\n+            LogPrintf(\" (1)\"); /* Continued */\n         }\n         if (i.first == mismatch.second) {\n-            LogPrintf(\" (2)\");\n+            LogPrintf(\" (2)\"); /* Continued */\n         }\n         LogPrintf(\" %s\\n\", i.second.ToString());\n     }"
      },
      {
        "sha": "1868aed7dd6735113d645f4ce85f8292daa46ca8",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -31,7 +31,7 @@ struct COrphanTx {\n };\n extern std::map<uint256, COrphanTx> mapOrphanTransactions;\n \n-CService ip(uint32_t i)\n+static CService ip(uint32_t i)\n {\n     struct in_addr s;\n     s.s_addr = i;\n@@ -92,7 +92,7 @@ BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n     peerLogic->FinalizeNode(dummyNode1.GetId(), dummy);\n }\n \n-void AddRandomOutboundPeer(std::vector<CNode *> &vNodes, PeerLogicValidation &peerLogic)\n+static void AddRandomOutboundPeer(std::vector<CNode *> &vNodes, PeerLogicValidation &peerLogic)\n {\n     CAddress addr(ip(GetRandInt(0xffffffff)), NODE_NONE);\n     vNodes.emplace_back(new CNode(id++, ServiceFlags(NODE_NETWORK|NODE_WITNESS), 0, INVALID_SOCKET, addr, 0, 0, CAddress(), \"\", /*fInboundIn=*/ false));\n@@ -291,7 +291,7 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n     peerLogic->FinalizeNode(dummyNode.GetId(), dummy);\n }\n \n-CTransactionRef RandomOrphan()\n+static CTransactionRef RandomOrphan()\n {\n     std::map<uint256, COrphanTx>::iterator it;\n     LOCK(cs_main);"
      },
      {
        "sha": "ee3650d148a02ff605da05f13955f1d26d8fe0de",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 33,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -98,22 +98,22 @@ BOOST_AUTO_TEST_CASE(addrman_simple)\n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n     // Test: Does Addrman respond correctly when empty.\n-    BOOST_CHECK_EQUAL(addrman.size(), 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0U);\n     CAddrInfo addr_null = addrman.Select();\n     BOOST_CHECK_EQUAL(addr_null.ToString(), \"[::]:0\");\n \n     // Test: Does Addrman::Add work as expected.\n     CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n     BOOST_CHECK(addrman.Add(CAddress(addr1, NODE_NONE), source));\n-    BOOST_CHECK_EQUAL(addrman.size(), 1);\n+    BOOST_CHECK_EQUAL(addrman.size(), 1U);\n     CAddrInfo addr_ret1 = addrman.Select();\n     BOOST_CHECK_EQUAL(addr_ret1.ToString(), \"250.1.1.1:8333\");\n \n     // Test: Does IP address deduplication work correctly.\n     //  Expected dup IP should not be added.\n     CService addr1_dup = ResolveService(\"250.1.1.1\", 8333);\n     BOOST_CHECK(!addrman.Add(CAddress(addr1_dup, NODE_NONE), source));\n-    BOOST_CHECK_EQUAL(addrman.size(), 1);\n+    BOOST_CHECK_EQUAL(addrman.size(), 1U);\n \n \n     // Test: New table has one addr and we add a diff addr we should\n@@ -128,7 +128,7 @@ BOOST_AUTO_TEST_CASE(addrman_simple)\n \n     // Test: AddrMan::Clear() should empty the new table.\n     addrman.Clear();\n-    BOOST_CHECK_EQUAL(addrman.size(), 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0U);\n     CAddrInfo addr_null2 = addrman.Select();\n     BOOST_CHECK_EQUAL(addr_null2.ToString(), \"[::]:0\");\n \n@@ -146,23 +146,23 @@ BOOST_AUTO_TEST_CASE(addrman_ports)\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n-    BOOST_CHECK_EQUAL(addrman.size(), 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0U);\n \n     // Test 7; Addr with same IP but diff port does not replace existing addr.\n     CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n     addrman.Add(CAddress(addr1, NODE_NONE), source);\n-    BOOST_CHECK_EQUAL(addrman.size(), 1);\n+    BOOST_CHECK_EQUAL(addrman.size(), 1U);\n \n     CService addr1_port = ResolveService(\"250.1.1.1\", 8334);\n     addrman.Add(CAddress(addr1_port, NODE_NONE), source);\n-    BOOST_CHECK_EQUAL(addrman.size(), 1);\n+    BOOST_CHECK_EQUAL(addrman.size(), 1U);\n     CAddrInfo addr_ret2 = addrman.Select();\n     BOOST_CHECK_EQUAL(addr_ret2.ToString(), \"250.1.1.1:8333\");\n \n     // Test: Add same IP but diff port to tried table, it doesn't get added.\n     //  Perhaps this is not ideal behavior but it is the current behavior.\n     addrman.Good(CAddress(addr1_port, NODE_NONE));\n-    BOOST_CHECK_EQUAL(addrman.size(), 1);\n+    BOOST_CHECK_EQUAL(addrman.size(), 1U);\n     bool newOnly = true;\n     CAddrInfo addr_ret3 = addrman.Select(newOnly);\n     BOOST_CHECK_EQUAL(addr_ret3.ToString(), \"250.1.1.1:8333\");\n@@ -178,22 +178,22 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     // Test: Select from new with 1 addr in new.\n     CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n     addrman.Add(CAddress(addr1, NODE_NONE), source);\n-    BOOST_CHECK_EQUAL(addrman.size(), 1);\n+    BOOST_CHECK_EQUAL(addrman.size(), 1U);\n \n     bool newOnly = true;\n     CAddrInfo addr_ret1 = addrman.Select(newOnly);\n     BOOST_CHECK_EQUAL(addr_ret1.ToString(), \"250.1.1.1:8333\");\n \n     // Test: move addr to tried, select from new expected nothing returned.\n     addrman.Good(CAddress(addr1, NODE_NONE));\n-    BOOST_CHECK_EQUAL(addrman.size(), 1);\n+    BOOST_CHECK_EQUAL(addrman.size(), 1U);\n     CAddrInfo addr_ret2 = addrman.Select(newOnly);\n     BOOST_CHECK_EQUAL(addr_ret2.ToString(), \"[::]:0\");\n \n     CAddrInfo addr_ret3 = addrman.Select();\n     BOOST_CHECK_EQUAL(addr_ret3.ToString(), \"250.1.1.1:8333\");\n \n-    BOOST_CHECK_EQUAL(addrman.size(), 1);\n+    BOOST_CHECK_EQUAL(addrman.size(), 1U);\n \n \n     // Add three addresses to new table.\n@@ -218,14 +218,14 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     addrman.Good(CAddress(addr7, NODE_NONE));\n \n     // Test: 6 addrs + 1 addr from last test = 7.\n-    BOOST_CHECK_EQUAL(addrman.size(), 7);\n+    BOOST_CHECK_EQUAL(addrman.size(), 7U);\n \n     // Test: Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman.Select().GetPort());\n     }\n-    BOOST_CHECK_EQUAL(ports.size(), 3);\n+    BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n BOOST_AUTO_TEST_CASE(addrman_new_collisions)\n@@ -234,7 +234,7 @@ BOOST_AUTO_TEST_CASE(addrman_new_collisions)\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n-    BOOST_CHECK_EQUAL(addrman.size(), 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0U);\n \n     for (unsigned int i = 1; i < 18; i++) {\n         CService addr = ResolveService(\"250.1.1.\" + std::to_string(i));\n@@ -247,11 +247,11 @@ BOOST_AUTO_TEST_CASE(addrman_new_collisions)\n     //Test: new table collision!\n     CService addr1 = ResolveService(\"250.1.1.18\");\n     addrman.Add(CAddress(addr1, NODE_NONE), source);\n-    BOOST_CHECK_EQUAL(addrman.size(), 17);\n+    BOOST_CHECK_EQUAL(addrman.size(), 17U);\n \n     CService addr2 = ResolveService(\"250.1.1.19\");\n     addrman.Add(CAddress(addr2, NODE_NONE), source);\n-    BOOST_CHECK_EQUAL(addrman.size(), 18);\n+    BOOST_CHECK_EQUAL(addrman.size(), 18U);\n }\n \n BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n@@ -260,7 +260,7 @@ BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n-    BOOST_CHECK_EQUAL(addrman.size(), 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0U);\n \n     for (unsigned int i = 1; i < 80; i++) {\n         CService addr = ResolveService(\"250.1.1.\" + std::to_string(i));\n@@ -274,18 +274,18 @@ BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n     //Test: tried table collision!\n     CService addr1 = ResolveService(\"250.1.1.80\");\n     addrman.Add(CAddress(addr1, NODE_NONE), source);\n-    BOOST_CHECK_EQUAL(addrman.size(), 79);\n+    BOOST_CHECK_EQUAL(addrman.size(), 79U);\n \n     CService addr2 = ResolveService(\"250.1.1.81\");\n     addrman.Add(CAddress(addr2, NODE_NONE), source);\n-    BOOST_CHECK_EQUAL(addrman.size(), 80);\n+    BOOST_CHECK_EQUAL(addrman.size(), 80U);\n }\n \n BOOST_AUTO_TEST_CASE(addrman_find)\n {\n     CAddrManTest addrman;\n \n-    BOOST_CHECK_EQUAL(addrman.size(), 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0U);\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n     CAddress addr2 = CAddress(ResolveService(\"250.1.2.1\", 9999), NODE_NONE);\n@@ -318,7 +318,7 @@ BOOST_AUTO_TEST_CASE(addrman_create)\n {\n     CAddrManTest addrman;\n \n-    BOOST_CHECK_EQUAL(addrman.size(), 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0U);\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n     CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n@@ -338,7 +338,7 @@ BOOST_AUTO_TEST_CASE(addrman_delete)\n {\n     CAddrManTest addrman;\n \n-    BOOST_CHECK_EQUAL(addrman.size(), 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0U);\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n     CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n@@ -347,9 +347,9 @@ BOOST_AUTO_TEST_CASE(addrman_delete)\n     addrman.Create(addr1, source1, &nId);\n \n     // Test: Delete should actually delete the addr.\n-    BOOST_CHECK_EQUAL(addrman.size(), 1);\n+    BOOST_CHECK_EQUAL(addrman.size(), 1U);\n     addrman.Delete(nId);\n-    BOOST_CHECK_EQUAL(addrman.size(), 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0U);\n     CAddrInfo* info2 = addrman.Find(addr1);\n     BOOST_CHECK(info2 == nullptr);\n }\n@@ -360,9 +360,9 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n \n     // Test: Sanity check, GetAddr should never return anything if addrman\n     //  is empty.\n-    BOOST_CHECK_EQUAL(addrman.size(), 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0U);\n     std::vector<CAddress> vAddr1 = addrman.GetAddr();\n-    BOOST_CHECK_EQUAL(vAddr1.size(), 0);\n+    BOOST_CHECK_EQUAL(vAddr1.size(), 0U);\n \n     CAddress addr1 = CAddress(ResolveService(\"250.250.2.1\", 8333), NODE_NONE);\n     addr1.nTime = GetAdjustedTime(); // Set time so isTerrible = false\n@@ -385,12 +385,12 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n     addrman.Add(addr5, source1);\n \n     // GetAddr returns 23% of addresses, 23% of 5 is 1 rounded down.\n-    BOOST_CHECK_EQUAL(addrman.GetAddr().size(), 1);\n+    BOOST_CHECK_EQUAL(addrman.GetAddr().size(), 1U);\n \n     // Test: Ensure GetAddr works with new and tried addresses.\n     addrman.Good(CAddress(addr1, NODE_NONE));\n     addrman.Good(CAddress(addr2, NODE_NONE));\n-    BOOST_CHECK_EQUAL(addrman.GetAddr().size(), 1);\n+    BOOST_CHECK_EQUAL(addrman.GetAddr().size(), 1U);\n \n     // Test: Ensure GetAddr still returns 23% when addrman has many addrs.\n     for (unsigned int i = 1; i < (8 * 256); i++) {\n@@ -409,9 +409,9 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n \n     size_t percent23 = (addrman.size() * 23) / 100;\n     BOOST_CHECK_EQUAL(vAddr.size(), percent23);\n-    BOOST_CHECK_EQUAL(vAddr.size(), 461);\n+    BOOST_CHECK_EQUAL(vAddr.size(), 461U);\n     // (Addrman.size() < number of addresses added) due to address collisions.\n-    BOOST_CHECK_EQUAL(addrman.size(), 2006);\n+    BOOST_CHECK_EQUAL(addrman.size(), 2006U);\n }\n \n \n@@ -454,7 +454,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n     }\n     // Test: IP addresses in the same group (\\16 prefix for IPv4) should\n     //  never get more than 8 buckets\n-    BOOST_CHECK_EQUAL(buckets.size(), 8);\n+    BOOST_CHECK_EQUAL(buckets.size(), 8U);\n \n     buckets.clear();\n     for (int j = 0; j < 255; j++) {\n@@ -466,7 +466,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n     }\n     // Test: IP addresses in the different groups should map to more than\n     //  8 buckets.\n-    BOOST_CHECK_EQUAL(buckets.size(), 160);\n+    BOOST_CHECK_EQUAL(buckets.size(), 160U);\n }\n \n BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n@@ -506,7 +506,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n     }\n     // Test: IP addresses in the same group (\\16 prefix for IPv4) should\n     //  always map to the same bucket.\n-    BOOST_CHECK_EQUAL(buckets.size(), 1);\n+    BOOST_CHECK_EQUAL(buckets.size(), 1U);\n \n     buckets.clear();\n     for (int j = 0; j < 4 * 255; j++) {"
      },
      {
        "sha": "67d1229c7010eb1be0839ef3d1390fc331e11291",
        "filename": "src/test/allocator_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/allocator_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/allocator_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/allocator_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -7,6 +7,8 @@\n #include <support/allocators/secure.h>\n #include <test/test_bitcoin.h>\n \n+#include <memory>\n+\n #include <boost/test/unit_test.hpp>\n \n BOOST_FIXTURE_TEST_SUITE(allocator_tests, BasicTestingSetup)\n@@ -62,10 +64,10 @@ BOOST_AUTO_TEST_CASE(arena_tests)\n     BOOST_CHECK(b.stats().used == 128);\n     b.free(a3);\n     BOOST_CHECK(b.stats().used == 0);\n-    BOOST_CHECK_EQUAL(b.stats().chunks_used, 0);\n+    BOOST_CHECK_EQUAL(b.stats().chunks_used, 0U);\n     BOOST_CHECK(b.stats().total == synth_size);\n     BOOST_CHECK(b.stats().free == synth_size);\n-    BOOST_CHECK_EQUAL(b.stats().chunks_free, 1);\n+    BOOST_CHECK_EQUAL(b.stats().chunks_free, 1U);\n \n     std::vector<void*> addr;\n     BOOST_CHECK(b.alloc(0) == nullptr); // allocating 0 always returns nullptr"
      },
      {
        "sha": "13ec19834a9c7f09ad921c9506c0f264904fe8a3",
        "filename": "src/test/arith_uint256_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/arith_uint256_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/arith_uint256_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/arith_uint256_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -17,7 +17,7 @@\n BOOST_FIXTURE_TEST_SUITE(arith_uint256_tests, BasicTestingSetup)\n \n /// Convert vector to arith_uint256, via uint256 blob\n-inline arith_uint256 arith_uint256V(const std::vector<unsigned char>& vch)\n+static inline arith_uint256 arith_uint256V(const std::vector<unsigned char>& vch)\n {\n     return UintToArith256(uint256(vch));\n }\n@@ -53,7 +53,7 @@ const unsigned char MaxArray[] =\n const arith_uint256 MaxL = arith_uint256V(std::vector<unsigned char>(MaxArray,MaxArray+32));\n \n const arith_uint256 HalfL = (OneL << 255);\n-std::string ArrayToString(const unsigned char A[], unsigned int width)\n+static std::string ArrayToString(const unsigned char A[], unsigned int width)\n {\n     std::stringstream Stream;\n     Stream << std::hex;\n@@ -122,7 +122,7 @@ BOOST_AUTO_TEST_CASE( basics ) // constructors, equality, inequality\n     tmpL = ~MaxL; BOOST_CHECK(tmpL == ~MaxL);\n }\n \n-void shiftArrayRight(unsigned char* to, const unsigned char* from, unsigned int arrayLength, unsigned int bitsToShift)\n+static void shiftArrayRight(unsigned char* to, const unsigned char* from, unsigned int arrayLength, unsigned int bitsToShift)\n {\n     for (unsigned int T=0; T < arrayLength; ++T)\n     {\n@@ -136,7 +136,7 @@ void shiftArrayRight(unsigned char* to, const unsigned char* from, unsigned int\n     }\n }\n \n-void shiftArrayLeft(unsigned char* to, const unsigned char* from, unsigned int arrayLength, unsigned int bitsToShift)\n+static void shiftArrayLeft(unsigned char* to, const unsigned char* from, unsigned int arrayLength, unsigned int bitsToShift)\n {\n     for (unsigned int T=0; T < arrayLength; ++T)\n     {\n@@ -369,7 +369,7 @@ BOOST_AUTO_TEST_CASE( divide )\n }\n \n \n-bool almostEqual(double d1, double d2)\n+static bool almostEqual(double d1, double d2)\n {\n     return fabs(d1-d2) <= 4*fabs(d1)*std::numeric_limits<double>::epsilon();\n }"
      },
      {
        "sha": "c23e23f6a124669b4055510b2c441709511fd8c4",
        "filename": "src/test/bech32_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/bech32_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/bech32_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/bech32_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -9,7 +9,7 @@\n \n BOOST_FIXTURE_TEST_SUITE(bech32_tests, BasicTestingSetup)\n \n-bool CaseInsensitiveEqual(const std::string &s1, const std::string &s2)\n+static bool CaseInsensitiveEqual(const std::string &s1, const std::string &s2)\n {\n     if (s1.size() != s2.size()) return false;\n     for (size_t i = 0; i < s1.size(); ++i) {"
      },
      {
        "sha": "51308847f6e8eafc8d390d890a4e1912d3a40c17",
        "filename": "src/test/bip32_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/bip32_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/bip32_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/bip32_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -87,7 +87,7 @@ TestVector test3 =\n      \"xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L\",\n       0);\n \n-void RunTest(const TestVector &test) {\n+static void RunTest(const TestVector &test) {\n     std::vector<unsigned char> seed = ParseHex(test.strHexMaster);\n     CExtKey key;\n     CExtPubKey pubkey;"
      },
      {
        "sha": "5b8df321580521805746692139bbf807cdb223a5",
        "filename": "src/test/blockchain_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/blockchain_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/blockchain_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/blockchain_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -8,12 +8,12 @@\n /* Equality between doubles is imprecise. Comparison should be done\n  * with a small threshold of tolerance, rather than exact equality.\n  */\n-bool DoubleEquals(double a, double b, double epsilon)\n+static bool DoubleEquals(double a, double b, double epsilon)\n {\n     return std::abs(a - b) < epsilon;\n }\n \n-CBlockIndex* CreateBlockIndexWithNbits(uint32_t nbits)\n+static CBlockIndex* CreateBlockIndexWithNbits(uint32_t nbits)\n {\n     CBlockIndex* block_index = new CBlockIndex();\n     block_index->nHeight = 46367;\n@@ -22,15 +22,15 @@ CBlockIndex* CreateBlockIndexWithNbits(uint32_t nbits)\n     return block_index;\n }\n \n-CChain CreateChainWithNbits(uint32_t nbits)\n+static CChain CreateChainWithNbits(uint32_t nbits)\n {\n     CBlockIndex* block_index = CreateBlockIndexWithNbits(nbits);\n     CChain chain;\n     chain.SetTip(block_index);\n     return chain;\n }\n \n-void RejectDifficultyMismatch(double difficulty, double expected_difficulty) {\n+static void RejectDifficultyMismatch(double difficulty, double expected_difficulty) {\n      BOOST_CHECK_MESSAGE(\n         DoubleEquals(difficulty, expected_difficulty, 0.00001),\n         \"Difficulty was \" + std::to_string(difficulty)\n@@ -40,7 +40,7 @@ void RejectDifficultyMismatch(double difficulty, double expected_difficulty) {\n /* Given a BlockIndex with the provided nbits,\n  * verify that the expected difficulty results.\n  */\n-void TestDifficulty(uint32_t nbits, double expected_difficulty)\n+static void TestDifficulty(uint32_t nbits, double expected_difficulty)\n {\n     CBlockIndex* block_index = CreateBlockIndexWithNbits(nbits);\n     /* Since we are passing in block index explicitly,\n@@ -54,7 +54,7 @@ void TestDifficulty(uint32_t nbits, double expected_difficulty)\n     RejectDifficultyMismatch(difficulty, expected_difficulty);\n }\n \n-BOOST_FIXTURE_TEST_SUITE(blockchain_difficulty_tests, BasicTestingSetup)\n+BOOST_FIXTURE_TEST_SUITE(blockchain_tests, BasicTestingSetup)\n \n BOOST_AUTO_TEST_CASE(get_difficulty_for_very_low_target)\n {"
      },
      {
        "sha": "8cffacbffeed771ed3f1cfb87ac9e1b0a9a66d16",
        "filename": "src/test/blockencodings_tests.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 10,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/blockencodings_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/blockencodings_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/blockencodings_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -52,16 +52,16 @@ static CBlock BuildBlockTestCase() {\n }\n \n // Number of shared use_counts we expect for a tx we haven't touched\n-// == 2 (mempool + our copy from the GetSharedTx call)\n-#define SHARED_TX_OFFSET 2\n+// (block + mempool + our copy from the GetSharedTx call)\n+constexpr long SHARED_TX_OFFSET{3};\n \n BOOST_AUTO_TEST_CASE(SimpleRoundTripTest)\n {\n     CTxMemPool pool;\n     TestMemPoolEntryHelper entry;\n     CBlock block(BuildBlockTestCase());\n \n-    pool.addUnchecked(block.vtx[2]->GetHash(), entry.FromTx(*block.vtx[2]));\n+    pool.addUnchecked(block.vtx[2]->GetHash(), entry.FromTx(block.vtx[2]));\n     LOCK(pool.cs);\n     BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[2]->GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 0);\n \n@@ -161,7 +161,7 @@ BOOST_AUTO_TEST_CASE(NonCoinbasePreforwardRTTest)\n     TestMemPoolEntryHelper entry;\n     CBlock block(BuildBlockTestCase());\n \n-    pool.addUnchecked(block.vtx[2]->GetHash(), entry.FromTx(*block.vtx[2]));\n+    pool.addUnchecked(block.vtx[2]->GetHash(), entry.FromTx(block.vtx[2]));\n     LOCK(pool.cs);\n     BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[2]->GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 0);\n \n@@ -188,7 +188,7 @@ BOOST_AUTO_TEST_CASE(NonCoinbasePreforwardRTTest)\n         BOOST_CHECK( partialBlock.IsTxAvailable(1));\n         BOOST_CHECK( partialBlock.IsTxAvailable(2));\n \n-        BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[2]->GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 1);\n+        BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[2]->GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 1); // +1 because of partialBlock\n \n         CBlock block2;\n         {\n@@ -203,6 +203,7 @@ BOOST_AUTO_TEST_CASE(NonCoinbasePreforwardRTTest)\n             partialBlock.FillBlock(block2, {block.vtx[1]}); // Current implementation doesn't check txn here, but don't require that\n             partialBlock = tmp;\n         }\n+        BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[2]->GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 2); // +2 because of partialBlock and block2\n         bool mutated;\n         BOOST_CHECK(block.hashMerkleRoot != BlockMerkleRoot(block2, &mutated));\n \n@@ -213,13 +214,15 @@ BOOST_AUTO_TEST_CASE(NonCoinbasePreforwardRTTest)\n         BOOST_CHECK_EQUAL(block.hashMerkleRoot.ToString(), BlockMerkleRoot(block3, &mutated).ToString());\n         BOOST_CHECK(!mutated);\n \n+        BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[2]->GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 3); // +2 because of partialBlock and block2 and block3\n+\n         txhash = block.vtx[2]->GetHash();\n         block.vtx.clear();\n         block2.vtx.clear();\n         block3.vtx.clear();\n-        BOOST_CHECK_EQUAL(pool.mapTx.find(txhash)->GetSharedTx().use_count(), SHARED_TX_OFFSET + 1); // + 1 because of partialBlockCopy.\n+        BOOST_CHECK_EQUAL(pool.mapTx.find(txhash)->GetSharedTx().use_count(), SHARED_TX_OFFSET + 1 - 1); // + 1 because of partialBlock; -1 because of block.\n     }\n-    BOOST_CHECK_EQUAL(pool.mapTx.find(txhash)->GetSharedTx().use_count(), SHARED_TX_OFFSET + 0);\n+    BOOST_CHECK_EQUAL(pool.mapTx.find(txhash)->GetSharedTx().use_count(), SHARED_TX_OFFSET - 1); // -1 because of block\n }\n \n BOOST_AUTO_TEST_CASE(SufficientPreforwardRTTest)\n@@ -228,7 +231,7 @@ BOOST_AUTO_TEST_CASE(SufficientPreforwardRTTest)\n     TestMemPoolEntryHelper entry;\n     CBlock block(BuildBlockTestCase());\n \n-    pool.addUnchecked(block.vtx[1]->GetHash(), entry.FromTx(*block.vtx[1]));\n+    pool.addUnchecked(block.vtx[1]->GetHash(), entry.FromTx(block.vtx[1]));\n     LOCK(pool.cs);\n     BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[1]->GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 0);\n \n@@ -268,9 +271,9 @@ BOOST_AUTO_TEST_CASE(SufficientPreforwardRTTest)\n         txhash = block.vtx[1]->GetHash();\n         block.vtx.clear();\n         block2.vtx.clear();\n-        BOOST_CHECK_EQUAL(pool.mapTx.find(txhash)->GetSharedTx().use_count(), SHARED_TX_OFFSET + 1); // + 1 because of partialBlockCopy.\n+        BOOST_CHECK_EQUAL(pool.mapTx.find(txhash)->GetSharedTx().use_count(), SHARED_TX_OFFSET + 1 - 1); // + 1 because of partialBlock; -1 because of block.\n     }\n-    BOOST_CHECK_EQUAL(pool.mapTx.find(txhash)->GetSharedTx().use_count(), SHARED_TX_OFFSET + 0);\n+    BOOST_CHECK_EQUAL(pool.mapTx.find(txhash)->GetSharedTx().use_count(), SHARED_TX_OFFSET - 1); // -1 because of block\n }\n \n BOOST_AUTO_TEST_CASE(EmptyBlockRoundTripTest)"
      },
      {
        "sha": "17f3004ef39660fcd0659ad2dc49076a0ad5215c",
        "filename": "src/test/bloom_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/bloom_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/bloom_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/bloom_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -185,7 +185,7 @@ BOOST_AUTO_TEST_CASE(merkle_block_1)\n     CMerkleBlock merkleBlock(block, filter);\n     BOOST_CHECK_EQUAL(merkleBlock.header.GetHash().GetHex(), block.GetHash().GetHex());\n \n-    BOOST_CHECK_EQUAL(merkleBlock.vMatchedTxn.size(), 1);\n+    BOOST_CHECK_EQUAL(merkleBlock.vMatchedTxn.size(), 1U);\n     std::pair<unsigned int, uint256> pair = merkleBlock.vMatchedTxn[0];\n \n     BOOST_CHECK(merkleBlock.vMatchedTxn[0].second == uint256S(\"0x74d681e0e03bafa802c8aa084379aa98d9fcd632ddc2ed9782b586ec87451f20\"));"
      },
      {
        "sha": "c8de7f4a7cd10dfcf2ebf7a914fc3dc5befa78e4",
        "filename": "src/test/checkqueue_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/checkqueue_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/checkqueue_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/checkqueue_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -146,7 +146,7 @@ typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n /** This test case checks that the CCheckQueue works properly\n  * with each specified size_t Checks pushed.\n  */\n-void Correct_Queue_range(std::vector<size_t> range)\n+static void Correct_Queue_range(std::vector<size_t> range)\n {\n     auto small_queue = std::unique_ptr<Correct_Queue>(new Correct_Queue {QUEUE_BATCH_SIZE});\n     boost::thread_group tg;\n@@ -331,7 +331,7 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Memory)\n                 control.Add(vChecks);\n             }\n         }\n-        BOOST_REQUIRE_EQUAL(MemoryCheck::fake_allocated_memory, 0);\n+        BOOST_REQUIRE_EQUAL(MemoryCheck::fake_allocated_memory, 0U);\n     }\n     tg.interrupt_all();\n     tg.join_all();"
      },
      {
        "sha": "276d5b80ee93bc32bbe90419cace390f9df15820",
        "filename": "src/test/coins_tests.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/coins_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/coins_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/coins_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -480,16 +480,16 @@ BOOST_AUTO_TEST_CASE(ccoins_serialization)\n     Coin cc1;\n     ss1 >> cc1;\n     BOOST_CHECK_EQUAL(cc1.fCoinBase, false);\n-    BOOST_CHECK_EQUAL(cc1.nHeight, 203998);\n-    BOOST_CHECK_EQUAL(cc1.out.nValue, 60000000000ULL);\n+    BOOST_CHECK_EQUAL(cc1.nHeight, 203998U);\n+    BOOST_CHECK_EQUAL(cc1.out.nValue, CAmount{60000000000});\n     BOOST_CHECK_EQUAL(HexStr(cc1.out.scriptPubKey), HexStr(GetScriptForDestination(CKeyID(uint160(ParseHex(\"816115944e077fe7c803cfa57f29b36bf87c1d35\"))))));\n \n     // Good example\n     CDataStream ss2(ParseHex(\"8ddf77bbd123008c988f1a4a4de2161e0f50aac7f17e7f9555caa4\"), SER_DISK, CLIENT_VERSION);\n     Coin cc2;\n     ss2 >> cc2;\n     BOOST_CHECK_EQUAL(cc2.fCoinBase, true);\n-    BOOST_CHECK_EQUAL(cc2.nHeight, 120891);\n+    BOOST_CHECK_EQUAL(cc2.nHeight, 120891U);\n     BOOST_CHECK_EQUAL(cc2.out.nValue, 110397);\n     BOOST_CHECK_EQUAL(HexStr(cc2.out.scriptPubKey), HexStr(GetScriptForDestination(CKeyID(uint160(ParseHex(\"8c988f1a4a4de2161e0f50aac7f17e7f9555caa4\"))))));\n \n@@ -498,9 +498,9 @@ BOOST_AUTO_TEST_CASE(ccoins_serialization)\n     Coin cc3;\n     ss3 >> cc3;\n     BOOST_CHECK_EQUAL(cc3.fCoinBase, false);\n-    BOOST_CHECK_EQUAL(cc3.nHeight, 0);\n+    BOOST_CHECK_EQUAL(cc3.nHeight, 0U);\n     BOOST_CHECK_EQUAL(cc3.out.nValue, 0);\n-    BOOST_CHECK_EQUAL(cc3.out.scriptPubKey.size(), 0);\n+    BOOST_CHECK_EQUAL(cc3.out.scriptPubKey.size(), 0U);\n \n     // scriptPubKey that ends beyond the end of the stream\n     CDataStream ss4(ParseHex(\"000007\"), SER_DISK, CLIENT_VERSION);\n@@ -540,7 +540,7 @@ const static auto FLAGS = {char(0), FRESH, DIRTY, char(DIRTY | FRESH)};\n const static auto CLEAN_FLAGS = {char(0), FRESH};\n const static auto ABSENT_FLAGS = {NO_ENTRY};\n \n-void SetCoinsValue(CAmount value, Coin& coin)\n+static void SetCoinsValue(CAmount value, Coin& coin)\n {\n     assert(value != ABSENT);\n     coin.Clear();\n@@ -552,7 +552,7 @@ void SetCoinsValue(CAmount value, Coin& coin)\n     }\n }\n \n-size_t InsertCoinsMapEntry(CCoinsMap& map, CAmount value, char flags)\n+static size_t InsertCoinsMapEntry(CCoinsMap& map, CAmount value, char flags)\n {\n     if (value == ABSENT) {\n         assert(flags == NO_ENTRY);\n@@ -605,7 +605,7 @@ class SingleEntryCacheTest\n     CCoinsViewCacheTest cache{&base};\n };\n \n-void CheckAccessCoin(CAmount base_value, CAmount cache_value, CAmount expected_value, char cache_flags, char expected_flags)\n+static void CheckAccessCoin(CAmount base_value, CAmount cache_value, CAmount expected_value, char cache_flags, char expected_flags)\n {\n     SingleEntryCacheTest test(base_value, cache_value, cache_flags);\n     test.cache.AccessCoin(OUTPOINT);\n@@ -656,7 +656,7 @@ BOOST_AUTO_TEST_CASE(ccoins_access)\n     CheckAccessCoin(VALUE1, VALUE2, VALUE2, DIRTY|FRESH, DIRTY|FRESH);\n }\n \n-void CheckSpendCoins(CAmount base_value, CAmount cache_value, CAmount expected_value, char cache_flags, char expected_flags)\n+static void CheckSpendCoins(CAmount base_value, CAmount cache_value, CAmount expected_value, char cache_flags, char expected_flags)\n {\n     SingleEntryCacheTest test(base_value, cache_value, cache_flags);\n     test.cache.SpendCoin(OUTPOINT);\n@@ -707,7 +707,7 @@ BOOST_AUTO_TEST_CASE(ccoins_spend)\n     CheckSpendCoins(VALUE1, VALUE2, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n }\n \n-void CheckAddCoinBase(CAmount base_value, CAmount cache_value, CAmount modify_value, CAmount expected_value, char cache_flags, char expected_flags, bool coinbase)\n+static void CheckAddCoinBase(CAmount base_value, CAmount cache_value, CAmount modify_value, CAmount expected_value, char cache_flags, char expected_flags, bool coinbase)\n {\n     SingleEntryCacheTest test(base_value, cache_value, cache_flags);\n \n@@ -734,7 +734,7 @@ void CheckAddCoinBase(CAmount base_value, CAmount cache_value, CAmount modify_va\n // while still verifying that the CoinsViewCache::AddCoin implementation\n // ignores base values.\n template <typename... Args>\n-void CheckAddCoin(Args&&... args)\n+static void CheckAddCoin(Args&&... args)\n {\n     for (CAmount base_value : {ABSENT, PRUNED, VALUE1})\n         CheckAddCoinBase(base_value, std::forward<Args>(args)...);"
      },
      {
        "sha": "127cc154df5f04da54a6ac1d7fc8f49b9971f3d3",
        "filename": "src/test/compress_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/compress_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/compress_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/compress_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -25,16 +25,16 @@\n BOOST_FIXTURE_TEST_SUITE(compress_tests, BasicTestingSetup)\n \n bool static TestEncode(uint64_t in) {\n-    return in == CTxOutCompressor::DecompressAmount(CTxOutCompressor::CompressAmount(in));\n+    return in == DecompressAmount(CompressAmount(in));\n }\n \n bool static TestDecode(uint64_t in) {\n-    return in == CTxOutCompressor::CompressAmount(CTxOutCompressor::DecompressAmount(in));\n+    return in == CompressAmount(DecompressAmount(in));\n }\n \n bool static TestPair(uint64_t dec, uint64_t enc) {\n-    return CTxOutCompressor::CompressAmount(dec) == enc &&\n-           CTxOutCompressor::DecompressAmount(enc) == dec;\n+    return CompressAmount(dec) == enc &&\n+           DecompressAmount(enc) == dec;\n }\n \n BOOST_AUTO_TEST_CASE(compress_amounts)"
      },
      {
        "sha": "518cb849bb1b351217afdb5e752052799c286a4d",
        "filename": "src/test/crypto_tests.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 15,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/crypto_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/crypto_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/crypto_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -23,7 +23,7 @@\n BOOST_FIXTURE_TEST_SUITE(crypto_tests, BasicTestingSetup)\n \n template<typename Hasher, typename In, typename Out>\n-void TestVector(const Hasher &h, const In &in, const Out &out) {\n+static void TestVector(const Hasher &h, const In &in, const Out &out) {\n     Out hash;\n     BOOST_CHECK(out.size() == h.OUTPUT_SIZE);\n     hash.resize(out.size());\n@@ -51,22 +51,22 @@ void TestVector(const Hasher &h, const In &in, const Out &out) {\n     }\n }\n \n-void TestSHA1(const std::string &in, const std::string &hexout) { TestVector(CSHA1(), in, ParseHex(hexout));}\n-void TestSHA256(const std::string &in, const std::string &hexout) { TestVector(CSHA256(), in, ParseHex(hexout));}\n-void TestSHA512(const std::string &in, const std::string &hexout) { TestVector(CSHA512(), in, ParseHex(hexout));}\n-void TestRIPEMD160(const std::string &in, const std::string &hexout) { TestVector(CRIPEMD160(), in, ParseHex(hexout));}\n+static void TestSHA1(const std::string &in, const std::string &hexout) { TestVector(CSHA1(), in, ParseHex(hexout));}\n+static void TestSHA256(const std::string &in, const std::string &hexout) { TestVector(CSHA256(), in, ParseHex(hexout));}\n+static void TestSHA512(const std::string &in, const std::string &hexout) { TestVector(CSHA512(), in, ParseHex(hexout));}\n+static void TestRIPEMD160(const std::string &in, const std::string &hexout) { TestVector(CRIPEMD160(), in, ParseHex(hexout));}\n \n-void TestHMACSHA256(const std::string &hexkey, const std::string &hexin, const std::string &hexout) {\n+static void TestHMACSHA256(const std::string &hexkey, const std::string &hexin, const std::string &hexout) {\n     std::vector<unsigned char> key = ParseHex(hexkey);\n     TestVector(CHMAC_SHA256(key.data(), key.size()), ParseHex(hexin), ParseHex(hexout));\n }\n \n-void TestHMACSHA512(const std::string &hexkey, const std::string &hexin, const std::string &hexout) {\n+static void TestHMACSHA512(const std::string &hexkey, const std::string &hexin, const std::string &hexout) {\n     std::vector<unsigned char> key = ParseHex(hexkey);\n     TestVector(CHMAC_SHA512(key.data(), key.size()), ParseHex(hexin), ParseHex(hexout));\n }\n \n-void TestAES128(const std::string &hexkey, const std::string &hexin, const std::string &hexout)\n+static void TestAES128(const std::string &hexkey, const std::string &hexin, const std::string &hexout)\n {\n     std::vector<unsigned char> key = ParseHex(hexkey);\n     std::vector<unsigned char> in = ParseHex(hexin);\n@@ -86,7 +86,7 @@ void TestAES128(const std::string &hexkey, const std::string &hexin, const std::\n     BOOST_CHECK_EQUAL(HexStr(buf2), HexStr(in));\n }\n \n-void TestAES256(const std::string &hexkey, const std::string &hexin, const std::string &hexout)\n+static void TestAES256(const std::string &hexkey, const std::string &hexin, const std::string &hexout)\n {\n     std::vector<unsigned char> key = ParseHex(hexkey);\n     std::vector<unsigned char> in = ParseHex(hexin);\n@@ -105,7 +105,7 @@ void TestAES256(const std::string &hexkey, const std::string &hexin, const std::\n     BOOST_CHECK(buf == in);\n }\n \n-void TestAES128CBC(const std::string &hexkey, const std::string &hexiv, bool pad, const std::string &hexin, const std::string &hexout)\n+static void TestAES128CBC(const std::string &hexkey, const std::string &hexiv, bool pad, const std::string &hexin, const std::string &hexout)\n {\n     std::vector<unsigned char> key = ParseHex(hexkey);\n     std::vector<unsigned char> iv = ParseHex(hexiv);\n@@ -146,7 +146,7 @@ void TestAES128CBC(const std::string &hexkey, const std::string &hexiv, bool pad\n     }\n }\n \n-void TestAES256CBC(const std::string &hexkey, const std::string &hexiv, bool pad, const std::string &hexin, const std::string &hexout)\n+static void TestAES256CBC(const std::string &hexkey, const std::string &hexiv, bool pad, const std::string &hexin, const std::string &hexout)\n {\n     std::vector<unsigned char> key = ParseHex(hexkey);\n     std::vector<unsigned char> iv = ParseHex(hexiv);\n@@ -187,7 +187,7 @@ void TestAES256CBC(const std::string &hexkey, const std::string &hexiv, bool pad\n     }\n }\n \n-void TestChaCha20(const std::string &hexkey, uint64_t nonce, uint64_t seek, const std::string& hexout)\n+static void TestChaCha20(const std::string &hexkey, uint64_t nonce, uint64_t seek, const std::string& hexout)\n {\n     std::vector<unsigned char> key = ParseHex(hexkey);\n     ChaCha20 rng(key.data(), key.size());\n@@ -200,7 +200,7 @@ void TestChaCha20(const std::string &hexkey, uint64_t nonce, uint64_t seek, cons\n     BOOST_CHECK(out == outres);\n }\n \n-std::string LongTestString(void) {\n+static std::string LongTestString(void) {\n     std::string ret;\n     for (int i=0; i<200000; i++) {\n         ret += (unsigned char)(i);\n@@ -527,10 +527,10 @@ BOOST_AUTO_TEST_CASE(chacha20_testvector)\n BOOST_AUTO_TEST_CASE(countbits_tests)\n {\n     FastRandomContext ctx;\n-    for (int i = 0; i <= 64; ++i) {\n+    for (unsigned int i = 0; i <= 64; ++i) {\n         if (i == 0) {\n             // Check handling of zero.\n-            BOOST_CHECK_EQUAL(CountBits(0), 0);\n+            BOOST_CHECK_EQUAL(CountBits(0), 0U);\n         } else if (i < 10) {\n             for (uint64_t j = 1 << (i - 1); (j >> i) == 0; ++j) {\n                 // Exhaustively test up to 10 bits"
      },
      {
        "sha": "857ab8a1b74c3262ce969176bb7ac97cd64fca96",
        "filename": "src/test/cuckoocache_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/cuckoocache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/cuckoocache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/cuckoocache_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -28,7 +28,7 @@ BOOST_AUTO_TEST_SUITE(cuckoocache_tests);\n \n /** insecure_GetRandHash fills in a uint256 from local_rand_ctx\n  */\n-void insecure_GetRandHash(uint256& t)\n+static void insecure_GetRandHash(uint256& t)\n {\n     uint32_t* ptr = (uint32_t*)t.begin();\n     for (uint8_t j = 0; j < 8; ++j)\n@@ -62,7 +62,7 @@ BOOST_AUTO_TEST_CASE(test_cuckoocache_no_fakes)\n  * inserted into a megabytes sized cache\n  */\n template <typename Cache>\n-double test_cache(size_t megabytes, double load)\n+static double test_cache(size_t megabytes, double load)\n {\n     local_rand_ctx = FastRandomContext(true);\n     std::vector<uint256> hashes;\n@@ -109,7 +109,7 @@ double test_cache(size_t megabytes, double load)\n  * how you measure around load 1.0 as after load 1.0 your normalized hit rate\n  * becomes effectively perfect, ignoring freshness.\n  */\n-double normalize_hit_rate(double hits, double load)\n+static double normalize_hit_rate(double hits, double load)\n {\n     return hits * std::max(load, 1.0);\n }\n@@ -132,7 +132,7 @@ BOOST_AUTO_TEST_CASE(cuckoocache_hit_rate_ok)\n /** This helper checks that erased elements are preferentially inserted onto and\n  * that the hit rate of \"fresher\" keys is reasonable*/\n template <typename Cache>\n-void test_cache_erase(size_t megabytes)\n+static void test_cache_erase(size_t megabytes)\n {\n     double load = 1;\n     local_rand_ctx = FastRandomContext(true);\n@@ -195,7 +195,7 @@ BOOST_AUTO_TEST_CASE(cuckoocache_erase_ok)\n }\n \n template <typename Cache>\n-void test_cache_erase_parallel(size_t megabytes)\n+static void test_cache_erase_parallel(size_t megabytes)\n {\n     double load = 1;\n     local_rand_ctx = FastRandomContext(true);\n@@ -283,7 +283,7 @@ BOOST_AUTO_TEST_CASE(cuckoocache_erase_parallel_ok)\n \n \n template <typename Cache>\n-void test_cache_generations()\n+static void test_cache_generations()\n {\n     // This test checks that for a simulation of network activity, the fresh hit\n     // rate is never below 99%, and the number of times that it is worse than"
      },
      {
        "sha": "97edc98bf62ebcb49bfc6c9971b7297cdb863eb4",
        "filename": "src/test/data/script_tests.json",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/data/script_tests.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/data/script_tests.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/script_tests.json?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -2553,22 +2553,22 @@\n [[\"01\", \"635168\", 0.00000001], \"\", \"0 0x20 0xc7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"P2SH,WITNESS\", \"OK\"],\n [[\"02\", \"635168\", 0.00000001], \"\", \"0 0x20 0xc7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"P2SH,WITNESS\", \"OK\"],\n [[\"0100\", \"635168\", 0.00000001], \"\", \"0 0x20 0xc7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"P2SH,WITNESS\", \"OK\"],\n-[[\"\", \"635168\", 0.00000001], \"\", \"0 0x20 0xc7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"P2SH,WITNESS\", \"EVAL_FALSE\"],\n-[[\"00\", \"635168\", 0.00000001], \"\", \"0 0x20 0xc7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"P2SH,WITNESS\", \"EVAL_FALSE\"],\n+[[\"\", \"635168\", 0.00000001], \"\", \"0 0x20 0xc7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"P2SH,WITNESS\", \"CLEANSTACK\"],\n+[[\"00\", \"635168\", 0.00000001], \"\", \"0 0x20 0xc7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"P2SH,WITNESS\", \"CLEANSTACK\"],\n [[\"01\", \"635168\", 0.00000001], \"\", \"0 0x20 0xc7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"P2SH,WITNESS,MINIMALIF\", \"OK\"],\n [[\"02\", \"635168\", 0.00000001], \"\", \"0 0x20 0xc7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"P2SH,WITNESS,MINIMALIF\", \"MINIMALIF\"],\n [[\"0100\", \"635168\", 0.00000001], \"\", \"0 0x20 0xc7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"P2SH,WITNESS,MINIMALIF\", \"MINIMALIF\"],\n-[[\"\", \"635168\", 0.00000001], \"\", \"0 0x20 0xc7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"P2SH,WITNESS,MINIMALIF\", \"EVAL_FALSE\"],\n+[[\"\", \"635168\", 0.00000001], \"\", \"0 0x20 0xc7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"P2SH,WITNESS,MINIMALIF\", \"CLEANSTACK\"],\n [[\"00\", \"635168\", 0.00000001], \"\", \"0 0x20 0xc7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"P2SH,WITNESS,MINIMALIF\", \"MINIMALIF\"],\n [[\"635168\", 0.00000001], \"\", \"0 0x20 0xc7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"P2SH,WITNESS\", \"UNBALANCED_CONDITIONAL\"],\n [[\"635168\", 0.00000001], \"\", \"0 0x20 0xc7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"P2SH,WITNESS,MINIMALIF\", \"UNBALANCED_CONDITIONAL\"],\n [\"P2WSH NOTIF 1 ENDIF\"],\n-[[\"01\", \"645168\", 0.00000001], \"\", \"0 0x20 0xf913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"P2SH,WITNESS\", \"EVAL_FALSE\"],\n-[[\"02\", \"645168\", 0.00000001], \"\", \"0 0x20 0xf913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"P2SH,WITNESS\", \"EVAL_FALSE\"],\n-[[\"0100\", \"645168\", 0.00000001], \"\", \"0 0x20 0xf913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"P2SH,WITNESS\", \"EVAL_FALSE\"],\n+[[\"01\", \"645168\", 0.00000001], \"\", \"0 0x20 0xf913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"P2SH,WITNESS\", \"CLEANSTACK\"],\n+[[\"02\", \"645168\", 0.00000001], \"\", \"0 0x20 0xf913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"P2SH,WITNESS\", \"CLEANSTACK\"],\n+[[\"0100\", \"645168\", 0.00000001], \"\", \"0 0x20 0xf913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"P2SH,WITNESS\", \"CLEANSTACK\"],\n [[\"\", \"645168\", 0.00000001], \"\", \"0 0x20 0xf913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"P2SH,WITNESS\", \"OK\"],\n [[\"00\", \"645168\", 0.00000001], \"\", \"0 0x20 0xf913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"P2SH,WITNESS\", \"OK\"],\n-[[\"01\", \"645168\", 0.00000001], \"\", \"0 0x20 0xf913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"P2SH,WITNESS,MINIMALIF\", \"EVAL_FALSE\"],\n+[[\"01\", \"645168\", 0.00000001], \"\", \"0 0x20 0xf913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"P2SH,WITNESS,MINIMALIF\", \"CLEANSTACK\"],\n [[\"02\", \"645168\", 0.00000001], \"\", \"0 0x20 0xf913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"P2SH,WITNESS,MINIMALIF\", \"MINIMALIF\"],\n [[\"0100\", \"645168\", 0.00000001], \"\", \"0 0x20 0xf913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"P2SH,WITNESS,MINIMALIF\", \"MINIMALIF\"],\n [[\"\", \"645168\", 0.00000001], \"\", \"0 0x20 0xf913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"P2SH,WITNESS,MINIMALIF\", \"OK\"],\n@@ -2582,22 +2582,22 @@\n [[\"01\", \"635168\", 0.00000001], \"0x22 0x0020c7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"HASH160 0x14 0x9b27ee6d9010c21bf837b334d043be5d150e7ba7 EQUAL\", \"P2SH,WITNESS\", \"OK\"],\n [[\"02\", \"635168\", 0.00000001], \"0x22 0x0020c7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"HASH160 0x14 0x9b27ee6d9010c21bf837b334d043be5d150e7ba7 EQUAL\", \"P2SH,WITNESS\", \"OK\"],\n [[\"0100\", \"635168\", 0.00000001], \"0x22 0x0020c7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"HASH160 0x14 0x9b27ee6d9010c21bf837b334d043be5d150e7ba7 EQUAL\", \"P2SH,WITNESS\", \"OK\"],\n-[[\"\", \"635168\", 0.00000001], \"0x22 0x0020c7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"HASH160 0x14 0x9b27ee6d9010c21bf837b334d043be5d150e7ba7 EQUAL\", \"P2SH,WITNESS\", \"EVAL_FALSE\"],\n-[[\"00\", \"635168\", 0.00000001], \"0x22 0x0020c7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"HASH160 0x14 0x9b27ee6d9010c21bf837b334d043be5d150e7ba7 EQUAL\", \"P2SH,WITNESS\", \"EVAL_FALSE\"],\n+[[\"\", \"635168\", 0.00000001], \"0x22 0x0020c7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"HASH160 0x14 0x9b27ee6d9010c21bf837b334d043be5d150e7ba7 EQUAL\", \"P2SH,WITNESS\", \"CLEANSTACK\"],\n+[[\"00\", \"635168\", 0.00000001], \"0x22 0x0020c7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"HASH160 0x14 0x9b27ee6d9010c21bf837b334d043be5d150e7ba7 EQUAL\", \"P2SH,WITNESS\", \"CLEANSTACK\"],\n [[\"01\", \"635168\", 0.00000001], \"0x22 0x0020c7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"HASH160 0x14 0x9b27ee6d9010c21bf837b334d043be5d150e7ba7 EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"OK\"],\n [[\"02\", \"635168\", 0.00000001], \"0x22 0x0020c7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"HASH160 0x14 0x9b27ee6d9010c21bf837b334d043be5d150e7ba7 EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"MINIMALIF\"],\n [[\"0100\", \"635168\", 0.00000001], \"0x22 0x0020c7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"HASH160 0x14 0x9b27ee6d9010c21bf837b334d043be5d150e7ba7 EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"MINIMALIF\"],\n-[[\"\", \"635168\", 0.00000001], \"0x22 0x0020c7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"HASH160 0x14 0x9b27ee6d9010c21bf837b334d043be5d150e7ba7 EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"EVAL_FALSE\"],\n+[[\"\", \"635168\", 0.00000001], \"0x22 0x0020c7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"HASH160 0x14 0x9b27ee6d9010c21bf837b334d043be5d150e7ba7 EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"CLEANSTACK\"],\n [[\"00\", \"635168\", 0.00000001], \"0x22 0x0020c7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"HASH160 0x14 0x9b27ee6d9010c21bf837b334d043be5d150e7ba7 EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"MINIMALIF\"],\n [[\"635168\", 0.00000001], \"0x22 0x0020c7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"HASH160 0x14 0x9b27ee6d9010c21bf837b334d043be5d150e7ba7 EQUAL\", \"P2SH,WITNESS\", \"UNBALANCED_CONDITIONAL\"],\n [[\"635168\", 0.00000001], \"0x22 0x0020c7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"HASH160 0x14 0x9b27ee6d9010c21bf837b334d043be5d150e7ba7 EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"UNBALANCED_CONDITIONAL\"],\n [\"P2SH-P2WSH NOTIF 1 ENDIF\"],\n-[[\"01\", \"645168\", 0.00000001], \"0x22 0x0020f913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"HASH160 0x14 0xdbb7d1c0a56b7a9c423300c8cca6e6e065baf1dc EQUAL\", \"P2SH,WITNESS\", \"EVAL_FALSE\"],\n-[[\"02\", \"645168\", 0.00000001], \"0x22 0x0020f913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"HASH160 0x14 0xdbb7d1c0a56b7a9c423300c8cca6e6e065baf1dc EQUAL\", \"P2SH,WITNESS\", \"EVAL_FALSE\"],\n-[[\"0100\", \"645168\", 0.00000001], \"0x22 0x0020f913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"HASH160 0x14 0xdbb7d1c0a56b7a9c423300c8cca6e6e065baf1dc EQUAL\", \"P2SH,WITNESS\", \"EVAL_FALSE\"],\n+[[\"01\", \"645168\", 0.00000001], \"0x22 0x0020f913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"HASH160 0x14 0xdbb7d1c0a56b7a9c423300c8cca6e6e065baf1dc EQUAL\", \"P2SH,WITNESS\", \"CLEANSTACK\"],\n+[[\"02\", \"645168\", 0.00000001], \"0x22 0x0020f913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"HASH160 0x14 0xdbb7d1c0a56b7a9c423300c8cca6e6e065baf1dc EQUAL\", \"P2SH,WITNESS\", \"CLEANSTACK\"],\n+[[\"0100\", \"645168\", 0.00000001], \"0x22 0x0020f913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"HASH160 0x14 0xdbb7d1c0a56b7a9c423300c8cca6e6e065baf1dc EQUAL\", \"P2SH,WITNESS\", \"CLEANSTACK\"],\n [[\"\", \"645168\", 0.00000001], \"0x22 0x0020f913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"HASH160 0x14 0xdbb7d1c0a56b7a9c423300c8cca6e6e065baf1dc EQUAL\", \"P2SH,WITNESS\", \"OK\"],\n [[\"00\", \"645168\", 0.00000001], \"0x22 0x0020f913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"HASH160 0x14 0xdbb7d1c0a56b7a9c423300c8cca6e6e065baf1dc EQUAL\", \"P2SH,WITNESS\", \"OK\"],\n-[[\"01\", \"645168\", 0.00000001], \"0x22 0x0020f913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"HASH160 0x14 0xdbb7d1c0a56b7a9c423300c8cca6e6e065baf1dc EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"EVAL_FALSE\"],\n+[[\"01\", \"645168\", 0.00000001], \"0x22 0x0020f913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"HASH160 0x14 0xdbb7d1c0a56b7a9c423300c8cca6e6e065baf1dc EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"CLEANSTACK\"],\n [[\"02\", \"645168\", 0.00000001], \"0x22 0x0020f913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"HASH160 0x14 0xdbb7d1c0a56b7a9c423300c8cca6e6e065baf1dc EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"MINIMALIF\"],\n [[\"0100\", \"645168\", 0.00000001], \"0x22 0x0020f913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"HASH160 0x14 0xdbb7d1c0a56b7a9c423300c8cca6e6e065baf1dc EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"MINIMALIF\"],\n [[\"\", \"645168\", 0.00000001], \"0x22 0x0020f913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"HASH160 0x14 0xdbb7d1c0a56b7a9c423300c8cca6e6e065baf1dc EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"OK\"],"
      },
      {
        "sha": "abb46fe533b776ce61232cd040f2d87a370810b9",
        "filename": "src/test/data/tx_invalid.json",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/data/tx_invalid.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/data/tx_invalid.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/tx_invalid.json?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -321,7 +321,7 @@\n [\"where the pubkey is obtained through key recovery with sig and the wrong sighash.\"],\n [\"This is to show that FindAndDelete is applied only to non-segwit scripts\"],\n [\"To show that the tests are 'correctly wrong', they should pass by modifying OP_CHECKSIG under interpreter.cpp\"],\n-[\"by replacing (sigversion == SIGVERSION_BASE) with (sigversion != SIGVERSION_BASE)\"],\n+[\"by replacing (sigversion == SigVersion::BASE) with (sigversion != SigVersion::BASE)\"],\n [\"Non-segwit: wrong sighash (without FindAndDelete) = 1ba1fe3bc90c5d1265460e684ce6774e324f0fabdf67619eda729e64e8b6bc08\"],\n [[[\"f18783ace138abac5d3a7a5cf08e88fe6912f267ef936452e0c27d090621c169\", 7000, \"HASH160 0x14 0x0c746489e2d83cdbb5b90b432773342ba809c134 EQUAL\", 200000]],\n \"010000000169c12106097dc2e0526493ef67f21269fe888ef05c7a3a5dacab38e1ac8387f1581b0000b64830450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e012103b12a1ec8428fc74166926318c15e17408fea82dbb157575e16a8c365f546248f4aad4830450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e01ffffffff0101000000000000000000000000\", \"P2SH,WITNESS\"],\n@@ -332,7 +332,7 @@\n [\"Script is 2 CHECKMULTISIGVERIFY <sig1> <sig2> DROP\"],\n [\"52af4830450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e0148304502205286f726690b2e9b0207f0345711e63fa7012045b9eb0f19c2458ce1db90cf43022100e89f17f86abc5b149eba4115d4f128bcf45d77fb3ecdd34f594091340c0395960175\"],\n [\"Signature is 0 <sig1> <sig2> 2 <key1> <key2>\"],\n-[\"Should pass by replacing (sigversion == SIGVERSION_BASE) with (sigversion != SIGVERSION_BASE) under OP_CHECKMULTISIG\"],\n+[\"Should pass by replacing (sigversion == SigVersion::BASE) with (sigversion != SigVersion::BASE) under OP_CHECKMULTISIG\"],\n [\"Non-segwit: wrong sighash (without FindAndDelete) = 4bc6a53e8e16ef508c19e38bba08831daba85228b0211f323d4cb0999cf2a5e8\"],\n [[[\"9628667ad48219a169b41b020800162287d2c0f713c04157e95c484a8dcb7592\", 7000, \"HASH160 0x14 0x5748407f5ca5cdca53ba30b79040260770c9ee1b EQUAL\", 200000]],\n \"01000000019275cb8d4a485ce95741c013f7c0d28722160008021bb469a11982d47a662896581b0000fd6f01004830450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e0148304502205286f726690b2e9b0207f0345711e63fa7012045b9eb0f19c2458ce1db90cf43022100e89f17f86abc5b149eba4115d4f128bcf45d77fb3ecdd34f594091340c039596015221023fd5dd42b44769c5653cbc5947ff30ab8871f240ad0c0e7432aefe84b5b4ff3421039d52178dbde360b83f19cf348deb04fa8360e1bf5634577be8e50fafc2b0e4ef4c9552af4830450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e0148304502205286f726690b2e9b0207f0345711e63fa7012045b9eb0f19c2458ce1db90cf43022100e89f17f86abc5b149eba4115d4f128bcf45d77fb3ecdd34f594091340c0395960175ffffffff0101000000000000000000000000\", \"P2SH,WITNESS\"],"
      },
      {
        "sha": "6df5aec9c94e592baf44c6c42f3fa71bac6420cc",
        "filename": "src/test/dbwrapper_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 4,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/dbwrapper_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/dbwrapper_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/dbwrapper_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -7,10 +7,12 @@\n #include <random.h>\n #include <test/test_bitcoin.h>\n \n+#include <memory>\n+\n #include <boost/test/unit_test.hpp>\n \n // Test if a string consists entirely of null characters\n-bool is_null_key(const std::vector<unsigned char>& key) {\n+static bool is_null_key(const std::vector<unsigned char>& key) {\n     bool isnull = true;\n \n     for (unsigned int i = 0; i < key.size(); i++)\n@@ -208,15 +210,15 @@ BOOST_AUTO_TEST_CASE(iterator_ordering)\n     // Check that creating an iterator creates a snapshot\n     std::unique_ptr<CDBIterator> it(const_cast<CDBWrapper&>(dbw).NewIterator());\n \n-    for (int x=0x00; x<256; ++x) {\n+    for (unsigned int x=0x00; x<256; ++x) {\n         uint8_t key = x;\n         uint32_t value = x*x;\n         if (x & 1) BOOST_CHECK(dbw.Write(key, value));\n     }\n \n     for (int seek_start : {0x00, 0x80}) {\n         it->Seek((uint8_t)seek_start);\n-        for (int x=seek_start; x<255; ++x) {\n+        for (unsigned int x=seek_start; x<255; ++x) {\n             uint8_t key;\n             uint32_t value;\n             BOOST_CHECK(it->Valid());\n@@ -293,7 +295,7 @@ BOOST_AUTO_TEST_CASE(iterator_string_ordering)\n         snprintf(buf, sizeof(buf), \"%d\", seek_start);\n         StringContentsSerializer seek_key(buf);\n         it->Seek(seek_key);\n-        for (int x=seek_start; x<10; ++x) {\n+        for (unsigned int x=seek_start; x<10; ++x) {\n             for (int y = 0; y < 10; y++) {\n                 snprintf(buf, sizeof(buf), \"%d\", x);\n                 std::string exp_key(buf);"
      },
      {
        "sha": "d7d6c9b5a35037411e04b09ce7c62ab3933a2157",
        "filename": "src/test/hash_tests.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 16,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/hash_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/hash_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/hash_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -25,22 +25,22 @@ BOOST_AUTO_TEST_CASE(murmurhash3)\n     //\n     // The magic number 0xFBA4C795 comes from CBloomFilter::Hash()\n \n-    T(0x00000000, 0x00000000, \"\");\n-    T(0x6a396f08, 0xFBA4C795, \"\");\n-    T(0x81f16f39, 0xffffffff, \"\");\n-\n-    T(0x514e28b7, 0x00000000, \"00\");\n-    T(0xea3f0b17, 0xFBA4C795, \"00\");\n-    T(0xfd6cf10d, 0x00000000, \"ff\");\n-\n-    T(0x16c6b7ab, 0x00000000, \"0011\");\n-    T(0x8eb51c3d, 0x00000000, \"001122\");\n-    T(0xb4471bf8, 0x00000000, \"00112233\");\n-    T(0xe2301fa8, 0x00000000, \"0011223344\");\n-    T(0xfc2e4a15, 0x00000000, \"001122334455\");\n-    T(0xb074502c, 0x00000000, \"00112233445566\");\n-    T(0x8034d2a0, 0x00000000, \"0011223344556677\");\n-    T(0xb4698def, 0x00000000, \"001122334455667788\");\n+    T(0x00000000U, 0x00000000, \"\");\n+    T(0x6a396f08U, 0xFBA4C795, \"\");\n+    T(0x81f16f39U, 0xffffffff, \"\");\n+\n+    T(0x514e28b7U, 0x00000000, \"00\");\n+    T(0xea3f0b17U, 0xFBA4C795, \"00\");\n+    T(0xfd6cf10dU, 0x00000000, \"ff\");\n+\n+    T(0x16c6b7abU, 0x00000000, \"0011\");\n+    T(0x8eb51c3dU, 0x00000000, \"001122\");\n+    T(0xb4471bf8U, 0x00000000, \"00112233\");\n+    T(0xe2301fa8U, 0x00000000, \"0011223344\");\n+    T(0xfc2e4a15U, 0x00000000, \"001122334455\");\n+    T(0xb074502cU, 0x00000000, \"00112233445566\");\n+    T(0x8034d2a0U, 0x00000000, \"0011223344556677\");\n+    T(0xb4698defU, 0x00000000, \"001122334455667788\");\n \n #undef T\n }"
      },
      {
        "sha": "8676a099da74a365ed8e69ad6da85a33d9b6587f",
        "filename": "src/test/main_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/main_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/main_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/main_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -55,11 +55,11 @@ BOOST_AUTO_TEST_CASE(subsidy_limit_test)\n         nSum += nSubsidy * 1000;\n         BOOST_CHECK(MoneyRange(nSum));\n     }\n-    BOOST_CHECK_EQUAL(nSum, 2099999997690000ULL);\n+    BOOST_CHECK_EQUAL(nSum, CAmount{2099999997690000});\n }\n \n-bool ReturnFalse() { return false; }\n-bool ReturnTrue() { return true; }\n+static bool ReturnFalse() { return false; }\n+static bool ReturnTrue() { return true; }\n \n BOOST_AUTO_TEST_CASE(test_combiner_all)\n {"
      },
      {
        "sha": "c4b18151a75f5da467194cf9b2cb827a11949e55",
        "filename": "src/test/mempool_tests.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/mempool_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/mempool_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/mempool_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -89,7 +89,7 @@ BOOST_AUTO_TEST_CASE(MempoolRemoveTest)\n     poolSize = testPool.size();\n     testPool.removeRecursive(txParent);\n     BOOST_CHECK_EQUAL(testPool.size(), poolSize - 5);\n-    BOOST_CHECK_EQUAL(testPool.size(), 0);\n+    BOOST_CHECK_EQUAL(testPool.size(), 0U);\n \n     // Add children and grandchildren, but NOT the parent (simulate the parent being in a block)\n     for (int i = 0; i < 3; i++)\n@@ -102,11 +102,11 @@ BOOST_AUTO_TEST_CASE(MempoolRemoveTest)\n     poolSize = testPool.size();\n     testPool.removeRecursive(txParent);\n     BOOST_CHECK_EQUAL(testPool.size(), poolSize - 6);\n-    BOOST_CHECK_EQUAL(testPool.size(), 0);\n+    BOOST_CHECK_EQUAL(testPool.size(), 0U);\n }\n \n template<typename name>\n-void CheckSort(CTxMemPool &pool, std::vector<std::string> &sortedOrder)\n+static void CheckSort(CTxMemPool &pool, std::vector<std::string> &sortedOrder)\n {\n     BOOST_CHECK_EQUAL(pool.size(), sortedOrder.size());\n     typename CTxMemPool::indexed_transaction_set::index<name>::type::iterator it = pool.mapTx.get<name>().begin();\n@@ -156,7 +156,7 @@ BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n     tx5.vout[0].nValue = 11 * COIN;\n     entry.nTime = 1;\n     pool.addUnchecked(tx5.GetHash(), entry.Fee(10000LL).FromTx(tx5));\n-    BOOST_CHECK_EQUAL(pool.size(), 5);\n+    BOOST_CHECK_EQUAL(pool.size(), 5U);\n \n     std::vector<std::string> sortedOrder;\n     sortedOrder.resize(5);\n@@ -175,7 +175,7 @@ BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n     tx6.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n     tx6.vout[0].nValue = 20 * COIN;\n     pool.addUnchecked(tx6.GetHash(), entry.Fee(0LL).FromTx(tx6));\n-    BOOST_CHECK_EQUAL(pool.size(), 6);\n+    BOOST_CHECK_EQUAL(pool.size(), 6U);\n     // Check that at this point, tx6 is sorted low\n     sortedOrder.insert(sortedOrder.begin(), tx6.GetHash().ToString());\n     CheckSort<descendant_score>(pool, sortedOrder);\n@@ -198,7 +198,7 @@ BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n     BOOST_CHECK(setAncestorsCalculated == setAncestors);\n \n     pool.addUnchecked(tx7.GetHash(), entry.FromTx(tx7), setAncestors);\n-    BOOST_CHECK_EQUAL(pool.size(), 7);\n+    BOOST_CHECK_EQUAL(pool.size(), 7U);\n \n     // Now tx6 should be sorted higher (high fee child): tx7, tx6, tx2, ...\n     sortedOrder.erase(sortedOrder.begin());\n@@ -232,7 +232,7 @@ BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n     pool.addUnchecked(tx9.GetHash(), entry.Fee(0LL).Time(3).FromTx(tx9), setAncestors);\n \n     // tx9 should be sorted low\n-    BOOST_CHECK_EQUAL(pool.size(), 9);\n+    BOOST_CHECK_EQUAL(pool.size(), 9U);\n     sortedOrder.insert(sortedOrder.begin(), tx9.GetHash().ToString());\n     CheckSort<descendant_score>(pool, sortedOrder);\n \n@@ -279,7 +279,7 @@ BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n     CheckSort<descendant_score>(pool, sortedOrder);\n \n     // there should be 10 transactions in the mempool\n-    BOOST_CHECK_EQUAL(pool.size(), 10);\n+    BOOST_CHECK_EQUAL(pool.size(), 10U);\n \n     // Now try removing tx10 and verify the sort order returns to normal\n     pool.removeRecursive(pool.mapTx.find(tx10.GetHash())->GetTx());\n@@ -329,7 +329,7 @@ BOOST_AUTO_TEST_CASE(MempoolAncestorIndexingTest)\n     tx5.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n     tx5.vout[0].nValue = 11 * COIN;\n     pool.addUnchecked(tx5.GetHash(), entry.Fee(10000LL).FromTx(tx5));\n-    BOOST_CHECK_EQUAL(pool.size(), 5);\n+    BOOST_CHECK_EQUAL(pool.size(), 5U);\n \n     std::vector<std::string> sortedOrder;\n     sortedOrder.resize(5);\n@@ -359,7 +359,7 @@ BOOST_AUTO_TEST_CASE(MempoolAncestorIndexingTest)\n     uint64_t tx6Size = GetVirtualTransactionSize(tx6);\n \n     pool.addUnchecked(tx6.GetHash(), entry.Fee(0LL).FromTx(tx6));\n-    BOOST_CHECK_EQUAL(pool.size(), 6);\n+    BOOST_CHECK_EQUAL(pool.size(), 6U);\n     // Ties are broken by hash\n     if (tx3.GetHash() < tx6.GetHash())\n         sortedOrder.push_back(tx6.GetHash().ToString());\n@@ -381,7 +381,7 @@ BOOST_AUTO_TEST_CASE(MempoolAncestorIndexingTest)\n     CAmount fee = (20000/tx2Size)*(tx7Size + tx6Size) - 1;\n \n     pool.addUnchecked(tx7.GetHash(), entry.Fee(fee).FromTx(tx7));\n-    BOOST_CHECK_EQUAL(pool.size(), 7);\n+    BOOST_CHECK_EQUAL(pool.size(), 7U);\n     sortedOrder.insert(sortedOrder.begin()+1, tx7.GetHash().ToString());\n     CheckSort<ancestor_score>(pool, sortedOrder);\n "
      },
      {
        "sha": "2472ea9950d5b01e7b0ecf3e43aa535eea73b2b1",
        "filename": "src/test/merkleblock_tests.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/merkleblock_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/merkleblock_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/merkleblock_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -35,20 +35,20 @@ BOOST_AUTO_TEST_CASE(merkleblock_construct_from_txids_found)\n     BOOST_CHECK_EQUAL(merkleBlock.header.GetHash().GetHex(), block.GetHash().GetHex());\n \n     // vMatchedTxn is only used when bloom filter is specified.\n-    BOOST_CHECK_EQUAL(merkleBlock.vMatchedTxn.size(), 0);\n+    BOOST_CHECK_EQUAL(merkleBlock.vMatchedTxn.size(), 0U);\n \n     std::vector<uint256> vMatched;\n     std::vector<unsigned int> vIndex;\n \n     BOOST_CHECK_EQUAL(merkleBlock.txn.ExtractMatches(vMatched, vIndex).GetHex(), block.hashMerkleRoot.GetHex());\n-    BOOST_CHECK_EQUAL(vMatched.size(), 2);\n+    BOOST_CHECK_EQUAL(vMatched.size(), 2U);\n \n     // Ordered by occurrence in depth-first tree traversal.\n     BOOST_CHECK_EQUAL(vMatched[0].ToString(), txhash2.ToString());\n-    BOOST_CHECK_EQUAL(vIndex[0], 1);\n+    BOOST_CHECK_EQUAL(vIndex[0], 1U);\n \n     BOOST_CHECK_EQUAL(vMatched[1].ToString(), txhash1.ToString());\n-    BOOST_CHECK_EQUAL(vIndex[1], 8);\n+    BOOST_CHECK_EQUAL(vIndex[1], 8U);\n }\n \n \n@@ -65,14 +65,14 @@ BOOST_AUTO_TEST_CASE(merkleblock_construct_from_txids_not_found)\n     CMerkleBlock merkleBlock(block, txids2);\n \n     BOOST_CHECK_EQUAL(merkleBlock.header.GetHash().GetHex(), block.GetHash().GetHex());\n-    BOOST_CHECK_EQUAL(merkleBlock.vMatchedTxn.size(), 0);\n+    BOOST_CHECK_EQUAL(merkleBlock.vMatchedTxn.size(), 0U);\n \n     std::vector<uint256> vMatched;\n     std::vector<unsigned int> vIndex;\n \n     BOOST_CHECK_EQUAL(merkleBlock.txn.ExtractMatches(vMatched, vIndex).GetHex(), block.hashMerkleRoot.GetHex());\n-    BOOST_CHECK_EQUAL(vMatched.size(), 0);\n-    BOOST_CHECK_EQUAL(vIndex.size(), 0);\n+    BOOST_CHECK_EQUAL(vMatched.size(), 0U);\n+    BOOST_CHECK_EQUAL(vIndex.size(), 0U);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "9a325f5f4c1f0a1abc29be92be185c5d7a123309",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -82,15 +82,15 @@ struct {\n     {2, 0xbbbeb305}, {2, 0xfe1c810a},\n };\n \n-CBlockIndex CreateBlockIndex(int nHeight)\n+static CBlockIndex CreateBlockIndex(int nHeight)\n {\n     CBlockIndex index;\n     index.nHeight = nHeight;\n     index.pprev = chainActive.Tip();\n     return index;\n }\n \n-bool TestSequenceLocks(const CTransaction &tx, int flags)\n+static bool TestSequenceLocks(const CTransaction &tx, int flags)\n {\n     LOCK(mempool.cs);\n     return CheckSequenceLocks(tx, flags);\n@@ -99,7 +99,7 @@ bool TestSequenceLocks(const CTransaction &tx, int flags)\n // Test suite for ancestor feerate transaction selection.\n // Implemented as an additional function, rather than a separate test case,\n // to allow reusing the blockchain created in CreateNewBlock_validity.\n-void TestPackageSelection(const CChainParams& chainparams, CScript scriptPubKey, std::vector<CTransactionRef>& txFirst)\n+static void TestPackageSelection(const CChainParams& chainparams, CScript scriptPubKey, std::vector<CTransactionRef>& txFirst)\n {\n     // Test the ancestor feerate transaction selection.\n     TestMemPoolEntryHelper entry;\n@@ -501,15 +501,15 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     // it into the template because we still check IsFinalTx in CreateNewBlock,\n     // but relative locked txs will if inconsistently added to mempool.\n     // For now these will still generate a valid template until BIP68 soft fork\n-    BOOST_CHECK_EQUAL(pblocktemplate->block.vtx.size(), 3);\n+    BOOST_CHECK_EQUAL(pblocktemplate->block.vtx.size(), 3U);\n     // However if we advance height by 1 and time by 512, all of them should be mined\n     for (int i = 0; i < CBlockIndex::nMedianTimeSpan; i++)\n         chainActive.Tip()->GetAncestor(chainActive.Tip()->nHeight - i)->nTime += 512; //Trick the MedianTimePast\n     chainActive.Tip()->nHeight++;\n     SetMockTime(chainActive.Tip()->GetMedianTimePast() + 1);\n \n     BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));\n-    BOOST_CHECK_EQUAL(pblocktemplate->block.vtx.size(), 5);\n+    BOOST_CHECK_EQUAL(pblocktemplate->block.vtx.size(), 5U);\n \n     chainActive.Tip()->nHeight--;\n     SetMockTime(0);"
      },
      {
        "sha": "77db9f5c57e7b62d86630361bef5d3eab677708a",
        "filename": "src/test/multisig_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/multisig_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/multisig_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/multisig_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -18,10 +18,10 @@\n \n BOOST_FIXTURE_TEST_SUITE(multisig_tests, BasicTestingSetup)\n \n-CScript\n-sign_multisig(CScript scriptPubKey, std::vector<CKey> keys, CTransaction transaction, int whichIn)\n+static CScript\n+sign_multisig(const CScript& scriptPubKey, const std::vector<CKey>& keys, const CTransaction& transaction, int whichIn)\n {\n-    uint256 hash = SignatureHash(scriptPubKey, transaction, whichIn, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+    uint256 hash = SignatureHash(scriptPubKey, transaction, whichIn, SIGHASH_ALL, 0, SigVersion::BASE);\n \n     CScript result;\n     result << OP_0; // CHECKMULTISIG bug workaround"
      },
      {
        "sha": "42e615ab0c485d6710d7273a15ece7b9da560c4e",
        "filename": "src/test/net_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 4,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/net_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/net_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -13,6 +13,8 @@\n #include <chainparams.h>\n #include <util.h>\n \n+#include <memory>\n+\n class CAddrManSerializationMock : public CAddrMan\n {\n public:\n@@ -61,10 +63,10 @@ class CAddrManCorrupted : public CAddrManSerializationMock\n     }\n };\n \n-CDataStream AddrmanToStream(CAddrManSerializationMock& _addrman)\n+static CDataStream AddrmanToStream(CAddrManSerializationMock& _addrman)\n {\n     CDataStream ssPeersIn(SER_DISK, CLIENT_VERSION);\n-    ssPeersIn << FLATDATA(Params().MessageStart());\n+    ssPeersIn << Params().MessageStart();\n     ssPeersIn << _addrman;\n     std::string str = ssPeersIn.str();\n     std::vector<unsigned char> vchData(str.begin(), str.end());\n@@ -110,7 +112,7 @@ BOOST_AUTO_TEST_CASE(caddrdb_read)\n     BOOST_CHECK(addrman1.size() == 0);\n     try {\n         unsigned char pchMsgTmp[4];\n-        ssPeers1 >> FLATDATA(pchMsgTmp);\n+        ssPeers1 >> pchMsgTmp;\n         ssPeers1 >> addrman1;\n     } catch (const std::exception& e) {\n         exceptionThrown = true;\n@@ -142,7 +144,7 @@ BOOST_AUTO_TEST_CASE(caddrdb_read_corrupted)\n     BOOST_CHECK(addrman1.size() == 0);\n     try {\n         unsigned char pchMsgTmp[4];\n-        ssPeers1 >> FLATDATA(pchMsgTmp);\n+        ssPeers1 >> pchMsgTmp;\n         ssPeers1 >> addrman1;\n     } catch (const std::exception& e) {\n         exceptionThrown = true;"
      },
      {
        "sha": "9abfd5ebd8c590458c5360f81c1b44299cab07cd",
        "filename": "src/test/pow_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/pow_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/pow_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/pow_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -22,7 +22,7 @@ BOOST_AUTO_TEST_CASE(get_next_work)\n     pindexLast.nHeight = 32255;\n     pindexLast.nTime = 1262152739;  // Block #32255\n     pindexLast.nBits = 0x1d00ffff;\n-    BOOST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, chainParams->GetConsensus()), 0x1d00d86a);\n+    BOOST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, chainParams->GetConsensus()), 0x1d00d86aU);\n }\n \n /* Test the constraint on the upper bound for next work */\n@@ -34,7 +34,7 @@ BOOST_AUTO_TEST_CASE(get_next_work_pow_limit)\n     pindexLast.nHeight = 2015;\n     pindexLast.nTime = 1233061996;  // Block #2015\n     pindexLast.nBits = 0x1d00ffff;\n-    BOOST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, chainParams->GetConsensus()), 0x1d00ffff);\n+    BOOST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, chainParams->GetConsensus()), 0x1d00ffffU);\n }\n \n /* Test the constraint on the lower bound for actual time taken */\n@@ -46,7 +46,7 @@ BOOST_AUTO_TEST_CASE(get_next_work_lower_limit_actual)\n     pindexLast.nHeight = 68543;\n     pindexLast.nTime = 1279297671;  // Block #68543\n     pindexLast.nBits = 0x1c05a3f4;\n-    BOOST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, chainParams->GetConsensus()), 0x1c0168fd);\n+    BOOST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, chainParams->GetConsensus()), 0x1c0168fdU);\n }\n \n /* Test the constraint on the upper bound for actual time taken */\n@@ -58,7 +58,7 @@ BOOST_AUTO_TEST_CASE(get_next_work_upper_limit_actual)\n     pindexLast.nHeight = 46367;\n     pindexLast.nTime = 1269211443;  // Block #46367\n     pindexLast.nBits = 0x1c387f6f;\n-    BOOST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, chainParams->GetConsensus()), 0x1d00e1fd);\n+    BOOST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, chainParams->GetConsensus()), 0x1d00e1fdU);\n }\n \n BOOST_AUTO_TEST_CASE(GetBlockProofEquivalentTime_test)"
      },
      {
        "sha": "fe6f10d845b7d3a3e95cb33dc08bd9b39b30e398",
        "filename": "src/test/prevector_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/prevector_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/prevector_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/prevector_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -13,7 +13,7 @@\n \n #include <boost/test/unit_test.hpp>\n \n-BOOST_FIXTURE_TEST_SUITE(PrevectorTests, TestingSetup)\n+BOOST_FIXTURE_TEST_SUITE(prevector_tests, TestingSetup)\n \n template<unsigned int N, typename T>\n class prevector_tester {"
      },
      {
        "sha": "80a294d129bb9daf69205e038e325564957f805a",
        "filename": "src/test/random_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/random_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/random_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/random_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -52,7 +52,7 @@ BOOST_AUTO_TEST_CASE(fastrandom_randbits)\n     for (int bits = 0; bits < 63; ++bits) {\n         for (int j = 0; j < 1000; ++j) {\n             uint64_t rangebits = ctx1.randbits(bits);\n-            BOOST_CHECK_EQUAL(rangebits >> bits, 0);\n+            BOOST_CHECK_EQUAL(rangebits >> bits, 0U);\n             uint64_t range = ((uint64_t)1) << bits | rangebits;\n             uint64_t rand = ctx2.randrange(range);\n             BOOST_CHECK(rand < range);"
      },
      {
        "sha": "da591547d77b4ede87fb5c4c713f0808d174e3c8",
        "filename": "src/test/rpc_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/rpc_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/rpc_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/rpc_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -245,16 +245,16 @@ BOOST_AUTO_TEST_CASE(rpc_ban)\n     BOOST_CHECK_NO_THROW(CallRPC(std::string(\"setban 127.0.0.0 remove\")));\n     BOOST_CHECK_NO_THROW(r = CallRPC(std::string(\"listbanned\")));\n     ar = r.get_array();\n-    BOOST_CHECK_EQUAL(ar.size(), 0);\n+    BOOST_CHECK_EQUAL(ar.size(), 0U);\n \n-    BOOST_CHECK_NO_THROW(r = CallRPC(std::string(\"setban 127.0.0.0/24 add 1607731200 true\")));\n+    BOOST_CHECK_NO_THROW(r = CallRPC(std::string(\"setban 127.0.0.0/24 add 9907731200 true\")));\n     BOOST_CHECK_NO_THROW(r = CallRPC(std::string(\"listbanned\")));\n     ar = r.get_array();\n     o1 = ar[0].get_obj();\n     adr = find_value(o1, \"address\");\n     UniValue banned_until = find_value(o1, \"banned_until\");\n     BOOST_CHECK_EQUAL(adr.get_str(), \"127.0.0.0/24\");\n-    BOOST_CHECK_EQUAL(banned_until.get_int64(), 1607731200); // absolute time check\n+    BOOST_CHECK_EQUAL(banned_until.get_int64(), 9907731200); // absolute time check\n \n     BOOST_CHECK_NO_THROW(CallRPC(std::string(\"clearbanned\")));\n \n@@ -275,15 +275,15 @@ BOOST_AUTO_TEST_CASE(rpc_ban)\n     BOOST_CHECK_NO_THROW(CallRPC(std::string(\"setban 127.0.0.0/24 remove\")));\n     BOOST_CHECK_NO_THROW(r = CallRPC(std::string(\"listbanned\")));\n     ar = r.get_array();\n-    BOOST_CHECK_EQUAL(ar.size(), 0);\n+    BOOST_CHECK_EQUAL(ar.size(), 0U);\n \n     BOOST_CHECK_NO_THROW(r = CallRPC(std::string(\"setban 127.0.0.0/255.255.0.0 add\")));\n     BOOST_CHECK_THROW(r = CallRPC(std::string(\"setban 127.0.1.1 add\")), std::runtime_error);\n \n     BOOST_CHECK_NO_THROW(CallRPC(std::string(\"clearbanned\")));\n     BOOST_CHECK_NO_THROW(r = CallRPC(std::string(\"listbanned\")));\n     ar = r.get_array();\n-    BOOST_CHECK_EQUAL(ar.size(), 0);\n+    BOOST_CHECK_EQUAL(ar.size(), 0U);\n \n \n     BOOST_CHECK_THROW(r = CallRPC(std::string(\"setban test add\")), std::runtime_error); //invalid IP"
      },
      {
        "sha": "ff0bf6c66d76bd38ea86ab984ed1601c07850ae9",
        "filename": "src/test/script_standard_tests.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 13,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/script_standard_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/script_standard_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_standard_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -33,15 +33,15 @@ BOOST_AUTO_TEST_CASE(script_standard_Solver_success)\n     s << ToByteVector(pubkeys[0]) << OP_CHECKSIG;\n     BOOST_CHECK(Solver(s, whichType, solutions));\n     BOOST_CHECK_EQUAL(whichType, TX_PUBKEY);\n-    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1U);\n     BOOST_CHECK(solutions[0] == ToByteVector(pubkeys[0]));\n \n     // TX_PUBKEYHASH\n     s.clear();\n     s << OP_DUP << OP_HASH160 << ToByteVector(pubkeys[0].GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n     BOOST_CHECK(Solver(s, whichType, solutions));\n     BOOST_CHECK_EQUAL(whichType, TX_PUBKEYHASH);\n-    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1U);\n     BOOST_CHECK(solutions[0] == ToByteVector(pubkeys[0].GetID()));\n \n     // TX_SCRIPTHASH\n@@ -50,7 +50,7 @@ BOOST_AUTO_TEST_CASE(script_standard_Solver_success)\n     s << OP_HASH160 << ToByteVector(CScriptID(redeemScript)) << OP_EQUAL;\n     BOOST_CHECK(Solver(s, whichType, solutions));\n     BOOST_CHECK_EQUAL(whichType, TX_SCRIPTHASH);\n-    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1U);\n     BOOST_CHECK(solutions[0] == ToByteVector(CScriptID(redeemScript)));\n \n     // TX_MULTISIG\n@@ -61,7 +61,7 @@ BOOST_AUTO_TEST_CASE(script_standard_Solver_success)\n         OP_2 << OP_CHECKMULTISIG;\n     BOOST_CHECK(Solver(s, whichType, solutions));\n     BOOST_CHECK_EQUAL(whichType, TX_MULTISIG);\n-    BOOST_CHECK_EQUAL(solutions.size(), 4);\n+    BOOST_CHECK_EQUAL(solutions.size(), 4U);\n     BOOST_CHECK(solutions[0] == std::vector<unsigned char>({1}));\n     BOOST_CHECK(solutions[1] == ToByteVector(pubkeys[0]));\n     BOOST_CHECK(solutions[2] == ToByteVector(pubkeys[1]));\n@@ -75,7 +75,7 @@ BOOST_AUTO_TEST_CASE(script_standard_Solver_success)\n         OP_3 << OP_CHECKMULTISIG;\n     BOOST_CHECK(Solver(s, whichType, solutions));\n     BOOST_CHECK_EQUAL(whichType, TX_MULTISIG);\n-    BOOST_CHECK_EQUAL(solutions.size(), 5);\n+    BOOST_CHECK_EQUAL(solutions.size(), 5U);\n     BOOST_CHECK(solutions[0] == std::vector<unsigned char>({2}));\n     BOOST_CHECK(solutions[1] == ToByteVector(pubkeys[0]));\n     BOOST_CHECK(solutions[2] == ToByteVector(pubkeys[1]));\n@@ -90,14 +90,14 @@ BOOST_AUTO_TEST_CASE(script_standard_Solver_success)\n         std::vector<unsigned char>({255});\n     BOOST_CHECK(Solver(s, whichType, solutions));\n     BOOST_CHECK_EQUAL(whichType, TX_NULL_DATA);\n-    BOOST_CHECK_EQUAL(solutions.size(), 0);\n+    BOOST_CHECK_EQUAL(solutions.size(), 0U);\n \n     // TX_WITNESS_V0_KEYHASH\n     s.clear();\n     s << OP_0 << ToByteVector(pubkeys[0].GetID());\n     BOOST_CHECK(Solver(s, whichType, solutions));\n     BOOST_CHECK_EQUAL(whichType, TX_WITNESS_V0_KEYHASH);\n-    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1U);\n     BOOST_CHECK(solutions[0] == ToByteVector(pubkeys[0].GetID()));\n \n     // TX_WITNESS_V0_SCRIPTHASH\n@@ -109,7 +109,7 @@ BOOST_AUTO_TEST_CASE(script_standard_Solver_success)\n     s << OP_0 << ToByteVector(scriptHash);\n     BOOST_CHECK(Solver(s, whichType, solutions));\n     BOOST_CHECK_EQUAL(whichType, TX_WITNESS_V0_SCRIPTHASH);\n-    BOOST_CHECK_EQUAL(solutions.size(), 1);\n+    BOOST_CHECK_EQUAL(solutions.size(), 1U);\n     BOOST_CHECK(solutions[0] == ToByteVector(scriptHash));\n \n     // TX_NONSTANDARD\n@@ -264,7 +264,7 @@ BOOST_AUTO_TEST_CASE(script_standard_ExtractDestinations)\n     s << ToByteVector(pubkeys[0]) << OP_CHECKSIG;\n     BOOST_CHECK(ExtractDestinations(s, whichType, addresses, nRequired));\n     BOOST_CHECK_EQUAL(whichType, TX_PUBKEY);\n-    BOOST_CHECK_EQUAL(addresses.size(), 1);\n+    BOOST_CHECK_EQUAL(addresses.size(), 1U);\n     BOOST_CHECK_EQUAL(nRequired, 1);\n     BOOST_CHECK(boost::get<CKeyID>(&addresses[0]) &&\n                 *boost::get<CKeyID>(&addresses[0]) == pubkeys[0].GetID());\n@@ -274,7 +274,7 @@ BOOST_AUTO_TEST_CASE(script_standard_ExtractDestinations)\n     s << OP_DUP << OP_HASH160 << ToByteVector(pubkeys[0].GetID()) << OP_EQUALVERIFY << OP_CHECKSIG;\n     BOOST_CHECK(ExtractDestinations(s, whichType, addresses, nRequired));\n     BOOST_CHECK_EQUAL(whichType, TX_PUBKEYHASH);\n-    BOOST_CHECK_EQUAL(addresses.size(), 1);\n+    BOOST_CHECK_EQUAL(addresses.size(), 1U);\n     BOOST_CHECK_EQUAL(nRequired, 1);\n     BOOST_CHECK(boost::get<CKeyID>(&addresses[0]) &&\n                 *boost::get<CKeyID>(&addresses[0]) == pubkeys[0].GetID());\n@@ -285,7 +285,7 @@ BOOST_AUTO_TEST_CASE(script_standard_ExtractDestinations)\n     s << OP_HASH160 << ToByteVector(CScriptID(redeemScript)) << OP_EQUAL;\n     BOOST_CHECK(ExtractDestinations(s, whichType, addresses, nRequired));\n     BOOST_CHECK_EQUAL(whichType, TX_SCRIPTHASH);\n-    BOOST_CHECK_EQUAL(addresses.size(), 1);\n+    BOOST_CHECK_EQUAL(addresses.size(), 1U);\n     BOOST_CHECK_EQUAL(nRequired, 1);\n     BOOST_CHECK(boost::get<CScriptID>(&addresses[0]) &&\n                 *boost::get<CScriptID>(&addresses[0]) == CScriptID(redeemScript));\n@@ -298,7 +298,7 @@ BOOST_AUTO_TEST_CASE(script_standard_ExtractDestinations)\n         OP_2 << OP_CHECKMULTISIG;\n     BOOST_CHECK(ExtractDestinations(s, whichType, addresses, nRequired));\n     BOOST_CHECK_EQUAL(whichType, TX_MULTISIG);\n-    BOOST_CHECK_EQUAL(addresses.size(), 2);\n+    BOOST_CHECK_EQUAL(addresses.size(), 2U);\n     BOOST_CHECK_EQUAL(nRequired, 2);\n     BOOST_CHECK(boost::get<CKeyID>(&addresses[0]) &&\n                 *boost::get<CKeyID>(&addresses[0]) == pubkeys[0].GetID());\n@@ -561,7 +561,14 @@ BOOST_AUTO_TEST_CASE(script_standard_IsMine)\n         keystore.AddKey(keys[1]);\n \n         result = IsMine(keystore, scriptPubKey, isInvalid);\n-        BOOST_CHECK_EQUAL(result, ISMINE_SPENDABLE);\n+        BOOST_CHECK_EQUAL(result, ISMINE_NO);\n+        BOOST_CHECK(!isInvalid);\n+\n+        // Keystore has 2/2 keys and the script\n+        keystore.AddCScript(scriptPubKey);\n+\n+        result = IsMine(keystore, scriptPubKey, isInvalid);\n+        BOOST_CHECK_EQUAL(result, ISMINE_NO);\n         BOOST_CHECK(!isInvalid);\n     }\n "
      },
      {
        "sha": "f561660fef7b7beb4c36005b2ba16628e9f7713d",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 89,
        "deletions": 89,
        "changes": 178,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -99,7 +99,7 @@ static ScriptErrorDesc script_errors[]={\n     {SCRIPT_ERR_WITNESS_PUBKEYTYPE, \"WITNESS_PUBKEYTYPE\"},\n };\n \n-const char *FormatScriptError(ScriptError_t err)\n+static const char *FormatScriptError(ScriptError_t err)\n {\n     for (unsigned int i=0; i<ARRAYLEN(script_errors); ++i)\n         if (script_errors[i].err == err)\n@@ -108,7 +108,7 @@ const char *FormatScriptError(ScriptError_t err)\n     return \"\";\n }\n \n-ScriptError_t ParseScriptError(const std::string &name)\n+static ScriptError_t ParseScriptError(const std::string &name)\n {\n     for (unsigned int i=0; i<ARRAYLEN(script_errors); ++i)\n         if (script_errors[i].name == name)\n@@ -267,10 +267,10 @@ struct KeyData\n     }\n };\n \n-enum WitnessMode {\n-    WITNESS_NONE,\n-    WITNESS_PKH,\n-    WITNESS_SH\n+enum class WitnessMode {\n+    NONE,\n+    PKH,\n+    SH\n };\n \n class TestBuilder\n@@ -308,15 +308,15 @@ class TestBuilder\n     }\n \n public:\n-    TestBuilder(const CScript& script_, const std::string& comment_, int flags_, bool P2SH = false, WitnessMode wm = WITNESS_NONE, int witnessversion = 0, CAmount nValue_ = 0) : script(script_), havePush(false), comment(comment_), flags(flags_), scriptError(SCRIPT_ERR_OK), nValue(nValue_)\n+    TestBuilder(const CScript& script_, const std::string& comment_, int flags_, bool P2SH = false, WitnessMode wm = WitnessMode::NONE, int witnessversion = 0, CAmount nValue_ = 0) : script(script_), havePush(false), comment(comment_), flags(flags_), scriptError(SCRIPT_ERR_OK), nValue(nValue_)\n     {\n         CScript scriptPubKey = script;\n-        if (wm == WITNESS_PKH) {\n+        if (wm == WitnessMode::PKH) {\n             uint160 hash;\n             CHash160().Write(&script[1], script.size() - 1).Finalize(hash.begin());\n             script = CScript() << OP_DUP << OP_HASH160 << ToByteVector(hash) << OP_EQUALVERIFY << OP_CHECKSIG;\n             scriptPubKey = CScript() << witnessversion << ToByteVector(hash);\n-        } else if (wm == WITNESS_SH) {\n+        } else if (wm == WitnessMode::SH) {\n             witscript = scriptPubKey;\n             uint256 hash;\n             CSHA256().Write(&witscript[0], witscript.size()).Finalize(hash.begin());\n@@ -361,7 +361,7 @@ class TestBuilder\n         return *this;\n     }\n \n-    TestBuilder& PushSig(const CKey& key, int nHashType = SIGHASH_ALL, unsigned int lenR = 32, unsigned int lenS = 32, SigVersion sigversion = SIGVERSION_BASE, CAmount amount = 0)\n+    TestBuilder& PushSig(const CKey& key, int nHashType = SIGHASH_ALL, unsigned int lenR = 32, unsigned int lenS = 32, SigVersion sigversion = SigVersion::BASE, CAmount amount = 0)\n     {\n         uint256 hash = SignatureHash(script, spendTx, 0, nHashType, amount, sigversion);\n         std::vector<unsigned char> vchSig, r, s;\n@@ -379,7 +379,7 @@ class TestBuilder\n         return *this;\n     }\n \n-    TestBuilder& PushWitSig(const CKey& key, CAmount amount = -1, int nHashType = SIGHASH_ALL, unsigned int lenR = 32, unsigned int lenS = 32, SigVersion sigversion = SIGVERSION_WITNESS_V0)\n+    TestBuilder& PushWitSig(const CKey& key, CAmount amount = -1, int nHashType = SIGHASH_ALL, unsigned int lenR = 32, unsigned int lenS = 32, SigVersion sigversion = SigVersion::WITNESS_V0)\n     {\n         if (amount == -1)\n             amount = nValue;\n@@ -747,57 +747,57 @@ BOOST_AUTO_TEST_CASE(script_build)\n                                ).PushSig(keys.key0).PushRedeem());\n \n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n-                                \"Basic P2WSH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH,\n+                                \"Basic P2WSH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::SH,\n                                 0, 1).PushWitSig(keys.key0).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n-                                \"Basic P2WPKH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_PKH,\n+                                \"Basic P2WPKH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::PKH,\n                                 0, 1).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n-                                \"Basic P2SH(P2WSH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH,\n+                                \"Basic P2SH(P2WSH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::SH,\n                                 0, 1).PushWitSig(keys.key0).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n-                                \"Basic P2SH(P2WPKH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_PKH,\n+                                \"Basic P2SH(P2WPKH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::PKH,\n                                 0, 1).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n-                                \"Basic P2WSH with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH\n+                                \"Basic P2WSH with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::SH\n                                ).PushWitSig(keys.key0).PushWitRedeem().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1),\n-                                \"Basic P2WPKH with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_PKH\n+                                \"Basic P2WPKH with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::PKH\n                                ).PushWitSig(keys.key0).Push(keys.pubkey1).AsWit().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n-                                \"Basic P2SH(P2WSH) with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH\n+                                \"Basic P2SH(P2WSH) with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::SH\n                                ).PushWitSig(keys.key0).PushWitRedeem().PushRedeem().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1),\n-                                \"Basic P2SH(P2WPKH) with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_PKH\n+                                \"Basic P2SH(P2WPKH) with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::PKH\n                                ).PushWitSig(keys.key0).Push(keys.pubkey1).AsWit().PushRedeem().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n-                                \"Basic P2WSH with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, false, WITNESS_SH\n+                                \"Basic P2WSH with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, false, WitnessMode::SH\n                                ).PushWitSig(keys.key0).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1),\n-                                \"Basic P2WPKH with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, false, WITNESS_PKH\n+                                \"Basic P2WPKH with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, false, WitnessMode::PKH\n                                ).PushWitSig(keys.key0).Push(keys.pubkey1).AsWit());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n-                                \"Basic P2SH(P2WSH) with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, true, WITNESS_SH\n+                                \"Basic P2SH(P2WSH) with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, true, WitnessMode::SH\n                                ).PushWitSig(keys.key0).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1),\n-                                \"Basic P2SH(P2WPKH) with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, true, WITNESS_PKH\n+                                \"Basic P2SH(P2WPKH) with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, true, WitnessMode::PKH\n                                ).PushWitSig(keys.key0).Push(keys.pubkey1).AsWit().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n-                                \"Basic P2WSH with wrong value\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH,\n+                                \"Basic P2WSH with wrong value\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::SH,\n                                 0, 0).PushWitSig(keys.key0, 1).PushWitRedeem().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n-                                \"Basic P2WPKH with wrong value\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_PKH,\n+                                \"Basic P2WPKH with wrong value\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::PKH,\n                                 0, 0).PushWitSig(keys.key0, 1).Push(keys.pubkey0).AsWit().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n-                                \"Basic P2SH(P2WSH) with wrong value\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH,\n+                                \"Basic P2SH(P2WSH) with wrong value\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::SH,\n                                 0, 0).PushWitSig(keys.key0, 1).PushWitRedeem().PushRedeem().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n-                                \"Basic P2SH(P2WPKH) with wrong value\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_PKH,\n+                                \"Basic P2SH(P2WPKH) with wrong value\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::PKH,\n                                 0, 0).PushWitSig(keys.key0, 1).Push(keys.pubkey0).AsWit().PushRedeem().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n \n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n                                 \"P2WPKH with future witness version\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH |\n-                                SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM, false, WITNESS_PKH, 1\n+                                SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM, false, WitnessMode::PKH, 1\n                                ).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().ScriptError(SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM));\n     {\n         CScript witscript = CScript() << ToByteVector(keys.pubkey0);\n@@ -810,118 +810,118 @@ BOOST_AUTO_TEST_CASE(script_build)\n                                    ).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().ScriptError(SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH));\n     }\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n-                                \"P2WSH with empty witness\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH\n+                                \"P2WSH with empty witness\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::SH\n                                ).ScriptError(SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY));\n     {\n         CScript witscript = CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG;\n         tests.push_back(TestBuilder(witscript,\n-                                    \"P2WSH with witness program mismatch\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH\n+                                    \"P2WSH with witness program mismatch\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::SH\n                                    ).PushWitSig(keys.key0).Push(witscript).DamagePush(0).AsWit().ScriptError(SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH));\n     }\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n-                                \"P2WPKH with witness program mismatch\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_PKH\n+                                \"P2WPKH with witness program mismatch\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::PKH\n                                ).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().Push(\"0\").AsWit().ScriptError(SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n-                                \"P2WPKH with non-empty scriptSig\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_PKH\n+                                \"P2WPKH with non-empty scriptSig\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::PKH\n                                ).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().Num(11).ScriptError(SCRIPT_ERR_WITNESS_MALLEATED));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1),\n-                                \"P2SH(P2WPKH) with superfluous push in scriptSig\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_PKH\n+                                \"P2SH(P2WPKH) with superfluous push in scriptSig\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::PKH\n                                ).PushWitSig(keys.key0).Push(keys.pubkey1).AsWit().Num(11).PushRedeem().ScriptError(SCRIPT_ERR_WITNESS_MALLEATED_P2SH));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n                                 \"P2PK with witness\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH\n                                ).PushSig(keys.key0).Push(\"0\").AsWit().ScriptError(SCRIPT_ERR_WITNESS_UNEXPECTED));\n \n     // Compressed keys should pass SCRIPT_VERIFY_WITNESS_PUBKEYTYPE\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0C) << OP_CHECKSIG,\n-                                \"Basic P2WSH with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                \"Basic P2WSH with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::SH,\n                                 0, 1).PushWitSig(keys.key0C).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0C),\n-                                \"Basic P2WPKH with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_PKH,\n+                                \"Basic P2WPKH with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::PKH,\n                                 0, 1).PushWitSig(keys.key0C).Push(keys.pubkey0C).AsWit());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0C) << OP_CHECKSIG,\n-                                \"Basic P2SH(P2WSH) with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                \"Basic P2SH(P2WSH) with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::SH,\n                                 0, 1).PushWitSig(keys.key0C).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0C),\n-                                \"Basic P2SH(P2WPKH) with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_PKH,\n+                                \"Basic P2SH(P2WPKH) with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::PKH,\n                                 0, 1).PushWitSig(keys.key0C).Push(keys.pubkey0C).AsWit().PushRedeem());\n \n     // Testing uncompressed key in witness with SCRIPT_VERIFY_WITNESS_PUBKEYTYPE\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n-                                \"Basic P2WSH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                \"Basic P2WSH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::SH,\n                                 0, 1).PushWitSig(keys.key0).PushWitRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n-                                \"Basic P2WPKH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_PKH,\n+                                \"Basic P2WPKH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::PKH,\n                                 0, 1).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n-                                \"Basic P2SH(P2WSH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                \"Basic P2SH(P2WSH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::SH,\n                                 0, 1).PushWitSig(keys.key0).PushWitRedeem().PushRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n-                                \"Basic P2SH(P2WPKH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_PKH,\n+                                \"Basic P2SH(P2WPKH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::PKH,\n                                 0, 1).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().PushRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n \n     // P2WSH 1-of-2 multisig with compressed keys\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0C).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0C).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1C).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1C).PushWitRedeem().PushRedeem());\n \n     // P2WSH 1-of-2 multisig with first key uncompressed\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0).PushWitRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG with first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0).PushWitRedeem().PushRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1C).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1C).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1C).PushWitRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1C).PushWitRedeem().PushRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n     // P2WSH 1-of-2 multisig with second key uncompressed\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0C).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG second key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG second key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0C).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the first key should pass as the uncompressed key is not used\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the first key should pass as the uncompressed key is not used\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0C).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG with second key uncompressed and signing with the first key should pass as the uncompressed key is not used\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with second key uncompressed and signing with the first key should pass as the uncompressed key is not used\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0C).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1).PushWitRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1).PushWitRedeem().PushRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n \n     std::set<std::string> tests_set;\n@@ -1009,29 +1009,29 @@ BOOST_AUTO_TEST_CASE(script_PushData)\n \n     ScriptError err;\n     std::vector<std::vector<unsigned char> > directStack;\n-    BOOST_CHECK(EvalScript(directStack, CScript(&direct[0], &direct[sizeof(direct)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SIGVERSION_BASE, &err));\n+    BOOST_CHECK(EvalScript(directStack, CScript(&direct[0], &direct[sizeof(direct)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SigVersion::BASE, &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     std::vector<std::vector<unsigned char> > pushdata1Stack;\n-    BOOST_CHECK(EvalScript(pushdata1Stack, CScript(&pushdata1[0], &pushdata1[sizeof(pushdata1)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SIGVERSION_BASE, &err));\n+    BOOST_CHECK(EvalScript(pushdata1Stack, CScript(&pushdata1[0], &pushdata1[sizeof(pushdata1)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SigVersion::BASE, &err));\n     BOOST_CHECK(pushdata1Stack == directStack);\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     std::vector<std::vector<unsigned char> > pushdata2Stack;\n-    BOOST_CHECK(EvalScript(pushdata2Stack, CScript(&pushdata2[0], &pushdata2[sizeof(pushdata2)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SIGVERSION_BASE, &err));\n+    BOOST_CHECK(EvalScript(pushdata2Stack, CScript(&pushdata2[0], &pushdata2[sizeof(pushdata2)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SigVersion::BASE, &err));\n     BOOST_CHECK(pushdata2Stack == directStack);\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     std::vector<std::vector<unsigned char> > pushdata4Stack;\n-    BOOST_CHECK(EvalScript(pushdata4Stack, CScript(&pushdata4[0], &pushdata4[sizeof(pushdata4)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SIGVERSION_BASE, &err));\n+    BOOST_CHECK(EvalScript(pushdata4Stack, CScript(&pushdata4[0], &pushdata4[sizeof(pushdata4)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SigVersion::BASE, &err));\n     BOOST_CHECK(pushdata4Stack == directStack);\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n }\n \n-CScript\n-sign_multisig(CScript scriptPubKey, std::vector<CKey> keys, CTransaction transaction)\n+static CScript\n+sign_multisig(const CScript& scriptPubKey, const std::vector<CKey>& keys, const CTransaction& transaction)\n {\n-    uint256 hash = SignatureHash(scriptPubKey, transaction, 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+    uint256 hash = SignatureHash(scriptPubKey, transaction, 0, SIGHASH_ALL, 0, SigVersion::BASE);\n \n     CScript result;\n     //\n@@ -1052,8 +1052,8 @@ sign_multisig(CScript scriptPubKey, std::vector<CKey> keys, CTransaction transac\n     }\n     return result;\n }\n-CScript\n-sign_multisig(CScript scriptPubKey, const CKey &key, CTransaction transaction)\n+static CScript\n+sign_multisig(const CScript& scriptPubKey, const CKey& key, const CTransaction& transaction)\n {\n     std::vector<CKey> keys;\n     keys.push_back(key);\n@@ -1227,15 +1227,15 @@ BOOST_AUTO_TEST_CASE(script_combineSigs)\n \n     // A couple of partially-signed versions:\n     std::vector<unsigned char> sig1;\n-    uint256 hash1 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+    uint256 hash1 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_ALL, 0, SigVersion::BASE);\n     BOOST_CHECK(keys[0].Sign(hash1, sig1));\n     sig1.push_back(SIGHASH_ALL);\n     std::vector<unsigned char> sig2;\n-    uint256 hash2 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_NONE, 0, SIGVERSION_BASE);\n+    uint256 hash2 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_NONE, 0, SigVersion::BASE);\n     BOOST_CHECK(keys[1].Sign(hash2, sig2));\n     sig2.push_back(SIGHASH_NONE);\n     std::vector<unsigned char> sig3;\n-    uint256 hash3 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_SINGLE, 0, SIGVERSION_BASE);\n+    uint256 hash3 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_SINGLE, 0, SigVersion::BASE);\n     BOOST_CHECK(keys[2].Sign(hash3, sig3));\n     sig3.push_back(SIGHASH_SINGLE);\n \n@@ -1349,102 +1349,102 @@ BOOST_AUTO_TEST_CASE(script_FindAndDelete)\n     s = CScript() << OP_1 << OP_2;\n     d = CScript(); // delete nothing should be a no-op\n     expect = s;\n-    BOOST_CHECK_EQUAL(s.FindAndDelete(d), 0);\n+    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 0);\n     BOOST_CHECK(s == expect);\n \n     s = CScript() << OP_1 << OP_2 << OP_3;\n     d = CScript() << OP_2;\n     expect = CScript() << OP_1 << OP_3;\n-    BOOST_CHECK_EQUAL(s.FindAndDelete(d), 1);\n+    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 1);\n     BOOST_CHECK(s == expect);\n \n     s = CScript() << OP_3 << OP_1 << OP_3 << OP_3 << OP_4 << OP_3;\n     d = CScript() << OP_3;\n     expect = CScript() << OP_1 << OP_4;\n-    BOOST_CHECK_EQUAL(s.FindAndDelete(d), 4);\n+    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 4);\n     BOOST_CHECK(s == expect);\n \n     s = ScriptFromHex(\"0302ff03\"); // PUSH 0x02ff03 onto stack\n     d = ScriptFromHex(\"0302ff03\");\n     expect = CScript();\n-    BOOST_CHECK_EQUAL(s.FindAndDelete(d), 1);\n+    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 1);\n     BOOST_CHECK(s == expect);\n \n     s = ScriptFromHex(\"0302ff030302ff03\"); // PUSH 0x2ff03 PUSH 0x2ff03\n     d = ScriptFromHex(\"0302ff03\");\n     expect = CScript();\n-    BOOST_CHECK_EQUAL(s.FindAndDelete(d), 2);\n+    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 2);\n     BOOST_CHECK(s == expect);\n \n     s = ScriptFromHex(\"0302ff030302ff03\");\n     d = ScriptFromHex(\"02\");\n     expect = s; // FindAndDelete matches entire opcodes\n-    BOOST_CHECK_EQUAL(s.FindAndDelete(d), 0);\n+    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 0);\n     BOOST_CHECK(s == expect);\n \n     s = ScriptFromHex(\"0302ff030302ff03\");\n     d = ScriptFromHex(\"ff\");\n     expect = s;\n-    BOOST_CHECK_EQUAL(s.FindAndDelete(d), 0);\n+    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 0);\n     BOOST_CHECK(s == expect);\n \n     // This is an odd edge case: strip of the push-three-bytes\n     // prefix, leaving 02ff03 which is push-two-bytes:\n     s = ScriptFromHex(\"0302ff030302ff03\");\n     d = ScriptFromHex(\"03\");\n     expect = CScript() << ParseHex(\"ff03\") << ParseHex(\"ff03\");\n-    BOOST_CHECK_EQUAL(s.FindAndDelete(d), 2);\n+    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 2);\n     BOOST_CHECK(s == expect);\n \n     // Byte sequence that spans multiple opcodes:\n     s = ScriptFromHex(\"02feed5169\"); // PUSH(0xfeed) OP_1 OP_VERIFY\n     d = ScriptFromHex(\"feed51\");\n     expect = s;\n-    BOOST_CHECK_EQUAL(s.FindAndDelete(d), 0); // doesn't match 'inside' opcodes\n+    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 0); // doesn't match 'inside' opcodes\n     BOOST_CHECK(s == expect);\n \n     s = ScriptFromHex(\"02feed5169\"); // PUSH(0xfeed) OP_1 OP_VERIFY\n     d = ScriptFromHex(\"02feed51\");\n     expect = ScriptFromHex(\"69\");\n-    BOOST_CHECK_EQUAL(s.FindAndDelete(d), 1);\n+    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 1);\n     BOOST_CHECK(s == expect);\n \n     s = ScriptFromHex(\"516902feed5169\");\n     d = ScriptFromHex(\"feed51\");\n     expect = s;\n-    BOOST_CHECK_EQUAL(s.FindAndDelete(d), 0);\n+    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 0);\n     BOOST_CHECK(s == expect);\n \n     s = ScriptFromHex(\"516902feed5169\");\n     d = ScriptFromHex(\"02feed51\");\n     expect = ScriptFromHex(\"516969\");\n-    BOOST_CHECK_EQUAL(s.FindAndDelete(d), 1);\n+    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 1);\n     BOOST_CHECK(s == expect);\n \n     s = CScript() << OP_0 << OP_0 << OP_1 << OP_1;\n     d = CScript() << OP_0 << OP_1;\n     expect = CScript() << OP_0 << OP_1; // FindAndDelete is single-pass\n-    BOOST_CHECK_EQUAL(s.FindAndDelete(d), 1);\n+    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 1);\n     BOOST_CHECK(s == expect);\n \n     s = CScript() << OP_0 << OP_0 << OP_1 << OP_0 << OP_1 << OP_1;\n     d = CScript() << OP_0 << OP_1;\n     expect = CScript() << OP_0 << OP_1; // FindAndDelete is single-pass\n-    BOOST_CHECK_EQUAL(s.FindAndDelete(d), 2);\n+    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 2);\n     BOOST_CHECK(s == expect);\n \n     // Another weird edge case:\n     // End with invalid push (not enough data)...\n     s = ScriptFromHex(\"0003feed\");\n     d = ScriptFromHex(\"03feed\"); // ... can remove the invalid push\n     expect = ScriptFromHex(\"00\");\n-    BOOST_CHECK_EQUAL(s.FindAndDelete(d), 1);\n+    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 1);\n     BOOST_CHECK(s == expect);\n \n     s = ScriptFromHex(\"0003feed\");\n     d = ScriptFromHex(\"00\");\n     expect = ScriptFromHex(\"03feed\");\n-    BOOST_CHECK_EQUAL(s.FindAndDelete(d), 1);\n+    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 1);\n     BOOST_CHECK(s == expect);\n }\n "
      },
      {
        "sha": "eba58e0042e46b0a4a72088cadf282c129c3017e",
        "filename": "src/test/serialize_tests.cpp",
        "status": "modified",
        "additions": 40,
        "deletions": 35,
        "changes": 75,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/serialize_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/serialize_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/serialize_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -19,19 +19,23 @@ class CSerializeMethodsTestSingle\n     int intval;\n     bool boolval;\n     std::string stringval;\n-    const char* charstrval;\n+    char charstrval[16];\n     CTransactionRef txval;\n public:\n     CSerializeMethodsTestSingle() = default;\n-    CSerializeMethodsTestSingle(int intvalin, bool boolvalin, std::string stringvalin, const char* charstrvalin, CTransaction txvalin) : intval(intvalin), boolval(boolvalin), stringval(std::move(stringvalin)), charstrval(charstrvalin), txval(MakeTransactionRef(txvalin)){}\n+    CSerializeMethodsTestSingle(int intvalin, bool boolvalin, std::string stringvalin, const char* charstrvalin, const CTransactionRef& txvalin) : intval(intvalin), boolval(boolvalin), stringval(std::move(stringvalin)), txval(txvalin)\n+    {\n+        memcpy(charstrval, charstrvalin, sizeof(charstrval));\n+    }\n+\n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n     inline void SerializationOp(Stream& s, Operation ser_action) {\n         READWRITE(intval);\n         READWRITE(boolval);\n         READWRITE(stringval);\n-        READWRITE(FLATDATA(charstrval));\n+        READWRITE(charstrval);\n         READWRITE(txval);\n     }\n \n@@ -53,7 +57,7 @@ class CSerializeMethodsTestMany : public CSerializeMethodsTestSingle\n \n     template <typename Stream, typename Operation>\n     inline void SerializationOp(Stream& s, Operation ser_action) {\n-        READWRITE(intval, boolval, stringval, FLATDATA(charstrval), txval);\n+        READWRITE(intval, boolval, stringval, charstrval, txval);\n     }\n };\n \n@@ -74,18 +78,18 @@ BOOST_AUTO_TEST_CASE(sizes)\n     BOOST_CHECK_EQUAL(sizeof(char), GetSerializeSize(bool(0), 0));\n \n     // Sanity-check GetSerializeSize and c++ type matching\n-    BOOST_CHECK_EQUAL(GetSerializeSize(char(0), 0), 1);\n-    BOOST_CHECK_EQUAL(GetSerializeSize(int8_t(0), 0), 1);\n-    BOOST_CHECK_EQUAL(GetSerializeSize(uint8_t(0), 0), 1);\n-    BOOST_CHECK_EQUAL(GetSerializeSize(int16_t(0), 0), 2);\n-    BOOST_CHECK_EQUAL(GetSerializeSize(uint16_t(0), 0), 2);\n-    BOOST_CHECK_EQUAL(GetSerializeSize(int32_t(0), 0), 4);\n-    BOOST_CHECK_EQUAL(GetSerializeSize(uint32_t(0), 0), 4);\n-    BOOST_CHECK_EQUAL(GetSerializeSize(int64_t(0), 0), 8);\n-    BOOST_CHECK_EQUAL(GetSerializeSize(uint64_t(0), 0), 8);\n-    BOOST_CHECK_EQUAL(GetSerializeSize(float(0), 0), 4);\n-    BOOST_CHECK_EQUAL(GetSerializeSize(double(0), 0), 8);\n-    BOOST_CHECK_EQUAL(GetSerializeSize(bool(0), 0), 1);\n+    BOOST_CHECK_EQUAL(GetSerializeSize(char(0), 0), 1U);\n+    BOOST_CHECK_EQUAL(GetSerializeSize(int8_t(0), 0), 1U);\n+    BOOST_CHECK_EQUAL(GetSerializeSize(uint8_t(0), 0), 1U);\n+    BOOST_CHECK_EQUAL(GetSerializeSize(int16_t(0), 0), 2U);\n+    BOOST_CHECK_EQUAL(GetSerializeSize(uint16_t(0), 0), 2U);\n+    BOOST_CHECK_EQUAL(GetSerializeSize(int32_t(0), 0), 4U);\n+    BOOST_CHECK_EQUAL(GetSerializeSize(uint32_t(0), 0), 4U);\n+    BOOST_CHECK_EQUAL(GetSerializeSize(int64_t(0), 0), 8U);\n+    BOOST_CHECK_EQUAL(GetSerializeSize(uint64_t(0), 0), 8U);\n+    BOOST_CHECK_EQUAL(GetSerializeSize(float(0), 0), 4U);\n+    BOOST_CHECK_EQUAL(GetSerializeSize(double(0), 0), 8U);\n+    BOOST_CHECK_EQUAL(GetSerializeSize(bool(0), 0), 1U);\n }\n \n BOOST_AUTO_TEST_CASE(floats_conversion)\n@@ -99,12 +103,12 @@ BOOST_AUTO_TEST_CASE(floats_conversion)\n     BOOST_CHECK_EQUAL(ser_uint32_to_float(0x40800000), 4.0F);\n     BOOST_CHECK_EQUAL(ser_uint32_to_float(0x44444444), 785.066650390625F);\n \n-    BOOST_CHECK_EQUAL(ser_float_to_uint32(0.0F), 0x00000000);\n-    BOOST_CHECK_EQUAL(ser_float_to_uint32(0.5F), 0x3f000000);\n-    BOOST_CHECK_EQUAL(ser_float_to_uint32(1.0F), 0x3f800000);\n-    BOOST_CHECK_EQUAL(ser_float_to_uint32(2.0F), 0x40000000);\n-    BOOST_CHECK_EQUAL(ser_float_to_uint32(4.0F), 0x40800000);\n-    BOOST_CHECK_EQUAL(ser_float_to_uint32(785.066650390625F), 0x44444444);\n+    BOOST_CHECK_EQUAL(ser_float_to_uint32(0.0F), 0x00000000U);\n+    BOOST_CHECK_EQUAL(ser_float_to_uint32(0.5F), 0x3f000000U);\n+    BOOST_CHECK_EQUAL(ser_float_to_uint32(1.0F), 0x3f800000U);\n+    BOOST_CHECK_EQUAL(ser_float_to_uint32(2.0F), 0x40000000U);\n+    BOOST_CHECK_EQUAL(ser_float_to_uint32(4.0F), 0x40800000U);\n+    BOOST_CHECK_EQUAL(ser_float_to_uint32(785.066650390625F), 0x44444444U);\n }\n \n BOOST_AUTO_TEST_CASE(doubles_conversion)\n@@ -295,39 +299,39 @@ BOOST_AUTO_TEST_CASE(insert_delete)\n {\n     // Test inserting/deleting bytes.\n     CDataStream ss(SER_DISK, 0);\n-    BOOST_CHECK_EQUAL(ss.size(), 0);\n+    BOOST_CHECK_EQUAL(ss.size(), 0U);\n \n     ss.write(\"\\x00\\x01\\x02\\xff\", 4);\n-    BOOST_CHECK_EQUAL(ss.size(), 4);\n+    BOOST_CHECK_EQUAL(ss.size(), 4U);\n \n     char c = (char)11;\n \n     // Inserting at beginning/end/middle:\n     ss.insert(ss.begin(), c);\n-    BOOST_CHECK_EQUAL(ss.size(), 5);\n+    BOOST_CHECK_EQUAL(ss.size(), 5U);\n     BOOST_CHECK_EQUAL(ss[0], c);\n     BOOST_CHECK_EQUAL(ss[1], 0);\n \n     ss.insert(ss.end(), c);\n-    BOOST_CHECK_EQUAL(ss.size(), 6);\n+    BOOST_CHECK_EQUAL(ss.size(), 6U);\n     BOOST_CHECK_EQUAL(ss[4], (char)0xff);\n     BOOST_CHECK_EQUAL(ss[5], c);\n \n     ss.insert(ss.begin()+2, c);\n-    BOOST_CHECK_EQUAL(ss.size(), 7);\n+    BOOST_CHECK_EQUAL(ss.size(), 7U);\n     BOOST_CHECK_EQUAL(ss[2], c);\n \n     // Delete at beginning/end/middle\n     ss.erase(ss.begin());\n-    BOOST_CHECK_EQUAL(ss.size(), 6);\n+    BOOST_CHECK_EQUAL(ss.size(), 6U);\n     BOOST_CHECK_EQUAL(ss[0], 0);\n \n     ss.erase(ss.begin()+ss.size()-1);\n-    BOOST_CHECK_EQUAL(ss.size(), 5);\n+    BOOST_CHECK_EQUAL(ss.size(), 5U);\n     BOOST_CHECK_EQUAL(ss[4], (char)0xff);\n \n     ss.erase(ss.begin()+1);\n-    BOOST_CHECK_EQUAL(ss.size(), 4);\n+    BOOST_CHECK_EQUAL(ss.size(), 4U);\n     BOOST_CHECK_EQUAL(ss[0], 0);\n     BOOST_CHECK_EQUAL(ss[1], 1);\n     BOOST_CHECK_EQUAL(ss[2], 2);\n@@ -336,18 +340,19 @@ BOOST_AUTO_TEST_CASE(insert_delete)\n     // Make sure GetAndClear does the right thing:\n     CSerializeData d;\n     ss.GetAndClear(d);\n-    BOOST_CHECK_EQUAL(ss.size(), 0);\n+    BOOST_CHECK_EQUAL(ss.size(), 0U);\n }\n \n BOOST_AUTO_TEST_CASE(class_methods)\n {\n     int intval(100);\n     bool boolval(true);\n     std::string stringval(\"testing\");\n-    const char* charstrval(\"testing charstr\");\n+    const char charstrval[16] = \"testing charstr\";\n     CMutableTransaction txval;\n-    CSerializeMethodsTestSingle methodtest1(intval, boolval, stringval, charstrval, txval);\n-    CSerializeMethodsTestMany methodtest2(intval, boolval, stringval, charstrval, txval);\n+    CTransactionRef tx_ref{MakeTransactionRef(txval)};\n+    CSerializeMethodsTestSingle methodtest1(intval, boolval, stringval, charstrval, tx_ref);\n+    CSerializeMethodsTestMany methodtest2(intval, boolval, stringval, charstrval, tx_ref);\n     CSerializeMethodsTestSingle methodtest3;\n     CSerializeMethodsTestMany methodtest4;\n     CDataStream ss(SER_DISK, PROTOCOL_VERSION);\n@@ -360,7 +365,7 @@ BOOST_AUTO_TEST_CASE(class_methods)\n     BOOST_CHECK(methodtest2 == methodtest3);\n     BOOST_CHECK(methodtest3 == methodtest4);\n \n-    CDataStream ss2(SER_DISK, PROTOCOL_VERSION, intval, boolval, stringval, FLATDATA(charstrval), txval);\n+    CDataStream ss2(SER_DISK, PROTOCOL_VERSION, intval, boolval, stringval, charstrval, txval);\n     ss2 >> methodtest3;\n     BOOST_CHECK(methodtest3 == methodtest4);\n }"
      },
      {
        "sha": "6b8856ef47cb74d13ba88d69ffe48ca55986e546",
        "filename": "src/test/sighash_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/sighash_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/sighash_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sighash_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -35,7 +35,7 @@ uint256 static SignatureHashOld(CScript scriptCode, const CTransaction& txTo, un\n \n     // In case concatenating two scripts ends up with two codeseparators,\n     // or an extra one at the end, this prevents all those possible incompatibilities.\n-    scriptCode.FindAndDelete(CScript(OP_CODESEPARATOR));\n+    FindAndDelete(scriptCode, CScript(OP_CODESEPARATOR));\n \n     // Blank out other inputs' signatures\n     for (unsigned int i = 0; i < txTmp.vin.size(); i++)\n@@ -138,7 +138,7 @@ BOOST_AUTO_TEST_CASE(sighash_test)\n \n         uint256 sh, sho;\n         sho = SignatureHashOld(scriptCode, txTo, nIn, nHashType);\n-        sh = SignatureHash(scriptCode, txTo, nIn, nHashType, 0, SIGVERSION_BASE);\n+        sh = SignatureHash(scriptCode, txTo, nIn, nHashType, 0, SigVersion::BASE);\n         #if defined(PRINT_SIGHASH_JSON)\n         CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n         ss << txTo;\n@@ -204,7 +204,7 @@ BOOST_AUTO_TEST_CASE(sighash_from_data)\n           continue;\n         }\n \n-        sh = SignatureHash(scriptCode, *tx, nIn, nHashType, 0, SIGVERSION_BASE);\n+        sh = SignatureHash(scriptCode, *tx, nIn, nHashType, 0, SigVersion::BASE);\n         BOOST_CHECK_MESSAGE(sh.GetHex() == sigHashHex, strTest);\n     }\n }"
      },
      {
        "sha": "86647e72ebb68e68f5baf808b9a3f07c844afe42",
        "filename": "src/test/sigopcount_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/sigopcount_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/sigopcount_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sigopcount_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -67,7 +67,7 @@ BOOST_AUTO_TEST_CASE(GetSigOpCount)\n  * Verifies script execution of the zeroth scriptPubKey of tx output and\n  * zeroth scriptSig and witness of tx input.\n  */\n-ScriptError VerifyWithFlag(const CTransaction& output, const CMutableTransaction& input, int flags)\n+static ScriptError VerifyWithFlag(const CTransaction& output, const CMutableTransaction& input, int flags)\n {\n     ScriptError error;\n     CTransaction inputi(input);\n@@ -82,7 +82,7 @@ ScriptError VerifyWithFlag(const CTransaction& output, const CMutableTransaction\n  * and witness such that spendingTx spends output zero of creationTx.\n  * Also inserts creationTx's output into the coins view.\n  */\n-void BuildTxs(CMutableTransaction& spendingTx, CCoinsViewCache& coins, CMutableTransaction& creationTx, const CScript& scriptPubKey, const CScript& scriptSig, const CScriptWitness& witness)\n+static void BuildTxs(CMutableTransaction& spendingTx, CCoinsViewCache& coins, CMutableTransaction& creationTx, const CScript& scriptPubKey, const CScript& scriptSig, const CScriptWitness& witness)\n {\n     creationTx.nVersion = 1;\n     creationTx.vin.resize(1);"
      },
      {
        "sha": "5d057108b13b327ee5c9cbb8b3136d1816efad12",
        "filename": "src/test/streams_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/streams_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/streams_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/streams_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -57,16 +57,16 @@ BOOST_AUTO_TEST_CASE(streams_vector_writer)\n     BOOST_CHECK((vch == std::vector<unsigned char>{{0, 0, 0, 0, 1, 2}}));\n     vch.clear();\n \n-    CVectorWriter(SER_NETWORK, INIT_PROTO_VERSION, vch, 0, FLATDATA(bytes));\n+    CVectorWriter(SER_NETWORK, INIT_PROTO_VERSION, vch, 0, bytes);\n     BOOST_CHECK((vch == std::vector<unsigned char>{{3, 4, 5, 6}}));\n-    CVectorWriter(SER_NETWORK, INIT_PROTO_VERSION, vch, 0, FLATDATA(bytes));\n+    CVectorWriter(SER_NETWORK, INIT_PROTO_VERSION, vch, 0, bytes);\n     BOOST_CHECK((vch == std::vector<unsigned char>{{3, 4, 5, 6}}));\n     vch.clear();\n \n     vch.resize(4, 8);\n-    CVectorWriter(SER_NETWORK, INIT_PROTO_VERSION, vch, 2, a, FLATDATA(bytes), b);\n+    CVectorWriter(SER_NETWORK, INIT_PROTO_VERSION, vch, 2, a, bytes, b);\n     BOOST_CHECK((vch == std::vector<unsigned char>{{8, 8, 1, 3, 4, 5, 6, 2}}));\n-    CVectorWriter(SER_NETWORK, INIT_PROTO_VERSION, vch, 2, a, FLATDATA(bytes), b);\n+    CVectorWriter(SER_NETWORK, INIT_PROTO_VERSION, vch, 2, a, bytes, b);\n     BOOST_CHECK((vch == std::vector<unsigned char>{{8, 8, 1, 3, 4, 5, 6, 2}}));\n     vch.clear();\n }"
      },
      {
        "sha": "fe816a6f7984832b64f1c14c4d416842f2fb8e18",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 11,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -17,8 +17,6 @@\n #include <rpc/register.h>\n #include <script/sigcache.h>\n \n-#include <memory>\n-\n void CConnmanTest::AddNode(CNode& node)\n {\n     LOCK(g_connman->cs_vNodes);\n@@ -49,7 +47,6 @@ BasicTestingSetup::BasicTestingSetup(const std::string& chainName)\n         SetupNetworking();\n         InitSignatureCache();\n         InitScriptExecutionCache();\n-        fPrintToDebugLog = false; // don't want to write to debug.log file\n         fCheckBlockIndex = true;\n         SelectParams(chainName);\n         noui_connect();\n@@ -68,7 +65,7 @@ TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(cha\n \n         RegisterAllCoreRPCCommands(tableRPC);\n         ClearDatadirCache();\n-        pathTemp = fs::temp_directory_path() / strprintf(\"test_bitcoin_%lu_%i\", (unsigned long)GetTime(), (int)(InsecureRandRange(100000)));\n+        pathTemp = fs::temp_directory_path() / strprintf(\"test_bitcoin_%lu_%i\", (unsigned long)GetTime(), (int)(InsecureRandRange(1 << 30)));\n         fs::create_directories(pathTemp);\n         gArgs.ForceSetArg(\"-datadir\", pathTemp.string());\n \n@@ -87,7 +84,7 @@ TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(cha\n         {\n             CValidationState state;\n             if (!ActivateBestChain(state, chainparams)) {\n-                throw std::runtime_error(\"ActivateBestChain failed.\");\n+                throw std::runtime_error(strprintf(\"ActivateBestChain failed. (%s)\", FormatStateMessage(state)));\n             }\n         }\n         nScriptCheckThreads = 3;\n@@ -125,7 +122,7 @@ TestChain100Setup::TestChain100Setup() : TestingSetup(CBaseChainParams::REGTEST)\n     {\n         std::vector<CMutableTransaction> noTxns;\n         CBlock b = CreateAndProcessBlock(noTxns, scriptPubKey);\n-        coinbaseTxns.push_back(*b.vtx[0]);\n+        m_coinbase_txns.push_back(b.vtx[0]);\n     }\n }\n \n@@ -145,9 +142,9 @@ TestChain100Setup::CreateAndProcessBlock(const std::vector<CMutableTransaction>&\n     for (const CMutableTransaction& tx : txns)\n         block.vtx.push_back(MakeTransactionRef(tx));\n     // IncrementExtraNonce creates a valid coinbase and merkleRoot\n-    unsigned int extraNonce = 0;\n     {\n         LOCK(cs_main);\n+        unsigned int extraNonce = 0;\n         IncrementExtraNonce(&block, chainActive.Tip(), extraNonce);\n     }\n \n@@ -166,12 +163,12 @@ TestChain100Setup::~TestChain100Setup()\n \n \n CTxMemPoolEntry TestMemPoolEntryHelper::FromTx(const CMutableTransaction &tx) {\n-    CTransaction txn(tx);\n-    return FromTx(txn);\n+    return FromTx(MakeTransactionRef(tx));\n }\n \n-CTxMemPoolEntry TestMemPoolEntryHelper::FromTx(const CTransaction &txn) {\n-    return CTxMemPoolEntry(MakeTransactionRef(txn), nFee, nTime, nHeight,\n+CTxMemPoolEntry TestMemPoolEntryHelper::FromTx(const CTransactionRef& tx)\n+{\n+    return CTxMemPoolEntry(tx, nFee, nTime, nHeight,\n                            spendsCoinbase, sigOpCost, lp);\n }\n "
      },
      {
        "sha": "1f91eb622c9f1d592d5a7498e55ea44c26665713",
        "filename": "src/test/test_bitcoin.h",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/test_bitcoin.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/test_bitcoin.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -14,6 +14,8 @@\n #include <txdb.h>\n #include <txmempool.h>\n \n+#include <memory>\n+\n #include <boost/thread.hpp>\n \n extern uint256 insecure_rand_seed;\n@@ -85,7 +87,7 @@ struct TestChain100Setup : public TestingSetup {\n \n     ~TestChain100Setup();\n \n-    std::vector<CTransaction> coinbaseTxns; // For convenience, coinbase transactions\n+    std::vector<CTransactionRef> m_coinbase_txns; // For convenience, coinbase transactions\n     CKey coinbaseKey; // private/public key needed to spend coinbase transactions\n };\n \n@@ -105,8 +107,8 @@ struct TestMemPoolEntryHelper\n         nFee(0), nTime(0), nHeight(1),\n         spendsCoinbase(false), sigOpCost(4) { }\n \n-    CTxMemPoolEntry FromTx(const CMutableTransaction &tx);\n-    CTxMemPoolEntry FromTx(const CTransaction &tx);\n+    CTxMemPoolEntry FromTx(const CMutableTransaction& tx);\n+    CTxMemPoolEntry FromTx(const CTransactionRef& tx);\n \n     // Change the default value\n     TestMemPoolEntryHelper &Fee(CAmount _fee) { nFee = _fee; return *this; }"
      },
      {
        "sha": "b2daa2adb542ebd665cb50b82c3e0fc33e2a852b",
        "filename": "src/test/test_bitcoin_fuzzy.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/test_bitcoin_fuzzy.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/test_bitcoin_fuzzy.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin_fuzzy.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -25,6 +25,7 @@\n #include <unistd.h>\n \n #include <algorithm>\n+#include <memory>\n #include <vector>\n \n enum TEST_ID {\n@@ -51,7 +52,7 @@ enum TEST_ID {\n     TEST_ID_END\n };\n \n-bool read_stdin(std::vector<uint8_t> &data) {\n+static bool read_stdin(std::vector<uint8_t> &data) {\n     uint8_t buffer[1024];\n     ssize_t length=0;\n     while((length = read(STDIN_FILENO, buffer, 1024)) > 0) {\n@@ -62,7 +63,7 @@ bool read_stdin(std::vector<uint8_t> &data) {\n     return length==0;\n }\n \n-int test_one_input(std::vector<uint8_t> buffer) {\n+static int test_one_input(std::vector<uint8_t> buffer) {\n     if (buffer.size() < sizeof(uint32_t)) return 0;\n \n     uint32_t test_id = 0xffffffff;"
      },
      {
        "sha": "e48c685b6b597cc2006de56fe63749d61c251fe4",
        "filename": "src/test/test_bitcoin_main.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/test_bitcoin_main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/test_bitcoin_main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin_main.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -6,6 +6,8 @@\n \n #include <net.h>\n \n+#include <memory>\n+\n #include <boost/test/unit_test.hpp>\n \n std::unique_ptr<CConnman> g_connman;"
      },
      {
        "sha": "8bd5ce12227fb8d3ba45eeff2b75fa03c3b3b425",
        "filename": "src/test/torcontrol_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/torcontrol_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/torcontrol_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/torcontrol_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -10,7 +10,7 @@\n \n BOOST_FIXTURE_TEST_SUITE(torcontrol_tests, BasicTestingSetup)\n \n-void CheckSplitTorReplyLine(std::string input, std::string command, std::string args)\n+static void CheckSplitTorReplyLine(std::string input, std::string command, std::string args)\n {\n     BOOST_TEST_MESSAGE(std::string(\"CheckSplitTorReplyLine(\") + input + \")\");\n     auto ret = SplitTorReplyLine(input);\n@@ -51,7 +51,7 @@ BOOST_AUTO_TEST_CASE(util_SplitTorReplyLine)\n     CheckSplitTorReplyLine(\"COMMAND   EVEN+more  ARGS\", \"COMMAND\", \"  EVEN+more  ARGS\");\n }\n \n-void CheckParseTorReplyMapping(std::string input, std::map<std::string,std::string> expected)\n+static void CheckParseTorReplyMapping(std::string input, std::map<std::string,std::string> expected)\n {\n     BOOST_TEST_MESSAGE(std::string(\"CheckParseTorReplyMapping(\") + input + \")\");\n     auto ret = ParseTorReplyMapping(input);\n@@ -167,10 +167,10 @@ BOOST_AUTO_TEST_CASE(util_ParseTorReplyMapping)\n     // (needed because string comparison reads the null as end-of-string)\n     BOOST_TEST_MESSAGE(std::string(\"CheckParseTorReplyMapping(Null=\\\"\\\\0\\\")\"));\n     auto ret = ParseTorReplyMapping(\"Null=\\\"\\\\0\\\"\");\n-    BOOST_CHECK_EQUAL(ret.size(), 1);\n+    BOOST_CHECK_EQUAL(ret.size(), 1U);\n     auto r_it = ret.begin();\n     BOOST_CHECK_EQUAL(r_it->first, \"Null\");\n-    BOOST_CHECK_EQUAL(r_it->second.size(), 1);\n+    BOOST_CHECK_EQUAL(r_it->second.size(), 1U);\n     BOOST_CHECK_EQUAL(r_it->second[0], '\\0');\n \n     // A more complex valid grammar. PROTOCOLINFO accepts a VersionLine that"
      },
      {
        "sha": "c753e0a11d4f48c352028c367a47f3da0c2aa7f6",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -343,7 +343,7 @@ BOOST_AUTO_TEST_CASE(test_Get)\n     BOOST_CHECK_EQUAL(coins.GetValueIn(t1), (50+21+22)*CENT);\n }\n \n-void CreateCreditAndSpend(const CKeyStore& keystore, const CScript& outscript, CTransactionRef& output, CMutableTransaction& input, bool success = true)\n+static void CreateCreditAndSpend(const CKeyStore& keystore, const CScript& outscript, CTransactionRef& output, CMutableTransaction& input, bool success = true)\n {\n     CMutableTransaction outputm;\n     outputm.nVersion = 1;\n@@ -381,7 +381,7 @@ void CreateCreditAndSpend(const CKeyStore& keystore, const CScript& outscript, C\n     assert(input.vin[0].scriptWitness.stack == inputm.vin[0].scriptWitness.stack);\n }\n \n-void CheckWithFlag(const CTransactionRef& output, const CMutableTransaction& input, int flags, bool success)\n+static void CheckWithFlag(const CTransactionRef& output, const CMutableTransaction& input, int flags, bool success)\n {\n     ScriptError error;\n     CTransaction inputi(input);\n@@ -404,10 +404,10 @@ static CScript PushAll(const std::vector<valtype>& values)\n     return result;\n }\n \n-void ReplaceRedeemScript(CScript& script, const CScript& redeemScript)\n+static void ReplaceRedeemScript(CScript& script, const CScript& redeemScript)\n {\n     std::vector<valtype> stack;\n-    EvalScript(stack, script, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker(), SIGVERSION_BASE);\n+    EvalScript(stack, script, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker(), SigVersion::BASE);\n     assert(stack.size() > 0);\n     stack.back() = std::vector<unsigned char>(redeemScript.begin(), redeemScript.end());\n     script = PushAll(stack);"
      },
      {
        "sha": "14158f2875fd6eb26cbfd985df734373fe388a21",
        "filename": "src/test/txindex_tests.cpp",
        "status": "added",
        "additions": 66,
        "deletions": 0,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/txindex_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/txindex_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txindex_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -0,0 +1,66 @@\n+// Copyright (c) 2017-2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <index/txindex.h>\n+#include <script/standard.h>\n+#include <test/test_bitcoin.h>\n+#include <util.h>\n+#include <utiltime.h>\n+#include <validation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(txindex_tests)\n+\n+BOOST_FIXTURE_TEST_CASE(txindex_initial_sync, TestChain100Setup)\n+{\n+    TxIndex txindex(MakeUnique<TxIndexDB>(1 << 20, true));\n+\n+    CTransactionRef tx_disk;\n+    uint256 block_hash;\n+\n+    // Transaction should not be found in the index before it is started.\n+    for (const auto& txn : m_coinbase_txns) {\n+        BOOST_CHECK(!txindex.FindTx(txn->GetHash(), block_hash, tx_disk));\n+    }\n+\n+    // BlockUntilSyncedToCurrentChain should return false before txindex is started.\n+    BOOST_CHECK(!txindex.BlockUntilSyncedToCurrentChain());\n+\n+    txindex.Start();\n+\n+    // Allow tx index to catch up with the block index.\n+    constexpr int64_t timeout_ms = 10 * 1000;\n+    int64_t time_start = GetTimeMillis();\n+    while (!txindex.BlockUntilSyncedToCurrentChain()) {\n+        BOOST_REQUIRE(time_start + timeout_ms > GetTimeMillis());\n+        MilliSleep(100);\n+    }\n+\n+    // Check that txindex has all txs that were in the chain before it started.\n+    for (const auto& txn : m_coinbase_txns) {\n+        if (!txindex.FindTx(txn->GetHash(), block_hash, tx_disk)) {\n+            BOOST_ERROR(\"FindTx failed\");\n+        } else if (tx_disk->GetHash() != txn->GetHash()) {\n+            BOOST_ERROR(\"Read incorrect tx\");\n+        }\n+    }\n+\n+    // Check that new transactions in new blocks make it into the index.\n+    for (int i = 0; i < 10; i++) {\n+        CScript coinbase_script_pub_key = GetScriptForDestination(coinbaseKey.GetPubKey().GetID());\n+        std::vector<CMutableTransaction> no_txns;\n+        const CBlock& block = CreateAndProcessBlock(no_txns, coinbase_script_pub_key);\n+        const CTransaction& txn = *block.vtx[0];\n+\n+        BOOST_CHECK(txindex.BlockUntilSyncedToCurrentChain());\n+        if (!txindex.FindTx(txn.GetHash(), block_hash, tx_disk)) {\n+            BOOST_ERROR(\"FindTx failed\");\n+        } else if (tx_disk->GetHash() != txn.GetHash()) {\n+            BOOST_ERROR(\"Read incorrect tx\");\n+        }\n+    }\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "eb23ba5ad21656b67278fcc4a84030bc67cf0f93",
        "filename": "src/test/txvalidationcache_tests.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/txvalidationcache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/txvalidationcache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidationcache_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -48,15 +48,15 @@ BOOST_FIXTURE_TEST_CASE(tx_mempool_block_doublespend, TestChain100Setup)\n     {\n         spends[i].nVersion = 1;\n         spends[i].vin.resize(1);\n-        spends[i].vin[0].prevout.hash = coinbaseTxns[0].GetHash();\n+        spends[i].vin[0].prevout.hash = m_coinbase_txns[0]->GetHash();\n         spends[i].vin[0].prevout.n = 0;\n         spends[i].vout.resize(1);\n         spends[i].vout[0].nValue = 11*CENT;\n         spends[i].vout[0].scriptPubKey = scriptPubKey;\n \n         // Sign:\n         std::vector<unsigned char> vchSig;\n-        uint256 hash = SignatureHash(scriptPubKey, spends[i], 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+        uint256 hash = SignatureHash(scriptPubKey, spends[i], 0, SIGHASH_ALL, 0, SigVersion::BASE);\n         BOOST_CHECK(coinbaseKey.Sign(hash, vchSig));\n         vchSig.push_back((unsigned char)SIGHASH_ALL);\n         spends[i].vin[0].scriptSig << vchSig;\n@@ -88,7 +88,7 @@ BOOST_FIXTURE_TEST_CASE(tx_mempool_block_doublespend, TestChain100Setup)\n     BOOST_CHECK(chainActive.Tip()->GetBlockHash() == block.GetHash());\n     // spends[1] should have been removed from the mempool when the\n     // block with spends[0] is accepted:\n-    BOOST_CHECK_EQUAL(mempool.size(), 0);\n+    BOOST_CHECK_EQUAL(mempool.size(), 0U);\n }\n \n // Run CheckInputs (using pcoinsTip) on the given transaction, for all script\n@@ -102,7 +102,7 @@ BOOST_FIXTURE_TEST_CASE(tx_mempool_block_doublespend, TestChain100Setup)\n // should fail.\n // Capture this interaction with the upgraded_nop argument: set it when evaluating\n // any script flag that is implemented as an upgraded NOP code.\n-void ValidateCheckInputsForAllFlags(CMutableTransaction &tx, uint32_t failing_flags, bool add_to_cache)\n+static void ValidateCheckInputsForAllFlags(CMutableTransaction &tx, uint32_t failing_flags, bool add_to_cache)\n {\n     PrecomputedTransactionData txdata(tx);\n     // If we add many more flags, this loop can get too expensive, but we can\n@@ -167,7 +167,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n \n     spend_tx.nVersion = 1;\n     spend_tx.vin.resize(1);\n-    spend_tx.vin[0].prevout.hash = coinbaseTxns[0].GetHash();\n+    spend_tx.vin[0].prevout.hash = m_coinbase_txns[0]->GetHash();\n     spend_tx.vin[0].prevout.n = 0;\n     spend_tx.vout.resize(4);\n     spend_tx.vout[0].nValue = 11*CENT;\n@@ -182,7 +182,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n     // Sign, with a non-DER signature\n     {\n         std::vector<unsigned char> vchSig;\n-        uint256 hash = SignatureHash(p2pk_scriptPubKey, spend_tx, 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+        uint256 hash = SignatureHash(p2pk_scriptPubKey, spend_tx, 0, SIGHASH_ALL, 0, SigVersion::BASE);\n         BOOST_CHECK(coinbaseKey.Sign(hash, vchSig));\n         vchSig.push_back((unsigned char) 0); // padding byte makes this non-DER\n         vchSig.push_back((unsigned char)SIGHASH_ALL);\n@@ -205,7 +205,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         // not caching invalidity (if that changes, delete this test case).\n         std::vector<CScriptCheck> scriptchecks;\n         BOOST_CHECK(CheckInputs(spend_tx, state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, &scriptchecks));\n-        BOOST_CHECK_EQUAL(scriptchecks.size(), 1);\n+        BOOST_CHECK_EQUAL(scriptchecks.size(), 1U);\n \n         // Test that CheckInputs returns true iff DERSIG-enforcing flags are\n         // not present.  Don't add these checks to the cache, so that we can\n@@ -256,7 +256,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n \n         // Sign\n         std::vector<unsigned char> vchSig;\n-        uint256 hash = SignatureHash(spend_tx.vout[2].scriptPubKey, invalid_with_cltv_tx, 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+        uint256 hash = SignatureHash(spend_tx.vout[2].scriptPubKey, invalid_with_cltv_tx, 0, SIGHASH_ALL, 0, SigVersion::BASE);\n         BOOST_CHECK(coinbaseKey.Sign(hash, vchSig));\n         vchSig.push_back((unsigned char)SIGHASH_ALL);\n         invalid_with_cltv_tx.vin[0].scriptSig = CScript() << vchSig << 101;\n@@ -284,7 +284,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n \n         // Sign\n         std::vector<unsigned char> vchSig;\n-        uint256 hash = SignatureHash(spend_tx.vout[3].scriptPubKey, invalid_with_csv_tx, 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+        uint256 hash = SignatureHash(spend_tx.vout[3].scriptPubKey, invalid_with_csv_tx, 0, SIGHASH_ALL, 0, SigVersion::BASE);\n         BOOST_CHECK(coinbaseKey.Sign(hash, vchSig));\n         vchSig.push_back((unsigned char)SIGHASH_ALL);\n         invalid_with_csv_tx.vin[0].scriptSig = CScript() << vchSig << 101;\n@@ -314,7 +314,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n \n         // Sign\n         SignatureData sigdata;\n-        ProduceSignature(MutableTransactionSignatureCreator(&keystore, &valid_with_witness_tx, 0, 11*CENT, SIGHASH_ALL), spend_tx.vout[1].scriptPubKey, sigdata);\n+        ProduceSignature(keystore, MutableTransactionSignatureCreator(&valid_with_witness_tx, 0, 11*CENT, SIGHASH_ALL), spend_tx.vout[1].scriptPubKey, sigdata);\n         UpdateTransaction(valid_with_witness_tx, 0, sigdata);\n \n         // This should be valid under all script flags.\n@@ -342,7 +342,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         // Sign\n         for (int i=0; i<2; ++i) {\n             SignatureData sigdata;\n-            ProduceSignature(MutableTransactionSignatureCreator(&keystore, &tx, i, 11*CENT, SIGHASH_ALL), spend_tx.vout[i].scriptPubKey, sigdata);\n+            ProduceSignature(keystore, MutableTransactionSignatureCreator(&tx, i, 11*CENT, SIGHASH_ALL), spend_tx.vout[i].scriptPubKey, sigdata);\n             UpdateTransaction(tx, i, sigdata);\n         }\n \n@@ -364,7 +364,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         // input was valid)\n         BOOST_CHECK(CheckInputs(tx, state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, &scriptchecks));\n         // Should get 2 script checks back -- caching is on a whole-transaction basis.\n-        BOOST_CHECK_EQUAL(scriptchecks.size(), 2);\n+        BOOST_CHECK_EQUAL(scriptchecks.size(), 2U);\n     }\n }\n "
      },
      {
        "sha": "79217fa4304bafa82f890d9429c62056cf3d2b59",
        "filename": "src/test/uint256_tests.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 1,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/uint256_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/uint256_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/uint256_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "patch": "@@ -48,7 +48,7 @@ const unsigned char MaxArray[] =\n const uint256 MaxL = uint256(std::vector<unsigned char>(MaxArray,MaxArray+32));\n const uint160 MaxS = uint160(std::vector<unsigned char>(MaxArray,MaxArray+20));\n \n-std::string ArrayToString(const unsigned char A[], unsigned int width)\n+static std::string ArrayToString(const unsigned char A[], unsigned int width)\n {\n     std::stringstream Stream;\n     Stream << std::hex;\n@@ -266,4 +266,17 @@ BOOST_AUTO_TEST_CASE( conversion )\n     BOOST_CHECK(R2L.GetHex() == UintToArith256(R2L).GetHex());\n }\n \n+BOOST_AUTO_TEST_CASE( operator_with_self )\n+{\n+    arith_uint256 v = UintToArith256(uint256S(\"02\"));\n+    v *= v;\n+    BOOST_CHECK(v == UintToArith256(uint256S(\"04\")));\n+    v /= v;\n+    BOOST_CHECK(v == UintToArith256(uint256S(\"01\")));\n+    v += v;\n+    BOOST_CHECK(v == UintToArith256(uint256S(\"02\")));\n+    v -= v;\n+    BOOST_CHECK(v == UintToArith256(uint256S(\"0\")));\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "1c3acfb1a5a289ea5f6c677e6abc2e6292f67660",
        "filename": "src/test/util_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/util_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/util_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b"
      },
      {
        "sha": "7442825300106a4b5cbb191f0ec7bc3cf7d17fdb",
        "filename": "src/test/versionbits_tests.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/versionbits_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/test/versionbits_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/versionbits_tests.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b"
      },
      {
        "sha": "7da4e136ef57f442509581107b67f9a588b1d38a",
        "filename": "src/threadinterrupt.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/threadinterrupt.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/threadinterrupt.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/threadinterrupt.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b"
      },
      {
        "sha": "d373e3c371e44ef937e963ea24f2e947fab1c6d9",
        "filename": "src/threadinterrupt.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/threadinterrupt.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/threadinterrupt.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/threadinterrupt.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b"
      },
      {
        "sha": "27d08172f52fc44c50467d3a7fccbd2c7f1f8725",
        "filename": "src/timedata.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/timedata.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/timedata.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/timedata.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b"
      },
      {
        "sha": "333d3596c155729c83b4a38bb17ff4d2aeeccfc9",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 174,
        "deletions": 3,
        "changes": 177,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b"
      },
      {
        "sha": "4193f98de1858eeccd1a0deeaa1691f0ef50242b",
        "filename": "src/txdb.h",
        "status": "modified",
        "additions": 36,
        "deletions": 5,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b"
      },
      {
        "sha": "d03429ca818734e06c4316ec769f188345c57148",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b"
      },
      {
        "sha": "3f9fb4850c45f24e67973054b04375b9a088590d",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b"
      },
      {
        "sha": "7dd6884f7588b03591051f409cebe9f97865790a",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 471,
        "deletions": 335,
        "changes": 806,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b"
      },
      {
        "sha": "17dd5c068321ed1ec17f7a088f733299398e48ed",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 90,
        "deletions": 110,
        "changes": 200,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b"
      },
      {
        "sha": "e60996efe1ae375435239bd9894a7dfc9db96ec4",
        "filename": "src/utiltime.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 15,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/utiltime.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/utiltime.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utiltime.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b"
      },
      {
        "sha": "3bcbb00c163e0e5a6eef97559f48dd23420ab29f",
        "filename": "src/utiltime.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/utiltime.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/utiltime.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utiltime.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b"
      },
      {
        "sha": "8a941561bbe1f686fc2adcb4bfe4b77a961d39c4",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 189,
        "deletions": 161,
        "changes": 350,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b"
      },
      {
        "sha": "9b4010076521e3a87884619571887f132da4d97d",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 11,
        "deletions": 6,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b"
      },
      {
        "sha": "f328d2d14be9af9bff48b942eedf9169c94ca8e8",
        "filename": "src/validationinterface.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 6,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/validationinterface.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/validationinterface.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b"
      },
      {
        "sha": "3a5fed0106e5b4252930296c94fc4f9246e30ef2",
        "filename": "src/validationinterface.h",
        "status": "modified",
        "additions": 13,
        "deletions": 2,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/validationinterface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/validationinterface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b"
      },
      {
        "sha": "e3ec078173408b1e835fc605a00126606f78d6d0",
        "filename": "src/versionbits.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/versionbits.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/versionbits.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/versionbits.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b"
      },
      {
        "sha": "8962a65057dcab89af3dbd7da99078c1a0c71134",
        "filename": "src/versionbits.h",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/versionbits.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/versionbits.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/versionbits.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b"
      },
      {
        "sha": "2f08162ee49bb6b883a434a6bc8a181ee897a129",
        "filename": "src/wallet/coincontrol.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/wallet/coincontrol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/wallet/coincontrol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coincontrol.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b"
      },
      {
        "sha": "a403411e5bda6ce6658e93cddae446cbaa01800e",
        "filename": "src/wallet/coinselection.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/wallet/coinselection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/wallet/coinselection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coinselection.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b"
      },
      {
        "sha": "2b185879c6ce277e70b4d4a125d2b77a5a7a0b59",
        "filename": "src/wallet/coinselection.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/wallet/coinselection.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/wallet/coinselection.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coinselection.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b"
      },
      {
        "sha": "4c0c8ff5ec2035556a310561b695315e8b03eefa",
        "filename": "src/wallet/crypter.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/wallet/crypter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/wallet/crypter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/crypter.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b"
      },
      {
        "sha": "10a06e4b9a61ba183a5948dc76153990292b03d2",
        "filename": "src/wallet/db.cpp",
        "status": "modified",
        "additions": 75,
        "deletions": 76,
        "changes": 151,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/wallet/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/wallet/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b"
      },
      {
        "sha": "5e61280f7a7ba690c239259b420f5a8962f7b64e",
        "filename": "src/wallet/db.h",
        "status": "modified",
        "additions": 27,
        "deletions": 26,
        "changes": 53,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/wallet/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/wallet/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b"
      },
      {
        "sha": "4d70dde72a173c63b3fcd9ace75eaf2e97e43908",
        "filename": "src/wallet/feebumper.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/wallet/feebumper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/wallet/feebumper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/feebumper.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b"
      },
      {
        "sha": "8d576a6689efa4100c6ecc61b0a9e5fdd6820c0c",
        "filename": "src/wallet/fees.cpp",
        "status": "modified",
        "additions": 21,
        "deletions": 21,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/wallet/fees.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/wallet/fees.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/fees.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b"
      },
      {
        "sha": "b3cd064abc230486f83d0076282f5c617123b903",
        "filename": "src/wallet/fees.h",
        "status": "modified",
        "additions": 9,
        "deletions": 8,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/wallet/fees.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/wallet/fees.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/fees.h?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b"
      },
      {
        "sha": "6c5522e4bc0376e196cc352f4119a5384ffbb920",
        "filename": "src/wallet/init.cpp",
        "status": "modified",
        "additions": 94,
        "deletions": 115,
        "changes": 209,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/wallet/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b/src/wallet/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/init.cpp?ref=ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b"
      },
      {
        "sha": "0b3ee2dda260d5b525af995c9c089c7ef3d7888c",
        "filename": "src/wallet/init.h",
        "status": "removed",
        "additions": 0,
        "deletions": 43,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7466a26cab5d66665991433947964a638f5b957e/src/wallet/init.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7466a26cab5d66665991433947964a638f5b957e/src/wallet/init.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/init.h?ref=7466a26cab5d66665991433947964a638f5b957e"
      }
    ]
  },
  {
    "sha": "efbd97e586655025cf9bad9081d6a2bd09b4dd9e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplZmJkOTdlNTg2NjU1MDI1Y2Y5YmFkOTA4MWQ2YTJiZDA5YjRkZDll",
    "commit": {
      "author": {
        "name": "leiyong",
        "email": "leiyong@gwecom.com",
        "date": "2018-05-10T04:03:03Z"
      },
      "committer": {
        "name": "leiyong",
        "email": "leiyong@gwecom.com",
        "date": "2018-05-10T04:03:03Z"
      },
      "message": "import proj in qt",
      "tree": {
        "sha": "3c9cb99b0bd2b47dad997b774e691b9ea395d298",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3c9cb99b0bd2b47dad997b774e691b9ea395d298"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/efbd97e586655025cf9bad9081d6a2bd09b4dd9e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/efbd97e586655025cf9bad9081d6a2bd09b4dd9e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/efbd97e586655025cf9bad9081d6a2bd09b4dd9e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/efbd97e586655025cf9bad9081d6a2bd09b4dd9e/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ca91d3ff8acfdb3b8dca61c088bffc6f9a72841b"
      }
    ],
    "stats": {
      "total": 707,
      "additions": 707,
      "deletions": 0
    },
    "files": [
      {
        "sha": "e0284f42573a21b9d3f32775068f4dc233bf1c27",
        "filename": "bitcoin.config",
        "status": "added",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/efbd97e586655025cf9bad9081d6a2bd09b4dd9e/bitcoin.config",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/efbd97e586655025cf9bad9081d6a2bd09b4dd9e/bitcoin.config",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/bitcoin.config?ref=efbd97e586655025cf9bad9081d6a2bd09b4dd9e",
        "patch": "@@ -0,0 +1,2 @@\n+// Add predefined macros for your project here. For example:\n+// #define THE_ANSWER 42"
      },
      {
        "sha": "e94cbbd3027df32cb00f4fca093d5c72d9696a85",
        "filename": "bitcoin.creator",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/efbd97e586655025cf9bad9081d6a2bd09b4dd9e/bitcoin.creator",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/efbd97e586655025cf9bad9081d6a2bd09b4dd9e/bitcoin.creator",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/bitcoin.creator?ref=efbd97e586655025cf9bad9081d6a2bd09b4dd9e",
        "patch": "@@ -0,0 +1 @@\n+[General]"
      },
      {
        "sha": "33c23b8d1dc0f3301c4d236b8e3acf17475e12d6",
        "filename": "bitcoin.files",
        "status": "added",
        "additions": 669,
        "deletions": 0,
        "changes": 669,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/efbd97e586655025cf9bad9081d6a2bd09b4dd9e/bitcoin.files",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/efbd97e586655025cf9bad9081d6a2bd09b4dd9e/bitcoin.files",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/bitcoin.files?ref=efbd97e586655025cf9bad9081d6a2bd09b4dd9e",
        "patch": "@@ -0,0 +1,669 @@\n+src/addrdb.cpp\n+src/addrdb.h\n+src/addrman.cpp\n+src/addrman.h\n+src/amount.h\n+src/arith_uint256.cpp\n+src/arith_uint256.h\n+src/base58.cpp\n+src/base58.h\n+src/bech32.cpp\n+src/bech32.h\n+src/bench/Examples.cpp\n+src/bench/base58.cpp\n+src/bench/bench.cpp\n+src/bench/bench.h\n+src/bench/bench_bitcoin.cpp\n+src/bench/ccoins_caching.cpp\n+src/bench/checkblock.cpp\n+src/bench/checkqueue.cpp\n+src/bench/coin_selection.cpp\n+src/bench/crypto_hash.cpp\n+src/bench/lockedpool.cpp\n+src/bench/mempool_eviction.cpp\n+src/bench/prevector.cpp\n+src/bench/rollingbloom.cpp\n+src/bench/verify_script.cpp\n+src/bitcoin-cli.cpp\n+src/bitcoin-tx.cpp\n+src/bitcoind.cpp\n+src/blockencodings.cpp\n+src/blockencodings.h\n+src/bloom.cpp\n+src/bloom.h\n+src/chain.cpp\n+src/chain.h\n+src/chainparams.cpp\n+src/chainparams.h\n+src/chainparamsbase.cpp\n+src/chainparamsbase.h\n+src/chainparamsseeds.h\n+src/checkpoints.cpp\n+src/checkpoints.h\n+src/checkqueue.h\n+src/clientversion.cpp\n+src/clientversion.h\n+src/coins.cpp\n+src/coins.h\n+src/compat.h\n+src/compat/byteswap.h\n+src/compat/endian.h\n+src/compat/glibc_compat.cpp\n+src/compat/glibc_sanity.cpp\n+src/compat/glibcxx_sanity.cpp\n+src/compat/sanity.h\n+src/compat/strnlen.cpp\n+src/compressor.cpp\n+src/compressor.h\n+src/consensus/consensus.h\n+src/consensus/merkle.cpp\n+src/consensus/merkle.h\n+src/consensus/params.h\n+src/consensus/tx_verify.cpp\n+src/consensus/tx_verify.h\n+src/consensus/validation.h\n+src/core_io.h\n+src/core_memusage.h\n+src/core_read.cpp\n+src/core_write.cpp\n+src/crypto/aes.cpp\n+src/crypto/aes.h\n+src/crypto/chacha20.cpp\n+src/crypto/chacha20.h\n+src/crypto/common.h\n+src/crypto/ctaes/bench.c\n+src/crypto/ctaes/ctaes.c\n+src/crypto/ctaes/ctaes.h\n+src/crypto/ctaes/test.c\n+src/crypto/hmac_sha256.cpp\n+src/crypto/hmac_sha256.h\n+src/crypto/hmac_sha512.cpp\n+src/crypto/hmac_sha512.h\n+src/crypto/ripemd160.cpp\n+src/crypto/ripemd160.h\n+src/crypto/sha1.cpp\n+src/crypto/sha1.h\n+src/crypto/sha256.cpp\n+src/crypto/sha256.h\n+src/crypto/sha256_sse4.cpp\n+src/crypto/sha512.cpp\n+src/crypto/sha512.h\n+src/cuckoocache.h\n+src/dbwrapper.cpp\n+src/dbwrapper.h\n+src/fs.cpp\n+src/fs.h\n+src/hash.cpp\n+src/hash.h\n+src/httprpc.cpp\n+src/httprpc.h\n+src/httpserver.cpp\n+src/httpserver.h\n+src/index/txindex.cpp\n+src/index/txindex.h\n+src/indirectmap.h\n+src/init.cpp\n+src/init.h\n+src/interfaces/handler.cpp\n+src/interfaces/handler.h\n+src/interfaces/node.cpp\n+src/interfaces/node.h\n+src/interfaces/wallet.cpp\n+src/interfaces/wallet.h\n+src/key.cpp\n+src/key.h\n+src/key_io.cpp\n+src/key_io.h\n+src/keystore.cpp\n+src/keystore.h\n+src/leveldb/db/autocompact_test.cc\n+src/leveldb/db/builder.cc\n+src/leveldb/db/builder.h\n+src/leveldb/db/c.cc\n+src/leveldb/db/c_test.c\n+src/leveldb/db/corruption_test.cc\n+src/leveldb/db/db_bench.cc\n+src/leveldb/db/db_impl.cc\n+src/leveldb/db/db_impl.h\n+src/leveldb/db/db_iter.cc\n+src/leveldb/db/db_iter.h\n+src/leveldb/db/db_test.cc\n+src/leveldb/db/dbformat.cc\n+src/leveldb/db/dbformat.h\n+src/leveldb/db/dbformat_test.cc\n+src/leveldb/db/dumpfile.cc\n+src/leveldb/db/fault_injection_test.cc\n+src/leveldb/db/filename.cc\n+src/leveldb/db/filename.h\n+src/leveldb/db/filename_test.cc\n+src/leveldb/db/leveldbutil.cc\n+src/leveldb/db/log_format.h\n+src/leveldb/db/log_reader.cc\n+src/leveldb/db/log_reader.h\n+src/leveldb/db/log_test.cc\n+src/leveldb/db/log_writer.cc\n+src/leveldb/db/log_writer.h\n+src/leveldb/db/memtable.cc\n+src/leveldb/db/memtable.h\n+src/leveldb/db/recovery_test.cc\n+src/leveldb/db/repair.cc\n+src/leveldb/db/skiplist.h\n+src/leveldb/db/skiplist_test.cc\n+src/leveldb/db/snapshot.h\n+src/leveldb/db/table_cache.cc\n+src/leveldb/db/table_cache.h\n+src/leveldb/db/version_edit.cc\n+src/leveldb/db/version_edit.h\n+src/leveldb/db/version_edit_test.cc\n+src/leveldb/db/version_set.cc\n+src/leveldb/db/version_set.h\n+src/leveldb/db/version_set_test.cc\n+src/leveldb/db/write_batch.cc\n+src/leveldb/db/write_batch_internal.h\n+src/leveldb/db/write_batch_test.cc\n+src/leveldb/doc/bench/db_bench_sqlite3.cc\n+src/leveldb/doc/bench/db_bench_tree_db.cc\n+src/leveldb/helpers/memenv/memenv.cc\n+src/leveldb/helpers/memenv/memenv.h\n+src/leveldb/helpers/memenv/memenv_test.cc\n+src/leveldb/include/leveldb/c.h\n+src/leveldb/include/leveldb/cache.h\n+src/leveldb/include/leveldb/comparator.h\n+src/leveldb/include/leveldb/db.h\n+src/leveldb/include/leveldb/dumpfile.h\n+src/leveldb/include/leveldb/env.h\n+src/leveldb/include/leveldb/filter_policy.h\n+src/leveldb/include/leveldb/iterator.h\n+src/leveldb/include/leveldb/options.h\n+src/leveldb/include/leveldb/slice.h\n+src/leveldb/include/leveldb/status.h\n+src/leveldb/include/leveldb/table.h\n+src/leveldb/include/leveldb/table_builder.h\n+src/leveldb/include/leveldb/write_batch.h\n+src/leveldb/issues/issue178_test.cc\n+src/leveldb/issues/issue200_test.cc\n+src/leveldb/port/atomic_pointer.h\n+src/leveldb/port/port.h\n+src/leveldb/port/port_example.h\n+src/leveldb/port/port_posix.cc\n+src/leveldb/port/port_posix.h\n+src/leveldb/port/port_posix_sse.cc\n+src/leveldb/port/port_win.cc\n+src/leveldb/port/port_win.h\n+src/leveldb/port/thread_annotations.h\n+src/leveldb/port/win/stdint.h\n+src/leveldb/table/block.cc\n+src/leveldb/table/block.h\n+src/leveldb/table/block_builder.cc\n+src/leveldb/table/block_builder.h\n+src/leveldb/table/filter_block.cc\n+src/leveldb/table/filter_block.h\n+src/leveldb/table/filter_block_test.cc\n+src/leveldb/table/format.cc\n+src/leveldb/table/format.h\n+src/leveldb/table/iterator.cc\n+src/leveldb/table/iterator_wrapper.h\n+src/leveldb/table/merger.cc\n+src/leveldb/table/merger.h\n+src/leveldb/table/table.cc\n+src/leveldb/table/table_builder.cc\n+src/leveldb/table/table_test.cc\n+src/leveldb/table/two_level_iterator.cc\n+src/leveldb/table/two_level_iterator.h\n+src/leveldb/util/arena.cc\n+src/leveldb/util/arena.h\n+src/leveldb/util/arena_test.cc\n+src/leveldb/util/bloom.cc\n+src/leveldb/util/bloom_test.cc\n+src/leveldb/util/cache.cc\n+src/leveldb/util/cache_test.cc\n+src/leveldb/util/coding.cc\n+src/leveldb/util/coding.h\n+src/leveldb/util/coding_test.cc\n+src/leveldb/util/comparator.cc\n+src/leveldb/util/crc32c.cc\n+src/leveldb/util/crc32c.h\n+src/leveldb/util/crc32c_test.cc\n+src/leveldb/util/env.cc\n+src/leveldb/util/env_posix.cc\n+src/leveldb/util/env_posix_test.cc\n+src/leveldb/util/env_posix_test_helper.h\n+src/leveldb/util/env_test.cc\n+src/leveldb/util/env_win.cc\n+src/leveldb/util/filter_policy.cc\n+src/leveldb/util/hash.cc\n+src/leveldb/util/hash.h\n+src/leveldb/util/hash_test.cc\n+src/leveldb/util/histogram.cc\n+src/leveldb/util/histogram.h\n+src/leveldb/util/logging.cc\n+src/leveldb/util/logging.h\n+src/leveldb/util/mutexlock.h\n+src/leveldb/util/options.cc\n+src/leveldb/util/posix_logger.h\n+src/leveldb/util/random.h\n+src/leveldb/util/status.cc\n+src/leveldb/util/testharness.cc\n+src/leveldb/util/testharness.h\n+src/leveldb/util/testutil.cc\n+src/leveldb/util/testutil.h\n+src/limitedmap.h\n+src/logging.cpp\n+src/logging.h\n+src/memusage.h\n+src/merkleblock.cpp\n+src/merkleblock.h\n+src/miner.cpp\n+src/miner.h\n+src/net.cpp\n+src/net.h\n+src/net_processing.cpp\n+src/net_processing.h\n+src/netaddress.cpp\n+src/netaddress.h\n+src/netbase.cpp\n+src/netbase.h\n+src/netmessagemaker.h\n+src/noui.cpp\n+src/noui.h\n+src/policy/feerate.cpp\n+src/policy/feerate.h\n+src/policy/fees.cpp\n+src/policy/fees.h\n+src/policy/policy.cpp\n+src/policy/policy.h\n+src/policy/rbf.cpp\n+src/policy/rbf.h\n+src/pow.cpp\n+src/pow.h\n+src/prevector.h\n+src/primitives/block.cpp\n+src/primitives/block.h\n+src/primitives/transaction.cpp\n+src/primitives/transaction.h\n+src/protocol.cpp\n+src/protocol.h\n+src/pubkey.cpp\n+src/pubkey.h\n+src/qt/addressbookpage.cpp\n+src/qt/addressbookpage.h\n+src/qt/addresstablemodel.cpp\n+src/qt/addresstablemodel.h\n+src/qt/askpassphrasedialog.cpp\n+src/qt/askpassphrasedialog.h\n+src/qt/bantablemodel.cpp\n+src/qt/bantablemodel.h\n+src/qt/bitcoin.cpp\n+src/qt/bitcoinaddressvalidator.cpp\n+src/qt/bitcoinaddressvalidator.h\n+src/qt/bitcoinamountfield.cpp\n+src/qt/bitcoinamountfield.h\n+src/qt/bitcoingui.cpp\n+src/qt/bitcoingui.h\n+src/qt/bitcoinstrings.cpp\n+src/qt/bitcoinunits.cpp\n+src/qt/bitcoinunits.h\n+src/qt/callback.h\n+src/qt/clientmodel.cpp\n+src/qt/clientmodel.h\n+src/qt/coincontroldialog.cpp\n+src/qt/coincontroldialog.h\n+src/qt/coincontroltreewidget.cpp\n+src/qt/coincontroltreewidget.h\n+src/qt/csvmodelwriter.cpp\n+src/qt/csvmodelwriter.h\n+src/qt/editaddressdialog.cpp\n+src/qt/editaddressdialog.h\n+src/qt/guiconstants.h\n+src/qt/guiutil.cpp\n+src/qt/guiutil.h\n+src/qt/intro.cpp\n+src/qt/intro.h\n+src/qt/macdockiconhandler.h\n+src/qt/macnotificationhandler.h\n+src/qt/modaloverlay.cpp\n+src/qt/modaloverlay.h\n+src/qt/networkstyle.cpp\n+src/qt/networkstyle.h\n+src/qt/notificator.cpp\n+src/qt/notificator.h\n+src/qt/openuridialog.cpp\n+src/qt/openuridialog.h\n+src/qt/optionsdialog.cpp\n+src/qt/optionsdialog.h\n+src/qt/optionsmodel.cpp\n+src/qt/optionsmodel.h\n+src/qt/overviewpage.cpp\n+src/qt/overviewpage.h\n+src/qt/paymentrequestplus.cpp\n+src/qt/paymentrequestplus.h\n+src/qt/paymentserver.cpp\n+src/qt/paymentserver.h\n+src/qt/peertablemodel.cpp\n+src/qt/peertablemodel.h\n+src/qt/platformstyle.cpp\n+src/qt/platformstyle.h\n+src/qt/qvalidatedlineedit.cpp\n+src/qt/qvalidatedlineedit.h\n+src/qt/qvaluecombobox.cpp\n+src/qt/qvaluecombobox.h\n+src/qt/receivecoinsdialog.cpp\n+src/qt/receivecoinsdialog.h\n+src/qt/receiverequestdialog.cpp\n+src/qt/receiverequestdialog.h\n+src/qt/recentrequeststablemodel.cpp\n+src/qt/recentrequeststablemodel.h\n+src/qt/rpcconsole.cpp\n+src/qt/rpcconsole.h\n+src/qt/sendcoinsdialog.cpp\n+src/qt/sendcoinsdialog.h\n+src/qt/sendcoinsentry.cpp\n+src/qt/sendcoinsentry.h\n+src/qt/signverifymessagedialog.cpp\n+src/qt/signverifymessagedialog.h\n+src/qt/splashscreen.cpp\n+src/qt/splashscreen.h\n+src/qt/test/addressbooktests.cpp\n+src/qt/test/addressbooktests.h\n+src/qt/test/compattests.cpp\n+src/qt/test/compattests.h\n+src/qt/test/paymentrequestdata.h\n+src/qt/test/paymentservertests.cpp\n+src/qt/test/paymentservertests.h\n+src/qt/test/rpcnestedtests.cpp\n+src/qt/test/rpcnestedtests.h\n+src/qt/test/test_main.cpp\n+src/qt/test/uritests.cpp\n+src/qt/test/uritests.h\n+src/qt/test/util.cpp\n+src/qt/test/util.h\n+src/qt/test/wallettests.cpp\n+src/qt/test/wallettests.h\n+src/qt/trafficgraphwidget.cpp\n+src/qt/trafficgraphwidget.h\n+src/qt/transactiondesc.cpp\n+src/qt/transactiondesc.h\n+src/qt/transactiondescdialog.cpp\n+src/qt/transactiondescdialog.h\n+src/qt/transactionfilterproxy.cpp\n+src/qt/transactionfilterproxy.h\n+src/qt/transactionrecord.cpp\n+src/qt/transactionrecord.h\n+src/qt/transactiontablemodel.cpp\n+src/qt/transactiontablemodel.h\n+src/qt/transactionview.cpp\n+src/qt/transactionview.h\n+src/qt/utilitydialog.cpp\n+src/qt/utilitydialog.h\n+src/qt/walletframe.cpp\n+src/qt/walletframe.h\n+src/qt/walletmodel.cpp\n+src/qt/walletmodel.h\n+src/qt/walletmodeltransaction.cpp\n+src/qt/walletmodeltransaction.h\n+src/qt/walletview.cpp\n+src/qt/walletview.h\n+src/qt/winshutdownmonitor.cpp\n+src/qt/winshutdownmonitor.h\n+src/random.cpp\n+src/random.h\n+src/rest.cpp\n+src/reverse_iterator.h\n+src/reverselock.h\n+src/rpc/blockchain.cpp\n+src/rpc/blockchain.h\n+src/rpc/client.cpp\n+src/rpc/client.h\n+src/rpc/mining.cpp\n+src/rpc/mining.h\n+src/rpc/misc.cpp\n+src/rpc/net.cpp\n+src/rpc/protocol.cpp\n+src/rpc/protocol.h\n+src/rpc/rawtransaction.cpp\n+src/rpc/rawtransaction.h\n+src/rpc/register.h\n+src/rpc/server.cpp\n+src/rpc/server.h\n+src/rpc/util.cpp\n+src/rpc/util.h\n+src/scheduler.cpp\n+src/scheduler.h\n+src/script/bitcoinconsensus.cpp\n+src/script/bitcoinconsensus.h\n+src/script/interpreter.cpp\n+src/script/interpreter.h\n+src/script/ismine.cpp\n+src/script/ismine.h\n+src/script/script.cpp\n+src/script/script.h\n+src/script/script_error.cpp\n+src/script/script_error.h\n+src/script/sigcache.cpp\n+src/script/sigcache.h\n+src/script/sign.cpp\n+src/script/sign.h\n+src/script/standard.cpp\n+src/script/standard.h\n+src/secp256k1/contrib/lax_der_parsing.c\n+src/secp256k1/contrib/lax_der_parsing.h\n+src/secp256k1/contrib/lax_der_privatekey_parsing.c\n+src/secp256k1/contrib/lax_der_privatekey_parsing.h\n+src/secp256k1/include/secp256k1.h\n+src/secp256k1/include/secp256k1_ecdh.h\n+src/secp256k1/include/secp256k1_recovery.h\n+src/secp256k1/src/basic-config.h\n+src/secp256k1/src/bench.h\n+src/secp256k1/src/bench_ecdh.c\n+src/secp256k1/src/bench_internal.c\n+src/secp256k1/src/bench_recover.c\n+src/secp256k1/src/bench_sign.c\n+src/secp256k1/src/bench_verify.c\n+src/secp256k1/src/ecdsa.h\n+src/secp256k1/src/ecdsa_impl.h\n+src/secp256k1/src/eckey.h\n+src/secp256k1/src/eckey_impl.h\n+src/secp256k1/src/ecmult.h\n+src/secp256k1/src/ecmult_const.h\n+src/secp256k1/src/ecmult_const_impl.h\n+src/secp256k1/src/ecmult_gen.h\n+src/secp256k1/src/ecmult_gen_impl.h\n+src/secp256k1/src/ecmult_impl.h\n+src/secp256k1/src/field.h\n+src/secp256k1/src/field_10x26.h\n+src/secp256k1/src/field_10x26_impl.h\n+src/secp256k1/src/field_5x52.h\n+src/secp256k1/src/field_5x52_asm_impl.h\n+src/secp256k1/src/field_5x52_impl.h\n+src/secp256k1/src/field_5x52_int128_impl.h\n+src/secp256k1/src/field_impl.h\n+src/secp256k1/src/gen_context.c\n+src/secp256k1/src/group.h\n+src/secp256k1/src/group_impl.h\n+src/secp256k1/src/hash.h\n+src/secp256k1/src/hash_impl.h\n+src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c\n+src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.h\n+src/secp256k1/src/java/org_bitcoin_Secp256k1Context.c\n+src/secp256k1/src/java/org_bitcoin_Secp256k1Context.h\n+src/secp256k1/src/modules/ecdh/main_impl.h\n+src/secp256k1/src/modules/ecdh/tests_impl.h\n+src/secp256k1/src/modules/recovery/main_impl.h\n+src/secp256k1/src/modules/recovery/tests_impl.h\n+src/secp256k1/src/num.h\n+src/secp256k1/src/num_gmp.h\n+src/secp256k1/src/num_gmp_impl.h\n+src/secp256k1/src/num_impl.h\n+src/secp256k1/src/scalar.h\n+src/secp256k1/src/scalar_4x64.h\n+src/secp256k1/src/scalar_4x64_impl.h\n+src/secp256k1/src/scalar_8x32.h\n+src/secp256k1/src/scalar_8x32_impl.h\n+src/secp256k1/src/scalar_impl.h\n+src/secp256k1/src/scalar_low.h\n+src/secp256k1/src/scalar_low_impl.h\n+src/secp256k1/src/secp256k1.c\n+src/secp256k1/src/testrand.h\n+src/secp256k1/src/testrand_impl.h\n+src/secp256k1/src/tests.c\n+src/secp256k1/src/tests_exhaustive.c\n+src/secp256k1/src/util.h\n+src/serialize.h\n+src/span.h\n+src/streams.h\n+src/support/allocators/secure.h\n+src/support/allocators/zeroafterfree.h\n+src/support/cleanse.cpp\n+src/support/cleanse.h\n+src/support/events.h\n+src/support/lockedpool.cpp\n+src/support/lockedpool.h\n+src/sync.cpp\n+src/sync.h\n+src/test/DoS_tests.cpp\n+src/test/addrman_tests.cpp\n+src/test/allocator_tests.cpp\n+src/test/amount_tests.cpp\n+src/test/arith_uint256_tests.cpp\n+src/test/base32_tests.cpp\n+src/test/base58_tests.cpp\n+src/test/base64_tests.cpp\n+src/test/bech32_tests.cpp\n+src/test/bip32_tests.cpp\n+src/test/blockchain_tests.cpp\n+src/test/blockencodings_tests.cpp\n+src/test/bloom_tests.cpp\n+src/test/bswap_tests.cpp\n+src/test/checkqueue_tests.cpp\n+src/test/coins_tests.cpp\n+src/test/compress_tests.cpp\n+src/test/crypto_tests.cpp\n+src/test/cuckoocache_tests.cpp\n+src/test/dbwrapper_tests.cpp\n+src/test/getarg_tests.cpp\n+src/test/hash_tests.cpp\n+src/test/key_io_tests.cpp\n+src/test/key_tests.cpp\n+src/test/limitedmap_tests.cpp\n+src/test/main_tests.cpp\n+src/test/mempool_tests.cpp\n+src/test/merkle_tests.cpp\n+src/test/merkleblock_tests.cpp\n+src/test/miner_tests.cpp\n+src/test/multisig_tests.cpp\n+src/test/net_tests.cpp\n+src/test/netbase_tests.cpp\n+src/test/pmt_tests.cpp\n+src/test/policyestimator_tests.cpp\n+src/test/pow_tests.cpp\n+src/test/prevector_tests.cpp\n+src/test/raii_event_tests.cpp\n+src/test/random_tests.cpp\n+src/test/reverselock_tests.cpp\n+src/test/rpc_tests.cpp\n+src/test/sanity_tests.cpp\n+src/test/scheduler_tests.cpp\n+src/test/script_P2SH_tests.cpp\n+src/test/script_standard_tests.cpp\n+src/test/script_tests.cpp\n+src/test/scriptnum10.h\n+src/test/scriptnum_tests.cpp\n+src/test/serialize_tests.cpp\n+src/test/sighash_tests.cpp\n+src/test/sigopcount_tests.cpp\n+src/test/skiplist_tests.cpp\n+src/test/streams_tests.cpp\n+src/test/test_bitcoin.cpp\n+src/test/test_bitcoin.h\n+src/test/test_bitcoin_fuzzy.cpp\n+src/test/test_bitcoin_main.cpp\n+src/test/timedata_tests.cpp\n+src/test/torcontrol_tests.cpp\n+src/test/transaction_tests.cpp\n+src/test/txindex_tests.cpp\n+src/test/txvalidation_tests.cpp\n+src/test/txvalidationcache_tests.cpp\n+src/test/uint256_tests.cpp\n+src/test/util_tests.cpp\n+src/test/versionbits_tests.cpp\n+src/threadinterrupt.cpp\n+src/threadinterrupt.h\n+src/threadsafety.h\n+src/timedata.cpp\n+src/timedata.h\n+src/tinyformat.h\n+src/torcontrol.cpp\n+src/torcontrol.h\n+src/txdb.cpp\n+src/txdb.h\n+src/txmempool.cpp\n+src/txmempool.h\n+src/ui_interface.cpp\n+src/ui_interface.h\n+src/uint256.cpp\n+src/uint256.h\n+src/undo.h\n+src/univalue/gen/gen.cpp\n+src/univalue/include/univalue.h\n+src/univalue/lib/univalue.cpp\n+src/univalue/lib/univalue_escapes.h\n+src/univalue/lib/univalue_get.cpp\n+src/univalue/lib/univalue_read.cpp\n+src/univalue/lib/univalue_utffilter.h\n+src/univalue/lib/univalue_write.cpp\n+src/univalue/test/no_nul.cpp\n+src/univalue/test/object.cpp\n+src/univalue/test/test_json.cpp\n+src/univalue/test/unitester.cpp\n+src/util.cpp\n+src/util.h\n+src/utilmoneystr.cpp\n+src/utilmoneystr.h\n+src/utilstrencodings.cpp\n+src/utilstrencodings.h\n+src/utiltime.cpp\n+src/utiltime.h\n+src/validation.cpp\n+src/validation.h\n+src/validationinterface.cpp\n+src/validationinterface.h\n+src/version.h\n+src/versionbits.cpp\n+src/versionbits.h\n+src/wallet/coincontrol.h\n+src/wallet/coinselection.cpp\n+src/wallet/coinselection.h\n+src/wallet/crypter.cpp\n+src/wallet/crypter.h\n+src/wallet/db.cpp\n+src/wallet/db.h\n+src/wallet/feebumper.cpp\n+src/wallet/feebumper.h\n+src/wallet/fees.cpp\n+src/wallet/fees.h\n+src/wallet/init.cpp\n+src/wallet/rpcdump.cpp\n+src/wallet/rpcwallet.cpp\n+src/wallet/rpcwallet.h\n+src/wallet/test/accounting_tests.cpp\n+src/wallet/test/coinselector_tests.cpp\n+src/wallet/test/wallet_crypto_tests.cpp\n+src/wallet/test/wallet_test_fixture.cpp\n+src/wallet/test/wallet_test_fixture.h\n+src/wallet/test/wallet_tests.cpp\n+src/wallet/wallet.cpp\n+src/wallet/wallet.h\n+src/wallet/walletdb.cpp\n+src/wallet/walletdb.h\n+src/wallet/walletutil.cpp\n+src/wallet/walletutil.h\n+src/walletinitinterface.h\n+src/warnings.cpp\n+src/warnings.h\n+src/zmq/zmqabstractnotifier.cpp\n+src/zmq/zmqabstractnotifier.h\n+src/zmq/zmqconfig.h\n+src/zmq/zmqnotificationinterface.cpp\n+src/zmq/zmqnotificationinterface.h\n+src/zmq/zmqpublishnotifier.cpp\n+src/zmq/zmqpublishnotifier.h"
      },
      {
        "sha": "597aa53fa0be41cfaec35fa4fb1c19cf566003aa",
        "filename": "bitcoin.includes",
        "status": "added",
        "additions": 35,
        "deletions": 0,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/efbd97e586655025cf9bad9081d6a2bd09b4dd9e/bitcoin.includes",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/efbd97e586655025cf9bad9081d6a2bd09b4dd9e/bitcoin.includes",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/bitcoin.includes?ref=efbd97e586655025cf9bad9081d6a2bd09b4dd9e",
        "patch": "@@ -0,0 +1,35 @@\n+src\n+src/bench\n+src/compat\n+src/consensus\n+src/crypto\n+src/crypto/ctaes\n+src/index\n+src/interfaces\n+src/leveldb/db\n+src/leveldb/helpers/memenv\n+src/leveldb/include/leveldb\n+src/leveldb/port\n+src/leveldb/port/win\n+src/leveldb/table\n+src/leveldb/util\n+src/policy\n+src/primitives\n+src/qt\n+src/qt/test\n+src/rpc\n+src/script\n+src/secp256k1/contrib\n+src/secp256k1/include\n+src/secp256k1/src\n+src/secp256k1/src/java\n+src/secp256k1/src/modules/ecdh\n+src/secp256k1/src/modules/recovery\n+src/support\n+src/support/allocators\n+src/test\n+src/univalue/include\n+src/univalue/lib\n+src/wallet\n+src/wallet/test\n+src/zmq"
      }
    ]
  }
]