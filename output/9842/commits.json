[
  {
    "sha": "c9bd0f64212cd600daf30c9c59035bfe9f07b81b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjOWJkMGY2NDIxMmNkNjAwZGFmMzBjOWM1OTAzNWJmZTlmMDdiODFi",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-03-07T19:08:59Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-03-15T15:56:25Z"
      },
      "message": "Fix RPC failure testing (2 of 2)\n\nCommit 9db8eecac1c713c760c0217b6acb7455c657fa8b improved the\nassert_raises_jsonrpc() function for better testing of RPC failure\nmodes. This commit completes the job by removing remaining broken\ntry-except RPC testing from the individual test cases and replacing it\nwith calls to assert_raises_jsonrpc().",
      "tree": {
        "sha": "9f587fadcbbd92fb983a770af4a1cf5084bc8b01",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9f587fadcbbd92fb983a770af4a1cf5084bc8b01"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c9bd0f64212cd600daf30c9c59035bfe9f07b81b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c9bd0f64212cd600daf30c9c59035bfe9f07b81b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c9bd0f64212cd600daf30c9c59035bfe9f07b81b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c9bd0f64212cd600daf30c9c59035bfe9f07b81b/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ce01e6226ce52b88c644b0cb89852278edbdf33b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ce01e6226ce52b88c644b0cb89852278edbdf33b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ce01e6226ce52b88c644b0cb89852278edbdf33b"
      }
    ],
    "stats": {
      "total": 384,
      "additions": 119,
      "deletions": 265
    },
    "files": [
      {
        "sha": "7f13bb9952f15b9f89671c3c28518faafad55f8c",
        "filename": "qa/rpc-tests/bip65-cltv.py",
        "status": "modified",
        "additions": 2,
        "deletions": 6,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9bd0f64212cd600daf30c9c59035bfe9f07b81b/qa/rpc-tests/bip65-cltv.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9bd0f64212cd600daf30c9c59035bfe9f07b81b/qa/rpc-tests/bip65-cltv.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/bip65-cltv.py?ref=c9bd0f64212cd600daf30c9c59035bfe9f07b81b",
        "patch": "@@ -69,12 +69,8 @@ def run_test(self):\n         if (self.nodes[0].getblockcount() != cnt + 1051):\n             raise AssertionError(\"Failed to mine a version=4 block\")\n \n-        # Mine 1 old-version blocks\n-        try:\n-            self.nodes[1].generate(1)\n-            raise AssertionError(\"Succeeded to mine a version=3 block after 950 version=4 blocks\")\n-        except JSONRPCException:\n-            pass\n+        # Mine 1 old-version blocks. This should fail\n+        assert_raises_jsonrpc(-1,\"CreateNewBlock: TestBlockValidity failed: bad-version(0x00000003)\", self.nodes[1].generate, 1)\n         self.sync_all()\n         if (self.nodes[0].getblockcount() != cnt + 1051):\n             raise AssertionError(\"Accepted a version=3 block after 950 version=4 blocks\")"
      },
      {
        "sha": "3ed6ebe044df1023b7acd28e4cd73b086c75d533",
        "filename": "qa/rpc-tests/bip68-sequence.py",
        "status": "modified",
        "additions": 14,
        "deletions": 32,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9bd0f64212cd600daf30c9c59035bfe9f07b81b/qa/rpc-tests/bip68-sequence.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9bd0f64212cd600daf30c9c59035bfe9f07b81b/qa/rpc-tests/bip68-sequence.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/bip68-sequence.py?ref=c9bd0f64212cd600daf30c9c59035bfe9f07b81b",
        "patch": "@@ -90,12 +90,7 @@ def test_disable_flag(self):\n         tx2.vout = [CTxOut(int(value-self.relayfee*COIN), CScript([b'a']))]\n         tx2.rehash()\n \n-        try:\n-            self.nodes[0].sendrawtransaction(ToHex(tx2))\n-        except JSONRPCException as exp:\n-            assert_equal(exp.error[\"message\"], NOT_FINAL_ERROR)\n-        else:\n-            assert(False)\n+        assert_raises_jsonrpc(-26, NOT_FINAL_ERROR, self.nodes[0].sendrawtransaction, ToHex(tx2))\n \n         # Setting the version back down to 1 should disable the sequence lock,\n         # so this should be accepted.\n@@ -190,14 +185,12 @@ def test_sequence_lock_confirmed_inputs(self):\n             tx.vout.append(CTxOut(int(value-self.relayfee*tx_size*COIN/1000), CScript([b'a'])))\n             rawtx = self.nodes[0].signrawtransaction(ToHex(tx))[\"hex\"]\n \n-            try:\n-                self.nodes[0].sendrawtransaction(rawtx)\n-            except JSONRPCException as exp:\n-                assert(not should_pass and using_sequence_locks)\n-                assert_equal(exp.error[\"message\"], NOT_FINAL_ERROR)\n+            if (using_sequence_locks and not should_pass):\n+                # This transaction should be rejected\n+                assert_raises_jsonrpc(-26, NOT_FINAL_ERROR, self.nodes[0].sendrawtransaction, rawtx)\n             else:\n-                assert(should_pass or not using_sequence_locks)\n-                # Recalculate utxos if we successfully sent the transaction\n+                # This raw transaction should be accepted\n+                self.nodes[0].sendrawtransaction(rawtx)\n                 utxos = self.nodes[0].listunspent()\n \n     # Test that sequence locks on unconfirmed inputs must have nSequence\n@@ -239,14 +232,13 @@ def test_nonzero_locks(orig_tx, node, relayfee, use_height_lock):\n             tx.vout = [CTxOut(int(orig_tx.vout[0].nValue - relayfee*COIN), CScript([b'a']))]\n             tx.rehash()\n \n-            try:\n-                node.sendrawtransaction(ToHex(tx))\n-            except JSONRPCException as exp:\n-                assert_equal(exp.error[\"message\"], NOT_FINAL_ERROR)\n-                assert(orig_tx.hash in node.getrawmempool())\n+            if (orig_tx.hash in node.getrawmempool()):\n+                # sendrawtransaction should fail if the tx is in the mempool\n+                assert_raises_jsonrpc(-26, NOT_FINAL_ERROR, node.sendrawtransaction, ToHex(tx))\n             else:\n-                # orig_tx must not be in mempool\n-                assert(orig_tx.hash not in node.getrawmempool())\n+                # sendrawtransaction should succeed if the tx is not in the mempool\n+                node.sendrawtransaction(ToHex(tx))\n+\n             return tx\n \n         test_nonzero_locks(tx2, self.nodes[0], self.relayfee, use_height_lock=True)\n@@ -295,12 +287,7 @@ def test_nonzero_locks(orig_tx, node, relayfee, use_height_lock):\n         tx5.vout[0].nValue += int(utxos[0][\"amount\"]*COIN)\n         raw_tx5 = self.nodes[0].signrawtransaction(ToHex(tx5))[\"hex\"]\n \n-        try:\n-            self.nodes[0].sendrawtransaction(raw_tx5)\n-        except JSONRPCException as exp:\n-            assert_equal(exp.error[\"message\"], NOT_FINAL_ERROR)\n-        else:\n-            assert(False)\n+        assert_raises_jsonrpc(-26, NOT_FINAL_ERROR, self.nodes[0].sendrawtransaction, raw_tx5)\n \n         # Test mempool-BIP68 consistency after reorg\n         #\n@@ -373,12 +360,7 @@ def test_bip68_not_consensus(self):\n         tx3.vout = [CTxOut(int(tx2.vout[0].nValue - self.relayfee*COIN), CScript([b'a']))]\n         tx3.rehash()\n \n-        try:\n-            self.nodes[0].sendrawtransaction(ToHex(tx3))\n-        except JSONRPCException as exp:\n-            assert_equal(exp.error[\"message\"], NOT_FINAL_ERROR)\n-        else:\n-            assert(False)\n+        assert_raises_jsonrpc(-26, NOT_FINAL_ERROR, self.nodes[0].sendrawtransaction, ToHex(tx3))\n \n         # make a block that violates bip68; ensure that the tip updates\n         tip = int(self.nodes[0].getbestblockhash(), 16)"
      },
      {
        "sha": "371cc41bb714a08edc24784ce01f73d65cbba87a",
        "filename": "qa/rpc-tests/bipdersig.py",
        "status": "modified",
        "additions": 2,
        "deletions": 6,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9bd0f64212cd600daf30c9c59035bfe9f07b81b/qa/rpc-tests/bipdersig.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9bd0f64212cd600daf30c9c59035bfe9f07b81b/qa/rpc-tests/bipdersig.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/bipdersig.py?ref=c9bd0f64212cd600daf30c9c59035bfe9f07b81b",
        "patch": "@@ -68,12 +68,8 @@ def run_test(self):\n         if (self.nodes[0].getblockcount() != cnt + 1051):\n             raise AssertionError(\"Failed to mine a version=3 block\")\n \n-        # Mine 1 old-version blocks\n-        try:\n-            self.nodes[1].generate(1)\n-            raise AssertionError(\"Succeeded to mine a version=2 block after 950 version=3 blocks\")\n-        except JSONRPCException:\n-            pass\n+        # Mine 1 old-version blocks. This should fail\n+        assert_raises_jsonrpc(-1, \"CreateNewBlock: TestBlockValidity failed: bad-version(0x00000002)\", self.nodes[1].generate, 1)\n         self.sync_all()\n         if (self.nodes[0].getblockcount() != cnt + 1051):\n             raise AssertionError(\"Accepted a version=2 block after 950 version=3 blocks\")"
      },
      {
        "sha": "596aed50ec9cfb7fb8b604e5feb30d80dcd88fb3",
        "filename": "qa/rpc-tests/blockchain.py",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9bd0f64212cd600daf30c9c59035bfe9f07b81b/qa/rpc-tests/blockchain.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9bd0f64212cd600daf30c9c59035bfe9f07b81b/qa/rpc-tests/blockchain.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/blockchain.py?ref=c9bd0f64212cd600daf30c9c59035bfe9f07b81b",
        "patch": "@@ -14,10 +14,9 @@\n from decimal import Decimal\n \n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.authproxy import JSONRPCException\n from test_framework.util import (\n     assert_equal,\n-    assert_raises,\n+    assert_raises_jsonrpc,\n     assert_is_hex_string,\n     assert_is_hash_string,\n     start_nodes,\n@@ -58,8 +57,7 @@ def _test_gettxoutsetinfo(self):\n     def _test_getblockheader(self):\n         node = self.nodes[0]\n \n-        assert_raises(\n-            JSONRPCException, lambda: node.getblockheader('nonsense'))\n+        assert_raises_jsonrpc(-5, \"Block not found\", node.getblockheader, \"nonsense\")\n \n         besthash = node.getbestblockhash()\n         secondbesthash = node.getblockhash(199)"
      },
      {
        "sha": "2f729e19bf60518ecb1fb61df893ddee692ab2b2",
        "filename": "qa/rpc-tests/disablewallet.py",
        "status": "modified",
        "additions": 4,
        "deletions": 13,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9bd0f64212cd600daf30c9c59035bfe9f07b81b/qa/rpc-tests/disablewallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9bd0f64212cd600daf30c9c59035bfe9f07b81b/qa/rpc-tests/disablewallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/disablewallet.py?ref=c9bd0f64212cd600daf30c9c59035bfe9f07b81b",
        "patch": "@@ -30,19 +30,10 @@ def run_test (self):\n         x = self.nodes[0].validateaddress('mneYUmWYsuk7kySiURxCi3AGxrAqZxLgPZ')\n         assert(x['isvalid'] == True)\n \n-        # Checking mining to an address without a wallet\n-        try:\n-            self.nodes[0].generatetoaddress(1, 'mneYUmWYsuk7kySiURxCi3AGxrAqZxLgPZ')\n-        except JSONRPCException as e:\n-            assert(\"Invalid address\" not in e.error['message'])\n-            assert(\"ProcessNewBlock, block not accepted\" not in e.error['message'])\n-            assert(\"Couldn't create new block\" not in e.error['message'])\n-\n-        try:\n-            self.nodes[0].generatetoaddress(1, '3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy')\n-            raise AssertionError(\"Must not mine to invalid address!\")\n-        except JSONRPCException as e:\n-            assert(\"Invalid address\" in e.error['message'])\n+        # Checking mining to an address without a wallet. Generating to a valid address should succeed\n+        # but generating to an invalid address will fail.\n+        self.nodes[0].generatetoaddress(1, 'mneYUmWYsuk7kySiURxCi3AGxrAqZxLgPZ')\n+        assert_raises_jsonrpc(-5, \"Invalid address\", self.nodes[0].generatetoaddress, 1, '3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy')\n \n if __name__ == '__main__':\n     DisableWalletTest ().main ()"
      },
      {
        "sha": "67745f77d18af56f38e2bffe503f762b4b2acf8d",
        "filename": "qa/rpc-tests/getblocktemplate_proposals.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9bd0f64212cd600daf30c9c59035bfe9f07b81b/qa/rpc-tests/getblocktemplate_proposals.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9bd0f64212cd600daf30c9c59035bfe9f07b81b/qa/rpc-tests/getblocktemplate_proposals.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/getblocktemplate_proposals.py?ref=c9bd0f64212cd600daf30c9c59035bfe9f07b81b",
        "patch": "@@ -105,7 +105,7 @@ def run_test(self):\n \n         # Test 3: Truncated final tx\n         lastbyte = txlist[-1].pop()\n-        assert_raises(JSONRPCException, assert_template, node, tmpl, txlist, 'n/a')\n+        assert_raises_jsonrpc(-22, \"Block decode failed\", assert_template, node, tmpl, txlist, 'n/a')\n         txlist[-1].append(lastbyte)\n \n         # Test 4: Add an invalid tx to the end (duplicate of gen tx)\n@@ -126,7 +126,7 @@ def run_test(self):\n \n         # Test 7: Bad tx count\n         txlist.append(b'')\n-        assert_raises(JSONRPCException, assert_template, node, tmpl, txlist, 'n/a')\n+        assert_raises_jsonrpc(-22, 'Block decode failed', assert_template, node, tmpl, txlist, 'n/a')\n         txlist.pop()\n \n         # Test 8: Bad bits"
      },
      {
        "sha": "cee58563f01487f641436e58a60b35a2ceb0d89b",
        "filename": "qa/rpc-tests/keypool.py",
        "status": "modified",
        "additions": 3,
        "deletions": 15,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9bd0f64212cd600daf30c9c59035bfe9f07b81b/qa/rpc-tests/keypool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9bd0f64212cd600daf30c9c59035bfe9f07b81b/qa/rpc-tests/keypool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/keypool.py?ref=c9bd0f64212cd600daf30c9c59035bfe9f07b81b",
        "patch": "@@ -28,11 +28,7 @@ def run_test(self):\n         assert(addr_before_encrypting_data['hdmasterkeyid'] != wallet_info['hdmasterkeyid'])\n         assert(addr_data['hdmasterkeyid'] == wallet_info['hdmasterkeyid'])\n         \n-        try:\n-            addr = nodes[0].getnewaddress()\n-            raise AssertionError('Keypool should be exhausted after one address')\n-        except JSONRPCException as e:\n-            assert(e.error['code']==-12)\n+        assert_raises_jsonrpc(-12, \"Error: Keypool ran out, please call keypoolrefill first\", nodes[0].getnewaddress)\n \n         # put three new keys in the keypool\n         nodes[0].walletpassphrase('test', 12000)\n@@ -48,11 +44,7 @@ def run_test(self):\n         # assert that four unique addresses were returned\n         assert(len(addr) == 4)\n         # the next one should fail\n-        try:\n-            addr = nodes[0].getrawchangeaddress()\n-            raise AssertionError('Keypool should be exhausted after three addresses')\n-        except JSONRPCException as e:\n-            assert(e.error['code']==-12)\n+        assert_raises_jsonrpc(-12, \"Keypool ran out\", nodes[0].getrawchangeaddress)\n \n         # refill keypool with three new addresses\n         nodes[0].walletpassphrase('test', 1)\n@@ -66,11 +58,7 @@ def run_test(self):\n         nodes[0].generate(1)\n         nodes[0].generate(1)\n         nodes[0].generate(1)\n-        try:\n-            nodes[0].generate(1)\n-            raise AssertionError('Keypool should be exhausted after three addesses')\n-        except JSONRPCException as e:\n-            assert(e.error['code']==-12)\n+        assert_raises_jsonrpc(-12, \"Keypool ran out\", nodes[0].generate, 1)\n \n     def __init__(self):\n         super().__init__()"
      },
      {
        "sha": "17e3a9a967c82d2d88a9c1016cb2f0aa6b6ed89f",
        "filename": "qa/rpc-tests/mempool_packages.py",
        "status": "modified",
        "additions": 13,
        "deletions": 16,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9bd0f64212cd600daf30c9c59035bfe9f07b81b/qa/rpc-tests/mempool_packages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9bd0f64212cd600daf30c9c59035bfe9f07b81b/qa/rpc-tests/mempool_packages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/mempool_packages.py?ref=c9bd0f64212cd600daf30c9c59035bfe9f07b81b",
        "patch": "@@ -112,10 +112,7 @@ def run_test(self):\n             assert_equal(mempool[x]['descendantfees'], descendant_fees * COIN + 1000)\n \n         # Adding one more transaction on to the chain should fail.\n-        try:\n-            self.chain_transaction(self.nodes[0], txid, vout, value, fee, 1)\n-        except JSONRPCException as e:\n-            self.log.info(\"too-long-ancestor-chain successfully rejected\")\n+        assert_raises_jsonrpc(-26, \"too-long-mempool-chain\", self.chain_transaction, self.nodes[0], txid, vout, value, fee, 1)\n \n         # Check that prioritising a tx before it's added to the mempool works\n         # First clear the mempool by mining a block.\n@@ -155,19 +152,19 @@ def run_test(self):\n         for i in range(10):\n             transaction_package.append({'txid': txid, 'vout': i, 'amount': sent_value})\n \n-        for i in range(MAX_DESCENDANTS):\n+        # Sign and send up to MAX_DESCENDANT transactions chained off the parent tx\n+        for i in range(MAX_DESCENDANTS - 1):\n             utxo = transaction_package.pop(0)\n-            try:\n-                (txid, sent_value) = self.chain_transaction(self.nodes[0], utxo['txid'], utxo['vout'], utxo['amount'], fee, 10)\n-                for j in range(10):\n-                    transaction_package.append({'txid': txid, 'vout': j, 'amount': sent_value})\n-                if i == MAX_DESCENDANTS - 2:\n-                    mempool = self.nodes[0].getrawmempool(True)\n-                    assert_equal(mempool[parent_transaction]['descendantcount'], MAX_DESCENDANTS)\n-            except JSONRPCException as e:\n-                self.log.info(e.error['message'])\n-                assert_equal(i, MAX_DESCENDANTS - 1)\n-                self.log.info(\"tx that would create too large descendant package successfully rejected\")\n+            (txid, sent_value) = self.chain_transaction(self.nodes[0], utxo['txid'], utxo['vout'], utxo['amount'], fee, 10)\n+            for j in range(10):\n+                transaction_package.append({'txid': txid, 'vout': j, 'amount': sent_value})\n+\n+        mempool = self.nodes[0].getrawmempool(True)\n+        assert_equal(mempool[parent_transaction]['descendantcount'], MAX_DESCENDANTS)\n+\n+        # Sending one more chained transaction will fail\n+        utxo = transaction_package.pop(0)\n+        assert_raises_jsonrpc(-26, \"too-long-mempool-chain\", self.chain_transaction, self.nodes[0], utxo['txid'], utxo['vout'], utxo['amount'], fee, 10)\n \n         # TODO: check that node1's mempool is as expected\n "
      },
      {
        "sha": "812b54ffcb3234ebd1c0c91a301f6874c2c205a6",
        "filename": "qa/rpc-tests/mempool_reorg.py",
        "status": "modified",
        "additions": 11,
        "deletions": 5,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9bd0f64212cd600daf30c9c59035bfe9f07b81b/qa/rpc-tests/mempool_reorg.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9bd0f64212cd600daf30c9c59035bfe9f07b81b/qa/rpc-tests/mempool_reorg.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/mempool_reorg.py?ref=c9bd0f64212cd600daf30c9c59035bfe9f07b81b",
        "patch": "@@ -30,9 +30,10 @@ def setup_network(self):\n         self.sync_all()\n \n     def run_test(self):\n-        start_count = self.nodes[0].getblockcount()\n+        # Start with a 200 block chain\n+        assert_equal(self.nodes[0].getblockcount(), 200)\n \n-        # Mine three blocks. After this, nodes[0] blocks\n+        # Mine four blocks. After this, nodes[0] blocks\n         # 101, 102, and 103 are spend-able.\n         new_blocks = self.nodes[1].generate(4)\n         self.sync_all()\n@@ -52,19 +53,21 @@ def run_test(self):\n         spend_102_raw = create_tx(self.nodes[0], coinbase_txids[2], node0_address, 49.99)\n         spend_103_raw = create_tx(self.nodes[0], coinbase_txids[3], node0_address, 49.99)\n \n-        # Create a block-height-locked transaction which will be invalid after reorg\n+        # Create a transaction which is time-locked to two blocks in the future\n         timelock_tx = self.nodes[0].createrawtransaction([{\"txid\": coinbase_txids[0], \"vout\": 0}], {node0_address: 49.99})\n         # Set the time lock\n         timelock_tx = timelock_tx.replace(\"ffffffff\", \"11111191\", 1)\n         timelock_tx = timelock_tx[:-8] + hex(self.nodes[0].getblockcount() + 2)[2:] + \"000000\"\n         timelock_tx = self.nodes[0].signrawtransaction(timelock_tx)[\"hex\"]\n-        assert_raises(JSONRPCException, self.nodes[0].sendrawtransaction, timelock_tx)\n+        # This will raise an exception because the timelock transaction is too immature to spend\n+        assert_raises_jsonrpc(-26, \"non-final\", self.nodes[0].sendrawtransaction, timelock_tx)\n \n         # Broadcast and mine spend_102 and 103:\n         spend_102_id = self.nodes[0].sendrawtransaction(spend_102_raw)\n         spend_103_id = self.nodes[0].sendrawtransaction(spend_103_raw)\n         self.nodes[0].generate(1)\n-        assert_raises(JSONRPCException, self.nodes[0].sendrawtransaction, timelock_tx)\n+        # Time-locked transaction is still too immature to spend\n+        assert_raises_jsonrpc(-26,'non-final', self.nodes[0].sendrawtransaction, timelock_tx)\n \n         # Create 102_1 and 103_1:\n         spend_102_1_raw = create_tx(self.nodes[0], spend_102_id, node1_address, 49.98)\n@@ -73,6 +76,7 @@ def run_test(self):\n         # Broadcast and mine 103_1:\n         spend_103_1_id = self.nodes[0].sendrawtransaction(spend_103_1_raw)\n         last_block = self.nodes[0].generate(1)\n+        # Time-locked transaction can now be spent\n         timelock_tx_id = self.nodes[0].sendrawtransaction(timelock_tx)\n \n         # ... now put spend_101 and spend_102_1 in memory pools:\n@@ -85,6 +89,8 @@ def run_test(self):\n \n         for node in self.nodes:\n             node.invalidateblock(last_block[0])\n+        # Time-locked transaction is now too immature and has been removed from the mempool\n+        # spend_103_1 has been re-orged out of the chain and is back in the mempool\n         assert_equal(set(self.nodes[0].getrawmempool()), {spend_101_id, spend_102_1_id, spend_103_1_id})\n \n         # Use invalidateblock to re-org back and make all those coinbase spends"
      },
      {
        "sha": "f562a93d86cdd6dc25e84e384d806a0ce6af4115",
        "filename": "qa/rpc-tests/mempool_spendcoinbase.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9bd0f64212cd600daf30c9c59035bfe9f07b81b/qa/rpc-tests/mempool_spendcoinbase.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9bd0f64212cd600daf30c9c59035bfe9f07b81b/qa/rpc-tests/mempool_spendcoinbase.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/mempool_spendcoinbase.py?ref=c9bd0f64212cd600daf30c9c59035bfe9f07b81b",
        "patch": "@@ -45,7 +45,7 @@ def run_test(self):\n         spend_101_id = self.nodes[0].sendrawtransaction(spends_raw[0])\n \n         # coinbase at height 102 should be too immature to spend\n-        assert_raises(JSONRPCException, self.nodes[0].sendrawtransaction, spends_raw[1])\n+        assert_raises_jsonrpc(-26,\"bad-txns-premature-spend-of-coinbase\", self.nodes[0].sendrawtransaction, spends_raw[1])\n \n         # mempool should have just spend_101:\n         assert_equal(self.nodes[0].getrawmempool(), [ spend_101_id ])"
      },
      {
        "sha": "7b19fbfd8268a1994559931a263943363b2d8930",
        "filename": "qa/rpc-tests/nulldummy.py",
        "status": "modified",
        "additions": 10,
        "deletions": 21,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9bd0f64212cd600daf30c9c59035bfe9f07b81b/qa/rpc-tests/nulldummy.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9bd0f64212cd600daf30c9c59035bfe9f07b81b/qa/rpc-tests/nulldummy.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/nulldummy.py?ref=c9bd0f64212cd600daf30c9c59035bfe9f07b81b",
        "patch": "@@ -66,38 +66,38 @@ def run_test(self):\n \n         self.log.info(\"Test 1: NULLDUMMY compliant base transactions should be accepted to mempool and mined before activation [430]\")\n         test1txs = [self.create_transaction(self.nodes[0], coinbase_txid[0], self.ms_address, 49)]\n-        txid1 = self.tx_submit(self.nodes[0], test1txs[0])\n+        txid1 = self.nodes[0].sendrawtransaction(bytes_to_hex_str(test1txs[0].serialize_with_witness()), True)\n         test1txs.append(self.create_transaction(self.nodes[0], txid1, self.ms_address, 48))\n-        txid2 = self.tx_submit(self.nodes[0], test1txs[1])\n+        txid2 = self.nodes[0].sendrawtransaction(bytes_to_hex_str(test1txs[1].serialize_with_witness()), True)\n         test1txs.append(self.create_transaction(self.nodes[0], coinbase_txid[1], self.wit_ms_address, 49))\n-        txid3 = self.tx_submit(self.nodes[0], test1txs[2])\n+        txid3 = self.nodes[0].sendrawtransaction(bytes_to_hex_str(test1txs[2].serialize_with_witness()), True)\n         self.block_submit(self.nodes[0], test1txs, False, True)\n \n         self.log.info(\"Test 2: Non-NULLDUMMY base multisig transaction should not be accepted to mempool before activation\")\n         test2tx = self.create_transaction(self.nodes[0], txid2, self.ms_address, 47)\n         trueDummy(test2tx)\n-        txid4 = self.tx_submit(self.nodes[0], test2tx, NULLDUMMY_ERROR)\n+        assert_raises_jsonrpc(-26, NULLDUMMY_ERROR, self.nodes[0].sendrawtransaction, bytes_to_hex_str(test2tx.serialize_with_witness()), True)\n \n         self.log.info(\"Test 3: Non-NULLDUMMY base transactions should be accepted in a block before activation [431]\")\n         self.block_submit(self.nodes[0], [test2tx], False, True)\n \n-        self.log.info(\"Test 4: Non-NULLDUMMY base multisig transaction is invalid after activation\")\n-        test4tx = self.create_transaction(self.nodes[0], txid4, self.address, 46)\n+        self.log.info (\"Test 4: Non-NULLDUMMY base multisig transaction is invalid after activation\")\n+        test4tx = self.create_transaction(self.nodes[0], test2tx.hash, self.address, 46)\n         test6txs=[CTransaction(test4tx)]\n         trueDummy(test4tx)\n-        self.tx_submit(self.nodes[0], test4tx, NULLDUMMY_ERROR)\n+        assert_raises_jsonrpc(-26, NULLDUMMY_ERROR, self.nodes[0].sendrawtransaction, bytes_to_hex_str(test4tx.serialize_with_witness()), True)\n         self.block_submit(self.nodes[0], [test4tx])\n \n-        self.log.info(\"Test 5: Non-NULLDUMMY P2WSH multisig transaction invalid after activation\")\n+        print (\"Test 5: Non-NULLDUMMY P2WSH multisig transaction invalid after activation\")\n         test5tx = self.create_transaction(self.nodes[0], txid3, self.wit_address, 48)\n         test6txs.append(CTransaction(test5tx))\n         test5tx.wit.vtxinwit[0].scriptWitness.stack[0] = b'\\x01'\n-        self.tx_submit(self.nodes[0], test5tx, NULLDUMMY_ERROR)\n+        assert_raises_jsonrpc(-26, NULLDUMMY_ERROR, self.nodes[0].sendrawtransaction, bytes_to_hex_str(test5tx.serialize_with_witness()), True)\n         self.block_submit(self.nodes[0], [test5tx], True)\n \n         self.log.info(\"Test 6: NULLDUMMY compliant base/witness transactions should be accepted to mempool and in block after activation [432]\")\n         for i in test6txs:\n-            self.tx_submit(self.nodes[0], i)\n+            self.nodes[0].sendrawtransaction(bytes_to_hex_str(i.serialize_with_witness()), True)\n         self.block_submit(self.nodes[0], test6txs, True, True)\n \n \n@@ -112,17 +112,6 @@ def create_transaction(self, node, txid, to_address, amount):\n         return tx\n \n \n-    def tx_submit(self, node, tx, msg = \"\"):\n-        tx.rehash()\n-        try:\n-            node.sendrawtransaction(bytes_to_hex_str(tx.serialize_with_witness()), True)\n-        except JSONRPCException as exp:\n-            assert_equal(exp.error[\"message\"], msg)\n-        else:\n-            assert_equal('', msg)\n-        return tx.hash\n-\n-\n     def block_submit(self, node, txs, witness = False, accept = False):\n         block = create_block(self.tip, create_coinbase(self.lastblockheight + 1), self.lastblocktime + 1)\n         block.nVersion = 4"
      },
      {
        "sha": "0b04ad17abbdc007a1be1c707b4d4e1f3f691c64",
        "filename": "qa/rpc-tests/prioritise_transaction.py",
        "status": "modified",
        "additions": 3,
        "deletions": 7,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9bd0f64212cd600daf30c9c59035bfe9f07b81b/qa/rpc-tests/prioritise_transaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9bd0f64212cd600daf30c9c59035bfe9f07b81b/qa/rpc-tests/prioritise_transaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/prioritise_transaction.py?ref=c9bd0f64212cd600daf30c9c59035bfe9f07b81b",
        "patch": "@@ -107,13 +107,9 @@ def run_test(self):\n         tx_hex = self.nodes[0].signrawtransaction(raw_tx)[\"hex\"]\n         tx_id = self.nodes[0].decoderawtransaction(tx_hex)[\"txid\"]\n \n-        try:\n-            self.nodes[0].sendrawtransaction(tx_hex)\n-        except JSONRPCException as exp:\n-            assert_equal(exp.error['code'], -26) # insufficient fee\n-            assert(tx_id not in self.nodes[0].getrawmempool())\n-        else:\n-            assert(False)\n+        # This will raise an exception due to min relay fee not being met\n+        assert_raises_jsonrpc(-26, \"66: min relay fee not met\", self.nodes[0].sendrawtransaction, tx_hex)\n+        assert(tx_id not in self.nodes[0].getrawmempool())\n \n         # This is a less than 1000-byte transaction, so just set the fee\n         # to be the minimum for a 1000 byte transaction and check that it is"
      },
      {
        "sha": "163c304ebaa825c48fb3c7f11a5447f2e95dc158",
        "filename": "qa/rpc-tests/replace-by-fee.py",
        "status": "modified",
        "additions": 24,
        "deletions": 81,
        "changes": 105,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9bd0f64212cd600daf30c9c59035bfe9f07b81b/qa/rpc-tests/replace-by-fee.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9bd0f64212cd600daf30c9c59035bfe9f07b81b/qa/rpc-tests/replace-by-fee.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/replace-by-fee.py?ref=c9bd0f64212cd600daf30c9c59035bfe9f07b81b",
        "patch": "@@ -125,12 +125,8 @@ def test_simple_doublespend(self):\n         tx1b.vout = [CTxOut(1*COIN, CScript([b'b']))]\n         tx1b_hex = txToHex(tx1b)\n \n-        try:\n-            tx1b_txid = self.nodes[0].sendrawtransaction(tx1b_hex, True)\n-        except JSONRPCException as exp:\n-            assert_equal(exp.error['code'], -26) # insufficient fee\n-        else:\n-            assert(False)\n+        # This will raise an exception due to insufficient fee\n+        assert_raises_jsonrpc(-26, \"insufficient fee\", self.nodes[0].sendrawtransaction, tx1b_hex, True)\n \n         # Extra 0.1 BTC fee\n         tx1b = CTransaction()\n@@ -172,12 +168,8 @@ def test_doublespend_chain(self):\n         dbl_tx.vout = [CTxOut(initial_nValue - 30*COIN, CScript([1]))]\n         dbl_tx_hex = txToHex(dbl_tx)\n \n-        try:\n-            self.nodes[0].sendrawtransaction(dbl_tx_hex, True)\n-        except JSONRPCException as exp:\n-            assert_equal(exp.error['code'], -26) # insufficient fee\n-        else:\n-            assert(False) # transaction mistakenly accepted!\n+        # This will raise an exception due to insufficient fee\n+        assert_raises_jsonrpc(-26, \"insufficient fee\", self.nodes[0].sendrawtransaction, dbl_tx_hex, True)\n \n         # Accepted with sufficient fee\n         dbl_tx = CTransaction()\n@@ -237,12 +229,8 @@ def branch(prevout, initial_value, max_txs, tree_width=5, fee=0.0001*COIN, _tota\n         dbl_tx.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n         dbl_tx.vout = [CTxOut(initial_nValue - fee*n, CScript([1]))]\n         dbl_tx_hex = txToHex(dbl_tx)\n-        try:\n-            self.nodes[0].sendrawtransaction(dbl_tx_hex, True)\n-        except JSONRPCException as exp:\n-            assert_equal(exp.error['code'], -26) # insufficient fee\n-        else:\n-            assert(False)\n+        # This will raise an exception due to insufficient fee\n+        assert_raises_jsonrpc(-26, \"insufficient fee\", self.nodes[0].sendrawtransaction, dbl_tx_hex, True)\n \n         # 1 BTC fee is enough\n         dbl_tx = CTransaction()\n@@ -269,13 +257,8 @@ def branch(prevout, initial_value, max_txs, tree_width=5, fee=0.0001*COIN, _tota\n             dbl_tx.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n             dbl_tx.vout = [CTxOut(initial_nValue - 2*fee*n, CScript([1]))]\n             dbl_tx_hex = txToHex(dbl_tx)\n-            try:\n-                self.nodes[0].sendrawtransaction(dbl_tx_hex, True)\n-            except JSONRPCException as exp:\n-                assert_equal(exp.error['code'], -26)\n-                assert_equal(\"too many potential replacements\" in exp.error['message'], True)\n-            else:\n-                assert(False)\n+            # This will raise an exception\n+            assert_raises_jsonrpc(-26, \"too many potential replacements\", self.nodes[0].sendrawtransaction, dbl_tx_hex, True)\n \n             for tx in tree_txs:\n                 tx.rehash()\n@@ -298,12 +281,8 @@ def test_replacement_feeperkb(self):\n         tx1b.vout = [CTxOut(int(0.001*COIN), CScript([b'a'*999000]))]\n         tx1b_hex = txToHex(tx1b)\n \n-        try:\n-            tx1b_txid = self.nodes[0].sendrawtransaction(tx1b_hex, True)\n-        except JSONRPCException as exp:\n-            assert_equal(exp.error['code'], -26) # insufficient fee\n-        else:\n-            assert(False)\n+        # This will raise an exception due to insufficient fee\n+        assert_raises_jsonrpc(-26, \"insufficient fee\", self.nodes[0].sendrawtransaction, tx1b_hex, True)\n \n     def test_spends_of_conflicting_outputs(self):\n         \"\"\"Replacements that spend conflicting tx outputs are rejected\"\"\"\n@@ -325,12 +304,8 @@ def test_spends_of_conflicting_outputs(self):\n         tx2.vout = tx1a.vout\n         tx2_hex = txToHex(tx2)\n \n-        try:\n-            tx2_txid = self.nodes[0].sendrawtransaction(tx2_hex, True)\n-        except JSONRPCException as exp:\n-            assert_equal(exp.error['code'], -26)\n-        else:\n-            assert(False)\n+        # This will raise an exception\n+        assert_raises_jsonrpc(-26, \"bad-txns-spends-conflicting-tx\", self.nodes[0].sendrawtransaction, tx2_hex, True)\n \n         # Spend tx1a's output to test the indirect case.\n         tx1b = CTransaction()\n@@ -346,12 +321,8 @@ def test_spends_of_conflicting_outputs(self):\n         tx2.vout = tx1a.vout\n         tx2_hex = txToHex(tx2)\n \n-        try:\n-            tx2_txid = self.nodes[0].sendrawtransaction(tx2_hex, True)\n-        except JSONRPCException as exp:\n-            assert_equal(exp.error['code'], -26)\n-        else:\n-            assert(False)\n+        # This will raise an exception\n+        assert_raises_jsonrpc(-26, \"bad-txns-spends-conflicting-tx\", self.nodes[0].sendrawtransaction, tx2_hex, True)\n \n     def test_new_unconfirmed_inputs(self):\n         \"\"\"Replacements that add new unconfirmed inputs are rejected\"\"\"\n@@ -369,12 +340,8 @@ def test_new_unconfirmed_inputs(self):\n         tx2.vout = tx1.vout\n         tx2_hex = txToHex(tx2)\n \n-        try:\n-            tx2_txid = self.nodes[0].sendrawtransaction(tx2_hex, True)\n-        except JSONRPCException as exp:\n-            assert_equal(exp.error['code'], -26)\n-        else:\n-            assert(False)\n+        # This will raise an exception\n+        assert_raises_jsonrpc(-26, \"replacement-adds-unconfirmed\", self.nodes[0].sendrawtransaction, tx2_hex, True)\n \n     def test_too_many_replacements(self):\n         \"\"\"Replacements that evict too many transactions are rejected\"\"\"\n@@ -419,13 +386,8 @@ def test_too_many_replacements(self):\n         double_tx.vout = [CTxOut(double_spend_value, CScript([b'a']))]\n         double_tx_hex = txToHex(double_tx)\n \n-        try:\n-            self.nodes[0].sendrawtransaction(double_tx_hex, True)\n-        except JSONRPCException as exp:\n-            assert_equal(exp.error['code'], -26)\n-            assert_equal(\"too many potential replacements\" in exp.error['message'], True)\n-        else:\n-            assert(False)\n+        # This will raise an exception\n+        assert_raises_jsonrpc(-26, \"too many potential replacements\", self.nodes[0].sendrawtransaction, double_tx_hex, True)\n \n         # If we remove an input, it should pass\n         double_tx = CTransaction()\n@@ -451,13 +413,8 @@ def test_opt_in(self):\n         tx1b.vout = [CTxOut(int(0.9*COIN), CScript([b'b']))]\n         tx1b_hex = txToHex(tx1b)\n \n-        try:\n-            tx1b_txid = self.nodes[0].sendrawtransaction(tx1b_hex, True)\n-        except JSONRPCException as exp:\n-            assert_equal(exp.error['code'], -26)\n-        else:\n-            self.log.info(tx1b_txid)\n-            assert(False)\n+        # This will raise an exception\n+        assert_raises_jsonrpc(-26, \"txn-mempool-conflict\", self.nodes[0].sendrawtransaction, tx1b_hex, True)\n \n         tx1_outpoint = make_utxo(self.nodes[0], int(1.1*COIN))\n \n@@ -474,12 +431,8 @@ def test_opt_in(self):\n         tx2b.vout = [CTxOut(int(0.9*COIN), CScript([b'b']))]\n         tx2b_hex = txToHex(tx2b)\n \n-        try:\n-            tx2b_txid = self.nodes[0].sendrawtransaction(tx2b_hex, True)\n-        except JSONRPCException as exp:\n-            assert_equal(exp.error['code'], -26)\n-        else:\n-            assert(False)\n+        # This will raise an exception\n+        assert_raises_jsonrpc(-26, \"txn-mempool-conflict\", self.nodes[0].sendrawtransaction, tx2b_hex, True)\n \n         # Now create a new transaction that spends from tx1a and tx2a\n         # opt-in on one of the inputs\n@@ -531,12 +484,7 @@ def test_prioritised_transactions(self):\n         tx1b_hex = txToHex(tx1b)\n \n         # Verify tx1b cannot replace tx1a.\n-        try:\n-            tx1b_txid = self.nodes[0].sendrawtransaction(tx1b_hex, True)\n-        except JSONRPCException as exp:\n-            assert_equal(exp.error['code'], -26)\n-        else:\n-            assert(False)\n+        assert_raises_jsonrpc(-26, \"insufficient fee\", self.nodes[0].sendrawtransaction, tx1b_hex, True)\n \n         # Use prioritisetransaction to set tx1a's fee to 0.\n         self.nodes[0].prioritisetransaction(tx1a_txid, int(-0.1*COIN))\n@@ -563,12 +511,7 @@ def test_prioritised_transactions(self):\n         tx2b_hex = txToHex(tx2b)\n \n         # Verify tx2b cannot replace tx2a.\n-        try:\n-            tx2b_txid = self.nodes[0].sendrawtransaction(tx2b_hex, True)\n-        except JSONRPCException as exp:\n-            assert_equal(exp.error['code'], -26)\n-        else:\n-            assert(False)\n+        assert_raises_jsonrpc(-26, \"insufficient fee\", self.nodes[0].sendrawtransaction, tx2b_hex, True)\n \n         # Now prioritise tx2b to have a higher modified fee\n         self.nodes[0].prioritisetransaction(tx2b.hash, int(0.1*COIN))"
      },
      {
        "sha": "8720a345cea5c542a3d8b2488cab934749615f77",
        "filename": "qa/rpc-tests/rpcbind_test.py",
        "status": "modified",
        "additions": 1,
        "deletions": 5,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9bd0f64212cd600daf30c9c59035bfe9f07b81b/qa/rpc-tests/rpcbind_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9bd0f64212cd600daf30c9c59035bfe9f07b81b/qa/rpc-tests/rpcbind_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/rpcbind_test.py?ref=c9bd0f64212cd600daf30c9c59035bfe9f07b81b",
        "patch": "@@ -92,11 +92,7 @@ def run_test(self):\n \n         # Check that with invalid rpcallowip, we are denied\n         self.run_allowip_test([non_loopback_ip], non_loopback_ip, defaultport)\n-        try:\n-            self.run_allowip_test(['1.1.1.1'], non_loopback_ip, defaultport)\n-            assert(not 'Connection not denied by rpcallowip as expected')\n-        except JSONRPCException:\n-            pass\n+        assert_raises_jsonrpc(-342, \"non-JSON HTTP response with '403 Forbidden' from server\", self.run_allowip_test, ['1.1.1.1'], non_loopback_ip, defaultport)\n \n if __name__ == '__main__':\n     RPCBindTest().main()"
      },
      {
        "sha": "5b1fba8eec09f48511a81090d836938027698d88",
        "filename": "qa/rpc-tests/segwit.py",
        "status": "modified",
        "additions": 21,
        "deletions": 37,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9bd0f64212cd600daf30c9c59035bfe9f07b81b/qa/rpc-tests/segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9bd0f64212cd600daf30c9c59035bfe9f07b81b/qa/rpc-tests/segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/segwit.py?ref=c9bd0f64212cd600daf30c9c59035bfe9f07b81b",
        "patch": "@@ -105,22 +105,12 @@ def skip_mine(self, node, txid, sign, redeem_script=\"\"):\n         assert_equal(len(node.getblock(block[0])[\"tx\"]), 1)\n         sync_blocks(self.nodes)\n \n-    def fail_accept(self, node, txid, sign, redeem_script=\"\"):\n-        try:\n-            send_to_witness(1, node, getutxo(txid), self.pubkey[0], False, Decimal(\"49.998\"), sign, redeem_script)\n-        except JSONRPCException as exp:\n-            assert(exp.error[\"code\"] == -26)\n-        else:\n-            raise AssertionError(\"Tx should not have been accepted\")\n+    def fail_accept(self, node, error_msg, txid, sign, redeem_script=\"\"):\n+        assert_raises_jsonrpc(-26, error_msg, send_to_witness, 1, node, getutxo(txid), self.pubkey[0], False, Decimal(\"49.998\"), sign, redeem_script)\n \n     def fail_mine(self, node, txid, sign, redeem_script=\"\"):\n         send_to_witness(1, node, getutxo(txid), self.pubkey[0], False, Decimal(\"49.998\"), sign, redeem_script)\n-        try:\n-            node.generate(1)\n-        except JSONRPCException as exp:\n-            assert(exp.error[\"code\"] == -1)\n-        else:\n-            raise AssertionError(\"Created valid block when TestBlockValidity should have failed\")\n+        assert_raises_jsonrpc(-1, \"CreateNewBlock: TestBlockValidity failed\", node.generate, 1)\n         sync_blocks(self.nodes)\n \n     def run_test(self):\n@@ -177,18 +167,18 @@ def run_test(self):\n \n         self.log.info(\"Verify default node can't accept any witness format txs before fork\")\n         # unsigned, no scriptsig\n-        self.fail_accept(self.nodes[0], wit_ids[NODE_0][WIT_V0][0], False)\n-        self.fail_accept(self.nodes[0], wit_ids[NODE_0][WIT_V1][0], False)\n-        self.fail_accept(self.nodes[0], p2sh_ids[NODE_0][WIT_V0][0], False)\n-        self.fail_accept(self.nodes[0], p2sh_ids[NODE_0][WIT_V1][0], False)\n+        self.fail_accept(self.nodes[0], \"mandatory-script-verify-flag\", wit_ids[NODE_0][WIT_V0][0], False)\n+        self.fail_accept(self.nodes[0], \"mandatory-script-verify-flag\", wit_ids[NODE_0][WIT_V1][0], False)\n+        self.fail_accept(self.nodes[0], \"mandatory-script-verify-flag\", p2sh_ids[NODE_0][WIT_V0][0], False)\n+        self.fail_accept(self.nodes[0], \"mandatory-script-verify-flag\", p2sh_ids[NODE_0][WIT_V1][0], False)\n         # unsigned with redeem script\n-        self.fail_accept(self.nodes[0], p2sh_ids[NODE_0][WIT_V0][0], False, witness_script(False, self.pubkey[0]))\n-        self.fail_accept(self.nodes[0], p2sh_ids[NODE_0][WIT_V1][0], False, witness_script(True, self.pubkey[0]))\n+        self.fail_accept(self.nodes[0], \"mandatory-script-verify-flag\", p2sh_ids[NODE_0][WIT_V0][0], False, witness_script(False, self.pubkey[0]))\n+        self.fail_accept(self.nodes[0], \"mandatory-script-verify-flag\", p2sh_ids[NODE_0][WIT_V1][0], False, witness_script(True, self.pubkey[0]))\n         # signed\n-        self.fail_accept(self.nodes[0], wit_ids[NODE_0][WIT_V0][0], True)\n-        self.fail_accept(self.nodes[0], wit_ids[NODE_0][WIT_V1][0], True)\n-        self.fail_accept(self.nodes[0], p2sh_ids[NODE_0][WIT_V0][0], True)\n-        self.fail_accept(self.nodes[0], p2sh_ids[NODE_0][WIT_V1][0], True)\n+        self.fail_accept(self.nodes[0], \"no-witness-yet\", wit_ids[NODE_0][WIT_V0][0], True)\n+        self.fail_accept(self.nodes[0], \"no-witness-yet\", wit_ids[NODE_0][WIT_V1][0], True)\n+        self.fail_accept(self.nodes[0], \"no-witness-yet\", p2sh_ids[NODE_0][WIT_V0][0], True)\n+        self.fail_accept(self.nodes[0], \"no-witness-yet\", p2sh_ids[NODE_0][WIT_V1][0], True)\n \n         self.log.info(\"Verify witness txs are skipped for mining before the fork\")\n         self.skip_mine(self.nodes[2], wit_ids[NODE_2][WIT_V0][0], True) #block 424\n@@ -203,8 +193,8 @@ def run_test(self):\n         self.success_mine(self.nodes[2], wit_ids[NODE_2][WIT_V1][1], False) #block 429\n \n         self.log.info(\"Verify unsigned p2sh witness txs without a redeem script are invalid\")\n-        self.fail_accept(self.nodes[2], p2sh_ids[NODE_2][WIT_V0][1], False)\n-        self.fail_accept(self.nodes[2], p2sh_ids[NODE_2][WIT_V1][1], False)\n+        self.fail_accept(self.nodes[2], \"mandatory-script-verify-flag\", p2sh_ids[NODE_2][WIT_V0][1], False)\n+        self.fail_accept(self.nodes[2], \"mandatory-script-verify-flag\", p2sh_ids[NODE_2][WIT_V1][1], False)\n \n         self.log.info(\"Verify unsigned p2sh witness txs with a redeem script in versionbits-settings blocks are valid before the fork\")\n         self.success_mine(self.nodes[2], p2sh_ids[NODE_2][WIT_V0][1], False, witness_script(False, self.pubkey[2])) #block 430\n@@ -457,10 +447,13 @@ def run_test(self):\n         importlist.append(bytes_to_hex_str(p2wshop1))\n \n         for i in importlist:\n+            # import all generated addresses. The wallet already has the private keys for some of these, so catch JSON RPC\n+            # exceptions and continue.\n             try:\n                 self.nodes[0].importaddress(i,\"\",False,True)\n             except JSONRPCException as exp:\n                 assert_equal(exp.error[\"message\"], \"The wallet already contains the private key for this address or script\")\n+                assert_equal(exp.error[\"code\"], -4)\n \n         self.nodes[0].importaddress(script_to_p2sh(op0)) # import OP_0 as address only\n         self.nodes[0].importaddress(multisig_without_privkey_address) # Test multisig_without_privkey\n@@ -475,12 +468,7 @@ def run_test(self):\n         # note that no witness address should be returned by unsolvable addresses\n         # the multisig_without_privkey_address will fail because its keys were not added with importpubkey\n         for i in uncompressed_spendable_address + uncompressed_solvable_address + unknown_address + unsolvable_address + [multisig_without_privkey_address]:\n-            try:\n-                self.nodes[0].addwitnessaddress(i)\n-            except JSONRPCException as exp:\n-                assert_equal(exp.error[\"message\"], \"Public key or redeemscript not known to wallet, or the key is uncompressed\")\n-            else:\n-                assert(False)\n+            assert_raises_jsonrpc(-4, \"Public key or redeemscript not known to wallet, or the key is uncompressed\", self.nodes[0].addwitnessaddress, i)\n \n         for i in compressed_spendable_address + compressed_solvable_address:\n             witaddress = self.nodes[0].addwitnessaddress(i)\n@@ -559,12 +547,8 @@ def run_test(self):\n         # note that a multisig address returned by addmultisigaddress is not solvable until it is added with importaddress\n         # premature_witaddress are not accepted until the script is added with addwitnessaddress first\n         for i in uncompressed_spendable_address + uncompressed_solvable_address + premature_witaddress + [compressed_solvable_address[1]]:\n-            try:\n-                self.nodes[0].addwitnessaddress(i)\n-            except JSONRPCException as exp:\n-                assert_equal(exp.error[\"message\"], \"Public key or redeemscript not known to wallet, or the key is uncompressed\")\n-            else:\n-                assert(False)\n+            # This will raise an exception\n+            assert_raises_jsonrpc(-4, \"Public key or redeemscript not known to wallet, or the key is uncompressed\", self.nodes[0].addwitnessaddress, i)\n \n         # after importaddress it should pass addwitnessaddress\n         v = self.nodes[0].validateaddress(compressed_solvable_address[1])"
      },
      {
        "sha": "80f74fa10804aecb74ad60ac0fb22a4e45111590",
        "filename": "qa/rpc-tests/wallet.py",
        "status": "modified",
        "additions": 6,
        "deletions": 14,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9bd0f64212cd600daf30c9c59035bfe9f07b81b/qa/rpc-tests/wallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9bd0f64212cd600daf30c9c59035bfe9f07b81b/qa/rpc-tests/wallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/wallet.py?ref=c9bd0f64212cd600daf30c9c59035bfe9f07b81b",
        "patch": "@@ -71,7 +71,7 @@ def run_test (self):\n         unspent_0 = self.nodes[2].listunspent()[0]\n         unspent_0 = {\"txid\": unspent_0[\"txid\"], \"vout\": unspent_0[\"vout\"]}\n         self.nodes[2].lockunspent(False, [unspent_0])\n-        assert_raises_message(JSONRPCException, \"Insufficient funds\", self.nodes[2].sendtoaddress, self.nodes[2].getnewaddress(), 20)\n+        assert_raises_jsonrpc(-4, \"Insufficient funds\", self.nodes[2].sendtoaddress, self.nodes[2].getnewaddress(), 20)\n         assert_equal([unspent_0], self.nodes[2].listlockunspent())\n         self.nodes[2].lockunspent(True, [unspent_0])\n         assert_equal(len(self.nodes[2].listlockunspent()), 0)\n@@ -251,19 +251,11 @@ def run_test (self):\n         txObj = self.nodes[0].gettransaction(txId)\n         assert_equal(txObj['amount'], Decimal('-0.0001'))\n \n-        try:\n-            txId  = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), \"1f-4\")\n-        except JSONRPCException as e:\n-            assert(\"Invalid amount\" in e.error['message'])\n-        else:\n-            raise AssertionError(\"Must not parse invalid amounts\")\n+        # This will raise an exception because the amount type is wrong\n+        assert_raises_jsonrpc(-3, \"Invalid amount\", self.nodes[0].sendtoaddress, self.nodes[2].getnewaddress(), \"1f-4\")\n \n-\n-        try:\n-            self.nodes[0].generate(\"2\")\n-            raise AssertionError(\"Must not accept strings as numeric\")\n-        except JSONRPCException as e:\n-            assert(\"not an integer\" in e.error['message'])\n+        # This will raise an exception since generate does not accept a string\n+        assert_raises_jsonrpc(-1, \"not an integer\", self.nodes[0].generate, \"2\")\n \n         # Import address and private key to check correct behavior of spendable unspents\n         # 1. Send some coins to generate new UTXO\n@@ -394,7 +386,7 @@ def run_test (self):\n \n         node0_balance = self.nodes[0].getbalance()\n         # With walletrejectlongchains we will not create the tx and store it in our wallet.\n-        assert_raises_message(JSONRPCException, \"mempool chain\", self.nodes[0].sendtoaddress, sending_addr, node0_balance - Decimal('0.01'))\n+        assert_raises_jsonrpc(-4, \"Transaction has too long of a mempool chain\", self.nodes[0].sendtoaddress, sending_addr, node0_balance - Decimal('0.01'))\n \n         # Verify nothing new in wallet\n         assert_equal(total_txs, len(self.nodes[0].listtransactions(\"*\",99999)))"
      }
    ]
  }
]