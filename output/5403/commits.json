[
  {
    "sha": "c5b390b6b91aacd7ea862df11d1b69e542dc9de0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjNWIzOTBiNmI5MWFhY2Q3ZWE4NjJkZjExZDFiNjllNTQyZGM5ZGUw",
    "commit": {
      "author": {
        "name": "Michael Ford",
        "email": "fanquake@gmail.com",
        "date": "2014-12-01T01:39:44Z"
      },
      "committer": {
        "name": "Michael Ford",
        "email": "fanquake@gmail.com",
        "date": "2014-12-02T07:50:58Z"
      },
      "message": "Make comments in main an init doxygen compatible\n\nFix typos where appropriate\nUpdate license/copyright",
      "tree": {
        "sha": "35f1cc862a6dd33e00ff4505f30a0cfb4d10a3a5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/35f1cc862a6dd33e00ff4505f30a0cfb4d10a3a5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c5b390b6b91aacd7ea862df11d1b69e542dc9de0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c5b390b6b91aacd7ea862df11d1b69e542dc9de0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c5b390b6b91aacd7ea862df11d1b69e542dc9de0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c5b390b6b91aacd7ea862df11d1b69e542dc9de0/comments",
    "author": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5270817180c7caae4d6c1dacb01605483d52eb48",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5270817180c7caae4d6c1dacb01605483d52eb48",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5270817180c7caae4d6c1dacb01605483d52eb48"
      }
    ],
    "stats": {
      "total": 349,
      "additions": 189,
      "deletions": 160
    },
    "files": [
      {
        "sha": "11329c16aa416c9e3dc679d98434d117a696ded0",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c5b390b6b91aacd7ea862df11d1b69e542dc9de0/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c5b390b6b91aacd7ea862df11d1b69e542dc9de0/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=c5b390b6b91aacd7ea862df11d1b69e542dc9de0",
        "patch": "@@ -1,6 +1,6 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n // Copyright (c) 2009-2014 The Bitcoin developers\n-// Distributed under the MIT/X11 software license, see the accompanying\n+// Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #if defined(HAVE_CONFIG_H)\n@@ -60,7 +60,7 @@ bool fFeeEstimatesInitialized = false;\n #define MIN_CORE_FILEDESCRIPTORS 150\n #endif\n \n-// Used to pass flags to the Bind() function\n+/** Used to pass flags to the Bind() function */\n enum BindFlags {\n     BF_NONE         = 0,\n     BF_EXPLICIT     = (1U << 0),\n@@ -175,9 +175,9 @@ void Shutdown()\n     LogPrintf(\"%s: done\\n\", __func__);\n }\n \n-//\n-// Signal handlers are very limited in what they are allowed to do, so:\n-//\n+/**\n+ * Signal handlers are very limited in what they are allowed to do, so:\n+ */\n void HandleSIGTERM(int)\n {\n     fRequestShutdown = true;"
      },
      {
        "sha": "f2f7ac6747abfb88be4bae095e9391208e4f946c",
        "filename": "src/init.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c5b390b6b91aacd7ea862df11d1b69e542dc9de0/src/init.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c5b390b6b91aacd7ea862df11d1b69e542dc9de0/src/init.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.h?ref=c5b390b6b91aacd7ea862df11d1b69e542dc9de0",
        "patch": "@@ -1,6 +1,6 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2013 The Bitcoin developers\n-// Distributed under the MIT/X11 software license, see the accompanying\n+// Copyright (c) 2009-2014 The Bitcoin developers\n+// Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #ifndef BITCOIN_INIT_H\n@@ -22,7 +22,7 @@ bool ShutdownRequested();\n void Shutdown();\n bool AppInit2(boost::thread_group& threadGroup);\n \n-/* The help message mode determines what help message to show */\n+/** The help message mode determines what help message to show */\n enum HelpMessageMode {\n     HMM_BITCOIND,\n     HMM_BITCOIN_QT"
      },
      {
        "sha": "451d6c8cd9633e15e8ce1b922e1df4a5241537d8",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 82,
        "deletions": 67,
        "changes": 149,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c5b390b6b91aacd7ea862df11d1b69e542dc9de0/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c5b390b6b91aacd7ea862df11d1b69e542dc9de0/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=c5b390b6b91aacd7ea862df11d1b69e542dc9de0",
        "patch": "@@ -1,6 +1,6 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n // Copyright (c) 2009-2014 The Bitcoin developers\n-// Distributed under the MIT/X11 software license, see the accompanying\n+// Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"main.h\"\n@@ -33,9 +33,9 @@ using namespace std;\n # error \"Bitcoin cannot be compiled without assertions.\"\n #endif\n \n-//\n-// Global state\n-//\n+/**\n+ * Global state\n+ */\n \n CCriticalSection cs_main;\n \n@@ -66,7 +66,7 @@ map<uint256, COrphanTx> mapOrphanTransactions;\n map<uint256, set<uint256> > mapOrphanTransactionsByPrev;\n void EraseOrphansFor(NodeId peer);\n \n-// Constant stuff for coinbase transactions we create:\n+/** Constant stuff for coinbase transactions we create: */\n CScript COINBASE_FLAGS;\n \n const string strMessageMagic = \"Bitcoin Signed Message:\\n\";\n@@ -97,44 +97,49 @@ namespace {\n \n     CBlockIndex *pindexBestInvalid;\n \n-    // The set of all CBlockIndex entries with BLOCK_VALID_TRANSACTIONS or better that are at least\n-    // as good as our current tip. Entries may be failed, though.\n+    /**\n+     * The set of all CBlockIndex entries with BLOCK_VALID_TRANSACTIONS or better that are at least\n+     * as good as our current tip. Entries may be failed, though.\n+     */\n     set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexCandidates;\n-    // Number of nodes with fSyncStarted.\n+    /** Number of nodes with fSyncStarted. */\n     int nSyncStarted = 0;\n-    // All pairs A->B, where A (or one if its ancestors) misses transactions, but B has transactions.\n+    /** All pairs A->B, where A (or one if its ancestors) misses transactions, but B has transactions. */\n     multimap<CBlockIndex*, CBlockIndex*> mapBlocksUnlinked;\n \n     CCriticalSection cs_LastBlockFile;\n     std::vector<CBlockFileInfo> vinfoBlockFile;\n     int nLastBlockFile = 0;\n \n-    // Every received block is assigned a unique and increasing identifier, so we\n-    // know which one to give priority in case of a fork.\n+    /**\n+     * Every received block is assigned a unique and increasing identifier, so we\n+     * know which one to give priority in case of a fork.\n+     */\n     CCriticalSection cs_nBlockSequenceId;\n-    // Blocks loaded from disk are assigned id 0, so start the counter at 1.\n+    /** Blocks loaded from disk are assigned id 0, so start the counter at 1. */\n     uint32_t nBlockSequenceId = 1;\n \n-    // Sources of received blocks, to be able to send them reject messages or ban\n-    // them, if processing happens afterwards. Protected by cs_main.\n+    /**\n+     * Sources of received blocks, to be able to send them reject messages or ban\n+     * them, if processing happens afterwards. Protected by cs_main.\n+     */\n     map<uint256, NodeId> mapBlockSource;\n \n-    // Blocks that are in flight, and that are in the queue to be downloaded.\n-    // Protected by cs_main.\n+    /** Blocks that are in flight, and that are in the queue to be downloaded. Protected by cs_main. */\n     struct QueuedBlock {\n         uint256 hash;\n-        CBlockIndex *pindex;  // Optional.\n-        int64_t nTime;  // Time of \"getdata\" request in microseconds.\n+        CBlockIndex *pindex;  //! Optional.\n+        int64_t nTime;  //! Time of \"getdata\" request in microseconds.\n     };\n     map<uint256, pair<NodeId, list<QueuedBlock>::iterator> > mapBlocksInFlight;\n \n-    // Number of preferrable block download peers.\n+    /** Number of preferable block download peers. */\n     int nPreferredDownload = 0;\n \n-    // Dirty block index entries.\n+    /** Dirty block index entries. */\n     set<CBlockIndex*> setDirtyBlockIndex;\n \n-    // Dirty block file entries.\n+    /** Dirty block file entries. */\n     set<int> setDirtyFileInfo;\n } // anon namespace\n \n@@ -148,19 +153,19 @@ namespace {\n namespace {\n \n struct CMainSignals {\n-    // Notifies listeners of updated transaction data (transaction, and optionally the block it is found in.\n+    /** Notifies listeners of updated transaction data (transaction, and optionally the block it is found in. */\n     boost::signals2::signal<void (const CTransaction &, const CBlock *)> SyncTransaction;\n-    // Notifies listeners of an erased transaction (currently disabled, requires transaction replacement).\n+    /** Notifies listeners of an erased transaction (currently disabled, requires transaction replacement). */\n     boost::signals2::signal<void (const uint256 &)> EraseTransaction;\n-    // Notifies listeners of an updated transaction without new data (for now: a coinbase potentially becoming visible).\n+    /** Notifies listeners of an updated transaction without new data (for now: a coinbase potentially becoming visible). */\n     boost::signals2::signal<void (const uint256 &)> UpdatedTransaction;\n-    // Notifies listeners of a new active block chain.\n+    /** Notifies listeners of a new active block chain. */\n     boost::signals2::signal<void (const CBlockLocator &)> SetBestChain;\n-    // Notifies listeners about an inventory item being seen on the network.\n+    /** Notifies listeners about an inventory item being seen on the network. */\n     boost::signals2::signal<void (const uint256 &)> Inventory;\n-    // Tells listeners to broadcast their data.\n+    /** Tells listeners to broadcast their data. */\n     boost::signals2::signal<void ()> Broadcast;\n-    // Notifies listeners of a block validation result\n+    /** Notifies listeners of a block validation result */\n     boost::signals2::signal<void (const CBlock&, const CValidationState&)> BlockChecked;\n } g_signals;\n \n@@ -213,32 +218,34 @@ struct CBlockReject {\n     uint256 hashBlock;\n };\n \n-// Maintain validation-specific state about nodes, protected by cs_main, instead\n-// by CNode's own locks. This simplifies asynchronous operation, where\n-// processing of incoming data is done after the ProcessMessage call returns,\n-// and we're no longer holding the node's locks.\n+/**\n+ * Maintain validation-specific state about nodes, protected by cs_main, instead\n+ * by CNode's own locks. This simplifies asynchronous operation, where\n+ * processing of incoming data is done after the ProcessMessage call returns,\n+ * and we're no longer holding the node's locks.\n+ */\n struct CNodeState {\n-    // Accumulated misbehaviour score for this peer.\n+    //! Accumulated misbehaviour score for this peer.\n     int nMisbehavior;\n-    // Whether this peer should be disconnected and banned (unless whitelisted).\n+    //! Whether this peer should be disconnected and banned (unless whitelisted).\n     bool fShouldBan;\n-    // String name of this peer (debugging/logging purposes).\n+    //! String name of this peer (debugging/logging purposes).\n     std::string name;\n-    // List of asynchronously-determined block rejections to notify this peer about.\n+    //! List of asynchronously-determined block rejections to notify this peer about.\n     std::vector<CBlockReject> rejects;\n-    // The best known block we know this peer has announced.\n+    //! The best known block we know this peer has announced.\n     CBlockIndex *pindexBestKnownBlock;\n-    // The hash of the last unknown block this peer has announced.\n+    //! The hash of the last unknown block this peer has announced.\n     uint256 hashLastUnknownBlock;\n-    // The last full block we both have.\n+    //! The last full block we both have.\n     CBlockIndex *pindexLastCommonBlock;\n-    // Whether we've started headers synchronization with this peer.\n+    //! Whether we've started headers synchronization with this peer.\n     bool fSyncStarted;\n-    // Since when we're stalling block download progress (in microseconds), or 0.\n+    //! Since when we're stalling block download progress (in microseconds), or 0.\n     int64_t nStallingSince;\n     list<QueuedBlock> vBlocksInFlight;\n     int nBlocksInFlight;\n-    // Whether we consider this a preferred download peer.\n+    //! Whether we consider this a preferred download peer.\n     bool fPreferredDownload;\n \n     CNodeState() {\n@@ -254,7 +261,7 @@ struct CNodeState {\n     }\n };\n \n-// Map maintaining per-node state. Requires cs_main.\n+/** Map maintaining per-node state. Requires cs_main. */\n map<NodeId, CNodeState> mapNodeState;\n \n // Requires cs_main.\n@@ -708,15 +715,15 @@ bool IsFinalTx(const CTransaction &tx, int nBlockHeight, int64_t nBlockTime)\n     return true;\n }\n \n-//\n-// Check transaction inputs to mitigate two\n-// potential denial-of-service attacks:\n-//\n-// 1. scriptSigs with extra data stuffed into them,\n-//    not consumed by scriptPubKey (or P2SH script)\n-// 2. P2SH scripts with a crazy number of expensive\n-//    CHECKSIG/CHECKMULTISIG operations\n-//\n+/**\n+ * Check transaction inputs to mitigate two\n+ * potential denial-of-service attacks:\n+ * \n+ * 1. scriptSigs with extra data stuffed into them,\n+ *    not consumed by scriptPubKey (or P2SH script)\n+ * 2. P2SH scripts with a crazy number of expensive\n+ *    CHECKSIG/CHECKMULTISIG operations\n+ */\n bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n {\n     if (tx.IsCoinBase())\n@@ -1054,7 +1061,7 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n     return true;\n }\n \n-// Return transaction in tx, and if it was found inside a block, its hash is placed in hashBlock\n+/** Return transaction in tx, and if it was found inside a block, its hash is placed in hashBlock */\n bool GetTransaction(const uint256 &hash, CTransaction &txOut, uint256 &hashBlock, bool fAllowSlow)\n {\n     CBlockIndex *pindexSlow = NULL;\n@@ -1818,7 +1825,7 @@ void FlushStateToDisk() {\n     FlushStateToDisk(state, FLUSH_STATE_ALWAYS);\n }\n \n-// Update chainActive and related internal data structures.\n+/** Update chainActive and related internal data structures. */\n void static UpdateTip(CBlockIndex *pindexNew) {\n     chainActive.SetTip(pindexNew);\n \n@@ -1857,7 +1864,7 @@ void static UpdateTip(CBlockIndex *pindexNew) {\n     }\n }\n \n-// Disconnect chainActive's tip.\n+/** Disconnect chainActive's tip. */\n bool static DisconnectTip(CValidationState &state) {\n     CBlockIndex *pindexDelete = chainActive.Tip();\n     assert(pindexDelete);\n@@ -1904,8 +1911,10 @@ static int64_t nTimeFlush = 0;\n static int64_t nTimeChainState = 0;\n static int64_t nTimePostConnect = 0;\n \n-// Connect a new block to chainActive. pblock is either NULL or a pointer to a CBlock\n-// corresponding to pindexNew, to bypass loading it again from disk.\n+/** \n+ * Connect a new block to chainActive. pblock is either NULL or a pointer to a CBlock\n+ * corresponding to pindexNew, to bypass loading it again from disk.\n+ */\n bool static ConnectTip(CValidationState &state, CBlockIndex *pindexNew, CBlock *pblock) {\n     assert(pindexNew->pprev == chainActive.Tip());\n     mempool.check(pcoinsTip);\n@@ -1965,8 +1974,10 @@ bool static ConnectTip(CValidationState &state, CBlockIndex *pindexNew, CBlock *\n     return true;\n }\n \n-// Return the tip of the chain with the most work in it, that isn't\n-// known to be invalid (it's however far from certain to be valid).\n+/**\n+ * Return the tip of the chain with the most work in it, that isn't\n+ * known to be invalid (it's however far from certain to be valid).\n+ */\n static CBlockIndex* FindMostWorkChain() {\n     do {\n         CBlockIndex *pindexNew = NULL;\n@@ -2007,7 +2018,7 @@ static CBlockIndex* FindMostWorkChain() {\n     } while(true);\n }\n \n-// Delete all entries in setBlockIndexCandidates that are worse than the current tip.\n+/** Delete all entries in setBlockIndexCandidates that are worse than the current tip. */\n static void PruneBlockIndexCandidates() {\n     // Note that we can't delete the current block itself, as we may need to return to it later in case a\n     // reorganization to a better block fails.\n@@ -2019,8 +2030,10 @@ static void PruneBlockIndexCandidates() {\n     assert(!setBlockIndexCandidates.empty());\n }\n \n-// Try to make some progress towards making pindexMostWork the active block.\n-// pblock is either NULL or a pointer to a CBlock corresponding to pindexMostWork.\n+/**\n+ * Try to make some progress towards making pindexMostWork the active block.\n+ * pblock is either NULL or a pointer to a CBlock corresponding to pindexMostWork.\n+ */\n static bool ActivateBestChainStep(CValidationState &state, CBlockIndex *pindexMostWork, CBlock *pblock) {\n     AssertLockHeld(cs_main);\n     bool fInvalidFound = false;\n@@ -2085,9 +2098,11 @@ static bool ActivateBestChainStep(CValidationState &state, CBlockIndex *pindexMo\n     return true;\n }\n \n-// Make the best chain active, in multiple steps. The result is either failure\n-// or an activated best chain. pblock is either NULL or a pointer to a block\n-// that is already loaded (to avoid loading it again from disk).\n+/**\n+ * Make the best chain active, in multiple steps. The result is either failure\n+ * or an activated best chain. pblock is either NULL or a pointer to a block\n+ * that is already loaded (to avoid loading it again from disk).\n+ */\n bool ActivateBestChain(CValidationState &state, CBlock *pblock) {\n     CBlockIndex *pindexNewTip = NULL;\n     CBlockIndex *pindexMostWork = NULL;\n@@ -2236,7 +2251,7 @@ CBlockIndex* AddToBlockIndex(const CBlockHeader& block)\n     return pindexNew;\n }\n \n-// Mark a block as having its data received and checked (up to BLOCK_VALID_TRANSACTIONS).\n+/** Mark a block as having its data received and checked (up to BLOCK_VALID_TRANSACTIONS). */\n bool ReceivedBlockTransactions(const CBlock &block, CValidationState& state, CBlockIndex *pindexNew, const CDiskBlockPos& pos)\n {\n     pindexNew->nTx = block.vtx.size();\n@@ -2745,7 +2760,7 @@ uint256 CPartialMerkleTree::CalcHash(int height, unsigned int pos, const std::ve\n     } else {\n         // calculate left hash\n         uint256 left = CalcHash(height-1, pos*2, vTxid), right;\n-        // calculate right hash if not beyong the end of the array - copy left hash otherwise1\n+        // calculate right hash if not beyond the end of the array - copy left hash otherwise1\n         if (pos*2+1 < CalcTreeWidth(height-1))\n             right = CalcHash(height-1, pos*2+1, vTxid);\n         else"
      },
      {
        "sha": "ecf54897185e25be42e159fe96b3b51d1c50a318",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 99,
        "deletions": 85,
        "changes": 184,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c5b390b6b91aacd7ea862df11d1b69e542dc9de0/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c5b390b6b91aacd7ea862df11d1b69e542dc9de0/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=c5b390b6b91aacd7ea862df11d1b69e542dc9de0",
        "patch": "@@ -1,6 +1,6 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n // Copyright (c) 2009-2014 The Bitcoin developers\n-// Distributed under the MIT/X11 software license, see the accompanying\n+// Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #ifndef BITCOIN_MAIN_H\n@@ -60,7 +60,7 @@ static const unsigned int DEFAULT_BLOCK_PRIORITY_SIZE = 50000;\n static const unsigned int MAX_STANDARD_TX_SIZE = 100000;\n /** The maximum allowed number of signature check operations in a block (network rule) */\n static const unsigned int MAX_BLOCK_SIGOPS = MAX_BLOCK_SIZE/50;\n-/** Maxiumum number of signature check operations in an IsStandard() P2SH script */\n+/** Maximum number of signature check operations in an IsStandard() P2SH script */\n static const unsigned int MAX_P2SH_SIGOPS = 15;\n /** The maximum number of sigops we're willing to relay/mine in a single tx */\n static const unsigned int MAX_TX_SIGOPS = MAX_BLOCK_SIGOPS/5;\n@@ -97,7 +97,7 @@ static const unsigned int BLOCK_DOWNLOAD_WINDOW = 1024;\n /** Time to wait (in seconds) between writing blockchain state to disk. */\n static const unsigned int DATABASE_WRITE_INTERVAL = 3600;\n \n-/** \"reject\" message codes **/\n+/** \"reject\" message codes */\n static const unsigned char REJECT_MALFORMED = 0x01;\n static const unsigned char REJECT_INVALID = 0x10;\n static const unsigned char REJECT_OBSOLETE = 0x11;\n@@ -131,10 +131,10 @@ extern bool fIsBareMultisigStd;\n extern unsigned int nCoinCacheSize;\n extern CFeeRate minRelayTxFee;\n \n-// Best header we've seen so far (used for getheaders queries' starting points).\n+/** Best header we've seen so far (used for getheaders queries' starting points). */\n extern CBlockIndex *pindexBestHeader;\n \n-// Minimum disk space required - used in CheckDiskSpace()\n+/** Minimum disk space required - used in CheckDiskSpace() */\n static const uint64_t nMinDiskSpace = 52428800;\n \n /** Register a wallet to receive updates from core */\n@@ -151,15 +151,17 @@ void RegisterNodeSignals(CNodeSignals& nodeSignals);\n /** Unregister a network node */\n void UnregisterNodeSignals(CNodeSignals& nodeSignals);\n \n-/** Process an incoming block. This only returns after the best known valid\n-    block is made active. Note that it does not, however, guarantee that the\n-    specific block passed to it has been checked for validity!\n-    @param[out]  state   This may be set to an Error state if any error occurred processing it, including during validation/connection/etc of otherwise unrelated blocks during reorganisation; or it may be set to an Invalid state iff pblock is itself invalid (but this is not guaranteed even when the block is checked). If you want to *possibly* get feedback on whether pblock is valid, you must also install a CValidationInterface - this will have its BlockChecked method called whenever *any* block completes validation.\n-    @param[in]   pfrom   The node which we are receiving the block from; it is added to mapBlockSource and may be penalised if the block is invalid.\n-    @param[in]   pblock  The block we want to process.\n-    @param[out]  dbp     If pblock is stored to disk (or already there), this will be set to its location.\n-    @return True if state.IsValid()\n-*/\n+/** \n+ * Process an incoming block. This only returns after the best known valid\n+ * block is made active. Note that it does not, however, guarantee that the\n+ * specific block passed to it has been checked for validity!\n+ * \n+ * @param[out]  state   This may be set to an Error state if any error occurred processing it, including during validation/connection/etc of otherwise unrelated blocks during reorganisation; or it may be set to an Invalid state if pblock is itself invalid (but this is not guaranteed even when the block is checked). If you want to *possibly* get feedback on whether pblock is valid, you must also install a CValidationInterface - this will have its BlockChecked method called whenever *any* block completes validation.\n+ * @param[in]   pfrom   The node which we are receiving the block from; it is added to mapBlockSource and may be penalised if the block is invalid.\n+ * @param[in]   pblock  The block we want to process.\n+ * @param[out]  dbp     If pblock is stored to disk (or already there), this will be set to its location.\n+ * @return True if state.IsValid()\n+ */\n bool ProcessNewBlock(CValidationState &state, CNode* pfrom, CBlock* pblock, CDiskBlockPos *dbp = NULL);\n /** Check whether enough disk space is available for an incoming block */\n bool CheckDiskSpace(uint64_t nAdditionalBytes = 0);\n@@ -245,54 +247,59 @@ struct CDiskTxPos : public CDiskBlockPos\n \n CAmount GetMinRelayFee(const CTransaction& tx, unsigned int nBytes, bool fAllowFree);\n \n-//\n-// Check transaction inputs, and make sure any\n-// pay-to-script-hash transactions are evaluating IsStandard scripts\n-//\n-// Why bother? To avoid denial-of-service attacks; an attacker\n-// can submit a standard HASH... OP_EQUAL transaction,\n-// which will get accepted into blocks. The redemption\n-// script can be anything; an attacker could use a very\n-// expensive-to-check-upon-redemption script like:\n-//   DUP CHECKSIG DROP ... repeated 100 times... OP_1\n-//\n+/**\n+ * Check transaction inputs, and make sure any\n+ * pay-to-script-hash transactions are evaluating IsStandard scripts\n+ * \n+ * Why bother? To avoid denial-of-service attacks; an attacker\n+ * can submit a standard HASH... OP_EQUAL transaction,\n+ * which will get accepted into blocks. The redemption\n+ * script can be anything; an attacker could use a very\n+ * expensive-to-check-upon-redemption script like:\n+ *   DUP CHECKSIG DROP ... repeated 100 times... OP_1\n+ */\n \n-/** Check for standard transaction types\n-    @param[in] mapInputs    Map of previous transactions that have outputs we're spending\n-    @return True if all inputs (scriptSigs) use only standard transaction forms\n-*/\n+/** \n+ * Check for standard transaction types\n+ * @param[in] mapInputs    Map of previous transactions that have outputs we're spending\n+ * @return True if all inputs (scriptSigs) use only standard transaction forms\n+ */\n bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs);\n \n-/** Count ECDSA signature operations the old-fashioned (pre-0.6) way\n-    @return number of sigops this transaction's outputs will produce when spent\n-    @see CTransaction::FetchInputs\n-*/\n+/** \n+ * Count ECDSA signature operations the old-fashioned (pre-0.6) way\n+ * @return number of sigops this transaction's outputs will produce when spent\n+ * @see CTransaction::FetchInputs\n+ */\n unsigned int GetLegacySigOpCount(const CTransaction& tx);\n \n-/** Count ECDSA signature operations in pay-to-script-hash inputs.\n-\n-    @param[in] mapInputs\tMap of previous transactions that have outputs we're spending\n-    @return maximum number of sigops required to validate this transaction's inputs\n-    @see CTransaction::FetchInputs\n+/**\n+ * Count ECDSA signature operations in pay-to-script-hash inputs.\n+ * \n+ * @param[in] mapInputs Map of previous transactions that have outputs we're spending\n+ * @return maximum number of sigops required to validate this transaction's inputs\n+ * @see CTransaction::FetchInputs\n  */\n unsigned int GetP2SHSigOpCount(const CTransaction& tx, const CCoinsViewCache& mapInputs);\n \n \n-// Check whether all inputs of this transaction are valid (no double spends, scripts & sigs, amounts)\n-// This does not modify the UTXO set. If pvChecks is not NULL, script checks are pushed onto it\n-// instead of being performed inline.\n+/**\n+ * Check whether all inputs of this transaction are valid (no double spends, scripts & sigs, amounts)\n+ * This does not modify the UTXO set. If pvChecks is not NULL, script checks are pushed onto it\n+ * instead of being performed inline.\n+ */\n bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &view, bool fScriptChecks,\n                  unsigned int flags, bool cacheStore, std::vector<CScriptCheck> *pvChecks = NULL);\n \n-// Apply the effects of this transaction on the UTXO set represented by view\n+/** Apply the effects of this transaction on the UTXO set represented by view */\n void UpdateCoins(const CTransaction& tx, CValidationState &state, CCoinsViewCache &inputs, CTxUndo &txundo, int nHeight);\n \n-// Context-independent validity checks\n+/** Context-independent validity checks */\n bool CheckTransaction(const CTransaction& tx, CValidationState& state);\n \n /** Check for standard transaction types\n-    @return True if all outputs (scriptPubKeys) use only standard transaction forms\n-*/\n+ * @return True if all outputs (scriptPubKeys) use only standard transaction forms\n+ */\n bool IsStandardTx(const CTransaction& tx, std::string& reason);\n \n bool IsFinalTx(const CTransaction &tx, int nBlockHeight = 0, int64_t nBlockTime = 0);\n@@ -315,8 +322,10 @@ class CBlockUndo\n };\n \n \n-/** Closure representing one script verification\n- *  Note that this stores references to the spending transaction */\n+/** \n+ * Closure representing one script verification\n+ * Note that this stores references to the spending transaction \n+ */\n class CScriptCheck\n {\n private:\n@@ -345,7 +354,7 @@ class CScriptCheck\n \n /** Data structure that represents a partial merkle tree.\n  *\n- * It respresents a subset of the txid's of a known block, in a way that\n+ * It represents a subset of the txid's of a known block, in a way that\n  * allows recovery of the list of txid's and the merkle root, in an\n  * authenticated way.\n  *\n@@ -380,36 +389,38 @@ class CScriptCheck\n class CPartialMerkleTree\n {\n protected:\n-    // the total number of transactions in the block\n+    /** the total number of transactions in the block */\n     unsigned int nTransactions;\n \n-    // node-is-parent-of-matched-txid bits\n+    /** node-is-parent-of-matched-txid bits */\n     std::vector<bool> vBits;\n \n-    // txids and internal hashes\n+    /** txids and internal hashes */\n     std::vector<uint256> vHash;\n \n-    // flag set when encountering invalid data\n+    /** flag set when encountering invalid data */\n     bool fBad;\n \n-    // helper function to efficiently calculate the number of nodes at given height in the merkle tree\n+    /** helper function to efficiently calculate the number of nodes at given height in the merkle tree */\n     unsigned int CalcTreeWidth(int height) {\n         return (nTransactions+(1 << height)-1) >> height;\n     }\n \n-    // calculate the hash of a node in the merkle tree (at leaf level: the txid's themself)\n+    /** calculate the hash of a node in the merkle tree (at leaf level: the txid's themselves) */\n     uint256 CalcHash(int height, unsigned int pos, const std::vector<uint256> &vTxid);\n \n-    // recursive function that traverses tree nodes, storing the data as bits and hashes\n+    /** recursive function that traverses tree nodes, storing the data as bits and hashes */\n     void TraverseAndBuild(int height, unsigned int pos, const std::vector<uint256> &vTxid, const std::vector<bool> &vMatch);\n \n-    // recursive function that traverses tree nodes, consuming the bits and hashes produced by TraverseAndBuild.\n-    // it returns the hash of the respective node.\n+    /**\n+     * recursive function that traverses tree nodes, consuming the bits and hashes produced by TraverseAndBuild.\n+     * it returns the hash of the respective node.\n+     */\n     uint256 TraverseAndExtract(int height, unsigned int pos, unsigned int &nBitsUsed, unsigned int &nHashUsed, std::vector<uint256> &vMatch);\n \n public:\n \n-    // serialization implementation\n+    /** serialization implementation */\n     ADD_SERIALIZE_METHODS;\n \n     template <typename Stream, typename Operation>\n@@ -432,13 +443,15 @@ class CPartialMerkleTree\n         }\n     }\n \n-    // Construct a partial merkle tree from a list of transaction id's, and a mask that selects a subset of them\n+    /** Construct a partial merkle tree from a list of transaction id's, and a mask that selects a subset of them */\n     CPartialMerkleTree(const std::vector<uint256> &vTxid, const std::vector<bool> &vMatch);\n \n     CPartialMerkleTree();\n \n-    // extract the matching txid's represented by this partial merkle tree.\n-    // returns the merkle root, or 0 in case of failure\n+    /**\n+     * extract the matching txid's represented by this partial merkle tree.\n+     * returns the merkle root, or 0 in case of failure\n+     */\n     uint256 ExtractMatches(std::vector<uint256> &vMatch);\n };\n \n@@ -458,22 +471,21 @@ bool ReadBlockFromDisk(CBlock& block, const CBlockIndex* pindex);\n  *  of problems. Note that in any case, coins may be modified. */\n bool DisconnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, CCoinsViewCache& coins, bool* pfClean = NULL);\n \n-// Apply the effects of this block (with given index) on the UTXO set represented by coins\n+/** Apply the effects of this block (with given index) on the UTXO set represented by coins */\n bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pindex, CCoinsViewCache& coins, bool fJustCheck = false);\n \n-// Context-independent validity checks\n+/** Context-independent validity checks */\n bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state, bool fCheckPOW = true);\n bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW = true, bool fCheckMerkleRoot = true);\n \n-// Context-dependent validity checks\n+/** Context-dependent validity checks */\n bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationState& state, CBlockIndex *pindexPrev);\n bool ContextualCheckBlock(const CBlock& block, CValidationState& state, CBlockIndex *pindexPrev);\n \n-// Check a block is completely valid from start to finish (only works on top of our current best block, with cs_main held)\n+/** Check a block is completely valid from start to finish (only works on top of our current best block, with cs_main held) */\n bool TestBlockValidity(CValidationState &state, const CBlock& block, CBlockIndex *pindexPrev, bool fCheckPOW = true, bool fCheckMerkleRoot = true);\n \n-// Store block on disk\n-// if dbp is provided, the file is known to already reside on disk\n+/** Store block on disk. If dbp is provided, the file is known to already reside on disk */\n bool AcceptBlock(CBlock& block, CValidationState& state, CBlockIndex **pindex, CDiskBlockPos* dbp = NULL);\n bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state, CBlockIndex **ppindex= NULL);\n \n@@ -482,13 +494,13 @@ bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state, CBloc\n class CBlockFileInfo\n {\n public:\n-    unsigned int nBlocks;      // number of blocks stored in file\n-    unsigned int nSize;        // number of used bytes of block file\n-    unsigned int nUndoSize;    // number of used bytes in the undo file\n-    unsigned int nHeightFirst; // lowest height of block in file\n-    unsigned int nHeightLast;  // highest height of block in file\n-    uint64_t nTimeFirst;         // earliest time of block in file\n-    uint64_t nTimeLast;          // latest time of block in file\n+    unsigned int nBlocks;      //! number of blocks stored in file\n+    unsigned int nSize;        //! number of used bytes of block file\n+    unsigned int nUndoSize;    //! number of used bytes in the undo file\n+    unsigned int nHeightFirst; //! lowest height of block in file\n+    unsigned int nHeightLast;  //! highest height of block in file\n+    uint64_t nTimeFirst;         //! earliest time of block in file\n+    uint64_t nTimeLast;          //! latest time of block in file\n \n     ADD_SERIALIZE_METHODS;\n \n@@ -519,7 +531,7 @@ class CBlockFileInfo\n \n      std::string ToString() const;\n \n-     // update statistics (does not update nSize)\n+     /** update statistics (does not update nSize) */\n      void AddBlock(unsigned int nHeightIn, uint64_t nTimeIn) {\n          if (nBlocks==0 || nHeightFirst > nHeightIn)\n              nHeightFirst = nHeightIn;\n@@ -537,9 +549,9 @@ class CBlockFileInfo\n class CValidationState {\n private:\n     enum mode_state {\n-        MODE_VALID,   // everything ok\n-        MODE_INVALID, // network rule violation (DoS value may be set)\n-        MODE_ERROR,   // run-time error\n+        MODE_VALID,   //! everything ok\n+        MODE_INVALID, //! network rule violation (DoS value may be set)\n+        MODE_ERROR,   //! run-time error\n     } mode;\n     int nDoS;\n     std::string strRejectReason;\n@@ -634,24 +646,26 @@ struct CBlockTemplate\n \n \n \n-/** Used to relay blocks as header + vector<merkle branch>\n+/** \n+ * Used to relay blocks as header + vector<merkle branch>\n  * to filtered nodes.\n  */\n class CMerkleBlock\n {\n public:\n-    // Public only for unit testing\n+    /** Public only for unit testing */\n     CBlockHeader header;\n     CPartialMerkleTree txn;\n \n public:\n-    // Public only for unit testing and relay testing\n-    // (not relayed)\n+    /** Public only for unit testing and relay testing (not relayed) */\n     std::vector<std::pair<unsigned int, uint256> > vMatchedTxn;\n \n-    // Create from a CBlock, filtering transactions according to filter\n-    // Note that this will call IsRelevantAndUpdate on the filter for each transaction,\n-    // thus the filter will likely be modified.\n+    /**\n+     * Create from a CBlock, filtering transactions according to filter\n+     * Note that this will call IsRelevantAndUpdate on the filter for each transaction,\n+     * thus the filter will likely be modified.\n+     */\n     CMerkleBlock(const CBlock& block, CBloomFilter& filter);\n \n     ADD_SERIALIZE_METHODS;"
      }
    ]
  }
]