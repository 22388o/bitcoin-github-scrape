[
  {
    "sha": "41c607f09badb2c3ed58ff6fb17a8ebbef2cdabd",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0MWM2MDdmMDliYWRiMmMzZWQ1OGZmNmZiMTdhOGViYmVmMmNkYWJk",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-06-27T23:53:48Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-07-13T21:27:31Z"
      },
      "message": "Implement PSBT Structures and un/serialization methods per BIP 174",
      "tree": {
        "sha": "5d64256ce892a04405c5f60962015643135e1bfa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5d64256ce892a04405c5f60962015643135e1bfa"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/41c607f09badb2c3ed58ff6fb17a8ebbef2cdabd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/41c607f09badb2c3ed58ff6fb17a8ebbef2cdabd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/41c607f09badb2c3ed58ff6fb17a8ebbef2cdabd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/41c607f09badb2c3ed58ff6fb17a8ebbef2cdabd/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "287e4edc2fd2514a0095273f01fe66b85ce10856",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/287e4edc2fd2514a0095273f01fe66b85ce10856",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/287e4edc2fd2514a0095273f01fe66b85ce10856"
      }
    ],
    "stats": {
      "total": 555,
      "additions": 555,
      "deletions": 0
    },
    "files": [
      {
        "sha": "0985273f343822e1b4dfaa3477782ee7d8859a49",
        "filename": "src/pubkey.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/41c607f09badb2c3ed58ff6fb17a8ebbef2cdabd/src/pubkey.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/41c607f09badb2c3ed58ff6fb17a8ebbef2cdabd/src/pubkey.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.h?ref=41c607f09badb2c3ed58ff6fb17a8ebbef2cdabd",
        "patch": "@@ -107,6 +107,7 @@ class CPubKey\n \n     //! Simple read-only vector-like interface to the pubkey data.\n     unsigned int size() const { return GetLen(vch[0]); }\n+    const unsigned char* data() const { return vch; }\n     const unsigned char* begin() const { return vch; }\n     const unsigned char* end() const { return vch + size(); }\n     const unsigned char& operator[](unsigned int pos) const { return vch[pos]; }"
      },
      {
        "sha": "afbcb22d189366bfa5950c7f61cbb88375878726",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/41c607f09badb2c3ed58ff6fb17a8ebbef2cdabd/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/41c607f09badb2c3ed58ff6fb17a8ebbef2cdabd/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=41c607f09badb2c3ed58ff6fb17a8ebbef2cdabd",
        "patch": "@@ -429,3 +429,19 @@ bool IsSolvable(const SigningProvider& provider, const CScript& script)\n     }\n     return false;\n }\n+\n+\n+bool PartiallySignedTransaction::IsNull() const\n+{\n+    return !tx && inputs.empty() && outputs.empty() && unknown.empty();\n+}\n+\n+bool PSBTInput::IsNull() const\n+{\n+    return !non_witness_utxo && witness_utxo.IsNull() && partial_sigs.empty() && unknown.empty() && hd_keypaths.empty() && redeem_script.empty() && witness_script.empty();\n+}\n+\n+bool PSBTOutput::IsNull() const\n+{\n+    return redeem_script.empty() && witness_script.empty() && hd_keypaths.empty() && unknown.empty();\n+}"
      },
      {
        "sha": "d1cf918610d605d8bb407ba5cde7b98554e53f90",
        "filename": "src/script/sign.h",
        "status": "modified",
        "additions": 538,
        "deletions": 0,
        "changes": 538,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/41c607f09badb2c3ed58ff6fb17a8ebbef2cdabd/src/script/sign.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/41c607f09badb2c3ed58ff6fb17a8ebbef2cdabd/src/script/sign.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.h?ref=41c607f09badb2c3ed58ff6fb17a8ebbef2cdabd",
        "patch": "@@ -6,7 +6,11 @@\n #ifndef BITCOIN_SCRIPT_SIGN_H\n #define BITCOIN_SCRIPT_SIGN_H\n \n+#include <boost/optional.hpp>\n+#include <hash.h>\n+#include <pubkey.h>\n #include <script/interpreter.h>\n+#include <streams.h>\n \n class CKey;\n class CKeyID;\n@@ -73,6 +77,540 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+// Magic bytes\n+static constexpr uint8_t PSBT_MAGIC_BYTES[5] = {'p', 's', 'b', 't', 0xff};\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key which indicates that this is the separator. The separator has no value.\n+static constexpr uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+template<typename Stream>\n+void DeserializeHDKeypaths(Stream& s, const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    // Make sure that the key is the size of pubkey + 1\n+    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+    }\n+    // Read in the pubkey from key\n+    CPubKey pubkey(key.begin() + 1, key.end());\n+    if (!pubkey.IsFullyValid()) {\n+       throw std::ios_base::failure(\"Invalid pubkey\");\n+    }\n+    if (hd_keypaths.count(pubkey) > 0) {\n+        throw std::ios_base::failure(\"Duplicate Key, pubkey derivation path already provided\");\n+    }\n+\n+    // Read in key path\n+    uint64_t value_len = ReadCompactSize(s);\n+    std::vector<uint32_t> keypath;\n+    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+        uint32_t index;\n+        s >> index;\n+        keypath.push_back(index);\n+    }\n+\n+    // Add to map\n+    hd_keypaths.emplace(pubkey, keypath);\n+}\n+\n+// Serialize HD keypaths to a stream from a map\n+template<typename Stream>\n+void SerializeHDKeypaths(Stream& s, const std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, uint8_t type)\n+{\n+    for (auto keypath_pair : hd_keypaths) {\n+        SerializeToVector(s, type, MakeSpan(keypath_pair.first));\n+        WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+        for (auto& path : keypath_pair.second) {\n+            s << path;\n+        }\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per-input information */\n+struct PSBTInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PSBTInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            SerializeHDKeypaths(s, hd_keypaths, PSBT_IN_BIP32_DERIVATION);\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // Read\n+            std::vector<unsigned char> key;\n+            s >> key;\n+\n+            // the key is empty if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key.empty()) return;\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    std::vector<unsigned char> sig;\n+                    s >> sig;\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, std::move(sig)));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    DeserializeHDKeypaths(s, key, hd_keypaths);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    std::vector<unsigned char> val_bytes;\n+                    s >> val_bytes;\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PSBTInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput\n+{\n+    CScript redeem_script;\n+    CScript witness_script;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    PSBTOutput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the redeem script\n+        if (!redeem_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_REDEEMSCRIPT);\n+            s << redeem_script;\n+        }\n+\n+        // Write the witness script\n+        if (!witness_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_WITNESSSCRIPT);\n+            s << witness_script;\n+        }\n+\n+        // Write any hd keypaths\n+        SerializeHDKeypaths(s, hd_keypaths, PSBT_OUT_BIP32_DERIVATION);\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // Read\n+            std::vector<unsigned char> key;\n+            s >> key;\n+\n+            // the key is empty if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key.empty()) return;\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_OUT_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_OUT_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_OUT_BIP32_DERIVATION:\n+                {\n+                    DeserializeHDKeypaths(s, key, hd_keypaths);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default: {\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    std::vector<unsigned char> val_bytes;\n+                    s >> val_bytes;\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PSBTOutput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    boost::optional<CMutableTransaction> tx;\n+    std::vector<PSBTInput> inputs;\n+    std::vector<PSBTOutput> outputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in) : tx(psbt_in.tx), inputs(psbt_in.inputs), outputs(psbt_in.outputs), unknown(psbt_in.unknown) {}\n+\n+    // Only checks if they refer to the same transaction\n+    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return a.tx->GetHash() == b.tx->GetHash();\n+    }\n+    friend bool operator!=(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return !(a == b);\n+    }\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES;\n+\n+        // unsigned tx flag\n+        SerializeToVector(s, PSBT_GLOBAL_UNSIGNED_TX);\n+\n+        // Write serialized tx to a stream\n+        SerializeToVector(s, *tx);\n+\n+        // Write the unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        // Write inputs\n+        for (const PSBTInput& input : inputs) {\n+            s << input;\n+        }\n+        // Write outputs\n+        for (const PSBTOutput& output : outputs) {\n+            s << output;\n+        }\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read the magic bytes\n+        uint8_t magic[5];\n+        s >> magic;\n+        if (!std::equal(magic, magic + 5, PSBT_MAGIC_BYTES)) {\n+            throw std::ios_base::failure(\"Invalid PSBT magic bytes\");\n+        }\n+\n+        // Read global data\n+        while(!s.empty()) {\n+            // Read\n+            std::vector<unsigned char> key;\n+            s >> key;\n+\n+            // the key is empty if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key.empty()) break;\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_GLOBAL_UNSIGNED_TX:\n+                {\n+                    if (tx) {\n+                        throw std::ios_base::failure(\"Duplicate Key, unsigned tx already provided\");\n+                    }\n+                    CMutableTransaction mtx;\n+                    UnserializeFromVector(s, mtx);\n+                    tx = std::move(mtx);\n+                    // Make sure that all scriptSigs and scriptWitnesses are empty\n+                    for (const CTxIn& txin : tx->vin) {\n+                        if (!txin.scriptSig.empty() || !txin.scriptWitness.IsNull()) {\n+                            throw std::ios_base::failure(\"Unsigned tx does not have empty scriptSigs and scriptWitnesses.\");\n+                        }\n+                    }\n+                    break;\n+                }\n+                // Unknown stuff\n+                default: {\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    std::vector<unsigned char> val_bytes;\n+                    s >> val_bytes;\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                }\n+            }\n+        }\n+\n+        // Make sure that we got an unsigned tx\n+        if (!tx) {\n+            throw std::ios_base::failure(\"No unsigned transcation was provided\");\n+        }\n+\n+        // Read input data\n+        unsigned int i = 0;\n+        while (!s.empty() && i < tx->vin.size()) {\n+            PSBTInput input;\n+            s >> input;\n+            inputs.push_back(input);\n+\n+            // Make sure the non-witness utxo matches the outpoint\n+            if (input.non_witness_utxo && input.non_witness_utxo->GetHash() != tx->vin[i].prevout.hash) {\n+                throw std::ios_base::failure(\"Non-witness UTXO does not match outpoint hash\");\n+            }\n+            ++i;\n+        }\n+        // Make sure that the number of inputs matches the number of inputs in the transaction\n+        if (inputs.size() != tx->vin.size()) {\n+            throw std::ios_base::failure(\"Inputs provided does not match the number of inputs in transaction.\");\n+        }\n+\n+        // Read output data\n+        i = 0;\n+        while (!s.empty() && i < tx->vout.size()) {\n+            PSBTOutput output;\n+            s >> output;\n+            outputs.push_back(output);\n+            ++i;\n+        }\n+        // Make sure that the number of outputs matches the number of outputs in the transaction\n+        if (outputs.size() != tx->vout.size()) {\n+            throw std::ios_base::failure(\"Outputs provided does not match the number of outputs in transaction.\");\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PartiallySignedTransaction(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n /** Produce a script signature using a generic signature creator. */\n bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreator& creator, const CScript& scriptPubKey, SignatureData& sigdata);\n "
      }
    ]
  },
  {
    "sha": "12bcc64f277f642ece03c25653e726f2276f0d51",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMmJjYzY0ZjI3N2Y2NDJlY2UwM2MyNTY1M2U3MjZmMjI3NmYwZDUx",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-06-27T23:56:30Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-07-13T21:27:31Z"
      },
      "message": "Add pubkeys and whether input was witness to SignatureData\n\nStores pubkeys in SignatureData and retrieves them when using GetPubKey().\n\nStores whether the signatures in a SignatureData are for a witness input.",
      "tree": {
        "sha": "94a1f3ba80ee473286ab601ffe21cd2f4c0acf30",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/94a1f3ba80ee473286ab601ffe21cd2f4c0acf30"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/12bcc64f277f642ece03c25653e726f2276f0d51",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/12bcc64f277f642ece03c25653e726f2276f0d51",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/12bcc64f277f642ece03c25653e726f2276f0d51",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/12bcc64f277f642ece03c25653e726f2276f0d51/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "41c607f09badb2c3ed58ff6fb17a8ebbef2cdabd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/41c607f09badb2c3ed58ff6fb17a8ebbef2cdabd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/41c607f09badb2c3ed58ff6fb17a8ebbef2cdabd"
      }
    ],
    "stats": {
      "total": 19,
      "additions": 16,
      "deletions": 3
    },
    "files": [
      {
        "sha": "b62fe2e92eaebf3b8f9ea326935679a180a985e2",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 3,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/12bcc64f277f642ece03c25653e726f2276f0d51/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/12bcc64f277f642ece03c25653e726f2276f0d51/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=12bcc64f277f642ece03c25653e726f2276f0d51",
        "patch": "@@ -49,9 +49,10 @@ static bool GetCScript(const SigningProvider& provider, const SignatureData& sig\n     return false;\n }\n \n-static bool GetPubKey(const SigningProvider& provider, const SignatureData& sigdata, const CKeyID& address, CPubKey& pubkey)\n+static bool GetPubKey(const SigningProvider& provider, SignatureData& sigdata, const CKeyID& address, CPubKey& pubkey)\n {\n     if (provider.GetPubKey(address, pubkey)) {\n+        sigdata.misc_pubkeys.emplace(pubkey.GetID(), pubkey);\n         return true;\n     }\n     // Look for pubkey in all partial sigs\n@@ -60,6 +61,12 @@ static bool GetPubKey(const SigningProvider& provider, const SignatureData& sigd\n         pubkey = it->second.first;\n         return true;\n     }\n+    // Look for pubkey in pubkey list\n+    const auto& pk_it = sigdata.misc_pubkeys.find(address);\n+    if (pk_it != sigdata.misc_pubkeys.end()) {\n+        pubkey = pk_it->second;\n+        return true;\n+    }\n     return false;\n }\n \n@@ -70,9 +77,9 @@ static bool CreateSig(const BaseSignatureCreator& creator, SignatureData& sigdat\n         sig_out = it->second.second;\n         return true;\n     }\n+    CPubKey pubkey;\n+    GetPubKey(provider, sigdata, keyid, pubkey);\n     if (creator.CreateSig(provider, sig_out, keyid, scriptcode, sigversion)) {\n-        CPubKey pubkey;\n-        GetPubKey(provider, sigdata, keyid, pubkey);\n         auto i = sigdata.signatures.emplace(keyid, SigPair(pubkey, sig_out));\n         assert(i.second);\n         return true;\n@@ -200,6 +207,7 @@ bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreato\n         txnouttype subType;\n         solved = solved && SignStep(provider, creator, witnessscript, result, subType, SigVersion::WITNESS_V0, sigdata);\n         sigdata.scriptWitness.stack = result;\n+        sigdata.witness = true;\n         result.clear();\n     }\n     else if (solved && whichType == TX_WITNESS_V0_SCRIPTHASH)\n@@ -210,7 +218,10 @@ bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreato\n         solved = solved && SignStep(provider, creator, witnessscript, result, subType, SigVersion::WITNESS_V0, sigdata) && subType != TX_SCRIPTHASH && subType != TX_WITNESS_V0_SCRIPTHASH && subType != TX_WITNESS_V0_KEYHASH;\n         result.push_back(std::vector<unsigned char>(witnessscript.begin(), witnessscript.end()));\n         sigdata.scriptWitness.stack = result;\n+        sigdata.witness = true;\n         result.clear();\n+    } else if (solved && whichType == TX_WITNESS_UNKNOWN) {\n+        sigdata.witness = true;\n     }\n \n     if (P2SH) {"
      },
      {
        "sha": "5384f9753938919985c59945535acbb0adff1ec3",
        "filename": "src/script/sign.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/12bcc64f277f642ece03c25653e726f2276f0d51/src/script/sign.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/12bcc64f277f642ece03c25653e726f2276f0d51/src/script/sign.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.h?ref=12bcc64f277f642ece03c25653e726f2276f0d51",
        "patch": "@@ -66,11 +66,13 @@ typedef std::pair<CPubKey, std::vector<unsigned char>> SigPair;\n // in order to construct final scriptSigs and scriptWitnesses.\n struct SignatureData {\n     bool complete = false; ///< Stores whether the scriptSig and scriptWitness are complete\n+    bool witness = false; ///< Stores whether the input this SigData corresponds to is a witness input\n     CScript scriptSig; ///< The scriptSig of an input. Contains complete signatures or the traditional partial signatures format\n     CScript redeem_script; ///< The redeemScript (if any) for the input\n     CScript witness_script; ///< The witnessScript (if any) for the input. witnessScripts are used in P2WSH outputs.\n     CScriptWitness scriptWitness; ///< The scriptWitness of an input. Contains complete signatures or the traditional partial signatures format. scriptWitness is part of a transaction input per BIP 144.\n     std::map<CKeyID, SigPair> signatures; ///< BIP 174 style partial signatures for the input. May contain all signatures necessary for producing a final scriptSig or scriptWitness.\n+    std::map<CKeyID, CPubKey> misc_pubkeys;\n \n     SignatureData() {}\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}"
      }
    ]
  },
  {
    "sha": "e9d86a43ad8b1ab83b324e9a7a64c43a61337501",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplOWQ4NmE0M2FkOGIxYWI4M2IzMjRlOWE3YTY0YzQzYTYxMzM3NTAx",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-06-27T23:58:01Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-07-13T21:27:31Z"
      },
      "message": "Methods for interacting with PSBT structs\n\nAdded methods which move data to/from SignaturData objects to\nPSBTInput and PSBTOutput objects.\n\nAdded sanity checks for PSBTs as a whole which are done immediately\nafter deserialization.\n\nAdded Merge methods to merge a PSBT into another one.",
      "tree": {
        "sha": "40a105b868ba62d9b7861d6e80e8c38371107930",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/40a105b868ba62d9b7861d6e80e8c38371107930"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e9d86a43ad8b1ab83b324e9a7a64c43a61337501",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e9d86a43ad8b1ab83b324e9a7a64c43a61337501",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e9d86a43ad8b1ab83b324e9a7a64c43a61337501",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e9d86a43ad8b1ab83b324e9a7a64c43a61337501/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "12bcc64f277f642ece03c25653e726f2276f0d51",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/12bcc64f277f642ece03c25653e726f2276f0d51",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/12bcc64f277f642ece03c25653e726f2276f0d51"
      }
    ],
    "stats": {
      "total": 146,
      "additions": 146,
      "deletions": 0
    },
    "files": [
      {
        "sha": "28dfdecdfc9433e040eecfa3ea05c84f8160508b",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 132,
        "deletions": 0,
        "changes": 132,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e9d86a43ad8b1ab83b324e9a7a64c43a61337501/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e9d86a43ad8b1ab83b324e9a7a64c43a61337501/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=e9d86a43ad8b1ab83b324e9a7a64c43a61337501",
        "patch": "@@ -447,12 +447,144 @@ bool PartiallySignedTransaction::IsNull() const\n     return !tx && inputs.empty() && outputs.empty() && unknown.empty();\n }\n \n+void PartiallySignedTransaction::Merge(const PartiallySignedTransaction& psbt)\n+{\n+    for (unsigned int i = 0; i < inputs.size(); ++i) {\n+        inputs[i].Merge(psbt.inputs[i]);\n+    }\n+    for (unsigned int i = 0; i < outputs.size(); ++i) {\n+        outputs[i].Merge(psbt.outputs[i]);\n+    }\n+}\n+\n+bool PartiallySignedTransaction::IsSane() const\n+{\n+    for (PSBTInput input : inputs) {\n+        if (!input.IsSane()) return false;\n+    }\n+    return true;\n+}\n+\n bool PSBTInput::IsNull() const\n {\n     return !non_witness_utxo && witness_utxo.IsNull() && partial_sigs.empty() && unknown.empty() && hd_keypaths.empty() && redeem_script.empty() && witness_script.empty();\n }\n \n+void PSBTInput::FillSignatureData(SignatureData& sigdata) const\n+{\n+    if (!final_script_sig.empty()) {\n+        sigdata.scriptSig = final_script_sig;\n+        sigdata.complete = true;\n+    }\n+    if (!final_script_witness.IsNull()) {\n+        sigdata.scriptWitness = final_script_witness;\n+        sigdata.complete = true;\n+    }\n+    if (sigdata.complete) {\n+        return;\n+    }\n+\n+    sigdata.signatures.insert(partial_sigs.begin(), partial_sigs.end());\n+    if (!redeem_script.empty()) {\n+        sigdata.redeem_script = redeem_script;\n+    }\n+    if (!witness_script.empty()) {\n+        sigdata.witness_script = witness_script;\n+    }\n+    for (const auto& key_pair : hd_keypaths) {\n+        sigdata.misc_pubkeys.emplace(key_pair.first.GetID(), key_pair.first);\n+    }\n+}\n+\n+void PSBTInput::FromSignatureData(const SignatureData& sigdata)\n+{\n+    if (sigdata.complete) {\n+        partial_sigs.clear();\n+        hd_keypaths.clear();\n+        redeem_script.clear();\n+        witness_script.clear();\n+\n+        if (!sigdata.scriptSig.empty()) {\n+            final_script_sig = sigdata.scriptSig;\n+        }\n+        if (!sigdata.scriptWitness.IsNull()) {\n+            final_script_witness = sigdata.scriptWitness;\n+        }\n+        return;\n+    }\n+\n+    partial_sigs.insert(sigdata.signatures.begin(), sigdata.signatures.end());\n+    if (redeem_script.empty() && !sigdata.redeem_script.empty()) {\n+        redeem_script = sigdata.redeem_script;\n+    }\n+    if (witness_script.empty() && !sigdata.witness_script.empty()) {\n+        witness_script = sigdata.witness_script;\n+    }\n+}\n+\n+void PSBTInput::Merge(const PSBTInput& input)\n+{\n+    if (!non_witness_utxo && input.non_witness_utxo) non_witness_utxo = input.non_witness_utxo;\n+    if (witness_utxo.IsNull() && !input.witness_utxo.IsNull()) {\n+        witness_utxo = input.witness_utxo;\n+        non_witness_utxo = nullptr; // Clear out any non-witness utxo when we set a witness one.\n+    }\n+\n+    partial_sigs.insert(input.partial_sigs.begin(), input.partial_sigs.end());\n+    hd_keypaths.insert(input.hd_keypaths.begin(), input.hd_keypaths.end());\n+    unknown.insert(input.unknown.begin(), input.unknown.end());\n+\n+    if (redeem_script.empty() && !input.redeem_script.empty()) redeem_script = input.redeem_script;\n+    if (witness_script.empty() && !input.witness_script.empty()) witness_script = input.witness_script;\n+    if (final_script_sig.empty() && !input.final_script_sig.empty()) final_script_sig = input.final_script_sig;\n+    if (final_script_witness.IsNull() && !input.final_script_witness.IsNull()) final_script_witness = input.final_script_witness;\n+}\n+\n+bool PSBTInput::IsSane() const\n+{\n+    // Cannot have both witness and non-witness utxos\n+    if (!witness_utxo.IsNull() && non_witness_utxo) return false;\n+\n+    // If we have a witness_script or a scriptWitness, we must also have a witness utxo\n+    if (!witness_script.empty() && witness_utxo.IsNull()) return false;\n+    if (!final_script_witness.IsNull() && witness_utxo.IsNull()) return false;\n+\n+    return true;\n+}\n+\n+void PSBTOutput::FillSignatureData(SignatureData& sigdata) const\n+{\n+    if (!redeem_script.empty()) {\n+        sigdata.redeem_script = redeem_script;\n+    }\n+    if (!witness_script.empty()) {\n+        sigdata.witness_script = witness_script;\n+    }\n+    for (const auto& key_pair : hd_keypaths) {\n+        sigdata.misc_pubkeys.emplace(key_pair.first.GetID(), key_pair.first);\n+    }\n+}\n+\n+void PSBTOutput::FromSignatureData(const SignatureData& sigdata)\n+{\n+    if (redeem_script.empty() && !sigdata.redeem_script.empty()) {\n+        redeem_script = sigdata.redeem_script;\n+    }\n+    if (witness_script.empty() && !sigdata.witness_script.empty()) {\n+        witness_script = sigdata.witness_script;\n+    }\n+}\n+\n bool PSBTOutput::IsNull() const\n {\n     return redeem_script.empty() && witness_script.empty() && hd_keypaths.empty() && unknown.empty();\n }\n+\n+void PSBTOutput::Merge(const PSBTOutput& output)\n+{\n+    hd_keypaths.insert(output.hd_keypaths.begin(), output.hd_keypaths.end());\n+    unknown.insert(output.unknown.begin(), output.unknown.end());\n+\n+    if (redeem_script.empty() && !output.redeem_script.empty()) redeem_script = output.redeem_script;\n+    if (witness_script.empty() && !output.witness_script.empty()) witness_script = output.witness_script;\n+}"
      },
      {
        "sha": "ab2153e3b920079ff5e4afdbc6a63e28b20b7308",
        "filename": "src/script/sign.h",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e9d86a43ad8b1ab83b324e9a7a64c43a61337501/src/script/sign.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e9d86a43ad8b1ab83b324e9a7a64c43a61337501/src/script/sign.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.h?ref=e9d86a43ad8b1ab83b324e9a7a64c43a61337501",
        "patch": "@@ -187,6 +187,10 @@ struct PSBTInput\n     int sighash_type = 0;\n \n     bool IsNull() const;\n+    void FillSignatureData(SignatureData& sigdata) const;\n+    void FromSignatureData(const SignatureData& sigdata);\n+    void Merge(const PSBTInput& input);\n+    bool IsSane() const;\n     PSBTInput() {}\n \n     template <typename Stream>\n@@ -375,6 +379,10 @@ struct PSBTOutput\n     std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n \n     bool IsNull() const;\n+    void FillSignatureData(SignatureData& sigdata) const;\n+    void FromSignatureData(const SignatureData& sigdata);\n+    void Merge(const PSBTOutput& output);\n+    bool IsSane() const;\n     PSBTOutput() {}\n \n     template <typename Stream>\n@@ -472,6 +480,8 @@ struct PartiallySignedTransaction\n     std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n \n     bool IsNull() const;\n+    void Merge(const PartiallySignedTransaction& psbt);\n+    bool IsSane() const;\n     PartiallySignedTransaction() {}\n     PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in) : tx(psbt_in.tx), inputs(psbt_in.inputs), outputs(psbt_in.outputs), unknown(psbt_in.unknown) {}\n \n@@ -605,6 +615,10 @@ struct PartiallySignedTransaction\n         if (outputs.size() != tx->vout.size()) {\n             throw std::ios_base::failure(\"Outputs provided does not match the number of outputs in transaction.\");\n         }\n+        // Sanity check\n+        if (!IsSane()) {\n+            throw std::ios_base::failure(\"PSBT is not sane.\");\n+        }\n     }\n \n     template <typename Stream>"
      }
    ]
  },
  {
    "sha": "58a8e28918025c28f19ba19cbaa4a72374162942",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1OGE4ZTI4OTE4MDI1YzI4ZjE5YmExOWNiYWE0YTcyMzc0MTYyOTQy",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-06-28T00:02:07Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-07-13T21:27:31Z"
      },
      "message": "Refactor transaction creation and transaction funding logic\n\nIn preparation for more create transaction and fund transcation RPCs,\nrefactor the transaction creation and funding logic into separate\nfunctions.",
      "tree": {
        "sha": "0970665902001b81b521753d146d065f6e04e401",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0970665902001b81b521753d146d065f6e04e401"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/58a8e28918025c28f19ba19cbaa4a72374162942",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/58a8e28918025c28f19ba19cbaa4a72374162942",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/58a8e28918025c28f19ba19cbaa4a72374162942",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/58a8e28918025c28f19ba19cbaa4a72374162942/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e9d86a43ad8b1ab83b324e9a7a64c43a61337501",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e9d86a43ad8b1ab83b324e9a7a64c43a61337501",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e9d86a43ad8b1ab83b324e9a7a64c43a61337501"
      }
    ],
    "stats": {
      "total": 320,
      "additions": 166,
      "deletions": 154
    },
    "files": [
      {
        "sha": "c27601e47f16ca268b7438f92a44c1c263ea32ba",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 70,
        "deletions": 64,
        "changes": 134,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/58a8e28918025c28f19ba19cbaa4a72374162942/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/58a8e28918025c28f19ba19cbaa4a72374162942/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=58a8e28918025c28f19ba19cbaa4a72374162942",
        "patch": "@@ -332,80 +332,25 @@ static UniValue verifytxoutproof(const JSONRPCRequest& request)\n     return res;\n }\n \n-static UniValue createrawtransaction(const JSONRPCRequest& request)\n+CMutableTransaction ConstructTransaction(const UniValue& inputs_in, const UniValue& outputs_in, const UniValue& locktime, const UniValue& rbf)\n {\n-    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4) {\n-        throw std::runtime_error(\n-            // clang-format off\n-            \"createrawtransaction [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable )\\n\"\n-            \"\\nCreate a transaction spending the given inputs and creating new outputs.\\n\"\n-            \"Outputs can be addresses or data.\\n\"\n-            \"Returns hex-encoded raw transaction.\\n\"\n-            \"Note that the transaction's inputs are not signed, and\\n\"\n-            \"it is not stored in the wallet or transmitted to the network.\\n\"\n-\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"inputs\\\"                (array, required) A json array of json objects\\n\"\n-            \"     [\\n\"\n-            \"       {\\n\"\n-            \"         \\\"txid\\\":\\\"id\\\",      (string, required) The transaction id\\n\"\n-            \"         \\\"vout\\\":n,         (numeric, required) The output number\\n\"\n-            \"         \\\"sequence\\\":n      (numeric, optional) The sequence number\\n\"\n-            \"       } \\n\"\n-            \"       ,...\\n\"\n-            \"     ]\\n\"\n-            \"2. \\\"outputs\\\"               (array, required) a json array with outputs (key-value pairs)\\n\"\n-            \"   [\\n\"\n-            \"    {\\n\"\n-            \"      \\\"address\\\": x.xxx,    (obj, optional) A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\\n\"\n-            \"    },\\n\"\n-            \"    {\\n\"\n-            \"      \\\"data\\\": \\\"hex\\\"        (obj, optional) A key-value pair. The key must be \\\"data\\\", the value is hex encoded data\\n\"\n-            \"    }\\n\"\n-            \"    ,...                     More key-value pairs of the above form. For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n-            \"                             accepted as second parameter.\\n\"\n-            \"   ]\\n\"\n-            \"3. locktime                  (numeric, optional, default=0) Raw locktime. Non-0 value also locktime-activates inputs\\n\"\n-            \"4. replaceable               (boolean, optional, default=false) Marks this transaction as BIP125 replaceable.\\n\"\n-            \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\\n\"\n-            \"\\nResult:\\n\"\n-            \"\\\"transaction\\\"              (string) hex string of the transaction\\n\"\n-\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"address\\\\\\\":0.01}]\\\"\")\n-            + HelpExampleCli(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")\n-            + HelpExampleRpc(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\", \\\"[{\\\\\\\"address\\\\\\\":0.01}]\\\"\")\n-            + HelpExampleRpc(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\", \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")\n-            // clang-format on\n-        );\n-    }\n-\n-    RPCTypeCheck(request.params, {\n-        UniValue::VARR,\n-        UniValueType(), // ARR or OBJ, checked later\n-        UniValue::VNUM,\n-        UniValue::VBOOL\n-        }, true\n-    );\n-    if (request.params[0].isNull() || request.params[1].isNull())\n+    if (inputs_in.isNull() || outputs_in.isNull())\n         throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, arguments 1 and 2 must be non-null\");\n \n-    UniValue inputs = request.params[0].get_array();\n-    const bool outputs_is_obj = request.params[1].isObject();\n-    UniValue outputs = outputs_is_obj ?\n-                           request.params[1].get_obj() :\n-                           request.params[1].get_array();\n+    UniValue inputs = inputs_in.get_array();\n+    const bool outputs_is_obj = outputs_in.isObject();\n+    UniValue outputs = outputs_is_obj ? outputs_in.get_obj() : outputs_in.get_array();\n \n     CMutableTransaction rawTx;\n \n-    if (!request.params[2].isNull()) {\n-        int64_t nLockTime = request.params[2].get_int64();\n+    if (!locktime.isNull()) {\n+        int64_t nLockTime = locktime.get_int64();\n         if (nLockTime < 0 || nLockTime > std::numeric_limits<uint32_t>::max())\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, locktime out of range\");\n         rawTx.nLockTime = nLockTime;\n     }\n \n-    bool rbfOptIn = request.params[3].isTrue();\n+    bool rbfOptIn = rbf.isTrue();\n \n     for (unsigned int idx = 0; idx < inputs.size(); idx++) {\n         const UniValue& input = inputs[idx];\n@@ -485,10 +430,71 @@ static UniValue createrawtransaction(const JSONRPCRequest& request)\n         }\n     }\n \n-    if (!request.params[3].isNull() && rbfOptIn != SignalsOptInRBF(rawTx)) {\n+    if (!rbf.isNull() && rbfOptIn != SignalsOptInRBF(rawTx)) {\n         throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter combination: Sequence number(s) contradict replaceable option\");\n     }\n \n+    return rawTx;\n+}\n+\n+static UniValue createrawtransaction(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4) {\n+        throw std::runtime_error(\n+            // clang-format off\n+            \"createrawtransaction [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable )\\n\"\n+            \"\\nCreate a transaction spending the given inputs and creating new outputs.\\n\"\n+            \"Outputs can be addresses or data.\\n\"\n+            \"Returns hex-encoded raw transaction.\\n\"\n+            \"Note that the transaction's inputs are not signed, and\\n\"\n+            \"it is not stored in the wallet or transmitted to the network.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"inputs\\\"                (array, required) A json array of json objects\\n\"\n+            \"     [\\n\"\n+            \"       {\\n\"\n+            \"         \\\"txid\\\":\\\"id\\\",      (string, required) The transaction id\\n\"\n+            \"         \\\"vout\\\":n,         (numeric, required) The output number\\n\"\n+            \"         \\\"sequence\\\":n      (numeric, optional) The sequence number\\n\"\n+            \"       } \\n\"\n+            \"       ,...\\n\"\n+            \"     ]\\n\"\n+            \"2. \\\"outputs\\\"               (array, required) a json array with outputs (key-value pairs)\\n\"\n+            \"   [\\n\"\n+            \"    {\\n\"\n+            \"      \\\"address\\\": x.xxx,    (obj, optional) A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\\n\"\n+            \"    },\\n\"\n+            \"    {\\n\"\n+            \"      \\\"data\\\": \\\"hex\\\"        (obj, optional) A key-value pair. The key must be \\\"data\\\", the value is hex encoded data\\n\"\n+            \"    }\\n\"\n+            \"    ,...                     More key-value pairs of the above form. For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n+            \"                             accepted as second parameter.\\n\"\n+            \"   ]\\n\"\n+            \"3. locktime                  (numeric, optional, default=0) Raw locktime. Non-0 value also locktime-activates inputs\\n\"\n+            \"4. replaceable               (boolean, optional, default=false) Marks this transaction as BIP125 replaceable.\\n\"\n+            \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\\n\"\n+            \"\\nResult:\\n\"\n+            \"\\\"transaction\\\"              (string) hex string of the transaction\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"address\\\\\\\":0.01}]\\\"\")\n+            + HelpExampleCli(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")\n+            + HelpExampleRpc(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\", \\\"[{\\\\\\\"address\\\\\\\":0.01}]\\\"\")\n+            + HelpExampleRpc(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\", \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")\n+            // clang-format on\n+        );\n+    }\n+\n+    RPCTypeCheck(request.params, {\n+        UniValue::VARR,\n+        UniValueType(), // ARR or OBJ, checked later\n+        UniValue::VNUM,\n+        UniValue::VBOOL\n+        }, true\n+    );\n+\n+    CMutableTransaction rawTx = ConstructTransaction(request.params[0], request.params[1], request.params[2], request.params[3]);\n+\n     return EncodeHexTx(rawTx);\n }\n "
      },
      {
        "sha": "52dccc90e840837b7184c4b4ad1333eb5dcc3580",
        "filename": "src/rpc/rawtransaction.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/58a8e28918025c28f19ba19cbaa4a72374162942/src/rpc/rawtransaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/58a8e28918025c28f19ba19cbaa4a72374162942/src/rpc/rawtransaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.h?ref=58a8e28918025c28f19ba19cbaa4a72374162942",
        "patch": "@@ -12,4 +12,7 @@ class UniValue;\n /** Sign a transaction with the given keystore and previous transactions */\n UniValue SignTransaction(CMutableTransaction& mtx, const UniValue& prevTxs, CBasicKeyStore *keystore, bool tempKeystore, const UniValue& hashType);\n \n+/** Create a transaction from univalue parameters */\n+CMutableTransaction ConstructTransaction(const UniValue& inputs_in, const UniValue& outputs_in, const UniValue& locktime, const UniValue& rbf);\n+\n #endif // BITCOIN_RPC_RAWTRANSACTION_H"
      },
      {
        "sha": "7cd9f4cfd36ce7e5a161d84730e1e8205c96d9ca",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 93,
        "deletions": 90,
        "changes": 183,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/58a8e28918025c28f19ba19cbaa4a72374162942/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/58a8e28918025c28f19ba19cbaa4a72374162942/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=58a8e28918025c28f19ba19cbaa4a72374162942",
        "patch": "@@ -3419,95 +3419,25 @@ static UniValue listunspent(const JSONRPCRequest& request)\n     return results;\n }\n \n-static UniValue fundrawtransaction(const JSONRPCRequest& request)\n+void FundTransaction(CWallet* const pwallet, CMutableTransaction& tx, CAmount& fee_out, int& change_position, UniValue options)\n {\n-    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n-    CWallet* const pwallet = wallet.get();\n-\n-    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n-        return NullUniValue;\n-    }\n-\n-    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n-        throw std::runtime_error(\n-                            \"fundrawtransaction \\\"hexstring\\\" ( options iswitness )\\n\"\n-                            \"\\nAdd inputs to a transaction until it has enough in value to meet its out value.\\n\"\n-                            \"This will not modify existing inputs, and will add at most one change output to the outputs.\\n\"\n-                            \"No existing outputs will be modified unless \\\"subtractFeeFromOutputs\\\" is specified.\\n\"\n-                            \"Note that inputs which were signed may need to be resigned after completion since in/outputs have been added.\\n\"\n-                            \"The inputs added will not be signed, use signrawtransaction for that.\\n\"\n-                            \"Note that all existing inputs must have their previous output transaction be in the wallet.\\n\"\n-                            \"Note that all inputs selected must be of standard form and P2SH scripts must be\\n\"\n-                            \"in the wallet using importaddress or addmultisigaddress (to calculate fees).\\n\"\n-                            \"You can see whether this is the case by checking the \\\"solvable\\\" field in the listunspent output.\\n\"\n-                            \"Only pay-to-pubkey, multisig, and P2SH versions thereof are currently supported for watch-only\\n\"\n-                            \"\\nArguments:\\n\"\n-                            \"1. \\\"hexstring\\\"           (string, required) The hex string of the raw transaction\\n\"\n-                            \"2. options                 (object, optional)\\n\"\n-                            \"   {\\n\"\n-                            \"     \\\"changeAddress\\\"          (string, optional, default pool address) The bitcoin address to receive the change\\n\"\n-                            \"     \\\"changePosition\\\"         (numeric, optional, default random) The index of the change output\\n\"\n-                            \"     \\\"change_type\\\"            (string, optional) The output type to use. Only valid if changeAddress is not specified. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\". Default is set by -changetype.\\n\"\n-                            \"     \\\"includeWatching\\\"        (boolean, optional, default false) Also select inputs which are watch only\\n\"\n-                            \"     \\\"lockUnspents\\\"           (boolean, optional, default false) Lock selected unspent outputs\\n\"\n-                            \"     \\\"feeRate\\\"                (numeric, optional, default not set: makes wallet determine the fee) Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"\n-                            \"     \\\"subtractFeeFromOutputs\\\" (array, optional) A json array of integers.\\n\"\n-                            \"                              The fee will be equally deducted from the amount of each specified output.\\n\"\n-                            \"                              The outputs are specified by their zero-based index, before any change output is added.\\n\"\n-                            \"                              Those recipients will receive less bitcoins than you enter in their corresponding amount field.\\n\"\n-                            \"                              If no outputs are specified here, the sender pays the fee.\\n\"\n-                            \"                                  [vout_index,...]\\n\"\n-                            \"     \\\"replaceable\\\"            (boolean, optional) Marks this transaction as BIP125 replaceable.\\n\"\n-                            \"                              Allows this transaction to be replaced by a transaction with higher fees\\n\"\n-                            \"     \\\"conf_target\\\"            (numeric, optional) Confirmation target (in blocks)\\n\"\n-                            \"     \\\"estimate_mode\\\"          (string, optional, default=UNSET) The fee estimate mode, must be one of:\\n\"\n-                            \"         \\\"UNSET\\\"\\n\"\n-                            \"         \\\"ECONOMICAL\\\"\\n\"\n-                            \"         \\\"CONSERVATIVE\\\"\\n\"\n-                            \"   }\\n\"\n-                            \"                         for backward compatibility: passing in a true instead of an object will result in {\\\"includeWatching\\\":true}\\n\"\n-                            \"3. iswitness               (boolean, optional) Whether the transaction hex is a serialized witness transaction \\n\"\n-                            \"                              If iswitness is not present, heuristic tests will be used in decoding\\n\"\n-\n-                            \"\\nResult:\\n\"\n-                            \"{\\n\"\n-                            \"  \\\"hex\\\":       \\\"value\\\", (string)  The resulting raw transaction (hex-encoded string)\\n\"\n-                            \"  \\\"fee\\\":       n,         (numeric) Fee in \" + CURRENCY_UNIT + \" the resulting transaction pays\\n\"\n-                            \"  \\\"changepos\\\": n          (numeric) The position of the added change output, or -1\\n\"\n-                            \"}\\n\"\n-                            \"\\nExamples:\\n\"\n-                            \"\\nCreate a transaction with no inputs\\n\"\n-                            + HelpExampleCli(\"createrawtransaction\", \"\\\"[]\\\" \\\"{\\\\\\\"myaddress\\\\\\\":0.01}\\\"\") +\n-                            \"\\nAdd sufficient unsigned inputs to meet the output value\\n\"\n-                            + HelpExampleCli(\"fundrawtransaction\", \"\\\"rawtransactionhex\\\"\") +\n-                            \"\\nSign the transaction\\n\"\n-                            + HelpExampleCli(\"signrawtransaction\", \"\\\"fundedtransactionhex\\\"\") +\n-                            \"\\nSend the transaction\\n\"\n-                            + HelpExampleCli(\"sendrawtransaction\", \"\\\"signedtransactionhex\\\"\")\n-                            );\n-\n-    RPCTypeCheck(request.params, {UniValue::VSTR});\n-\n     // Make sure the results are valid at least up to the most recent block\n     // the user could have gotten from another RPC command prior to now\n     pwallet->BlockUntilSyncedToCurrentChain();\n \n     CCoinControl coinControl;\n-    int changePosition = -1;\n+    change_position = -1;\n     bool lockUnspents = false;\n     UniValue subtractFeeFromOutputs;\n     std::set<int> setSubtractFeeFromOutputs;\n \n-    if (!request.params[1].isNull()) {\n-      if (request.params[1].type() == UniValue::VBOOL) {\n+    if (!options.isNull()) {\n+      if (options.type() == UniValue::VBOOL) {\n         // backward compatibility bool only fallback\n-        coinControl.fAllowWatchOnly = request.params[1].get_bool();\n+        coinControl.fAllowWatchOnly = options.get_bool();\n       }\n       else {\n-        RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VOBJ, UniValue::VBOOL});\n-\n-        UniValue options = request.params[1];\n-\n+        RPCTypeCheckArgument(options, UniValue::VOBJ);\n         RPCTypeCheckObj(options,\n             {\n                 {\"changeAddress\", UniValueType(UniValue::VSTR)},\n@@ -3534,7 +3464,7 @@ static UniValue fundrawtransaction(const JSONRPCRequest& request)\n         }\n \n         if (options.exists(\"changePosition\"))\n-            changePosition = options[\"changePosition\"].get_int();\n+            change_position = options[\"changePosition\"].get_int();\n \n         if (options.exists(\"change_type\")) {\n             if (options.exists(\"changeAddress\")) {\n@@ -3581,18 +3511,10 @@ static UniValue fundrawtransaction(const JSONRPCRequest& request)\n       }\n     }\n \n-    // parse hex string from parameter\n-    CMutableTransaction tx;\n-    bool try_witness = request.params[2].isNull() ? true : request.params[2].get_bool();\n-    bool try_no_witness = request.params[2].isNull() ? true : !request.params[2].get_bool();\n-    if (!DecodeHexTx(tx, request.params[0].get_str(), try_no_witness, try_witness)) {\n-        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n-    }\n-\n     if (tx.vout.size() == 0)\n         throw JSONRPCError(RPC_INVALID_PARAMETER, \"TX must have at least one output\");\n \n-    if (changePosition != -1 && (changePosition < 0 || (unsigned int)changePosition > tx.vout.size()))\n+    if (change_position != -1 && (change_position < 0 || (unsigned int)change_position > tx.vout.size()))\n         throw JSONRPCError(RPC_INVALID_PARAMETER, \"changePosition out of bounds\");\n \n     for (unsigned int idx = 0; idx < subtractFeeFromOutputs.size(); idx++) {\n@@ -3606,17 +3528,98 @@ static UniValue fundrawtransaction(const JSONRPCRequest& request)\n         setSubtractFeeFromOutputs.insert(pos);\n     }\n \n-    CAmount nFeeOut;\n     std::string strFailReason;\n \n-    if (!pwallet->FundTransaction(tx, nFeeOut, changePosition, strFailReason, lockUnspents, setSubtractFeeFromOutputs, coinControl)) {\n+    if (!pwallet->FundTransaction(tx, fee_out, change_position, strFailReason, lockUnspents, setSubtractFeeFromOutputs, coinControl)) {\n         throw JSONRPCError(RPC_WALLET_ERROR, strFailReason);\n     }\n+}\n+\n+static UniValue fundrawtransaction(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+                            \"fundrawtransaction \\\"hexstring\\\" ( options iswitness )\\n\"\n+                            \"\\nAdd inputs to a transaction until it has enough in value to meet its out value.\\n\"\n+                            \"This will not modify existing inputs, and will add at most one change output to the outputs.\\n\"\n+                            \"No existing outputs will be modified unless \\\"subtractFeeFromOutputs\\\" is specified.\\n\"\n+                            \"Note that inputs which were signed may need to be resigned after completion since in/outputs have been added.\\n\"\n+                            \"The inputs added will not be signed, use signrawtransaction for that.\\n\"\n+                            \"Note that all existing inputs must have their previous output transaction be in the wallet.\\n\"\n+                            \"Note that all inputs selected must be of standard form and P2SH scripts must be\\n\"\n+                            \"in the wallet using importaddress or addmultisigaddress (to calculate fees).\\n\"\n+                            \"You can see whether this is the case by checking the \\\"solvable\\\" field in the listunspent output.\\n\"\n+                            \"Only pay-to-pubkey, multisig, and P2SH versions thereof are currently supported for watch-only\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"hexstring\\\"           (string, required) The hex string of the raw transaction\\n\"\n+                            \"2. options                 (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"changeAddress\\\"          (string, optional, default pool address) The bitcoin address to receive the change\\n\"\n+                            \"     \\\"changePosition\\\"         (numeric, optional, default random) The index of the change output\\n\"\n+                            \"     \\\"change_type\\\"            (string, optional) The output type to use. Only valid if changeAddress is not specified. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\". Default is set by -changetype.\\n\"\n+                            \"     \\\"includeWatching\\\"        (boolean, optional, default false) Also select inputs which are watch only\\n\"\n+                            \"     \\\"lockUnspents\\\"           (boolean, optional, default false) Lock selected unspent outputs\\n\"\n+                            \"     \\\"feeRate\\\"                (numeric, optional, default not set: makes wallet determine the fee) Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"\n+                            \"     \\\"subtractFeeFromOutputs\\\" (array, optional) A json array of integers.\\n\"\n+                            \"                              The fee will be equally deducted from the amount of each specified output.\\n\"\n+                            \"                              The outputs are specified by their zero-based index, before any change output is added.\\n\"\n+                            \"                              Those recipients will receive less bitcoins than you enter in their corresponding amount field.\\n\"\n+                            \"                              If no outputs are specified here, the sender pays the fee.\\n\"\n+                            \"                                  [vout_index,...]\\n\"\n+                            \"     \\\"replaceable\\\"            (boolean, optional) Marks this transaction as BIP125 replaceable.\\n\"\n+                            \"                              Allows this transaction to be replaced by a transaction with higher fees\\n\"\n+                            \"     \\\"conf_target\\\"            (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"estimate_mode\\\"          (string, optional, default=UNSET) The fee estimate mode, must be one of:\\n\"\n+                            \"         \\\"UNSET\\\"\\n\"\n+                            \"         \\\"ECONOMICAL\\\"\\n\"\n+                            \"         \\\"CONSERVATIVE\\\"\\n\"\n+                            \"   }\\n\"\n+                            \"                         for backward compatibility: passing in a true instead of an object will result in {\\\"includeWatching\\\":true}\\n\"\n+                            \"3. iswitness               (boolean, optional) Whether the transaction hex is a serialized witness transaction \\n\"\n+                            \"                              If iswitness is not present, heuristic tests will be used in decoding\\n\"\n+\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"hex\\\":       \\\"value\\\", (string)  The resulting raw transaction (hex-encoded string)\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee in \" + CURRENCY_UNIT + \" the resulting transaction pays\\n\"\n+                            \"  \\\"changepos\\\": n          (numeric) The position of the added change output, or -1\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nCreate a transaction with no inputs\\n\"\n+                            + HelpExampleCli(\"createrawtransaction\", \"\\\"[]\\\" \\\"{\\\\\\\"myaddress\\\\\\\":0.01}\\\"\") +\n+                            \"\\nAdd sufficient unsigned inputs to meet the output value\\n\"\n+                            + HelpExampleCli(\"fundrawtransaction\", \"\\\"rawtransactionhex\\\"\") +\n+                            \"\\nSign the transaction\\n\"\n+                            + HelpExampleCli(\"signrawtransaction\", \"\\\"fundedtransactionhex\\\"\") +\n+                            \"\\nSend the transaction\\n\"\n+                            + HelpExampleCli(\"sendrawtransaction\", \"\\\"signedtransactionhex\\\"\")\n+                            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValueType(), UniValue::VBOOL});\n+\n+    // parse hex string from parameter\n+    CMutableTransaction tx;\n+    bool try_witness = request.params[2].isNull() ? true : request.params[2].get_bool();\n+    bool try_no_witness = request.params[2].isNull() ? true : !request.params[2].get_bool();\n+    if (!DecodeHexTx(tx, request.params[0].get_str(), try_no_witness, try_witness)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n+    }\n+\n+    CAmount fee;\n+    int change_position;\n+    FundTransaction(pwallet, tx, fee, change_position, request.params[1]);\n \n     UniValue result(UniValue::VOBJ);\n     result.pushKV(\"hex\", EncodeHexTx(tx));\n-    result.pushKV(\"changepos\", changePosition);\n-    result.pushKV(\"fee\", ValueFromAmount(nFeeOut));\n+    result.pushKV(\"fee\", ValueFromAmount(fee));\n+    result.pushKV(\"changepos\", change_position);\n \n     return result;\n }"
      }
    ]
  },
  {
    "sha": "8b5ef2793748065727a9a2498805ae5b269dcb4f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4YjVlZjI3OTM3NDgwNjU3MjdhOWEyNDk4ODA1YWU1YjI2OWRjYjRm",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-06-29T01:56:34Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-07-13T21:27:31Z"
      },
      "message": "SignPSBTInput wrapper function\n\nThe SignPSBTInput function takes a PSBTInput, SignatureData, SigningProvider,\nand other data necessary for signing. It fills the SignatureData with data from\nthe PSBTInput, retrieves the UTXO from the PSBTInput, signs and finalizes the\ninput if possible, and then extracts the results from the SignatureData and\nputs them back into the PSBTInput.",
      "tree": {
        "sha": "66d4ffbac5555defeb41c4dd6118ad73998634d4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/66d4ffbac5555defeb41c4dd6118ad73998634d4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8b5ef2793748065727a9a2498805ae5b269dcb4f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8b5ef2793748065727a9a2498805ae5b269dcb4f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8b5ef2793748065727a9a2498805ae5b269dcb4f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8b5ef2793748065727a9a2498805ae5b269dcb4f/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "58a8e28918025c28f19ba19cbaa4a72374162942",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/58a8e28918025c28f19ba19cbaa4a72374162942",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/58a8e28918025c28f19ba19cbaa4a72374162942"
      }
    ],
    "stats": {
      "total": 29,
      "additions": 29,
      "deletions": 0
    },
    "files": [
      {
        "sha": "f9907f5e00684d998e41892d11ca3ded80ceccfa",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8b5ef2793748065727a9a2498805ae5b269dcb4f/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8b5ef2793748065727a9a2498805ae5b269dcb4f/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=8b5ef2793748065727a9a2498805ae5b269dcb4f",
        "patch": "@@ -234,6 +234,32 @@ bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreato\n     return sigdata.complete;\n }\n \n+bool SignPSBTInput(const SigningProvider& provider, const CMutableTransaction& tx, PSBTInput& input, SignatureData& sigdata, int index, int sighash)\n+{\n+    // if this input has a final scriptsig or scriptwitness, don't do anything with it\n+    if (!input.final_script_sig.empty() || !input.final_script_witness.IsNull()) {\n+        return true;\n+    }\n+\n+    // Fill SignatureData with input info\n+    input.FillSignatureData(sigdata);\n+\n+    // Get UTXO\n+    CTxOut utxo;\n+    if (input.non_witness_utxo) {\n+        utxo = input.non_witness_utxo->vout[tx.vin[index].prevout.n];\n+    } else if (!input.witness_utxo.IsNull()) {\n+        utxo = input.witness_utxo;\n+    } else {\n+        return false;\n+    }\n+\n+    MutableTransactionSignatureCreator creator(&tx, index, utxo.nValue, sighash);\n+    bool sig_complete = ProduceSignature(provider, creator, utxo.scriptPubKey, sigdata);\n+    input.FromSignatureData(sigdata);\n+    return sig_complete;\n+}\n+\n class SignatureExtractorChecker final : public BaseSignatureChecker\n {\n private:"
      },
      {
        "sha": "9f0382e25715fdebcd4e0295069f022e3faf78bf",
        "filename": "src/script/sign.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8b5ef2793748065727a9a2498805ae5b269dcb4f/src/script/sign.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8b5ef2793748065727a9a2498805ae5b269dcb4f/src/script/sign.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.h?ref=8b5ef2793748065727a9a2498805ae5b269dcb4f",
        "patch": "@@ -634,6 +634,9 @@ bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreato\n bool SignSignature(const SigningProvider &provider, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, const CAmount& amount, int nHashType);\n bool SignSignature(const SigningProvider &provider, const CTransaction& txFrom, CMutableTransaction& txTo, unsigned int nIn, int nHashType);\n \n+/** Signs a PSBTInput */\n+bool SignPSBTInput(const SigningProvider& provider, const CMutableTransaction& tx, PSBTInput& input, SignatureData& sigdata, int index, int sighash = 1);\n+\n /** Extract signature data from a transaction input, and insert it. */\n SignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nIn, const CTxOut& txout);\n void UpdateInput(CTxIn& input, const SignatureData& data);"
      }
    ]
  },
  {
    "sha": "c27fe419efb3b6588c400d764122ffb33375e028",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjMjdmZTQxOWVmYjNiNjU4OGM0MDBkNzY0MTIyZmZiMzMzNzVlMDI4",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-06-29T02:04:40Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-07-16T23:08:24Z"
      },
      "message": "Create utility RPCs for PSBT\n\ndecodepsbt takes a PSBT and decodes it to JSON\n\ncombinepsbt takes multiple PSBTs for the same tx and combines them.\n\nfinalizepsbt takes a PSBT and finalizes the inputs. If all inputs\nare final, it extracts the network serialized transaction and returns\nthat instead of a PSBT unless instructed otherwise.\n\ncreatepsbt is like createrawtransaction but for PSBTs instead of\nraw transactions.\n\nconvertpsbt takes a network serialized transaction and converts it\ninto a psbt. The resulting psbt will lose all signature data and\nan explicit flag must be set to allow transactions with signature\ndata to be converted.",
      "tree": {
        "sha": "710267c171e804f20286191f1495c66ca59683cf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/710267c171e804f20286191f1495c66ca59683cf"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c27fe419efb3b6588c400d764122ffb33375e028",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c27fe419efb3b6588c400d764122ffb33375e028",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c27fe419efb3b6588c400d764122ffb33375e028",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c27fe419efb3b6588c400d764122ffb33375e028/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8b5ef2793748065727a9a2498805ae5b269dcb4f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8b5ef2793748065727a9a2498805ae5b269dcb4f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8b5ef2793748065727a9a2498805ae5b269dcb4f"
      }
    ],
    "stats": {
      "total": 606,
      "additions": 606,
      "deletions": 0
    },
    "files": [
      {
        "sha": "d364bca8b102c78d90af927d02a83d0cdb6f35ad",
        "filename": "src/core_io.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c27fe419efb3b6588c400d764122ffb33375e028/src/core_io.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c27fe419efb3b6588c400d764122ffb33375e028/src/core_io.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_io.h?ref=c27fe419efb3b6588c400d764122ffb33375e028",
        "patch": "@@ -14,6 +14,7 @@ class CBlock;\n class CScript;\n class CTransaction;\n struct CMutableTransaction;\n+struct PartiallySignedTransaction;\n class uint256;\n class UniValue;\n \n@@ -24,12 +25,15 @@ bool DecodeHexTx(CMutableTransaction& tx, const std::string& hex_tx, bool try_no\n bool DecodeHexBlk(CBlock&, const std::string& strHexBlk);\n uint256 ParseHashStr(const std::string&, const std::string& strName);\n std::vector<unsigned char> ParseHexUV(const UniValue& v, const std::string& strName);\n+bool DecodePSBT(PartiallySignedTransaction& psbt, const std::string& base64_tx, std::string& error);\n \n // core_write.cpp\n UniValue ValueFromAmount(const CAmount& amount);\n std::string FormatScript(const CScript& script);\n std::string EncodeHexTx(const CTransaction& tx, const int serializeFlags = 0);\n+std::string SighashToStr(unsigned char sighash_type);\n void ScriptPubKeyToUniv(const CScript& scriptPubKey, UniValue& out, bool fIncludeHex);\n+void ScriptToUniv(const CScript& script, UniValue& out, bool include_address);\n void TxToUniv(const CTransaction& tx, const uint256& hashBlock, UniValue& entry, bool include_hex = true, int serialize_flags = 0);\n \n #endif // BITCOIN_CORE_IO_H"
      },
      {
        "sha": "7ee3edc1f35d064e48b9a5b1969e028357f53b43",
        "filename": "src/core_read.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c27fe419efb3b6588c400d764122ffb33375e028/src/core_read.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c27fe419efb3b6588c400d764122ffb33375e028/src/core_read.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_read.cpp?ref=c27fe419efb3b6588c400d764122ffb33375e028",
        "patch": "@@ -7,6 +7,7 @@\n #include <primitives/block.h>\n #include <primitives/transaction.h>\n #include <script/script.h>\n+#include <script/sign.h>\n #include <serialize.h>\n #include <streams.h>\n #include <univalue.h>\n@@ -160,6 +161,23 @@ bool DecodeHexBlk(CBlock& block, const std::string& strHexBlk)\n     return true;\n }\n \n+bool DecodePSBT(PartiallySignedTransaction& psbt, const std::string& base64_tx, std::string& error)\n+{\n+    std::vector<unsigned char> tx_data = DecodeBase64(base64_tx.c_str());\n+    CDataStream ss_data(tx_data, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ss_data >> psbt;\n+        if (!ss_data.empty()) {\n+            error = \"extra data after PSBT\";\n+            return false;\n+        }\n+    } catch (const std::exception& e) {\n+        error = e.what();\n+        return false;\n+    }\n+    return true;\n+}\n+\n uint256 ParseHashStr(const std::string& strHex, const std::string& strName)\n {\n     if (!IsHex(strHex)) // Note: IsHex(\"\") is false"
      },
      {
        "sha": "1272266235393971873569c1faddec9a2662a901",
        "filename": "src/core_write.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c27fe419efb3b6588c400d764122ffb33375e028/src/core_write.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c27fe419efb3b6588c400d764122ffb33375e028/src/core_write.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_write.cpp?ref=c27fe419efb3b6588c400d764122ffb33375e028",
        "patch": "@@ -70,6 +70,13 @@ const std::map<unsigned char, std::string> mapSigHashTypes = {\n     {static_cast<unsigned char>(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY), std::string(\"SINGLE|ANYONECANPAY\")},\n };\n \n+std::string SighashToStr(unsigned char sighash_type)\n+{\n+    const auto& it = mapSigHashTypes.find(sighash_type);\n+    if (it == mapSigHashTypes.end()) return \"\";\n+    return it->second;\n+}\n+\n /**\n  * Create the assembly string representation of a CScript object.\n  * @param[in] script    CScript object to convert into the asm string representation.\n@@ -128,6 +135,22 @@ std::string EncodeHexTx(const CTransaction& tx, const int serializeFlags)\n     return HexStr(ssTx.begin(), ssTx.end());\n }\n \n+void ScriptToUniv(const CScript& script, UniValue& out, bool include_address)\n+{\n+    out.pushKV(\"asm\", ScriptToAsmStr(script));\n+    out.pushKV(\"hex\", HexStr(script.begin(), script.end()));\n+\n+    std::vector<std::vector<unsigned char>> solns;\n+    txnouttype type;\n+    Solver(script, type, solns);\n+    out.pushKV(\"type\", GetTxnOutputType(type));\n+\n+    CTxDestination address;\n+    if (include_address && ExtractDestination(script, address)) {\n+        out.pushKV(\"address\", EncodeDestination(address));\n+    }\n+}\n+\n void ScriptPubKeyToUniv(const CScript& scriptPubKey,\n                         UniValue& out, bool fIncludeHex)\n {"
      },
      {
        "sha": "d97165b301fe91900d668d7ac5037304e86c40d5",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c27fe419efb3b6588c400d764122ffb33375e028/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c27fe419efb3b6588c400d764122ffb33375e028/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=c27fe419efb3b6588c400d764122ffb33375e028",
        "patch": "@@ -109,6 +109,14 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"combinerawtransaction\", 0, \"txs\" },\n     { \"fundrawtransaction\", 1, \"options\" },\n     { \"fundrawtransaction\", 2, \"iswitness\" },\n+    { \"createpsbt\", 0, \"inputs\" },\n+    { \"createpsbt\", 1, \"outputs\" },\n+    { \"createpsbt\", 2, \"locktime\" },\n+    { \"createpsbt\", 3, \"replaceable\" },\n+    { \"combinepsbt\", 0, \"txs\"},\n+    { \"finalizepsbt\", 1, \"extract\"},\n+    { \"converttopsbt\", 1, \"permitsigdata\"},\n+    { \"converttopsbt\", 2, \"iswitness\"},\n     { \"gettxout\", 1, \"n\" },\n     { \"gettxout\", 2, \"include_mempool\" },\n     { \"gettxoutproof\", 0, \"txids\" },"
      },
      {
        "sha": "797c8b6973e88e2e25f580bd7dfd02ff59442d71",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 553,
        "deletions": 0,
        "changes": 553,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c27fe419efb3b6588c400d764122ffb33375e028/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c27fe419efb3b6588c400d764122ffb33375e028/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=c27fe419efb3b6588c400d764122ffb33375e028",
        "patch": "@@ -5,6 +5,7 @@\n \n #include <chain.h>\n #include <coins.h>\n+#include <compat/byteswap.h>\n #include <consensus/validation.h>\n #include <core_io.h>\n #include <index/txindex.h>\n@@ -1259,6 +1260,553 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : {             (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"bip32_derivs\\\" : {          (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : {                     (json object, optional) The public key with the derivation path as the value.\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"final_scriptsig\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"        }\\n\"\n+            \"       \\\"final_scriptwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"fee\\\" : fee                      (numeric, optional) The transaction fee paid if all UTXOs slots in the PSBT have been filled.\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    CAmount total_in = 0;\n+    bool have_all_utxos = true;\n+    UniValue inputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {\n+        const PSBTInput& input = psbtx.inputs[i];\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"amount\", ValueFromAmount(txout.nValue));\n+            total_in += txout.nValue;\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+            total_in += input.non_witness_utxo->vout[psbtx.tx->vin[i].prevout.n].nValue;\n+        } else {\n+            have_all_utxos = false;\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VOBJ);\n+            for (const auto& sig : input.partial_sigs) {\n+                partial_sigs.pushKV(HexStr(sig.second.first), HexStr(sig.second.second));\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            UniValue scriptsig(UniValue::VOBJ);\n+            scriptsig.pushKV(\"asm\", ScriptToAsmStr(input.final_script_sig, true));\n+            scriptsig.pushKV(\"hex\", HexStr(input.final_script_sig));\n+            in.pushKV(\"final_scriptSig\", scriptsig);\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            UniValue txinwitness(UniValue::VARR);\n+            for (const auto& item : input.final_script_witness.stack) {\n+                txinwitness.push_back(HexStr(item.begin(), item.end()));\n+            }\n+            in.pushKV(\"final_scriptwitness\", txinwitness);\n+        }\n+\n+        // Unknown data\n+        if (input.unknown.size() > 0) {\n+            UniValue unknowns(UniValue::VOBJ);\n+            for (auto entry : input.unknown) {\n+                unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+            }\n+            in.pushKV(\"unknown\", unknowns);\n+        }\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    CAmount output_value = 0;\n+    UniValue outputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.outputs.size(); ++i) {\n+        const PSBTOutput& output = psbtx.outputs[i];\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        if (output.unknown.size() > 0) {\n+            UniValue unknowns(UniValue::VOBJ);\n+            for (auto entry : output.unknown) {\n+                unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+            }\n+            out.pushKV(\"unknown\", unknowns);\n+        }\n+\n+        outputs.push_back(out);\n+\n+        // Fee calculation\n+        output_value += psbtx.tx->vout[i].nValue;\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+    if (have_all_utxos) {\n+        result.pushKV(\"fee\", ValueFromAmount(total_in - output_value));\n+    }\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"psbt\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner role.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        if (*it != merged_psbt) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+        merged_psbt.Merge(*it);\n+    }\n+    if (!merged_psbt.IsSane()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is inconsistent\");\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"psbt\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction. Otherwise a PSBT will be\\n\"\n+            \"created which has the final_scriptSig and final_scriptWitness fields filled for inputs that are complete.\\n\"\n+            \"Implements the Finalizer and Extractor roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization instead of the PSBT.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction if not extracted\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded network transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        SignatureData sigdata;\n+        complete &= SignPSBTInput(DUMMY_SIGNING_PROVIDER, *psbtx.tx, input, sigdata, i, 1);\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\n+    if (complete && extract) {\n+        CMutableTransaction mtx(*psbtx.tx);\n+        for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+            mtx.vin[i].scriptSig = psbtx.inputs[i].final_script_sig;\n+            mtx.vin[i].scriptWitness = psbtx.inputs[i].final_script_witness;\n+        }\n+        ssTx << mtx;\n+        result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n+    } else {\n+        ssTx << psbtx;\n+        result.push_back(Pair(\"psbt\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size())));\n+    }\n+    result.push_back(Pair(\"complete\", complete));\n+\n+    return result;\n+}\n+\n+UniValue createpsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n+        throw std::runtime_error(\n+                            \"createpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable )\\n\"\n+                            \"\\nCreates a transaction in the Partially Signed Transaction format.\\n\"\n+                            \"Implements the Creator role.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"inputs\\\"                (array, required) A json array of json objects\\n\"\n+                            \"     [\\n\"\n+                            \"       {\\n\"\n+                            \"         \\\"txid\\\":\\\"id\\\",      (string, required) The transaction id\\n\"\n+                            \"         \\\"vout\\\":n,         (numeric, required) The output number\\n\"\n+                            \"         \\\"sequence\\\":n      (numeric, optional) The sequence number\\n\"\n+                            \"       } \\n\"\n+                            \"       ,...\\n\"\n+                            \"     ]\\n\"\n+                            \"2. \\\"outputs\\\"               (array, required) a json array with outputs (key-value pairs)\\n\"\n+                            \"   [\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"address\\\": x.xxx,    (obj, optional) A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\\n\"\n+                            \"    },\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"data\\\": \\\"hex\\\"        (obj, optional) A key-value pair. The key must be \\\"data\\\", the value is hex encoded data\\n\"\n+                            \"    }\\n\"\n+                            \"    ,...                     More key-value pairs of the above form. For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n+                            \"                             accepted as second parameter.\\n\"\n+                            \"   ]\\n\"\n+                            \"3. locktime                  (numeric, optional, default=0) Raw locktime. Non-0 value also locktime-activates inputs\\n\"\n+                            \"4. replaceable               (boolean, optional, default=false) Marks this transaction as BIP125 replaceable.\\n\"\n+                            \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"        (string)  The resulting raw transaction (base64-encoded string)\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"createpsbt\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")\n+                            );\n+\n+\n+    RPCTypeCheck(request.params, {\n+        UniValue::VARR,\n+        UniValueType(), // ARR or OBJ, checked later\n+        UniValue::VNUM,\n+        UniValue::VBOOL,\n+        }, true\n+    );\n+\n+    CMutableTransaction rawTx = ConstructTransaction(request.params[0], request.params[1], request.params[2], request.params[3]);\n+\n+    // Make a blank psbt\n+    PartiallySignedTransaction psbtx;\n+    psbtx.tx = rawTx;\n+    for (unsigned int i = 0; i < rawTx.vin.size(); ++i) {\n+        psbtx.inputs.push_back(PSBTInput());\n+    }\n+    for (unsigned int i = 0; i < rawTx.vout.size(); ++i) {\n+        psbtx.outputs.push_back(PSBTOutput());\n+    }\n+\n+    // Serialize the PSBT\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue converttopsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+                            \"converttopsbt \\\"hexstring\\\" ( permitsigdata iswitness )\\n\"\n+                            \"\\nConverts a network serialized transaction to a PSBT. This should be used only with createrawtransaction and fundrawtransaction\\n\"\n+                            \"createpsbt and walletcreatefundedpsbt should be used for new applications.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"hexstring\\\"              (string, required) The hex string of a raw transaction\\n\"\n+                            \"2. permitsigdata           (boolean, optional, default=false) If true, any signatures in the input will be discarded and conversion.\\n\"\n+                            \"                              will continue. If false, RPC will fail if any signatures are present.\\n\"\n+                            \"3. iswitness               (boolean, optional) Whether the transaction hex is a serialized witness transaction.\\n\"\n+                            \"                              If iswitness is not present, heuristic tests will be used in decoding. If true, only witness deserializaion\\n\"\n+                            \"                              will be tried. If false, only non-witness deserialization wil be tried. Only has an effect if\\n\"\n+                            \"                              permitsigdata is true.\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"        (string)  The resulting raw transaction (base64-encoded string)\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nCreate a transaction\\n\"\n+                            + HelpExampleCli(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\") +\n+                            \"\\nConvert the transaction to a PSBT\\n\"\n+                            + HelpExampleCli(\"converttopsbt\", \"\\\"rawtransaction\\\"\")\n+                            );\n+\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL, UniValue::VBOOL}, true);\n+\n+    // parse hex string from parameter\n+    CMutableTransaction tx;\n+    bool permitsigdata = request.params[1].isNull() ? false : request.params[1].get_bool();\n+    bool witness_specified = !request.params[2].isNull();\n+    bool iswitness = witness_specified ? request.params[2].get_bool() : false;\n+    bool try_witness = permitsigdata ? (witness_specified ? iswitness : true) : false;\n+    bool try_no_witness = permitsigdata ? (witness_specified ? !iswitness : true) : true;\n+    if (!DecodeHexTx(tx, request.params[0].get_str(), try_no_witness, try_witness)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n+    }\n+\n+    // Remove all scriptSigs and scriptWitnesses from inputs\n+    for (CTxIn& input : tx.vin) {\n+        if ((!input.scriptSig.empty() || !input.scriptWitness.IsNull()) && (request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool()))) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Inputs must not have scriptSigs and scriptWitnesses\");\n+        }\n+        input.scriptSig.clear();\n+        input.scriptWitness.SetNull();\n+    }\n+\n+    // Make a blank psbt\n+    PartiallySignedTransaction psbtx;\n+    psbtx.tx = tx;\n+    for (unsigned int i = 0; i < tx.vin.size(); ++i) {\n+        psbtx.inputs.push_back(PSBTInput());\n+    }\n+    for (unsigned int i = 0; i < tx.vout.size(); ++i) {\n+        psbtx.outputs.push_back(PSBTOutput());\n+    }\n+\n+    // Serialize the PSBT\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n static const CRPCCommand commands[] =\n { //  category              name                            actor (function)            argNames\n   //  --------------------- ------------------------        -----------------------     ----------\n@@ -1271,6 +1819,11 @@ static const CRPCCommand commands[] =\n     { \"rawtransactions\",    \"signrawtransaction\",           &signrawtransaction,        {\"hexstring\",\"prevtxs\",\"privkeys\",\"sighashtype\"} }, /* uses wallet if enabled */\n     { \"rawtransactions\",    \"signrawtransactionwithkey\",    &signrawtransactionwithkey, {\"hexstring\",\"privkeys\",\"prevtxs\",\"sighashtype\"} },\n     { \"rawtransactions\",    \"testmempoolaccept\",            &testmempoolaccept,         {\"rawtxs\",\"allowhighfees\"} },\n+    { \"rawtransactions\",    \"decodepsbt\",                   &decodepsbt,                {\"psbt\"} },\n+    { \"rawtransactions\",    \"combinepsbt\",                  &combinepsbt,               {\"txs\"} },\n+    { \"rawtransactions\",    \"finalizepsbt\",                 &finalizepsbt,              {\"psbt\", \"extract\"} },\n+    { \"rawtransactions\",    \"createpsbt\",                   &createpsbt,                {\"inputs\",\"outputs\",\"locktime\",\"replaceable\"} },\n+    { \"rawtransactions\",    \"converttopsbt\",                &converttopsbt,             {\"hexstring\",\"permitsigdata\",\"iswitness\"} },\n \n     { \"blockchain\",         \"gettxoutproof\",                &gettxoutproof,             {\"txids\", \"blockhash\"} },\n     { \"blockchain\",         \"verifytxoutproof\",             &verifytxoutproof,          {\"proof\"} },"
      }
    ]
  },
  {
    "sha": "a4b06fb42eb0ad94e562ca839391b57e69285136",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphNGIwNmZiNDJlYjBhZDk0ZTU2MmNhODM5MzkxYjU3ZTY5Mjg1MTM2",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-06-29T02:05:05Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-07-16T23:08:24Z"
      },
      "message": "Create wallet RPCs for PSBT\n\nwalletprocesspsbt takes a PSBT format transaction, updates the\nPSBT with any inputs related to this wallet, signs, and finalizes\nthe transaction. There is also an option to not sign and just\nupdate.\n\nwalletcreatefundedpsbt creates a PSBT from user provided data\nin the same form as createrawtransaction. It also funds the transaction\nand takes an options argument in the same form as fundrawtransaction.\nThe resulting PSBT is blank with no input or output data filled\nin.",
      "tree": {
        "sha": "ab08f3ef40a2e47df0513f242cb9ad6fe35dda2f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ab08f3ef40a2e47df0513f242cb9ad6fe35dda2f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a4b06fb42eb0ad94e562ca839391b57e69285136",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a4b06fb42eb0ad94e562ca839391b57e69285136",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a4b06fb42eb0ad94e562ca839391b57e69285136",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a4b06fb42eb0ad94e562ca839391b57e69285136/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c27fe419efb3b6588c400d764122ffb33375e028",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c27fe419efb3b6588c400d764122ffb33375e028",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c27fe419efb3b6588c400d764122ffb33375e028"
      }
    ],
    "stats": {
      "total": 402,
      "additions": 385,
      "deletions": 17
    },
    "files": [
      {
        "sha": "ebddcc2a042a9018d17590f3060716a8c68de436",
        "filename": "src/core_io.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4b06fb42eb0ad94e562ca839391b57e69285136/src/core_io.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4b06fb42eb0ad94e562ca839391b57e69285136/src/core_io.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_io.h?ref=a4b06fb42eb0ad94e562ca839391b57e69285136",
        "patch": "@@ -26,6 +26,7 @@ bool DecodeHexBlk(CBlock&, const std::string& strHexBlk);\n uint256 ParseHashStr(const std::string&, const std::string& strName);\n std::vector<unsigned char> ParseHexUV(const UniValue& v, const std::string& strName);\n bool DecodePSBT(PartiallySignedTransaction& psbt, const std::string& base64_tx, std::string& error);\n+int ParseSighashString(const UniValue& sighash);\n \n // core_write.cpp\n UniValue ValueFromAmount(const CAmount& amount);"
      },
      {
        "sha": "067e1b91bd0d12406a12e940faf1dcc73d4ac23e",
        "filename": "src/core_read.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4b06fb42eb0ad94e562ca839391b57e69285136/src/core_read.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4b06fb42eb0ad94e562ca839391b57e69285136/src/core_read.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_read.cpp?ref=a4b06fb42eb0ad94e562ca839391b57e69285136",
        "patch": "@@ -197,3 +197,26 @@ std::vector<unsigned char> ParseHexUV(const UniValue& v, const std::string& strN\n         throw std::runtime_error(strName + \" must be hexadecimal string (not '\" + strHex + \"')\");\n     return ParseHex(strHex);\n }\n+\n+int ParseSighashString(const UniValue& sighash)\n+{\n+    int hash_type = SIGHASH_ALL;\n+    if (!sighash.isNull()) {\n+        static std::map<std::string, int> map_sighash_values = {\n+            {std::string(\"ALL\"), int(SIGHASH_ALL)},\n+            {std::string(\"ALL|ANYONECANPAY\"), int(SIGHASH_ALL|SIGHASH_ANYONECANPAY)},\n+            {std::string(\"NONE\"), int(SIGHASH_NONE)},\n+            {std::string(\"NONE|ANYONECANPAY\"), int(SIGHASH_NONE|SIGHASH_ANYONECANPAY)},\n+            {std::string(\"SINGLE\"), int(SIGHASH_SINGLE)},\n+            {std::string(\"SINGLE|ANYONECANPAY\"), int(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY)},\n+        };\n+        std::string strHashType = sighash.get_str();\n+        const auto& it = map_sighash_values.find(strHashType);\n+        if (it != map_sighash_values.end()) {\n+            hash_type = it->second;\n+        } else {\n+            throw std::runtime_error(strHashType + \" is not a valid sighash parameter.\");\n+        }\n+    }\n+    return hash_type;\n+}"
      },
      {
        "sha": "96e0a96ab5e27075345d263bf57f3b3275cffa3d",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4b06fb42eb0ad94e562ca839391b57e69285136/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4b06fb42eb0ad94e562ca839391b57e69285136/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=a4b06fb42eb0ad94e562ca839391b57e69285136",
        "patch": "@@ -109,6 +109,14 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"combinerawtransaction\", 0, \"txs\" },\n     { \"fundrawtransaction\", 1, \"options\" },\n     { \"fundrawtransaction\", 2, \"iswitness\" },\n+    { \"walletcreatefundedpsbt\", 0, \"inputs\" },\n+    { \"walletcreatefundedpsbt\", 1, \"outputs\" },\n+    { \"walletcreatefundedpsbt\", 2, \"locktime\" },\n+    { \"walletcreatefundedpsbt\", 3, \"replaceable\" },\n+    { \"walletcreatefundedpsbt\", 4, \"options\" },\n+    { \"walletcreatefundedpsbt\", 5, \"bip32derivs\" },\n+    { \"walletprocesspsbt\", 1, \"sign\" },\n+    { \"walletprocesspsbt\", 3, \"bip32derivs\" },\n     { \"createpsbt\", 0, \"inputs\" },\n     { \"createpsbt\", 1, \"outputs\" },\n     { \"createpsbt\", 2, \"locktime\" },"
      },
      {
        "sha": "82dfe4d5614c93a49005dfd3a6611f8e803a5443",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 17,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4b06fb42eb0ad94e562ca839391b57e69285136/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4b06fb42eb0ad94e562ca839391b57e69285136/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=a4b06fb42eb0ad94e562ca839391b57e69285136",
        "patch": "@@ -840,23 +840,7 @@ UniValue SignTransaction(CMutableTransaction& mtx, const UniValue& prevTxsUnival\n         }\n     }\n \n-    int nHashType = SIGHASH_ALL;\n-    if (!hashType.isNull()) {\n-        static std::map<std::string, int> mapSigHashValues = {\n-            {std::string(\"ALL\"), int(SIGHASH_ALL)},\n-            {std::string(\"ALL|ANYONECANPAY\"), int(SIGHASH_ALL|SIGHASH_ANYONECANPAY)},\n-            {std::string(\"NONE\"), int(SIGHASH_NONE)},\n-            {std::string(\"NONE|ANYONECANPAY\"), int(SIGHASH_NONE|SIGHASH_ANYONECANPAY)},\n-            {std::string(\"SINGLE\"), int(SIGHASH_SINGLE)},\n-            {std::string(\"SINGLE|ANYONECANPAY\"), int(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY)},\n-        };\n-        std::string strHashType = hashType.get_str();\n-        if (mapSigHashValues.count(strHashType)) {\n-            nHashType = mapSigHashValues[strHashType];\n-        } else {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid sighash param\");\n-        }\n-    }\n+    int nHashType = ParseSighashString(hashType);\n \n     bool fHashSingle = ((nHashType & ~SIGHASH_ANYONECANPAY) == SIGHASH_SINGLE);\n "
      },
      {
        "sha": "f1ac1f411ad2ae24648db544c71f144b1d0d9cb0",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4b06fb42eb0ad94e562ca839391b57e69285136/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4b06fb42eb0ad94e562ca839391b57e69285136/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=a4b06fb42eb0ad94e562ca839391b57e69285136",
        "patch": "@@ -614,3 +614,13 @@ void PSBTOutput::Merge(const PSBTOutput& output)\n     if (redeem_script.empty() && !output.redeem_script.empty()) redeem_script = output.redeem_script;\n     if (witness_script.empty() && !output.witness_script.empty()) witness_script = output.witness_script;\n }\n+\n+bool PublicOnlySigningProvider::GetCScript(const CScriptID &scriptid, CScript& script) const\n+{\n+    return m_provider->GetCScript(scriptid, script);\n+}\n+\n+bool PublicOnlySigningProvider::GetPubKey(const CKeyID &address, CPubKey& pubkey) const\n+{\n+    return m_provider->GetPubKey(address, pubkey);\n+}"
      },
      {
        "sha": "e3a6196b2830e51141302a55d026f852854e58d3",
        "filename": "src/script/sign.h",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4b06fb42eb0ad94e562ca839391b57e69285136/src/script/sign.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4b06fb42eb0ad94e562ca839391b57e69285136/src/script/sign.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.h?ref=a4b06fb42eb0ad94e562ca839391b57e69285136",
        "patch": "@@ -32,6 +32,17 @@ class SigningProvider\n \n extern const SigningProvider& DUMMY_SIGNING_PROVIDER;\n \n+class PublicOnlySigningProvider : public SigningProvider\n+{\n+private:\n+    const SigningProvider* m_provider;\n+\n+public:\n+    PublicOnlySigningProvider(const SigningProvider* provider) : m_provider(provider) {}\n+    bool GetCScript(const CScriptID &scriptid, CScript& script) const;\n+    bool GetPubKey(const CKeyID &address, CPubKey& pubkey) const;\n+};\n+\n /** Interface for signature creators. */\n class BaseSignatureCreator {\n public:"
      },
      {
        "sha": "6d2499ee8a758978dbf3763c294492a7c5d0bf55",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 328,
        "deletions": 0,
        "changes": 328,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4b06fb42eb0ad94e562ca839391b57e69285136/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4b06fb42eb0ad94e562ca839391b57e69285136/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=a4b06fb42eb0ad94e562ca839391b57e69285136",
        "patch": "@@ -4390,6 +4390,332 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n+        return;\n+    }\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    std::vector<uint32_t> keypath;\n+    if (!meta.hdKeypath.empty()) {\n+        if (!ParseHDKeypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), ReadLE32(masterKey.key.GetPubKey().GetID().begin()));\n+    } else { // Single pubkeys get the master fingerprint of themselves\n+        keypath.insert(keypath.begin(), ReadLE32(vchPubKey.GetID().begin()));\n+    }\n+    hd_keypaths.emplace(vchPubKey, keypath);\n+}\n+\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type, bool sign, bool bip32derivs)\n+{\n+    LOCK(pwallet->cs_wallet);\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        const CTxIn& txin = txConst->vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        const uint256& txhash = txin.prevout.hash;\n+        const auto& it = pwallet->mapWallet.find(txhash);\n+        if (it != pwallet->mapWallet.end()) {\n+            const CWalletTx& wtx = it->second;\n+            CTxOut utxo = wtx.tx->vout[txin.prevout.n];\n+            input.non_witness_utxo = wtx.tx;\n+            input.witness_utxo = utxo;\n+        }\n+\n+        // Get the Sighash type\n+        if (sign && input.sighash_type > 0 && input.sighash_type != sighash_type) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Specified Sighash and sighash in PSBT do not match.\");\n+        }\n+\n+        SignatureData sigdata;\n+        if (sign) {\n+            complete &= SignPSBTInput(*pwallet, *psbtx.tx, input, sigdata, i, sighash_type);\n+        } else {\n+            complete &= SignPSBTInput(PublicOnlySigningProvider(pwallet), *psbtx.tx, input, sigdata, i, sighash_type);\n+        }\n+\n+        // Drop the unnecessary UTXO\n+        if (sigdata.witness) {\n+            input.non_witness_utxo = nullptr;\n+        } else {\n+            input.witness_utxo.SetNull();\n+        }\n+\n+        // Get public key paths\n+        if (bip32derivs) {\n+            for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+                AddKeypathToMap(pwallet, pubkey_it.first, input.hd_keypaths);\n+            }\n+        }\n+    }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    for (unsigned int i = 0; i < txConst->vout.size(); ++i) {\n+        const CTxOut& out = txConst->vout.at(i);\n+        PSBTOutput& psbt_out = psbtx.outputs.at(i);\n+\n+        // Dummy tx so we can use ProduceSignature to get stuff out\n+        CMutableTransaction dummy_tx;\n+        dummy_tx.vin.push_back(CTxIn());\n+        dummy_tx.vout.push_back(CTxOut());\n+\n+        // Fill a SignatureData with output info\n+        SignatureData sigdata;\n+        psbt_out.FillSignatureData(sigdata);\n+\n+        MutableTransactionSignatureCreator creator(psbtx.tx.get_ptr(), 0, out.nValue, 1);\n+        ProduceSignature(*pwallet, creator, out.scriptPubKey, sigdata);\n+        psbt_out.FromSignatureData(sigdata);\n+\n+        // Get public key paths\n+        if (bip32derivs) {\n+            for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+                AddKeypathToMap(pwallet, pubkey_it.first, psbt_out.hd_keypaths);\n+            }\n+        }\n+    }\n+    return complete;\n+}\n+\n+UniValue walletprocesspsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"walletprocesspsbt \\\"psbt\\\" ( sign \\\"sighashtype\\\" bip32derivs )\\n\"\n+            \"\\nUpdate a PSBT with input information from our wallet and then sign inputs\\n\"\n+            \"that we can sign for.\\n\"\n+            + HelpRequiringPassphrase(pwallet) + \"\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                      (string, required) The transaction base64 string\\n\"\n+            \"2. sign                          (boolean, optional, default=true) Also sign the transaction when updating\\n\"\n+            \"3. \\\"sighashtype\\\"            (string, optional, default=ALL) The signature hash type to sign with if not specified by the PSBT. Must be one of\\n\"\n+            \"       \\\"ALL\\\"\\n\"\n+            \"       \\\"NONE\\\"\\n\"\n+            \"       \\\"SINGLE\\\"\\n\"\n+            \"       \\\"ALL|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"NONE|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"SINGLE|ANYONECANPAY\\\"\\n\"\n+            \"4. bip32derivs                    (boolean, optiona, default=false) If true, includes the BIP 32 derivation paths for public keys if we know them\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"walletprocesspsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL, UniValue::VSTR});\n+\n+    // Unserialize the transaction\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get the sighash type\n+    int nHashType = ParseSighashString(request.params[2]);\n+\n+    // Use CTransaction for the constant parts of the\n+    // transaction to avoid rehashing.\n+    const CTransaction txConst(*psbtx.tx);\n+\n+    // Fill transaction with our data and also sign\n+    bool sign = request.params[1].isNull() ? true : request.params[1].get_bool();\n+    bool bip32derivs = request.params[3].isNull() ? false : request.params[3].get_bool();\n+    bool complete = FillPSBT(pwallet, psbtx, &txConst, nHashType, sign, bip32derivs);\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+    result.push_back(Pair(\"psbt\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size())));\n+    result.push_back(Pair(\"complete\", complete));\n+\n+    return result;\n+}\n+\n+UniValue walletcreatefundedpsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 6)\n+        throw std::runtime_error(\n+                            \"walletcreatefundedpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable ) ( options bip32derivs )\\n\"\n+                            \"\\nCreates and funds a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"\n+                            \"Implements the Creator and Updater roles.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"inputs\\\"                (array, required) A json array of json objects\\n\"\n+                            \"     [\\n\"\n+                            \"       {\\n\"\n+                            \"         \\\"txid\\\":\\\"id\\\",      (string, required) The transaction id\\n\"\n+                            \"         \\\"vout\\\":n,         (numeric, required) The output number\\n\"\n+                            \"         \\\"sequence\\\":n      (numeric, optional) The sequence number\\n\"\n+                            \"       } \\n\"\n+                            \"       ,...\\n\"\n+                            \"     ]\\n\"\n+                            \"2. \\\"outputs\\\"               (array, required) a json array with outputs (key-value pairs)\\n\"\n+                            \"   [\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"address\\\": x.xxx,    (obj, optional) A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\\n\"\n+                            \"    },\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"data\\\": \\\"hex\\\"        (obj, optional) A key-value pair. The key must be \\\"data\\\", the value is hex encoded data\\n\"\n+                            \"    }\\n\"\n+                            \"    ,...                     More key-value pairs of the above form. For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n+                            \"                             accepted as second parameter.\\n\"\n+                            \"   ]\\n\"\n+                            \"3. locktime                  (numeric, optional, default=0) Raw locktime. Non-0 value also locktime-activates inputs\\n\"\n+                            \"4. replaceable               (boolean, optional, default=false) Marks this transaction as BIP125 replaceable.\\n\"\n+                            \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\\n\"\n+                            \"5. options                 (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"changeAddress\\\"          (string, optional, default pool address) The bitcoin address to receive the change\\n\"\n+                            \"     \\\"changePosition\\\"         (numeric, optional, default random) The index of the change output\\n\"\n+                            \"     \\\"change_type\\\"            (string, optional) The output type to use. Only valid if changeAddress is not specified. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\". Default is set by -changetype.\\n\"\n+                            \"     \\\"includeWatching\\\"        (boolean, optional, default false) Also select inputs which are watch only\\n\"\n+                            \"     \\\"lockUnspents\\\"           (boolean, optional, default false) Lock selected unspent outputs\\n\"\n+                            \"     \\\"feeRate\\\"                (numeric, optional, default not set: makes wallet determine the fee) Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"\n+                            \"     \\\"subtractFeeFromOutputs\\\" (array, optional) A json array of integers.\\n\"\n+                            \"                              The fee will be equally deducted from the amount of each specified output.\\n\"\n+                            \"                              The outputs are specified by their zero-based index, before any change output is added.\\n\"\n+                            \"                              Those recipients will receive less bitcoins than you enter in their corresponding amount field.\\n\"\n+                            \"                              If no outputs are specified here, the sender pays the fee.\\n\"\n+                            \"                                  [vout_index,...]\\n\"\n+                            \"     \\\"replaceable\\\"            (boolean, optional) Marks this transaction as BIP125 replaceable.\\n\"\n+                            \"                              Allows this transaction to be replaced by a transaction with higher fees\\n\"\n+                            \"     \\\"conf_target\\\"            (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"estimate_mode\\\"          (string, optional, default=UNSET) The fee estimate mode, must be one of:\\n\"\n+                            \"         \\\"UNSET\\\"\\n\"\n+                            \"         \\\"ECONOMICAL\\\"\\n\"\n+                            \"         \\\"CONSERVATIVE\\\"\\n\"\n+                            \"   }\\n\"\n+                            \"6. bip32derivs                    (boolean, optiona, default=false) If true, includes the BIP 32 derivation paths for public keys if we know them\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"psbt\\\": \\\"value\\\",        (string)  The resulting raw transaction (base64-encoded string)\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee in \" + CURRENCY_UNIT + \" the resulting transaction pays\\n\"\n+                            \"  \\\"changepos\\\": n          (numeric) The position of the added change output, or -1\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nCreate a transaction with no inputs\\n\"\n+                            + HelpExampleCli(\"walletcreatefundedpsbt\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")\n+                            );\n+\n+    RPCTypeCheck(request.params, {\n+        UniValue::VARR,\n+        UniValueType(), // ARR or OBJ, checked later\n+        UniValue::VNUM,\n+        UniValue::VBOOL,\n+        UniValue::VOBJ\n+        }, true\n+    );\n+\n+    CAmount fee;\n+    int change_position;\n+    CMutableTransaction rawTx = ConstructTransaction(request.params[0], request.params[1], request.params[2], request.params[3]);\n+    FundTransaction(pwallet, rawTx, fee, change_position, request.params[4]);\n+\n+    // Make a blank psbt\n+    PartiallySignedTransaction psbtx;\n+    psbtx.tx = rawTx;\n+    for (unsigned int i = 0; i < rawTx.vin.size(); ++i) {\n+        psbtx.inputs.push_back(PSBTInput());\n+    }\n+    for (unsigned int i = 0; i < rawTx.vout.size(); ++i) {\n+        psbtx.outputs.push_back(PSBTOutput());\n+    }\n+\n+    // Use CTransaction for the constant parts of the\n+    // transaction to avoid rehashing.\n+    const CTransaction txConst(*psbtx.tx);\n+\n+    // Fill transaction with out data but don't sign\n+    bool bip32derivs = request.params[5].isNull() ? false : request.params[5].get_bool();\n+    FillPSBT(pwallet, psbtx, &txConst, 1, false, bip32derivs);\n+\n+    // Serialize the PSBT\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+\n+    UniValue result(UniValue::VOBJ);\n+    result.pushKV(\"psbt\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size()));\n+    result.pushKV(\"fee\", ValueFromAmount(fee));\n+    result.pushKV(\"changepos\", change_position);\n+    return result;\n+}\n+\n extern UniValue abortrescan(const JSONRPCRequest& request); // in rpcdump.cpp\n extern UniValue dumpprivkey(const JSONRPCRequest& request); // in rpcdump.cpp\n extern UniValue importprivkey(const JSONRPCRequest& request);\n@@ -4406,6 +4732,8 @@ static const CRPCCommand commands[] =\n { //  category              name                                actor (function)                argNames\n     //  --------------------- ------------------------          -----------------------         ----------\n     { \"rawtransactions\",    \"fundrawtransaction\",               &fundrawtransaction,            {\"hexstring\",\"options\",\"iswitness\"} },\n+    { \"wallet\",             \"walletprocesspsbt\",                &walletprocesspsbt,             {\"psbt\",\"sign\",\"sighashtype\",\"bip32derivs\"} },\n+    { \"wallet\",             \"walletcreatefundedpsbt\",           &walletcreatefundedpsbt,        {\"inputs\",\"outputs\",\"locktime\",\"replaceable\",\"options\",\"bip32derivs\"} },\n     { \"hidden\",             \"resendwallettransactions\",         &resendwallettransactions,      {} },\n     { \"wallet\",             \"abandontransaction\",               &abandontransaction,            {\"txid\"} },\n     { \"wallet\",             \"abortrescan\",                      &abortrescan,                   {} },"
      },
      {
        "sha": "64556b582431deebda3e533dfff72ca9cd49073c",
        "filename": "src/wallet/rpcwallet.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4b06fb42eb0ad94e562ca839391b57e69285136/src/wallet/rpcwallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4b06fb42eb0ad94e562ca839391b57e69285136/src/wallet/rpcwallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.h?ref=a4b06fb42eb0ad94e562ca839391b57e69285136",
        "patch": "@@ -11,6 +11,8 @@ class CRPCTable;\n class CWallet;\n class JSONRPCRequest;\n class UniValue;\n+struct PartiallySignedTransaction;\n+class CTransaction;\n \n void RegisterWalletRPCCommands(CRPCTable &t);\n \n@@ -28,4 +30,5 @@ bool EnsureWalletIsAvailable(CWallet *, bool avoidException);\n \n UniValue getaddressinfo(const JSONRPCRequest& request);\n UniValue signrawtransactionwithwallet(const JSONRPCRequest& request);\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type = 1, bool sign = true, bool bip32derivs = false);\n #endif //BITCOIN_WALLET_RPCWALLET_H"
      }
    ]
  },
  {
    "sha": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMjA2MjhlM2E0ZTg4ZTM2NjQ3ZWFmOTJiYWM0YjM1NTI3OTZhYzZh",
    "commit": {
      "author": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-06-28T00:05:54Z"
      },
      "committer": {
        "name": "Andrew Chow",
        "email": "achow101-github@achow101.com",
        "date": "2018-07-17T00:05:30Z"
      },
      "message": "Tests for PSBT\n\nAdded functional tests for PSBT that test the RPCs. Also added all\nof the BIP 174 test vectors (except for the updater tests) in the\nfunctional tests.\n\nAdded a Unit test for the BIP 174 updater test vector.",
      "tree": {
        "sha": "9450c20f9d91711555a534b0e083cbcf6ad4d513",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9450c20f9d91711555a534b0e083cbcf6ad4d513"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/020628e3a4e88e36647eaf92bac4b3552796ac6a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/020628e3a4e88e36647eaf92bac4b3552796ac6a/comments",
    "author": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a4b06fb42eb0ad94e562ca839391b57e69285136",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a4b06fb42eb0ad94e562ca839391b57e69285136",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a4b06fb42eb0ad94e562ca839391b57e69285136"
      }
    ],
    "stats": {
      "total": 344,
      "additions": 344,
      "deletions": 0
    },
    "files": [
      {
        "sha": "b50b75c081263c66d954d529e94ace84372108d0",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/020628e3a4e88e36647eaf92bac4b3552796ac6a/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/020628e3a4e88e36647eaf92bac4b3552796ac6a/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=020628e3a4e88e36647eaf92bac4b3552796ac6a",
        "patch": "@@ -94,6 +94,7 @@ BITCOIN_TESTS =\\\n if ENABLE_WALLET\n BITCOIN_TESTS += \\\n   wallet/test/accounting_tests.cpp \\\n+  wallet/test/psbt_wallet_tests.cpp \\\n   wallet/test/wallet_tests.cpp \\\n   wallet/test/wallet_crypto_tests.cpp \\\n   wallet/test/coinselector_tests.cpp"
      },
      {
        "sha": "a74ca85349e2f56d28c270370effd8e2107063d6",
        "filename": "src/wallet/test/psbt_wallet_tests.cpp",
        "status": "added",
        "additions": 74,
        "deletions": 0,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/020628e3a4e88e36647eaf92bac4b3552796ac6a/src/wallet/test/psbt_wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/020628e3a4e88e36647eaf92bac4b3552796ac6a/src/wallet/test/psbt_wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/psbt_wallet_tests.cpp?ref=020628e3a4e88e36647eaf92bac4b3552796ac6a",
        "patch": "@@ -0,0 +1,74 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <key_io.h>\n+#include <script/sign.h>\n+#include <utilstrencodings.h>\n+#include <wallet/rpcwallet.h>\n+#include <wallet/wallet.h>\n+#include <univalue.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <test/test_bitcoin.h>\n+#include <wallet/test/wallet_test_fixture.h>\n+\n+BOOST_FIXTURE_TEST_SUITE(psbt_wallet_tests, WalletTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(psbt_updater_test)\n+{\n+    // Create prevtxs and add to wallet\n+    CDataStream s_prev_tx1(ParseHex(\"0200000000010158e87a21b56daf0c23be8e7070456c336f7cbaa5c8757924f545887bb2abdd7501000000171600145f275f436b09a8cc9a2eb2a2f528485c68a56323feffffff02d8231f1b0100000017a914aed962d6654f9a2b36608eb9d64d2b260db4f1118700c2eb0b0000000017a914b7f5faf40e3d40a5a459b1db3535f2b72fa921e88702483045022100a22edcc6e5bc511af4cc4ae0de0fcd75c7e04d8c1c3a8aa9d820ed4b967384ec02200642963597b9b1bc22c75e9f3e117284a962188bf5e8a74c895089046a20ad770121035509a48eb623e10aace8bfd0212fdb8a8e5af3c94b0b133b95e114cab89e4f7965000000\"), SER_NETWORK, PROTOCOL_VERSION);\n+    CTransactionRef prev_tx1;\n+    s_prev_tx1 >> prev_tx1;\n+    CWalletTx prev_wtx1(&m_wallet, prev_tx1);\n+    m_wallet.mapWallet.emplace(prev_wtx1.GetHash(), std::move(prev_wtx1));\n+\n+    CDataStream s_prev_tx2(ParseHex(\"0200000001aad73931018bd25f84ae400b68848be09db706eac2ac18298babee71ab656f8b0000000048473044022058f6fc7c6a33e1b31548d481c826c015bd30135aad42cd67790dab66d2ad243b02204a1ced2604c6735b6393e5b41691dd78b00f0c5942fb9f751856faa938157dba01feffffff0280f0fa020000000017a9140fb9463421696b82c833af241c78c17ddbde493487d0f20a270100000017a91429ca74f8a08f81999428185c97b5d852e4063f618765000000\"), SER_NETWORK, PROTOCOL_VERSION);\n+    CTransactionRef prev_tx2;\n+    s_prev_tx2 >> prev_tx2;\n+    CWalletTx prev_wtx2(&m_wallet, prev_tx2);\n+    m_wallet.mapWallet.emplace(prev_wtx2.GetHash(), std::move(prev_wtx2));\n+\n+    // Add scripts\n+    CScript rs1;\n+    CDataStream s_rs1(ParseHex(\"475221029583bf39ae0a609747ad199addd634fa6108559d6c5cd39b4c2183f1ab96e07f2102dab61ff49a14db6a7d02b0cd1fbb78fc4b18312b5b4e54dae4dba2fbfef536d752ae\"), SER_NETWORK, PROTOCOL_VERSION);\n+    s_rs1 >> rs1;\n+    m_wallet.AddCScript(rs1);\n+\n+    CScript rs2;\n+    CDataStream s_rs2(ParseHex(\"2200208c2353173743b595dfb4a07b72ba8e42e3797da74e87fe7d9d7497e3b2028903\"), SER_NETWORK, PROTOCOL_VERSION);\n+    s_rs2 >> rs2;\n+    m_wallet.AddCScript(rs2);\n+\n+    CScript ws1;\n+    CDataStream s_ws1(ParseHex(\"47522103089dc10c7ac6db54f91329af617333db388cead0c231f723379d1b99030b02dc21023add904f3d6dcf59ddb906b0dee23529b7ffb9ed50e5e86151926860221f0e7352ae\"), SER_NETWORK, PROTOCOL_VERSION);\n+    s_ws1 >> ws1;\n+    m_wallet.AddCScript(ws1);\n+\n+    // Add hd seed\n+    CKey key = DecodeSecret(\"5KSSJQ7UNfFGwVgpCZDSHm5rVNhMFcFtvWM3zQ8mW4qNDEN7LFd\"); // Mainnet and uncompressed form of cUkG8i1RFfWGWy5ziR11zJ5V4U4W3viSFCfyJmZnvQaUsd1xuF3T\n+    CPubKey master_pub_key = m_wallet.DeriveNewSeed(key);\n+    m_wallet.SetHDSeed(master_pub_key);\n+    m_wallet.NewKeyPool();\n+\n+    // Call FillPSBT\n+    PartiallySignedTransaction psbtx;\n+    CDataStream ssData(ParseHex(\"70736274ff01009a020000000258e87a21b56daf0c23be8e7070456c336f7cbaa5c8757924f545887bb2abdd750000000000ffffffff838d0427d0ec650a68aa46bb0b098aea4422c071b2ca78352a077959d07cea1d0100000000ffffffff0270aaf00800000000160014d85c2b71d0060b09c9886aeb815e50991dda124d00e1f5050000000016001400aea9a2e5f0f876a588df5546e8742d1d87008f000000000000000000\"), SER_NETWORK, PROTOCOL_VERSION);\n+    ssData >> psbtx;\n+\n+    // Use CTransaction for the constant parts of the\n+    // transaction to avoid rehashing.\n+    const CTransaction txConst(*psbtx.tx);\n+\n+    // Fill transaction with our data\n+    FillPSBT(&m_wallet, psbtx, &txConst, 1, false, true);\n+\n+    // Get the final tx\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+    std::string final_hex = HexStr(ssTx.begin(), ssTx.end());\n+    BOOST_CHECK_EQUAL(final_hex, \"70736274ff01009a020000000258e87a21b56daf0c23be8e7070456c336f7cbaa5c8757924f545887bb2abdd750000000000ffffffff838d0427d0ec650a68aa46bb0b098aea4422c071b2ca78352a077959d07cea1d0100000000ffffffff0270aaf00800000000160014d85c2b71d0060b09c9886aeb815e50991dda124d00e1f5050000000016001400aea9a2e5f0f876a588df5546e8742d1d87008f00000000000100bb0200000001aad73931018bd25f84ae400b68848be09db706eac2ac18298babee71ab656f8b0000000048473044022058f6fc7c6a33e1b31548d481c826c015bd30135aad42cd67790dab66d2ad243b02204a1ced2604c6735b6393e5b41691dd78b00f0c5942fb9f751856faa938157dba01feffffff0280f0fa020000000017a9140fb9463421696b82c833af241c78c17ddbde493487d0f20a270100000017a91429ca74f8a08f81999428185c97b5d852e4063f6187650000000104475221029583bf39ae0a609747ad199addd634fa6108559d6c5cd39b4c2183f1ab96e07f2102dab61ff49a14db6a7d02b0cd1fbb78fc4b18312b5b4e54dae4dba2fbfef536d752ae2206029583bf39ae0a609747ad199addd634fa6108559d6c5cd39b4c2183f1ab96e07f10d90c6a4f000000800000008000000080220602dab61ff49a14db6a7d02b0cd1fbb78fc4b18312b5b4e54dae4dba2fbfef536d710d90c6a4f0000008000000080010000800001012000c2eb0b0000000017a914b7f5faf40e3d40a5a459b1db3535f2b72fa921e88701042200208c2353173743b595dfb4a07b72ba8e42e3797da74e87fe7d9d7497e3b2028903010547522103089dc10c7ac6db54f91329af617333db388cead0c231f723379d1b99030b02dc21023add904f3d6dcf59ddb906b0dee23529b7ffb9ed50e5e86151926860221f0e7352ae2206023add904f3d6dcf59ddb906b0dee23529b7ffb9ed50e5e86151926860221f0e7310d90c6a4f000000800000008003000080220603089dc10c7ac6db54f91329af617333db388cead0c231f723379d1b99030b02dc10d90c6a4f00000080000000800200008000220203a9a4c37f5996d3aa25dbac6b570af0650394492942460b354753ed9eeca5877110d90c6a4f000000800000008004000080002202027f6399757d2eff55a136ad02c684b1838b6556e5f1b6b34282a94b6b5005109610d90c6a4f00000080000000800500008000\");\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "b85bc31c48d442fc74de9cf3d0d0771eec9357aa",
        "filename": "test/functional/data/rpc_psbt.json",
        "status": "added",
        "additions": 78,
        "deletions": 0,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/020628e3a4e88e36647eaf92bac4b3552796ac6a/test/functional/data/rpc_psbt.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/020628e3a4e88e36647eaf92bac4b3552796ac6a/test/functional/data/rpc_psbt.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/data/rpc_psbt.json?ref=020628e3a4e88e36647eaf92bac4b3552796ac6a",
        "patch": "@@ -0,0 +1,78 @@\n+{\n+    \"invalid\" : [\n+        \"AgAAAAEmgXE3Ht/yhek3re6ks3t4AAwFZsuzrWRkFxPKQhcb9gAAAABqRzBEAiBwsiRRI+a/R01gxbUMBD1MaRpdJDXwmjSnZiqdwlF5CgIgATKcqdrPKAvfMHQOwDkEIkIsgctFg5RXrrdvwS7dlbMBIQJlfRGNM1e44PTCzUbbezn22cONmnCry5st5dyNv+TOMf7///8C09/1BQAAAAAZdqkU0MWZA8W6woaHYOkP1SGkZlqnZSCIrADh9QUAAAAAF6kUNUXm4zuDLEcFDyTT7rk8nAOUi8eHsy4TAA==\",\n+        \"cHNidP8BAHUCAAAAASaBcTce3/KF6Tet7qSze3gADAVmy7OtZGQXE8pCFxv2AAAAAAD+////AtPf9QUAAAAAGXapFNDFmQPFusKGh2DpD9UhpGZap2UgiKwA4fUFAAAAABepFDVF5uM7gyxHBQ8k0+65PJwDlIvHh7MuEwAAAQD9pQEBAAAAAAECiaPHHqtNIOA3G7ukzGmPopXJRjr6Ljl/hTPMti+VZ+UBAAAAFxYAFL4Y0VKpsBIDna89p95PUzSe7LmF/////4b4qkOnHf8USIk6UwpyN+9rRgi7st0tAXHmOuxqSJC0AQAAABcWABT+Pp7xp0XpdNkCxDVZQ6vLNL1TU/////8CAMLrCwAAAAAZdqkUhc/xCX/Z4Ai7NK9wnGIZeziXikiIrHL++E4sAAAAF6kUM5cluiHv1irHU6m80GfWx6ajnQWHAkcwRAIgJxK+IuAnDzlPVoMR3HyppolwuAJf3TskAinwf4pfOiQCIAGLONfc0xTnNMkna9b7QPZzMlvEuqFEyADS8vAtsnZcASED0uFWdJQbrUqZY3LLh+GFbTZSYG2YVi/jnF6efkE/IQUCSDBFAiEA0SuFLYXc2WHS9fSrZgZU327tzHlMDDPOXMMJ/7X85Y0CIGczio4OFyXBl/saiK9Z9R5E5CVbIBZ8hoQDHAXR8lkqASECI7cr7vCWXRC+B3jv7NYfysb3mk6haTkzgHNEZPhPKrMAAAAAAA==\",\n+        \"cHNidP8BAP0KAQIAAAACqwlJoIxa98SbghL0F+LxWrP1wz3PFTghqBOfh3pbe+QAAAAAakcwRAIgR1lmF5fAGwNrJZKJSGhiGDR9iYZLcZ4ff89X0eURZYcCIFMJ6r9Wqk2Ikf/REf3xM286KdqGbX+EhtdVRs7tr5MZASEDXNxh/HupccC1AaZGoqg7ECy0OIEhfKaC3Ibi1z+ogpL+////qwlJoIxa98SbghL0F+LxWrP1wz3PFTghqBOfh3pbe+QBAAAAAP7///8CYDvqCwAAAAAZdqkUdopAu9dAy+gdmI5x3ipNXHE5ax2IrI4kAAAAAAAAGXapFG9GILVT+glechue4O/p+gOcykWXiKwAAAAAAAABASAA4fUFAAAAABepFDVF5uM7gyxHBQ8k0+65PJwDlIvHhwEEFgAUhdE1N/LiZUBaNNuvqePdoB+4IwgAAAA=\",\n+        \"cHNidP8AAQD9pQEBAAAAAAECiaPHHqtNIOA3G7ukzGmPopXJRjr6Ljl/hTPMti+VZ+UBAAAAFxYAFL4Y0VKpsBIDna89p95PUzSe7LmF/////4b4qkOnHf8USIk6UwpyN+9rRgi7st0tAXHmOuxqSJC0AQAAABcWABT+Pp7xp0XpdNkCxDVZQ6vLNL1TU/////8CAMLrCwAAAAAZdqkUhc/xCX/Z4Ai7NK9wnGIZeziXikiIrHL++E4sAAAAF6kUM5cluiHv1irHU6m80GfWx6ajnQWHAkcwRAIgJxK+IuAnDzlPVoMR3HyppolwuAJf3TskAinwf4pfOiQCIAGLONfc0xTnNMkna9b7QPZzMlvEuqFEyADS8vAtsnZcASED0uFWdJQbrUqZY3LLh+GFbTZSYG2YVi/jnF6efkE/IQUCSDBFAiEA0SuFLYXc2WHS9fSrZgZU327tzHlMDDPOXMMJ/7X85Y0CIGczio4OFyXBl/saiK9Z9R5E5CVbIBZ8hoQDHAXR8lkqASECI7cr7vCWXRC+B3jv7NYfysb3mk6haTkzgHNEZPhPKrMAAAAAAA==\",\n+        \"cHNidP8BAHUCAAAAASaBcTce3/KF6Tet7qSze3gADAVmy7OtZGQXE8pCFxv2AAAAAAD+////AtPf9QUAAAAAGXapFNDFmQPFusKGh2DpD9UhpGZap2UgiKwA4fUFAAAAABepFDVF5uM7gyxHBQ8k0+65PJwDlIvHh7MuEwAAAQD9pQEBAAAAAAECiaPHHqtNIOA3G7ukzGmPopXJRjr6Ljl/hTPMti+VZ+UBAAAAFxYAFL4Y0VKpsBIDna89p95PUzSe7LmF/////4b4qkOnHf8USIk6UwpyN+9rRgi7st0tAXHmOuxqSJC0AQAAABcWABT+Pp7xp0XpdNkCxDVZQ6vLNL1TU/////8CAMLrCwAAAAAZdqkUhc/xCX/Z4Ai7NK9wnGIZeziXikiIrHL++E4sAAAAF6kUM5cluiHv1irHU6m80GfWx6ajnQWHAkcwRAIgJxK+IuAnDzlPVoMR3HyppolwuAJf3TskAinwf4pfOiQCIAGLONfc0xTnNMkna9b7QPZzMlvEuqFEyADS8vAtsnZcASED0uFWdJQbrUqZY3LLh+GFbTZSYG2YVi/jnF6efkE/IQUCSDBFAiEA0SuFLYXc2WHS9fSrZgZU327tzHlMDDPOXMMJ/7X85Y0CIGczio4OFyXBl/saiK9Z9R5E5CVbIBZ8hoQDHAXR8lkqASECI7cr7vCWXRC+B3jv7NYfysb3mk6haTkzgHNEZPhPKrMAAAAAAQA/AgAAAAH//////////////////////////////////////////wAAAAAA/////wEAAAAAAAAAAANqAQAAAAAAAAAA\"\n+    ],\n+    \"valid\" : [\n+        \"cHNidP8BAHUCAAAAASaBcTce3/KF6Tet7qSze3gADAVmy7OtZGQXE8pCFxv2AAAAAAD+////AtPf9QUAAAAAGXapFNDFmQPFusKGh2DpD9UhpGZap2UgiKwA4fUFAAAAABepFDVF5uM7gyxHBQ8k0+65PJwDlIvHh7MuEwAAAQD9pQEBAAAAAAECiaPHHqtNIOA3G7ukzGmPopXJRjr6Ljl/hTPMti+VZ+UBAAAAFxYAFL4Y0VKpsBIDna89p95PUzSe7LmF/////4b4qkOnHf8USIk6UwpyN+9rRgi7st0tAXHmOuxqSJC0AQAAABcWABT+Pp7xp0XpdNkCxDVZQ6vLNL1TU/////8CAMLrCwAAAAAZdqkUhc/xCX/Z4Ai7NK9wnGIZeziXikiIrHL++E4sAAAAF6kUM5cluiHv1irHU6m80GfWx6ajnQWHAkcwRAIgJxK+IuAnDzlPVoMR3HyppolwuAJf3TskAinwf4pfOiQCIAGLONfc0xTnNMkna9b7QPZzMlvEuqFEyADS8vAtsnZcASED0uFWdJQbrUqZY3LLh+GFbTZSYG2YVi/jnF6efkE/IQUCSDBFAiEA0SuFLYXc2WHS9fSrZgZU327tzHlMDDPOXMMJ/7X85Y0CIGczio4OFyXBl/saiK9Z9R5E5CVbIBZ8hoQDHAXR8lkqASECI7cr7vCWXRC+B3jv7NYfysb3mk6haTkzgHNEZPhPKrMAAAAAAAAA\",\n+        \"cHNidP8BAKACAAAAAqsJSaCMWvfEm4IS9Bfi8Vqz9cM9zxU4IagTn4d6W3vkAAAAAAD+////qwlJoIxa98SbghL0F+LxWrP1wz3PFTghqBOfh3pbe+QBAAAAAP7///8CYDvqCwAAAAAZdqkUdopAu9dAy+gdmI5x3ipNXHE5ax2IrI4kAAAAAAAAGXapFG9GILVT+glechue4O/p+gOcykWXiKwAAAAAAAEHakcwRAIgR1lmF5fAGwNrJZKJSGhiGDR9iYZLcZ4ff89X0eURZYcCIFMJ6r9Wqk2Ikf/REf3xM286KdqGbX+EhtdVRs7tr5MZASEDXNxh/HupccC1AaZGoqg7ECy0OIEhfKaC3Ibi1z+ogpIAAQEgAOH1BQAAAAAXqRQ1RebjO4MsRwUPJNPuuTycA5SLx4cBBBYAFIXRNTfy4mVAWjTbr6nj3aAfuCMIAAAA\",\n+        \"cHNidP8BAHUCAAAAASaBcTce3/KF6Tet7qSze3gADAVmy7OtZGQXE8pCFxv2AAAAAAD+////AtPf9QUAAAAAGXapFNDFmQPFusKGh2DpD9UhpGZap2UgiKwA4fUFAAAAABepFDVF5uM7gyxHBQ8k0+65PJwDlIvHh7MuEwAAAQD9pQEBAAAAAAECiaPHHqtNIOA3G7ukzGmPopXJRjr6Ljl/hTPMti+VZ+UBAAAAFxYAFL4Y0VKpsBIDna89p95PUzSe7LmF/////4b4qkOnHf8USIk6UwpyN+9rRgi7st0tAXHmOuxqSJC0AQAAABcWABT+Pp7xp0XpdNkCxDVZQ6vLNL1TU/////8CAMLrCwAAAAAZdqkUhc/xCX/Z4Ai7NK9wnGIZeziXikiIrHL++E4sAAAAF6kUM5cluiHv1irHU6m80GfWx6ajnQWHAkcwRAIgJxK+IuAnDzlPVoMR3HyppolwuAJf3TskAinwf4pfOiQCIAGLONfc0xTnNMkna9b7QPZzMlvEuqFEyADS8vAtsnZcASED0uFWdJQbrUqZY3LLh+GFbTZSYG2YVi/jnF6efkE/IQUCSDBFAiEA0SuFLYXc2WHS9fSrZgZU327tzHlMDDPOXMMJ/7X85Y0CIGczio4OFyXBl/saiK9Z9R5E5CVbIBZ8hoQDHAXR8lkqASECI7cr7vCWXRC+B3jv7NYfysb3mk6haTkzgHNEZPhPKrMAAAAAAQMEAQAAAAAAAA==\",\n+        \"cHNidP8BAKACAAAAAqsJSaCMWvfEm4IS9Bfi8Vqz9cM9zxU4IagTn4d6W3vkAAAAAAD+////qwlJoIxa98SbghL0F+LxWrP1wz3PFTghqBOfh3pbe+QBAAAAAP7///8CYDvqCwAAAAAZdqkUdopAu9dAy+gdmI5x3ipNXHE5ax2IrI4kAAAAAAAAGXapFG9GILVT+glechue4O/p+gOcykWXiKwAAAAAAAEA3wIAAAABJoFxNx7f8oXpN63upLN7eAAMBWbLs61kZBcTykIXG/YAAAAAakcwRAIgcLIkUSPmv0dNYMW1DAQ9TGkaXSQ18Jo0p2YqncJReQoCIAEynKnazygL3zB0DsA5BCJCLIHLRYOUV663b8Eu3ZWzASECZX0RjTNXuOD0ws1G23s59tnDjZpwq8ubLeXcjb/kzjH+////AtPf9QUAAAAAGXapFNDFmQPFusKGh2DpD9UhpGZap2UgiKwA4fUFAAAAABepFDVF5uM7gyxHBQ8k0+65PJwDlIvHh7MuEwAAAQEgAOH1BQAAAAAXqRQ1RebjO4MsRwUPJNPuuTycA5SLx4cBBBYAFIXRNTfy4mVAWjTbr6nj3aAfuCMIACICAurVlmh8qAYEPtw94RbN8p1eklfBls0FXPaYyNAr8k6ZELSmumcAAACAAAAAgAIAAIAAIgIDlPYr6d8ZlSxVh3aK63aYBhrSxKJciU9H2MFitNchPQUQtKa6ZwAAAIABAACAAgAAgAA=\",\n+        \"cHNidP8BAFUCAAAAASeaIyOl37UfxF8iD6WLD8E+HjNCeSqF1+Ns1jM7XLw5AAAAAAD/////AaBa6gsAAAAAGXapFP/pwAYQl8w7Y28ssEYPpPxCfStFiKwAAAAAAAEBIJVe6gsAAAAAF6kUY0UgD2jRieGtwN8cTRbqjxTA2+uHIgIDsTQcy6doO2r08SOM1ul+cWfVafrEfx5I1HVBhENVvUZGMEMCIAQktY7/qqaU4VWepck7v9SokGQiQFXN8HC2dxRpRC0HAh9cjrD+plFtYLisszrWTt5g6Hhb+zqpS5m9+GFR25qaAQEEIgAgdx/RitRZZm3Unz1WTj28QvTIR3TjYK2haBao7UiNVoEBBUdSIQOxNBzLp2g7avTxI4zW6X5xZ9Vp+sR/HkjUdUGEQ1W9RiED3lXR4drIBeP4pYwfv5uUwC89uq/hJ/78pJlfJvggg71SriIGA7E0HMunaDtq9PEjjNbpfnFn1Wn6xH8eSNR1QYRDVb1GELSmumcAAACAAAAAgAQAAIAiBgPeVdHh2sgF4/iljB+/m5TALz26r+En/vykmV8m+CCDvRC0prpnAAAAgAAAAIAFAACAAAA=\"\n+    ],\n+    \"creator\" : [\n+        {\n+            \"inputs\" : [\n+                {\n+                    \"txid\":\"75ddabb27b8845f5247975c8a5ba7c6f336c4570708ebe230caf6db5217ae858\",\n+                    \"vout\":0\n+                },\n+                {\n+                    \"txid\":\"1dea7cd05979072a3578cab271c02244ea8a090bbb46aa680a65ecd027048d83\",\n+                    \"vout\":1\n+                }\n+            ],\n+            \"outputs\" : [\n+                {\n+                    \"bcrt1qmpwzkuwsqc9snjvgdt4czhjsnywa5yjdqpxskv\":1.49990000\n+                },\n+                {\n+                    \"bcrt1qqzh2ngh97ru8dfvgma25d6r595wcwqy0cee4cc\": 1\n+                }\n+            ],\n+            \"result\" : \"cHNidP8BAJoCAAAAAljoeiG1ba8MI76OcHBFbDNvfLqlyHV5JPVFiHuyq911AAAAAAD/////g40EJ9DsZQpoqka7CwmK6kQiwHGyyng1Kgd5WdB86h0BAAAAAP////8CcKrwCAAAAAAWABTYXCtx0AYLCcmIauuBXlCZHdoSTQDh9QUAAAAAFgAUAK6pouXw+HaliN9VRuh0LR2HAI8AAAAAAAAAAAA=\"\n+        }\n+    ],\n+    \"signer\" : [\n+        {\n+            \"privkeys\" : [\n+                \"cP53pDbR5WtAD8dYAW9hhTjuvvTVaEiQBdrz9XPrgLBeRFiyCbQr\",\n+                \"cR6SXDoyfQrcp4piaiHE97Rsgta9mNhGTen9XeonVgwsh4iSgw6d\"\n+            ],\n+            \"psbt\" : \"cHNidP8BAJoCAAAAAljoeiG1ba8MI76OcHBFbDNvfLqlyHV5JPVFiHuyq911AAAAAAD/////g40EJ9DsZQpoqka7CwmK6kQiwHGyyng1Kgd5WdB86h0BAAAAAP////8CcKrwCAAAAAAWABTYXCtx0AYLCcmIauuBXlCZHdoSTQDh9QUAAAAAFgAUAK6pouXw+HaliN9VRuh0LR2HAI8AAAAAAAEAuwIAAAABqtc5MQGL0l+ErkALaISL4J23BurCrBgpi6vucatlb4sAAAAASEcwRAIgWPb8fGoz4bMVSNSByCbAFb0wE1qtQs1neQ2rZtKtJDsCIEoc7SYExnNbY5PltBaR3XiwDwxZQvufdRhW+qk4FX26Af7///8CgPD6AgAAAAAXqRQPuUY0IWlrgsgzryQceMF9295JNIfQ8gonAQAAABepFCnKdPigj4GZlCgYXJe12FLkBj9hh2UAAAABBEdSIQKVg785rgpgl0etGZrd1jT6YQhVnWxc05tMIYPxq5bgfyEC2rYf9JoU22p9ArDNH7t4/EsYMStbTlTa5Nui+/71NtdSriIGApWDvzmuCmCXR60Zmt3WNPphCFWdbFzTm0whg/GrluB/ENkMak8AAACAAAAAgAAAAIAiBgLath/0mhTban0CsM0fu3j8SxgxK1tOVNrk26L7/vU21xDZDGpPAAAAgAAAAIABAACAAQMEAQAAAAABASAAwusLAAAAABepFLf1+vQOPUClpFmx2zU18rcvqSHohwEEIgAgjCNTFzdDtZXftKB7crqOQuN5fadOh/59nXSX47ICiQMBBUdSIQMIncEMesbbVPkTKa9hczPbOIzq0MIx9yM3nRuZAwsC3CECOt2QTz1tz1nduQaw3uI1Kbf/ue1Q5ehhUZJoYCIfDnNSriIGAjrdkE89bc9Z3bkGsN7iNSm3/7ntUOXoYVGSaGAiHw5zENkMak8AAACAAAAAgAMAAIAiBgMIncEMesbbVPkTKa9hczPbOIzq0MIx9yM3nRuZAwsC3BDZDGpPAAAAgAAAAIACAACAAQMEAQAAAAAiAgOppMN/WZbTqiXbrGtXCvBlA5RJKUJGCzVHU+2e7KWHcRDZDGpPAAAAgAAAAIAEAACAACICAn9jmXV9Lv9VoTatAsaEsYOLZVbl8bazQoKpS2tQBRCWENkMak8AAACAAAAAgAUAAIAA\",\n+            \"result\" : \"cHNidP8BAJoCAAAAAljoeiG1ba8MI76OcHBFbDNvfLqlyHV5JPVFiHuyq911AAAAAAD/////g40EJ9DsZQpoqka7CwmK6kQiwHGyyng1Kgd5WdB86h0BAAAAAP////8CcKrwCAAAAAAWABTYXCtx0AYLCcmIauuBXlCZHdoSTQDh9QUAAAAAFgAUAK6pouXw+HaliN9VRuh0LR2HAI8AAAAAAAEAuwIAAAABqtc5MQGL0l+ErkALaISL4J23BurCrBgpi6vucatlb4sAAAAASEcwRAIgWPb8fGoz4bMVSNSByCbAFb0wE1qtQs1neQ2rZtKtJDsCIEoc7SYExnNbY5PltBaR3XiwDwxZQvufdRhW+qk4FX26Af7///8CgPD6AgAAAAAXqRQPuUY0IWlrgsgzryQceMF9295JNIfQ8gonAQAAABepFCnKdPigj4GZlCgYXJe12FLkBj9hh2UAAAAiAgKVg785rgpgl0etGZrd1jT6YQhVnWxc05tMIYPxq5bgf0cwRAIgdAGK1BgAl7hzMjwAFXILNoTMgSOJEEjn282bVa1nnJkCIHPTabdA4+tT3O+jOCPIBwUUylWn3ZVE8VfBZ5EyYRGMAQEDBAEAAAABBEdSIQKVg785rgpgl0etGZrd1jT6YQhVnWxc05tMIYPxq5bgfyEC2rYf9JoU22p9ArDNH7t4/EsYMStbTlTa5Nui+/71NtdSriIGApWDvzmuCmCXR60Zmt3WNPphCFWdbFzTm0whg/GrluB/ENkMak8AAACAAAAAgAAAAIAiBgLath/0mhTban0CsM0fu3j8SxgxK1tOVNrk26L7/vU21xDZDGpPAAAAgAAAAIABAACAAAEBIADC6wsAAAAAF6kUt/X69A49QKWkWbHbNTXyty+pIeiHIgIDCJ3BDHrG21T5EymvYXMz2ziM6tDCMfcjN50bmQMLAtxHMEQCIGLrelVhB6fHP0WsSrWh3d9vcHX7EnWWmn84Pv/3hLyyAiAMBdu3Rw2/LwhVfdNWxzJcHtMJE+mWzThAlF2xIijaXwEBAwQBAAAAAQQiACCMI1MXN0O1ld+0oHtyuo5C43l9p06H/n2ddJfjsgKJAwEFR1IhAwidwQx6xttU+RMpr2FzM9s4jOrQwjH3IzedG5kDCwLcIQI63ZBPPW3PWd25BrDe4jUpt/+57VDl6GFRkmhgIh8Oc1KuIgYCOt2QTz1tz1nduQaw3uI1Kbf/ue1Q5ehhUZJoYCIfDnMQ2QxqTwAAAIAAAACAAwAAgCIGAwidwQx6xttU+RMpr2FzM9s4jOrQwjH3IzedG5kDCwLcENkMak8AAACAAAAAgAIAAIAAIgIDqaTDf1mW06ol26xrVwrwZQOUSSlCRgs1R1Ptnuylh3EQ2QxqTwAAAIAAAACABAAAgAAiAgJ/Y5l1fS7/VaE2rQLGhLGDi2VW5fG2s0KCqUtrUAUQlhDZDGpPAAAAgAAAAIAFAACAAA==\"\n+        },\n+        {\n+            \"privkeys\" : [\n+                \"cT7J9YpCwY3AVRFSjN6ukeEeWY6mhpbJPxRaDaP5QTdygQRxP9Au\",\n+                \"cNBc3SWUip9PPm1GjRoLEJT6T41iNzCYtD7qro84FMnM5zEqeJsE\"\n+            ],\n+            \"psbt\" : \"cHNidP8BAJoCAAAAAljoeiG1ba8MI76OcHBFbDNvfLqlyHV5JPVFiHuyq911AAAAAAD/////g40EJ9DsZQpoqka7CwmK6kQiwHGyyng1Kgd5WdB86h0BAAAAAP////8CcKrwCAAAAAAWABTYXCtx0AYLCcmIauuBXlCZHdoSTQDh9QUAAAAAFgAUAK6pouXw+HaliN9VRuh0LR2HAI8AAAAAAAEAuwIAAAABqtc5MQGL0l+ErkALaISL4J23BurCrBgpi6vucatlb4sAAAAASEcwRAIgWPb8fGoz4bMVSNSByCbAFb0wE1qtQs1neQ2rZtKtJDsCIEoc7SYExnNbY5PltBaR3XiwDwxZQvufdRhW+qk4FX26Af7///8CgPD6AgAAAAAXqRQPuUY0IWlrgsgzryQceMF9295JNIfQ8gonAQAAABepFCnKdPigj4GZlCgYXJe12FLkBj9hh2UAAAABBEdSIQKVg785rgpgl0etGZrd1jT6YQhVnWxc05tMIYPxq5bgfyEC2rYf9JoU22p9ArDNH7t4/EsYMStbTlTa5Nui+/71NtdSriIGApWDvzmuCmCXR60Zmt3WNPphCFWdbFzTm0whg/GrluB/ENkMak8AAACAAAAAgAAAAIAiBgLath/0mhTban0CsM0fu3j8SxgxK1tOVNrk26L7/vU21xDZDGpPAAAAgAAAAIABAACAAQMEAQAAAAABASAAwusLAAAAABepFLf1+vQOPUClpFmx2zU18rcvqSHohwEEIgAgjCNTFzdDtZXftKB7crqOQuN5fadOh/59nXSX47ICiQMBBUdSIQMIncEMesbbVPkTKa9hczPbOIzq0MIx9yM3nRuZAwsC3CECOt2QTz1tz1nduQaw3uI1Kbf/ue1Q5ehhUZJoYCIfDnNSriIGAjrdkE89bc9Z3bkGsN7iNSm3/7ntUOXoYVGSaGAiHw5zENkMak8AAACAAAAAgAMAAIAiBgMIncEMesbbVPkTKa9hczPbOIzq0MIx9yM3nRuZAwsC3BDZDGpPAAAAgAAAAIACAACAAQMEAQAAAAAiAgOppMN/WZbTqiXbrGtXCvBlA5RJKUJGCzVHU+2e7KWHcRDZDGpPAAAAgAAAAIAEAACAACICAn9jmXV9Lv9VoTatAsaEsYOLZVbl8bazQoKpS2tQBRCWENkMak8AAACAAAAAgAUAAIAA\",\n+            \"result\" : \"cHNidP8BAJoCAAAAAljoeiG1ba8MI76OcHBFbDNvfLqlyHV5JPVFiHuyq911AAAAAAD/////g40EJ9DsZQpoqka7CwmK6kQiwHGyyng1Kgd5WdB86h0BAAAAAP////8CcKrwCAAAAAAWABTYXCtx0AYLCcmIauuBXlCZHdoSTQDh9QUAAAAAFgAUAK6pouXw+HaliN9VRuh0LR2HAI8AAAAAAAEAuwIAAAABqtc5MQGL0l+ErkALaISL4J23BurCrBgpi6vucatlb4sAAAAASEcwRAIgWPb8fGoz4bMVSNSByCbAFb0wE1qtQs1neQ2rZtKtJDsCIEoc7SYExnNbY5PltBaR3XiwDwxZQvufdRhW+qk4FX26Af7///8CgPD6AgAAAAAXqRQPuUY0IWlrgsgzryQceMF9295JNIfQ8gonAQAAABepFCnKdPigj4GZlCgYXJe12FLkBj9hh2UAAAAiAgLath/0mhTban0CsM0fu3j8SxgxK1tOVNrk26L7/vU210gwRQIhAPYQOLMI3B2oZaNIUnRvAVdyk0IIxtJEVDk82ZvfIhd3AiAFbmdaZ1ptCgK4WxTl4pB02KJam1dgvqKBb2YZEKAG6gEBAwQBAAAAAQRHUiEClYO/Oa4KYJdHrRma3dY0+mEIVZ1sXNObTCGD8auW4H8hAtq2H/SaFNtqfQKwzR+7ePxLGDErW05U2uTbovv+9TbXUq4iBgKVg785rgpgl0etGZrd1jT6YQhVnWxc05tMIYPxq5bgfxDZDGpPAAAAgAAAAIAAAACAIgYC2rYf9JoU22p9ArDNH7t4/EsYMStbTlTa5Nui+/71NtcQ2QxqTwAAAIAAAACAAQAAgAABASAAwusLAAAAABepFLf1+vQOPUClpFmx2zU18rcvqSHohyICAjrdkE89bc9Z3bkGsN7iNSm3/7ntUOXoYVGSaGAiHw5zRzBEAiBl9FulmYtZon/+GnvtAWrx8fkNVLOqj3RQql9WolEDvQIgf3JHA60e25ZoCyhLVtT/y4j3+3Weq74IqjDym4UTg9IBAQMEAQAAAAEEIgAgjCNTFzdDtZXftKB7crqOQuN5fadOh/59nXSX47ICiQMBBUdSIQMIncEMesbbVPkTKa9hczPbOIzq0MIx9yM3nRuZAwsC3CECOt2QTz1tz1nduQaw3uI1Kbf/ue1Q5ehhUZJoYCIfDnNSriIGAjrdkE89bc9Z3bkGsN7iNSm3/7ntUOXoYVGSaGAiHw5zENkMak8AAACAAAAAgAMAAIAiBgMIncEMesbbVPkTKa9hczPbOIzq0MIx9yM3nRuZAwsC3BDZDGpPAAAAgAAAAIACAACAACICA6mkw39ZltOqJdusa1cK8GUDlEkpQkYLNUdT7Z7spYdxENkMak8AAACAAAAAgAQAAIAAIgICf2OZdX0u/1WhNq0CxoSxg4tlVuXxtrNCgqlLa1AFEJYQ2QxqTwAAAIAAAACABQAAgAA=\"\n+        }\n+    ],\n+    \"combiner\" : [\n+        {\n+            \"combine\" : [\n+                \"cHNidP8BAJoCAAAAAljoeiG1ba8MI76OcHBFbDNvfLqlyHV5JPVFiHuyq911AAAAAAD/////g40EJ9DsZQpoqka7CwmK6kQiwHGyyng1Kgd5WdB86h0BAAAAAP////8CcKrwCAAAAAAWABTYXCtx0AYLCcmIauuBXlCZHdoSTQDh9QUAAAAAFgAUAK6pouXw+HaliN9VRuh0LR2HAI8AAAAAAAEAuwIAAAABqtc5MQGL0l+ErkALaISL4J23BurCrBgpi6vucatlb4sAAAAASEcwRAIgWPb8fGoz4bMVSNSByCbAFb0wE1qtQs1neQ2rZtKtJDsCIEoc7SYExnNbY5PltBaR3XiwDwxZQvufdRhW+qk4FX26Af7///8CgPD6AgAAAAAXqRQPuUY0IWlrgsgzryQceMF9295JNIfQ8gonAQAAABepFCnKdPigj4GZlCgYXJe12FLkBj9hh2UAAAAiAgKVg785rgpgl0etGZrd1jT6YQhVnWxc05tMIYPxq5bgf0cwRAIgdAGK1BgAl7hzMjwAFXILNoTMgSOJEEjn282bVa1nnJkCIHPTabdA4+tT3O+jOCPIBwUUylWn3ZVE8VfBZ5EyYRGMAQEDBAEAAAABBEdSIQKVg785rgpgl0etGZrd1jT6YQhVnWxc05tMIYPxq5bgfyEC2rYf9JoU22p9ArDNH7t4/EsYMStbTlTa5Nui+/71NtdSriIGApWDvzmuCmCXR60Zmt3WNPphCFWdbFzTm0whg/GrluB/ENkMak8AAACAAAAAgAAAAIAiBgLath/0mhTban0CsM0fu3j8SxgxK1tOVNrk26L7/vU21xDZDGpPAAAAgAAAAIABAACAAAEBIADC6wsAAAAAF6kUt/X69A49QKWkWbHbNTXyty+pIeiHIgIDCJ3BDHrG21T5EymvYXMz2ziM6tDCMfcjN50bmQMLAtxHMEQCIGLrelVhB6fHP0WsSrWh3d9vcHX7EnWWmn84Pv/3hLyyAiAMBdu3Rw2/LwhVfdNWxzJcHtMJE+mWzThAlF2xIijaXwEBAwQBAAAAAQQiACCMI1MXN0O1ld+0oHtyuo5C43l9p06H/n2ddJfjsgKJAwEFR1IhAwidwQx6xttU+RMpr2FzM9s4jOrQwjH3IzedG5kDCwLcIQI63ZBPPW3PWd25BrDe4jUpt/+57VDl6GFRkmhgIh8Oc1KuIgYCOt2QTz1tz1nduQaw3uI1Kbf/ue1Q5ehhUZJoYCIfDnMQ2QxqTwAAAIAAAACAAwAAgCIGAwidwQx6xttU+RMpr2FzM9s4jOrQwjH3IzedG5kDCwLcENkMak8AAACAAAAAgAIAAIAAIgIDqaTDf1mW06ol26xrVwrwZQOUSSlCRgs1R1Ptnuylh3EQ2QxqTwAAAIAAAACABAAAgAAiAgJ/Y5l1fS7/VaE2rQLGhLGDi2VW5fG2s0KCqUtrUAUQlhDZDGpPAAAAgAAAAIAFAACAAA==\",\n+                \"cHNidP8BAJoCAAAAAljoeiG1ba8MI76OcHBFbDNvfLqlyHV5JPVFiHuyq911AAAAAAD/////g40EJ9DsZQpoqka7CwmK6kQiwHGyyng1Kgd5WdB86h0BAAAAAP////8CcKrwCAAAAAAWABTYXCtx0AYLCcmIauuBXlCZHdoSTQDh9QUAAAAAFgAUAK6pouXw+HaliN9VRuh0LR2HAI8AAAAAAAEAuwIAAAABqtc5MQGL0l+ErkALaISL4J23BurCrBgpi6vucatlb4sAAAAASEcwRAIgWPb8fGoz4bMVSNSByCbAFb0wE1qtQs1neQ2rZtKtJDsCIEoc7SYExnNbY5PltBaR3XiwDwxZQvufdRhW+qk4FX26Af7///8CgPD6AgAAAAAXqRQPuUY0IWlrgsgzryQceMF9295JNIfQ8gonAQAAABepFCnKdPigj4GZlCgYXJe12FLkBj9hh2UAAAAiAgLath/0mhTban0CsM0fu3j8SxgxK1tOVNrk26L7/vU210gwRQIhAPYQOLMI3B2oZaNIUnRvAVdyk0IIxtJEVDk82ZvfIhd3AiAFbmdaZ1ptCgK4WxTl4pB02KJam1dgvqKBb2YZEKAG6gEBAwQBAAAAAQRHUiEClYO/Oa4KYJdHrRma3dY0+mEIVZ1sXNObTCGD8auW4H8hAtq2H/SaFNtqfQKwzR+7ePxLGDErW05U2uTbovv+9TbXUq4iBgKVg785rgpgl0etGZrd1jT6YQhVnWxc05tMIYPxq5bgfxDZDGpPAAAAgAAAAIAAAACAIgYC2rYf9JoU22p9ArDNH7t4/EsYMStbTlTa5Nui+/71NtcQ2QxqTwAAAIAAAACAAQAAgAABASAAwusLAAAAABepFLf1+vQOPUClpFmx2zU18rcvqSHohyICAjrdkE89bc9Z3bkGsN7iNSm3/7ntUOXoYVGSaGAiHw5zRzBEAiBl9FulmYtZon/+GnvtAWrx8fkNVLOqj3RQql9WolEDvQIgf3JHA60e25ZoCyhLVtT/y4j3+3Weq74IqjDym4UTg9IBAQMEAQAAAAEEIgAgjCNTFzdDtZXftKB7crqOQuN5fadOh/59nXSX47ICiQMBBUdSIQMIncEMesbbVPkTKa9hczPbOIzq0MIx9yM3nRuZAwsC3CECOt2QTz1tz1nduQaw3uI1Kbf/ue1Q5ehhUZJoYCIfDnNSriIGAjrdkE89bc9Z3bkGsN7iNSm3/7ntUOXoYVGSaGAiHw5zENkMak8AAACAAAAAgAMAAIAiBgMIncEMesbbVPkTKa9hczPbOIzq0MIx9yM3nRuZAwsC3BDZDGpPAAAAgAAAAIACAACAACICA6mkw39ZltOqJdusa1cK8GUDlEkpQkYLNUdT7Z7spYdxENkMak8AAACAAAAAgAQAAIAAIgICf2OZdX0u/1WhNq0CxoSxg4tlVuXxtrNCgqlLa1AFEJYQ2QxqTwAAAIAAAACABQAAgAA=\"\n+            ],\n+            \"result\" : \"cHNidP8BAJoCAAAAAljoeiG1ba8MI76OcHBFbDNvfLqlyHV5JPVFiHuyq911AAAAAAD/////g40EJ9DsZQpoqka7CwmK6kQiwHGyyng1Kgd5WdB86h0BAAAAAP////8CcKrwCAAAAAAWABTYXCtx0AYLCcmIauuBXlCZHdoSTQDh9QUAAAAAFgAUAK6pouXw+HaliN9VRuh0LR2HAI8AAAAAAAEAuwIAAAABqtc5MQGL0l+ErkALaISL4J23BurCrBgpi6vucatlb4sAAAAASEcwRAIgWPb8fGoz4bMVSNSByCbAFb0wE1qtQs1neQ2rZtKtJDsCIEoc7SYExnNbY5PltBaR3XiwDwxZQvufdRhW+qk4FX26Af7///8CgPD6AgAAAAAXqRQPuUY0IWlrgsgzryQceMF9295JNIfQ8gonAQAAABepFCnKdPigj4GZlCgYXJe12FLkBj9hh2UAAAAiAgKVg785rgpgl0etGZrd1jT6YQhVnWxc05tMIYPxq5bgf0cwRAIgdAGK1BgAl7hzMjwAFXILNoTMgSOJEEjn282bVa1nnJkCIHPTabdA4+tT3O+jOCPIBwUUylWn3ZVE8VfBZ5EyYRGMASICAtq2H/SaFNtqfQKwzR+7ePxLGDErW05U2uTbovv+9TbXSDBFAiEA9hA4swjcHahlo0hSdG8BV3KTQgjG0kRUOTzZm98iF3cCIAVuZ1pnWm0KArhbFOXikHTYolqbV2C+ooFvZhkQoAbqAQEDBAEAAAABBEdSIQKVg785rgpgl0etGZrd1jT6YQhVnWxc05tMIYPxq5bgfyEC2rYf9JoU22p9ArDNH7t4/EsYMStbTlTa5Nui+/71NtdSriIGApWDvzmuCmCXR60Zmt3WNPphCFWdbFzTm0whg/GrluB/ENkMak8AAACAAAAAgAAAAIAiBgLath/0mhTban0CsM0fu3j8SxgxK1tOVNrk26L7/vU21xDZDGpPAAAAgAAAAIABAACAAAEBIADC6wsAAAAAF6kUt/X69A49QKWkWbHbNTXyty+pIeiHIgIDCJ3BDHrG21T5EymvYXMz2ziM6tDCMfcjN50bmQMLAtxHMEQCIGLrelVhB6fHP0WsSrWh3d9vcHX7EnWWmn84Pv/3hLyyAiAMBdu3Rw2/LwhVfdNWxzJcHtMJE+mWzThAlF2xIijaXwEiAgI63ZBPPW3PWd25BrDe4jUpt/+57VDl6GFRkmhgIh8Oc0cwRAIgZfRbpZmLWaJ//hp77QFq8fH5DVSzqo90UKpfVqJRA70CIH9yRwOtHtuWaAsoS1bU/8uI9/t1nqu+CKow8puFE4PSAQEDBAEAAAABBCIAIIwjUxc3Q7WV37Sge3K6jkLjeX2nTof+fZ10l+OyAokDAQVHUiEDCJ3BDHrG21T5EymvYXMz2ziM6tDCMfcjN50bmQMLAtwhAjrdkE89bc9Z3bkGsN7iNSm3/7ntUOXoYVGSaGAiHw5zUq4iBgI63ZBPPW3PWd25BrDe4jUpt/+57VDl6GFRkmhgIh8OcxDZDGpPAAAAgAAAAIADAACAIgYDCJ3BDHrG21T5EymvYXMz2ziM6tDCMfcjN50bmQMLAtwQ2QxqTwAAAIAAAACAAgAAgAAiAgOppMN/WZbTqiXbrGtXCvBlA5RJKUJGCzVHU+2e7KWHcRDZDGpPAAAAgAAAAIAEAACAACICAn9jmXV9Lv9VoTatAsaEsYOLZVbl8bazQoKpS2tQBRCWENkMak8AAACAAAAAgAUAAIAA\"\n+        }\n+    ],\n+    \"finalizer\" : [\n+        {\n+            \"finalize\" : \"cHNidP8BAJoCAAAAAljoeiG1ba8MI76OcHBFbDNvfLqlyHV5JPVFiHuyq911AAAAAAD/////g40EJ9DsZQpoqka7CwmK6kQiwHGyyng1Kgd5WdB86h0BAAAAAP////8CcKrwCAAAAAAWABTYXCtx0AYLCcmIauuBXlCZHdoSTQDh9QUAAAAAFgAUAK6pouXw+HaliN9VRuh0LR2HAI8AAAAAAAEAuwIAAAABqtc5MQGL0l+ErkALaISL4J23BurCrBgpi6vucatlb4sAAAAASEcwRAIgWPb8fGoz4bMVSNSByCbAFb0wE1qtQs1neQ2rZtKtJDsCIEoc7SYExnNbY5PltBaR3XiwDwxZQvufdRhW+qk4FX26Af7///8CgPD6AgAAAAAXqRQPuUY0IWlrgsgzryQceMF9295JNIfQ8gonAQAAABepFCnKdPigj4GZlCgYXJe12FLkBj9hh2UAAAAiAgKVg785rgpgl0etGZrd1jT6YQhVnWxc05tMIYPxq5bgf0cwRAIgdAGK1BgAl7hzMjwAFXILNoTMgSOJEEjn282bVa1nnJkCIHPTabdA4+tT3O+jOCPIBwUUylWn3ZVE8VfBZ5EyYRGMASICAtq2H/SaFNtqfQKwzR+7ePxLGDErW05U2uTbovv+9TbXSDBFAiEA9hA4swjcHahlo0hSdG8BV3KTQgjG0kRUOTzZm98iF3cCIAVuZ1pnWm0KArhbFOXikHTYolqbV2C+ooFvZhkQoAbqAQEDBAEAAAABBEdSIQKVg785rgpgl0etGZrd1jT6YQhVnWxc05tMIYPxq5bgfyEC2rYf9JoU22p9ArDNH7t4/EsYMStbTlTa5Nui+/71NtdSriIGApWDvzmuCmCXR60Zmt3WNPphCFWdbFzTm0whg/GrluB/ENkMak8AAACAAAAAgAAAAIAiBgLath/0mhTban0CsM0fu3j8SxgxK1tOVNrk26L7/vU21xDZDGpPAAAAgAAAAIABAACAAAEBIADC6wsAAAAAF6kUt/X69A49QKWkWbHbNTXyty+pIeiHIgIDCJ3BDHrG21T5EymvYXMz2ziM6tDCMfcjN50bmQMLAtxHMEQCIGLrelVhB6fHP0WsSrWh3d9vcHX7EnWWmn84Pv/3hLyyAiAMBdu3Rw2/LwhVfdNWxzJcHtMJE+mWzThAlF2xIijaXwEiAgI63ZBPPW3PWd25BrDe4jUpt/+57VDl6GFRkmhgIh8Oc0cwRAIgZfRbpZmLWaJ//hp77QFq8fH5DVSzqo90UKpfVqJRA70CIH9yRwOtHtuWaAsoS1bU/8uI9/t1nqu+CKow8puFE4PSAQEDBAEAAAABBCIAIIwjUxc3Q7WV37Sge3K6jkLjeX2nTof+fZ10l+OyAokDAQVHUiEDCJ3BDHrG21T5EymvYXMz2ziM6tDCMfcjN50bmQMLAtwhAjrdkE89bc9Z3bkGsN7iNSm3/7ntUOXoYVGSaGAiHw5zUq4iBgI63ZBPPW3PWd25BrDe4jUpt/+57VDl6GFRkmhgIh8OcxDZDGpPAAAAgAAAAIADAACAIgYDCJ3BDHrG21T5EymvYXMz2ziM6tDCMfcjN50bmQMLAtwQ2QxqTwAAAIAAAACAAgAAgAAiAgOppMN/WZbTqiXbrGtXCvBlA5RJKUJGCzVHU+2e7KWHcRDZDGpPAAAAgAAAAIAEAACAACICAn9jmXV9Lv9VoTatAsaEsYOLZVbl8bazQoKpS2tQBRCWENkMak8AAACAAAAAgAUAAIAA\",\n+            \"result\" : \"cHNidP8BAJoCAAAAAljoeiG1ba8MI76OcHBFbDNvfLqlyHV5JPVFiHuyq911AAAAAAD/////g40EJ9DsZQpoqka7CwmK6kQiwHGyyng1Kgd5WdB86h0BAAAAAP////8CcKrwCAAAAAAWABTYXCtx0AYLCcmIauuBXlCZHdoSTQDh9QUAAAAAFgAUAK6pouXw+HaliN9VRuh0LR2HAI8AAAAAAAEAuwIAAAABqtc5MQGL0l+ErkALaISL4J23BurCrBgpi6vucatlb4sAAAAASEcwRAIgWPb8fGoz4bMVSNSByCbAFb0wE1qtQs1neQ2rZtKtJDsCIEoc7SYExnNbY5PltBaR3XiwDwxZQvufdRhW+qk4FX26Af7///8CgPD6AgAAAAAXqRQPuUY0IWlrgsgzryQceMF9295JNIfQ8gonAQAAABepFCnKdPigj4GZlCgYXJe12FLkBj9hh2UAAAABB9oARzBEAiB0AYrUGACXuHMyPAAVcgs2hMyBI4kQSOfbzZtVrWecmQIgc9Npt0Dj61Pc76M4I8gHBRTKVafdlUTxV8FnkTJhEYwBSDBFAiEA9hA4swjcHahlo0hSdG8BV3KTQgjG0kRUOTzZm98iF3cCIAVuZ1pnWm0KArhbFOXikHTYolqbV2C+ooFvZhkQoAbqAUdSIQKVg785rgpgl0etGZrd1jT6YQhVnWxc05tMIYPxq5bgfyEC2rYf9JoU22p9ArDNH7t4/EsYMStbTlTa5Nui+/71NtdSrgABASAAwusLAAAAABepFLf1+vQOPUClpFmx2zU18rcvqSHohwEHIyIAIIwjUxc3Q7WV37Sge3K6jkLjeX2nTof+fZ10l+OyAokDAQjaBABHMEQCIGLrelVhB6fHP0WsSrWh3d9vcHX7EnWWmn84Pv/3hLyyAiAMBdu3Rw2/LwhVfdNWxzJcHtMJE+mWzThAlF2xIijaXwFHMEQCIGX0W6WZi1mif/4ae+0BavHx+Q1Us6qPdFCqX1aiUQO9AiB/ckcDrR7blmgLKEtW1P/LiPf7dZ6rvgiqMPKbhROD0gFHUiEDCJ3BDHrG21T5EymvYXMz2ziM6tDCMfcjN50bmQMLAtwhAjrdkE89bc9Z3bkGsN7iNSm3/7ntUOXoYVGSaGAiHw5zUq4AIgIDqaTDf1mW06ol26xrVwrwZQOUSSlCRgs1R1Ptnuylh3EQ2QxqTwAAAIAAAACABAAAgAAiAgJ/Y5l1fS7/VaE2rQLGhLGDi2VW5fG2s0KCqUtrUAUQlhDZDGpPAAAAgAAAAIAFAACAAA==\"\n+        }\n+    ],\n+    \"extractor\" : [\n+        {\n+            \"extract\" : \"cHNidP8BAJoCAAAAAljoeiG1ba8MI76OcHBFbDNvfLqlyHV5JPVFiHuyq911AAAAAAD/////g40EJ9DsZQpoqka7CwmK6kQiwHGyyng1Kgd5WdB86h0BAAAAAP////8CcKrwCAAAAAAWABTYXCtx0AYLCcmIauuBXlCZHdoSTQDh9QUAAAAAFgAUAK6pouXw+HaliN9VRuh0LR2HAI8AAAAAAAEAuwIAAAABqtc5MQGL0l+ErkALaISL4J23BurCrBgpi6vucatlb4sAAAAASEcwRAIgWPb8fGoz4bMVSNSByCbAFb0wE1qtQs1neQ2rZtKtJDsCIEoc7SYExnNbY5PltBaR3XiwDwxZQvufdRhW+qk4FX26Af7///8CgPD6AgAAAAAXqRQPuUY0IWlrgsgzryQceMF9295JNIfQ8gonAQAAABepFCnKdPigj4GZlCgYXJe12FLkBj9hh2UAAAABB9oARzBEAiB0AYrUGACXuHMyPAAVcgs2hMyBI4kQSOfbzZtVrWecmQIgc9Npt0Dj61Pc76M4I8gHBRTKVafdlUTxV8FnkTJhEYwBSDBFAiEA9hA4swjcHahlo0hSdG8BV3KTQgjG0kRUOTzZm98iF3cCIAVuZ1pnWm0KArhbFOXikHTYolqbV2C+ooFvZhkQoAbqAUdSIQKVg785rgpgl0etGZrd1jT6YQhVnWxc05tMIYPxq5bgfyEC2rYf9JoU22p9ArDNH7t4/EsYMStbTlTa5Nui+/71NtdSrgABASAAwusLAAAAABepFLf1+vQOPUClpFmx2zU18rcvqSHohwEHIyIAIIwjUxc3Q7WV37Sge3K6jkLjeX2nTof+fZ10l+OyAokDAQjaBABHMEQCIGLrelVhB6fHP0WsSrWh3d9vcHX7EnWWmn84Pv/3hLyyAiAMBdu3Rw2/LwhVfdNWxzJcHtMJE+mWzThAlF2xIijaXwFHMEQCIGX0W6WZi1mif/4ae+0BavHx+Q1Us6qPdFCqX1aiUQO9AiB/ckcDrR7blmgLKEtW1P/LiPf7dZ6rvgiqMPKbhROD0gFHUiEDCJ3BDHrG21T5EymvYXMz2ziM6tDCMfcjN50bmQMLAtwhAjrdkE89bc9Z3bkGsN7iNSm3/7ntUOXoYVGSaGAiHw5zUq4AIgIDqaTDf1mW06ol26xrVwrwZQOUSSlCRgs1R1Ptnuylh3EQ2QxqTwAAAIAAAACABAAAgAAiAgJ/Y5l1fS7/VaE2rQLGhLGDi2VW5fG2s0KCqUtrUAUQlhDZDGpPAAAAgAAAAIAFAACAAA==\",\n+            \"result\" : \"0200000000010258e87a21b56daf0c23be8e7070456c336f7cbaa5c8757924f545887bb2abdd7500000000da00473044022074018ad4180097b873323c0015720b3684cc8123891048e7dbcd9b55ad679c99022073d369b740e3eb53dcefa33823c8070514ca55a7dd9544f157c167913261118c01483045022100f61038b308dc1da865a34852746f015772934208c6d24454393cd99bdf2217770220056e675a675a6d0a02b85b14e5e29074d8a25a9b5760bea2816f661910a006ea01475221029583bf39ae0a609747ad199addd634fa6108559d6c5cd39b4c2183f1ab96e07f2102dab61ff49a14db6a7d02b0cd1fbb78fc4b18312b5b4e54dae4dba2fbfef536d752aeffffffff838d0427d0ec650a68aa46bb0b098aea4422c071b2ca78352a077959d07cea1d01000000232200208c2353173743b595dfb4a07b72ba8e42e3797da74e87fe7d9d7497e3b2028903ffffffff0270aaf00800000000160014d85c2b71d0060b09c9886aeb815e50991dda124d00e1f5050000000016001400aea9a2e5f0f876a588df5546e8742d1d87008f000400473044022062eb7a556107a7c73f45ac4ab5a1dddf6f7075fb1275969a7f383efff784bcb202200c05dbb7470dbf2f08557dd356c7325c1ed30913e996cd3840945db12228da5f01473044022065f45ba5998b59a27ffe1a7bed016af1f1f90d54b3aa8f7450aa5f56a25103bd02207f724703ad1edb96680b284b56d4ffcb88f7fb759eabbe08aa30f29b851383d20147522103089dc10c7ac6db54f91329af617333db388cead0c231f723379d1b99030b02dc21023add904f3d6dcf59ddb906b0dee23529b7ffb9ed50e5e86151926860221f0e7352ae00000000\"\n+        }\n+    ]\n+}\n\\ No newline at end of file"
      },
      {
        "sha": "a68327496fea9b5573d0616712f347eea83079b6",
        "filename": "test/functional/rpc_psbt.py",
        "status": "added",
        "additions": 190,
        "deletions": 0,
        "changes": 190,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/020628e3a4e88e36647eaf92bac4b3552796ac6a/test/functional/rpc_psbt.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/020628e3a4e88e36647eaf92bac4b3552796ac6a/test/functional/rpc_psbt.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_psbt.py?ref=020628e3a4e88e36647eaf92bac4b3552796ac6a",
        "patch": "@@ -0,0 +1,190 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the Partially Signed Transaction RPCs.\n+\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+# Create one-input, one-output, no-fee transaction:\n+class PSBTTest(BitcoinTestFramework):\n+\n+    def set_test_params(self):\n+        self.setup_clean_chain = False\n+        self.num_nodes = 3\n+\n+    def run_test(self):\n+        # Create and fund a raw tx for sending 10 BTC\n+        psbtx1 = self.nodes[0].walletcreatefundedpsbt([], {self.nodes[2].getnewaddress():10})['psbt']\n+\n+        # Node 1 should not be able to add anything to it but still return the psbtx same as before\n+        psbtx = self.nodes[1].walletprocesspsbt(psbtx1)['psbt']\n+        assert_equal(psbtx1, psbtx)\n+\n+        # Sign the transaction and send\n+        signed_tx = self.nodes[0].walletprocesspsbt(psbtx)['psbt']\n+        final_tx = self.nodes[0].finalizepsbt(signed_tx)['hex']\n+        self.nodes[0].sendrawtransaction(final_tx)\n+\n+        # Create p2sh, p2wpkh, and p2wsh addresses\n+        pubkey0 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())['pubkey']\n+        pubkey1 = self.nodes[1].getaddressinfo(self.nodes[1].getnewaddress())['pubkey']\n+        pubkey2 = self.nodes[2].getaddressinfo(self.nodes[2].getnewaddress())['pubkey']\n+        p2sh = self.nodes[1].addmultisigaddress(2, [pubkey0, pubkey1, pubkey2], \"\", \"legacy\")['address']\n+        p2wsh = self.nodes[1].addmultisigaddress(2, [pubkey0, pubkey1, pubkey2], \"\", \"bech32\")['address']\n+        p2sh_p2wsh = self.nodes[1].addmultisigaddress(2, [pubkey0, pubkey1, pubkey2], \"\", \"p2sh-segwit\")['address']\n+        p2wpkh = self.nodes[1].getnewaddress(\"\", \"bech32\")\n+        p2pkh = self.nodes[1].getnewaddress(\"\", \"legacy\")\n+        p2sh_p2wpkh = self.nodes[1].getnewaddress(\"\", \"p2sh-segwit\")\n+\n+        # fund those addresses\n+        rawtx = self.nodes[0].createrawtransaction([], {p2sh:10, p2wsh:10, p2wpkh:10, p2sh_p2wsh:10, p2sh_p2wpkh:10, p2pkh:10})\n+        rawtx = self.nodes[0].fundrawtransaction(rawtx, {\"changePosition\":3})\n+        signed_tx = self.nodes[0].signrawtransactionwithwallet(rawtx['hex'])['hex']\n+        txid = self.nodes[0].sendrawtransaction(signed_tx)\n+        self.nodes[0].generate(6)\n+        self.sync_all()\n+\n+        # Find the output pos\n+        p2sh_pos = -1\n+        p2wsh_pos = -1\n+        p2wpkh_pos = -1\n+        p2pkh_pos = -1\n+        p2sh_p2wsh_pos = -1\n+        p2sh_p2wpkh_pos = -1\n+        decoded = self.nodes[0].decoderawtransaction(signed_tx)\n+        for out in decoded['vout']:\n+            if out['scriptPubKey']['addresses'][0] == p2sh:\n+                p2sh_pos = out['n']\n+            elif out['scriptPubKey']['addresses'][0] == p2wsh:\n+                p2wsh_pos = out['n']\n+            elif out['scriptPubKey']['addresses'][0] == p2wpkh:\n+                p2wpkh_pos = out['n']\n+            elif out['scriptPubKey']['addresses'][0] == p2sh_p2wsh:\n+                p2sh_p2wsh_pos = out['n']\n+            elif out['scriptPubKey']['addresses'][0] == p2sh_p2wpkh:\n+                p2sh_p2wpkh_pos = out['n']\n+            elif out['scriptPubKey']['addresses'][0] == p2pkh:\n+                p2pkh_pos = out['n']\n+\n+        # spend single key from node 1\n+        rawtx = self.nodes[1].walletcreatefundedpsbt([{\"txid\":txid,\"vout\":p2wpkh_pos},{\"txid\":txid,\"vout\":p2sh_p2wpkh_pos},{\"txid\":txid,\"vout\":p2pkh_pos}], {self.nodes[1].getnewaddress():29.99})['psbt']\n+        walletprocesspsbt_out = self.nodes[1].walletprocesspsbt(rawtx)\n+        assert_equal(walletprocesspsbt_out['complete'], True)\n+        self.nodes[1].sendrawtransaction(self.nodes[1].finalizepsbt(walletprocesspsbt_out['psbt'])['hex'])\n+\n+        # partially sign multisig things with node 1\n+        psbtx = self.nodes[1].walletcreatefundedpsbt([{\"txid\":txid,\"vout\":p2wsh_pos},{\"txid\":txid,\"vout\":p2sh_pos},{\"txid\":txid,\"vout\":p2sh_p2wsh_pos}], {self.nodes[1].getnewaddress():29.99})['psbt']\n+        walletprocesspsbt_out = self.nodes[1].walletprocesspsbt(psbtx)\n+        psbtx = walletprocesspsbt_out['psbt']\n+        assert_equal(walletprocesspsbt_out['complete'], False)\n+\n+        # partially sign with node 2. This should be complete and sendable\n+        walletprocesspsbt_out = self.nodes[2].walletprocesspsbt(psbtx)\n+        assert_equal(walletprocesspsbt_out['complete'], True)\n+        self.nodes[2].sendrawtransaction(self.nodes[2].finalizepsbt(walletprocesspsbt_out['psbt'])['hex'])\n+\n+        # check that walletprocesspsbt fails to decode a non-psbt\n+        rawtx = self.nodes[1].createrawtransaction([{\"txid\":txid,\"vout\":p2wpkh_pos}], {self.nodes[1].getnewaddress():9.99})\n+        assert_raises_rpc_error(-22, \"TX decode failed\", self.nodes[1].walletprocesspsbt, rawtx)\n+\n+        # Convert a non-psbt to psbt and make sure we can decode it\n+        rawtx = self.nodes[0].createrawtransaction([], {self.nodes[1].getnewaddress():10})\n+        rawtx = self.nodes[0].fundrawtransaction(rawtx)\n+        new_psbt = self.nodes[0].converttopsbt(rawtx['hex'])\n+        self.nodes[0].decodepsbt(new_psbt)\n+\n+        # Make sure that a psbt with signatures cannot be converted\n+        signedtx = self.nodes[0].signrawtransactionwithwallet(rawtx['hex'])\n+        assert_raises_rpc_error(-22, \"TX decode failed\", self.nodes[0].converttopsbt, signedtx['hex'])\n+\n+        # Explicilty allow converting non-empty txs\n+        new_psbt = self.nodes[0].converttopsbt(rawtx['hex'])\n+        self.nodes[0].decodepsbt(new_psbt)\n+\n+        # Create outputs to nodes 1 and 2\n+        node1_addr = self.nodes[1].getnewaddress()\n+        node2_addr = self.nodes[2].getnewaddress()\n+        txid1 = self.nodes[0].sendtoaddress(node1_addr, 13)\n+        txid2 =self.nodes[0].sendtoaddress(node2_addr, 13)\n+        self.nodes[0].generate(6)\n+        self.sync_all()\n+        vout1 = find_output(self.nodes[1], txid1, 13)\n+        vout2 = find_output(self.nodes[2], txid2, 13)\n+\n+        # Create a psbt spending outputs from nodes 1 and 2\n+        psbt_orig = self.nodes[0].createpsbt([{\"txid\":txid1,  \"vout\":vout1}, {\"txid\":txid2, \"vout\":vout2}], {self.nodes[0].getnewaddress():25.999})\n+\n+        # Update psbts, should only have data for one input and not the other\n+        psbt1 = self.nodes[1].walletprocesspsbt(psbt_orig)['psbt']\n+        psbt1_decoded = self.nodes[0].decodepsbt(psbt1)\n+        assert psbt1_decoded['inputs'][0] and not psbt1_decoded['inputs'][1]\n+        psbt2 = self.nodes[2].walletprocesspsbt(psbt_orig)['psbt']\n+        psbt2_decoded = self.nodes[0].decodepsbt(psbt2)\n+        assert not psbt2_decoded['inputs'][0] and psbt2_decoded['inputs'][1]\n+\n+        # Combine, finalize, and send the psbts\n+        combined = self.nodes[0].combinepsbt([psbt1, psbt2])\n+        finalized = self.nodes[0].finalizepsbt(combined)['hex']\n+        self.nodes[0].sendrawtransaction(finalized)\n+        self.nodes[0].generate(6)\n+        self.sync_all()\n+\n+        # BIP 174 Test Vectors\n+\n+        # Check that unknown values are just passed through\n+        unknown_psbt = \"cHNidP8BAD8CAAAAAf//////////////////////////////////////////AAAAAAD/////AQAAAAAAAAAAA2oBAAAAAAAACg8BAgMEBQYHCAkPAQIDBAUGBwgJCgsMDQ4PAAA=\"\n+        unknown_out = self.nodes[0].walletprocesspsbt(unknown_psbt)['psbt']\n+        assert_equal(unknown_psbt, unknown_out)\n+\n+        # Open the data file\n+        with open(os.path.join(os.path.dirname(os.path.realpath(__file__)), 'data/rpc_psbt.json'), encoding='utf-8') as f:\n+            d = json.load(f)\n+            invalids = d['invalid']\n+            valids = d['valid']\n+            creators = d['creator']\n+            signers = d['signer']\n+            combiners = d['combiner']\n+            finalizers = d['finalizer']\n+            extractors = d['extractor']\n+\n+        # Invalid PSBTs\n+        for invalid in invalids:\n+            assert_raises_rpc_error(-22, \"TX decode failed\", self.nodes[0].decodepsbt, invalid)\n+\n+        # Valid PSBTs\n+        for valid in valids:\n+            self.nodes[0].decodepsbt(valid)\n+\n+        # Creator Tests\n+        for creator in creators:\n+            created_tx = self.nodes[0].createpsbt(creator['inputs'], creator['outputs'])\n+            assert_equal(created_tx, creator['result'])\n+\n+        # Signer tests\n+        for i, signer in enumerate(signers):\n+            for key in signer['privkeys']:\n+                self.nodes[i].importprivkey(key)\n+            signed_tx = self.nodes[i].walletprocesspsbt(signer['psbt'])['psbt']\n+            assert_equal(signed_tx, signer['result'])\n+\n+        # Combiner test\n+        for combiner in combiners:\n+            combined = self.nodes[2].combinepsbt(combiner['combine'])\n+            assert_equal(combined, combiner['result'])\n+\n+        # Finalizer test\n+        for finalizer in finalizers:\n+            finalized = self.nodes[2].finalizepsbt(finalizer['finalize'], False)['psbt']\n+            assert_equal(finalized, finalizer['result'])\n+\n+        # Extractor test\n+        for extractor in extractors:\n+            extracted = self.nodes[2].finalizepsbt(extractor['extract'], True)['hex']\n+            assert_equal(extracted, extractor['result'])\n+\n+\n+if __name__ == '__main__':\n+    PSBTTest().main()"
      },
      {
        "sha": "80539eca72c7bb148e176ed4b1dd0727e88b775b",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/020628e3a4e88e36647eaf92bac4b3552796ac6a/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/020628e3a4e88e36647eaf92bac4b3552796ac6a/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=020628e3a4e88e36647eaf92bac4b3552796ac6a",
        "patch": "@@ -99,6 +99,7 @@\n     'wallet_multiwallet.py',\n     'wallet_multiwallet.py --usecli',\n     'interface_http.py',\n+    'rpc_psbt.py',\n     'rpc_users.py',\n     'feature_proxy.py',\n     'rpc_signrawtransaction.py',"
      }
    ]
  }
]