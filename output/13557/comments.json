[
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/400972753",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-400972753",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
    "id": 400972753,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDk3Mjc1Mw==",
    "user": {
      "login": "DrahtBot",
      "id": 39886733,
      "node_id": "MDQ6VXNlcjM5ODg2NzMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/39886733?u=3c1e73d828cf5a5850dfc25c8397c1cf751db5ac&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/DrahtBot",
      "html_url": "https://github.com/DrahtBot",
      "followers_url": "https://api.github.com/users/DrahtBot/followers",
      "following_url": "https://api.github.com/users/DrahtBot/following{/other_user}",
      "gists_url": "https://api.github.com/users/DrahtBot/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
      "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
      "repos_url": "https://api.github.com/users/DrahtBot/repos",
      "events_url": "https://api.github.com/users/DrahtBot/events{/privacy}",
      "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-28T09:28:00Z",
    "updated_at": "2018-07-16T11:32:29Z",
    "author_association": "CONTRIBUTOR",
    "body": "<!--e57a25ab6845829454e8d69fc972939a-->Note to reviewers: This pull request conflicts with the following ones:\n\n* #13359 (wallet: Directly operate with CMutableTransaction by MarcoFalke)\n* #13266 (refactoring: privatize SignatureExtractorChecker by Empact)\n* #13144 (RPC: Improve error messages on RPC endpoints that use GetTransaction by jimpo)\n* #13098 (Skip tx-rehashing on historic blocks by MarcoFalke)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/400972753/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/401119664",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-401119664",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
    "id": 401119664,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMTExOTY2NA==",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?u=9791e96cd4268d48e3517bac41eaf2b1d09759fd&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-28T17:52:59Z",
    "updated_at": "2018-06-28T17:52:59Z",
    "author_association": "MEMBER",
    "body": "@promag Just so you know, those commits are part of #13425 ",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/401119664/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/401122013",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-401122013",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
    "id": 401122013,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMTEyMjAxMw==",
    "user": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?u=4a9af998e1a560b3f49c3827f453e1bcbe6a5cfb&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-28T18:01:00Z",
    "updated_at": "2018-06-28T18:01:00Z",
    "author_association": "MEMBER",
    "body": "Ops @achow101 do you want me to comment there?",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/401122013/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/401123362",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-401123362",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
    "id": 401123362,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMTEyMzM2Mg==",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?u=9791e96cd4268d48e3517bac41eaf2b1d09759fd&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-28T18:05:52Z",
    "updated_at": "2018-06-28T18:05:52Z",
    "author_association": "MEMBER",
    "body": "No need to comment twice. I will update that PR and then rebase this onto that.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/401123362/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/401200508",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-401200508",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
    "id": 401200508,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMTIwMDUwOA==",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?u=7999a16349f0df0fb273fffa18e5a955c9d3f11c&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-28T23:13:58Z",
    "updated_at": "2018-06-28T23:13:58Z",
    "author_association": "MEMBER",
    "body": "General comment on naming of RPC field names and input arguments, `\"base64\"` isn't very informative I think. I suggest using `\"psbt\"` anywhere you have an input or output in base64. There isn't any other encoding used, so there should never be any confusion. Using `\"hex\"` for fully signed or legacy partially signed transaction makes sense for consistency with the existing RPCs.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/401200508/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/401228577",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-401228577",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
    "id": 401228577,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMTIyODU3Nw==",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?u=9791e96cd4268d48e3517bac41eaf2b1d09759fd&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-29T02:26:44Z",
    "updated_at": "2018-06-29T02:26:44Z",
    "author_association": "MEMBER",
    "body": "I did a bit of commit splitting and have reduced the size of the RPCs commit by splitting it up. Hopefully this will make review easier.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/401228577/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/401433514",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-401433514",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
    "id": 401433514,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMTQzMzUxNA==",
    "user": {
      "login": "nvk",
      "id": 797193,
      "node_id": "MDQ6VXNlcjc5NzE5Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/797193?u=42449e03fe190cc57d88b53ccdf36048a18095b4&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nvk",
      "html_url": "https://github.com/nvk",
      "followers_url": "https://api.github.com/users/nvk/followers",
      "following_url": "https://api.github.com/users/nvk/following{/other_user}",
      "gists_url": "https://api.github.com/users/nvk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nvk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nvk/subscriptions",
      "organizations_url": "https://api.github.com/users/nvk/orgs",
      "repos_url": "https://api.github.com/users/nvk/repos",
      "events_url": "https://api.github.com/users/nvk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nvk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-29T18:16:28Z",
    "updated_at": "2018-06-29T18:16:28Z",
    "author_association": "NONE",
    "body": "We will start implementing as soon as this gets merged.\r\nThanks for sorting it out so fast \ud83d\udc4d",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/401433514/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/402764376",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-402764376",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
    "id": 402764376,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMjc2NDM3Ng==",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-05T15:38:29Z",
    "updated_at": "2018-07-05T15:38:57Z",
    "author_association": "MEMBER",
    "body": "Needs rebase now that https://github.com/bitcoin/bitcoin/pull/13425 is merged. (I think?)",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/402764376/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/402805217",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-402805217",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
    "id": 402805217,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMjgwNTIxNw==",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?u=9791e96cd4268d48e3517bac41eaf2b1d09759fd&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-05T18:00:14Z",
    "updated_at": "2018-07-05T18:00:14Z",
    "author_association": "MEMBER",
    "body": "Rebased onto master after #13425 was merged. Will address comments soon.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/402805217/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/402873779",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-402873779",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
    "id": 402873779,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMjg3Mzc3OQ==",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?u=9791e96cd4268d48e3517bac41eaf2b1d09759fd&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-05T22:44:42Z",
    "updated_at": "2018-07-05T22:44:42Z",
    "author_association": "MEMBER",
    "body": "> Instead of `walletcreatefundedpsbt`, could make a `rawtransactiontopsbt` or alike?\r\n\r\nThere already is a `converttopsbt` method. I do not think that we should make using PSBT require using raw transactions first. It should be self contained as I hope that we will move from raw transactions to PSBT entirely.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/402873779/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/403178806",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-403178806",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
    "id": 403178806,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMzE3ODgwNg==",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?u=7999a16349f0df0fb273fffa18e5a955c9d3f11c&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-07T01:15:19Z",
    "updated_at": "2018-07-07T01:15:19Z",
    "author_association": "MEMBER",
    "body": "utACK 14339b0214f2976cae772ae836322d285138c353. Going to play around with it more before I give a tACK.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/403178806/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/403246618",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-403246618",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
    "id": 403246618,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMzI0NjYxOA==",
    "user": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?u=4a9af998e1a560b3f49c3827f453e1bcbe6a5cfb&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-07T22:23:26Z",
    "updated_at": "2018-07-07T22:23:26Z",
    "author_association": "MEMBER",
    "body": "utACK 14339b0. I have a couple of comments but are all nits here and there.\r\n\r\n> There already is a `converttopsbt` method. I do not think that we should make using PSBT require using raw transactions first. It should be self contained as I hope that we will move from raw transactions to PSBT entirely.\r\n\r\nOk got it.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/403246618/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/403481109",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-403481109",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
    "id": 403481109,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMzQ4MTEwOQ==",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-09T13:35:22Z",
    "updated_at": "2018-07-09T13:35:50Z",
    "author_association": "MEMBER",
    "body": "Left some comments, looking good overall.\r\n\r\nI'd also like the RPC help to be a bit more descriptive of what the calls are doing, in plain english, to avoid users having to be BIP174 experts. e.g., what does \"finalizer\" mean.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/403481109/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/403496398",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-403496398",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
    "id": 403496398,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMzQ5NjM5OA==",
    "user": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?u=13b19d1ff2f5f914e180c41418f451a4ba6f8bd1&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-09T14:21:54Z",
    "updated_at": "2018-07-09T14:21:54Z",
    "author_association": "MEMBER",
    "body": "might want to fix this warning:\r\n```\r\n/.../bitcoin/src/wallet/rpcwallet.h:14:1: warning: class 'PartiallySignedTransaction' was previously declared as a struct [-Wmismatched-tags]\r\nclass PartiallySignedTransaction;\r\n^\r\n/.../bitcoin/src/script/sign.h:486:8: note: previous use is here\r\nstruct PartiallySignedTransaction\r\n       ^\r\n/.../bitcoin/src/wallet/rpcwallet.h:14:1: note: did you mean struct here?\r\nclass PartiallySignedTransaction;\r\n^~~~~\r\nstruct\r\n1 warning generated.\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/403496398/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/403600427",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-403600427",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
    "id": 403600427,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMzYwMDQyNw==",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?u=7999a16349f0df0fb273fffa18e5a955c9d3f11c&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-09T19:55:28Z",
    "updated_at": "2018-07-09T19:55:28Z",
    "author_association": "MEMBER",
    "body": "We should probably have a document (in doc/ or so) that explain the most common workflows (hardware wallet, coinjoin, multisig) with the relevant RPCs.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/403600427/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/403605592",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-403605592",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
    "id": 403605592,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMzYwNTU5Mg==",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?u=9791e96cd4268d48e3517bac41eaf2b1d09759fd&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-09T20:14:24Z",
    "updated_at": "2018-07-09T20:14:24Z",
    "author_association": "MEMBER",
    "body": "> might want to fix this warning\r\n\r\nI don't see this warning locally, but fixed anyways.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/403605592/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/403839132",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-403839132",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
    "id": 403839132,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMzgzOTEzMg==",
    "user": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?u=13b19d1ff2f5f914e180c41418f451a4ba6f8bd1&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-10T14:18:17Z",
    "updated_at": "2018-07-10T14:18:17Z",
    "author_association": "MEMBER",
    "body": "> I don't see this warning locally, but fixed anyways.\r\n\r\nHeh, building with clang-latest-master is sometimes useful.\r\n\r\n> We should probably have a document (in doc/ or so) that  explain the most common workflows (hardware wallet, coinjoin, multisig)  with the relevant RPCs.\r\n\r\nGood idea, though probably not in this PR if we want it in before the feature freeze.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/403839132/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/403993033",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-403993033",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
    "id": 403993033,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMzk5MzAzMw==",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?u=9791e96cd4268d48e3517bac41eaf2b1d09759fd&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-10T23:03:23Z",
    "updated_at": "2018-07-10T23:03:23Z",
    "author_association": "MEMBER",
    "body": "> Adding test for those would be useful, and could catch if we forgot any useful params in the RPC.\r\n\r\nThere already are test cases for multisig. I have added one for coinjoin where inputs come from multiple nodes.\r\n\r\n> I'm missing a test case for `bip32_derivs`.\r\n\r\nThis is done in the updater tests which is a unit test (so we can add specific prevtxs).\r\n\r\n> Adding `bip32_derivs` should probably be opt-in.\r\n\r\nDone\r\n\r\n> At the risk over expanding the scope too much, it would be quite useful if inputs of createpsbt can add add a redeemScript argument, as a hint for multisig addresses the wallet might not be aware of. Although see below...\r\n\r\nWhile that could be useful, `createpsbt` does not do any updating, and I do not think it would be good to include any other data in an input before a UTXO is included for the input.\r\n\r\n> Somewhat orthogonal bug(?): walletcreatefundedpsbt is unable to construct a transaction if it can't find the relevant UTXO. E.g. if you call addmultisig for a 2 of 2 where you only control one key, and then fund it from an external wallet. Although getaddressinfo will be aware of the mutlisig, getreceivedbyaddress will claim it's not part of the wallet. You have to import the address and rescan for this to work. It seems to me that the wallet really should care about these transactions even if it doesn't list them.\r\n\r\nThis is more of a problem with the wallet structure in general. I do not think that PSBT should really be doing anything about this.\r\n\r\n> These rescans are rather painful, so - if it's not too late - adding a blockheight hint to BIP-174 might be really helpful. I can suggest that on the mailing list if others think it's useful.\r\n\r\nIn general, I don't think this is really useful. If you already know where to start rescanning for UTXOs, why can't you just find the UTXO and add it yourself? There isn't really any need to tell someone else to do it.\r\n\r\n> It would be nice if all RPC calls which can produce a complete transaction have a flag that lets you produce the hex immediately, rather than going through the finalizepsbt dance.\r\n\r\nThis was considered, but I think it is easier to follow and understand if the roles are more separated rather than integrated into one command. Instead of having many commands that can produce variable output, we will only have one command that does. The rest will have fixed, known outputs.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/403993033/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/404329633",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-404329633",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
    "id": 404329633,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwNDMyOTYzMw==",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?u=7999a16349f0df0fb273fffa18e5a955c9d3f11c&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-11T22:24:26Z",
    "updated_at": "2018-07-11T22:26:51Z",
    "author_association": "MEMBER",
    "body": "> Bit of a privacy issue: let's say person A and B are about to spend from a multisig address, sending everything to person A. Person A gives their address to person B, their wallet wallet creates a PSBT, but doesn't sign it. Wallet A then calls walletprocesspsbt which signs it and spontaneously adds the master_fingerprint and bip32 path. Same issue with walletcreatefundedpsbt.\r\n\r\nI think it's generally hard to maintain much privacy in PSBT. You should assume that those you share a PSBT with will learn more about you than the general public will, even if just by observing which parties add data at what time.\r\n\r\n> Somewhat orthogonal bug(?): walletcreatefundedpsbt is unable to construct a transaction if it can't find the relevant UTXO.\r\n\r\nThat's inevitable. If you don't know what is being spent, you don't know what data to add the the PSBT.\r\n\r\n>  walletprocesspsbt won't sign a transaction if it doesn't know about the multisig address (i.e. addmultisig was never called). This is the case even if the PSBT has sufficient information, since it could match the witness_script against its own pub keys. Might be a nice improvement for later.\r\n\r\nThat sounds like a bug to me. If the PSBT actually has all the information available (UTXO, redeemscript, witnessscript), walletprocesspsbt should sign with all the keys it has.\r\n\r\n> However in this case it could in principle blind sign it, or at least throw a more clear error message than \"complete\": false.\r\n\r\n> These rescans are rather painful, so - if it's not too late - adding a blockheight hint to BIP-174 might be really helpful. I can suggest that on the mailing list if others think it's useful.\r\n\r\nI think that generally no normal operation should involve rescans. PSBT are for formalizing interactions between pieces of wallet software, and wallet software should already have ways to know about its own UTXOs (which may in exceptional situations mean rescan, but generally shouldn't).\r\n\r\nThere can also be more low-level separate RPCs that permit simulating some of the functionality without having strict wallets participate. None of that needs to be part of the initial functionality in Bitcoin Core, and some of it can be separate tools even. For example:\r\n* `utxoupdatepsbt` (node RPC) which adds UTXO data using chainstate/mempool to a PSBT rather than from a wallet. \r\n* `descriptorupdatepsbt` (utility RPC) Which is provided an output descriptor (see https://gist.github.com/sipa/e3d23d498c430bb601c5bca83523fa82) and adds derivation paths and scripts.\r\n* `analyzepsbt` (utility RPC, but aware of signing logic) which could report more data on PSBT than just decoding it (it could include fee, estimated vsize after signing, estimated feerate, what stage each input is towards finalizing and/or what's missing to progress further).\r\n* `joinpsbts` (utility RPC) which would combine the inputs and outputs from multiple PSBTs for possible different transactions (effectively constructing a coinjoin), maintaining all utxo/script/derivation data for existing inputs.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/404329633/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/404332054",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-404332054",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
    "id": 404332054,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwNDMzMjA1NA==",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?u=9791e96cd4268d48e3517bac41eaf2b1d09759fd&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-11T22:36:50Z",
    "updated_at": "2018-07-11T22:36:50Z",
    "author_association": "MEMBER",
    "body": "> `walletprocesspsbt` won't sign a transaction if it doesn't know about the multisig address (i.e. addmultisig was never called). This is the case even if the PSBT has sufficient information, since it could match the witness_script against its own pub keys. Might be a nice improvement for later.\r\n\r\nThis shouldn't be the case as it is explicitly tested for in the test cases. A multisig address is used with keys from 3 nodes, but the multisig address is only added to one of them. One of the other nodes (without having called `addmultisigaddress`) is still able to sign the transaction and produce a complete, sendable transaction.\r\n\r\n> There can also be more low-level separate RPCs that permit simulating some of the functionality without having strict wallets participate\r\n\r\nCertainly, but I think such functionality should be done in a separate PR to avoid adding more things to review in this PR which is already somewhat large.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/404332054/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/404447084",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-404447084",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
    "id": 404447084,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwNDQ0NzA4NA==",
    "user": {
      "login": "Sjors",
      "id": 10217,
      "node_id": "MDQ6VXNlcjEwMjE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Sjors",
      "html_url": "https://github.com/Sjors",
      "followers_url": "https://api.github.com/users/Sjors/followers",
      "following_url": "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url": "https://api.github.com/users/Sjors/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
      "organizations_url": "https://api.github.com/users/Sjors/orgs",
      "repos_url": "https://api.github.com/users/Sjors/repos",
      "events_url": "https://api.github.com/users/Sjors/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Sjors/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-12T09:16:34Z",
    "updated_at": "2018-07-12T09:16:34Z",
    "author_association": "MEMBER",
    "body": "In this test case node1 created the multisig and is the first to sign it. In the scenario I tested, the multisig was created by an independent wallet, so the participating wallets only have the matching public and private keys, but don't know there's a multisig involved.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/404447084/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/404591447",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-404591447",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
    "id": 404591447,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwNDU5MTQ0Nw==",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?u=7999a16349f0df0fb273fffa18e5a955c9d3f11c&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-12T17:38:01Z",
    "updated_at": "2018-07-12T17:38:01Z",
    "author_association": "MEMBER",
    "body": "> In this test case node1 created the multisig and is the first to sign it. In the scenario I tested, the multisig was created by an independent wallet, so the participating wallets only have the matching public and private keys, but don't know there's a multisig involved.\r\n\r\nSo run walletprocesspsbt on the PSBT with the wallet that does have the information about the multisig construction? It should add it to the file, and permit the signers to use that information.\r\n\r\nIf I'm misunderstanding the scenario, can you give a script to reproduce the issue? If you're right, this may be an issue.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/404591447/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/404867941",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-404867941",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
    "id": 404867941,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwNDg2Nzk0MQ==",
    "user": {
      "login": "Sjors",
      "id": 10217,
      "node_id": "MDQ6VXNlcjEwMjE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Sjors",
      "html_url": "https://github.com/Sjors",
      "followers_url": "https://api.github.com/users/Sjors/followers",
      "following_url": "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url": "https://api.github.com/users/Sjors/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
      "organizations_url": "https://api.github.com/users/Sjors/orgs",
      "repos_url": "https://api.github.com/users/Sjors/repos",
      "events_url": "https://api.github.com/users/Sjors/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Sjors/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-13T15:30:05Z",
    "updated_at": "2018-07-13T15:30:05Z",
    "author_association": "MEMBER",
    "body": "@sipa I described the behavior in more detail in a functional test:\r\nhttps://github.com/achow101/bitcoin/compare/psbt...Sjors:2018/07/psbt-tests",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/404867941/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/404915029",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-404915029",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
    "id": 404915029,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwNDkxNTAyOQ==",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?u=9791e96cd4268d48e3517bac41eaf2b1d09759fd&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-13T18:25:43Z",
    "updated_at": "2018-07-13T18:25:43Z",
    "author_association": "MEMBER",
    "body": "@sjors this is expected behavior due to how the wallet works. It is orthogonal to this PR and is just a side effect of the current wallet structure.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/404915029/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/404918179",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-404918179",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
    "id": 404918179,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwNDkxODE3OQ==",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?u=7999a16349f0df0fb273fffa18e5a955c9d3f11c&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-13T18:38:15Z",
    "updated_at": "2018-07-13T18:41:18Z",
    "author_association": "MEMBER",
    "body": "@Sjors So what is happening is that none of the wallets involved in your tests treat the address as \"mine\", and:\r\n* As a result none know about the UTXO being spent,\r\n* As a result none can add UTXO information to the PSBT\r\n* As a result none can add script information (even those that know about the multisig, because they don't know that it is relevant for that input).\r\n* As a result none sign (because they don't know their key is relevant)\r\n\r\nThe solution is calling `importaddress` with P2WSH address on one of the nodes, then giving the PSBT to that node, then giving it to the node with the multisig information, and then giving it to all signers.\r\n\r\nIt is a highly confusing situation that adding a multisig address doesn't automatically watch it, but it is consistent with how everything works: things are only treated as mine if (A) you know the scripts involved and have ALL the private keys or (B) the address was imported as watch-only.\r\n\r\nLonger term this is something I want to address with my descriptors work.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/404918179/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/404924606",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-404924606",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
    "id": 404924606,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwNDkyNDYwNg==",
    "user": {
      "login": "Sjors",
      "id": 10217,
      "node_id": "MDQ6VXNlcjEwMjE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Sjors",
      "html_url": "https://github.com/Sjors",
      "followers_url": "https://api.github.com/users/Sjors/followers",
      "following_url": "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url": "https://api.github.com/users/Sjors/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
      "organizations_url": "https://api.github.com/users/Sjors/orgs",
      "repos_url": "https://api.github.com/users/Sjors/repos",
      "events_url": "https://api.github.com/users/Sjors/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Sjors/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-13T19:03:08Z",
    "updated_at": "2018-07-13T19:03:08Z",
    "author_association": "MEMBER",
    "body": "I see, at least we have it documented again :-)",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/404924606/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/404986537",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-404986537",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
    "id": 404986537,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwNDk4NjUzNw==",
    "user": {
      "login": "DrahtBot",
      "id": 39886733,
      "node_id": "MDQ6VXNlcjM5ODg2NzMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/39886733?u=3c1e73d828cf5a5850dfc25c8397c1cf751db5ac&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/DrahtBot",
      "html_url": "https://github.com/DrahtBot",
      "followers_url": "https://api.github.com/users/DrahtBot/followers",
      "following_url": "https://api.github.com/users/DrahtBot/following{/other_user}",
      "gists_url": "https://api.github.com/users/DrahtBot/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
      "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
      "repos_url": "https://api.github.com/users/DrahtBot/repos",
      "events_url": "https://api.github.com/users/DrahtBot/events{/privacy}",
      "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-14T00:50:16Z",
    "updated_at": "2018-07-14T00:50:16Z",
    "author_association": "CONTRIBUTOR",
    "body": "<!--e57a25ab6845829454e8d69fc972939a-->Note to reviewers: This pull request conflicts with the following ones:\n\n* #13359 (wallet: Directly operate with CMutableTransaction by MarcoFalke)\n* #13266 (refactoring: Convert DataFromTransaction to a SignatureData constructor, and privatize helpers by Empact)\n* #13144 (RPC: Improve error messages on RPC endpoints that use GetTransaction by jimpo)\n* #13098 (Skip tx-rehashing on historic blocks by MarcoFalke)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/404986537/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/405428971",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-405428971",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
    "id": 405428971,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwNTQyODk3MQ==",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?u=7999a16349f0df0fb273fffa18e5a955c9d3f11c&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-17T01:20:56Z",
    "updated_at": "2018-07-17T01:20:56Z",
    "author_association": "MEMBER",
    "body": "utACK 020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/405428971/reactions",
      "total_count": 4,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 4,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/406028854",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-406028854",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
    "id": 406028854,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwNjAyODg1NA==",
    "user": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?u=13b19d1ff2f5f914e180c41418f451a4ba6f8bd1&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-18T18:25:41Z",
    "updated_at": "2018-07-18T18:25:41Z",
    "author_association": "MEMBER",
    "body": "utACK 020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/406028854/reactions",
      "total_count": 3,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 3,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198708045",
    "pull_request_review_id": 132687160,
    "id": 198708045,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODcwODA0NQ==",
    "diff_hunk": "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> sig;\n+                    sig.resize(value_len);\n+                    s >> MakeSpan(sig);\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PartiallySignedInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput",
    "path": "src/script/sign.h",
    "position": 339,
    "original_position": 298,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Inconsistent class name (PartiallySignedInput vs PSBTOutput).",
    "created_at": "2018-06-28T05:01:33Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198708045",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198708045"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198708045"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198708045/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 385,
    "original_line": 385,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198708146",
    "pull_request_review_id": 132687160,
    "id": 198708146,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODcwODE0Ng==",
    "diff_hunk": "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 44,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Perhaps add a comment to explain this function and the one below.",
    "created_at": "2018-06-28T05:02:39Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198708146",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198708146"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198708146"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198708146/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 122,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198764592",
    "pull_request_review_id": 132751570,
    "id": 198764592,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODc2NDU5Mg==",
    "diff_hunk": "@@ -169,15 +171,106 @@ bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreato\n     sigdata.scriptSig = PushAll(result);\n \n     // Test solution\n-    return solved && VerifyScript(sigdata.scriptSig, fromPubKey, &sigdata.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, creator.Checker());\n+    sigdata.complete = solved && VerifyScript(sigdata.scriptSig, fromPubKey, &sigdata.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, creator.Checker());\n+    return sigdata.complete;\n }\n \n-SignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nIn)\n+bool SignatureExtractorChecker::CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n+{\n+    if (checker->CheckSig(scriptSig, vchPubKey, scriptCode, sigversion)) {\n+        CPubKey pubkey(vchPubKey);\n+        sigdata->signatures.emplace(pubkey.GetID(), SigPair(pubkey, scriptSig));\n+        return true;\n+    }\n+    return false;\n+}\n+\n+namespace\n+{\n+struct Stacks\n+{\n+    std::vector<valtype> script;\n+    std::vector<valtype> witness;\n+\n+    Stacks() {}\n+    explicit Stacks(const std::vector<valtype>& scriptSigStack_) : script(scriptSigStack_), witness() {}\n+    explicit Stacks(const SignatureData& data) : witness(data.scriptWitness.stack) {\n+        EvalScript(script, data.scriptSig, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker(), SigVersion::BASE);\n+    }\n+\n+    SignatureData Output() const {\n+        SignatureData result;\n+        result.scriptSig = PushAll(script);\n+        result.scriptWitness.stack = witness;\n+        return result;\n+    }\n+};\n+}\n+\n+// Extracts signatures and scripts from incomplete scriptSigs. Please do not extend this, use PSBT instead\n+SignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nIn, const CTxOut& txout)\n {\n     SignatureData data;\n     assert(tx.vin.size() > nIn);\n     data.scriptSig = tx.vin[nIn].scriptSig;\n     data.scriptWitness = tx.vin[nIn].scriptWitness;\n+    Stacks stack(data);\n+\n+    // Get signatures\n+    MutableTransactionSignatureChecker tx_checker(&tx, nIn, txout.nValue);\n+    SignatureExtractorChecker extractor_checker(&data, &tx_checker);\n+    if (VerifyScript(data.scriptSig, txout.scriptPubKey, &data.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, extractor_checker)) {\n+        data.complete = true;\n+        return data;\n+    }\n+\n+    // Get scripts\n+    txnouttype script_type;\n+    std::vector<std::vector<unsigned char>> solutions;\n+    Solver(txout.scriptPubKey, script_type, solutions);\n+    SigVersion sigversion = SigVersion::BASE;\n+    CScript next_script = txout.scriptPubKey;\n+\n+    if (script_type == TX_SCRIPTHASH && !stack.script.empty() && !stack.script.back().empty()) {\n+        // Get the redeemScript\n+        CScript redeem_script(stack.script.back().begin(), stack.script.back().end());\n+        data.redeem_script = redeem_script;\n+        next_script = std::move(redeem_script);\n+\n+        // Get redeemScript type\n+        Solver(next_script, script_type, solutions);\n+        stack.script.pop_back();\n+    }\n+    if (script_type == TX_WITNESS_V0_SCRIPTHASH && !stack.witness.empty() && !stack.witness.back().empty()) {\n+        // Get the witnessScript\n+        CScript witness_script(stack.witness.back().begin(), stack.witness.back().end());\n+        data.witness_script = witness_script;\n+        next_script = std::move(witness_script);\n+\n+        // Get witnessScript type\n+        Solver(next_script, script_type, solutions);\n+        stack.witness.pop_back();\n+        stack.script = std::move(stack.witness);\n+        stack.witness.clear();\n+        sigversion = SigVersion::WITNESS_V0;\n+    }\n+    if (script_type == TX_MULTISIG && !stack.script.empty()) {\n+        // Build a map of pubkey -> signature by matching sigs to pubkeys:\n+        assert(solutions.size() > 1);\n+        unsigned int num_pubkeys = solutions.size()-2;\n+        unsigned int last_success_key = 0;\n+        for (const valtype& sig : stack.script) {\n+            for (unsigned int i = last_success_key; i < num_pubkeys; i++) {",
    "path": "src/script/sign.cpp",
    "position": null,
    "original_position": 104,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "a86d0679db0eb0a12e4ced4ee09c18b0bd81dd84",
    "user": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Commit \"Make SignatureData able to store signatures and scripts\"\r\n\r\nnit, `++i`",
    "created_at": "2018-06-28T09:04:02Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198764592",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198764592"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198764592"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198764592/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 263,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198766870",
    "pull_request_review_id": 132751570,
    "id": 198766870,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODc2Njg3MA==",
    "diff_hunk": "@@ -81,4 +91,15 @@ void UpdateInput(CTxIn& input, const SignatureData& data);\n  * Solvability is unrelated to whether we consider this output to be ours. */\n bool IsSolvable(const SigningProvider& provider, const CScript& script);\n \n+class SignatureExtractorChecker : public BaseSignatureChecker",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 40,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "a86d0679db0eb0a12e4ced4ee09c18b0bd81dd84",
    "user": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Commit  \"Make SignatureData able to store signatures and scripts\"\r\n\r\n`class SignatureExtractorChecker final`?",
    "created_at": "2018-06-28T09:09:27Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198766870",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198766870"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198766870"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198766870/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 94,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198769412",
    "pull_request_review_id": 132751570,
    "id": 198769412,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODc2OTQxMg==",
    "diff_hunk": "@@ -169,15 +171,106 @@ bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreato\n     sigdata.scriptSig = PushAll(result);\n \n     // Test solution\n-    return solved && VerifyScript(sigdata.scriptSig, fromPubKey, &sigdata.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, creator.Checker());\n+    sigdata.complete = solved && VerifyScript(sigdata.scriptSig, fromPubKey, &sigdata.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, creator.Checker());\n+    return sigdata.complete;\n }\n \n-SignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nIn)\n+bool SignatureExtractorChecker::CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n+{\n+    if (checker->CheckSig(scriptSig, vchPubKey, scriptCode, sigversion)) {\n+        CPubKey pubkey(vchPubKey);\n+        sigdata->signatures.emplace(pubkey.GetID(), SigPair(pubkey, scriptSig));",
    "path": "src/script/sign.cpp",
    "position": null,
    "original_position": 23,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "a86d0679db0eb0a12e4ced4ee09c18b0bd81dd84",
    "user": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Commit \"Make SignatureData able to store signatures and scripts\"\r\n\r\nThis is called when `pubkey.GetID()` doesn't exists in signatures, maybe assert it is new:\r\n```cpp\r\nauto i = sigdata->signatures.emplace(...);\r\nassert(i.second);\r\n```",
    "created_at": "2018-06-28T09:15:36Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198769412",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198769412"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198769412"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198769412/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 182,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198769810",
    "pull_request_review_id": 132751570,
    "id": 198769810,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODc2OTgxMA==",
    "diff_hunk": "@@ -81,4 +91,15 @@ void UpdateInput(CTxIn& input, const SignatureData& data);\n  * Solvability is unrelated to whether we consider this output to be ours. */\n bool IsSolvable(const SigningProvider& provider, const CScript& script);\n \n+class SignatureExtractorChecker : public BaseSignatureChecker\n+{\n+private:\n+    SignatureData* sigdata;",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 43,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "a86d0679db0eb0a12e4ced4ee09c18b0bd81dd84",
    "user": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Commit \"Make SignatureData able to store signatures and scripts\"\r\n\r\nUse references instead of pointers?",
    "created_at": "2018-06-28T09:16:40Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198769810",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198769810"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198769810"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198769810/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 97,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198771222",
    "pull_request_review_id": 132751570,
    "id": 198771222,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODc3MTIyMg==",
    "diff_hunk": "@@ -33,14 +33,60 @@ bool MutableTransactionSignatureCreator::CreateSig(const SigningProvider& provid\n     return true;\n }\n \n+static bool GetCScript(const SigningProvider* provider, const SignatureData* sigdata, const CScriptID &scriptid, CScript& script)",
    "path": "src/script/sign.cpp",
    "position": null,
    "original_position": 4,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "c5d47a58fdeea1a3ed206e5cdb2c37d70942c819",
    "user": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Commit \"Replace CombineSignatures with ProduceSignature\"\r\n\r\nLooks like these could be references:\r\n```cpp\r\nstatic bool GetCScript(const SigningProvider& provider, const SignatureData& sigdata, const CScriptID &scriptid, CScript& script)\r\n```\r\nand remove `provider != nullptr` below.",
    "created_at": "2018-06-28T09:20:06Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198771222",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198771222"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198771222"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198771222/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 36,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198773739",
    "pull_request_review_id": 132751570,
    "id": 198773739,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODc3MzczOQ==",
    "diff_hunk": "@@ -33,14 +33,60 @@ bool MutableTransactionSignatureCreator::CreateSig(const SigningProvider& provid\n     return true;\n }\n \n+static bool GetCScript(const SigningProvider* provider, const SignatureData* sigdata, const CScriptID &scriptid, CScript& script)",
    "path": "src/script/sign.cpp",
    "position": null,
    "original_position": 4,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "c5d47a58fdeea1a3ed206e5cdb2c37d70942c819",
    "user": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Otherwise fix space before `scriptid` argument. Same below in the definition.",
    "created_at": "2018-06-28T09:25:59Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198773739",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198773739"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198773739"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198773739/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 36,
    "side": "RIGHT",
    "in_reply_to_id": 198771222
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198774215",
    "pull_request_review_id": 132751570,
    "id": 198774215,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODc3NDIxNQ==",
    "diff_hunk": "@@ -33,14 +33,60 @@ bool MutableTransactionSignatureCreator::CreateSig(const SigningProvider& provid\n     return true;\n }\n \n+static bool GetCScript(const SigningProvider* provider, const SignatureData* sigdata, const CScriptID &scriptid, CScript& script)\n+{\n+    if (provider != nullptr && provider->GetCScript(scriptid, script)) {\n+        return true;\n+    }\n+    // Look for scripts in SignatureData\n+    if (CScriptID(sigdata->redeem_script) == scriptid) {\n+        script = sigdata->redeem_script;\n+        return true;\n+    } else if (CScriptID(sigdata->witness_script) == scriptid) {\n+        script = sigdata->witness_script;\n+        return true;\n+    }\n+    return false;\n+}\n+\n+static bool GetPubKey(const SigningProvider* provider, const SignatureData* sigdata, const CKeyID &address, CPubKey& pubkey)\n+{\n+    if (provider != nullptr && provider->GetPubKey(address, pubkey)) {\n+        return true;\n+    }\n+    // Look for pubkey in all partial sigs\n+    const auto& it = sigdata->signatures.find(address);",
    "path": "src/script/sign.cpp",
    "position": null,
    "original_position": 26,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "c5d47a58fdeea1a3ed206e5cdb2c37d70942c819",
    "user": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Commit \"Replace CombineSignatures with ProduceSignature\"\r\n\r\nAs pointed by @MarcoFalke, don't use references to iterators. Check throughout too.",
    "created_at": "2018-06-28T09:27:04Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198774215",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198774215"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198774215"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198774215/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 58,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198933070",
    "pull_request_review_id": 132687160,
    "id": 198933070,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODkzMzA3MA==",
    "diff_hunk": "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 200,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I think this can be written as just `std::vector<unsigned char> sig; s >> sig`.",
    "created_at": "2018-06-28T18:01:31Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198933070",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198933070"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198933070"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198933070/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 268,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198934388",
    "pull_request_review_id": 132687160,
    "id": 198934388,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODkzNDM4OA==",
    "diff_hunk": "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:",
    "path": "src/script/sign.h",
    "position": 240,
    "original_position": 172,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "For this one and the next, check whether you don't already have the other UTXO type?",
    "created_at": "2018-06-28T18:06:09Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198934388",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198934388"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198934388"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198934388/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 286,
    "original_line": 286,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198937087",
    "pull_request_review_id": 132687160,
    "id": 198937087,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODkzNzA4Nw==",
    "diff_hunk": "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> sig;\n+                    sig.resize(value_len);\n+                    s >> MakeSpan(sig);\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 281,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Here you can again just use `std::vector<unsigned char> val_bytes; s >> val_bytes;`.",
    "created_at": "2018-06-28T18:15:21Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198937087",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198937087"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198937087"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198937087/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 349,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198937464",
    "pull_request_review_id": 132687160,
    "id": 198937464,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODkzNzQ2NA==",
    "diff_hunk": "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> sig;\n+                    sig.resize(value_len);\n+                    s >> MakeSpan(sig);\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PartiallySignedInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput\n+{\n+    CScript redeem_script;\n+    CScript witness_script;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    PSBTOutput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the redeem script\n+        if (!redeem_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_REDEEMSCRIPT);\n+            s << redeem_script;\n+        }\n+\n+        // Write the witness script\n+        if (!witness_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_WITNESSSCRIPT);\n+            s << witness_script;\n+        }\n+\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            SerializeToVector(s, PSBT_OUT_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_OUT_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_OUT_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_OUT_BIP32_DERIVATION:",
    "path": "src/script/sign.h",
    "position": 413,
    "original_position": 380,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Can you abstract out the serialization/deserialization code for derivation paths and scripts into separate functions? Otherwise it is needlessly duplicated across input and outputs.",
    "created_at": "2018-06-28T18:16:37Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198937464",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198937464"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198937464"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198937464/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 459,
    "original_line": 459,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198946369",
    "pull_request_review_id": 132687160,
    "id": 198946369,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk0NjM2OQ==",
    "diff_hunk": "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> sig;\n+                    sig.resize(value_len);\n+                    s >> MakeSpan(sig);\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PartiallySignedInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput\n+{\n+    CScript redeem_script;\n+    CScript witness_script;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    PSBTOutput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the redeem script\n+        if (!redeem_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_REDEEMSCRIPT);\n+            s << redeem_script;\n+        }\n+\n+        // Write the witness script\n+        if (!witness_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_WITNESSSCRIPT);\n+            s << witness_script;\n+        }\n+\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            SerializeToVector(s, PSBT_OUT_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_OUT_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_OUT_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_OUT_BIP32_DERIVATION:\n+                {\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default: {\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PSBTOutput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::vector<PSBTOutput> outputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    uint64_t num_ins = 0;",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 438,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Do you still need `num_ins` and `use_in_index`?",
    "created_at": "2018-06-28T18:44:44Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198946369",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198946369"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198946369"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198946369/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 508,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198947030",
    "pull_request_review_id": 132687160,
    "id": 198947030,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk0NzAzMA==",
    "diff_hunk": "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> sig;\n+                    sig.resize(value_len);\n+                    s >> MakeSpan(sig);\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PartiallySignedInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput\n+{\n+    CScript redeem_script;\n+    CScript witness_script;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    PSBTOutput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the redeem script\n+        if (!redeem_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_REDEEMSCRIPT);\n+            s << redeem_script;\n+        }\n+\n+        // Write the witness script\n+        if (!witness_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_WITNESSSCRIPT);\n+            s << witness_script;\n+        }\n+\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            SerializeToVector(s, PSBT_OUT_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_OUT_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_OUT_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_OUT_BIP32_DERIVATION:\n+                {\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default: {\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PSBTOutput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::vector<PSBTOutput> outputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    bool IsNull() const;\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in) : tx(psbt_in.tx), inputs(psbt_in.inputs), outputs(psbt_in.outputs), unknown(psbt_in.unknown) {}\n+\n+    // Only checks if they refer to the same transaction\n+    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return a.tx.GetHash() == b.tx.GetHash();\n+    }\n+    friend bool operator!=(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return !(a == b);\n+    }\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // unsigned tx flag\n+        SerializeToVector(s, PSBT_GLOBAL_UNSIGNED_TX);\n+\n+        // Write serialized tx to a stream\n+        SerializeToVector(s, tx);\n+\n+        // Write the unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        // Write inputs\n+        for (const PartiallySignedInput& input : inputs) {\n+            s << input;\n+        }\n+        // Write outputs\n+        for (const PSBTOutput& output : outputs) {\n+            s << output;\n+        }\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read the magic bytes\n+        int magic;\n+        s >> magic;\n+        if (magic != PSBT_MAGIC_BYTES) {\n+            throw std::ios_base::failure(\"Invalid PSBT magic bytes\");\n+        }\n+        unsigned char magic_sep;\n+        s >> magic_sep;\n+\n+        // Read global data\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                break;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_GLOBAL_UNSIGNED_TX:\n+                    if (!CTransaction(tx).IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, unsigned tx already provided\");\n+                    }\n+                    UnserializeFromVector(s, tx);\n+                    // Make sure that all scriptSigs and scriptWitnesses are empty\n+                    for (const CTxIn& txin : tx.vin) {\n+                        if (!txin.scriptSig.empty() || !txin.scriptWitness.IsNull()) {\n+                            throw std::ios_base::failure(\"Unsigned tx does not have empty scriptSigs and scriptWitnesses.\");\n+                        }\n+                    }\n+                    break;\n+                // Unknown stuff\n+                default: {\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                }\n+            }\n+        }\n+\n+        // Make sure that we got an unsigned tx\n+        if (CTransaction(tx).IsNull()) {\n+            throw std::ios_base::failure(\"No unsigned transcation was provided\");\n+        }\n+\n+        // Read input data\n+        unsigned int i = 0;\n+        while (!s.empty() && i < tx.vin.size()) {",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 553,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Why the `!s.empty()` check here? If we reach EOF in the stream an error should be raised, not ignore it.",
    "created_at": "2018-06-28T18:46:56Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198947030",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198947030"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198947030"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198947030/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 587,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954379",
    "pull_request_review_id": 132981605,
    "id": 198954379,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk1NDM3OQ==",
    "diff_hunk": "@@ -169,15 +171,106 @@ bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreato\n     sigdata.scriptSig = PushAll(result);\n \n     // Test solution\n-    return solved && VerifyScript(sigdata.scriptSig, fromPubKey, &sigdata.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, creator.Checker());\n+    sigdata.complete = solved && VerifyScript(sigdata.scriptSig, fromPubKey, &sigdata.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, creator.Checker());\n+    return sigdata.complete;\n }\n \n-SignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nIn)\n+bool SignatureExtractorChecker::CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n+{\n+    if (checker->CheckSig(scriptSig, vchPubKey, scriptCode, sigversion)) {\n+        CPubKey pubkey(vchPubKey);\n+        sigdata->signatures.emplace(pubkey.GetID(), SigPair(pubkey, scriptSig));\n+        return true;\n+    }\n+    return false;\n+}\n+\n+namespace\n+{\n+struct Stacks\n+{\n+    std::vector<valtype> script;\n+    std::vector<valtype> witness;\n+\n+    Stacks() {}\n+    explicit Stacks(const std::vector<valtype>& scriptSigStack_) : script(scriptSigStack_), witness() {}\n+    explicit Stacks(const SignatureData& data) : witness(data.scriptWitness.stack) {\n+        EvalScript(script, data.scriptSig, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker(), SigVersion::BASE);\n+    }\n+\n+    SignatureData Output() const {\n+        SignatureData result;\n+        result.scriptSig = PushAll(script);\n+        result.scriptWitness.stack = witness;\n+        return result;\n+    }\n+};\n+}\n+\n+// Extracts signatures and scripts from incomplete scriptSigs. Please do not extend this, use PSBT instead\n+SignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nIn, const CTxOut& txout)\n {\n     SignatureData data;\n     assert(tx.vin.size() > nIn);\n     data.scriptSig = tx.vin[nIn].scriptSig;\n     data.scriptWitness = tx.vin[nIn].scriptWitness;\n+    Stacks stack(data);\n+\n+    // Get signatures\n+    MutableTransactionSignatureChecker tx_checker(&tx, nIn, txout.nValue);\n+    SignatureExtractorChecker extractor_checker(&data, &tx_checker);\n+    if (VerifyScript(data.scriptSig, txout.scriptPubKey, &data.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, extractor_checker)) {\n+        data.complete = true;\n+        return data;\n+    }\n+\n+    // Get scripts\n+    txnouttype script_type;\n+    std::vector<std::vector<unsigned char>> solutions;\n+    Solver(txout.scriptPubKey, script_type, solutions);\n+    SigVersion sigversion = SigVersion::BASE;\n+    CScript next_script = txout.scriptPubKey;\n+\n+    if (script_type == TX_SCRIPTHASH && !stack.script.empty() && !stack.script.back().empty()) {\n+        // Get the redeemScript\n+        CScript redeem_script(stack.script.back().begin(), stack.script.back().end());\n+        data.redeem_script = redeem_script;\n+        next_script = std::move(redeem_script);\n+\n+        // Get redeemScript type\n+        Solver(next_script, script_type, solutions);\n+        stack.script.pop_back();\n+    }\n+    if (script_type == TX_WITNESS_V0_SCRIPTHASH && !stack.witness.empty() && !stack.witness.back().empty()) {\n+        // Get the witnessScript\n+        CScript witness_script(stack.witness.back().begin(), stack.witness.back().end());\n+        data.witness_script = witness_script;\n+        next_script = std::move(witness_script);\n+\n+        // Get witnessScript type\n+        Solver(next_script, script_type, solutions);\n+        stack.witness.pop_back();\n+        stack.script = std::move(stack.witness);\n+        stack.witness.clear();\n+        sigversion = SigVersion::WITNESS_V0;\n+    }\n+    if (script_type == TX_MULTISIG && !stack.script.empty()) {\n+        // Build a map of pubkey -> signature by matching sigs to pubkeys:\n+        assert(solutions.size() > 1);\n+        unsigned int num_pubkeys = solutions.size()-2;\n+        unsigned int last_success_key = 0;\n+        for (const valtype& sig : stack.script) {\n+            for (unsigned int i = last_success_key; i < num_pubkeys; i++) {",
    "path": "src/script/sign.cpp",
    "position": null,
    "original_position": 104,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "a86d0679db0eb0a12e4ced4ee09c18b0bd81dd84",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-06-28T19:11:57Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198954379",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954379"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198954379"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954379/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 263,
    "side": "RIGHT",
    "in_reply_to_id": 198764592
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954398",
    "pull_request_review_id": 132981628,
    "id": 198954398,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk1NDM5OA==",
    "diff_hunk": "@@ -81,4 +91,15 @@ void UpdateInput(CTxIn& input, const SignatureData& data);\n  * Solvability is unrelated to whether we consider this output to be ours. */\n bool IsSolvable(const SigningProvider& provider, const CScript& script);\n \n+class SignatureExtractorChecker : public BaseSignatureChecker",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 40,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "a86d0679db0eb0a12e4ced4ee09c18b0bd81dd84",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-06-28T19:12:02Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198954398",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954398"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198954398"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954398/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 94,
    "side": "RIGHT",
    "in_reply_to_id": 198766870
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954415",
    "pull_request_review_id": 132981653,
    "id": 198954415,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk1NDQxNQ==",
    "diff_hunk": "@@ -169,15 +171,106 @@ bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreato\n     sigdata.scriptSig = PushAll(result);\n \n     // Test solution\n-    return solved && VerifyScript(sigdata.scriptSig, fromPubKey, &sigdata.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, creator.Checker());\n+    sigdata.complete = solved && VerifyScript(sigdata.scriptSig, fromPubKey, &sigdata.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, creator.Checker());\n+    return sigdata.complete;\n }\n \n-SignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nIn)\n+bool SignatureExtractorChecker::CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n+{\n+    if (checker->CheckSig(scriptSig, vchPubKey, scriptCode, sigversion)) {\n+        CPubKey pubkey(vchPubKey);\n+        sigdata->signatures.emplace(pubkey.GetID(), SigPair(pubkey, scriptSig));",
    "path": "src/script/sign.cpp",
    "position": null,
    "original_position": 23,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "a86d0679db0eb0a12e4ced4ee09c18b0bd81dd84",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-06-28T19:12:07Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198954415",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954415"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198954415"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954415/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 182,
    "side": "RIGHT",
    "in_reply_to_id": 198769412
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954423",
    "pull_request_review_id": 132981667,
    "id": 198954423,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk1NDQyMw==",
    "diff_hunk": "@@ -81,4 +91,15 @@ void UpdateInput(CTxIn& input, const SignatureData& data);\n  * Solvability is unrelated to whether we consider this output to be ours. */\n bool IsSolvable(const SigningProvider& provider, const CScript& script);\n \n+class SignatureExtractorChecker : public BaseSignatureChecker\n+{\n+private:\n+    SignatureData* sigdata;",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 43,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "a86d0679db0eb0a12e4ced4ee09c18b0bd81dd84",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-06-28T19:12:11Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198954423",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954423"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198954423"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954423/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 97,
    "side": "RIGHT",
    "in_reply_to_id": 198769810
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954439",
    "pull_request_review_id": 132981693,
    "id": 198954439,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk1NDQzOQ==",
    "diff_hunk": "@@ -33,14 +33,60 @@ bool MutableTransactionSignatureCreator::CreateSig(const SigningProvider& provid\n     return true;\n }\n \n+static bool GetCScript(const SigningProvider* provider, const SignatureData* sigdata, const CScriptID &scriptid, CScript& script)",
    "path": "src/script/sign.cpp",
    "position": null,
    "original_position": 4,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "c5d47a58fdeea1a3ed206e5cdb2c37d70942c819",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-06-28T19:12:16Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198954439",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954439"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198954439"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954439/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 36,
    "side": "RIGHT",
    "in_reply_to_id": 198771222
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954471",
    "pull_request_review_id": 132981734,
    "id": 198954471,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk1NDQ3MQ==",
    "diff_hunk": "@@ -33,14 +33,60 @@ bool MutableTransactionSignatureCreator::CreateSig(const SigningProvider& provid\n     return true;\n }\n \n+static bool GetCScript(const SigningProvider* provider, const SignatureData* sigdata, const CScriptID &scriptid, CScript& script)\n+{\n+    if (provider != nullptr && provider->GetCScript(scriptid, script)) {\n+        return true;\n+    }\n+    // Look for scripts in SignatureData\n+    if (CScriptID(sigdata->redeem_script) == scriptid) {\n+        script = sigdata->redeem_script;\n+        return true;\n+    } else if (CScriptID(sigdata->witness_script) == scriptid) {\n+        script = sigdata->witness_script;\n+        return true;\n+    }\n+    return false;\n+}\n+\n+static bool GetPubKey(const SigningProvider* provider, const SignatureData* sigdata, const CKeyID &address, CPubKey& pubkey)\n+{\n+    if (provider != nullptr && provider->GetPubKey(address, pubkey)) {\n+        return true;\n+    }\n+    // Look for pubkey in all partial sigs\n+    const auto& it = sigdata->signatures.find(address);",
    "path": "src/script/sign.cpp",
    "position": null,
    "original_position": 26,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "c5d47a58fdeea1a3ed206e5cdb2c37d70942c819",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done.",
    "created_at": "2018-06-28T19:12:24Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198954471",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954471"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198954471"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954471/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 58,
    "side": "RIGHT",
    "in_reply_to_id": 198774215
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198964995",
    "pull_request_review_id": 132994672,
    "id": 198964995,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk2NDk5NQ==",
    "diff_hunk": "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> sig;\n+                    sig.resize(value_len);\n+                    s >> MakeSpan(sig);\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PartiallySignedInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput\n+{\n+    CScript redeem_script;\n+    CScript witness_script;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    PSBTOutput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the redeem script\n+        if (!redeem_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_REDEEMSCRIPT);\n+            s << redeem_script;\n+        }\n+\n+        // Write the witness script\n+        if (!witness_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_WITNESSSCRIPT);\n+            s << witness_script;\n+        }\n+\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            SerializeToVector(s, PSBT_OUT_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_OUT_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_OUT_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_OUT_BIP32_DERIVATION:\n+                {\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default: {\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PSBTOutput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::vector<PSBTOutput> outputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    bool IsNull() const;\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in) : tx(psbt_in.tx), inputs(psbt_in.inputs), outputs(psbt_in.outputs), unknown(psbt_in.unknown) {}\n+\n+    // Only checks if they refer to the same transaction\n+    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return a.tx.GetHash() == b.tx.GetHash();\n+    }\n+    friend bool operator!=(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return !(a == b);\n+    }\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // unsigned tx flag\n+        SerializeToVector(s, PSBT_GLOBAL_UNSIGNED_TX);\n+\n+        // Write serialized tx to a stream\n+        SerializeToVector(s, tx);\n+\n+        // Write the unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        // Write inputs\n+        for (const PartiallySignedInput& input : inputs) {\n+            s << input;\n+        }\n+        // Write outputs\n+        for (const PSBTOutput& output : outputs) {\n+            s << output;\n+        }\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read the magic bytes\n+        int magic;\n+        s >> magic;\n+        if (magic != PSBT_MAGIC_BYTES) {\n+            throw std::ios_base::failure(\"Invalid PSBT magic bytes\");\n+        }\n+        unsigned char magic_sep;\n+        s >> magic_sep;\n+\n+        // Read global data\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                break;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_GLOBAL_UNSIGNED_TX:\n+                    if (!CTransaction(tx).IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, unsigned tx already provided\");\n+                    }\n+                    UnserializeFromVector(s, tx);\n+                    // Make sure that all scriptSigs and scriptWitnesses are empty\n+                    for (const CTxIn& txin : tx.vin) {\n+                        if (!txin.scriptSig.empty() || !txin.scriptWitness.IsNull()) {\n+                            throw std::ios_base::failure(\"Unsigned tx does not have empty scriptSigs and scriptWitnesses.\");\n+                        }\n+                    }\n+                    break;\n+                // Unknown stuff\n+                default: {\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                }\n+            }\n+        }\n+\n+        // Make sure that we got an unsigned tx\n+        if (CTransaction(tx).IsNull()) {\n+            throw std::ios_base::failure(\"No unsigned transcation was provided\");\n+        }\n+\n+        // Read input data\n+        unsigned int i = 0;\n+        while (!s.empty() && i < tx.vin.size()) {",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 553,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "If we reach EOF in the stream, this loop will exit and the if block below will throw the error as the number of inputs/outputs will differ from the number of inputs/outputs in the unsigned tx. ",
    "created_at": "2018-06-28T19:52:47Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198964995",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198964995"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198964995"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198964995/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 587,
    "side": "RIGHT",
    "in_reply_to_id": 198947030
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965231",
    "pull_request_review_id": 132994952,
    "id": 198965231,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk2NTIzMQ==",
    "diff_hunk": "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> sig;\n+                    sig.resize(value_len);\n+                    s >> MakeSpan(sig);\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PartiallySignedInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput",
    "path": "src/script/sign.h",
    "position": 339,
    "original_position": 298,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done. Renamed PartiallySignedInput to PSBTInput",
    "created_at": "2018-06-28T19:53:37Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965231",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965231"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965231"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965231/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 385,
    "original_line": 385,
    "side": "RIGHT",
    "in_reply_to_id": 198708045
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965252",
    "pull_request_review_id": 132994984,
    "id": 198965252,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk2NTI1Mg==",
    "diff_hunk": "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 44,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-06-28T19:53:42Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965252",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965252"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965252"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965252/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 122,
    "side": "RIGHT",
    "in_reply_to_id": 198708146
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965304",
    "pull_request_review_id": 132995071,
    "id": 198965304,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk2NTMwNA==",
    "diff_hunk": "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 200,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-06-28T19:53:57Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965304",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965304"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965304"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965304/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 268,
    "side": "RIGHT",
    "in_reply_to_id": 198933070
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965331",
    "pull_request_review_id": 132995102,
    "id": 198965331,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk2NTMzMQ==",
    "diff_hunk": "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:",
    "path": "src/script/sign.h",
    "position": 240,
    "original_position": 172,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-06-28T19:54:03Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965331",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965331"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965331"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965331/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 286,
    "original_line": 286,
    "side": "RIGHT",
    "in_reply_to_id": 198934388
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965350",
    "pull_request_review_id": 132995127,
    "id": 198965350,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk2NTM1MA==",
    "diff_hunk": "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> sig;\n+                    sig.resize(value_len);\n+                    s >> MakeSpan(sig);\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 281,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-06-28T19:54:07Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965350",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965350"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965350"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965350/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 349,
    "side": "RIGHT",
    "in_reply_to_id": 198937087
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965361",
    "pull_request_review_id": 132995146,
    "id": 198965361,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk2NTM2MQ==",
    "diff_hunk": "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> sig;\n+                    sig.resize(value_len);\n+                    s >> MakeSpan(sig);\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PartiallySignedInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput\n+{\n+    CScript redeem_script;\n+    CScript witness_script;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    PSBTOutput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the redeem script\n+        if (!redeem_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_REDEEMSCRIPT);\n+            s << redeem_script;\n+        }\n+\n+        // Write the witness script\n+        if (!witness_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_WITNESSSCRIPT);\n+            s << witness_script;\n+        }\n+\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            SerializeToVector(s, PSBT_OUT_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_OUT_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_OUT_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_OUT_BIP32_DERIVATION:",
    "path": "src/script/sign.h",
    "position": 413,
    "original_position": 380,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-06-28T19:54:11Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965361",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965361"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965361"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965361/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 459,
    "original_line": 459,
    "side": "RIGHT",
    "in_reply_to_id": 198937464
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965374",
    "pull_request_review_id": 132995170,
    "id": 198965374,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk2NTM3NA==",
    "diff_hunk": "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> sig;\n+                    sig.resize(value_len);\n+                    s >> MakeSpan(sig);\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PartiallySignedInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput\n+{\n+    CScript redeem_script;\n+    CScript witness_script;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    PSBTOutput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the redeem script\n+        if (!redeem_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_REDEEMSCRIPT);\n+            s << redeem_script;\n+        }\n+\n+        // Write the witness script\n+        if (!witness_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_WITNESSSCRIPT);\n+            s << witness_script;\n+        }\n+\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            SerializeToVector(s, PSBT_OUT_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_OUT_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_OUT_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_OUT_BIP32_DERIVATION:\n+                {\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default: {\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PSBTOutput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::vector<PSBTOutput> outputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    uint64_t num_ins = 0;",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 438,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Removed",
    "created_at": "2018-06-28T19:54:16Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965374",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965374"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965374"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965374/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 508,
    "side": "RIGHT",
    "in_reply_to_id": 198946369
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198991851",
    "pull_request_review_id": 133027924,
    "id": 198991851,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk5MTg1MQ==",
    "diff_hunk": "@@ -73,6 +76,565 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 18,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "fdd7cd5a1d2cfa2c676e87cd341dfc06d709d4aa",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "You could also write it as `uint8_t PSBT_MAGIC_BYTES[4] = \"PSBT\";`. Byte arrays can be serialized directly now.",
    "created_at": "2018-06-28T21:28:24Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198991851",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198991851"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198991851"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198991851/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 84,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198991986",
    "pull_request_review_id": 133027924,
    "id": 198991986,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk5MTk4Ng==",
    "diff_hunk": "@@ -73,6 +76,565 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 41,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "fdd7cd5a1d2cfa2c676e87cd341dfc06d709d4aa",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "`constexpr`",
    "created_at": "2018-06-28T21:28:47Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198991986",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198991986"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198991986"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198991986/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 107,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198992193",
    "pull_request_review_id": 133027924,
    "id": 198992193,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk5MjE5Mw==",
    "diff_hunk": "@@ -73,6 +76,565 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+static void DeserializeHDKeypaths(const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, Stream& s)",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 68,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "fdd7cd5a1d2cfa2c676e87cd341dfc06d709d4aa",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Add `template <typename Stream>` before.",
    "created_at": "2018-06-28T21:29:28Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198992193",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198992193"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198992193"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198992193/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 132,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198992304",
    "pull_request_review_id": 133027924,
    "id": 198992304,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk5MjMwNA==",
    "diff_hunk": "@@ -73,6 +76,565 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+static void DeserializeHDKeypaths(const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, Stream& s)\n+{\n+    // Make sure that the key is the size of pubkey + 1\n+    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+    }\n+    // Read in the pubkey from key\n+    CPubKey pubkey(key.begin() + 1, key.end());\n+    if (!pubkey.IsFullyValid()) {\n+       throw std::ios_base::failure(\"Invalid pubkey\");\n+    }\n+    if (hd_keypaths.count(pubkey) > 0) {\n+        throw std::ios_base::failure(\"Duplicate Key, pubkey derivation path already provided\");\n+    }\n+\n+    // Read in key path\n+    uint64_t value_len = ReadCompactSize(s);\n+    std::vector<uint32_t> keypath;\n+    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+        uint32_t index;\n+        s >> index;\n+        keypath.push_back(index);\n+    }\n+\n+    // Add to map\n+    hd_keypaths.emplace(pubkey, keypath);\n+}\n+\n+// Serialize HD keypaths to a stream from a map\n+static void SerializeHDKeypaths(std::vector<uint32_t>>& hd_keypaths, Stream& s)",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 97,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "fdd7cd5a1d2cfa2c676e87cd341dfc06d709d4aa",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Add `template<typename Stream>` before.",
    "created_at": "2018-06-28T21:29:51Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198992304",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198992304"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198992304"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198992304/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 161,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198993246",
    "pull_request_review_id": 133027924,
    "id": 198993246,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk5MzI0Ng==",
    "diff_hunk": "@@ -73,6 +76,565 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+static void DeserializeHDKeypaths(const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, Stream& s)\n+{\n+    // Make sure that the key is the size of pubkey + 1\n+    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+    }\n+    // Read in the pubkey from key\n+    CPubKey pubkey(key.begin() + 1, key.end());\n+    if (!pubkey.IsFullyValid()) {\n+       throw std::ios_base::failure(\"Invalid pubkey\");\n+    }\n+    if (hd_keypaths.count(pubkey) > 0) {\n+        throw std::ios_base::failure(\"Duplicate Key, pubkey derivation path already provided\");\n+    }\n+\n+    // Read in key path\n+    uint64_t value_len = ReadCompactSize(s);\n+    std::vector<uint32_t> keypath;\n+    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+        uint32_t index;\n+        s >> index;\n+        keypath.push_back(index);\n+    }\n+\n+    // Add to map\n+    hd_keypaths.emplace(pubkey, keypath);\n+}\n+\n+// Serialize HD keypaths to a stream from a map\n+static void SerializeHDKeypaths(std::vector<uint32_t>>& hd_keypaths, Stream& s)\n+{\n+    for (auto keypath_pair : hd_keypaths) {\n+        SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 100,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "fdd7cd5a1d2cfa2c676e87cd341dfc06d709d4aa",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Make the field type a function argument; it differs between input and output types.",
    "created_at": "2018-06-28T21:32:56Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198993246",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198993246"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198993246"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198993246/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 164,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198994362",
    "pull_request_review_id": 133027924,
    "id": 198994362,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk5NDM2Mg==",
    "diff_hunk": "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> sig;\n+                    sig.resize(value_len);\n+                    s >> MakeSpan(sig);\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PartiallySignedInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput\n+{\n+    CScript redeem_script;\n+    CScript witness_script;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    PSBTOutput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the redeem script\n+        if (!redeem_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_REDEEMSCRIPT);\n+            s << redeem_script;\n+        }\n+\n+        // Write the witness script\n+        if (!witness_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_WITNESSSCRIPT);\n+            s << witness_script;\n+        }\n+\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            SerializeToVector(s, PSBT_OUT_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_OUT_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_OUT_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_OUT_BIP32_DERIVATION:\n+                {\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default: {\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PSBTOutput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::vector<PSBTOutput> outputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    bool IsNull() const;\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in) : tx(psbt_in.tx), inputs(psbt_in.inputs), outputs(psbt_in.outputs), unknown(psbt_in.unknown) {}\n+\n+    // Only checks if they refer to the same transaction\n+    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return a.tx.GetHash() == b.tx.GetHash();\n+    }\n+    friend bool operator!=(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return !(a == b);\n+    }\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // unsigned tx flag\n+        SerializeToVector(s, PSBT_GLOBAL_UNSIGNED_TX);\n+\n+        // Write serialized tx to a stream\n+        SerializeToVector(s, tx);\n+\n+        // Write the unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        // Write inputs\n+        for (const PartiallySignedInput& input : inputs) {\n+            s << input;\n+        }\n+        // Write outputs\n+        for (const PSBTOutput& output : outputs) {\n+            s << output;\n+        }\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read the magic bytes\n+        int magic;\n+        s >> magic;\n+        if (magic != PSBT_MAGIC_BYTES) {\n+            throw std::ios_base::failure(\"Invalid PSBT magic bytes\");\n+        }\n+        unsigned char magic_sep;\n+        s >> magic_sep;\n+\n+        // Read global data\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                break;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_GLOBAL_UNSIGNED_TX:\n+                    if (!CTransaction(tx).IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, unsigned tx already provided\");\n+                    }\n+                    UnserializeFromVector(s, tx);\n+                    // Make sure that all scriptSigs and scriptWitnesses are empty\n+                    for (const CTxIn& txin : tx.vin) {\n+                        if (!txin.scriptSig.empty() || !txin.scriptWitness.IsNull()) {\n+                            throw std::ios_base::failure(\"Unsigned tx does not have empty scriptSigs and scriptWitnesses.\");\n+                        }\n+                    }\n+                    break;\n+                // Unknown stuff\n+                default: {\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                }\n+            }\n+        }\n+\n+        // Make sure that we got an unsigned tx\n+        if (CTransaction(tx).IsNull()) {\n+            throw std::ios_base::failure(\"No unsigned transcation was provided\");\n+        }\n+\n+        // Read input data\n+        unsigned int i = 0;\n+        while (!s.empty() && i < tx.vin.size()) {",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 553,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Ah, I see. That will probably give a more useful error.",
    "created_at": "2018-06-28T21:36:45Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198994362",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198994362"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198994362"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198994362/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 587,
    "side": "RIGHT",
    "in_reply_to_id": 198947030
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198998355",
    "pull_request_review_id": 133035647,
    "id": 198998355,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk5ODM1NQ==",
    "diff_hunk": "@@ -73,6 +76,565 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 41,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "fdd7cd5a1d2cfa2c676e87cd341dfc06d709d4aa",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-06-28T21:53:34Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198998355",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198998355"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198998355"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198998355/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 107,
    "side": "RIGHT",
    "in_reply_to_id": 198991986
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198998372",
    "pull_request_review_id": 133035666,
    "id": 198998372,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk5ODM3Mg==",
    "diff_hunk": "@@ -73,6 +76,565 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+static void DeserializeHDKeypaths(const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, Stream& s)",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 68,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "fdd7cd5a1d2cfa2c676e87cd341dfc06d709d4aa",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Fixed",
    "created_at": "2018-06-28T21:53:41Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198998372",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198998372"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198998372"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198998372/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 132,
    "side": "RIGHT",
    "in_reply_to_id": 198992193
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198998457",
    "pull_request_review_id": 133035769,
    "id": 198998457,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk5ODQ1Nw==",
    "diff_hunk": "@@ -73,6 +76,565 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+static void DeserializeHDKeypaths(const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, Stream& s)\n+{\n+    // Make sure that the key is the size of pubkey + 1\n+    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+    }\n+    // Read in the pubkey from key\n+    CPubKey pubkey(key.begin() + 1, key.end());\n+    if (!pubkey.IsFullyValid()) {\n+       throw std::ios_base::failure(\"Invalid pubkey\");\n+    }\n+    if (hd_keypaths.count(pubkey) > 0) {\n+        throw std::ios_base::failure(\"Duplicate Key, pubkey derivation path already provided\");\n+    }\n+\n+    // Read in key path\n+    uint64_t value_len = ReadCompactSize(s);\n+    std::vector<uint32_t> keypath;\n+    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+        uint32_t index;\n+        s >> index;\n+        keypath.push_back(index);\n+    }\n+\n+    // Add to map\n+    hd_keypaths.emplace(pubkey, keypath);\n+}\n+\n+// Serialize HD keypaths to a stream from a map\n+static void SerializeHDKeypaths(std::vector<uint32_t>>& hd_keypaths, Stream& s)",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 97,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "fdd7cd5a1d2cfa2c676e87cd341dfc06d709d4aa",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Fixed",
    "created_at": "2018-06-28T21:54:03Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198998457",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198998457"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198998457"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198998457/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 161,
    "side": "RIGHT",
    "in_reply_to_id": 198992304
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198998482",
    "pull_request_review_id": 133035800,
    "id": 198998482,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk5ODQ4Mg==",
    "diff_hunk": "@@ -73,6 +76,565 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+static void DeserializeHDKeypaths(const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, Stream& s)\n+{\n+    // Make sure that the key is the size of pubkey + 1\n+    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+    }\n+    // Read in the pubkey from key\n+    CPubKey pubkey(key.begin() + 1, key.end());\n+    if (!pubkey.IsFullyValid()) {\n+       throw std::ios_base::failure(\"Invalid pubkey\");\n+    }\n+    if (hd_keypaths.count(pubkey) > 0) {\n+        throw std::ios_base::failure(\"Duplicate Key, pubkey derivation path already provided\");\n+    }\n+\n+    // Read in key path\n+    uint64_t value_len = ReadCompactSize(s);\n+    std::vector<uint32_t> keypath;\n+    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+        uint32_t index;\n+        s >> index;\n+        keypath.push_back(index);\n+    }\n+\n+    // Add to map\n+    hd_keypaths.emplace(pubkey, keypath);\n+}\n+\n+// Serialize HD keypaths to a stream from a map\n+static void SerializeHDKeypaths(std::vector<uint32_t>>& hd_keypaths, Stream& s)\n+{\n+    for (auto keypath_pair : hd_keypaths) {\n+        SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 100,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "fdd7cd5a1d2cfa2c676e87cd341dfc06d709d4aa",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Fixed",
    "created_at": "2018-06-28T21:54:09Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198998482",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198998482"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198998482"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198998482/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 164,
    "side": "RIGHT",
    "in_reply_to_id": 198993246
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199004472",
    "pull_request_review_id": 133042762,
    "id": 199004472,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAwNDQ3Mg==",
    "diff_hunk": "@@ -73,6 +76,565 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 18,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "fdd7cd5a1d2cfa2c676e87cd341dfc06d709d4aa",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-06-28T22:22:11Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199004472",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199004472"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199004472"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199004472/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 84,
    "side": "RIGHT",
    "in_reply_to_id": 198991851
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199005299",
    "pull_request_review_id": 133043120,
    "id": 199005299,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAwNTI5OQ==",
    "diff_hunk": "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions",
    "path": "src/rpc/rawtransaction.cpp",
    "position": 322,
    "original_position": 101,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "af544a96fa3a74f960723d5c34f3b015e683ae57",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Would it make sense to abstract out this convert-base64-to-psbt RPC routine into a separate function? It's probably called from many RPCs.",
    "created_at": "2018-06-28T22:25:51Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199005299",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199005299"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199005299"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199005299/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1370,
    "original_line": 1370,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199005647",
    "pull_request_review_id": 133043120,
    "id": 199005647,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAwNTY0Nw==",
    "diff_hunk": "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 197,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "af544a96fa3a74f960723d5c34f3b015e683ae57",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Also add unknowns to the decode?",
    "created_at": "2018-06-28T22:26:40Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199005647",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199005647"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199005647"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199005647/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1469,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199005825",
    "pull_request_review_id": 133043120,
    "id": 199005825,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAwNTgyNQ==",
    "diff_hunk": "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 84,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "af544a96fa3a74f960723d5c34f3b015e683ae57",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "What do you think about combing fingerprint and path into one string (like proposed in my descriptor language)?",
    "created_at": "2018-06-28T22:27:23Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199005825",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199005825"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199005825"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199005825/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1345,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199006165",
    "pull_request_review_id": 133043120,
    "id": 199006165,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAwNjE2NQ==",
    "diff_hunk": "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::vector<unsigned char> txData = DecodeBase64(txs[i].get_str().c_str());\n+        CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+        try {\n+            ssData >> psbtx;\n+            if (!ssData.empty()) {\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+            }\n+        } catch (const std::exception& e) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbtx(psbtxs[0]); // Copy the first one\n+    // Merge input data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vin.size(); ++i) {\n+        CTxIn& txin = merged_psbtx.tx.vin[i];\n+\n+        // Find the utxo from one of the psbtxs\n+        CTxOut utxo;\n+        CTransactionRef non_witness_utxo = nullptr;\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // First find the non-witness utxo\n+            if (psbtx.inputs.at(i).non_witness_utxo) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n]) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n];\n+                    non_witness_utxo = psbtx.inputs.at(i).non_witness_utxo;\n+                }\n+            }\n+            // Now find the witness utxo if the non witness doesn't exist\n+            else if (!psbtx.inputs.at(i).witness_utxo.IsNull()) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).witness_utxo) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).witness_utxo;\n+                }\n+            }\n+            // If there is no nonwitness or witness utxo, the continue and see if it is in another psbt\n+            else {\n+                continue;\n+            }\n+        }\n+\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 327,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "af544a96fa3a74f960723d5c34f3b015e683ae57",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "It feels like this should be written as a method or function operating on `PartiallySignedTransaction` objects, rather than inside the RPC code.",
    "created_at": "2018-06-28T22:28:30Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199006165",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199006165"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199006165"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199006165/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1588,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199006515",
    "pull_request_review_id": 133043120,
    "id": 199006515,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAwNjUxNQ==",
    "diff_hunk": "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::vector<unsigned char> txData = DecodeBase64(txs[i].get_str().c_str());\n+        CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+        try {\n+            ssData >> psbtx;\n+            if (!ssData.empty()) {\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+            }\n+        } catch (const std::exception& e) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbtx(psbtxs[0]); // Copy the first one\n+    // Merge input data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vin.size(); ++i) {\n+        CTxIn& txin = merged_psbtx.tx.vin[i];\n+\n+        // Find the utxo from one of the psbtxs",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 294,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "af544a96fa3a74f960723d5c34f3b015e683ae57",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I'm not sure what this entire UTXO handling section does. Is it sufficient to (a) rely on a generic combine PSBT function somewhere (suggested below) which also combined the utxo data, and then perhaps convert the logic in this section to a sanity check function?",
    "created_at": "2018-06-28T22:29:48Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199006515",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199006515"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199006515"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199006515/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1555,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199006766",
    "pull_request_review_id": 133043120,
    "id": 199006766,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAwNjc2Ng==",
    "diff_hunk": "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::vector<unsigned char> txData = DecodeBase64(txs[i].get_str().c_str());\n+        CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+        try {\n+            ssData >> psbtx;\n+            if (!ssData.empty()) {\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+            }\n+        } catch (const std::exception& e) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbtx(psbtxs[0]); // Copy the first one\n+    // Merge input data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vin.size(); ++i) {\n+        CTxIn& txin = merged_psbtx.tx.vin[i];\n+\n+        // Find the utxo from one of the psbtxs\n+        CTxOut utxo;\n+        CTransactionRef non_witness_utxo = nullptr;\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // First find the non-witness utxo\n+            if (psbtx.inputs.at(i).non_witness_utxo) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n]) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n];\n+                    non_witness_utxo = psbtx.inputs.at(i).non_witness_utxo;\n+                }\n+            }\n+            // Now find the witness utxo if the non witness doesn't exist\n+            else if (!psbtx.inputs.at(i).witness_utxo.IsNull()) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).witness_utxo) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).witness_utxo;\n+                }\n+            }\n+            // If there is no nonwitness or witness utxo, the continue and see if it is in another psbt\n+            else {\n+                continue;\n+            }\n+        }\n+\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.inputs.at(i).partial_sigs.insert(psbtx.inputs.at(i).partial_sigs.begin(), psbtx.inputs.at(i).partial_sigs.end());\n+            merged_psbtx.inputs.at(i).hd_keypaths.insert(psbtx.inputs.at(i).hd_keypaths.begin(), psbtx.inputs.at(i).hd_keypaths.end());\n+            merged_psbtx.inputs.at(i).unknown.insert(psbtx.inputs.at(i).unknown.begin(), psbtx.inputs.at(i).unknown.end());\n+            if (merged_psbtx.inputs.at(i).redeem_script.empty() && !psbtx.inputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.inputs.at(i).redeem_script = psbtx.inputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).witness_script.empty() && !psbtx.inputs.at(i).witness_script.empty()) {\n+                merged_psbtx.inputs.at(i).witness_script = psbtx.inputs.at(i).witness_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_sig.empty() && !psbtx.inputs.at(i).final_script_sig.empty()) {\n+                merged_psbtx.inputs.at(i).final_script_sig = psbtx.inputs.at(i).final_script_sig;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_witness.IsNull() && !psbtx.inputs.at(i).final_script_witness.IsNull()) {\n+                merged_psbtx.inputs.at(i).final_script_witness = psbtx.inputs.at(i).final_script_witness;\n+            }\n+        }\n+\n+        // Only do this if there was a utxo\n+        if (!utxo.IsNull()) {\n+            // Put the UTXO in the merged psbtx\n+            if (non_witness_utxo) {\n+                merged_psbtx.inputs.at(i).non_witness_utxo = non_witness_utxo;\n+            } else {\n+                merged_psbtx.inputs.at(i).witness_utxo = utxo;\n+            }\n+        }\n+    }\n+\n+    // Merge the output data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vout.size(); ++i) {\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.outputs.at(i).hd_keypaths.insert(psbtx.outputs.at(i).hd_keypaths.begin(), psbtx.outputs.at(i).hd_keypaths.end());\n+            merged_psbtx.outputs.at(i).unknown.insert(psbtx.outputs.at(i).unknown.begin(), psbtx.outputs.at(i).unknown.end());\n+            if (merged_psbtx.outputs.at(i).redeem_script.empty() && !psbtx.outputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.outputs.at(i).redeem_script = psbtx.outputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.outputs.at(i).witness_script.empty() && !psbtx.outputs.at(i).witness_script.empty()) {\n+                merged_psbtx.outputs.at(i).witness_script = psbtx.outputs.at(i).witness_script;\n+            }\n+        }\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"base64string\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"            (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded network transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded partially signed transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"base64string\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx.vin.size(); ++i) {\n+        CTxIn txin = psbtx.tx.vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // if this input has a final scriptsig or scriptwitness, don't do anything with it\n+        if (!input.final_script_sig.empty() || !input.final_script_witness.IsNull()) {\n+            continue;\n+        }\n+\n+        // Fill a SignatureData with input info\n+        SignatureData sigdata;\n+        input.FillSignatureData(sigdata);\n+\n+        // Get UTXO\n+        CTxOut utxo;\n+        if (input.non_witness_utxo) {\n+            utxo = input.non_witness_utxo->vout[txin.prevout.n];\n+        }\n+        // Now find the witness utxo if the non witness doesn't exist\n+        else if (!input.witness_utxo.IsNull()) {",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 439,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "af544a96fa3a74f960723d5c34f3b015e683ae57",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Nit: `else` on the same line as `}` (and elsewhere).",
    "created_at": "2018-06-28T22:31:12Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199006766",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199006766"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199006766"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199006766/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1700,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199009612",
    "pull_request_review_id": 133043120,
    "id": 199009612,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAwOTYxMg==",
    "diff_hunk": "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 28,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "af544a96fa3a74f960723d5c34f3b015e683ae57",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Not hex encoded.",
    "created_at": "2018-06-28T22:46:22Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199009612",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199009612"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199009612"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199009612/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1289,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199009777",
    "pull_request_review_id": 133043120,
    "id": 199009777,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAwOTc3Nw==",
    "diff_hunk": "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 242,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "af544a96fa3a74f960723d5c34f3b015e683ae57",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Explain that this implements the Combiner and Finalizer roles?",
    "created_at": "2018-06-28T22:47:11Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199009777",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199009777"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199009777"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199009777/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1553,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199010254",
    "pull_request_review_id": 133043120,
    "id": 199010254,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAxMDI1NA==",
    "diff_hunk": "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::vector<unsigned char> txData = DecodeBase64(txs[i].get_str().c_str());\n+        CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+        try {\n+            ssData >> psbtx;\n+            if (!ssData.empty()) {\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+            }\n+        } catch (const std::exception& e) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbtx(psbtxs[0]); // Copy the first one\n+    // Merge input data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vin.size(); ++i) {\n+        CTxIn& txin = merged_psbtx.tx.vin[i];\n+\n+        // Find the utxo from one of the psbtxs\n+        CTxOut utxo;\n+        CTransactionRef non_witness_utxo = nullptr;\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // First find the non-witness utxo\n+            if (psbtx.inputs.at(i).non_witness_utxo) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n]) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n];\n+                    non_witness_utxo = psbtx.inputs.at(i).non_witness_utxo;\n+                }\n+            }\n+            // Now find the witness utxo if the non witness doesn't exist\n+            else if (!psbtx.inputs.at(i).witness_utxo.IsNull()) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).witness_utxo) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).witness_utxo;\n+                }\n+            }\n+            // If there is no nonwitness or witness utxo, the continue and see if it is in another psbt\n+            else {\n+                continue;\n+            }\n+        }\n+\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.inputs.at(i).partial_sigs.insert(psbtx.inputs.at(i).partial_sigs.begin(), psbtx.inputs.at(i).partial_sigs.end());\n+            merged_psbtx.inputs.at(i).hd_keypaths.insert(psbtx.inputs.at(i).hd_keypaths.begin(), psbtx.inputs.at(i).hd_keypaths.end());\n+            merged_psbtx.inputs.at(i).unknown.insert(psbtx.inputs.at(i).unknown.begin(), psbtx.inputs.at(i).unknown.end());\n+            if (merged_psbtx.inputs.at(i).redeem_script.empty() && !psbtx.inputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.inputs.at(i).redeem_script = psbtx.inputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).witness_script.empty() && !psbtx.inputs.at(i).witness_script.empty()) {\n+                merged_psbtx.inputs.at(i).witness_script = psbtx.inputs.at(i).witness_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_sig.empty() && !psbtx.inputs.at(i).final_script_sig.empty()) {\n+                merged_psbtx.inputs.at(i).final_script_sig = psbtx.inputs.at(i).final_script_sig;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_witness.IsNull() && !psbtx.inputs.at(i).final_script_witness.IsNull()) {\n+                merged_psbtx.inputs.at(i).final_script_witness = psbtx.inputs.at(i).final_script_witness;\n+            }\n+        }\n+\n+        // Only do this if there was a utxo\n+        if (!utxo.IsNull()) {\n+            // Put the UTXO in the merged psbtx\n+            if (non_witness_utxo) {\n+                merged_psbtx.inputs.at(i).non_witness_utxo = non_witness_utxo;\n+            } else {\n+                merged_psbtx.inputs.at(i).witness_utxo = utxo;\n+            }\n+        }\n+    }\n+\n+    // Merge the output data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vout.size(); ++i) {\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.outputs.at(i).hd_keypaths.insert(psbtx.outputs.at(i).hd_keypaths.begin(), psbtx.outputs.at(i).hd_keypaths.end());\n+            merged_psbtx.outputs.at(i).unknown.insert(psbtx.outputs.at(i).unknown.begin(), psbtx.outputs.at(i).unknown.end());\n+            if (merged_psbtx.outputs.at(i).redeem_script.empty() && !psbtx.outputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.outputs.at(i).redeem_script = psbtx.outputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.outputs.at(i).witness_script.empty() && !psbtx.outputs.at(i).witness_script.empty()) {\n+                merged_psbtx.outputs.at(i).witness_script = psbtx.outputs.at(i).witness_script;\n+            }\n+        }\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"base64string\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"            (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded network transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded partially signed transaction if extracted\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 394,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "af544a96fa3a74f960723d5c34f3b015e683ae57",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Fully signed transaction, no? It seems the explanation of this and the field above are swapped.",
    "created_at": "2018-06-28T22:49:48Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199010254",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199010254"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199010254"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199010254/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1655,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199010547",
    "pull_request_review_id": 133043120,
    "id": 199010547,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAxMDU0Nw==",
    "diff_hunk": "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::vector<unsigned char> txData = DecodeBase64(txs[i].get_str().c_str());\n+        CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+        try {\n+            ssData >> psbtx;\n+            if (!ssData.empty()) {\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+            }\n+        } catch (const std::exception& e) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbtx(psbtxs[0]); // Copy the first one\n+    // Merge input data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vin.size(); ++i) {\n+        CTxIn& txin = merged_psbtx.tx.vin[i];\n+\n+        // Find the utxo from one of the psbtxs\n+        CTxOut utxo;\n+        CTransactionRef non_witness_utxo = nullptr;\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // First find the non-witness utxo\n+            if (psbtx.inputs.at(i).non_witness_utxo) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n]) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n];\n+                    non_witness_utxo = psbtx.inputs.at(i).non_witness_utxo;\n+                }\n+            }\n+            // Now find the witness utxo if the non witness doesn't exist\n+            else if (!psbtx.inputs.at(i).witness_utxo.IsNull()) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).witness_utxo) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).witness_utxo;\n+                }\n+            }\n+            // If there is no nonwitness or witness utxo, the continue and see if it is in another psbt\n+            else {\n+                continue;\n+            }\n+        }\n+\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.inputs.at(i).partial_sigs.insert(psbtx.inputs.at(i).partial_sigs.begin(), psbtx.inputs.at(i).partial_sigs.end());\n+            merged_psbtx.inputs.at(i).hd_keypaths.insert(psbtx.inputs.at(i).hd_keypaths.begin(), psbtx.inputs.at(i).hd_keypaths.end());\n+            merged_psbtx.inputs.at(i).unknown.insert(psbtx.inputs.at(i).unknown.begin(), psbtx.inputs.at(i).unknown.end());\n+            if (merged_psbtx.inputs.at(i).redeem_script.empty() && !psbtx.inputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.inputs.at(i).redeem_script = psbtx.inputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).witness_script.empty() && !psbtx.inputs.at(i).witness_script.empty()) {\n+                merged_psbtx.inputs.at(i).witness_script = psbtx.inputs.at(i).witness_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_sig.empty() && !psbtx.inputs.at(i).final_script_sig.empty()) {\n+                merged_psbtx.inputs.at(i).final_script_sig = psbtx.inputs.at(i).final_script_sig;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_witness.IsNull() && !psbtx.inputs.at(i).final_script_witness.IsNull()) {\n+                merged_psbtx.inputs.at(i).final_script_witness = psbtx.inputs.at(i).final_script_witness;\n+            }\n+        }\n+\n+        // Only do this if there was a utxo\n+        if (!utxo.IsNull()) {\n+            // Put the UTXO in the merged psbtx\n+            if (non_witness_utxo) {\n+                merged_psbtx.inputs.at(i).non_witness_utxo = non_witness_utxo;\n+            } else {\n+                merged_psbtx.inputs.at(i).witness_utxo = utxo;\n+            }\n+        }\n+    }\n+\n+    // Merge the output data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vout.size(); ++i) {\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.outputs.at(i).hd_keypaths.insert(psbtx.outputs.at(i).hd_keypaths.begin(), psbtx.outputs.at(i).hd_keypaths.end());\n+            merged_psbtx.outputs.at(i).unknown.insert(psbtx.outputs.at(i).unknown.begin(), psbtx.outputs.at(i).unknown.end());\n+            if (merged_psbtx.outputs.at(i).redeem_script.empty() && !psbtx.outputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.outputs.at(i).redeem_script = psbtx.outputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.outputs.at(i).witness_script.empty() && !psbtx.outputs.at(i).witness_script.empty()) {\n+                merged_psbtx.outputs.at(i).witness_script = psbtx.outputs.at(i).witness_script;\n+            }\n+        }\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"base64string\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"            (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded network transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded partially signed transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"base64string\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx.vin.size(); ++i) {\n+        CTxIn txin = psbtx.tx.vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // if this input has a final scriptsig or scriptwitness, don't do anything with it\n+        if (!input.final_script_sig.empty() || !input.final_script_witness.IsNull()) {\n+            continue;\n+        }\n+\n+        // Fill a SignatureData with input info",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 429,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "af544a96fa3a74f960723d5c34f3b015e683ae57",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This whole section that extracts UTXOs and data from a PSBT input and invokes ProduceSignature on it seems like something that can be abstracted out.",
    "created_at": "2018-06-28T22:51:30Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199010547",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199010547"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199010547"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199010547/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1690,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199010700",
    "pull_request_review_id": 133043120,
    "id": 199010700,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAxMDcwMA==",
    "diff_hunk": "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::vector<unsigned char> txData = DecodeBase64(txs[i].get_str().c_str());\n+        CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+        try {\n+            ssData >> psbtx;\n+            if (!ssData.empty()) {\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+            }\n+        } catch (const std::exception& e) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbtx(psbtxs[0]); // Copy the first one\n+    // Merge input data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vin.size(); ++i) {\n+        CTxIn& txin = merged_psbtx.tx.vin[i];\n+\n+        // Find the utxo from one of the psbtxs\n+        CTxOut utxo;\n+        CTransactionRef non_witness_utxo = nullptr;\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // First find the non-witness utxo\n+            if (psbtx.inputs.at(i).non_witness_utxo) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n]) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n];\n+                    non_witness_utxo = psbtx.inputs.at(i).non_witness_utxo;\n+                }\n+            }\n+            // Now find the witness utxo if the non witness doesn't exist\n+            else if (!psbtx.inputs.at(i).witness_utxo.IsNull()) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).witness_utxo) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).witness_utxo;\n+                }\n+            }\n+            // If there is no nonwitness or witness utxo, the continue and see if it is in another psbt\n+            else {\n+                continue;\n+            }\n+        }\n+\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.inputs.at(i).partial_sigs.insert(psbtx.inputs.at(i).partial_sigs.begin(), psbtx.inputs.at(i).partial_sigs.end());\n+            merged_psbtx.inputs.at(i).hd_keypaths.insert(psbtx.inputs.at(i).hd_keypaths.begin(), psbtx.inputs.at(i).hd_keypaths.end());\n+            merged_psbtx.inputs.at(i).unknown.insert(psbtx.inputs.at(i).unknown.begin(), psbtx.inputs.at(i).unknown.end());\n+            if (merged_psbtx.inputs.at(i).redeem_script.empty() && !psbtx.inputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.inputs.at(i).redeem_script = psbtx.inputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).witness_script.empty() && !psbtx.inputs.at(i).witness_script.empty()) {\n+                merged_psbtx.inputs.at(i).witness_script = psbtx.inputs.at(i).witness_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_sig.empty() && !psbtx.inputs.at(i).final_script_sig.empty()) {\n+                merged_psbtx.inputs.at(i).final_script_sig = psbtx.inputs.at(i).final_script_sig;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_witness.IsNull() && !psbtx.inputs.at(i).final_script_witness.IsNull()) {\n+                merged_psbtx.inputs.at(i).final_script_witness = psbtx.inputs.at(i).final_script_witness;\n+            }\n+        }\n+\n+        // Only do this if there was a utxo\n+        if (!utxo.IsNull()) {\n+            // Put the UTXO in the merged psbtx\n+            if (non_witness_utxo) {\n+                merged_psbtx.inputs.at(i).non_witness_utxo = non_witness_utxo;\n+            } else {\n+                merged_psbtx.inputs.at(i).witness_utxo = utxo;\n+            }\n+        }\n+    }\n+\n+    // Merge the output data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vout.size(); ++i) {\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.outputs.at(i).hd_keypaths.insert(psbtx.outputs.at(i).hd_keypaths.begin(), psbtx.outputs.at(i).hd_keypaths.end());\n+            merged_psbtx.outputs.at(i).unknown.insert(psbtx.outputs.at(i).unknown.begin(), psbtx.outputs.at(i).unknown.end());\n+            if (merged_psbtx.outputs.at(i).redeem_script.empty() && !psbtx.outputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.outputs.at(i).redeem_script = psbtx.outputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.outputs.at(i).witness_script.empty() && !psbtx.outputs.at(i).witness_script.empty()) {\n+                merged_psbtx.outputs.at(i).witness_script = psbtx.outputs.at(i).witness_script;\n+            }\n+        }\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"base64string\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"            (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded network transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded partially signed transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"base64string\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx.vin.size(); ++i) {\n+        CTxIn txin = psbtx.tx.vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // if this input has a final scriptsig or scriptwitness, don't do anything with it\n+        if (!input.final_script_sig.empty() || !input.final_script_witness.IsNull()) {\n+            continue;\n+        }\n+\n+        // Fill a SignatureData with input info\n+        SignatureData sigdata;\n+        input.FillSignatureData(sigdata);\n+\n+        // Get UTXO\n+        CTxOut utxo;\n+        if (input.non_witness_utxo) {\n+            utxo = input.non_witness_utxo->vout[txin.prevout.n];\n+        }\n+        // Now find the witness utxo if the non witness doesn't exist\n+        else if (!input.witness_utxo.IsNull()) {\n+            utxo = input.witness_utxo;\n+        }\n+        // No UTXO, don't do anything\n+        else {\n+            continue;\n+        }\n+\n+        MutableTransactionSignatureCreator creator(&psbtx.tx, i, utxo.nValue, 1);\n+        bool sig_complete = ProduceSignature(DUMMY_SIGNING_PROVIDER, creator, utxo.scriptPubKey, sigdata);\n+        input.FromSignatureData(sigdata);\n+        complete &= sig_complete;\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\n+    if (complete && extract) {\n+        CMutableTransaction mtx(psbtx.tx);\n+        for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+            mtx.vin[i].scriptSig = psbtx.inputs[i].final_script_sig;\n+            mtx.vin[i].scriptWitness = psbtx.inputs[i].final_script_witness;\n+        }\n+        ssTx << mtx;\n+        result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n+    } else {\n+        ssTx << psbtx;\n+        result.push_back(Pair(\"base64\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size())));\n+    }\n+    result.push_back(Pair(\"complete\", complete));\n+\n+    return result;\n+}\n+\n+UniValue createpsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n+        throw std::runtime_error(\n+                            \"createpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable )\\n\"\n+                            \"\\nCreates and funds a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 478,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "af544a96fa3a74f960723d5c34f3b015e683ae57",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This RPC does not do any funding, I think.\r\n\r\nExplain that this implements a Creator role.",
    "created_at": "2018-06-28T22:52:26Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199010700",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199010700"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199010700"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199010700/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1739,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199012847",
    "pull_request_review_id": 133043120,
    "id": 199012847,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAxMjg0Nw==",
    "diff_hunk": "@@ -91,6 +91,15 @@ class base_blob\n                ((uint64_t)ptr[7]) << 56;\n     }\n \n+    uint32_t GetUint32LE(int pos) const",
    "path": "src/uint256.h",
    "position": null,
    "original_position": 4,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "ed7a484d92034e79b753c9594c2b099d3be959f4",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "You can use `ReadLE32` for this, it's more efficient.\r\n\r\nIf instead this would be BE (`ReadBE32` also exists), you can get rid of `Uint32ToUint8VectorLE` and instead print using `strprintf(\"%08x\", fingerprint)`.",
    "created_at": "2018-06-28T23:04:06Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199012847",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199012847"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199012847"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199012847/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 94,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199013256",
    "pull_request_review_id": 133043120,
    "id": 199013256,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAxMzI1Ng==",
    "diff_hunk": "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::vector<unsigned char> txData = DecodeBase64(txs[i].get_str().c_str());\n+        CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+        try {\n+            ssData >> psbtx;\n+            if (!ssData.empty()) {\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+            }\n+        } catch (const std::exception& e) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbtx(psbtxs[0]); // Copy the first one\n+    // Merge input data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vin.size(); ++i) {\n+        CTxIn& txin = merged_psbtx.tx.vin[i];\n+\n+        // Find the utxo from one of the psbtxs\n+        CTxOut utxo;\n+        CTransactionRef non_witness_utxo = nullptr;\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // First find the non-witness utxo\n+            if (psbtx.inputs.at(i).non_witness_utxo) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n]) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n];\n+                    non_witness_utxo = psbtx.inputs.at(i).non_witness_utxo;\n+                }\n+            }\n+            // Now find the witness utxo if the non witness doesn't exist\n+            else if (!psbtx.inputs.at(i).witness_utxo.IsNull()) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).witness_utxo) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).witness_utxo;\n+                }\n+            }\n+            // If there is no nonwitness or witness utxo, the continue and see if it is in another psbt\n+            else {\n+                continue;\n+            }\n+        }\n+\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.inputs.at(i).partial_sigs.insert(psbtx.inputs.at(i).partial_sigs.begin(), psbtx.inputs.at(i).partial_sigs.end());\n+            merged_psbtx.inputs.at(i).hd_keypaths.insert(psbtx.inputs.at(i).hd_keypaths.begin(), psbtx.inputs.at(i).hd_keypaths.end());\n+            merged_psbtx.inputs.at(i).unknown.insert(psbtx.inputs.at(i).unknown.begin(), psbtx.inputs.at(i).unknown.end());\n+            if (merged_psbtx.inputs.at(i).redeem_script.empty() && !psbtx.inputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.inputs.at(i).redeem_script = psbtx.inputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).witness_script.empty() && !psbtx.inputs.at(i).witness_script.empty()) {\n+                merged_psbtx.inputs.at(i).witness_script = psbtx.inputs.at(i).witness_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_sig.empty() && !psbtx.inputs.at(i).final_script_sig.empty()) {\n+                merged_psbtx.inputs.at(i).final_script_sig = psbtx.inputs.at(i).final_script_sig;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_witness.IsNull() && !psbtx.inputs.at(i).final_script_witness.IsNull()) {\n+                merged_psbtx.inputs.at(i).final_script_witness = psbtx.inputs.at(i).final_script_witness;\n+            }\n+        }\n+\n+        // Only do this if there was a utxo\n+        if (!utxo.IsNull()) {\n+            // Put the UTXO in the merged psbtx\n+            if (non_witness_utxo) {\n+                merged_psbtx.inputs.at(i).non_witness_utxo = non_witness_utxo;\n+            } else {\n+                merged_psbtx.inputs.at(i).witness_utxo = utxo;\n+            }\n+        }\n+    }\n+\n+    // Merge the output data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vout.size(); ++i) {\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.outputs.at(i).hd_keypaths.insert(psbtx.outputs.at(i).hd_keypaths.begin(), psbtx.outputs.at(i).hd_keypaths.end());\n+            merged_psbtx.outputs.at(i).unknown.insert(psbtx.outputs.at(i).unknown.begin(), psbtx.outputs.at(i).unknown.end());\n+            if (merged_psbtx.outputs.at(i).redeem_script.empty() && !psbtx.outputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.outputs.at(i).redeem_script = psbtx.outputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.outputs.at(i).witness_script.empty() && !psbtx.outputs.at(i).witness_script.empty()) {\n+                merged_psbtx.outputs.at(i).witness_script = psbtx.outputs.at(i).witness_script;\n+            }\n+        }\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"base64string\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"            (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded network transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded partially signed transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"base64string\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx.vin.size(); ++i) {\n+        CTxIn txin = psbtx.tx.vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // if this input has a final scriptsig or scriptwitness, don't do anything with it\n+        if (!input.final_script_sig.empty() || !input.final_script_witness.IsNull()) {\n+            continue;\n+        }\n+\n+        // Fill a SignatureData with input info\n+        SignatureData sigdata;\n+        input.FillSignatureData(sigdata);\n+\n+        // Get UTXO\n+        CTxOut utxo;\n+        if (input.non_witness_utxo) {\n+            utxo = input.non_witness_utxo->vout[txin.prevout.n];\n+        }\n+        // Now find the witness utxo if the non witness doesn't exist\n+        else if (!input.witness_utxo.IsNull()) {\n+            utxo = input.witness_utxo;\n+        }\n+        // No UTXO, don't do anything\n+        else {\n+            continue;\n+        }\n+\n+        MutableTransactionSignatureCreator creator(&psbtx.tx, i, utxo.nValue, 1);\n+        bool sig_complete = ProduceSignature(DUMMY_SIGNING_PROVIDER, creator, utxo.scriptPubKey, sigdata);\n+        input.FromSignatureData(sigdata);\n+        complete &= sig_complete;\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\n+    if (complete && extract) {\n+        CMutableTransaction mtx(psbtx.tx);\n+        for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+            mtx.vin[i].scriptSig = psbtx.inputs[i].final_script_sig;\n+            mtx.vin[i].scriptWitness = psbtx.inputs[i].final_script_witness;\n+        }\n+        ssTx << mtx;\n+        result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n+    } else {\n+        ssTx << psbtx;\n+        result.push_back(Pair(\"base64\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size())));\n+    }\n+    result.push_back(Pair(\"complete\", complete));\n+\n+    return result;\n+}\n+\n+UniValue createpsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n+        throw std::runtime_error(\n+                            \"createpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable )\\n\"\n+                            \"\\nCreates and funds a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"inputs\\\"                (array, required) A json array of json objects\\n\"\n+                            \"     [\\n\"\n+                            \"       {\\n\"\n+                            \"         \\\"txid\\\":\\\"id\\\",      (string, required) The transaction id\\n\"\n+                            \"         \\\"vout\\\":n,         (numeric, required) The output number\\n\"\n+                            \"         \\\"sequence\\\":n      (numeric, optional) The sequence number\\n\"\n+                            \"       } \\n\"\n+                            \"       ,...\\n\"\n+                            \"     ]\\n\"\n+                            \"2. \\\"outputs\\\"               (array, required) a json array with outputs (key-value pairs)\\n\"\n+                            \"   [\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"address\\\": x.xxx,    (obj, optional) A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\\n\"\n+                            \"    },\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"data\\\": \\\"hex\\\"        (obj, optional) A key-value pair. The key must be \\\"data\\\", the value is hex encoded data\\n\"\n+                            \"    }\\n\"\n+                            \"    ,...                     More key-value pairs of the above form. For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n+                            \"                             accepted as second parameter.\\n\"\n+                            \"   ]\\n\"\n+                            \"3. locktime                  (numeric, optional, default=0) Raw locktime. Non-0 value also locktime-activates inputs\\n\"\n+                            \"4. replaceable               (boolean, optional, default=false) Marks this transaction as BIP125 replaceable.\\n\"\n+                            \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"base64\\\": \\\"value\\\",      (string)  The resulting raw transaction (base64-encoded string)\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"createpsbt\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")\n+                            );\n+\n+\n+    RPCTypeCheck(request.params, {\n+        UniValue::VARR,\n+        UniValueType(), // ARR or OBJ, checked later\n+        UniValue::VNUM,\n+        UniValue::VBOOL,\n+        }, true\n+    );\n+\n+    CMutableTransaction rawTx = ConstructTransaction(request.params[0], request.params[1], request.params[2], request.params[3]);\n+\n+    // Make a blank psbt\n+    PartiallySignedTransaction psbtx;\n+    psbtx.tx = rawTx;\n+    for (unsigned int i = 0; i < rawTx.vin.size(); ++i) {\n+        psbtx.inputs.push_back(PSBTInput());\n+    }\n+    for (unsigned int i = 0; i < rawTx.vout.size(); ++i) {\n+        psbtx.outputs.push_back(PSBTOutput());\n+    }\n+\n+    // Serialize the PSBT\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue converttopsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+                            \"converttopsbt \\\"hexstring\\\" ( permitsigdata iswitness )\\n\"\n+                            \"\\nConverts a network serialized transaction to a PSBT.\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 542,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "af544a96fa3a74f960723d5c34f3b015e683ae57",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Perhaps clarify that it's intended to work with `createrawtransaction` and `fundrawtransaction`, and `createpsbt`/`createfundedpsbt` should be used for new applications.",
    "created_at": "2018-06-28T23:06:42Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199013256",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199013256"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199013256"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199013256/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1803,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199017225",
    "pull_request_review_id": 133056768,
    "id": 199017225,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAxNzIyNQ==",
    "diff_hunk": "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 84,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "af544a96fa3a74f960723d5c34f3b015e683ae57",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I think it is clearer to list the fingerprint separately.",
    "created_at": "2018-06-28T23:30:52Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199017225",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199017225"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199017225"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199017225/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1345,
    "side": "RIGHT",
    "in_reply_to_id": 199005825
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199017473",
    "pull_request_review_id": 133057086,
    "id": 199017473,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAxNzQ3Mw==",
    "diff_hunk": "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::vector<unsigned char> txData = DecodeBase64(txs[i].get_str().c_str());\n+        CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+        try {\n+            ssData >> psbtx;\n+            if (!ssData.empty()) {\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+            }\n+        } catch (const std::exception& e) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbtx(psbtxs[0]); // Copy the first one\n+    // Merge input data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vin.size(); ++i) {\n+        CTxIn& txin = merged_psbtx.tx.vin[i];\n+\n+        // Find the utxo from one of the psbtxs\n+        CTxOut utxo;\n+        CTransactionRef non_witness_utxo = nullptr;\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // First find the non-witness utxo\n+            if (psbtx.inputs.at(i).non_witness_utxo) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n]) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n];\n+                    non_witness_utxo = psbtx.inputs.at(i).non_witness_utxo;\n+                }\n+            }\n+            // Now find the witness utxo if the non witness doesn't exist\n+            else if (!psbtx.inputs.at(i).witness_utxo.IsNull()) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).witness_utxo) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).witness_utxo;\n+                }\n+            }\n+            // If there is no nonwitness or witness utxo, the continue and see if it is in another psbt\n+            else {\n+                continue;\n+            }\n+        }\n+\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 327,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "af544a96fa3a74f960723d5c34f3b015e683ae57",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Why?",
    "created_at": "2018-06-28T23:32:31Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199017473",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199017473"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199017473"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199017473/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1588,
    "side": "RIGHT",
    "in_reply_to_id": 199006165
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199017650",
    "pull_request_review_id": 133057324,
    "id": 199017650,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAxNzY1MA==",
    "diff_hunk": "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::vector<unsigned char> txData = DecodeBase64(txs[i].get_str().c_str());\n+        CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+        try {\n+            ssData >> psbtx;\n+            if (!ssData.empty()) {\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+            }\n+        } catch (const std::exception& e) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbtx(psbtxs[0]); // Copy the first one\n+    // Merge input data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vin.size(); ++i) {\n+        CTxIn& txin = merged_psbtx.tx.vin[i];\n+\n+        // Find the utxo from one of the psbtxs\n+        CTxOut utxo;\n+        CTransactionRef non_witness_utxo = nullptr;\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // First find the non-witness utxo\n+            if (psbtx.inputs.at(i).non_witness_utxo) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n]) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n];\n+                    non_witness_utxo = psbtx.inputs.at(i).non_witness_utxo;\n+                }\n+            }\n+            // Now find the witness utxo if the non witness doesn't exist\n+            else if (!psbtx.inputs.at(i).witness_utxo.IsNull()) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).witness_utxo) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).witness_utxo;\n+                }\n+            }\n+            // If there is no nonwitness or witness utxo, the continue and see if it is in another psbt\n+            else {\n+                continue;\n+            }\n+        }\n+\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 327,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "af544a96fa3a74f960723d5c34f3b015e683ae57",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Because it's not RPC specific. It's cleaner to put the operations on the lowest level they can go.",
    "created_at": "2018-06-28T23:34:04Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199017650",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199017650"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199017650"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199017650/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1588,
    "side": "RIGHT",
    "in_reply_to_id": 199006165
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199037960",
    "pull_request_review_id": 133080543,
    "id": 199037960,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAzNzk2MA==",
    "diff_hunk": "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions",
    "path": "src/rpc/rawtransaction.cpp",
    "position": 322,
    "original_position": 101,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "af544a96fa3a74f960723d5c34f3b015e683ae57",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-06-29T02:24:01Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199037960",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199037960"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199037960"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199037960/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1370,
    "original_line": 1370,
    "side": "RIGHT",
    "in_reply_to_id": 199005299
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199037966",
    "pull_request_review_id": 133080551,
    "id": 199037966,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAzNzk2Ng==",
    "diff_hunk": "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 197,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "af544a96fa3a74f960723d5c34f3b015e683ae57",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-06-29T02:24:06Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199037966",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199037966"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199037966"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199037966/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1469,
    "side": "RIGHT",
    "in_reply_to_id": 199005647
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199037978",
    "pull_request_review_id": 133080568,
    "id": 199037978,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAzNzk3OA==",
    "diff_hunk": "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::vector<unsigned char> txData = DecodeBase64(txs[i].get_str().c_str());\n+        CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+        try {\n+            ssData >> psbtx;\n+            if (!ssData.empty()) {\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+            }\n+        } catch (const std::exception& e) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbtx(psbtxs[0]); // Copy the first one\n+    // Merge input data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vin.size(); ++i) {\n+        CTxIn& txin = merged_psbtx.tx.vin[i];\n+\n+        // Find the utxo from one of the psbtxs\n+        CTxOut utxo;\n+        CTransactionRef non_witness_utxo = nullptr;\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // First find the non-witness utxo\n+            if (psbtx.inputs.at(i).non_witness_utxo) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n]) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n];\n+                    non_witness_utxo = psbtx.inputs.at(i).non_witness_utxo;\n+                }\n+            }\n+            // Now find the witness utxo if the non witness doesn't exist\n+            else if (!psbtx.inputs.at(i).witness_utxo.IsNull()) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).witness_utxo) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).witness_utxo;\n+                }\n+            }\n+            // If there is no nonwitness or witness utxo, the continue and see if it is in another psbt\n+            else {\n+                continue;\n+            }\n+        }\n+\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 327,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "af544a96fa3a74f960723d5c34f3b015e683ae57",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-06-29T02:24:12Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199037978",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199037978"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199037978"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199037978/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1588,
    "side": "RIGHT",
    "in_reply_to_id": 199006165
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038045",
    "pull_request_review_id": 133080652,
    "id": 199038045,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAzODA0NQ==",
    "diff_hunk": "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::vector<unsigned char> txData = DecodeBase64(txs[i].get_str().c_str());\n+        CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+        try {\n+            ssData >> psbtx;\n+            if (!ssData.empty()) {\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+            }\n+        } catch (const std::exception& e) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbtx(psbtxs[0]); // Copy the first one\n+    // Merge input data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vin.size(); ++i) {\n+        CTxIn& txin = merged_psbtx.tx.vin[i];\n+\n+        // Find the utxo from one of the psbtxs",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 294,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "af544a96fa3a74f960723d5c34f3b015e683ae57",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I have refactored the merging stuff into a Merge() method for each PSBT struct. I also added a sanity checking method for each.",
    "created_at": "2018-06-29T02:24:57Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199038045",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038045"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199038045"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038045/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1555,
    "side": "RIGHT",
    "in_reply_to_id": 199006515
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038057",
    "pull_request_review_id": 133080663,
    "id": 199038057,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAzODA1Nw==",
    "diff_hunk": "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::vector<unsigned char> txData = DecodeBase64(txs[i].get_str().c_str());\n+        CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+        try {\n+            ssData >> psbtx;\n+            if (!ssData.empty()) {\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+            }\n+        } catch (const std::exception& e) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbtx(psbtxs[0]); // Copy the first one\n+    // Merge input data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vin.size(); ++i) {\n+        CTxIn& txin = merged_psbtx.tx.vin[i];\n+\n+        // Find the utxo from one of the psbtxs\n+        CTxOut utxo;\n+        CTransactionRef non_witness_utxo = nullptr;\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // First find the non-witness utxo\n+            if (psbtx.inputs.at(i).non_witness_utxo) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n]) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n];\n+                    non_witness_utxo = psbtx.inputs.at(i).non_witness_utxo;\n+                }\n+            }\n+            // Now find the witness utxo if the non witness doesn't exist\n+            else if (!psbtx.inputs.at(i).witness_utxo.IsNull()) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).witness_utxo) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).witness_utxo;\n+                }\n+            }\n+            // If there is no nonwitness or witness utxo, the continue and see if it is in another psbt\n+            else {\n+                continue;\n+            }\n+        }\n+\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.inputs.at(i).partial_sigs.insert(psbtx.inputs.at(i).partial_sigs.begin(), psbtx.inputs.at(i).partial_sigs.end());\n+            merged_psbtx.inputs.at(i).hd_keypaths.insert(psbtx.inputs.at(i).hd_keypaths.begin(), psbtx.inputs.at(i).hd_keypaths.end());\n+            merged_psbtx.inputs.at(i).unknown.insert(psbtx.inputs.at(i).unknown.begin(), psbtx.inputs.at(i).unknown.end());\n+            if (merged_psbtx.inputs.at(i).redeem_script.empty() && !psbtx.inputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.inputs.at(i).redeem_script = psbtx.inputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).witness_script.empty() && !psbtx.inputs.at(i).witness_script.empty()) {\n+                merged_psbtx.inputs.at(i).witness_script = psbtx.inputs.at(i).witness_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_sig.empty() && !psbtx.inputs.at(i).final_script_sig.empty()) {\n+                merged_psbtx.inputs.at(i).final_script_sig = psbtx.inputs.at(i).final_script_sig;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_witness.IsNull() && !psbtx.inputs.at(i).final_script_witness.IsNull()) {\n+                merged_psbtx.inputs.at(i).final_script_witness = psbtx.inputs.at(i).final_script_witness;\n+            }\n+        }\n+\n+        // Only do this if there was a utxo\n+        if (!utxo.IsNull()) {\n+            // Put the UTXO in the merged psbtx\n+            if (non_witness_utxo) {\n+                merged_psbtx.inputs.at(i).non_witness_utxo = non_witness_utxo;\n+            } else {\n+                merged_psbtx.inputs.at(i).witness_utxo = utxo;\n+            }\n+        }\n+    }\n+\n+    // Merge the output data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vout.size(); ++i) {\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.outputs.at(i).hd_keypaths.insert(psbtx.outputs.at(i).hd_keypaths.begin(), psbtx.outputs.at(i).hd_keypaths.end());\n+            merged_psbtx.outputs.at(i).unknown.insert(psbtx.outputs.at(i).unknown.begin(), psbtx.outputs.at(i).unknown.end());\n+            if (merged_psbtx.outputs.at(i).redeem_script.empty() && !psbtx.outputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.outputs.at(i).redeem_script = psbtx.outputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.outputs.at(i).witness_script.empty() && !psbtx.outputs.at(i).witness_script.empty()) {\n+                merged_psbtx.outputs.at(i).witness_script = psbtx.outputs.at(i).witness_script;\n+            }\n+        }\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"base64string\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"            (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded network transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded partially signed transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"base64string\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx.vin.size(); ++i) {\n+        CTxIn txin = psbtx.tx.vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // if this input has a final scriptsig or scriptwitness, don't do anything with it\n+        if (!input.final_script_sig.empty() || !input.final_script_witness.IsNull()) {\n+            continue;\n+        }\n+\n+        // Fill a SignatureData with input info\n+        SignatureData sigdata;\n+        input.FillSignatureData(sigdata);\n+\n+        // Get UTXO\n+        CTxOut utxo;\n+        if (input.non_witness_utxo) {\n+            utxo = input.non_witness_utxo->vout[txin.prevout.n];\n+        }\n+        // Now find the witness utxo if the non witness doesn't exist\n+        else if (!input.witness_utxo.IsNull()) {",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 439,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "af544a96fa3a74f960723d5c34f3b015e683ae57",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-06-29T02:25:03Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199038057",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038057"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199038057"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038057/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1700,
    "side": "RIGHT",
    "in_reply_to_id": 199006766
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038063",
    "pull_request_review_id": 133080672,
    "id": 199038063,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAzODA2Mw==",
    "diff_hunk": "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 28,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "af544a96fa3a74f960723d5c34f3b015e683ae57",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Fixed",
    "created_at": "2018-06-29T02:25:09Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199038063",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038063"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199038063"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038063/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1289,
    "side": "RIGHT",
    "in_reply_to_id": 199009612
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038068",
    "pull_request_review_id": 133080683,
    "id": 199038068,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAzODA2OA==",
    "diff_hunk": "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 242,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "af544a96fa3a74f960723d5c34f3b015e683ae57",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-06-29T02:25:14Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199038068",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038068"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199038068"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038068/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1553,
    "side": "RIGHT",
    "in_reply_to_id": 199009777
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038075",
    "pull_request_review_id": 133080693,
    "id": 199038075,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAzODA3NQ==",
    "diff_hunk": "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::vector<unsigned char> txData = DecodeBase64(txs[i].get_str().c_str());\n+        CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+        try {\n+            ssData >> psbtx;\n+            if (!ssData.empty()) {\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+            }\n+        } catch (const std::exception& e) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbtx(psbtxs[0]); // Copy the first one\n+    // Merge input data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vin.size(); ++i) {\n+        CTxIn& txin = merged_psbtx.tx.vin[i];\n+\n+        // Find the utxo from one of the psbtxs\n+        CTxOut utxo;\n+        CTransactionRef non_witness_utxo = nullptr;\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // First find the non-witness utxo\n+            if (psbtx.inputs.at(i).non_witness_utxo) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n]) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n];\n+                    non_witness_utxo = psbtx.inputs.at(i).non_witness_utxo;\n+                }\n+            }\n+            // Now find the witness utxo if the non witness doesn't exist\n+            else if (!psbtx.inputs.at(i).witness_utxo.IsNull()) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).witness_utxo) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).witness_utxo;\n+                }\n+            }\n+            // If there is no nonwitness or witness utxo, the continue and see if it is in another psbt\n+            else {\n+                continue;\n+            }\n+        }\n+\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.inputs.at(i).partial_sigs.insert(psbtx.inputs.at(i).partial_sigs.begin(), psbtx.inputs.at(i).partial_sigs.end());\n+            merged_psbtx.inputs.at(i).hd_keypaths.insert(psbtx.inputs.at(i).hd_keypaths.begin(), psbtx.inputs.at(i).hd_keypaths.end());\n+            merged_psbtx.inputs.at(i).unknown.insert(psbtx.inputs.at(i).unknown.begin(), psbtx.inputs.at(i).unknown.end());\n+            if (merged_psbtx.inputs.at(i).redeem_script.empty() && !psbtx.inputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.inputs.at(i).redeem_script = psbtx.inputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).witness_script.empty() && !psbtx.inputs.at(i).witness_script.empty()) {\n+                merged_psbtx.inputs.at(i).witness_script = psbtx.inputs.at(i).witness_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_sig.empty() && !psbtx.inputs.at(i).final_script_sig.empty()) {\n+                merged_psbtx.inputs.at(i).final_script_sig = psbtx.inputs.at(i).final_script_sig;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_witness.IsNull() && !psbtx.inputs.at(i).final_script_witness.IsNull()) {\n+                merged_psbtx.inputs.at(i).final_script_witness = psbtx.inputs.at(i).final_script_witness;\n+            }\n+        }\n+\n+        // Only do this if there was a utxo\n+        if (!utxo.IsNull()) {\n+            // Put the UTXO in the merged psbtx\n+            if (non_witness_utxo) {\n+                merged_psbtx.inputs.at(i).non_witness_utxo = non_witness_utxo;\n+            } else {\n+                merged_psbtx.inputs.at(i).witness_utxo = utxo;\n+            }\n+        }\n+    }\n+\n+    // Merge the output data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vout.size(); ++i) {\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.outputs.at(i).hd_keypaths.insert(psbtx.outputs.at(i).hd_keypaths.begin(), psbtx.outputs.at(i).hd_keypaths.end());\n+            merged_psbtx.outputs.at(i).unknown.insert(psbtx.outputs.at(i).unknown.begin(), psbtx.outputs.at(i).unknown.end());\n+            if (merged_psbtx.outputs.at(i).redeem_script.empty() && !psbtx.outputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.outputs.at(i).redeem_script = psbtx.outputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.outputs.at(i).witness_script.empty() && !psbtx.outputs.at(i).witness_script.empty()) {\n+                merged_psbtx.outputs.at(i).witness_script = psbtx.outputs.at(i).witness_script;\n+            }\n+        }\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"base64string\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"            (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded network transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded partially signed transaction if extracted\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 394,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "af544a96fa3a74f960723d5c34f3b015e683ae57",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Fixed",
    "created_at": "2018-06-29T02:25:19Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199038075",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038075"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199038075"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038075/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1655,
    "side": "RIGHT",
    "in_reply_to_id": 199010254
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038094",
    "pull_request_review_id": 133080707,
    "id": 199038094,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAzODA5NA==",
    "diff_hunk": "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::vector<unsigned char> txData = DecodeBase64(txs[i].get_str().c_str());\n+        CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+        try {\n+            ssData >> psbtx;\n+            if (!ssData.empty()) {\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+            }\n+        } catch (const std::exception& e) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbtx(psbtxs[0]); // Copy the first one\n+    // Merge input data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vin.size(); ++i) {\n+        CTxIn& txin = merged_psbtx.tx.vin[i];\n+\n+        // Find the utxo from one of the psbtxs\n+        CTxOut utxo;\n+        CTransactionRef non_witness_utxo = nullptr;\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // First find the non-witness utxo\n+            if (psbtx.inputs.at(i).non_witness_utxo) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n]) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n];\n+                    non_witness_utxo = psbtx.inputs.at(i).non_witness_utxo;\n+                }\n+            }\n+            // Now find the witness utxo if the non witness doesn't exist\n+            else if (!psbtx.inputs.at(i).witness_utxo.IsNull()) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).witness_utxo) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).witness_utxo;\n+                }\n+            }\n+            // If there is no nonwitness or witness utxo, the continue and see if it is in another psbt\n+            else {\n+                continue;\n+            }\n+        }\n+\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.inputs.at(i).partial_sigs.insert(psbtx.inputs.at(i).partial_sigs.begin(), psbtx.inputs.at(i).partial_sigs.end());\n+            merged_psbtx.inputs.at(i).hd_keypaths.insert(psbtx.inputs.at(i).hd_keypaths.begin(), psbtx.inputs.at(i).hd_keypaths.end());\n+            merged_psbtx.inputs.at(i).unknown.insert(psbtx.inputs.at(i).unknown.begin(), psbtx.inputs.at(i).unknown.end());\n+            if (merged_psbtx.inputs.at(i).redeem_script.empty() && !psbtx.inputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.inputs.at(i).redeem_script = psbtx.inputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).witness_script.empty() && !psbtx.inputs.at(i).witness_script.empty()) {\n+                merged_psbtx.inputs.at(i).witness_script = psbtx.inputs.at(i).witness_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_sig.empty() && !psbtx.inputs.at(i).final_script_sig.empty()) {\n+                merged_psbtx.inputs.at(i).final_script_sig = psbtx.inputs.at(i).final_script_sig;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_witness.IsNull() && !psbtx.inputs.at(i).final_script_witness.IsNull()) {\n+                merged_psbtx.inputs.at(i).final_script_witness = psbtx.inputs.at(i).final_script_witness;\n+            }\n+        }\n+\n+        // Only do this if there was a utxo\n+        if (!utxo.IsNull()) {\n+            // Put the UTXO in the merged psbtx\n+            if (non_witness_utxo) {\n+                merged_psbtx.inputs.at(i).non_witness_utxo = non_witness_utxo;\n+            } else {\n+                merged_psbtx.inputs.at(i).witness_utxo = utxo;\n+            }\n+        }\n+    }\n+\n+    // Merge the output data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vout.size(); ++i) {\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.outputs.at(i).hd_keypaths.insert(psbtx.outputs.at(i).hd_keypaths.begin(), psbtx.outputs.at(i).hd_keypaths.end());\n+            merged_psbtx.outputs.at(i).unknown.insert(psbtx.outputs.at(i).unknown.begin(), psbtx.outputs.at(i).unknown.end());\n+            if (merged_psbtx.outputs.at(i).redeem_script.empty() && !psbtx.outputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.outputs.at(i).redeem_script = psbtx.outputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.outputs.at(i).witness_script.empty() && !psbtx.outputs.at(i).witness_script.empty()) {\n+                merged_psbtx.outputs.at(i).witness_script = psbtx.outputs.at(i).witness_script;\n+            }\n+        }\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"base64string\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"            (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded network transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded partially signed transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"base64string\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx.vin.size(); ++i) {\n+        CTxIn txin = psbtx.tx.vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // if this input has a final scriptsig or scriptwitness, don't do anything with it\n+        if (!input.final_script_sig.empty() || !input.final_script_witness.IsNull()) {\n+            continue;\n+        }\n+\n+        // Fill a SignatureData with input info",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 429,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "af544a96fa3a74f960723d5c34f3b015e683ae57",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-06-29T02:25:27Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199038094",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038094"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199038094"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038094/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1690,
    "side": "RIGHT",
    "in_reply_to_id": 199010547
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038105",
    "pull_request_review_id": 133080722,
    "id": 199038105,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAzODEwNQ==",
    "diff_hunk": "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::vector<unsigned char> txData = DecodeBase64(txs[i].get_str().c_str());\n+        CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+        try {\n+            ssData >> psbtx;\n+            if (!ssData.empty()) {\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+            }\n+        } catch (const std::exception& e) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbtx(psbtxs[0]); // Copy the first one\n+    // Merge input data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vin.size(); ++i) {\n+        CTxIn& txin = merged_psbtx.tx.vin[i];\n+\n+        // Find the utxo from one of the psbtxs\n+        CTxOut utxo;\n+        CTransactionRef non_witness_utxo = nullptr;\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // First find the non-witness utxo\n+            if (psbtx.inputs.at(i).non_witness_utxo) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n]) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n];\n+                    non_witness_utxo = psbtx.inputs.at(i).non_witness_utxo;\n+                }\n+            }\n+            // Now find the witness utxo if the non witness doesn't exist\n+            else if (!psbtx.inputs.at(i).witness_utxo.IsNull()) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).witness_utxo) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).witness_utxo;\n+                }\n+            }\n+            // If there is no nonwitness or witness utxo, the continue and see if it is in another psbt\n+            else {\n+                continue;\n+            }\n+        }\n+\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.inputs.at(i).partial_sigs.insert(psbtx.inputs.at(i).partial_sigs.begin(), psbtx.inputs.at(i).partial_sigs.end());\n+            merged_psbtx.inputs.at(i).hd_keypaths.insert(psbtx.inputs.at(i).hd_keypaths.begin(), psbtx.inputs.at(i).hd_keypaths.end());\n+            merged_psbtx.inputs.at(i).unknown.insert(psbtx.inputs.at(i).unknown.begin(), psbtx.inputs.at(i).unknown.end());\n+            if (merged_psbtx.inputs.at(i).redeem_script.empty() && !psbtx.inputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.inputs.at(i).redeem_script = psbtx.inputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).witness_script.empty() && !psbtx.inputs.at(i).witness_script.empty()) {\n+                merged_psbtx.inputs.at(i).witness_script = psbtx.inputs.at(i).witness_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_sig.empty() && !psbtx.inputs.at(i).final_script_sig.empty()) {\n+                merged_psbtx.inputs.at(i).final_script_sig = psbtx.inputs.at(i).final_script_sig;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_witness.IsNull() && !psbtx.inputs.at(i).final_script_witness.IsNull()) {\n+                merged_psbtx.inputs.at(i).final_script_witness = psbtx.inputs.at(i).final_script_witness;\n+            }\n+        }\n+\n+        // Only do this if there was a utxo\n+        if (!utxo.IsNull()) {\n+            // Put the UTXO in the merged psbtx\n+            if (non_witness_utxo) {\n+                merged_psbtx.inputs.at(i).non_witness_utxo = non_witness_utxo;\n+            } else {\n+                merged_psbtx.inputs.at(i).witness_utxo = utxo;\n+            }\n+        }\n+    }\n+\n+    // Merge the output data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vout.size(); ++i) {\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.outputs.at(i).hd_keypaths.insert(psbtx.outputs.at(i).hd_keypaths.begin(), psbtx.outputs.at(i).hd_keypaths.end());\n+            merged_psbtx.outputs.at(i).unknown.insert(psbtx.outputs.at(i).unknown.begin(), psbtx.outputs.at(i).unknown.end());\n+            if (merged_psbtx.outputs.at(i).redeem_script.empty() && !psbtx.outputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.outputs.at(i).redeem_script = psbtx.outputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.outputs.at(i).witness_script.empty() && !psbtx.outputs.at(i).witness_script.empty()) {\n+                merged_psbtx.outputs.at(i).witness_script = psbtx.outputs.at(i).witness_script;\n+            }\n+        }\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"base64string\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"            (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded network transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded partially signed transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"base64string\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx.vin.size(); ++i) {\n+        CTxIn txin = psbtx.tx.vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // if this input has a final scriptsig or scriptwitness, don't do anything with it\n+        if (!input.final_script_sig.empty() || !input.final_script_witness.IsNull()) {\n+            continue;\n+        }\n+\n+        // Fill a SignatureData with input info\n+        SignatureData sigdata;\n+        input.FillSignatureData(sigdata);\n+\n+        // Get UTXO\n+        CTxOut utxo;\n+        if (input.non_witness_utxo) {\n+            utxo = input.non_witness_utxo->vout[txin.prevout.n];\n+        }\n+        // Now find the witness utxo if the non witness doesn't exist\n+        else if (!input.witness_utxo.IsNull()) {\n+            utxo = input.witness_utxo;\n+        }\n+        // No UTXO, don't do anything\n+        else {\n+            continue;\n+        }\n+\n+        MutableTransactionSignatureCreator creator(&psbtx.tx, i, utxo.nValue, 1);\n+        bool sig_complete = ProduceSignature(DUMMY_SIGNING_PROVIDER, creator, utxo.scriptPubKey, sigdata);\n+        input.FromSignatureData(sigdata);\n+        complete &= sig_complete;\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\n+    if (complete && extract) {\n+        CMutableTransaction mtx(psbtx.tx);\n+        for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+            mtx.vin[i].scriptSig = psbtx.inputs[i].final_script_sig;\n+            mtx.vin[i].scriptWitness = psbtx.inputs[i].final_script_witness;\n+        }\n+        ssTx << mtx;\n+        result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n+    } else {\n+        ssTx << psbtx;\n+        result.push_back(Pair(\"base64\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size())));\n+    }\n+    result.push_back(Pair(\"complete\", complete));\n+\n+    return result;\n+}\n+\n+UniValue createpsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n+        throw std::runtime_error(\n+                            \"createpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable )\\n\"\n+                            \"\\nCreates and funds a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 478,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "af544a96fa3a74f960723d5c34f3b015e683ae57",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-06-29T02:25:34Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199038105",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038105"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199038105"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038105/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1739,
    "side": "RIGHT",
    "in_reply_to_id": 199010700
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038146",
    "pull_request_review_id": 133080779,
    "id": 199038146,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAzODE0Ng==",
    "diff_hunk": "@@ -91,6 +91,15 @@ class base_blob\n                ((uint64_t)ptr[7]) << 56;\n     }\n \n+    uint32_t GetUint32LE(int pos) const",
    "path": "src/uint256.h",
    "position": null,
    "original_position": 4,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "ed7a484d92034e79b753c9594c2b099d3be959f4",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-06-29T02:26:02Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199038146",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038146"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199038146"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038146/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 94,
    "side": "RIGHT",
    "in_reply_to_id": 199012847
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038156",
    "pull_request_review_id": 133080790,
    "id": 199038156,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAzODE1Ng==",
    "diff_hunk": "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::vector<unsigned char> txData = DecodeBase64(txs[i].get_str().c_str());\n+        CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+        try {\n+            ssData >> psbtx;\n+            if (!ssData.empty()) {\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+            }\n+        } catch (const std::exception& e) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbtx(psbtxs[0]); // Copy the first one\n+    // Merge input data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vin.size(); ++i) {\n+        CTxIn& txin = merged_psbtx.tx.vin[i];\n+\n+        // Find the utxo from one of the psbtxs\n+        CTxOut utxo;\n+        CTransactionRef non_witness_utxo = nullptr;\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // First find the non-witness utxo\n+            if (psbtx.inputs.at(i).non_witness_utxo) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n]) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n];\n+                    non_witness_utxo = psbtx.inputs.at(i).non_witness_utxo;\n+                }\n+            }\n+            // Now find the witness utxo if the non witness doesn't exist\n+            else if (!psbtx.inputs.at(i).witness_utxo.IsNull()) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).witness_utxo) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).witness_utxo;\n+                }\n+            }\n+            // If there is no nonwitness or witness utxo, the continue and see if it is in another psbt\n+            else {\n+                continue;\n+            }\n+        }\n+\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.inputs.at(i).partial_sigs.insert(psbtx.inputs.at(i).partial_sigs.begin(), psbtx.inputs.at(i).partial_sigs.end());\n+            merged_psbtx.inputs.at(i).hd_keypaths.insert(psbtx.inputs.at(i).hd_keypaths.begin(), psbtx.inputs.at(i).hd_keypaths.end());\n+            merged_psbtx.inputs.at(i).unknown.insert(psbtx.inputs.at(i).unknown.begin(), psbtx.inputs.at(i).unknown.end());\n+            if (merged_psbtx.inputs.at(i).redeem_script.empty() && !psbtx.inputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.inputs.at(i).redeem_script = psbtx.inputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).witness_script.empty() && !psbtx.inputs.at(i).witness_script.empty()) {\n+                merged_psbtx.inputs.at(i).witness_script = psbtx.inputs.at(i).witness_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_sig.empty() && !psbtx.inputs.at(i).final_script_sig.empty()) {\n+                merged_psbtx.inputs.at(i).final_script_sig = psbtx.inputs.at(i).final_script_sig;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_witness.IsNull() && !psbtx.inputs.at(i).final_script_witness.IsNull()) {\n+                merged_psbtx.inputs.at(i).final_script_witness = psbtx.inputs.at(i).final_script_witness;\n+            }\n+        }\n+\n+        // Only do this if there was a utxo\n+        if (!utxo.IsNull()) {\n+            // Put the UTXO in the merged psbtx\n+            if (non_witness_utxo) {\n+                merged_psbtx.inputs.at(i).non_witness_utxo = non_witness_utxo;\n+            } else {\n+                merged_psbtx.inputs.at(i).witness_utxo = utxo;\n+            }\n+        }\n+    }\n+\n+    // Merge the output data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vout.size(); ++i) {\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.outputs.at(i).hd_keypaths.insert(psbtx.outputs.at(i).hd_keypaths.begin(), psbtx.outputs.at(i).hd_keypaths.end());\n+            merged_psbtx.outputs.at(i).unknown.insert(psbtx.outputs.at(i).unknown.begin(), psbtx.outputs.at(i).unknown.end());\n+            if (merged_psbtx.outputs.at(i).redeem_script.empty() && !psbtx.outputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.outputs.at(i).redeem_script = psbtx.outputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.outputs.at(i).witness_script.empty() && !psbtx.outputs.at(i).witness_script.empty()) {\n+                merged_psbtx.outputs.at(i).witness_script = psbtx.outputs.at(i).witness_script;\n+            }\n+        }\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"base64string\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"            (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded network transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded partially signed transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"base64string\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx.vin.size(); ++i) {\n+        CTxIn txin = psbtx.tx.vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // if this input has a final scriptsig or scriptwitness, don't do anything with it\n+        if (!input.final_script_sig.empty() || !input.final_script_witness.IsNull()) {\n+            continue;\n+        }\n+\n+        // Fill a SignatureData with input info\n+        SignatureData sigdata;\n+        input.FillSignatureData(sigdata);\n+\n+        // Get UTXO\n+        CTxOut utxo;\n+        if (input.non_witness_utxo) {\n+            utxo = input.non_witness_utxo->vout[txin.prevout.n];\n+        }\n+        // Now find the witness utxo if the non witness doesn't exist\n+        else if (!input.witness_utxo.IsNull()) {\n+            utxo = input.witness_utxo;\n+        }\n+        // No UTXO, don't do anything\n+        else {\n+            continue;\n+        }\n+\n+        MutableTransactionSignatureCreator creator(&psbtx.tx, i, utxo.nValue, 1);\n+        bool sig_complete = ProduceSignature(DUMMY_SIGNING_PROVIDER, creator, utxo.scriptPubKey, sigdata);\n+        input.FromSignatureData(sigdata);\n+        complete &= sig_complete;\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\n+    if (complete && extract) {\n+        CMutableTransaction mtx(psbtx.tx);\n+        for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+            mtx.vin[i].scriptSig = psbtx.inputs[i].final_script_sig;\n+            mtx.vin[i].scriptWitness = psbtx.inputs[i].final_script_witness;\n+        }\n+        ssTx << mtx;\n+        result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n+    } else {\n+        ssTx << psbtx;\n+        result.push_back(Pair(\"base64\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size())));\n+    }\n+    result.push_back(Pair(\"complete\", complete));\n+\n+    return result;\n+}\n+\n+UniValue createpsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n+        throw std::runtime_error(\n+                            \"createpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable )\\n\"\n+                            \"\\nCreates and funds a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"inputs\\\"                (array, required) A json array of json objects\\n\"\n+                            \"     [\\n\"\n+                            \"       {\\n\"\n+                            \"         \\\"txid\\\":\\\"id\\\",      (string, required) The transaction id\\n\"\n+                            \"         \\\"vout\\\":n,         (numeric, required) The output number\\n\"\n+                            \"         \\\"sequence\\\":n      (numeric, optional) The sequence number\\n\"\n+                            \"       } \\n\"\n+                            \"       ,...\\n\"\n+                            \"     ]\\n\"\n+                            \"2. \\\"outputs\\\"               (array, required) a json array with outputs (key-value pairs)\\n\"\n+                            \"   [\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"address\\\": x.xxx,    (obj, optional) A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\\n\"\n+                            \"    },\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"data\\\": \\\"hex\\\"        (obj, optional) A key-value pair. The key must be \\\"data\\\", the value is hex encoded data\\n\"\n+                            \"    }\\n\"\n+                            \"    ,...                     More key-value pairs of the above form. For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n+                            \"                             accepted as second parameter.\\n\"\n+                            \"   ]\\n\"\n+                            \"3. locktime                  (numeric, optional, default=0) Raw locktime. Non-0 value also locktime-activates inputs\\n\"\n+                            \"4. replaceable               (boolean, optional, default=false) Marks this transaction as BIP125 replaceable.\\n\"\n+                            \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"base64\\\": \\\"value\\\",      (string)  The resulting raw transaction (base64-encoded string)\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"createpsbt\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")\n+                            );\n+\n+\n+    RPCTypeCheck(request.params, {\n+        UniValue::VARR,\n+        UniValueType(), // ARR or OBJ, checked later\n+        UniValue::VNUM,\n+        UniValue::VBOOL,\n+        }, true\n+    );\n+\n+    CMutableTransaction rawTx = ConstructTransaction(request.params[0], request.params[1], request.params[2], request.params[3]);\n+\n+    // Make a blank psbt\n+    PartiallySignedTransaction psbtx;\n+    psbtx.tx = rawTx;\n+    for (unsigned int i = 0; i < rawTx.vin.size(); ++i) {\n+        psbtx.inputs.push_back(PSBTInput());\n+    }\n+    for (unsigned int i = 0; i < rawTx.vout.size(); ++i) {\n+        psbtx.outputs.push_back(PSBTOutput());\n+    }\n+\n+    // Serialize the PSBT\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue converttopsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+                            \"converttopsbt \\\"hexstring\\\" ( permitsigdata iswitness )\\n\"\n+                            \"\\nConverts a network serialized transaction to a PSBT.\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 542,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "af544a96fa3a74f960723d5c34f3b015e683ae57",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-06-29T02:26:08Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199038156",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038156"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199038156"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038156/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1803,
    "side": "RIGHT",
    "in_reply_to_id": 199013256
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199065136",
    "pull_request_review_id": 133111552,
    "id": 199065136,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTA2NTEzNg==",
    "diff_hunk": "@@ -235,6 +235,36 @@ bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreato\n     return sigdata.complete;\n }\n \n+bool SignPSBTInput(const SigningProvider& provider, const CTxIn& txin, const CMutableTransaction& tx, PSBTInput& input, SignatureData& sigdata, int index, int sighash, bool sign)",
    "path": "src/script/sign.cpp",
    "position": null,
    "original_position": 4,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "c751edcff5121d9fff63bd5d65f948e20a1c5775",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "No need to pass `txin`; it's always equal to `tx.vin[index]` I think.",
    "created_at": "2018-06-29T06:37:29Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199065136",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199065136"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199065136"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199065136/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 238,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199065265",
    "pull_request_review_id": 133111552,
    "id": 199065265,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTA2NTI2NQ==",
    "diff_hunk": "@@ -235,6 +235,36 @@ bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreato\n     return sigdata.complete;\n }\n \n+bool SignPSBTInput(const SigningProvider& provider, const CTxIn& txin, const CMutableTransaction& tx, PSBTInput& input, SignatureData& sigdata, int index, int sighash, bool sign)\n+{\n+    // if this input has a final scriptsig or scriptwitness, don't do anything with it\n+    if (!input.final_script_sig.empty() || !input.final_script_witness.IsNull()) {\n+        return true;\n+    }\n+\n+    // Fill SignatureData with input info\n+    input.FillSignatureData(sigdata);\n+\n+    // Get UTXO\n+    CTxOut utxo;\n+    if (input.non_witness_utxo) {\n+        utxo = input.non_witness_utxo->vout[txin.prevout.n];\n+    }\n+    // Now find the witness utxo if the non witness doesn't exist\n+    else if (!input.witness_utxo.IsNull()) {",
    "path": "src/script/sign.cpp",
    "position": null,
    "original_position": 20,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "c751edcff5121d9fff63bd5d65f948e20a1c5775",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Nit: else on the same line as `}`.",
    "created_at": "2018-06-29T06:37:58Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199065265",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199065265"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199065265"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199065265/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 254,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199066062",
    "pull_request_review_id": 133111552,
    "id": 199066062,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTA2NjA2Mg==",
    "diff_hunk": "@@ -4388,6 +4391,333 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool parse_hd_keypath(std::string keypath_str, std::vector<uint32_t>& keypath)",
    "path": "src/wallet/rpcwallet.cpp",
    "position": null,
    "original_position": 238,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Nit: function naming style",
    "created_at": "2018-06-29T06:41:26Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199066062",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199066062"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199066062"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199066062/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4394,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199066104",
    "pull_request_review_id": 133111552,
    "id": 199066104,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTA2NjEwNA==",
    "diff_hunk": "@@ -4388,6 +4391,333 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool parse_hd_keypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void add_keypath_to_map(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)",
    "path": "src/wallet/rpcwallet.cpp",
    "position": null,
    "original_position": 277,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Nit: function naming style",
    "created_at": "2018-06-29T06:41:38Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199066104",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199066104"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199066104"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199066104/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4433,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199066556",
    "pull_request_review_id": 133111552,
    "id": 199066556,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTA2NjU1Ng==",
    "diff_hunk": "@@ -4388,6 +4391,333 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool parse_hd_keypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void add_keypath_to_map(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n+        return;\n+    }\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    std::vector<uint32_t> keypath;\n+    if (!meta.hdKeypath.empty()) {\n+        if (!parse_hd_keypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), ReadLE32(masterKey.key.GetPubKey().GetID().begin()));\n+    }\n+    // Single pubkeys get the master fingerprint of themselves\n+    else {\n+        keypath.insert(keypath.begin(), ReadLE32(vchPubKey.GetID().begin()));\n+    }\n+    hd_keypaths.emplace(vchPubKey, keypath);\n+}\n+\n+bool fill_psbt(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type, bool sign)",
    "path": "src/wallet/rpcwallet.cpp",
    "position": null,
    "original_position": 308,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Nit: function naming style",
    "created_at": "2018-06-29T06:43:40Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199066556",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199066556"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199066556"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199066556/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4464,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199241206",
    "pull_request_review_id": 133328329,
    "id": 199241206,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTI0MTIwNg==",
    "diff_hunk": "@@ -235,6 +235,36 @@ bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreato\n     return sigdata.complete;\n }\n \n+bool SignPSBTInput(const SigningProvider& provider, const CTxIn& txin, const CMutableTransaction& tx, PSBTInput& input, SignatureData& sigdata, int index, int sighash, bool sign)",
    "path": "src/script/sign.cpp",
    "position": null,
    "original_position": 4,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "c751edcff5121d9fff63bd5d65f948e20a1c5775",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-06-29T18:15:38Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199241206",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199241206"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199241206"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199241206/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 238,
    "side": "RIGHT",
    "in_reply_to_id": 199065136
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199241256",
    "pull_request_review_id": 133328380,
    "id": 199241256,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTI0MTI1Ng==",
    "diff_hunk": "@@ -235,6 +235,36 @@ bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreato\n     return sigdata.complete;\n }\n \n+bool SignPSBTInput(const SigningProvider& provider, const CTxIn& txin, const CMutableTransaction& tx, PSBTInput& input, SignatureData& sigdata, int index, int sighash, bool sign)\n+{\n+    // if this input has a final scriptsig or scriptwitness, don't do anything with it\n+    if (!input.final_script_sig.empty() || !input.final_script_witness.IsNull()) {\n+        return true;\n+    }\n+\n+    // Fill SignatureData with input info\n+    input.FillSignatureData(sigdata);\n+\n+    // Get UTXO\n+    CTxOut utxo;\n+    if (input.non_witness_utxo) {\n+        utxo = input.non_witness_utxo->vout[txin.prevout.n];\n+    }\n+    // Now find the witness utxo if the non witness doesn't exist\n+    else if (!input.witness_utxo.IsNull()) {",
    "path": "src/script/sign.cpp",
    "position": null,
    "original_position": 20,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "c751edcff5121d9fff63bd5d65f948e20a1c5775",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Fixed",
    "created_at": "2018-06-29T18:15:45Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199241256",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199241256"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199241256"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199241256/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 254,
    "side": "RIGHT",
    "in_reply_to_id": 199065265
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199241287",
    "pull_request_review_id": 133328419,
    "id": 199241287,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTI0MTI4Nw==",
    "diff_hunk": "@@ -4388,6 +4391,333 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool parse_hd_keypath(std::string keypath_str, std::vector<uint32_t>& keypath)",
    "path": "src/wallet/rpcwallet.cpp",
    "position": null,
    "original_position": 238,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Fixed",
    "created_at": "2018-06-29T18:15:50Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199241287",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199241287"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199241287"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199241287/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4394,
    "side": "RIGHT",
    "in_reply_to_id": 199066062
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199241307",
    "pull_request_review_id": 133328445,
    "id": 199241307,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTI0MTMwNw==",
    "diff_hunk": "@@ -4388,6 +4391,333 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool parse_hd_keypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void add_keypath_to_map(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)",
    "path": "src/wallet/rpcwallet.cpp",
    "position": null,
    "original_position": 277,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Fixed",
    "created_at": "2018-06-29T18:15:56Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199241307",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199241307"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199241307"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199241307/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4433,
    "side": "RIGHT",
    "in_reply_to_id": 199066104
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199241346",
    "pull_request_review_id": 133328502,
    "id": 199241346,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTI0MTM0Ng==",
    "diff_hunk": "@@ -4388,6 +4391,333 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool parse_hd_keypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void add_keypath_to_map(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n+        return;\n+    }\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    std::vector<uint32_t> keypath;\n+    if (!meta.hdKeypath.empty()) {\n+        if (!parse_hd_keypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), ReadLE32(masterKey.key.GetPubKey().GetID().begin()));\n+    }\n+    // Single pubkeys get the master fingerprint of themselves\n+    else {\n+        keypath.insert(keypath.begin(), ReadLE32(vchPubKey.GetID().begin()));\n+    }\n+    hd_keypaths.emplace(vchPubKey, keypath);\n+}\n+\n+bool fill_psbt(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type, bool sign)",
    "path": "src/wallet/rpcwallet.cpp",
    "position": null,
    "original_position": 308,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Fixed",
    "created_at": "2018-06-29T18:16:05Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199241346",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199241346"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199241346"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199241346/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4464,
    "side": "RIGHT",
    "in_reply_to_id": 199066556
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199306583",
    "pull_request_review_id": 133408214,
    "id": 199306583,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMwNjU4Mw==",
    "diff_hunk": "@@ -73,6 +76,562 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+// Magic bytes\n+static constexpr uint8_t PSBT_MAGIC_BYTES[4] = {'p', 's', 'b', 't'};\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static constexpr uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+template<typename Stream>\n+void DeserializeHDKeypaths(Stream& s, const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    // Make sure that the key is the size of pubkey + 1\n+    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+    }\n+    // Read in the pubkey from key\n+    CPubKey pubkey(key.begin() + 1, key.end());\n+    if (!pubkey.IsFullyValid()) {\n+       throw std::ios_base::failure(\"Invalid pubkey\");\n+    }\n+    if (hd_keypaths.count(pubkey) > 0) {\n+        throw std::ios_base::failure(\"Duplicate Key, pubkey derivation path already provided\");\n+    }\n+\n+    // Read in key path\n+    uint64_t value_len = ReadCompactSize(s);\n+    std::vector<uint32_t> keypath;\n+    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+        uint32_t index;\n+        s >> index;\n+        keypath.push_back(index);\n+    }\n+\n+    // Add to map\n+    hd_keypaths.emplace(pubkey, keypath);\n+}\n+\n+// Serialize HD keypaths to a stream from a map\n+template<typename Stream>\n+void SerializeHDKeypaths(Stream& s, const std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, uint8_t type)\n+{\n+    for (auto keypath_pair : hd_keypaths) {\n+        SerializeToVector(s, type, MakeSpan(keypath_pair.first));\n+        WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+        for (auto& path : keypath_pair.second) {\n+            s << path;\n+        }\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PSBTInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PSBTInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            SerializeHDKeypaths(s, hd_keypaths, PSBT_IN_BIP32_DERIVATION);\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 191,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "48f2cf53eacd5a26d6b7ae04d15254d4b0ecd38a",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This section (up to `s >> MakeSpan(key)`) can be written more concisely as:\r\n\r\n```\r\nstd::vector<unsigned char> key;\r\ns >> key;\r\nif (key.empty()) return;\r\n```\r\n",
    "created_at": "2018-06-30T00:34:06Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199306583",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199306583"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199306583"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199306583/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 255,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199306849",
    "pull_request_review_id": 133408214,
    "id": 199306849,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMwNjg0OQ==",
    "diff_hunk": "@@ -73,6 +76,562 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+// Magic bytes\n+static constexpr uint8_t PSBT_MAGIC_BYTES[4] = {'p', 's', 'b', 't'};\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static constexpr uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+template<typename Stream>\n+void DeserializeHDKeypaths(Stream& s, const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    // Make sure that the key is the size of pubkey + 1\n+    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+    }\n+    // Read in the pubkey from key\n+    CPubKey pubkey(key.begin() + 1, key.end());\n+    if (!pubkey.IsFullyValid()) {\n+       throw std::ios_base::failure(\"Invalid pubkey\");\n+    }\n+    if (hd_keypaths.count(pubkey) > 0) {\n+        throw std::ios_base::failure(\"Duplicate Key, pubkey derivation path already provided\");\n+    }\n+\n+    // Read in key path\n+    uint64_t value_len = ReadCompactSize(s);\n+    std::vector<uint32_t> keypath;\n+    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+        uint32_t index;\n+        s >> index;\n+        keypath.push_back(index);\n+    }\n+\n+    // Add to map\n+    hd_keypaths.emplace(pubkey, keypath);\n+}\n+\n+// Serialize HD keypaths to a stream from a map\n+template<typename Stream>\n+void SerializeHDKeypaths(Stream& s, const std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, uint8_t type)\n+{\n+    for (auto keypath_pair : hd_keypaths) {\n+        SerializeToVector(s, type, MakeSpan(keypath_pair.first));\n+        WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+        for (auto& path : keypath_pair.second) {\n+            s << path;\n+        }\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PSBTInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PSBTInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            SerializeHDKeypaths(s, hd_keypaths, PSBT_IN_BIP32_DERIVATION);\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    if (!witness_utxo.IsNull()) {",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 214,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "48f2cf53eacd5a26d6b7ae04d15254d4b0ecd38a",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I guess this is now done by the `IsSane()` function, and doesn't need to be repeated here?",
    "created_at": "2018-06-30T00:39:29Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199306849",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199306849"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199306849"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199306849/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 278,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199306860",
    "pull_request_review_id": 133408214,
    "id": 199306860,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMwNjg2MA==",
    "diff_hunk": "@@ -73,6 +76,562 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+// Magic bytes\n+static constexpr uint8_t PSBT_MAGIC_BYTES[4] = {'p', 's', 'b', 't'};\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static constexpr uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+template<typename Stream>\n+void DeserializeHDKeypaths(Stream& s, const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    // Make sure that the key is the size of pubkey + 1\n+    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+    }\n+    // Read in the pubkey from key\n+    CPubKey pubkey(key.begin() + 1, key.end());\n+    if (!pubkey.IsFullyValid()) {\n+       throw std::ios_base::failure(\"Invalid pubkey\");\n+    }\n+    if (hd_keypaths.count(pubkey) > 0) {\n+        throw std::ios_base::failure(\"Duplicate Key, pubkey derivation path already provided\");\n+    }\n+\n+    // Read in key path\n+    uint64_t value_len = ReadCompactSize(s);\n+    std::vector<uint32_t> keypath;\n+    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+        uint32_t index;\n+        s >> index;\n+        keypath.push_back(index);\n+    }\n+\n+    // Add to map\n+    hd_keypaths.emplace(pubkey, keypath);\n+}\n+\n+// Serialize HD keypaths to a stream from a map\n+template<typename Stream>\n+void SerializeHDKeypaths(Stream& s, const std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, uint8_t type)\n+{\n+    for (auto keypath_pair : hd_keypaths) {\n+        SerializeToVector(s, type, MakeSpan(keypath_pair.first));\n+        WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+        for (auto& path : keypath_pair.second) {\n+            s << path;\n+        }\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PSBTInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PSBTInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            SerializeHDKeypaths(s, hd_keypaths, PSBT_IN_BIP32_DERIVATION);\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"A Witness utxo was already provided, cannot provide a non-witness utxo\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"A non-witness utxo was already provided, cannot provide a witness utxo\");",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 224,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "48f2cf53eacd5a26d6b7ae04d15254d4b0ecd38a",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Same thing here.",
    "created_at": "2018-06-30T00:39:40Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199306860",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199306860"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199306860"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199306860/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 288,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199306899",
    "pull_request_review_id": 133408214,
    "id": 199306899,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMwNjg5OQ==",
    "diff_hunk": "@@ -73,6 +76,562 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+// Magic bytes\n+static constexpr uint8_t PSBT_MAGIC_BYTES[4] = {'p', 's', 'b', 't'};\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static constexpr uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+template<typename Stream>\n+void DeserializeHDKeypaths(Stream& s, const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    // Make sure that the key is the size of pubkey + 1\n+    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+    }\n+    // Read in the pubkey from key\n+    CPubKey pubkey(key.begin() + 1, key.end());\n+    if (!pubkey.IsFullyValid()) {\n+       throw std::ios_base::failure(\"Invalid pubkey\");\n+    }\n+    if (hd_keypaths.count(pubkey) > 0) {\n+        throw std::ios_base::failure(\"Duplicate Key, pubkey derivation path already provided\");\n+    }\n+\n+    // Read in key path\n+    uint64_t value_len = ReadCompactSize(s);\n+    std::vector<uint32_t> keypath;\n+    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+        uint32_t index;\n+        s >> index;\n+        keypath.push_back(index);\n+    }\n+\n+    // Add to map\n+    hd_keypaths.emplace(pubkey, keypath);\n+}\n+\n+// Serialize HD keypaths to a stream from a map\n+template<typename Stream>\n+void SerializeHDKeypaths(Stream& s, const std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, uint8_t type)\n+{\n+    for (auto keypath_pair : hd_keypaths) {\n+        SerializeToVector(s, type, MakeSpan(keypath_pair.first));\n+        WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+        for (auto& path : keypath_pair.second) {\n+            s << path;\n+        }\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PSBTInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PSBTInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            SerializeHDKeypaths(s, hd_keypaths, PSBT_IN_BIP32_DERIVATION);\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"A Witness utxo was already provided, cannot provide a non-witness utxo\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"A non-witness utxo was already provided, cannot provide a witness utxo\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    std::vector<unsigned char> sig;\n+                    s >> sig;\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 248,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "48f2cf53eacd5a26d6b7ae04d15254d4b0ecd38a",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Can be `std::move(sig)`.",
    "created_at": "2018-06-30T00:40:27Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199306899",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199306899"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199306899"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199306899/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 312,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199307069",
    "pull_request_review_id": 133408214,
    "id": 199307069,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMwNzA2OQ==",
    "diff_hunk": "@@ -73,6 +76,562 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+// Magic bytes\n+static constexpr uint8_t PSBT_MAGIC_BYTES[4] = {'p', 's', 'b', 't'};\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static constexpr uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+template<typename Stream>\n+void DeserializeHDKeypaths(Stream& s, const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    // Make sure that the key is the size of pubkey + 1\n+    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+    }\n+    // Read in the pubkey from key\n+    CPubKey pubkey(key.begin() + 1, key.end());\n+    if (!pubkey.IsFullyValid()) {\n+       throw std::ios_base::failure(\"Invalid pubkey\");\n+    }\n+    if (hd_keypaths.count(pubkey) > 0) {\n+        throw std::ios_base::failure(\"Duplicate Key, pubkey derivation path already provided\");\n+    }\n+\n+    // Read in key path\n+    uint64_t value_len = ReadCompactSize(s);\n+    std::vector<uint32_t> keypath;\n+    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+        uint32_t index;\n+        s >> index;\n+        keypath.push_back(index);\n+    }\n+\n+    // Add to map\n+    hd_keypaths.emplace(pubkey, keypath);\n+}\n+\n+// Serialize HD keypaths to a stream from a map\n+template<typename Stream>\n+void SerializeHDKeypaths(Stream& s, const std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, uint8_t type)\n+{\n+    for (auto keypath_pair : hd_keypaths) {\n+        SerializeToVector(s, type, MakeSpan(keypath_pair.first));\n+        WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+        for (auto& path : keypath_pair.second) {\n+            s << path;\n+        }\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PSBTInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PSBTInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            SerializeHDKeypaths(s, hd_keypaths, PSBT_IN_BIP32_DERIVATION);\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"A Witness utxo was already provided, cannot provide a non-witness utxo\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"A non-witness utxo was already provided, cannot provide a witness utxo\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    std::vector<unsigned char> sig;\n+                    s >> sig;\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    DeserializeHDKeypaths(s, key, hd_keypaths);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    std::vector<unsigned char> val_bytes;\n+                    s >> val_bytes;\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PSBTInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput\n+{\n+    CScript redeem_script;\n+    CScript witness_script;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    PSBTOutput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the redeem script\n+        if (!redeem_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_REDEEMSCRIPT);\n+            s << redeem_script;\n+        }\n+\n+        // Write the witness script\n+        if (!witness_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_WITNESSSCRIPT);\n+            s << witness_script;\n+        }\n+\n+        // Write any hd keypaths\n+        SerializeHDKeypaths(s, hd_keypaths, PSBT_OUT_BIP32_DERIVATION);\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 356,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "48f2cf53eacd5a26d6b7ae04d15254d4b0ecd38a",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "The same shorter read routine is possible here.",
    "created_at": "2018-06-30T00:44:10Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199307069",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199307069"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199307069"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199307069/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 420,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199307083",
    "pull_request_review_id": 133408214,
    "id": 199307083,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMwNzA4Mw==",
    "diff_hunk": "@@ -73,6 +76,562 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+// Magic bytes\n+static constexpr uint8_t PSBT_MAGIC_BYTES[4] = {'p', 's', 'b', 't'};\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static constexpr uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+template<typename Stream>\n+void DeserializeHDKeypaths(Stream& s, const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    // Make sure that the key is the size of pubkey + 1\n+    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+    }\n+    // Read in the pubkey from key\n+    CPubKey pubkey(key.begin() + 1, key.end());\n+    if (!pubkey.IsFullyValid()) {\n+       throw std::ios_base::failure(\"Invalid pubkey\");\n+    }\n+    if (hd_keypaths.count(pubkey) > 0) {\n+        throw std::ios_base::failure(\"Duplicate Key, pubkey derivation path already provided\");\n+    }\n+\n+    // Read in key path\n+    uint64_t value_len = ReadCompactSize(s);\n+    std::vector<uint32_t> keypath;\n+    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+        uint32_t index;\n+        s >> index;\n+        keypath.push_back(index);\n+    }\n+\n+    // Add to map\n+    hd_keypaths.emplace(pubkey, keypath);\n+}\n+\n+// Serialize HD keypaths to a stream from a map\n+template<typename Stream>\n+void SerializeHDKeypaths(Stream& s, const std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, uint8_t type)\n+{\n+    for (auto keypath_pair : hd_keypaths) {\n+        SerializeToVector(s, type, MakeSpan(keypath_pair.first));\n+        WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+        for (auto& path : keypath_pair.second) {\n+            s << path;\n+        }\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PSBTInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PSBTInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            SerializeHDKeypaths(s, hd_keypaths, PSBT_IN_BIP32_DERIVATION);\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"A Witness utxo was already provided, cannot provide a non-witness utxo\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"A non-witness utxo was already provided, cannot provide a witness utxo\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    std::vector<unsigned char> sig;\n+                    s >> sig;\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    DeserializeHDKeypaths(s, key, hd_keypaths);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    std::vector<unsigned char> val_bytes;\n+                    s >> val_bytes;\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PSBTInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput\n+{\n+    CScript redeem_script;\n+    CScript witness_script;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    PSBTOutput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the redeem script\n+        if (!redeem_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_REDEEMSCRIPT);\n+            s << redeem_script;\n+        }\n+\n+        // Write the witness script\n+        if (!witness_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_WITNESSSCRIPT);\n+            s << witness_script;\n+        }\n+\n+        // Write any hd keypaths\n+        SerializeHDKeypaths(s, hd_keypaths, PSBT_OUT_BIP32_DERIVATION);\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_OUT_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_OUT_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_OUT_BIP32_DERIVATION:\n+                {\n+                    DeserializeHDKeypaths(s, key, hd_keypaths);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default: {\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    std::vector<unsigned char> val_bytes;\n+                    s >> val_bytes;\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PSBTOutput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::vector<PSBTInput> inputs;\n+    std::vector<PSBTOutput> outputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in) : tx(psbt_in.tx), inputs(psbt_in.inputs), outputs(psbt_in.outputs), unknown(psbt_in.unknown) {}\n+\n+    // Only checks if they refer to the same transaction\n+    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return a.tx.GetHash() == b.tx.GetHash();\n+    }\n+    friend bool operator!=(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return !(a == b);\n+    }\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // unsigned tx flag\n+        SerializeToVector(s, PSBT_GLOBAL_UNSIGNED_TX);\n+\n+        // Write serialized tx to a stream\n+        SerializeToVector(s, tx);\n+\n+        // Write the unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        // Write inputs\n+        for (const PSBTInput& input : inputs) {\n+            s << input;\n+        }\n+        // Write outputs\n+        for (const PSBTOutput& output : outputs) {\n+            s << output;\n+        }\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read the magic bytes\n+        uint8_t magic[4];\n+        s >> magic;\n+        if (!std::equal(magic, magic + 4, PSBT_MAGIC_BYTES)) {\n+            throw std::ios_base::failure(\"Invalid PSBT magic bytes\");\n+        }\n+        unsigned char magic_sep;\n+        s >> magic_sep;\n+\n+        // Read global data\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 485,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "48f2cf53eacd5a26d6b7ae04d15254d4b0ecd38a",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "And again here.",
    "created_at": "2018-06-30T00:44:33Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199307083",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199307083"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199307083"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199307083/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 549,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199308042",
    "pull_request_review_id": 133409871,
    "id": 199308042,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMwODA0Mg==",
    "diff_hunk": "@@ -73,6 +76,562 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+// Magic bytes\n+static constexpr uint8_t PSBT_MAGIC_BYTES[4] = {'p', 's', 'b', 't'};\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static constexpr uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+template<typename Stream>\n+void DeserializeHDKeypaths(Stream& s, const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    // Make sure that the key is the size of pubkey + 1\n+    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+    }\n+    // Read in the pubkey from key\n+    CPubKey pubkey(key.begin() + 1, key.end());\n+    if (!pubkey.IsFullyValid()) {\n+       throw std::ios_base::failure(\"Invalid pubkey\");\n+    }\n+    if (hd_keypaths.count(pubkey) > 0) {\n+        throw std::ios_base::failure(\"Duplicate Key, pubkey derivation path already provided\");\n+    }\n+\n+    // Read in key path\n+    uint64_t value_len = ReadCompactSize(s);\n+    std::vector<uint32_t> keypath;\n+    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+        uint32_t index;\n+        s >> index;\n+        keypath.push_back(index);\n+    }\n+\n+    // Add to map\n+    hd_keypaths.emplace(pubkey, keypath);\n+}\n+\n+// Serialize HD keypaths to a stream from a map\n+template<typename Stream>\n+void SerializeHDKeypaths(Stream& s, const std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, uint8_t type)\n+{\n+    for (auto keypath_pair : hd_keypaths) {\n+        SerializeToVector(s, type, MakeSpan(keypath_pair.first));\n+        WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+        for (auto& path : keypath_pair.second) {\n+            s << path;\n+        }\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PSBTInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PSBTInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            SerializeHDKeypaths(s, hd_keypaths, PSBT_IN_BIP32_DERIVATION);\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 191,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "48f2cf53eacd5a26d6b7ae04d15254d4b0ecd38a",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-06-30T01:06:40Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199308042",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199308042"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199308042"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199308042/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 255,
    "side": "RIGHT",
    "in_reply_to_id": 199306583
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199308047",
    "pull_request_review_id": 133409876,
    "id": 199308047,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMwODA0Nw==",
    "diff_hunk": "@@ -73,6 +76,562 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+// Magic bytes\n+static constexpr uint8_t PSBT_MAGIC_BYTES[4] = {'p', 's', 'b', 't'};\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static constexpr uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+template<typename Stream>\n+void DeserializeHDKeypaths(Stream& s, const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    // Make sure that the key is the size of pubkey + 1\n+    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+    }\n+    // Read in the pubkey from key\n+    CPubKey pubkey(key.begin() + 1, key.end());\n+    if (!pubkey.IsFullyValid()) {\n+       throw std::ios_base::failure(\"Invalid pubkey\");\n+    }\n+    if (hd_keypaths.count(pubkey) > 0) {\n+        throw std::ios_base::failure(\"Duplicate Key, pubkey derivation path already provided\");\n+    }\n+\n+    // Read in key path\n+    uint64_t value_len = ReadCompactSize(s);\n+    std::vector<uint32_t> keypath;\n+    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+        uint32_t index;\n+        s >> index;\n+        keypath.push_back(index);\n+    }\n+\n+    // Add to map\n+    hd_keypaths.emplace(pubkey, keypath);\n+}\n+\n+// Serialize HD keypaths to a stream from a map\n+template<typename Stream>\n+void SerializeHDKeypaths(Stream& s, const std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, uint8_t type)\n+{\n+    for (auto keypath_pair : hd_keypaths) {\n+        SerializeToVector(s, type, MakeSpan(keypath_pair.first));\n+        WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+        for (auto& path : keypath_pair.second) {\n+            s << path;\n+        }\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PSBTInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PSBTInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            SerializeHDKeypaths(s, hd_keypaths, PSBT_IN_BIP32_DERIVATION);\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    if (!witness_utxo.IsNull()) {",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 214,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "48f2cf53eacd5a26d6b7ae04d15254d4b0ecd38a",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Removed",
    "created_at": "2018-06-30T01:06:45Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199308047",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199308047"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199308047"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199308047/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 278,
    "side": "RIGHT",
    "in_reply_to_id": 199306849
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199308050",
    "pull_request_review_id": 133409881,
    "id": 199308050,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMwODA1MA==",
    "diff_hunk": "@@ -73,6 +76,562 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+// Magic bytes\n+static constexpr uint8_t PSBT_MAGIC_BYTES[4] = {'p', 's', 'b', 't'};\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static constexpr uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+template<typename Stream>\n+void DeserializeHDKeypaths(Stream& s, const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    // Make sure that the key is the size of pubkey + 1\n+    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+    }\n+    // Read in the pubkey from key\n+    CPubKey pubkey(key.begin() + 1, key.end());\n+    if (!pubkey.IsFullyValid()) {\n+       throw std::ios_base::failure(\"Invalid pubkey\");\n+    }\n+    if (hd_keypaths.count(pubkey) > 0) {\n+        throw std::ios_base::failure(\"Duplicate Key, pubkey derivation path already provided\");\n+    }\n+\n+    // Read in key path\n+    uint64_t value_len = ReadCompactSize(s);\n+    std::vector<uint32_t> keypath;\n+    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+        uint32_t index;\n+        s >> index;\n+        keypath.push_back(index);\n+    }\n+\n+    // Add to map\n+    hd_keypaths.emplace(pubkey, keypath);\n+}\n+\n+// Serialize HD keypaths to a stream from a map\n+template<typename Stream>\n+void SerializeHDKeypaths(Stream& s, const std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, uint8_t type)\n+{\n+    for (auto keypath_pair : hd_keypaths) {\n+        SerializeToVector(s, type, MakeSpan(keypath_pair.first));\n+        WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+        for (auto& path : keypath_pair.second) {\n+            s << path;\n+        }\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PSBTInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PSBTInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            SerializeHDKeypaths(s, hd_keypaths, PSBT_IN_BIP32_DERIVATION);\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"A Witness utxo was already provided, cannot provide a non-witness utxo\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"A non-witness utxo was already provided, cannot provide a witness utxo\");",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 224,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "48f2cf53eacd5a26d6b7ae04d15254d4b0ecd38a",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-06-30T01:06:52Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199308050",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199308050"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199308050"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199308050/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 288,
    "side": "RIGHT",
    "in_reply_to_id": 199306860
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199308055",
    "pull_request_review_id": 133409886,
    "id": 199308055,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMwODA1NQ==",
    "diff_hunk": "@@ -73,6 +76,562 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+// Magic bytes\n+static constexpr uint8_t PSBT_MAGIC_BYTES[4] = {'p', 's', 'b', 't'};\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static constexpr uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+template<typename Stream>\n+void DeserializeHDKeypaths(Stream& s, const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    // Make sure that the key is the size of pubkey + 1\n+    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+    }\n+    // Read in the pubkey from key\n+    CPubKey pubkey(key.begin() + 1, key.end());\n+    if (!pubkey.IsFullyValid()) {\n+       throw std::ios_base::failure(\"Invalid pubkey\");\n+    }\n+    if (hd_keypaths.count(pubkey) > 0) {\n+        throw std::ios_base::failure(\"Duplicate Key, pubkey derivation path already provided\");\n+    }\n+\n+    // Read in key path\n+    uint64_t value_len = ReadCompactSize(s);\n+    std::vector<uint32_t> keypath;\n+    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+        uint32_t index;\n+        s >> index;\n+        keypath.push_back(index);\n+    }\n+\n+    // Add to map\n+    hd_keypaths.emplace(pubkey, keypath);\n+}\n+\n+// Serialize HD keypaths to a stream from a map\n+template<typename Stream>\n+void SerializeHDKeypaths(Stream& s, const std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, uint8_t type)\n+{\n+    for (auto keypath_pair : hd_keypaths) {\n+        SerializeToVector(s, type, MakeSpan(keypath_pair.first));\n+        WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+        for (auto& path : keypath_pair.second) {\n+            s << path;\n+        }\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PSBTInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PSBTInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            SerializeHDKeypaths(s, hd_keypaths, PSBT_IN_BIP32_DERIVATION);\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"A Witness utxo was already provided, cannot provide a non-witness utxo\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"A non-witness utxo was already provided, cannot provide a witness utxo\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    std::vector<unsigned char> sig;\n+                    s >> sig;\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 248,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "48f2cf53eacd5a26d6b7ae04d15254d4b0ecd38a",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-06-30T01:06:56Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199308055",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199308055"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199308055"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199308055/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 312,
    "side": "RIGHT",
    "in_reply_to_id": 199306899
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199308057",
    "pull_request_review_id": 133409890,
    "id": 199308057,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMwODA1Nw==",
    "diff_hunk": "@@ -73,6 +76,562 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+// Magic bytes\n+static constexpr uint8_t PSBT_MAGIC_BYTES[4] = {'p', 's', 'b', 't'};\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static constexpr uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+template<typename Stream>\n+void DeserializeHDKeypaths(Stream& s, const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    // Make sure that the key is the size of pubkey + 1\n+    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+    }\n+    // Read in the pubkey from key\n+    CPubKey pubkey(key.begin() + 1, key.end());\n+    if (!pubkey.IsFullyValid()) {\n+       throw std::ios_base::failure(\"Invalid pubkey\");\n+    }\n+    if (hd_keypaths.count(pubkey) > 0) {\n+        throw std::ios_base::failure(\"Duplicate Key, pubkey derivation path already provided\");\n+    }\n+\n+    // Read in key path\n+    uint64_t value_len = ReadCompactSize(s);\n+    std::vector<uint32_t> keypath;\n+    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+        uint32_t index;\n+        s >> index;\n+        keypath.push_back(index);\n+    }\n+\n+    // Add to map\n+    hd_keypaths.emplace(pubkey, keypath);\n+}\n+\n+// Serialize HD keypaths to a stream from a map\n+template<typename Stream>\n+void SerializeHDKeypaths(Stream& s, const std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, uint8_t type)\n+{\n+    for (auto keypath_pair : hd_keypaths) {\n+        SerializeToVector(s, type, MakeSpan(keypath_pair.first));\n+        WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+        for (auto& path : keypath_pair.second) {\n+            s << path;\n+        }\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PSBTInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PSBTInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            SerializeHDKeypaths(s, hd_keypaths, PSBT_IN_BIP32_DERIVATION);\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"A Witness utxo was already provided, cannot provide a non-witness utxo\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"A non-witness utxo was already provided, cannot provide a witness utxo\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    std::vector<unsigned char> sig;\n+                    s >> sig;\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    DeserializeHDKeypaths(s, key, hd_keypaths);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    std::vector<unsigned char> val_bytes;\n+                    s >> val_bytes;\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PSBTInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput\n+{\n+    CScript redeem_script;\n+    CScript witness_script;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    PSBTOutput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the redeem script\n+        if (!redeem_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_REDEEMSCRIPT);\n+            s << redeem_script;\n+        }\n+\n+        // Write the witness script\n+        if (!witness_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_WITNESSSCRIPT);\n+            s << witness_script;\n+        }\n+\n+        // Write any hd keypaths\n+        SerializeHDKeypaths(s, hd_keypaths, PSBT_OUT_BIP32_DERIVATION);\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 356,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "48f2cf53eacd5a26d6b7ae04d15254d4b0ecd38a",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-06-30T01:07:00Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199308057",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199308057"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199308057"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199308057/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 420,
    "side": "RIGHT",
    "in_reply_to_id": 199307069
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199308062",
    "pull_request_review_id": 133409895,
    "id": 199308062,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMwODA2Mg==",
    "diff_hunk": "@@ -73,6 +76,562 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+// Magic bytes\n+static constexpr uint8_t PSBT_MAGIC_BYTES[4] = {'p', 's', 'b', 't'};\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static constexpr uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+template<typename Stream>\n+void DeserializeHDKeypaths(Stream& s, const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    // Make sure that the key is the size of pubkey + 1\n+    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+    }\n+    // Read in the pubkey from key\n+    CPubKey pubkey(key.begin() + 1, key.end());\n+    if (!pubkey.IsFullyValid()) {\n+       throw std::ios_base::failure(\"Invalid pubkey\");\n+    }\n+    if (hd_keypaths.count(pubkey) > 0) {\n+        throw std::ios_base::failure(\"Duplicate Key, pubkey derivation path already provided\");\n+    }\n+\n+    // Read in key path\n+    uint64_t value_len = ReadCompactSize(s);\n+    std::vector<uint32_t> keypath;\n+    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+        uint32_t index;\n+        s >> index;\n+        keypath.push_back(index);\n+    }\n+\n+    // Add to map\n+    hd_keypaths.emplace(pubkey, keypath);\n+}\n+\n+// Serialize HD keypaths to a stream from a map\n+template<typename Stream>\n+void SerializeHDKeypaths(Stream& s, const std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, uint8_t type)\n+{\n+    for (auto keypath_pair : hd_keypaths) {\n+        SerializeToVector(s, type, MakeSpan(keypath_pair.first));\n+        WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+        for (auto& path : keypath_pair.second) {\n+            s << path;\n+        }\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PSBTInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PSBTInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            SerializeHDKeypaths(s, hd_keypaths, PSBT_IN_BIP32_DERIVATION);\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"A Witness utxo was already provided, cannot provide a non-witness utxo\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"A non-witness utxo was already provided, cannot provide a witness utxo\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    std::vector<unsigned char> sig;\n+                    s >> sig;\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    DeserializeHDKeypaths(s, key, hd_keypaths);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    std::vector<unsigned char> val_bytes;\n+                    s >> val_bytes;\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PSBTInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput\n+{\n+    CScript redeem_script;\n+    CScript witness_script;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    PSBTOutput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the redeem script\n+        if (!redeem_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_REDEEMSCRIPT);\n+            s << redeem_script;\n+        }\n+\n+        // Write the witness script\n+        if (!witness_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_WITNESSSCRIPT);\n+            s << witness_script;\n+        }\n+\n+        // Write any hd keypaths\n+        SerializeHDKeypaths(s, hd_keypaths, PSBT_OUT_BIP32_DERIVATION);\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_OUT_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_OUT_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_OUT_BIP32_DERIVATION:\n+                {\n+                    DeserializeHDKeypaths(s, key, hd_keypaths);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default: {\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    std::vector<unsigned char> val_bytes;\n+                    s >> val_bytes;\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PSBTOutput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::vector<PSBTInput> inputs;\n+    std::vector<PSBTOutput> outputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in) : tx(psbt_in.tx), inputs(psbt_in.inputs), outputs(psbt_in.outputs), unknown(psbt_in.unknown) {}\n+\n+    // Only checks if they refer to the same transaction\n+    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return a.tx.GetHash() == b.tx.GetHash();\n+    }\n+    friend bool operator!=(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return !(a == b);\n+    }\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // unsigned tx flag\n+        SerializeToVector(s, PSBT_GLOBAL_UNSIGNED_TX);\n+\n+        // Write serialized tx to a stream\n+        SerializeToVector(s, tx);\n+\n+        // Write the unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        // Write inputs\n+        for (const PSBTInput& input : inputs) {\n+            s << input;\n+        }\n+        // Write outputs\n+        for (const PSBTOutput& output : outputs) {\n+            s << output;\n+        }\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read the magic bytes\n+        uint8_t magic[4];\n+        s >> magic;\n+        if (!std::equal(magic, magic + 4, PSBT_MAGIC_BYTES)) {\n+            throw std::ios_base::failure(\"Invalid PSBT magic bytes\");\n+        }\n+        unsigned char magic_sep;\n+        s >> magic_sep;\n+\n+        // Read global data\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 485,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "48f2cf53eacd5a26d6b7ae04d15254d4b0ecd38a",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-06-30T01:07:05Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199308062",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199308062"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199308062"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199308062/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 549,
    "side": "RIGHT",
    "in_reply_to_id": 199307083
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199309739",
    "pull_request_review_id": 133411738,
    "id": 199309739,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMwOTczOQ==",
    "diff_hunk": "@@ -160,6 +161,23 @@ bool DecodeHexBlk(CBlock& block, const std::string& strHexBlk)\n     return true;\n }\n \n+bool DecodePSBT(PartiallySignedTransaction& psbt, const std::string& base64_tx, std::string& error)\n+{\n+    std::vector<unsigned char> txData = DecodeBase64(base64_tx.c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbt;\n+        if (!ssData.empty()) {\n+            error = \"extra data after PSBT\";\n+            return false;\n+        }\n+    } catch (const std::exception& e) {",
    "path": "src/core_read.cpp",
    "position": null,
    "original_position": 22,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "d59ebaa3c064c479ea91368e07e811d4f84b9abe",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Perhaps check for `ssData.eof()` here (so that adding garbage at the end of the base64 string is rejected).",
    "created_at": "2018-06-30T01:53:50Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199309739",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199309739"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199309739"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199309739/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 174,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199309749",
    "pull_request_review_id": 133411738,
    "id": 199309749,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMwOTc0OQ==",
    "diff_hunk": "@@ -160,6 +161,23 @@ bool DecodeHexBlk(CBlock& block, const std::string& strHexBlk)\n     return true;\n }\n \n+bool DecodePSBT(PartiallySignedTransaction& psbt, const std::string& base64_tx, std::string& error)\n+{\n+    std::vector<unsigned char> txData = DecodeBase64(base64_tx.c_str());",
    "path": "src/core_read.cpp",
    "position": null,
    "original_position": 14,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "d59ebaa3c064c479ea91368e07e811d4f84b9abe",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Nit: variable naming style.",
    "created_at": "2018-06-30T01:54:04Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199309749",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199309749"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199309749"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199309749/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 166,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199309761",
    "pull_request_review_id": 133411738,
    "id": 199309761,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMwOTc2MQ==",
    "diff_hunk": "@@ -160,6 +161,23 @@ bool DecodeHexBlk(CBlock& block, const std::string& strHexBlk)\n     return true;\n }\n \n+bool DecodePSBT(PartiallySignedTransaction& psbt, const std::string& base64_tx, std::string& error)\n+{\n+    std::vector<unsigned char> txData = DecodeBase64(base64_tx.c_str());",
    "path": "src/core_read.cpp",
    "position": null,
    "original_position": 14,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "d59ebaa3c064c479ea91368e07e811d4f84b9abe",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "You can drop the `.c_str()`.",
    "created_at": "2018-06-30T01:54:36Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199309761",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199309761"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199309761"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199309761/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 166,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199309777",
    "pull_request_review_id": 133411738,
    "id": 199309777,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMwOTc3Nw==",
    "diff_hunk": "@@ -1262,6 +1263,551 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)",
    "path": "src/rpc/rawtransaction.cpp",
    "position": 199,
    "original_position": 12,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "d59ebaa3c064c479ea91368e07e811d4f84b9abe",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This adds a superfluous `/` at the end of the string.",
    "created_at": "2018-06-30T01:55:14Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199309777",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199309777"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199309777"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199309777/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1247,
    "original_line": 1247,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199309807",
    "pull_request_review_id": 133411738,
    "id": 199309807,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMwOTgwNw==",
    "diff_hunk": "@@ -1262,6 +1263,551 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 35,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "d59ebaa3c064c479ea91368e07e811d4f84b9abe",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "What do you think about renaming input psbt arguments from `\"base64\"` or `\"base64string\"` to `\"psbt\"` (and similar for output object field names)?",
    "created_at": "2018-06-30T01:57:01Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199309807",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199309807"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199309807"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199309807/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1289,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199309850",
    "pull_request_review_id": 133411738,
    "id": 199309850,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMwOTg1MA==",
    "diff_hunk": "@@ -1262,6 +1263,551 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"          {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"       ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"        }\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                UniValue sig_univ(UniValue::VOBJ);\n+                sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                partial_sigs.push_back(sig_univ);\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner and Finalizer roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 315,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "d59ebaa3c064c479ea91368e07e811d4f84b9abe",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Not hex.",
    "created_at": "2018-06-30T01:58:37Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199309850",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199309850"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199309850"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199309850/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1569,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199309871",
    "pull_request_review_id": 133411738,
    "id": 199309871,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMwOTg3MQ==",
    "diff_hunk": "@@ -1262,6 +1263,551 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"          {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"       ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"        }\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                UniValue sig_univ(UniValue::VOBJ);\n+                sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                partial_sigs.push_back(sig_univ);\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner and Finalizer roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+    // Merge them\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 355,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "d59ebaa3c064c479ea91368e07e811d4f84b9abe",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "No need to merge in the first one again.",
    "created_at": "2018-06-30T01:59:24Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199309871",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199309871"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199309871"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199309871/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1611,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199309880",
    "pull_request_review_id": 133411738,
    "id": 199309880,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMwOTg4MA==",
    "diff_hunk": "@@ -1262,6 +1263,551 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"          {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"       ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"        }\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                UniValue sig_univ(UniValue::VOBJ);\n+                sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                partial_sigs.push_back(sig_univ);\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner and Finalizer roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+    // Merge them\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        merged_psbt.Merge(psbtx);\n+    }\n+    if (!merged_psbt.IsSane()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is not sane\");",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 359,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "d59ebaa3c064c479ea91368e07e811d4f84b9abe",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "\"Not sane\" sounds funny. What about \"Resulting PSBT would be inconsistent\"?",
    "created_at": "2018-06-30T01:59:58Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199309880",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199309880"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199309880"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199309880/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1613,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199309897",
    "pull_request_review_id": 133411738,
    "id": 199309897,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMwOTg5Nw==",
    "diff_hunk": "@@ -1262,6 +1263,551 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"          {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"       ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"        }\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                UniValue sig_univ(UniValue::VOBJ);\n+                sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                partial_sigs.push_back(sig_univ);\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner and Finalizer roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+    // Merge them\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        merged_psbt.Merge(psbtx);\n+    }\n+    if (!merged_psbt.IsSane()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is not sane\");\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());",
    "path": "src/rpc/rawtransaction.cpp",
    "position": 550,
    "original_position": 365,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "d59ebaa3c064c479ea91368e07e811d4f84b9abe",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Is the cast necessary here?",
    "created_at": "2018-06-30T02:00:37Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199309897",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199309897"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199309897"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199309897/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1598,
    "original_line": 1598,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310113",
    "pull_request_review_id": 133411738,
    "id": 199310113,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMxMDExMw==",
    "diff_hunk": "@@ -1262,6 +1263,551 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"          {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"       ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"        }\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                UniValue sig_univ(UniValue::VOBJ);\n+                sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                partial_sigs.push_back(sig_univ);\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner and Finalizer roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+    // Merge them\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        merged_psbt.Merge(psbtx);\n+    }\n+    if (!merged_psbt.IsSane()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is not sane\");\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"base64string\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\\n\"\n+            \"Implements the Finalizer and Extractor roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"            (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded network transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"base64string\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx.vin.size(); ++i) {\n+        CTxIn txin = psbtx.tx.vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        SignatureData sigdata;\n+        complete &= SignPSBTInput(DUMMY_SIGNING_PROVIDER, psbtx.tx, input, sigdata, i, 1);\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\n+    if (complete && extract) {\n+        CMutableTransaction mtx(psbtx.tx);\n+        for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+            mtx.vin[i].scriptSig = psbtx.inputs[i].final_script_sig;\n+            mtx.vin[i].scriptWitness = psbtx.inputs[i].final_script_witness;\n+        }\n+        ssTx << mtx;\n+        result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n+    } else {\n+        ssTx << psbtx;\n+        result.push_back(Pair(\"base64\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size())));\n+    }\n+    result.push_back(Pair(\"complete\", complete));\n+\n+    return result;\n+}\n+\n+UniValue createpsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n+        throw std::runtime_error(\n+                            \"createpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable )\\n\"\n+                            \"\\nCreates a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"\n+                            \"Implements the Creator role.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"inputs\\\"                (array, required) A json array of json objects\\n\"\n+                            \"     [\\n\"\n+                            \"       {\\n\"\n+                            \"         \\\"txid\\\":\\\"id\\\",      (string, required) The transaction id\\n\"\n+                            \"         \\\"vout\\\":n,         (numeric, required) The output number\\n\"\n+                            \"         \\\"sequence\\\":n      (numeric, optional) The sequence number\\n\"\n+                            \"       } \\n\"\n+                            \"       ,...\\n\"\n+                            \"     ]\\n\"\n+                            \"2. \\\"outputs\\\"               (array, required) a json array with outputs (key-value pairs)\\n\"\n+                            \"   [\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"address\\\": x.xxx,    (obj, optional) A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\\n\"\n+                            \"    },\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"data\\\": \\\"hex\\\"        (obj, optional) A key-value pair. The key must be \\\"data\\\", the value is hex encoded data\\n\"\n+                            \"    }\\n\"\n+                            \"    ,...                     More key-value pairs of the above form. For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n+                            \"                             accepted as second parameter.\\n\"\n+                            \"   ]\\n\"\n+                            \"3. locktime                  (numeric, optional, default=0) Raw locktime. Non-0 value also locktime-activates inputs\\n\"\n+                            \"4. replaceable               (boolean, optional, default=false) Marks this transaction as BIP125 replaceable.\\n\"\n+                            \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"base64\\\": \\\"value\\\",      (string)  The resulting raw transaction (base64-encoded string)\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"createpsbt\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")\n+                            );\n+\n+\n+    RPCTypeCheck(request.params, {\n+        UniValue::VARR,\n+        UniValueType(), // ARR or OBJ, checked later\n+        UniValue::VNUM,\n+        UniValue::VBOOL,\n+        }, true\n+    );\n+\n+    CMutableTransaction rawTx = ConstructTransaction(request.params[0], request.params[1], request.params[2], request.params[3]);\n+\n+    // Make a blank psbt\n+    PartiallySignedTransaction psbtx;\n+    psbtx.tx = rawTx;\n+    for (unsigned int i = 0; i < rawTx.vin.size(); ++i) {\n+        psbtx.inputs.push_back(PSBTInput());\n+    }\n+    for (unsigned int i = 0; i < rawTx.vout.size(); ++i) {\n+        psbtx.outputs.push_back(PSBTOutput());\n+    }\n+\n+    // Serialize the PSBT\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue converttopsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+                            \"converttopsbt \\\"hexstring\\\" ( permitsigdata iswitness )\\n\"\n+                            \"\\nConverts a network serialized transaction to a PSBT. This should be used only with createrawtransaction and fundrawtransaction\\n\"\n+                            \"createpsbt and walletcreatefundedpsbt should be used for new applications.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"hexstring\\\"              (string, required) The hex string of a raw transaction\\n\"\n+                            \"2. permitsigdata           (boolean, optional) Whether the transaction hex contains any data in the scriptSigs or scriptWitnesses.\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 506,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "d59ebaa3c064c479ea91368e07e811d4f84b9abe",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This explanation is confusing. It's an input argument, right? How about \"If true, the RPC will ignore any signatures present in the input. When this argument is false, it will fail if signatures are present.\"",
    "created_at": "2018-06-30T02:05:06Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199310113",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310113"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199310113"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310113/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1760,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310430",
    "pull_request_review_id": 133412555,
    "id": 199310430,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMxMDQzMA==",
    "diff_hunk": "@@ -160,6 +161,23 @@ bool DecodeHexBlk(CBlock& block, const std::string& strHexBlk)\n     return true;\n }\n \n+bool DecodePSBT(PartiallySignedTransaction& psbt, const std::string& base64_tx, std::string& error)\n+{\n+    std::vector<unsigned char> txData = DecodeBase64(base64_tx.c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbt;\n+        if (!ssData.empty()) {\n+            error = \"extra data after PSBT\";\n+            return false;\n+        }\n+    } catch (const std::exception& e) {",
    "path": "src/core_read.cpp",
    "position": null,
    "original_position": 22,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "d59ebaa3c064c479ea91368e07e811d4f84b9abe",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This is checked for above with `if (!ssData.empty()) {`",
    "created_at": "2018-06-30T02:22:08Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199310430",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310430"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199310430"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310430/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 174,
    "side": "RIGHT",
    "in_reply_to_id": 199309739
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310587",
    "pull_request_review_id": 133412745,
    "id": 199310587,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMxMDU4Nw==",
    "diff_hunk": "@@ -160,6 +161,23 @@ bool DecodeHexBlk(CBlock& block, const std::string& strHexBlk)\n     return true;\n }\n \n+bool DecodePSBT(PartiallySignedTransaction& psbt, const std::string& base64_tx, std::string& error)\n+{\n+    std::vector<unsigned char> txData = DecodeBase64(base64_tx.c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbt;\n+        if (!ssData.empty()) {\n+            error = \"extra data after PSBT\";\n+            return false;\n+        }\n+    } catch (const std::exception& e) {",
    "path": "src/core_read.cpp",
    "position": null,
    "original_position": 22,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "d59ebaa3c064c479ea91368e07e811d4f84b9abe",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I should learn to read.",
    "created_at": "2018-06-30T02:28:59Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199310587",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310587"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199310587"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310587/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 174,
    "side": "RIGHT",
    "in_reply_to_id": 199309739
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310681",
    "pull_request_review_id": 133412854,
    "id": 199310681,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMxMDY4MQ==",
    "diff_hunk": "@@ -160,6 +161,23 @@ bool DecodeHexBlk(CBlock& block, const std::string& strHexBlk)\n     return true;\n }\n \n+bool DecodePSBT(PartiallySignedTransaction& psbt, const std::string& base64_tx, std::string& error)\n+{\n+    std::vector<unsigned char> txData = DecodeBase64(base64_tx.c_str());",
    "path": "src/core_read.cpp",
    "position": null,
    "original_position": 14,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "d59ebaa3c064c479ea91368e07e811d4f84b9abe",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "`DecodeBase64` takes an `unsigned char*` while base64_tx is a `std::string`. It fails to compile without `c_str()`",
    "created_at": "2018-06-30T02:34:13Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199310681",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310681"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199310681"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310681/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 166,
    "side": "RIGHT",
    "in_reply_to_id": 199309761
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310686",
    "pull_request_review_id": 133412862,
    "id": 199310686,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMxMDY4Ng==",
    "diff_hunk": "@@ -1262,6 +1263,551 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"          {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"       ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"        }\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                UniValue sig_univ(UniValue::VOBJ);\n+                sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                partial_sigs.push_back(sig_univ);\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner and Finalizer roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+    // Merge them\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        merged_psbt.Merge(psbtx);\n+    }\n+    if (!merged_psbt.IsSane()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is not sane\");\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());",
    "path": "src/rpc/rawtransaction.cpp",
    "position": 550,
    "original_position": 365,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "d59ebaa3c064c479ea91368e07e811d4f84b9abe",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Yes. `EncodeBase64` takes an `unsigned char*` but `ssTx.data()` is a `char *`.",
    "created_at": "2018-06-30T02:34:45Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199310686",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310686"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199310686"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310686/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1598,
    "original_line": 1598,
    "side": "RIGHT",
    "in_reply_to_id": 199309897
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310802",
    "pull_request_review_id": 133413015,
    "id": 199310802,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMxMDgwMg==",
    "diff_hunk": "@@ -160,6 +161,23 @@ bool DecodeHexBlk(CBlock& block, const std::string& strHexBlk)\n     return true;\n }\n \n+bool DecodePSBT(PartiallySignedTransaction& psbt, const std::string& base64_tx, std::string& error)\n+{\n+    std::vector<unsigned char> txData = DecodeBase64(base64_tx.c_str());",
    "path": "src/core_read.cpp",
    "position": null,
    "original_position": 14,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "d59ebaa3c064c479ea91368e07e811d4f84b9abe",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "There is also a version of `DecodeBase64` which takes a `const std::string&`.",
    "created_at": "2018-06-30T02:42:12Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199310802",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310802"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199310802"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310802/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 166,
    "side": "RIGHT",
    "in_reply_to_id": 199309761
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310847",
    "pull_request_review_id": 133413083,
    "id": 199310847,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMxMDg0Nw==",
    "diff_hunk": "@@ -160,6 +161,23 @@ bool DecodeHexBlk(CBlock& block, const std::string& strHexBlk)\n     return true;\n }\n \n+bool DecodePSBT(PartiallySignedTransaction& psbt, const std::string& base64_tx, std::string& error)\n+{\n+    std::vector<unsigned char> txData = DecodeBase64(base64_tx.c_str());",
    "path": "src/core_read.cpp",
    "position": null,
    "original_position": 14,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "d59ebaa3c064c479ea91368e07e811d4f84b9abe",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Yes, but not to a `std::vector<unsigned char>`. It decodes to a `std::string`, but I need a `std::vector<unsigned char>`",
    "created_at": "2018-06-30T02:45:44Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199310847",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310847"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199310847"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310847/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 166,
    "side": "RIGHT",
    "in_reply_to_id": 199309761
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310858",
    "pull_request_review_id": 133413092,
    "id": 199310858,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMxMDg1OA==",
    "diff_hunk": "@@ -160,6 +161,23 @@ bool DecodeHexBlk(CBlock& block, const std::string& strHexBlk)\n     return true;\n }\n \n+bool DecodePSBT(PartiallySignedTransaction& psbt, const std::string& base64_tx, std::string& error)\n+{\n+    std::vector<unsigned char> txData = DecodeBase64(base64_tx.c_str());",
    "path": "src/core_read.cpp",
    "position": null,
    "original_position": 14,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "d59ebaa3c064c479ea91368e07e811d4f84b9abe",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Fixed",
    "created_at": "2018-06-30T02:46:09Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199310858",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310858"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199310858"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310858/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 166,
    "side": "RIGHT",
    "in_reply_to_id": 199309749
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310861",
    "pull_request_review_id": 133413095,
    "id": 199310861,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMxMDg2MQ==",
    "diff_hunk": "@@ -1262,6 +1263,551 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)",
    "path": "src/rpc/rawtransaction.cpp",
    "position": 199,
    "original_position": 12,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "d59ebaa3c064c479ea91368e07e811d4f84b9abe",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Fixed",
    "created_at": "2018-06-30T02:46:15Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199310861",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310861"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199310861"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310861/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1247,
    "original_line": 1247,
    "side": "RIGHT",
    "in_reply_to_id": 199309777
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310864",
    "pull_request_review_id": 133413102,
    "id": 199310864,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMxMDg2NA==",
    "diff_hunk": "@@ -1262,6 +1263,551 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 35,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "d59ebaa3c064c479ea91368e07e811d4f84b9abe",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Renamed",
    "created_at": "2018-06-30T02:46:23Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199310864",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310864"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199310864"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310864/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1289,
    "side": "RIGHT",
    "in_reply_to_id": 199309807
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310866",
    "pull_request_review_id": 133413104,
    "id": 199310866,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMxMDg2Ng==",
    "diff_hunk": "@@ -1262,6 +1263,551 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"          {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"       ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"        }\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                UniValue sig_univ(UniValue::VOBJ);\n+                sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                partial_sigs.push_back(sig_univ);\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner and Finalizer roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 315,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "d59ebaa3c064c479ea91368e07e811d4f84b9abe",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Fixed",
    "created_at": "2018-06-30T02:46:31Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199310866",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310866"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199310866"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310866/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1569,
    "side": "RIGHT",
    "in_reply_to_id": 199309850
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310871",
    "pull_request_review_id": 133413110,
    "id": 199310871,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMxMDg3MQ==",
    "diff_hunk": "@@ -1262,6 +1263,551 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"          {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"       ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"        }\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                UniValue sig_univ(UniValue::VOBJ);\n+                sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                partial_sigs.push_back(sig_univ);\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner and Finalizer roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+    // Merge them\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 355,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "d59ebaa3c064c479ea91368e07e811d4f84b9abe",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Changed to erase the first element from the vector.",
    "created_at": "2018-06-30T02:46:48Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199310871",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310871"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199310871"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310871/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1611,
    "side": "RIGHT",
    "in_reply_to_id": 199309871
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310875",
    "pull_request_review_id": 133413116,
    "id": 199310875,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMxMDg3NQ==",
    "diff_hunk": "@@ -1262,6 +1263,551 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"          {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"       ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"        }\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                UniValue sig_univ(UniValue::VOBJ);\n+                sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                partial_sigs.push_back(sig_univ);\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner and Finalizer roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+    // Merge them\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        merged_psbt.Merge(psbtx);\n+    }\n+    if (!merged_psbt.IsSane()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is not sane\");",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 359,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "d59ebaa3c064c479ea91368e07e811d4f84b9abe",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-06-30T02:46:54Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199310875",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310875"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199310875"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310875/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1613,
    "side": "RIGHT",
    "in_reply_to_id": 199309880
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310876",
    "pull_request_review_id": 133413118,
    "id": 199310876,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMxMDg3Ng==",
    "diff_hunk": "@@ -1262,6 +1263,551 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"          {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"       ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"        }\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                UniValue sig_univ(UniValue::VOBJ);\n+                sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                partial_sigs.push_back(sig_univ);\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner and Finalizer roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+    // Merge them\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        merged_psbt.Merge(psbtx);\n+    }\n+    if (!merged_psbt.IsSane()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is not sane\");\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"base64string\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\\n\"\n+            \"Implements the Finalizer and Extractor roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"            (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded network transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"base64string\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx.vin.size(); ++i) {\n+        CTxIn txin = psbtx.tx.vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        SignatureData sigdata;\n+        complete &= SignPSBTInput(DUMMY_SIGNING_PROVIDER, psbtx.tx, input, sigdata, i, 1);\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\n+    if (complete && extract) {\n+        CMutableTransaction mtx(psbtx.tx);\n+        for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+            mtx.vin[i].scriptSig = psbtx.inputs[i].final_script_sig;\n+            mtx.vin[i].scriptWitness = psbtx.inputs[i].final_script_witness;\n+        }\n+        ssTx << mtx;\n+        result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n+    } else {\n+        ssTx << psbtx;\n+        result.push_back(Pair(\"base64\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size())));\n+    }\n+    result.push_back(Pair(\"complete\", complete));\n+\n+    return result;\n+}\n+\n+UniValue createpsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n+        throw std::runtime_error(\n+                            \"createpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable )\\n\"\n+                            \"\\nCreates a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"\n+                            \"Implements the Creator role.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"inputs\\\"                (array, required) A json array of json objects\\n\"\n+                            \"     [\\n\"\n+                            \"       {\\n\"\n+                            \"         \\\"txid\\\":\\\"id\\\",      (string, required) The transaction id\\n\"\n+                            \"         \\\"vout\\\":n,         (numeric, required) The output number\\n\"\n+                            \"         \\\"sequence\\\":n      (numeric, optional) The sequence number\\n\"\n+                            \"       } \\n\"\n+                            \"       ,...\\n\"\n+                            \"     ]\\n\"\n+                            \"2. \\\"outputs\\\"               (array, required) a json array with outputs (key-value pairs)\\n\"\n+                            \"   [\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"address\\\": x.xxx,    (obj, optional) A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\\n\"\n+                            \"    },\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"data\\\": \\\"hex\\\"        (obj, optional) A key-value pair. The key must be \\\"data\\\", the value is hex encoded data\\n\"\n+                            \"    }\\n\"\n+                            \"    ,...                     More key-value pairs of the above form. For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n+                            \"                             accepted as second parameter.\\n\"\n+                            \"   ]\\n\"\n+                            \"3. locktime                  (numeric, optional, default=0) Raw locktime. Non-0 value also locktime-activates inputs\\n\"\n+                            \"4. replaceable               (boolean, optional, default=false) Marks this transaction as BIP125 replaceable.\\n\"\n+                            \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"base64\\\": \\\"value\\\",      (string)  The resulting raw transaction (base64-encoded string)\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"createpsbt\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")\n+                            );\n+\n+\n+    RPCTypeCheck(request.params, {\n+        UniValue::VARR,\n+        UniValueType(), // ARR or OBJ, checked later\n+        UniValue::VNUM,\n+        UniValue::VBOOL,\n+        }, true\n+    );\n+\n+    CMutableTransaction rawTx = ConstructTransaction(request.params[0], request.params[1], request.params[2], request.params[3]);\n+\n+    // Make a blank psbt\n+    PartiallySignedTransaction psbtx;\n+    psbtx.tx = rawTx;\n+    for (unsigned int i = 0; i < rawTx.vin.size(); ++i) {\n+        psbtx.inputs.push_back(PSBTInput());\n+    }\n+    for (unsigned int i = 0; i < rawTx.vout.size(); ++i) {\n+        psbtx.outputs.push_back(PSBTOutput());\n+    }\n+\n+    // Serialize the PSBT\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue converttopsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+                            \"converttopsbt \\\"hexstring\\\" ( permitsigdata iswitness )\\n\"\n+                            \"\\nConverts a network serialized transaction to a PSBT. This should be used only with createrawtransaction and fundrawtransaction\\n\"\n+                            \"createpsbt and walletcreatefundedpsbt should be used for new applications.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"hexstring\\\"              (string, required) The hex string of a raw transaction\\n\"\n+                            \"2. permitsigdata           (boolean, optional) Whether the transaction hex contains any data in the scriptSigs or scriptWitnesses.\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 506,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "d59ebaa3c064c479ea91368e07e811d4f84b9abe",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Changed",
    "created_at": "2018-06-30T02:47:02Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199310876",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310876"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199310876"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199310876/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1760,
    "side": "RIGHT",
    "in_reply_to_id": 199310113
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199329840",
    "pull_request_review_id": 133433770,
    "id": 199329840,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMyOTg0MA==",
    "diff_hunk": "@@ -3607,17 +3529,98 @@ static UniValue fundrawtransaction(const JSONRPCRequest& request)\n         setSubtractFeeFromOutputs.insert(pos);\n     }\n \n-    CAmount nFeeOut;\n     std::string strFailReason;\n \n-    if (!pwallet->FundTransaction(tx, nFeeOut, changePosition, strFailReason, lockUnspents, setSubtractFeeFromOutputs, coinControl)) {\n+    if (!pwallet->FundTransaction(tx, fee_out, change_position, strFailReason, lockUnspents, setSubtractFeeFromOutputs, coinControl)) {\n         throw JSONRPCError(RPC_WALLET_ERROR, strFailReason);\n     }\n+}\n+\n+static UniValue fundrawtransaction(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+                            \"fundrawtransaction \\\"hexstring\\\" ( options iswitness )\\n\"\n+                            \"\\nAdd inputs to a transaction until it has enough in value to meet its out value.\\n\"\n+                            \"This will not modify existing inputs, and will add at most one change output to the outputs.\\n\"\n+                            \"No existing outputs will be modified unless \\\"subtractFeeFromOutputs\\\" is specified.\\n\"\n+                            \"Note that inputs which were signed may need to be resigned after completion since in/outputs have been added.\\n\"\n+                            \"The inputs added will not be signed, use signrawtransaction for that.\\n\"\n+                            \"Note that all existing inputs must have their previous output transaction be in the wallet.\\n\"\n+                            \"Note that all inputs selected must be of standard form and P2SH scripts must be\\n\"\n+                            \"in the wallet using importaddress or addmultisigaddress (to calculate fees).\\n\"\n+                            \"You can see whether this is the case by checking the \\\"solvable\\\" field in the listunspent output.\\n\"\n+                            \"Only pay-to-pubkey, multisig, and P2SH versions thereof are currently supported for watch-only\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"hexstring\\\"           (string, required) The hex string of the raw transaction\\n\"\n+                            \"2. options                 (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"changeAddress\\\"          (string, optional, default pool address) The bitcoin address to receive the change\\n\"\n+                            \"     \\\"changePosition\\\"         (numeric, optional, default random) The index of the change output\\n\"\n+                            \"     \\\"change_type\\\"            (string, optional) The output type to use. Only valid if changeAddress is not specified. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\". Default is set by -changetype.\\n\"\n+                            \"     \\\"includeWatching\\\"        (boolean, optional, default false) Also select inputs which are watch only\\n\"\n+                            \"     \\\"lockUnspents\\\"           (boolean, optional, default false) Lock selected unspent outputs\\n\"\n+                            \"     \\\"feeRate\\\"                (numeric, optional, default not set: makes wallet determine the fee) Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"\n+                            \"     \\\"subtractFeeFromOutputs\\\" (array, optional) A json array of integers.\\n\"\n+                            \"                              The fee will be equally deducted from the amount of each specified output.\\n\"\n+                            \"                              The outputs are specified by their zero-based index, before any change output is added.\\n\"\n+                            \"                              Those recipients will receive less bitcoins than you enter in their corresponding amount field.\\n\"\n+                            \"                              If no outputs are specified here, the sender pays the fee.\\n\"\n+                            \"                                  [vout_index,...]\\n\"\n+                            \"     \\\"replaceable\\\"            (boolean, optional) Marks this transaction as BIP125 replaceable.\\n\"\n+                            \"                              Allows this transaction to be replaced by a transaction with higher fees\\n\"\n+                            \"     \\\"conf_target\\\"            (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"estimate_mode\\\"          (string, optional, default=UNSET) The fee estimate mode, must be one of:\\n\"\n+                            \"         \\\"UNSET\\\"\\n\"\n+                            \"         \\\"ECONOMICAL\\\"\\n\"\n+                            \"         \\\"CONSERVATIVE\\\"\\n\"\n+                            \"   }\\n\"\n+                            \"                         for backward compatibility: passing in a true instead of an object will result in {\\\"includeWatching\\\":true}\\n\"\n+                            \"3. iswitness               (boolean, optional) Whether the transaction hex is a serialized witness transaction \\n\"\n+                            \"                              If iswitness is not present, heuristic tests will be used in decoding\\n\"\n+\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"hex\\\":       \\\"value\\\", (string)  The resulting raw transaction (hex-encoded string)\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee in \" + CURRENCY_UNIT + \" the resulting transaction pays\\n\"\n+                            \"  \\\"changepos\\\": n          (numeric) The position of the added change output, or -1\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nCreate a transaction with no inputs\\n\"\n+                            + HelpExampleCli(\"createrawtransaction\", \"\\\"[]\\\" \\\"{\\\\\\\"myaddress\\\\\\\":0.01}\\\"\") +\n+                            \"\\nAdd sufficient unsigned inputs to meet the output value\\n\"\n+                            + HelpExampleCli(\"fundrawtransaction\", \"\\\"rawtransactionhex\\\"\") +\n+                            \"\\nSign the transaction\\n\"\n+                            + HelpExampleCli(\"signrawtransaction\", \"\\\"fundedtransactionhex\\\"\") +\n+                            \"\\nSend the transaction\\n\"\n+                            + HelpExampleCli(\"sendrawtransaction\", \"\\\"signedtransactionhex\\\"\")\n+                            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValueType(), UniValue::VBOOL});\n+\n+    // parse hex string from parameter\n+    CMutableTransaction tx;\n+    bool try_witness = request.params[2].isNull() ? true : request.params[2].get_bool();\n+    bool try_no_witness = request.params[2].isNull() ? true : !request.params[2].get_bool();\n+    if (!DecodeHexTx(tx, request.params[0].get_str(), try_no_witness, try_witness)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n+    }\n+\n+    CAmount fee;\n+    int change_position;\n+    FundTransaction(pwallet, tx, fee, change_position, request.params[1]);\n \n     UniValue result(UniValue::VOBJ);\n     result.pushKV(\"hex\", EncodeHexTx(tx));\n-    result.pushKV(\"changepos\", changePosition);\n-    result.pushKV(\"fee\", ValueFromAmount(nFeeOut));\n+    result.pushKV(\"fee\", ValueFromAmount(fee));",
    "path": "src/wallet/rpcwallet.cpp",
    "position": 229,
    "original_position": 229,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "37236e54c4797c85ef9d965f149ec4ca819d2f65",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Why swap these?",
    "created_at": "2018-06-30T19:00:41Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199329840",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199329840"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199329840"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199329840/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 3621,
    "original_line": 3621,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199329881",
    "pull_request_review_id": 133433770,
    "id": 199329881,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMyOTg4MQ==",
    "diff_hunk": "@@ -73,6 +76,538 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+// Magic bytes\n+static constexpr uint8_t PSBT_MAGIC_BYTES[4] = {'p', 's', 'b', 't'};\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static constexpr uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+template<typename Stream>\n+void DeserializeHDKeypaths(Stream& s, const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    // Make sure that the key is the size of pubkey + 1\n+    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+    }\n+    // Read in the pubkey from key\n+    CPubKey pubkey(key.begin() + 1, key.end());\n+    if (!pubkey.IsFullyValid()) {\n+       throw std::ios_base::failure(\"Invalid pubkey\");\n+    }\n+    if (hd_keypaths.count(pubkey) > 0) {\n+        throw std::ios_base::failure(\"Duplicate Key, pubkey derivation path already provided\");\n+    }\n+\n+    // Read in key path\n+    uint64_t value_len = ReadCompactSize(s);\n+    std::vector<uint32_t> keypath;\n+    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+        uint32_t index;\n+        s >> index;\n+        keypath.push_back(index);\n+    }\n+\n+    // Add to map\n+    hd_keypaths.emplace(pubkey, keypath);\n+}\n+\n+// Serialize HD keypaths to a stream from a map\n+template<typename Stream>\n+void SerializeHDKeypaths(Stream& s, const std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, uint8_t type)\n+{\n+    for (auto keypath_pair : hd_keypaths) {\n+        SerializeToVector(s, type, MakeSpan(keypath_pair.first));\n+        WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+        for (auto& path : keypath_pair.second) {\n+            s << path;\n+        }\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PSBTInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PSBTInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            SerializeHDKeypaths(s, hd_keypaths, PSBT_IN_BIP32_DERIVATION);\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // Read\n+            std::vector<unsigned char> key;\n+            s >> key;\n+\n+            // the key is empty if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key.empty()) return;\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    std::vector<unsigned char> sig;\n+                    s >> sig;\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, std::move(sig)));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    DeserializeHDKeypaths(s, key, hd_keypaths);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    std::vector<unsigned char> val_bytes;\n+                    s >> val_bytes;\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PSBTInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput\n+{\n+    CScript redeem_script;\n+    CScript witness_script;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    PSBTOutput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the redeem script\n+        if (!redeem_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_REDEEMSCRIPT);\n+            s << redeem_script;\n+        }\n+\n+        // Write the witness script\n+        if (!witness_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_WITNESSSCRIPT);\n+            s << witness_script;\n+        }\n+\n+        // Write any hd keypaths\n+        SerializeHDKeypaths(s, hd_keypaths, PSBT_OUT_BIP32_DERIVATION);\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // Read\n+            std::vector<unsigned char> key;\n+            s >> key;\n+\n+            // the key is empty if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key.empty()) return;\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_OUT_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_OUT_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_OUT_BIP32_DERIVATION:\n+                {\n+                    DeserializeHDKeypaths(s, key, hd_keypaths);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default: {\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    std::vector<unsigned char> val_bytes;\n+                    s >> val_bytes;\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PSBTOutput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 402,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "c7154487c6494882f6509a29a9854857a1ecba20",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Is this were a `std::unique_ptr<CMutableTransaction>` (or `boost::optional<CMutableTransaction>`), you could avoid the need for implementing `IsNull` or converting to `CTransaction` to decide whether it is set or not.",
    "created_at": "2018-06-30T19:02:23Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199329881",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199329881"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199329881"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199329881/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 466,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199330059",
    "pull_request_review_id": 133433770,
    "id": 199330059,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMzMDA1OQ==",
    "diff_hunk": "@@ -4388,6 +4391,333 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n+        return;\n+    }\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    std::vector<uint32_t> keypath;\n+    if (!meta.hdKeypath.empty()) {\n+        if (!ParseHDKeypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), ReadLE32(masterKey.key.GetPubKey().GetID().begin()));\n+    }\n+    // Single pubkeys get the master fingerprint of themselves\n+    else {\n+        keypath.insert(keypath.begin(), ReadLE32(vchPubKey.GetID().begin()));\n+    }\n+    hd_keypaths.emplace(vchPubKey, keypath);\n+}\n+\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type, bool sign)\n+{\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        CTxIn txin = txConst->vin[i];",
    "path": "src/wallet/rpcwallet.cpp",
    "position": null,
    "original_position": 313,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "a871194feebc4152ecc2130adcb67f3521c42dc8",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "You can use a const reference here to avoid a copy.",
    "created_at": "2018-06-30T19:08:59Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199330059",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199330059"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199330059"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199330059/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4469,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199330061",
    "pull_request_review_id": 133433770,
    "id": 199330061,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMzMDA2MQ==",
    "diff_hunk": "@@ -4388,6 +4391,333 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n+        return;\n+    }\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    std::vector<uint32_t> keypath;\n+    if (!meta.hdKeypath.empty()) {\n+        if (!ParseHDKeypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), ReadLE32(masterKey.key.GetPubKey().GetID().begin()));\n+    }\n+    // Single pubkeys get the master fingerprint of themselves\n+    else {\n+        keypath.insert(keypath.begin(), ReadLE32(vchPubKey.GetID().begin()));\n+    }\n+    hd_keypaths.emplace(vchPubKey, keypath);\n+}\n+\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type, bool sign)\n+{\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        CTxIn txin = txConst->vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        uint256 txhash = txin.prevout.hash;",
    "path": "src/wallet/rpcwallet.cpp",
    "position": null,
    "original_position": 317,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "a871194feebc4152ecc2130adcb67f3521c42dc8",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Same here.",
    "created_at": "2018-06-30T19:09:06Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199330061",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199330061"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199330061"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199330061/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4473,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199330073",
    "pull_request_review_id": 133433770,
    "id": 199330073,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMzMDA3Mw==",
    "diff_hunk": "@@ -1259,6 +1263,553 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str.substr(0, keypath_str.size() - 1); // Drop last '/'\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"          {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"       ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"        }\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                UniValue sig_univ(UniValue::VOBJ);\n+                sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                partial_sigs.push_back(sig_univ);\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"psbt\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner and Finalizer roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+    psbtxs.erase(psbtxs.begin());\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != merged_psbt) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    // Merge them\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        merged_psbt.Merge(psbtx);\n+    }\n+    if (!merged_psbt.IsSane()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is inconsistent\");\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"psbt\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\\n\"\n+            \"Implements the Finalizer and Extractor roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded network transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx.vin.size(); ++i) {\n+        CTxIn txin = psbtx.tx.vin[i];",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 603,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "a871194feebc4152ecc2130adcb67f3521c42dc8",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Unused variable.",
    "created_at": "2018-06-30T19:09:47Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199330073",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199330073"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199330073"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199330073/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1661,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199330188",
    "pull_request_review_id": 133433770,
    "id": 199330188,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMzMDE4OA==",
    "diff_hunk": "@@ -4388,6 +4391,333 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n+        return;\n+    }\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    std::vector<uint32_t> keypath;\n+    if (!meta.hdKeypath.empty()) {\n+        if (!ParseHDKeypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), ReadLE32(masterKey.key.GetPubKey().GetID().begin()));\n+    }\n+    // Single pubkeys get the master fingerprint of themselves\n+    else {\n+        keypath.insert(keypath.begin(), ReadLE32(vchPubKey.GetID().begin()));\n+    }\n+    hd_keypaths.emplace(vchPubKey, keypath);\n+}\n+\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type, bool sign)\n+{\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        CTxIn txin = txConst->vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        uint256 txhash = txin.prevout.hash;\n+        if (pwallet->mapWallet.count(txhash)) {\n+            const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+            CTxOut utxo = wtx.tx->vout[txin.prevout.n];\n+            input.non_witness_utxo = wtx.tx;\n+            input.witness_utxo = utxo;\n+        }\n+\n+        // Get the Sighash type\n+        int sighash = sighash_type;\n+        if (input.sighash_type > 0) {\n+            sighash = input.sighash_type;\n+        }\n+\n+        SignatureData sigdata;\n+        complete &= SignPSBTInput(*pwallet, psbtx.tx, input, sigdata, i, sighash, sign);\n+\n+        // Drop the unnecessary UTXO\n+        if (sigdata.witness) {\n+            input.non_witness_utxo = nullptr;\n+        } else {\n+            input.witness_utxo.SetNull();\n+        }\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, input.hd_keypaths);\n+        }\n+    }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    for (unsigned int i = 0; i < txConst->vout.size(); ++i) {\n+        const CTxOut& out = txConst->vout.at(i);\n+        PSBTOutput& psbt_out = psbtx.outputs.at(i);\n+\n+        // Dummy tx so we can use ProduceSignature to get stuff out\n+        CMutableTransaction dummy_tx;\n+        dummy_tx.vin.push_back(CTxIn());\n+        dummy_tx.vout.push_back(CTxOut());\n+\n+        // Fill a SignatureData with output info\n+        SignatureData sigdata;\n+        psbt_out.FillSignatureData(sigdata);\n+\n+        MutableTransactionSignatureCreator creator(&psbtx.tx, 0, out.nValue, 1);\n+        ProduceSignature(*pwallet, creator, out.scriptPubKey, sigdata);\n+        psbt_out.FromSignatureData(sigdata);\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, psbt_out.hd_keypaths);\n+        }\n+    }\n+    return complete;\n+}\n+\n+UniValue walletprocesspsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"walletprocesspsbt \\\"psbt\\\" ( sign sighashtype )\\n\"\n+            \"\\nUpdate a PSBT with input information from our wallet and then sign inputs\\n\"\n+            \"that we can sign for.\\n\"\n+            + HelpRequiringPassphrase(pwallet) + \"\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                      (string, required) The transaction base64 string\\n\"\n+            \"2. \\\"sign\\\",                     (string, optional, default=true) Also sign the transaction when updating\\n\"\n+            \"3. \\\"sighashtype\\\"            (string, optional, default=ALL) The signature hash type to sign with if not specified by the PSBT. Must be one of\\n\"",
    "path": "src/wallet/rpcwallet.cpp",
    "position": null,
    "original_position": 392,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "a871194feebc4152ecc2130adcb67f3521c42dc8",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I think the semantics should be to fail if the specified sighash type (or the default) does not match the sighash type in the PSBT.",
    "created_at": "2018-06-30T19:14:38Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199330188",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199330188"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199330188"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199330188/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4554,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199330230",
    "pull_request_review_id": 133433770,
    "id": 199330230,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMzMDIzMA==",
    "diff_hunk": "@@ -4388,6 +4391,333 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n+        return;\n+    }\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    std::vector<uint32_t> keypath;\n+    if (!meta.hdKeypath.empty()) {\n+        if (!ParseHDKeypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), ReadLE32(masterKey.key.GetPubKey().GetID().begin()));\n+    }\n+    // Single pubkeys get the master fingerprint of themselves\n+    else {\n+        keypath.insert(keypath.begin(), ReadLE32(vchPubKey.GetID().begin()));\n+    }\n+    hd_keypaths.emplace(vchPubKey, keypath);\n+}\n+\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type, bool sign)\n+{\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        CTxIn txin = txConst->vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        uint256 txhash = txin.prevout.hash;\n+        if (pwallet->mapWallet.count(txhash)) {\n+            const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+            CTxOut utxo = wtx.tx->vout[txin.prevout.n];\n+            input.non_witness_utxo = wtx.tx;\n+            input.witness_utxo = utxo;\n+        }\n+\n+        // Get the Sighash type\n+        int sighash = sighash_type;\n+        if (input.sighash_type > 0) {\n+            sighash = input.sighash_type;\n+        }\n+\n+        SignatureData sigdata;\n+        complete &= SignPSBTInput(*pwallet, psbtx.tx, input, sigdata, i, sighash, sign);",
    "path": "src/wallet/rpcwallet.cpp",
    "position": null,
    "original_position": 332,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "a871194feebc4152ecc2130adcb67f3521c42dc8",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "If you'd have a `SigningProvider` wrapper that removes access to private keys, you could use that instead of passing down a `sign` variable. The other call site doesn't need a `sign` anyway, as it's using a dummy provider.\r\n",
    "created_at": "2018-06-30T19:17:05Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199330230",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199330230"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199330230"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199330230/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4488,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199330273",
    "pull_request_review_id": 133433770,
    "id": 199330273,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTMzMDI3Mw==",
    "diff_hunk": "@@ -4388,6 +4391,333 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n+        return;\n+    }\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    std::vector<uint32_t> keypath;\n+    if (!meta.hdKeypath.empty()) {\n+        if (!ParseHDKeypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), ReadLE32(masterKey.key.GetPubKey().GetID().begin()));\n+    }\n+    // Single pubkeys get the master fingerprint of themselves\n+    else {\n+        keypath.insert(keypath.begin(), ReadLE32(vchPubKey.GetID().begin()));\n+    }\n+    hd_keypaths.emplace(vchPubKey, keypath);\n+}\n+\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type, bool sign)\n+{\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        CTxIn txin = txConst->vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        uint256 txhash = txin.prevout.hash;\n+        if (pwallet->mapWallet.count(txhash)) {\n+            const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+            CTxOut utxo = wtx.tx->vout[txin.prevout.n];\n+            input.non_witness_utxo = wtx.tx;\n+            input.witness_utxo = utxo;\n+        }\n+\n+        // Get the Sighash type\n+        int sighash = sighash_type;\n+        if (input.sighash_type > 0) {\n+            sighash = input.sighash_type;\n+        }\n+\n+        SignatureData sigdata;\n+        complete &= SignPSBTInput(*pwallet, psbtx.tx, input, sigdata, i, sighash, sign);\n+\n+        // Drop the unnecessary UTXO\n+        if (sigdata.witness) {\n+            input.non_witness_utxo = nullptr;\n+        } else {\n+            input.witness_utxo.SetNull();\n+        }\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, input.hd_keypaths);\n+        }\n+    }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    for (unsigned int i = 0; i < txConst->vout.size(); ++i) {\n+        const CTxOut& out = txConst->vout.at(i);\n+        PSBTOutput& psbt_out = psbtx.outputs.at(i);\n+\n+        // Dummy tx so we can use ProduceSignature to get stuff out\n+        CMutableTransaction dummy_tx;\n+        dummy_tx.vin.push_back(CTxIn());\n+        dummy_tx.vout.push_back(CTxOut());\n+\n+        // Fill a SignatureData with output info\n+        SignatureData sigdata;\n+        psbt_out.FillSignatureData(sigdata);\n+\n+        MutableTransactionSignatureCreator creator(&psbtx.tx, 0, out.nValue, 1);\n+        ProduceSignature(*pwallet, creator, out.scriptPubKey, sigdata);\n+        psbt_out.FromSignatureData(sigdata);\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, psbt_out.hd_keypaths);\n+        }\n+    }\n+    return complete;\n+}\n+\n+UniValue walletprocesspsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"walletprocesspsbt \\\"psbt\\\" ( sign sighashtype )\\n\"\n+            \"\\nUpdate a PSBT with input information from our wallet and then sign inputs\\n\"\n+            \"that we can sign for.\\n\"\n+            + HelpRequiringPassphrase(pwallet) + \"\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                      (string, required) The transaction base64 string\\n\"\n+            \"2. \\\"sign\\\",                     (string, optional, default=true) Also sign the transaction when updating\\n\"\n+            \"3. \\\"sighashtype\\\"            (string, optional, default=ALL) The signature hash type to sign with if not specified by the PSBT. Must be one of\\n\"\n+            \"       \\\"ALL\\\"\\n\"\n+            \"       \\\"NONE\\\"\\n\"\n+            \"       \\\"SINGLE\\\"\\n\"\n+            \"       \\\"ALL|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"NONE|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"SINGLE|ANYONECANPAY\\\"\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"walletprocesspsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    LOCK2(cs_main, pwallet->cs_wallet);\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL, UniValue::VSTR});\n+\n+    // Unserialize the transaction\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get the sighash type\n+    int nHashType = SIGHASH_ALL;\n+    if (!request.params[2].isNull()) {\n+        static std::map<std::string, int> mapSigHashValues = {\n+            {std::string(\"ALL\"), int(SIGHASH_ALL)},\n+            {std::string(\"ALL|ANYONECANPAY\"), int(SIGHASH_ALL|SIGHASH_ANYONECANPAY)},\n+            {std::string(\"NONE\"), int(SIGHASH_NONE)},\n+            {std::string(\"NONE|ANYONECANPAY\"), int(SIGHASH_NONE|SIGHASH_ANYONECANPAY)},\n+            {std::string(\"SINGLE\"), int(SIGHASH_SINGLE)},\n+            {std::string(\"SINGLE|ANYONECANPAY\"), int(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY)},\n+        };\n+        std::string strHashType = request.params[1].get_str();\n+        if (mapSigHashValues.count(strHashType)) {\n+            nHashType = mapSigHashValues[strHashType];\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid sighash param\");\n+        }\n+    }\n+\n+    // Script verification errors\n+    UniValue vErrors(UniValue::VARR);\n+\n+    // Use CTransaction for the constant parts of the\n+    // transaction to avoid rehashing.\n+    const CTransaction txConst(psbtx.tx);\n+\n+    // Fill transaction with our data and also sign\n+    bool sign = request.params[1].isNull() ? true : request.params[1].get_bool();\n+    bool fComplete = FillPSBT(pwallet, psbtx, &txConst, nHashType, sign);\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+    result.push_back(Pair(\"psbt\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size())));\n+    result.push_back(Pair(\"complete\", fComplete));\n+\n+    return result;\n+}\n+\n+UniValue walletcreatefundedpsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 5)\n+        throw std::runtime_error(\n+                            \"walletcreatefundedpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable ) ( options )\\n\"",
    "path": "src/wallet/rpcwallet.cpp",
    "position": null,
    "original_position": 471,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "a871194feebc4152ecc2130adcb67f3521c42dc8",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Thinking more about this, I can't find a reason why someone would not want to also Update the PSBT. Since in this case, the wallet is adding inputs and change, it is exactly in the position to also add keys/scripts/utxos for those. It shouldn't include signing, though.",
    "created_at": "2018-06-30T19:19:53Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199330273",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199330273"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199330273"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199330273/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4609,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199589534",
    "pull_request_review_id": 133738880,
    "id": 199589534,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTU4OTUzNA==",
    "diff_hunk": "@@ -3607,17 +3529,98 @@ static UniValue fundrawtransaction(const JSONRPCRequest& request)\n         setSubtractFeeFromOutputs.insert(pos);\n     }\n \n-    CAmount nFeeOut;\n     std::string strFailReason;\n \n-    if (!pwallet->FundTransaction(tx, nFeeOut, changePosition, strFailReason, lockUnspents, setSubtractFeeFromOutputs, coinControl)) {\n+    if (!pwallet->FundTransaction(tx, fee_out, change_position, strFailReason, lockUnspents, setSubtractFeeFromOutputs, coinControl)) {\n         throw JSONRPCError(RPC_WALLET_ERROR, strFailReason);\n     }\n+}\n+\n+static UniValue fundrawtransaction(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+                            \"fundrawtransaction \\\"hexstring\\\" ( options iswitness )\\n\"\n+                            \"\\nAdd inputs to a transaction until it has enough in value to meet its out value.\\n\"\n+                            \"This will not modify existing inputs, and will add at most one change output to the outputs.\\n\"\n+                            \"No existing outputs will be modified unless \\\"subtractFeeFromOutputs\\\" is specified.\\n\"\n+                            \"Note that inputs which were signed may need to be resigned after completion since in/outputs have been added.\\n\"\n+                            \"The inputs added will not be signed, use signrawtransaction for that.\\n\"\n+                            \"Note that all existing inputs must have their previous output transaction be in the wallet.\\n\"\n+                            \"Note that all inputs selected must be of standard form and P2SH scripts must be\\n\"\n+                            \"in the wallet using importaddress or addmultisigaddress (to calculate fees).\\n\"\n+                            \"You can see whether this is the case by checking the \\\"solvable\\\" field in the listunspent output.\\n\"\n+                            \"Only pay-to-pubkey, multisig, and P2SH versions thereof are currently supported for watch-only\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"hexstring\\\"           (string, required) The hex string of the raw transaction\\n\"\n+                            \"2. options                 (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"changeAddress\\\"          (string, optional, default pool address) The bitcoin address to receive the change\\n\"\n+                            \"     \\\"changePosition\\\"         (numeric, optional, default random) The index of the change output\\n\"\n+                            \"     \\\"change_type\\\"            (string, optional) The output type to use. Only valid if changeAddress is not specified. Options are \\\"legacy\\\", \\\"p2sh-segwit\\\", and \\\"bech32\\\". Default is set by -changetype.\\n\"\n+                            \"     \\\"includeWatching\\\"        (boolean, optional, default false) Also select inputs which are watch only\\n\"\n+                            \"     \\\"lockUnspents\\\"           (boolean, optional, default false) Lock selected unspent outputs\\n\"\n+                            \"     \\\"feeRate\\\"                (numeric, optional, default not set: makes wallet determine the fee) Set a specific fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"\n+                            \"     \\\"subtractFeeFromOutputs\\\" (array, optional) A json array of integers.\\n\"\n+                            \"                              The fee will be equally deducted from the amount of each specified output.\\n\"\n+                            \"                              The outputs are specified by their zero-based index, before any change output is added.\\n\"\n+                            \"                              Those recipients will receive less bitcoins than you enter in their corresponding amount field.\\n\"\n+                            \"                              If no outputs are specified here, the sender pays the fee.\\n\"\n+                            \"                                  [vout_index,...]\\n\"\n+                            \"     \\\"replaceable\\\"            (boolean, optional) Marks this transaction as BIP125 replaceable.\\n\"\n+                            \"                              Allows this transaction to be replaced by a transaction with higher fees\\n\"\n+                            \"     \\\"conf_target\\\"            (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"estimate_mode\\\"          (string, optional, default=UNSET) The fee estimate mode, must be one of:\\n\"\n+                            \"         \\\"UNSET\\\"\\n\"\n+                            \"         \\\"ECONOMICAL\\\"\\n\"\n+                            \"         \\\"CONSERVATIVE\\\"\\n\"\n+                            \"   }\\n\"\n+                            \"                         for backward compatibility: passing in a true instead of an object will result in {\\\"includeWatching\\\":true}\\n\"\n+                            \"3. iswitness               (boolean, optional) Whether the transaction hex is a serialized witness transaction \\n\"\n+                            \"                              If iswitness is not present, heuristic tests will be used in decoding\\n\"\n+\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"hex\\\":       \\\"value\\\", (string)  The resulting raw transaction (hex-encoded string)\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee in \" + CURRENCY_UNIT + \" the resulting transaction pays\\n\"\n+                            \"  \\\"changepos\\\": n          (numeric) The position of the added change output, or -1\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nCreate a transaction with no inputs\\n\"\n+                            + HelpExampleCli(\"createrawtransaction\", \"\\\"[]\\\" \\\"{\\\\\\\"myaddress\\\\\\\":0.01}\\\"\") +\n+                            \"\\nAdd sufficient unsigned inputs to meet the output value\\n\"\n+                            + HelpExampleCli(\"fundrawtransaction\", \"\\\"rawtransactionhex\\\"\") +\n+                            \"\\nSign the transaction\\n\"\n+                            + HelpExampleCli(\"signrawtransaction\", \"\\\"fundedtransactionhex\\\"\") +\n+                            \"\\nSend the transaction\\n\"\n+                            + HelpExampleCli(\"sendrawtransaction\", \"\\\"signedtransactionhex\\\"\")\n+                            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValueType(), UniValue::VBOOL});\n+\n+    // parse hex string from parameter\n+    CMutableTransaction tx;\n+    bool try_witness = request.params[2].isNull() ? true : request.params[2].get_bool();\n+    bool try_no_witness = request.params[2].isNull() ? true : !request.params[2].get_bool();\n+    if (!DecodeHexTx(tx, request.params[0].get_str(), try_no_witness, try_witness)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n+    }\n+\n+    CAmount fee;\n+    int change_position;\n+    FundTransaction(pwallet, tx, fee, change_position, request.params[1]);\n \n     UniValue result(UniValue::VOBJ);\n     result.pushKV(\"hex\", EncodeHexTx(tx));\n-    result.pushKV(\"changepos\", changePosition);\n-    result.pushKV(\"fee\", ValueFromAmount(nFeeOut));\n+    result.pushKV(\"fee\", ValueFromAmount(fee));",
    "path": "src/wallet/rpcwallet.cpp",
    "position": 229,
    "original_position": 229,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "37236e54c4797c85ef9d965f149ec4ca819d2f65",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "To match the order in the help text.",
    "created_at": "2018-07-02T18:51:58Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199589534",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199589534"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199589534"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199589534/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 3621,
    "original_line": 3621,
    "side": "RIGHT",
    "in_reply_to_id": 199329840
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199602121",
    "pull_request_review_id": 133754450,
    "id": 199602121,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTYwMjEyMQ==",
    "diff_hunk": "@@ -4388,6 +4391,333 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n+        return;\n+    }\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    std::vector<uint32_t> keypath;\n+    if (!meta.hdKeypath.empty()) {\n+        if (!ParseHDKeypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), ReadLE32(masterKey.key.GetPubKey().GetID().begin()));\n+    }\n+    // Single pubkeys get the master fingerprint of themselves\n+    else {\n+        keypath.insert(keypath.begin(), ReadLE32(vchPubKey.GetID().begin()));\n+    }\n+    hd_keypaths.emplace(vchPubKey, keypath);\n+}\n+\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type, bool sign)\n+{\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        CTxIn txin = txConst->vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        uint256 txhash = txin.prevout.hash;\n+        if (pwallet->mapWallet.count(txhash)) {\n+            const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+            CTxOut utxo = wtx.tx->vout[txin.prevout.n];\n+            input.non_witness_utxo = wtx.tx;\n+            input.witness_utxo = utxo;\n+        }\n+\n+        // Get the Sighash type\n+        int sighash = sighash_type;\n+        if (input.sighash_type > 0) {\n+            sighash = input.sighash_type;\n+        }\n+\n+        SignatureData sigdata;\n+        complete &= SignPSBTInput(*pwallet, psbtx.tx, input, sigdata, i, sighash, sign);\n+\n+        // Drop the unnecessary UTXO\n+        if (sigdata.witness) {\n+            input.non_witness_utxo = nullptr;\n+        } else {\n+            input.witness_utxo.SetNull();\n+        }\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, input.hd_keypaths);\n+        }\n+    }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    for (unsigned int i = 0; i < txConst->vout.size(); ++i) {\n+        const CTxOut& out = txConst->vout.at(i);\n+        PSBTOutput& psbt_out = psbtx.outputs.at(i);\n+\n+        // Dummy tx so we can use ProduceSignature to get stuff out\n+        CMutableTransaction dummy_tx;\n+        dummy_tx.vin.push_back(CTxIn());\n+        dummy_tx.vout.push_back(CTxOut());\n+\n+        // Fill a SignatureData with output info\n+        SignatureData sigdata;\n+        psbt_out.FillSignatureData(sigdata);\n+\n+        MutableTransactionSignatureCreator creator(&psbtx.tx, 0, out.nValue, 1);\n+        ProduceSignature(*pwallet, creator, out.scriptPubKey, sigdata);\n+        psbt_out.FromSignatureData(sigdata);\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, psbt_out.hd_keypaths);\n+        }\n+    }\n+    return complete;\n+}\n+\n+UniValue walletprocesspsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"walletprocesspsbt \\\"psbt\\\" ( sign sighashtype )\\n\"\n+            \"\\nUpdate a PSBT with input information from our wallet and then sign inputs\\n\"\n+            \"that we can sign for.\\n\"\n+            + HelpRequiringPassphrase(pwallet) + \"\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                      (string, required) The transaction base64 string\\n\"\n+            \"2. \\\"sign\\\",                     (string, optional, default=true) Also sign the transaction when updating\\n\"\n+            \"3. \\\"sighashtype\\\"            (string, optional, default=ALL) The signature hash type to sign with if not specified by the PSBT. Must be one of\\n\"\n+            \"       \\\"ALL\\\"\\n\"\n+            \"       \\\"NONE\\\"\\n\"\n+            \"       \\\"SINGLE\\\"\\n\"\n+            \"       \\\"ALL|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"NONE|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"SINGLE|ANYONECANPAY\\\"\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"walletprocesspsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    LOCK2(cs_main, pwallet->cs_wallet);\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL, UniValue::VSTR});\n+\n+    // Unserialize the transaction\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get the sighash type\n+    int nHashType = SIGHASH_ALL;\n+    if (!request.params[2].isNull()) {\n+        static std::map<std::string, int> mapSigHashValues = {\n+            {std::string(\"ALL\"), int(SIGHASH_ALL)},\n+            {std::string(\"ALL|ANYONECANPAY\"), int(SIGHASH_ALL|SIGHASH_ANYONECANPAY)},\n+            {std::string(\"NONE\"), int(SIGHASH_NONE)},\n+            {std::string(\"NONE|ANYONECANPAY\"), int(SIGHASH_NONE|SIGHASH_ANYONECANPAY)},\n+            {std::string(\"SINGLE\"), int(SIGHASH_SINGLE)},\n+            {std::string(\"SINGLE|ANYONECANPAY\"), int(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY)},\n+        };\n+        std::string strHashType = request.params[1].get_str();\n+        if (mapSigHashValues.count(strHashType)) {\n+            nHashType = mapSigHashValues[strHashType];\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid sighash param\");\n+        }\n+    }\n+\n+    // Script verification errors\n+    UniValue vErrors(UniValue::VARR);\n+\n+    // Use CTransaction for the constant parts of the\n+    // transaction to avoid rehashing.\n+    const CTransaction txConst(psbtx.tx);\n+\n+    // Fill transaction with our data and also sign\n+    bool sign = request.params[1].isNull() ? true : request.params[1].get_bool();\n+    bool fComplete = FillPSBT(pwallet, psbtx, &txConst, nHashType, sign);\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+    result.push_back(Pair(\"psbt\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size())));\n+    result.push_back(Pair(\"complete\", fComplete));\n+\n+    return result;\n+}\n+\n+UniValue walletcreatefundedpsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 5)\n+        throw std::runtime_error(\n+                            \"walletcreatefundedpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable ) ( options )\\n\"",
    "path": "src/wallet/rpcwallet.cpp",
    "position": null,
    "original_position": 471,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "a871194feebc4152ecc2130adcb67f3521c42dc8",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "In order to sign the PSBT, you still have to use `walletupdatepsbt` and that will update the PSBT at the same time.",
    "created_at": "2018-07-02T19:48:40Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199602121",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199602121"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199602121"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199602121/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4609,
    "side": "RIGHT",
    "in_reply_to_id": 199330273
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199603524",
    "pull_request_review_id": 133756154,
    "id": 199603524,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTYwMzUyNA==",
    "diff_hunk": "@@ -4388,6 +4391,333 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n+        return;\n+    }\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    std::vector<uint32_t> keypath;\n+    if (!meta.hdKeypath.empty()) {\n+        if (!ParseHDKeypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), ReadLE32(masterKey.key.GetPubKey().GetID().begin()));\n+    }\n+    // Single pubkeys get the master fingerprint of themselves\n+    else {\n+        keypath.insert(keypath.begin(), ReadLE32(vchPubKey.GetID().begin()));\n+    }\n+    hd_keypaths.emplace(vchPubKey, keypath);\n+}\n+\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type, bool sign)\n+{\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        CTxIn txin = txConst->vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        uint256 txhash = txin.prevout.hash;\n+        if (pwallet->mapWallet.count(txhash)) {\n+            const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+            CTxOut utxo = wtx.tx->vout[txin.prevout.n];\n+            input.non_witness_utxo = wtx.tx;\n+            input.witness_utxo = utxo;\n+        }\n+\n+        // Get the Sighash type\n+        int sighash = sighash_type;\n+        if (input.sighash_type > 0) {\n+            sighash = input.sighash_type;\n+        }\n+\n+        SignatureData sigdata;\n+        complete &= SignPSBTInput(*pwallet, psbtx.tx, input, sigdata, i, sighash, sign);\n+\n+        // Drop the unnecessary UTXO\n+        if (sigdata.witness) {\n+            input.non_witness_utxo = nullptr;\n+        } else {\n+            input.witness_utxo.SetNull();\n+        }\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, input.hd_keypaths);\n+        }\n+    }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    for (unsigned int i = 0; i < txConst->vout.size(); ++i) {\n+        const CTxOut& out = txConst->vout.at(i);\n+        PSBTOutput& psbt_out = psbtx.outputs.at(i);\n+\n+        // Dummy tx so we can use ProduceSignature to get stuff out\n+        CMutableTransaction dummy_tx;\n+        dummy_tx.vin.push_back(CTxIn());\n+        dummy_tx.vout.push_back(CTxOut());\n+\n+        // Fill a SignatureData with output info\n+        SignatureData sigdata;\n+        psbt_out.FillSignatureData(sigdata);\n+\n+        MutableTransactionSignatureCreator creator(&psbtx.tx, 0, out.nValue, 1);\n+        ProduceSignature(*pwallet, creator, out.scriptPubKey, sigdata);\n+        psbt_out.FromSignatureData(sigdata);\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, psbt_out.hd_keypaths);\n+        }\n+    }\n+    return complete;\n+}\n+\n+UniValue walletprocesspsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"walletprocesspsbt \\\"psbt\\\" ( sign sighashtype )\\n\"\n+            \"\\nUpdate a PSBT with input information from our wallet and then sign inputs\\n\"\n+            \"that we can sign for.\\n\"\n+            + HelpRequiringPassphrase(pwallet) + \"\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                      (string, required) The transaction base64 string\\n\"\n+            \"2. \\\"sign\\\",                     (string, optional, default=true) Also sign the transaction when updating\\n\"\n+            \"3. \\\"sighashtype\\\"            (string, optional, default=ALL) The signature hash type to sign with if not specified by the PSBT. Must be one of\\n\"\n+            \"       \\\"ALL\\\"\\n\"\n+            \"       \\\"NONE\\\"\\n\"\n+            \"       \\\"SINGLE\\\"\\n\"\n+            \"       \\\"ALL|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"NONE|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"SINGLE|ANYONECANPAY\\\"\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"walletprocesspsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    LOCK2(cs_main, pwallet->cs_wallet);\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL, UniValue::VSTR});\n+\n+    // Unserialize the transaction\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get the sighash type\n+    int nHashType = SIGHASH_ALL;\n+    if (!request.params[2].isNull()) {\n+        static std::map<std::string, int> mapSigHashValues = {\n+            {std::string(\"ALL\"), int(SIGHASH_ALL)},\n+            {std::string(\"ALL|ANYONECANPAY\"), int(SIGHASH_ALL|SIGHASH_ANYONECANPAY)},\n+            {std::string(\"NONE\"), int(SIGHASH_NONE)},\n+            {std::string(\"NONE|ANYONECANPAY\"), int(SIGHASH_NONE|SIGHASH_ANYONECANPAY)},\n+            {std::string(\"SINGLE\"), int(SIGHASH_SINGLE)},\n+            {std::string(\"SINGLE|ANYONECANPAY\"), int(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY)},\n+        };\n+        std::string strHashType = request.params[1].get_str();\n+        if (mapSigHashValues.count(strHashType)) {\n+            nHashType = mapSigHashValues[strHashType];\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid sighash param\");\n+        }\n+    }\n+\n+    // Script verification errors\n+    UniValue vErrors(UniValue::VARR);\n+\n+    // Use CTransaction for the constant parts of the\n+    // transaction to avoid rehashing.\n+    const CTransaction txConst(psbtx.tx);\n+\n+    // Fill transaction with our data and also sign\n+    bool sign = request.params[1].isNull() ? true : request.params[1].get_bool();\n+    bool fComplete = FillPSBT(pwallet, psbtx, &txConst, nHashType, sign);\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+    result.push_back(Pair(\"psbt\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size())));\n+    result.push_back(Pair(\"complete\", fComplete));\n+\n+    return result;\n+}\n+\n+UniValue walletcreatefundedpsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 5)\n+        throw std::runtime_error(\n+                            \"walletcreatefundedpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable ) ( options )\\n\"",
    "path": "src/wallet/rpcwallet.cpp",
    "position": null,
    "original_position": 471,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "a871194feebc4152ecc2130adcb67f3521c42dc8",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I meant: why should createfunded not automatically update? It by definition has all the data available, and I don't think there is a reason why you wouldn't run update immediately after anyway.",
    "created_at": "2018-07-02T19:55:15Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199603524",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199603524"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199603524"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199603524/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4609,
    "side": "RIGHT",
    "in_reply_to_id": 199330273
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199622754",
    "pull_request_review_id": 133779118,
    "id": 199622754,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTYyMjc1NA==",
    "diff_hunk": "@@ -73,6 +76,538 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+// Magic bytes\n+static constexpr uint8_t PSBT_MAGIC_BYTES[4] = {'p', 's', 'b', 't'};\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static constexpr uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+template<typename Stream>\n+void DeserializeHDKeypaths(Stream& s, const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    // Make sure that the key is the size of pubkey + 1\n+    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+    }\n+    // Read in the pubkey from key\n+    CPubKey pubkey(key.begin() + 1, key.end());\n+    if (!pubkey.IsFullyValid()) {\n+       throw std::ios_base::failure(\"Invalid pubkey\");\n+    }\n+    if (hd_keypaths.count(pubkey) > 0) {\n+        throw std::ios_base::failure(\"Duplicate Key, pubkey derivation path already provided\");\n+    }\n+\n+    // Read in key path\n+    uint64_t value_len = ReadCompactSize(s);\n+    std::vector<uint32_t> keypath;\n+    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+        uint32_t index;\n+        s >> index;\n+        keypath.push_back(index);\n+    }\n+\n+    // Add to map\n+    hd_keypaths.emplace(pubkey, keypath);\n+}\n+\n+// Serialize HD keypaths to a stream from a map\n+template<typename Stream>\n+void SerializeHDKeypaths(Stream& s, const std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, uint8_t type)\n+{\n+    for (auto keypath_pair : hd_keypaths) {\n+        SerializeToVector(s, type, MakeSpan(keypath_pair.first));\n+        WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+        for (auto& path : keypath_pair.second) {\n+            s << path;\n+        }\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PSBTInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PSBTInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            SerializeHDKeypaths(s, hd_keypaths, PSBT_IN_BIP32_DERIVATION);\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // Read\n+            std::vector<unsigned char> key;\n+            s >> key;\n+\n+            // the key is empty if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key.empty()) return;\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    std::vector<unsigned char> sig;\n+                    s >> sig;\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, std::move(sig)));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    DeserializeHDKeypaths(s, key, hd_keypaths);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    std::vector<unsigned char> val_bytes;\n+                    s >> val_bytes;\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PSBTInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput\n+{\n+    CScript redeem_script;\n+    CScript witness_script;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    PSBTOutput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the redeem script\n+        if (!redeem_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_REDEEMSCRIPT);\n+            s << redeem_script;\n+        }\n+\n+        // Write the witness script\n+        if (!witness_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_WITNESSSCRIPT);\n+            s << witness_script;\n+        }\n+\n+        // Write any hd keypaths\n+        SerializeHDKeypaths(s, hd_keypaths, PSBT_OUT_BIP32_DERIVATION);\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // Read\n+            std::vector<unsigned char> key;\n+            s >> key;\n+\n+            // the key is empty if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key.empty()) return;\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_OUT_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_OUT_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_OUT_BIP32_DERIVATION:\n+                {\n+                    DeserializeHDKeypaths(s, key, hd_keypaths);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default: {\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    std::vector<unsigned char> val_bytes;\n+                    s >> val_bytes;\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PSBTOutput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 402,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "c7154487c6494882f6509a29a9854857a1ecba20",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Made into a `boost::optional`",
    "created_at": "2018-07-02T21:13:00Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199622754",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199622754"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199622754"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199622754/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 466,
    "side": "RIGHT",
    "in_reply_to_id": 199329881
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199622782",
    "pull_request_review_id": 133779145,
    "id": 199622782,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTYyMjc4Mg==",
    "diff_hunk": "@@ -4388,6 +4391,333 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n+        return;\n+    }\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    std::vector<uint32_t> keypath;\n+    if (!meta.hdKeypath.empty()) {\n+        if (!ParseHDKeypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), ReadLE32(masterKey.key.GetPubKey().GetID().begin()));\n+    }\n+    // Single pubkeys get the master fingerprint of themselves\n+    else {\n+        keypath.insert(keypath.begin(), ReadLE32(vchPubKey.GetID().begin()));\n+    }\n+    hd_keypaths.emplace(vchPubKey, keypath);\n+}\n+\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type, bool sign)\n+{\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        CTxIn txin = txConst->vin[i];",
    "path": "src/wallet/rpcwallet.cpp",
    "position": null,
    "original_position": 313,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "a871194feebc4152ecc2130adcb67f3521c42dc8",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-07-02T21:13:06Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199622782",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199622782"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199622782"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199622782/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4469,
    "side": "RIGHT",
    "in_reply_to_id": 199330059
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199622799",
    "pull_request_review_id": 133779161,
    "id": 199622799,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTYyMjc5OQ==",
    "diff_hunk": "@@ -4388,6 +4391,333 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n+        return;\n+    }\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    std::vector<uint32_t> keypath;\n+    if (!meta.hdKeypath.empty()) {\n+        if (!ParseHDKeypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), ReadLE32(masterKey.key.GetPubKey().GetID().begin()));\n+    }\n+    // Single pubkeys get the master fingerprint of themselves\n+    else {\n+        keypath.insert(keypath.begin(), ReadLE32(vchPubKey.GetID().begin()));\n+    }\n+    hd_keypaths.emplace(vchPubKey, keypath);\n+}\n+\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type, bool sign)\n+{\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        CTxIn txin = txConst->vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        uint256 txhash = txin.prevout.hash;",
    "path": "src/wallet/rpcwallet.cpp",
    "position": null,
    "original_position": 317,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "a871194feebc4152ecc2130adcb67f3521c42dc8",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-07-02T21:13:10Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199622799",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199622799"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199622799"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199622799/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4473,
    "side": "RIGHT",
    "in_reply_to_id": 199330061
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199622836",
    "pull_request_review_id": 133779202,
    "id": 199622836,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTYyMjgzNg==",
    "diff_hunk": "@@ -1259,6 +1263,553 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str.substr(0, keypath_str.size() - 1); // Drop last '/'\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"          {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"       ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"        }\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                UniValue sig_univ(UniValue::VOBJ);\n+                sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                partial_sigs.push_back(sig_univ);\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"psbt\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner and Finalizer roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+    psbtxs.erase(psbtxs.begin());\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != merged_psbt) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    // Merge them\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        merged_psbt.Merge(psbtx);\n+    }\n+    if (!merged_psbt.IsSane()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is inconsistent\");\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"psbt\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\\n\"\n+            \"Implements the Finalizer and Extractor roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded network transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx.vin.size(); ++i) {\n+        CTxIn txin = psbtx.tx.vin[i];",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 603,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "a871194feebc4152ecc2130adcb67f3521c42dc8",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Removed",
    "created_at": "2018-07-02T21:13:19Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199622836",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199622836"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199622836"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199622836/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1661,
    "side": "RIGHT",
    "in_reply_to_id": 199330073
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199622882",
    "pull_request_review_id": 133779250,
    "id": 199622882,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTYyMjg4Mg==",
    "diff_hunk": "@@ -4388,6 +4391,333 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n+        return;\n+    }\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    std::vector<uint32_t> keypath;\n+    if (!meta.hdKeypath.empty()) {\n+        if (!ParseHDKeypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), ReadLE32(masterKey.key.GetPubKey().GetID().begin()));\n+    }\n+    // Single pubkeys get the master fingerprint of themselves\n+    else {\n+        keypath.insert(keypath.begin(), ReadLE32(vchPubKey.GetID().begin()));\n+    }\n+    hd_keypaths.emplace(vchPubKey, keypath);\n+}\n+\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type, bool sign)\n+{\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        CTxIn txin = txConst->vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        uint256 txhash = txin.prevout.hash;\n+        if (pwallet->mapWallet.count(txhash)) {\n+            const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+            CTxOut utxo = wtx.tx->vout[txin.prevout.n];\n+            input.non_witness_utxo = wtx.tx;\n+            input.witness_utxo = utxo;\n+        }\n+\n+        // Get the Sighash type\n+        int sighash = sighash_type;\n+        if (input.sighash_type > 0) {\n+            sighash = input.sighash_type;\n+        }\n+\n+        SignatureData sigdata;\n+        complete &= SignPSBTInput(*pwallet, psbtx.tx, input, sigdata, i, sighash, sign);\n+\n+        // Drop the unnecessary UTXO\n+        if (sigdata.witness) {\n+            input.non_witness_utxo = nullptr;\n+        } else {\n+            input.witness_utxo.SetNull();\n+        }\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, input.hd_keypaths);\n+        }\n+    }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    for (unsigned int i = 0; i < txConst->vout.size(); ++i) {\n+        const CTxOut& out = txConst->vout.at(i);\n+        PSBTOutput& psbt_out = psbtx.outputs.at(i);\n+\n+        // Dummy tx so we can use ProduceSignature to get stuff out\n+        CMutableTransaction dummy_tx;\n+        dummy_tx.vin.push_back(CTxIn());\n+        dummy_tx.vout.push_back(CTxOut());\n+\n+        // Fill a SignatureData with output info\n+        SignatureData sigdata;\n+        psbt_out.FillSignatureData(sigdata);\n+\n+        MutableTransactionSignatureCreator creator(&psbtx.tx, 0, out.nValue, 1);\n+        ProduceSignature(*pwallet, creator, out.scriptPubKey, sigdata);\n+        psbt_out.FromSignatureData(sigdata);\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, psbt_out.hd_keypaths);\n+        }\n+    }\n+    return complete;\n+}\n+\n+UniValue walletprocesspsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"walletprocesspsbt \\\"psbt\\\" ( sign sighashtype )\\n\"\n+            \"\\nUpdate a PSBT with input information from our wallet and then sign inputs\\n\"\n+            \"that we can sign for.\\n\"\n+            + HelpRequiringPassphrase(pwallet) + \"\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                      (string, required) The transaction base64 string\\n\"\n+            \"2. \\\"sign\\\",                     (string, optional, default=true) Also sign the transaction when updating\\n\"\n+            \"3. \\\"sighashtype\\\"            (string, optional, default=ALL) The signature hash type to sign with if not specified by the PSBT. Must be one of\\n\"",
    "path": "src/wallet/rpcwallet.cpp",
    "position": null,
    "original_position": 392,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "a871194feebc4152ecc2130adcb67f3521c42dc8",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-07-02T21:13:30Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199622882",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199622882"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199622882"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199622882/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4554,
    "side": "RIGHT",
    "in_reply_to_id": 199330188
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199622917",
    "pull_request_review_id": 133779290,
    "id": 199622917,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTYyMjkxNw==",
    "diff_hunk": "@@ -4388,6 +4391,333 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n+        return;\n+    }\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    std::vector<uint32_t> keypath;\n+    if (!meta.hdKeypath.empty()) {\n+        if (!ParseHDKeypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), ReadLE32(masterKey.key.GetPubKey().GetID().begin()));\n+    }\n+    // Single pubkeys get the master fingerprint of themselves\n+    else {\n+        keypath.insert(keypath.begin(), ReadLE32(vchPubKey.GetID().begin()));\n+    }\n+    hd_keypaths.emplace(vchPubKey, keypath);\n+}\n+\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type, bool sign)\n+{\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        CTxIn txin = txConst->vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        uint256 txhash = txin.prevout.hash;\n+        if (pwallet->mapWallet.count(txhash)) {\n+            const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+            CTxOut utxo = wtx.tx->vout[txin.prevout.n];\n+            input.non_witness_utxo = wtx.tx;\n+            input.witness_utxo = utxo;\n+        }\n+\n+        // Get the Sighash type\n+        int sighash = sighash_type;\n+        if (input.sighash_type > 0) {\n+            sighash = input.sighash_type;\n+        }\n+\n+        SignatureData sigdata;\n+        complete &= SignPSBTInput(*pwallet, psbtx.tx, input, sigdata, i, sighash, sign);",
    "path": "src/wallet/rpcwallet.cpp",
    "position": null,
    "original_position": 332,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "a871194feebc4152ecc2130adcb67f3521c42dc8",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done.",
    "created_at": "2018-07-02T21:13:39Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199622917",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199622917"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199622917"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199622917/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4488,
    "side": "RIGHT",
    "in_reply_to_id": 199330230
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199622992",
    "pull_request_review_id": 133779373,
    "id": 199622992,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTYyMjk5Mg==",
    "diff_hunk": "@@ -4388,6 +4391,333 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n+        return;\n+    }\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    std::vector<uint32_t> keypath;\n+    if (!meta.hdKeypath.empty()) {\n+        if (!ParseHDKeypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), ReadLE32(masterKey.key.GetPubKey().GetID().begin()));\n+    }\n+    // Single pubkeys get the master fingerprint of themselves\n+    else {\n+        keypath.insert(keypath.begin(), ReadLE32(vchPubKey.GetID().begin()));\n+    }\n+    hd_keypaths.emplace(vchPubKey, keypath);\n+}\n+\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type, bool sign)\n+{\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        CTxIn txin = txConst->vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        uint256 txhash = txin.prevout.hash;\n+        if (pwallet->mapWallet.count(txhash)) {\n+            const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+            CTxOut utxo = wtx.tx->vout[txin.prevout.n];\n+            input.non_witness_utxo = wtx.tx;\n+            input.witness_utxo = utxo;\n+        }\n+\n+        // Get the Sighash type\n+        int sighash = sighash_type;\n+        if (input.sighash_type > 0) {\n+            sighash = input.sighash_type;\n+        }\n+\n+        SignatureData sigdata;\n+        complete &= SignPSBTInput(*pwallet, psbtx.tx, input, sigdata, i, sighash, sign);\n+\n+        // Drop the unnecessary UTXO\n+        if (sigdata.witness) {\n+            input.non_witness_utxo = nullptr;\n+        } else {\n+            input.witness_utxo.SetNull();\n+        }\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, input.hd_keypaths);\n+        }\n+    }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    for (unsigned int i = 0; i < txConst->vout.size(); ++i) {\n+        const CTxOut& out = txConst->vout.at(i);\n+        PSBTOutput& psbt_out = psbtx.outputs.at(i);\n+\n+        // Dummy tx so we can use ProduceSignature to get stuff out\n+        CMutableTransaction dummy_tx;\n+        dummy_tx.vin.push_back(CTxIn());\n+        dummy_tx.vout.push_back(CTxOut());\n+\n+        // Fill a SignatureData with output info\n+        SignatureData sigdata;\n+        psbt_out.FillSignatureData(sigdata);\n+\n+        MutableTransactionSignatureCreator creator(&psbtx.tx, 0, out.nValue, 1);\n+        ProduceSignature(*pwallet, creator, out.scriptPubKey, sigdata);\n+        psbt_out.FromSignatureData(sigdata);\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, psbt_out.hd_keypaths);\n+        }\n+    }\n+    return complete;\n+}\n+\n+UniValue walletprocesspsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"walletprocesspsbt \\\"psbt\\\" ( sign sighashtype )\\n\"\n+            \"\\nUpdate a PSBT with input information from our wallet and then sign inputs\\n\"\n+            \"that we can sign for.\\n\"\n+            + HelpRequiringPassphrase(pwallet) + \"\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                      (string, required) The transaction base64 string\\n\"\n+            \"2. \\\"sign\\\",                     (string, optional, default=true) Also sign the transaction when updating\\n\"\n+            \"3. \\\"sighashtype\\\"            (string, optional, default=ALL) The signature hash type to sign with if not specified by the PSBT. Must be one of\\n\"\n+            \"       \\\"ALL\\\"\\n\"\n+            \"       \\\"NONE\\\"\\n\"\n+            \"       \\\"SINGLE\\\"\\n\"\n+            \"       \\\"ALL|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"NONE|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"SINGLE|ANYONECANPAY\\\"\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"walletprocesspsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    LOCK2(cs_main, pwallet->cs_wallet);\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL, UniValue::VSTR});\n+\n+    // Unserialize the transaction\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get the sighash type\n+    int nHashType = SIGHASH_ALL;\n+    if (!request.params[2].isNull()) {\n+        static std::map<std::string, int> mapSigHashValues = {\n+            {std::string(\"ALL\"), int(SIGHASH_ALL)},\n+            {std::string(\"ALL|ANYONECANPAY\"), int(SIGHASH_ALL|SIGHASH_ANYONECANPAY)},\n+            {std::string(\"NONE\"), int(SIGHASH_NONE)},\n+            {std::string(\"NONE|ANYONECANPAY\"), int(SIGHASH_NONE|SIGHASH_ANYONECANPAY)},\n+            {std::string(\"SINGLE\"), int(SIGHASH_SINGLE)},\n+            {std::string(\"SINGLE|ANYONECANPAY\"), int(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY)},\n+        };\n+        std::string strHashType = request.params[1].get_str();\n+        if (mapSigHashValues.count(strHashType)) {\n+            nHashType = mapSigHashValues[strHashType];\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid sighash param\");\n+        }\n+    }\n+\n+    // Script verification errors\n+    UniValue vErrors(UniValue::VARR);\n+\n+    // Use CTransaction for the constant parts of the\n+    // transaction to avoid rehashing.\n+    const CTransaction txConst(psbtx.tx);\n+\n+    // Fill transaction with our data and also sign\n+    bool sign = request.params[1].isNull() ? true : request.params[1].get_bool();\n+    bool fComplete = FillPSBT(pwallet, psbtx, &txConst, nHashType, sign);\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+    result.push_back(Pair(\"psbt\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size())));\n+    result.push_back(Pair(\"complete\", fComplete));\n+\n+    return result;\n+}\n+\n+UniValue walletcreatefundedpsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 5)\n+        throw std::runtime_error(\n+                            \"walletcreatefundedpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable ) ( options )\\n\"",
    "path": "src/wallet/rpcwallet.cpp",
    "position": null,
    "original_position": 471,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "a871194feebc4152ecc2130adcb67f3521c42dc8",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Changed to also update",
    "created_at": "2018-07-02T21:13:58Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199622992",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199622992"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199622992"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199622992/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4609,
    "side": "RIGHT",
    "in_reply_to_id": 199330273
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199980955",
    "pull_request_review_id": 134205604,
    "id": 199980955,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTk4MDk1NQ==",
    "diff_hunk": "@@ -1262,6 +1263,552 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str.substr(0, keypath_str.size() - 1); // Drop last '/'",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 28,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "e7707b610ae7c5e22fa947d246d4e893634ea36a",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Alternatively: move the `keypath_str += \"/\";` to the front of the loop and initialize with just `\"m\"`. That way you can avoid adding and then stripping the final slash.",
    "created_at": "2018-07-04T00:11:41Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199980955",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199980955"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199980955"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199980955/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1282,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199981568",
    "pull_request_review_id": 134205604,
    "id": 199981568,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTk4MTU2OA==",
    "diff_hunk": "@@ -1262,6 +1263,552 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str.substr(0, keypath_str.size() - 1); // Drop last '/'\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 62,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "e7707b610ae7c5e22fa947d246d4e893634ea36a",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I think it's bad practice to keep outputting \"addresses\" that correspond to a script. It's confusing (they're not really addresses, just multisig pubkeys represented through their corresponding P2PKH address) and also generally useless as it can't introspect into P2SH and P2WSH.\r\n\r\nI preference would be to just output \"hex\", \"asm\" and \"address\" (only if a corresponding address is known through `ExtractDestination`).",
    "created_at": "2018-07-04T00:17:14Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199981568",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199981568"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199981568"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199981568/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1316,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199982817",
    "pull_request_review_id": 134205604,
    "id": 199982817,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTk4MjgxNw==",
    "diff_hunk": "@@ -1262,6 +1263,552 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str.substr(0, keypath_str.size() - 1); // Drop last '/'\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"          {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"       ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 112,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "e7707b610ae7c5e22fa947d246d4e893634ea36a",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "What is this \"script\" intermediate layer? I don't see that in the implementation (for this and for witness_script). Again, just \"hex\" and \"asm\" is sufficient here I think.",
    "created_at": "2018-07-04T00:29:00Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199982817",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199982817"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199982817"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199982817/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1366,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199982918",
    "pull_request_review_id": 134205604,
    "id": 199982918,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTk4MjkxOA==",
    "diff_hunk": "@@ -1262,6 +1263,552 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str.substr(0, keypath_str.size() - 1); // Drop last '/'\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"          {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"       ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"        }\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"value\", ValueFromAmount(txout.nValue));",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 183,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "e7707b610ae7c5e22fa947d246d4e893634ea36a",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "For compatibility with `listunspent` you may want to call this `\"amount\"`.",
    "created_at": "2018-07-04T00:30:00Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199982918",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199982918"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199982918"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199982918/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1437,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199983146",
    "pull_request_review_id": 134205604,
    "id": 199983146,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTk4MzE0Ng==",
    "diff_hunk": "@@ -1262,6 +1263,552 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str.substr(0, keypath_str.size() - 1); // Drop last '/'\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"          {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"       ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"        }\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 197,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "e7707b610ae7c5e22fa947d246d4e893634ea36a",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "How about modelling this as an object whose keys are hex pubkeys, and signatures are hex values?\r\n\r\nSo `{\"<p1>\":\"<sig1>\",...}` instead of `[{\"pubkey\":\"<pk1>\",\"signature\":\"\"<sig1>\"},...]`.",
    "created_at": "2018-07-04T00:32:20Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199983146",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199983146"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199983146"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199983146/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1422,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199983285",
    "pull_request_review_id": 134205604,
    "id": 199983285,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTk4MzI4NQ==",
    "diff_hunk": "@@ -1262,6 +1263,552 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str.substr(0, keypath_str.size() - 1); // Drop last '/'\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"          {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"       ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"        }\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                UniValue sig_univ(UniValue::VOBJ);\n+                sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                partial_sigs.push_back(sig_univ);\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 243,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "e7707b610ae7c5e22fa947d246d4e893634ea36a",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Here you may want to have both `hex` and `asm`.",
    "created_at": "2018-07-04T00:33:45Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199983285",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199983285"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199983285"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199983285/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1497,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199983569",
    "pull_request_review_id": 134205604,
    "id": 199983569,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTk4MzU2OQ==",
    "diff_hunk": "@@ -1262,6 +1263,552 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str.substr(0, keypath_str.size() - 1); // Drop last '/'\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"          {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"       ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"        }\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                UniValue sig_univ(UniValue::VOBJ);\n+                sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                partial_sigs.push_back(sig_univ);\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"psbt\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner and Finalizer roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+    psbtxs.erase(psbtxs.begin());",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 347,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "e7707b610ae7c5e22fa947d246d4e893634ea36a",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "`psbtxs.pop_front()` will do the same. Alternatively, you can write a loop like `for (auto it = std::next(psbtx.begin()); ++it; it !=psbtx.end()) { merged_psbt.Merge(*it); }`.",
    "created_at": "2018-07-04T00:36:51Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199983569",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199983569"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199983569"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199983569/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1601,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199984212",
    "pull_request_review_id": 134205604,
    "id": 199984212,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTk4NDIxMg==",
    "diff_hunk": "@@ -1262,6 +1263,552 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str.substr(0, keypath_str.size() - 1); // Drop last '/'\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"          {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"       ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"        }\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                UniValue sig_univ(UniValue::VOBJ);\n+                sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                partial_sigs.push_back(sig_univ);\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"psbt\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner and Finalizer roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+    psbtxs.erase(psbtxs.begin());\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != merged_psbt) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    // Merge them\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        merged_psbt.Merge(psbtx);\n+    }\n+    if (!merged_psbt.IsSane()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is inconsistent\");\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"psbt\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\\n\"\n+            \"Implements the Finalizer and Extractor roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded network transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        SignatureData sigdata;\n+        complete &= SignPSBTInput(DUMMY_SIGNING_PROVIDER, *psbtx.tx, input, sigdata, i, 1);\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\n+    if (complete && extract) {\n+        CMutableTransaction mtx(*psbtx.tx);\n+        for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+            mtx.vin[i].scriptSig = psbtx.inputs[i].final_script_sig;\n+            mtx.vin[i].scriptWitness = psbtx.inputs[i].final_script_witness;\n+        }\n+        ssTx << mtx;\n+        result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n+    } else {\n+        ssTx << psbtx;\n+        result.push_back(Pair(\"psbt\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size())));\n+    }\n+    result.push_back(Pair(\"complete\", complete));\n+\n+    return result;\n+}\n+\n+UniValue createpsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n+        throw std::runtime_error(\n+                            \"createpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable )\\n\"\n+                            \"\\nCreates a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"\n+                            \"Implements the Creator role.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"inputs\\\"                (array, required) A json array of json objects\\n\"\n+                            \"     [\\n\"\n+                            \"       {\\n\"\n+                            \"         \\\"txid\\\":\\\"id\\\",      (string, required) The transaction id\\n\"\n+                            \"         \\\"vout\\\":n,         (numeric, required) The output number\\n\"\n+                            \"         \\\"sequence\\\":n      (numeric, optional) The sequence number\\n\"\n+                            \"       } \\n\"\n+                            \"       ,...\\n\"\n+                            \"     ]\\n\"\n+                            \"2. \\\"outputs\\\"               (array, required) a json array with outputs (key-value pairs)\\n\"\n+                            \"   [\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"address\\\": x.xxx,    (obj, optional) A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\\n\"\n+                            \"    },\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"data\\\": \\\"hex\\\"        (obj, optional) A key-value pair. The key must be \\\"data\\\", the value is hex encoded data\\n\"\n+                            \"    }\\n\"\n+                            \"    ,...                     More key-value pairs of the above form. For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n+                            \"                             accepted as second parameter.\\n\"\n+                            \"   ]\\n\"\n+                            \"3. locktime                  (numeric, optional, default=0) Raw locktime. Non-0 value also locktime-activates inputs\\n\"\n+                            \"4. replaceable               (boolean, optional, default=false) Marks this transaction as BIP125 replaceable.\\n\"\n+                            \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\": \\\"value\\\",        (string)  The resulting raw transaction (base64-encoded string)\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"createpsbt\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")\n+                            );\n+\n+\n+    RPCTypeCheck(request.params, {\n+        UniValue::VARR,\n+        UniValueType(), // ARR or OBJ, checked later\n+        UniValue::VNUM,\n+        UniValue::VBOOL,\n+        }, true\n+    );\n+\n+    CMutableTransaction rawTx = ConstructTransaction(request.params[0], request.params[1], request.params[2], request.params[3]);\n+\n+    // Make a blank psbt\n+    PartiallySignedTransaction psbtx;\n+    psbtx.tx = rawTx;\n+    for (unsigned int i = 0; i < rawTx.vin.size(); ++i) {\n+        psbtx.inputs.push_back(PSBTInput());\n+    }\n+    for (unsigned int i = 0; i < rawTx.vout.size(); ++i) {\n+        psbtx.outputs.push_back(PSBTOutput());\n+    }\n+\n+    // Serialize the PSBT\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue converttopsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+                            \"converttopsbt \\\"hexstring\\\" ( permitsigdata iswitness )\\n\"\n+                            \"\\nConverts a network serialized transaction to a PSBT. This should be used only with createrawtransaction and fundrawtransaction\\n\"\n+                            \"createpsbt and walletcreatefundedpsbt should be used for new applications.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"hexstring\\\"              (string, required) The hex string of a raw transaction\\n\"\n+                            \"2. permitsigdata           (boolean, optional) If true, any signatures in the input will be discarded.\\n\"\n+                            \"                              If false, RPC will fail if any signatures are present.\\n\"\n+                            \"3. iswitness               (boolean, optional) Whether the transaction hex is a serialized witness transaction.\\n\"\n+                            \"                              If iswitness is not present, heuristic tests will be used in decoding. Only has an effect if\\n\"\n+                            \"                              permitsigdata is true\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\": \\\"value\\\",        (string)  The resulting raw transaction (base64-encoded string)\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nCreate a transaction\\n\"\n+                            + HelpExampleCli(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\") +\n+                            \"\\nConvert the transaction to a PSBT\\n\"\n+                            + HelpExampleCli(\"converttopsbt\", \"\\\"rawtransaction\\\"\")\n+                            );\n+\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL, UniValue::VBOOL}, true);\n+\n+    // parse hex string from parameter\n+    CMutableTransaction tx;\n+    bool try_witness = !request.params[1].isNull() ? (request.params[2].isNull() ? true : request.params[2].get_bool()) : true;",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 526,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "e7707b610ae7c5e22fa947d246d4e893634ea36a",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "These boolean expressions and the ones below are pretty hard to follow.\r\n\r\nWhat about first extracting the boolean values of the arguments, and then writing things in function of those?\r\n",
    "created_at": "2018-07-04T00:43:40Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199984212",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199984212"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199984212"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199984212/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1780,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199984328",
    "pull_request_review_id": 134205604,
    "id": 199984328,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTk4NDMyOA==",
    "diff_hunk": "@@ -4391,6 +4391,341 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n+        return;\n+    }\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    std::vector<uint32_t> keypath;\n+    if (!meta.hdKeypath.empty()) {\n+        if (!ParseHDKeypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), ReadLE32(masterKey.key.GetPubKey().GetID().begin()));\n+    }\n+    // Single pubkeys get the master fingerprint of themselves\n+    else {",
    "path": "src/wallet/rpcwallet.cpp",
    "position": null,
    "original_position": 68,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "b8b9e7e9314814be8ce995350a77ed0415ea70e6",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Style nit: else on the same line",
    "created_at": "2018-07-04T00:44:57Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199984328",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199984328"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199984328"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199984328/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4458,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199992289",
    "pull_request_review_id": 134218728,
    "id": 199992289,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTk5MjI4OQ==",
    "diff_hunk": "@@ -1262,6 +1263,552 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str.substr(0, keypath_str.size() - 1); // Drop last '/'",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 28,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "e7707b610ae7c5e22fa947d246d4e893634ea36a",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-07-04T02:05:14Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199992289",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199992289"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199992289"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199992289/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1282,
    "side": "RIGHT",
    "in_reply_to_id": 199980955
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199992298",
    "pull_request_review_id": 134218745,
    "id": 199992298,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTk5MjI5OA==",
    "diff_hunk": "@@ -1262,6 +1263,552 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str.substr(0, keypath_str.size() - 1); // Drop last '/'\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 62,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "e7707b610ae7c5e22fa947d246d4e893634ea36a",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-07-04T02:05:20Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199992298",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199992298"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199992298"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199992298/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1316,
    "side": "RIGHT",
    "in_reply_to_id": 199981568
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199992310",
    "pull_request_review_id": 134218758,
    "id": 199992310,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTk5MjMxMA==",
    "diff_hunk": "@@ -1262,6 +1263,552 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str.substr(0, keypath_str.size() - 1); // Drop last '/'\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"          {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"       ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 112,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "e7707b610ae7c5e22fa947d246d4e893634ea36a",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Removed, that's a mistake",
    "created_at": "2018-07-04T02:05:28Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199992310",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199992310"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199992310"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199992310/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1366,
    "side": "RIGHT",
    "in_reply_to_id": 199982817
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199992319",
    "pull_request_review_id": 134218771,
    "id": 199992319,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTk5MjMxOQ==",
    "diff_hunk": "@@ -1262,6 +1263,552 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str.substr(0, keypath_str.size() - 1); // Drop last '/'\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"          {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"       ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"        }\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"value\", ValueFromAmount(txout.nValue));",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 183,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "e7707b610ae7c5e22fa947d246d4e893634ea36a",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-07-04T02:05:33Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199992319",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199992319"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199992319"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199992319/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1437,
    "side": "RIGHT",
    "in_reply_to_id": 199982918
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199992326",
    "pull_request_review_id": 134218781,
    "id": 199992326,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTk5MjMyNg==",
    "diff_hunk": "@@ -1262,6 +1263,552 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str.substr(0, keypath_str.size() - 1); // Drop last '/'\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"          {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"       ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"        }\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 197,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "e7707b610ae7c5e22fa947d246d4e893634ea36a",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-07-04T02:05:38Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199992326",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199992326"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199992326"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199992326/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1422,
    "side": "RIGHT",
    "in_reply_to_id": 199983146
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199992333",
    "pull_request_review_id": 134218796,
    "id": 199992333,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTk5MjMzMw==",
    "diff_hunk": "@@ -1262,6 +1263,552 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str.substr(0, keypath_str.size() - 1); // Drop last '/'\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"          {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"       ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"        }\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                UniValue sig_univ(UniValue::VOBJ);\n+                sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                partial_sigs.push_back(sig_univ);\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 243,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "e7707b610ae7c5e22fa947d246d4e893634ea36a",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-07-04T02:05:42Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199992333",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199992333"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199992333"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199992333/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1497,
    "side": "RIGHT",
    "in_reply_to_id": 199983285
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199992370",
    "pull_request_review_id": 134218849,
    "id": 199992370,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTk5MjM3MA==",
    "diff_hunk": "@@ -1262,6 +1263,552 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str.substr(0, keypath_str.size() - 1); // Drop last '/'\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"          {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"       ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"        }\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                UniValue sig_univ(UniValue::VOBJ);\n+                sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                partial_sigs.push_back(sig_univ);\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"psbt\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner and Finalizer roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+    psbtxs.erase(psbtxs.begin());",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 347,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "e7707b610ae7c5e22fa947d246d4e893634ea36a",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "`std::vector` doesn't have a `pop_front()`, so I used your other suggestion for the loop.",
    "created_at": "2018-07-04T02:06:09Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199992370",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199992370"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199992370"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199992370/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1601,
    "side": "RIGHT",
    "in_reply_to_id": 199983569
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199992384",
    "pull_request_review_id": 134218859,
    "id": 199992384,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTk5MjM4NA==",
    "diff_hunk": "@@ -1262,6 +1263,552 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str.substr(0, keypath_str.size() - 1); // Drop last '/'\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"          {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"       ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"        }\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                UniValue sig_univ(UniValue::VOBJ);\n+                sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                partial_sigs.push_back(sig_univ);\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"psbt\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner and Finalizer roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+    psbtxs.erase(psbtxs.begin());\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != merged_psbt) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    // Merge them\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        merged_psbt.Merge(psbtx);\n+    }\n+    if (!merged_psbt.IsSane()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is inconsistent\");\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"psbt\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\\n\"\n+            \"Implements the Finalizer and Extractor roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded network transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        SignatureData sigdata;\n+        complete &= SignPSBTInput(DUMMY_SIGNING_PROVIDER, *psbtx.tx, input, sigdata, i, 1);\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\n+    if (complete && extract) {\n+        CMutableTransaction mtx(*psbtx.tx);\n+        for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+            mtx.vin[i].scriptSig = psbtx.inputs[i].final_script_sig;\n+            mtx.vin[i].scriptWitness = psbtx.inputs[i].final_script_witness;\n+        }\n+        ssTx << mtx;\n+        result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n+    } else {\n+        ssTx << psbtx;\n+        result.push_back(Pair(\"psbt\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size())));\n+    }\n+    result.push_back(Pair(\"complete\", complete));\n+\n+    return result;\n+}\n+\n+UniValue createpsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n+        throw std::runtime_error(\n+                            \"createpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable )\\n\"\n+                            \"\\nCreates a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"\n+                            \"Implements the Creator role.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"inputs\\\"                (array, required) A json array of json objects\\n\"\n+                            \"     [\\n\"\n+                            \"       {\\n\"\n+                            \"         \\\"txid\\\":\\\"id\\\",      (string, required) The transaction id\\n\"\n+                            \"         \\\"vout\\\":n,         (numeric, required) The output number\\n\"\n+                            \"         \\\"sequence\\\":n      (numeric, optional) The sequence number\\n\"\n+                            \"       } \\n\"\n+                            \"       ,...\\n\"\n+                            \"     ]\\n\"\n+                            \"2. \\\"outputs\\\"               (array, required) a json array with outputs (key-value pairs)\\n\"\n+                            \"   [\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"address\\\": x.xxx,    (obj, optional) A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\\n\"\n+                            \"    },\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"data\\\": \\\"hex\\\"        (obj, optional) A key-value pair. The key must be \\\"data\\\", the value is hex encoded data\\n\"\n+                            \"    }\\n\"\n+                            \"    ,...                     More key-value pairs of the above form. For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n+                            \"                             accepted as second parameter.\\n\"\n+                            \"   ]\\n\"\n+                            \"3. locktime                  (numeric, optional, default=0) Raw locktime. Non-0 value also locktime-activates inputs\\n\"\n+                            \"4. replaceable               (boolean, optional, default=false) Marks this transaction as BIP125 replaceable.\\n\"\n+                            \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\": \\\"value\\\",        (string)  The resulting raw transaction (base64-encoded string)\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"createpsbt\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")\n+                            );\n+\n+\n+    RPCTypeCheck(request.params, {\n+        UniValue::VARR,\n+        UniValueType(), // ARR or OBJ, checked later\n+        UniValue::VNUM,\n+        UniValue::VBOOL,\n+        }, true\n+    );\n+\n+    CMutableTransaction rawTx = ConstructTransaction(request.params[0], request.params[1], request.params[2], request.params[3]);\n+\n+    // Make a blank psbt\n+    PartiallySignedTransaction psbtx;\n+    psbtx.tx = rawTx;\n+    for (unsigned int i = 0; i < rawTx.vin.size(); ++i) {\n+        psbtx.inputs.push_back(PSBTInput());\n+    }\n+    for (unsigned int i = 0; i < rawTx.vout.size(); ++i) {\n+        psbtx.outputs.push_back(PSBTOutput());\n+    }\n+\n+    // Serialize the PSBT\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue converttopsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+                            \"converttopsbt \\\"hexstring\\\" ( permitsigdata iswitness )\\n\"\n+                            \"\\nConverts a network serialized transaction to a PSBT. This should be used only with createrawtransaction and fundrawtransaction\\n\"\n+                            \"createpsbt and walletcreatefundedpsbt should be used for new applications.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"hexstring\\\"              (string, required) The hex string of a raw transaction\\n\"\n+                            \"2. permitsigdata           (boolean, optional) If true, any signatures in the input will be discarded.\\n\"\n+                            \"                              If false, RPC will fail if any signatures are present.\\n\"\n+                            \"3. iswitness               (boolean, optional) Whether the transaction hex is a serialized witness transaction.\\n\"\n+                            \"                              If iswitness is not present, heuristic tests will be used in decoding. Only has an effect if\\n\"\n+                            \"                              permitsigdata is true\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\": \\\"value\\\",        (string)  The resulting raw transaction (base64-encoded string)\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nCreate a transaction\\n\"\n+                            + HelpExampleCli(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\") +\n+                            \"\\nConvert the transaction to a PSBT\\n\"\n+                            + HelpExampleCli(\"converttopsbt\", \"\\\"rawtransaction\\\"\")\n+                            );\n+\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL, UniValue::VBOOL}, true);\n+\n+    // parse hex string from parameter\n+    CMutableTransaction tx;\n+    bool try_witness = !request.params[1].isNull() ? (request.params[2].isNull() ? true : request.params[2].get_bool()) : true;",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 526,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "e7707b610ae7c5e22fa947d246d4e893634ea36a",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Changed",
    "created_at": "2018-07-04T02:06:15Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199992384",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199992384"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199992384"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199992384/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1780,
    "side": "RIGHT",
    "in_reply_to_id": 199984212
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199992393",
    "pull_request_review_id": 134218866,
    "id": 199992393,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTk5MjM5Mw==",
    "diff_hunk": "@@ -4391,6 +4391,341 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n+        return;\n+    }\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    std::vector<uint32_t> keypath;\n+    if (!meta.hdKeypath.empty()) {\n+        if (!ParseHDKeypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), ReadLE32(masterKey.key.GetPubKey().GetID().begin()));\n+    }\n+    // Single pubkeys get the master fingerprint of themselves\n+    else {",
    "path": "src/wallet/rpcwallet.cpp",
    "position": null,
    "original_position": 68,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "b8b9e7e9314814be8ce995350a77ed0415ea70e6",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Fixed",
    "created_at": "2018-07-04T02:06:21Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199992393",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199992393"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199992393"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199992393/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4458,
    "side": "RIGHT",
    "in_reply_to_id": 199984328
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199992864",
    "pull_request_review_id": 134219431,
    "id": 199992864,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTk5Mjg2NA==",
    "diff_hunk": "@@ -1262,6 +1263,552 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str.substr(0, keypath_str.size() - 1); // Drop last '/'\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"          {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"       ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"        }\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 197,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "e7707b610ae7c5e22fa947d246d4e893634ea36a",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Now you have `[{\"<p1>\":\"<sig1>\"},{\"<p2>\":\"<sig2>\"},...]`. You can get rid of the internal objects too: `{\"<p1>\":\"<sig1>\",\"<p2>\":\"<sig2>\",...}`.",
    "created_at": "2018-07-04T02:11:01Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199992864",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199992864"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199992864"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199992864/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1422,
    "side": "RIGHT",
    "in_reply_to_id": 199983146
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199993097",
    "pull_request_review_id": 134219431,
    "id": 199993097,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTk5MzA5Nw==",
    "diff_hunk": "@@ -1262,6 +1263,541 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 70,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "336f31d78d494ed19bfb95dfefc455b580bbed17",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Not just recommended.",
    "created_at": "2018-07-04T02:13:30Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199993097",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199993097"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199993097"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199993097/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1324,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199993329",
    "pull_request_review_id": 134219431,
    "id": 199993329,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTk5MzMyOQ==",
    "diff_hunk": "@@ -1262,6 +1263,541 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 81,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "336f31d78d494ed19bfb95dfefc455b580bbed17",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This could be modeled as an object with the pubkey as key, and `{\"master_fingerprint\":\"...\",\"path\":\"...\"}` as value.",
    "created_at": "2018-07-04T02:15:44Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199993329",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199993329"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199993329"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199993329/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1335,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199993761",
    "pull_request_review_id": 134219431,
    "id": 199993761,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTk5Mzc2MQ==",
    "diff_hunk": "@@ -1262,6 +1263,541 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"          {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"       ],\\n\"\n+            \"      \\\"final_scriptsig\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"        }\\n\"\n+            \"       \\\"final_scriptwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 130,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "336f31d78d494ed19bfb95dfefc455b580bbed17",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "It would be very useful to add the fee of the transaction here, if known. Make sure there is a consistency check that non-witness utxo's txid matches the vin.prevout.hash.",
    "created_at": "2018-07-04T02:20:43Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199993761",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199993761"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199993761"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199993761/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1362,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199994098",
    "pull_request_review_id": 134219431,
    "id": 199994098,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTk5NDA5OA==",
    "diff_hunk": "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 242,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "af544a96fa3a74f960723d5c34f3b015e683ae57",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Well perhaps don't say it implements a Finalizer unless it actually implements that :)",
    "created_at": "2018-07-04T02:24:28Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199994098",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199994098"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199994098"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199994098/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1553,
    "side": "RIGHT",
    "in_reply_to_id": 199009777
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199994322",
    "pull_request_review_id": 134219431,
    "id": 199994322,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTk5NDMyMg==",
    "diff_hunk": "@@ -1262,6 +1263,541 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"          {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"       ],\\n\"\n+            \"      \\\"final_scriptsig\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"        }\\n\"\n+            \"       \\\"final_scriptwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"amount\", ValueFromAmount(txout.nValue));\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                UniValue sig_univ(UniValue::VOBJ);\n+                sig_univ.pushKV(HexStr(sig.second.first), HexStr(sig.second.second));\n+                partial_sigs.push_back(sig_univ);\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            UniValue scriptsig(UniValue::VOBJ);\n+            scriptsig.pushKV(\"asm\", ScriptToAsmStr(input.final_script_sig, true));\n+            scriptsig.pushKV(\"hex\", HexStr(input.final_script_sig));\n+            in.pushKV(\"final_scriptSig\", scriptsig);\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            UniValue txinwitness(UniValue::VARR);\n+            for (const auto& item : input.final_script_witness.stack) {\n+                txinwitness.push_back(HexStr(item.begin(), item.end()));\n+            }\n+            in.pushKV(\"final_scriptwitness\", txinwitness);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"psbt\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner and Finalizer roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 315,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "336f31d78d494ed19bfb95dfefc455b580bbed17",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "That doesn't look like the output it's actually producing.",
    "created_at": "2018-07-04T02:25:32Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199994322",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199994322"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199994322"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199994322/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1569,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199994450",
    "pull_request_review_id": 134219431,
    "id": 199994450,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTk5NDQ1MA==",
    "diff_hunk": "@@ -1262,6 +1263,541 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"          {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"       ],\\n\"\n+            \"      \\\"final_scriptsig\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"        }\\n\"\n+            \"       \\\"final_scriptwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"amount\", ValueFromAmount(txout.nValue));\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                UniValue sig_univ(UniValue::VOBJ);\n+                sig_univ.pushKV(HexStr(sig.second.first), HexStr(sig.second.second));\n+                partial_sigs.push_back(sig_univ);\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            UniValue scriptsig(UniValue::VOBJ);\n+            scriptsig.pushKV(\"asm\", ScriptToAsmStr(input.final_script_sig, true));\n+            scriptsig.pushKV(\"hex\", HexStr(input.final_script_sig));\n+            in.pushKV(\"final_scriptSig\", scriptsig);\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            UniValue txinwitness(UniValue::VARR);\n+            for (const auto& item : input.final_script_witness.stack) {\n+                txinwitness.push_back(HexStr(item.begin(), item.end()));\n+            }\n+            in.pushKV(\"final_scriptwitness\", txinwitness);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"psbt\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner and Finalizer roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        if (*it != merged_psbt) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+        merged_psbt.Merge(*it);\n+    }\n+    if (!merged_psbt.IsSane()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is inconsistent\");\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"psbt\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\\n\"\n+            \"Implements the Finalizer and Extractor roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded network transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        SignatureData sigdata;\n+        complete &= SignPSBTInput(DUMMY_SIGNING_PROVIDER, *psbtx.tx, input, sigdata, i, 1);\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\n+    if (complete && extract) {\n+        CMutableTransaction mtx(*psbtx.tx);\n+        for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+            mtx.vin[i].scriptSig = psbtx.inputs[i].final_script_sig;\n+            mtx.vin[i].scriptWitness = psbtx.inputs[i].final_script_witness;\n+        }\n+        ssTx << mtx;\n+        result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n+    } else {\n+        ssTx << psbtx;\n+        result.push_back(Pair(\"psbt\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size())));\n+    }\n+    result.push_back(Pair(\"complete\", complete));\n+\n+    return result;\n+}\n+\n+UniValue createpsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n+        throw std::runtime_error(\n+                            \"createpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable )\\n\"\n+                            \"\\nCreates a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"\n+                            \"Implements the Creator role.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"inputs\\\"                (array, required) A json array of json objects\\n\"\n+                            \"     [\\n\"\n+                            \"       {\\n\"\n+                            \"         \\\"txid\\\":\\\"id\\\",      (string, required) The transaction id\\n\"\n+                            \"         \\\"vout\\\":n,         (numeric, required) The output number\\n\"\n+                            \"         \\\"sequence\\\":n      (numeric, optional) The sequence number\\n\"\n+                            \"       } \\n\"\n+                            \"       ,...\\n\"\n+                            \"     ]\\n\"\n+                            \"2. \\\"outputs\\\"               (array, required) a json array with outputs (key-value pairs)\\n\"\n+                            \"   [\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"address\\\": x.xxx,    (obj, optional) A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\\n\"\n+                            \"    },\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"data\\\": \\\"hex\\\"        (obj, optional) A key-value pair. The key must be \\\"data\\\", the value is hex encoded data\\n\"\n+                            \"    }\\n\"\n+                            \"    ,...                     More key-value pairs of the above form. For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n+                            \"                             accepted as second parameter.\\n\"\n+                            \"   ]\\n\"\n+                            \"3. locktime                  (numeric, optional, default=0) Raw locktime. Non-0 value also locktime-activates inputs\\n\"\n+                            \"4. replaceable               (boolean, optional, default=false) Marks this transaction as BIP125 replaceable.\\n\"\n+                            \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\": \\\"value\\\",        (string)  The resulting raw transaction (base64-encoded string)\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 452,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "336f31d78d494ed19bfb95dfefc455b580bbed17",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "The output looks like just a string, not an object.",
    "created_at": "2018-07-04T02:26:44Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199994450",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199994450"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199994450"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199994450/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1706,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199994478",
    "pull_request_review_id": 134219431,
    "id": 199994478,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTk5NDQ3OA==",
    "diff_hunk": "@@ -1262,6 +1263,541 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"          {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"       ],\\n\"\n+            \"      \\\"final_scriptsig\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"        }\\n\"\n+            \"       \\\"final_scriptwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"amount\", ValueFromAmount(txout.nValue));\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                UniValue sig_univ(UniValue::VOBJ);\n+                sig_univ.pushKV(HexStr(sig.second.first), HexStr(sig.second.second));\n+                partial_sigs.push_back(sig_univ);\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            UniValue scriptsig(UniValue::VOBJ);\n+            scriptsig.pushKV(\"asm\", ScriptToAsmStr(input.final_script_sig, true));\n+            scriptsig.pushKV(\"hex\", HexStr(input.final_script_sig));\n+            in.pushKV(\"final_scriptSig\", scriptsig);\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            UniValue txinwitness(UniValue::VARR);\n+            for (const auto& item : input.final_script_witness.stack) {\n+                txinwitness.push_back(HexStr(item.begin(), item.end()));\n+            }\n+            in.pushKV(\"final_scriptwitness\", txinwitness);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"psbt\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner and Finalizer roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        if (*it != merged_psbt) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+        merged_psbt.Merge(*it);\n+    }\n+    if (!merged_psbt.IsSane()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is inconsistent\");\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"psbt\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\\n\"\n+            \"Implements the Finalizer and Extractor roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded network transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        SignatureData sigdata;\n+        complete &= SignPSBTInput(DUMMY_SIGNING_PROVIDER, *psbtx.tx, input, sigdata, i, 1);\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\n+    if (complete && extract) {\n+        CMutableTransaction mtx(*psbtx.tx);\n+        for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+            mtx.vin[i].scriptSig = psbtx.inputs[i].final_script_sig;\n+            mtx.vin[i].scriptWitness = psbtx.inputs[i].final_script_witness;\n+        }\n+        ssTx << mtx;\n+        result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n+    } else {\n+        ssTx << psbtx;\n+        result.push_back(Pair(\"psbt\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size())));\n+    }\n+    result.push_back(Pair(\"complete\", complete));\n+\n+    return result;\n+}\n+\n+UniValue createpsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n+        throw std::runtime_error(\n+                            \"createpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable )\\n\"\n+                            \"\\nCreates a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"\n+                            \"Implements the Creator role.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"inputs\\\"                (array, required) A json array of json objects\\n\"\n+                            \"     [\\n\"\n+                            \"       {\\n\"\n+                            \"         \\\"txid\\\":\\\"id\\\",      (string, required) The transaction id\\n\"\n+                            \"         \\\"vout\\\":n,         (numeric, required) The output number\\n\"\n+                            \"         \\\"sequence\\\":n      (numeric, optional) The sequence number\\n\"\n+                            \"       } \\n\"\n+                            \"       ,...\\n\"\n+                            \"     ]\\n\"\n+                            \"2. \\\"outputs\\\"               (array, required) a json array with outputs (key-value pairs)\\n\"\n+                            \"   [\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"address\\\": x.xxx,    (obj, optional) A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\\n\"\n+                            \"    },\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"data\\\": \\\"hex\\\"        (obj, optional) A key-value pair. The key must be \\\"data\\\", the value is hex encoded data\\n\"\n+                            \"    }\\n\"\n+                            \"    ,...                     More key-value pairs of the above form. For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n+                            \"                             accepted as second parameter.\\n\"\n+                            \"   ]\\n\"\n+                            \"3. locktime                  (numeric, optional, default=0) Raw locktime. Non-0 value also locktime-activates inputs\\n\"\n+                            \"4. replaceable               (boolean, optional, default=false) Marks this transaction as BIP125 replaceable.\\n\"\n+                            \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\": \\\"value\\\",        (string)  The resulting raw transaction (base64-encoded string)\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"createpsbt\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")\n+                            );\n+\n+\n+    RPCTypeCheck(request.params, {\n+        UniValue::VARR,\n+        UniValueType(), // ARR or OBJ, checked later\n+        UniValue::VNUM,\n+        UniValue::VBOOL,\n+        }, true\n+    );\n+\n+    CMutableTransaction rawTx = ConstructTransaction(request.params[0], request.params[1], request.params[2], request.params[3]);\n+\n+    // Make a blank psbt\n+    PartiallySignedTransaction psbtx;\n+    psbtx.tx = rawTx;\n+    for (unsigned int i = 0; i < rawTx.vin.size(); ++i) {\n+        psbtx.inputs.push_back(PSBTInput());\n+    }\n+    for (unsigned int i = 0; i < rawTx.vout.size(); ++i) {\n+        psbtx.outputs.push_back(PSBTOutput());\n+    }\n+\n+    // Serialize the PSBT\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue converttopsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+                            \"converttopsbt \\\"hexstring\\\" ( permitsigdata iswitness )\\n\"\n+                            \"\\nConverts a network serialized transaction to a PSBT. This should be used only with createrawtransaction and fundrawtransaction\\n\"\n+                            \"createpsbt and walletcreatefundedpsbt should be used for new applications.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"hexstring\\\"              (string, required) The hex string of a raw transaction\\n\"\n+                            \"2. permitsigdata           (boolean, optional) If true, any signatures in the input will be discarded.\\n\"\n+                            \"                              If false, RPC will fail if any signatures are present.\\n\"\n+                            \"3. iswitness               (boolean, optional) Whether the transaction hex is a serialized witness transaction.\\n\"\n+                            \"                              If iswitness is not present, heuristic tests will be used in decoding. Only has an effect if\\n\"\n+                            \"                              permitsigdata is true\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\": \\\"value\\\",        (string)  The resulting raw transaction (base64-encoded string)\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 500,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "336f31d78d494ed19bfb95dfefc455b580bbed17",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Same here.",
    "created_at": "2018-07-04T02:27:02Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199994478",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199994478"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199994478"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199994478/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1754,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199994562",
    "pull_request_review_id": 134219431,
    "id": 199994562,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTk5NDU2Mg==",
    "diff_hunk": "@@ -32,6 +32,17 @@ class SigningProvider\n \n extern const SigningProvider& DUMMY_SIGNING_PROVIDER;\n \n+class PublicOnlySigningProvider : public SigningProvider\n+{\n+private:\n+    const SigningProvider* provider;",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 7,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "cc05bb068e36aa9a68b8f0c31bf7362f676c69af",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Style nit: `m_provider`.",
    "created_at": "2018-07-04T02:27:38Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199994562",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199994562"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199994562"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199994562/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 38,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199997044",
    "pull_request_review_id": 134224218,
    "id": 199997044,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTk5NzA0NA==",
    "diff_hunk": "@@ -1262,6 +1263,552 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str.substr(0, keypath_str.size() - 1); // Drop last '/'\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"          {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"       ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"        }\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 197,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "e7707b610ae7c5e22fa947d246d4e893634ea36a",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done.",
    "created_at": "2018-07-04T02:52:24Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199997044",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199997044"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199997044"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199997044/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1422,
    "side": "RIGHT",
    "in_reply_to_id": 199983146
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199997058",
    "pull_request_review_id": 134224234,
    "id": 199997058,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTk5NzA1OA==",
    "diff_hunk": "@@ -1262,6 +1263,541 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 70,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "336f31d78d494ed19bfb95dfefc455b580bbed17",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Fixed",
    "created_at": "2018-07-04T02:52:32Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199997058",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199997058"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199997058"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199997058/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1324,
    "side": "RIGHT",
    "in_reply_to_id": 199993097
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199997068",
    "pull_request_review_id": 134224249,
    "id": 199997068,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTk5NzA2OA==",
    "diff_hunk": "@@ -1262,6 +1263,541 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 81,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "336f31d78d494ed19bfb95dfefc455b580bbed17",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-07-04T02:52:40Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199997068",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199997068"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199997068"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199997068/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1335,
    "side": "RIGHT",
    "in_reply_to_id": 199993329
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199997143",
    "pull_request_review_id": 134224330,
    "id": 199997143,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTk5NzE0Mw==",
    "diff_hunk": "@@ -1262,6 +1263,541 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"          {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"       ],\\n\"\n+            \"      \\\"final_scriptsig\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"        }\\n\"\n+            \"       \\\"final_scriptwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"amount\", ValueFromAmount(txout.nValue));\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                UniValue sig_univ(UniValue::VOBJ);\n+                sig_univ.pushKV(HexStr(sig.second.first), HexStr(sig.second.second));\n+                partial_sigs.push_back(sig_univ);\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            UniValue scriptsig(UniValue::VOBJ);\n+            scriptsig.pushKV(\"asm\", ScriptToAsmStr(input.final_script_sig, true));\n+            scriptsig.pushKV(\"hex\", HexStr(input.final_script_sig));\n+            in.pushKV(\"final_scriptSig\", scriptsig);\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            UniValue txinwitness(UniValue::VARR);\n+            for (const auto& item : input.final_script_witness.stack) {\n+                txinwitness.push_back(HexStr(item.begin(), item.end()));\n+            }\n+            in.pushKV(\"final_scriptwitness\", txinwitness);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"psbt\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner and Finalizer roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 315,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "336f31d78d494ed19bfb95dfefc455b580bbed17",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Fixed here and elsewhere",
    "created_at": "2018-07-04T02:53:23Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199997143",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199997143"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199997143"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199997143/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1569,
    "side": "RIGHT",
    "in_reply_to_id": 199994322
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199997166",
    "pull_request_review_id": 134224359,
    "id": 199997166,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTk5NzE2Ng==",
    "diff_hunk": "@@ -1262,6 +1263,541 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"          {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"       ],\\n\"\n+            \"      \\\"final_scriptsig\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"        }\\n\"\n+            \"       \\\"final_scriptwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"amount\", ValueFromAmount(txout.nValue));\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                UniValue sig_univ(UniValue::VOBJ);\n+                sig_univ.pushKV(HexStr(sig.second.first), HexStr(sig.second.second));\n+                partial_sigs.push_back(sig_univ);\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            UniValue scriptsig(UniValue::VOBJ);\n+            scriptsig.pushKV(\"asm\", ScriptToAsmStr(input.final_script_sig, true));\n+            scriptsig.pushKV(\"hex\", HexStr(input.final_script_sig));\n+            in.pushKV(\"final_scriptSig\", scriptsig);\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            UniValue txinwitness(UniValue::VARR);\n+            for (const auto& item : input.final_script_witness.stack) {\n+                txinwitness.push_back(HexStr(item.begin(), item.end()));\n+            }\n+            in.pushKV(\"final_scriptwitness\", txinwitness);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"psbt\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner and Finalizer roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        if (*it != merged_psbt) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+        merged_psbt.Merge(*it);\n+    }\n+    if (!merged_psbt.IsSane()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is inconsistent\");\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"psbt\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\\n\"\n+            \"Implements the Finalizer and Extractor roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded network transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        SignatureData sigdata;\n+        complete &= SignPSBTInput(DUMMY_SIGNING_PROVIDER, *psbtx.tx, input, sigdata, i, 1);\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\n+    if (complete && extract) {\n+        CMutableTransaction mtx(*psbtx.tx);\n+        for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+            mtx.vin[i].scriptSig = psbtx.inputs[i].final_script_sig;\n+            mtx.vin[i].scriptWitness = psbtx.inputs[i].final_script_witness;\n+        }\n+        ssTx << mtx;\n+        result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n+    } else {\n+        ssTx << psbtx;\n+        result.push_back(Pair(\"psbt\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size())));\n+    }\n+    result.push_back(Pair(\"complete\", complete));\n+\n+    return result;\n+}\n+\n+UniValue createpsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n+        throw std::runtime_error(\n+                            \"createpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable )\\n\"\n+                            \"\\nCreates a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"\n+                            \"Implements the Creator role.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"inputs\\\"                (array, required) A json array of json objects\\n\"\n+                            \"     [\\n\"\n+                            \"       {\\n\"\n+                            \"         \\\"txid\\\":\\\"id\\\",      (string, required) The transaction id\\n\"\n+                            \"         \\\"vout\\\":n,         (numeric, required) The output number\\n\"\n+                            \"         \\\"sequence\\\":n      (numeric, optional) The sequence number\\n\"\n+                            \"       } \\n\"\n+                            \"       ,...\\n\"\n+                            \"     ]\\n\"\n+                            \"2. \\\"outputs\\\"               (array, required) a json array with outputs (key-value pairs)\\n\"\n+                            \"   [\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"address\\\": x.xxx,    (obj, optional) A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\\n\"\n+                            \"    },\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"data\\\": \\\"hex\\\"        (obj, optional) A key-value pair. The key must be \\\"data\\\", the value is hex encoded data\\n\"\n+                            \"    }\\n\"\n+                            \"    ,...                     More key-value pairs of the above form. For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n+                            \"                             accepted as second parameter.\\n\"\n+                            \"   ]\\n\"\n+                            \"3. locktime                  (numeric, optional, default=0) Raw locktime. Non-0 value also locktime-activates inputs\\n\"\n+                            \"4. replaceable               (boolean, optional, default=false) Marks this transaction as BIP125 replaceable.\\n\"\n+                            \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\": \\\"value\\\",        (string)  The resulting raw transaction (base64-encoded string)\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 452,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "336f31d78d494ed19bfb95dfefc455b580bbed17",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Fixed here and elsewhere",
    "created_at": "2018-07-04T02:53:38Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199997166",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199997166"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199997166"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199997166/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1706,
    "side": "RIGHT",
    "in_reply_to_id": 199994450
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199999207",
    "pull_request_review_id": 134226814,
    "id": 199999207,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTk5OTIwNw==",
    "diff_hunk": "@@ -1262,6 +1263,541 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"          {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"       ],\\n\"\n+            \"      \\\"final_scriptsig\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"        }\\n\"\n+            \"       \\\"final_scriptwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 130,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "336f31d78d494ed19bfb95dfefc455b580bbed17",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done. The consistency check occurs at deserialization time.",
    "created_at": "2018-07-04T03:16:53Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199999207",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199999207"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199999207"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199999207/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1362,
    "side": "RIGHT",
    "in_reply_to_id": 199993761
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200201430",
    "pull_request_review_id": 134470768,
    "id": 200201430,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDIwMTQzMA==",
    "diff_hunk": "@@ -4391,6 +4391,339 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n+        return;\n+    }\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    std::vector<uint32_t> keypath;\n+    if (!meta.hdKeypath.empty()) {\n+        if (!ParseHDKeypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), ReadLE32(masterKey.key.GetPubKey().GetID().begin()));\n+    } else { // Single pubkeys get the master fingerprint of themselves\n+        keypath.insert(keypath.begin(), ReadLE32(vchPubKey.GetID().begin()));\n+    }\n+    hd_keypaths.emplace(vchPubKey, keypath);\n+}\n+\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type, bool sign)\n+{\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        const CTxIn& txin = txConst->vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        const uint256& txhash = txin.prevout.hash;\n+        if (pwallet->mapWallet.count(txhash)) {\n+            const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+            CTxOut utxo = wtx.tx->vout[txin.prevout.n];\n+            input.non_witness_utxo = wtx.tx;\n+            input.witness_utxo = utxo;\n+        }\n+\n+        // Get the Sighash type\n+        if (sign && input.sighash_type > 0 && input.sighash_type != sighash_type) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Specified Sighash and sighash in PSBT do not match.\");\n+        }\n+\n+        SignatureData sigdata;\n+        if (sign) {\n+            complete &= SignPSBTInput(*pwallet, *psbtx.tx, input, sigdata, i, sighash_type);\n+        } else {\n+            complete &= SignPSBTInput(PublicOnlySigningProvider(pwallet), *psbtx.tx, input, sigdata, i, sighash_type);\n+        }\n+\n+        // Drop the unnecessary UTXO\n+        if (sigdata.witness) {\n+            input.non_witness_utxo = nullptr;\n+        } else {\n+            input.witness_utxo.SetNull();\n+        }\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, input.hd_keypaths);\n+        }\n+    }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    for (unsigned int i = 0; i < txConst->vout.size(); ++i) {\n+        const CTxOut& out = txConst->vout.at(i);\n+        PSBTOutput& psbt_out = psbtx.outputs.at(i);\n+\n+        // Dummy tx so we can use ProduceSignature to get stuff out\n+        CMutableTransaction dummy_tx;\n+        dummy_tx.vin.push_back(CTxIn());\n+        dummy_tx.vout.push_back(CTxOut());\n+\n+        // Fill a SignatureData with output info\n+        SignatureData sigdata;\n+        psbt_out.FillSignatureData(sigdata);\n+\n+        MutableTransactionSignatureCreator creator(psbtx.tx.get_ptr(), 0, out.nValue, 1);\n+        ProduceSignature(*pwallet, creator, out.scriptPubKey, sigdata);\n+        psbt_out.FromSignatureData(sigdata);\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, psbt_out.hd_keypaths);\n+        }\n+    }\n+    return complete;\n+}\n+\n+UniValue walletprocesspsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)",
    "path": "src/wallet/rpcwallet.cpp",
    "position": 389,
    "original_position": 149,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "9e4077a992bc647f36f724c74ba6c595afe12419",
    "user": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "`> 3`",
    "created_at": "2018-07-04T21:08:36Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200201430",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200201430"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200201430"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200201430/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 4544,
    "original_line": 4544,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200201761",
    "pull_request_review_id": 134470768,
    "id": 200201761,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDIwMTc2MQ==",
    "diff_hunk": "@@ -4391,6 +4391,339 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n+        return;\n+    }\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    std::vector<uint32_t> keypath;\n+    if (!meta.hdKeypath.empty()) {\n+        if (!ParseHDKeypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), ReadLE32(masterKey.key.GetPubKey().GetID().begin()));\n+    } else { // Single pubkeys get the master fingerprint of themselves\n+        keypath.insert(keypath.begin(), ReadLE32(vchPubKey.GetID().begin()));\n+    }\n+    hd_keypaths.emplace(vchPubKey, keypath);\n+}\n+\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type, bool sign)\n+{\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        const CTxIn& txin = txConst->vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        const uint256& txhash = txin.prevout.hash;\n+        if (pwallet->mapWallet.count(txhash)) {\n+            const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+            CTxOut utxo = wtx.tx->vout[txin.prevout.n];\n+            input.non_witness_utxo = wtx.tx;\n+            input.witness_utxo = utxo;\n+        }\n+\n+        // Get the Sighash type\n+        if (sign && input.sighash_type > 0 && input.sighash_type != sighash_type) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Specified Sighash and sighash in PSBT do not match.\");\n+        }\n+\n+        SignatureData sigdata;\n+        if (sign) {\n+            complete &= SignPSBTInput(*pwallet, *psbtx.tx, input, sigdata, i, sighash_type);\n+        } else {\n+            complete &= SignPSBTInput(PublicOnlySigningProvider(pwallet), *psbtx.tx, input, sigdata, i, sighash_type);\n+        }\n+\n+        // Drop the unnecessary UTXO\n+        if (sigdata.witness) {\n+            input.non_witness_utxo = nullptr;\n+        } else {\n+            input.witness_utxo.SetNull();\n+        }\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, input.hd_keypaths);\n+        }\n+    }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    for (unsigned int i = 0; i < txConst->vout.size(); ++i) {\n+        const CTxOut& out = txConst->vout.at(i);\n+        PSBTOutput& psbt_out = psbtx.outputs.at(i);\n+\n+        // Dummy tx so we can use ProduceSignature to get stuff out\n+        CMutableTransaction dummy_tx;\n+        dummy_tx.vin.push_back(CTxIn());\n+        dummy_tx.vout.push_back(CTxOut());\n+\n+        // Fill a SignatureData with output info\n+        SignatureData sigdata;\n+        psbt_out.FillSignatureData(sigdata);\n+\n+        MutableTransactionSignatureCreator creator(psbtx.tx.get_ptr(), 0, out.nValue, 1);\n+        ProduceSignature(*pwallet, creator, out.scriptPubKey, sigdata);\n+        psbt_out.FromSignatureData(sigdata);\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, psbt_out.hd_keypaths);\n+        }\n+    }\n+    return complete;\n+}\n+\n+UniValue walletprocesspsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"walletprocesspsbt \\\"psbt\\\" ( sign sighashtype )\\n\"\n+            \"\\nUpdate a PSBT with input information from our wallet and then sign inputs\\n\"\n+            \"that we can sign for.\\n\"\n+            + HelpRequiringPassphrase(pwallet) + \"\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                      (string, required) The transaction base64 string\\n\"\n+            \"2. \\\"sign\\\",                     (string, optional, default=true) Also sign the transaction when updating\\n\"\n+            \"3. \\\"sighashtype\\\"            (string, optional, default=ALL) The signature hash type to sign with if not specified by the PSBT. Must be one of\\n\"\n+            \"       \\\"ALL\\\"\\n\"\n+            \"       \\\"NONE\\\"\\n\"\n+            \"       \\\"SINGLE\\\"\\n\"\n+            \"       \\\"ALL|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"NONE|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"SINGLE|ANYONECANPAY\\\"\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"walletprocesspsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    LOCK2(cs_main, pwallet->cs_wallet);\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL, UniValue::VSTR});\n+\n+    // Unserialize the transaction\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get the sighash type\n+    int nHashType = SIGHASH_ALL;\n+    if (!request.params[2].isNull()) {\n+        static std::map<std::string, int> mapSigHashValues = {\n+            {std::string(\"ALL\"), int(SIGHASH_ALL)},\n+            {std::string(\"ALL|ANYONECANPAY\"), int(SIGHASH_ALL|SIGHASH_ANYONECANPAY)},\n+            {std::string(\"NONE\"), int(SIGHASH_NONE)},\n+            {std::string(\"NONE|ANYONECANPAY\"), int(SIGHASH_NONE|SIGHASH_ANYONECANPAY)},\n+            {std::string(\"SINGLE\"), int(SIGHASH_SINGLE)},\n+            {std::string(\"SINGLE|ANYONECANPAY\"), int(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY)},\n+        };\n+        std::string strHashType = request.params[1].get_str();",
    "path": "src/wallet/rpcwallet.cpp",
    "position": null,
    "original_position": 199,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "9e4077a992bc647f36f724c74ba6c595afe12419",
    "user": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "`[2]`?",
    "created_at": "2018-07-04T21:13:01Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200201761",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200201761"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200201761"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200201761/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4588,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200202027",
    "pull_request_review_id": 134470768,
    "id": 200202027,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDIwMjAyNw==",
    "diff_hunk": "@@ -4391,6 +4391,339 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n+        return;\n+    }\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    std::vector<uint32_t> keypath;\n+    if (!meta.hdKeypath.empty()) {\n+        if (!ParseHDKeypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), ReadLE32(masterKey.key.GetPubKey().GetID().begin()));\n+    } else { // Single pubkeys get the master fingerprint of themselves\n+        keypath.insert(keypath.begin(), ReadLE32(vchPubKey.GetID().begin()));\n+    }\n+    hd_keypaths.emplace(vchPubKey, keypath);\n+}\n+\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type, bool sign)\n+{\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        const CTxIn& txin = txConst->vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        const uint256& txhash = txin.prevout.hash;\n+        if (pwallet->mapWallet.count(txhash)) {\n+            const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+            CTxOut utxo = wtx.tx->vout[txin.prevout.n];\n+            input.non_witness_utxo = wtx.tx;\n+            input.witness_utxo = utxo;\n+        }\n+\n+        // Get the Sighash type\n+        if (sign && input.sighash_type > 0 && input.sighash_type != sighash_type) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Specified Sighash and sighash in PSBT do not match.\");\n+        }\n+\n+        SignatureData sigdata;\n+        if (sign) {\n+            complete &= SignPSBTInput(*pwallet, *psbtx.tx, input, sigdata, i, sighash_type);\n+        } else {\n+            complete &= SignPSBTInput(PublicOnlySigningProvider(pwallet), *psbtx.tx, input, sigdata, i, sighash_type);\n+        }\n+\n+        // Drop the unnecessary UTXO\n+        if (sigdata.witness) {\n+            input.non_witness_utxo = nullptr;\n+        } else {\n+            input.witness_utxo.SetNull();\n+        }\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, input.hd_keypaths);\n+        }\n+    }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    for (unsigned int i = 0; i < txConst->vout.size(); ++i) {\n+        const CTxOut& out = txConst->vout.at(i);\n+        PSBTOutput& psbt_out = psbtx.outputs.at(i);\n+\n+        // Dummy tx so we can use ProduceSignature to get stuff out\n+        CMutableTransaction dummy_tx;\n+        dummy_tx.vin.push_back(CTxIn());\n+        dummy_tx.vout.push_back(CTxOut());\n+\n+        // Fill a SignatureData with output info\n+        SignatureData sigdata;\n+        psbt_out.FillSignatureData(sigdata);\n+\n+        MutableTransactionSignatureCreator creator(psbtx.tx.get_ptr(), 0, out.nValue, 1);\n+        ProduceSignature(*pwallet, creator, out.scriptPubKey, sigdata);\n+        psbt_out.FromSignatureData(sigdata);\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, psbt_out.hd_keypaths);\n+        }\n+    }\n+    return complete;\n+}\n+\n+UniValue walletprocesspsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"walletprocesspsbt \\\"psbt\\\" ( sign sighashtype )\\n\"\n+            \"\\nUpdate a PSBT with input information from our wallet and then sign inputs\\n\"\n+            \"that we can sign for.\\n\"\n+            + HelpRequiringPassphrase(pwallet) + \"\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                      (string, required) The transaction base64 string\\n\"\n+            \"2. \\\"sign\\\",                     (string, optional, default=true) Also sign the transaction when updating\\n\"\n+            \"3. \\\"sighashtype\\\"            (string, optional, default=ALL) The signature hash type to sign with if not specified by the PSBT. Must be one of\\n\"\n+            \"       \\\"ALL\\\"\\n\"\n+            \"       \\\"NONE\\\"\\n\"\n+            \"       \\\"SINGLE\\\"\\n\"\n+            \"       \\\"ALL|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"NONE|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"SINGLE|ANYONECANPAY\\\"\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"walletprocesspsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    LOCK2(cs_main, pwallet->cs_wallet);\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL, UniValue::VSTR});\n+\n+    // Unserialize the transaction\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get the sighash type\n+    int nHashType = SIGHASH_ALL;\n+    if (!request.params[2].isNull()) {\n+        static std::map<std::string, int> mapSigHashValues = {\n+            {std::string(\"ALL\"), int(SIGHASH_ALL)},\n+            {std::string(\"ALL|ANYONECANPAY\"), int(SIGHASH_ALL|SIGHASH_ANYONECANPAY)},\n+            {std::string(\"NONE\"), int(SIGHASH_NONE)},\n+            {std::string(\"NONE|ANYONECANPAY\"), int(SIGHASH_NONE|SIGHASH_ANYONECANPAY)},\n+            {std::string(\"SINGLE\"), int(SIGHASH_SINGLE)},\n+            {std::string(\"SINGLE|ANYONECANPAY\"), int(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY)},\n+        };\n+        std::string strHashType = request.params[1].get_str();",
    "path": "src/wallet/rpcwallet.cpp",
    "position": null,
    "original_position": 199,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "9e4077a992bc647f36f724c74ba6c595afe12419",
    "user": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Nit, could move this to a `ParseSigHashType()`? Like `ParseOutputType` and `ParseConfirmTarget`.",
    "created_at": "2018-07-04T21:16:39Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200202027",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200202027"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200202027"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200202027/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4588,
    "side": "RIGHT",
    "in_reply_to_id": 200201761
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200202117",
    "pull_request_review_id": 134470768,
    "id": 200202117,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDIwMjExNw==",
    "diff_hunk": "@@ -4391,6 +4391,339 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n+        return;\n+    }\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    std::vector<uint32_t> keypath;\n+    if (!meta.hdKeypath.empty()) {\n+        if (!ParseHDKeypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), ReadLE32(masterKey.key.GetPubKey().GetID().begin()));\n+    } else { // Single pubkeys get the master fingerprint of themselves\n+        keypath.insert(keypath.begin(), ReadLE32(vchPubKey.GetID().begin()));\n+    }\n+    hd_keypaths.emplace(vchPubKey, keypath);\n+}\n+\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type, bool sign)\n+{\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        const CTxIn& txin = txConst->vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        const uint256& txhash = txin.prevout.hash;\n+        if (pwallet->mapWallet.count(txhash)) {\n+            const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+            CTxOut utxo = wtx.tx->vout[txin.prevout.n];\n+            input.non_witness_utxo = wtx.tx;\n+            input.witness_utxo = utxo;\n+        }\n+\n+        // Get the Sighash type\n+        if (sign && input.sighash_type > 0 && input.sighash_type != sighash_type) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Specified Sighash and sighash in PSBT do not match.\");\n+        }\n+\n+        SignatureData sigdata;\n+        if (sign) {\n+            complete &= SignPSBTInput(*pwallet, *psbtx.tx, input, sigdata, i, sighash_type);\n+        } else {\n+            complete &= SignPSBTInput(PublicOnlySigningProvider(pwallet), *psbtx.tx, input, sigdata, i, sighash_type);\n+        }\n+\n+        // Drop the unnecessary UTXO\n+        if (sigdata.witness) {\n+            input.non_witness_utxo = nullptr;\n+        } else {\n+            input.witness_utxo.SetNull();\n+        }\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, input.hd_keypaths);\n+        }\n+    }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    for (unsigned int i = 0; i < txConst->vout.size(); ++i) {\n+        const CTxOut& out = txConst->vout.at(i);\n+        PSBTOutput& psbt_out = psbtx.outputs.at(i);\n+\n+        // Dummy tx so we can use ProduceSignature to get stuff out\n+        CMutableTransaction dummy_tx;\n+        dummy_tx.vin.push_back(CTxIn());\n+        dummy_tx.vout.push_back(CTxOut());\n+\n+        // Fill a SignatureData with output info\n+        SignatureData sigdata;\n+        psbt_out.FillSignatureData(sigdata);\n+\n+        MutableTransactionSignatureCreator creator(psbtx.tx.get_ptr(), 0, out.nValue, 1);\n+        ProduceSignature(*pwallet, creator, out.scriptPubKey, sigdata);\n+        psbt_out.FromSignatureData(sigdata);\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, psbt_out.hd_keypaths);\n+        }\n+    }\n+    return complete;\n+}\n+\n+UniValue walletprocesspsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"walletprocesspsbt \\\"psbt\\\" ( sign sighashtype )\\n\"\n+            \"\\nUpdate a PSBT with input information from our wallet and then sign inputs\\n\"\n+            \"that we can sign for.\\n\"\n+            + HelpRequiringPassphrase(pwallet) + \"\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                      (string, required) The transaction base64 string\\n\"\n+            \"2. \\\"sign\\\",                     (string, optional, default=true) Also sign the transaction when updating\\n\"\n+            \"3. \\\"sighashtype\\\"            (string, optional, default=ALL) The signature hash type to sign with if not specified by the PSBT. Must be one of\\n\"\n+            \"       \\\"ALL\\\"\\n\"\n+            \"       \\\"NONE\\\"\\n\"\n+            \"       \\\"SINGLE\\\"\\n\"\n+            \"       \\\"ALL|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"NONE|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"SINGLE|ANYONECANPAY\\\"\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"walletprocesspsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    LOCK2(cs_main, pwallet->cs_wallet);\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL, UniValue::VSTR});\n+\n+    // Unserialize the transaction\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get the sighash type\n+    int nHashType = SIGHASH_ALL;\n+    if (!request.params[2].isNull()) {\n+        static std::map<std::string, int> mapSigHashValues = {\n+            {std::string(\"ALL\"), int(SIGHASH_ALL)},\n+            {std::string(\"ALL|ANYONECANPAY\"), int(SIGHASH_ALL|SIGHASH_ANYONECANPAY)},\n+            {std::string(\"NONE\"), int(SIGHASH_NONE)},\n+            {std::string(\"NONE|ANYONECANPAY\"), int(SIGHASH_NONE|SIGHASH_ANYONECANPAY)},\n+            {std::string(\"SINGLE\"), int(SIGHASH_SINGLE)},\n+            {std::string(\"SINGLE|ANYONECANPAY\"), int(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY)},\n+        };\n+        std::string strHashType = request.params[1].get_str();\n+        if (mapSigHashValues.count(strHashType)) {\n+            nHashType = mapSigHashValues[strHashType];\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid sighash param\");\n+        }\n+    }\n+\n+    // Use CTransaction for the constant parts of the\n+    // transaction to avoid rehashing.\n+    const CTransaction txConst(*psbtx.tx);\n+\n+    // Fill transaction with our data and also sign\n+    bool sign = request.params[1].isNull() ? true : request.params[1].get_bool();\n+    bool fComplete = FillPSBT(pwallet, psbtx, &txConst, nHashType, sign);",
    "path": "src/wallet/rpcwallet.cpp",
    "position": null,
    "original_position": 213,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "9e4077a992bc647f36f724c74ba6c595afe12419",
    "user": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "nit, just `complete`.",
    "created_at": "2018-07-04T21:17:51Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200202117",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200202117"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200202117"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200202117/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4586,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200202478",
    "pull_request_review_id": 134470768,
    "id": 200202478,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDIwMjQ3OA==",
    "diff_hunk": "@@ -4391,6 +4391,339 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n+        return;\n+    }\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    std::vector<uint32_t> keypath;\n+    if (!meta.hdKeypath.empty()) {\n+        if (!ParseHDKeypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), ReadLE32(masterKey.key.GetPubKey().GetID().begin()));\n+    } else { // Single pubkeys get the master fingerprint of themselves\n+        keypath.insert(keypath.begin(), ReadLE32(vchPubKey.GetID().begin()));\n+    }\n+    hd_keypaths.emplace(vchPubKey, keypath);\n+}\n+\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type, bool sign)\n+{\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        const CTxIn& txin = txConst->vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        const uint256& txhash = txin.prevout.hash;\n+        if (pwallet->mapWallet.count(txhash)) {\n+            const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+            CTxOut utxo = wtx.tx->vout[txin.prevout.n];\n+            input.non_witness_utxo = wtx.tx;\n+            input.witness_utxo = utxo;\n+        }\n+\n+        // Get the Sighash type\n+        if (sign && input.sighash_type > 0 && input.sighash_type != sighash_type) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Specified Sighash and sighash in PSBT do not match.\");\n+        }\n+\n+        SignatureData sigdata;\n+        if (sign) {\n+            complete &= SignPSBTInput(*pwallet, *psbtx.tx, input, sigdata, i, sighash_type);\n+        } else {\n+            complete &= SignPSBTInput(PublicOnlySigningProvider(pwallet), *psbtx.tx, input, sigdata, i, sighash_type);\n+        }\n+\n+        // Drop the unnecessary UTXO\n+        if (sigdata.witness) {\n+            input.non_witness_utxo = nullptr;\n+        } else {\n+            input.witness_utxo.SetNull();\n+        }\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, input.hd_keypaths);\n+        }\n+    }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    for (unsigned int i = 0; i < txConst->vout.size(); ++i) {\n+        const CTxOut& out = txConst->vout.at(i);\n+        PSBTOutput& psbt_out = psbtx.outputs.at(i);\n+\n+        // Dummy tx so we can use ProduceSignature to get stuff out\n+        CMutableTransaction dummy_tx;\n+        dummy_tx.vin.push_back(CTxIn());\n+        dummy_tx.vout.push_back(CTxOut());\n+\n+        // Fill a SignatureData with output info\n+        SignatureData sigdata;\n+        psbt_out.FillSignatureData(sigdata);\n+\n+        MutableTransactionSignatureCreator creator(psbtx.tx.get_ptr(), 0, out.nValue, 1);\n+        ProduceSignature(*pwallet, creator, out.scriptPubKey, sigdata);\n+        psbt_out.FromSignatureData(sigdata);\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, psbt_out.hd_keypaths);\n+        }\n+    }\n+    return complete;\n+}\n+\n+UniValue walletprocesspsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"walletprocesspsbt \\\"psbt\\\" ( sign sighashtype )\\n\"\n+            \"\\nUpdate a PSBT with input information from our wallet and then sign inputs\\n\"\n+            \"that we can sign for.\\n\"\n+            + HelpRequiringPassphrase(pwallet) + \"\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                      (string, required) The transaction base64 string\\n\"\n+            \"2. \\\"sign\\\",                     (string, optional, default=true) Also sign the transaction when updating\\n\"\n+            \"3. \\\"sighashtype\\\"            (string, optional, default=ALL) The signature hash type to sign with if not specified by the PSBT. Must be one of\\n\"\n+            \"       \\\"ALL\\\"\\n\"\n+            \"       \\\"NONE\\\"\\n\"\n+            \"       \\\"SINGLE\\\"\\n\"\n+            \"       \\\"ALL|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"NONE|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"SINGLE|ANYONECANPAY\\\"\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"walletprocesspsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    LOCK2(cs_main, pwallet->cs_wallet);",
    "path": "src/wallet/rpcwallet.cpp",
    "position": null,
    "original_position": 178,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "9e4077a992bc647f36f724c74ba6c595afe12419",
    "user": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Why lock `cs_main`? Locking could be in `FillPSBT`?",
    "created_at": "2018-07-04T21:22:09Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200202478",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200202478"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200202478"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200202478/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4567,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200202562",
    "pull_request_review_id": 134470768,
    "id": 200202562,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDIwMjU2Mg==",
    "diff_hunk": "@@ -4391,6 +4391,339 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n+        return;\n+    }\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    std::vector<uint32_t> keypath;\n+    if (!meta.hdKeypath.empty()) {\n+        if (!ParseHDKeypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), ReadLE32(masterKey.key.GetPubKey().GetID().begin()));\n+    } else { // Single pubkeys get the master fingerprint of themselves\n+        keypath.insert(keypath.begin(), ReadLE32(vchPubKey.GetID().begin()));\n+    }\n+    hd_keypaths.emplace(vchPubKey, keypath);\n+}\n+\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type, bool sign)\n+{\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        const CTxIn& txin = txConst->vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        const uint256& txhash = txin.prevout.hash;\n+        if (pwallet->mapWallet.count(txhash)) {\n+            const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+            CTxOut utxo = wtx.tx->vout[txin.prevout.n];\n+            input.non_witness_utxo = wtx.tx;\n+            input.witness_utxo = utxo;\n+        }\n+\n+        // Get the Sighash type\n+        if (sign && input.sighash_type > 0 && input.sighash_type != sighash_type) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Specified Sighash and sighash in PSBT do not match.\");\n+        }\n+\n+        SignatureData sigdata;\n+        if (sign) {\n+            complete &= SignPSBTInput(*pwallet, *psbtx.tx, input, sigdata, i, sighash_type);\n+        } else {\n+            complete &= SignPSBTInput(PublicOnlySigningProvider(pwallet), *psbtx.tx, input, sigdata, i, sighash_type);\n+        }\n+\n+        // Drop the unnecessary UTXO\n+        if (sigdata.witness) {\n+            input.non_witness_utxo = nullptr;\n+        } else {\n+            input.witness_utxo.SetNull();\n+        }\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, input.hd_keypaths);\n+        }\n+    }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    for (unsigned int i = 0; i < txConst->vout.size(); ++i) {\n+        const CTxOut& out = txConst->vout.at(i);\n+        PSBTOutput& psbt_out = psbtx.outputs.at(i);\n+\n+        // Dummy tx so we can use ProduceSignature to get stuff out\n+        CMutableTransaction dummy_tx;\n+        dummy_tx.vin.push_back(CTxIn());\n+        dummy_tx.vout.push_back(CTxOut());\n+\n+        // Fill a SignatureData with output info\n+        SignatureData sigdata;\n+        psbt_out.FillSignatureData(sigdata);\n+\n+        MutableTransactionSignatureCreator creator(psbtx.tx.get_ptr(), 0, out.nValue, 1);\n+        ProduceSignature(*pwallet, creator, out.scriptPubKey, sigdata);\n+        psbt_out.FromSignatureData(sigdata);\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, psbt_out.hd_keypaths);\n+        }\n+    }\n+    return complete;\n+}\n+\n+UniValue walletprocesspsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"walletprocesspsbt \\\"psbt\\\" ( sign sighashtype )\\n\"\n+            \"\\nUpdate a PSBT with input information from our wallet and then sign inputs\\n\"\n+            \"that we can sign for.\\n\"\n+            + HelpRequiringPassphrase(pwallet) + \"\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                      (string, required) The transaction base64 string\\n\"\n+            \"2. \\\"sign\\\",                     (string, optional, default=true) Also sign the transaction when updating\\n\"",
    "path": "src/wallet/rpcwallet.cpp",
    "position": null,
    "original_position": 158,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "9e4077a992bc647f36f724c74ba6c595afe12419",
    "user": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "boolean? Drop `\\\"` in `sign`.",
    "created_at": "2018-07-04T21:23:33Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200202562",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200202562"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200202562"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200202562/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4547,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200202663",
    "pull_request_review_id": 134470768,
    "id": 200202663,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDIwMjY2Mw==",
    "diff_hunk": "@@ -4391,6 +4391,339 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n+        return;\n+    }\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    std::vector<uint32_t> keypath;\n+    if (!meta.hdKeypath.empty()) {\n+        if (!ParseHDKeypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), ReadLE32(masterKey.key.GetPubKey().GetID().begin()));\n+    } else { // Single pubkeys get the master fingerprint of themselves\n+        keypath.insert(keypath.begin(), ReadLE32(vchPubKey.GetID().begin()));\n+    }\n+    hd_keypaths.emplace(vchPubKey, keypath);\n+}\n+\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type, bool sign)\n+{\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        const CTxIn& txin = txConst->vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        const uint256& txhash = txin.prevout.hash;\n+        if (pwallet->mapWallet.count(txhash)) {\n+            const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+            CTxOut utxo = wtx.tx->vout[txin.prevout.n];\n+            input.non_witness_utxo = wtx.tx;\n+            input.witness_utxo = utxo;\n+        }\n+\n+        // Get the Sighash type\n+        if (sign && input.sighash_type > 0 && input.sighash_type != sighash_type) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Specified Sighash and sighash in PSBT do not match.\");\n+        }\n+\n+        SignatureData sigdata;\n+        if (sign) {\n+            complete &= SignPSBTInput(*pwallet, *psbtx.tx, input, sigdata, i, sighash_type);\n+        } else {\n+            complete &= SignPSBTInput(PublicOnlySigningProvider(pwallet), *psbtx.tx, input, sigdata, i, sighash_type);\n+        }\n+\n+        // Drop the unnecessary UTXO\n+        if (sigdata.witness) {\n+            input.non_witness_utxo = nullptr;\n+        } else {\n+            input.witness_utxo.SetNull();\n+        }\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, input.hd_keypaths);\n+        }\n+    }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    for (unsigned int i = 0; i < txConst->vout.size(); ++i) {\n+        const CTxOut& out = txConst->vout.at(i);\n+        PSBTOutput& psbt_out = psbtx.outputs.at(i);\n+\n+        // Dummy tx so we can use ProduceSignature to get stuff out\n+        CMutableTransaction dummy_tx;\n+        dummy_tx.vin.push_back(CTxIn());\n+        dummy_tx.vout.push_back(CTxOut());\n+\n+        // Fill a SignatureData with output info\n+        SignatureData sigdata;\n+        psbt_out.FillSignatureData(sigdata);\n+\n+        MutableTransactionSignatureCreator creator(psbtx.tx.get_ptr(), 0, out.nValue, 1);\n+        ProduceSignature(*pwallet, creator, out.scriptPubKey, sigdata);\n+        psbt_out.FromSignatureData(sigdata);\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, psbt_out.hd_keypaths);\n+        }\n+    }\n+    return complete;\n+}\n+\n+UniValue walletprocesspsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"walletprocesspsbt \\\"psbt\\\" ( sign sighashtype )\\n\"",
    "path": "src/wallet/rpcwallet.cpp",
    "position": null,
    "original_position": 151,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "9e4077a992bc647f36f724c74ba6c595afe12419",
    "user": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "`\"sighashtype\"`?",
    "created_at": "2018-07-04T21:25:03Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200202663",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200202663"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200202663"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200202663/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4540,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200202834",
    "pull_request_review_id": 134470768,
    "id": 200202834,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDIwMjgzNA==",
    "diff_hunk": "@@ -109,6 +109,11 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"combinerawtransaction\", 0, \"txs\" },\n     { \"fundrawtransaction\", 1, \"options\" },\n     { \"fundrawtransaction\", 2, \"iswitness\" },\n+    { \"walletcreatefundedpsbt\", 0, \"inputs\" },\n+    { \"walletcreatefundedpsbt\", 1, \"outputs\" },\n+    { \"walletcreatefundedpsbt\", 2, \"locktime\" },\n+    { \"walletcreatefundedpsbt\", 3, \"replaceable\" },\n+    { \"walletcreatefundedpsbt\", 4, \"options\" },\n     { \"createpsbt\", 0, \"inputs\" },",
    "path": "src/rpc/client.cpp",
    "position": null,
    "original_position": 9,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "9e4077a992bc647f36f724c74ba6c595afe12419",
    "user": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Missing `{ \"walletprocesspsbt\", 1, \"sign\" }`?",
    "created_at": "2018-07-04T21:27:27Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200202834",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200202834"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200202834"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200202834/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 120,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200202931",
    "pull_request_review_id": 134470768,
    "id": 200202931,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDIwMjkzMQ==",
    "diff_hunk": "@@ -4391,6 +4391,339 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n+        return;\n+    }\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    std::vector<uint32_t> keypath;\n+    if (!meta.hdKeypath.empty()) {\n+        if (!ParseHDKeypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), ReadLE32(masterKey.key.GetPubKey().GetID().begin()));\n+    } else { // Single pubkeys get the master fingerprint of themselves\n+        keypath.insert(keypath.begin(), ReadLE32(vchPubKey.GetID().begin()));\n+    }\n+    hd_keypaths.emplace(vchPubKey, keypath);\n+}\n+\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type, bool sign)\n+{\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        const CTxIn& txin = txConst->vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        const uint256& txhash = txin.prevout.hash;\n+        if (pwallet->mapWallet.count(txhash)) {",
    "path": "src/wallet/rpcwallet.cpp",
    "position": null,
    "original_position": 82,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "9e4077a992bc647f36f724c74ba6c595afe12419",
    "user": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Use find to avoid 2nd lookup below.",
    "created_at": "2018-07-04T21:28:45Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200202931",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200202931"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200202931"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200202931/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4471,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200354449",
    "pull_request_review_id": 134652869,
    "id": 200354449,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDM1NDQ0OQ==",
    "diff_hunk": "@@ -434,3 +466,160 @@ bool IsSolvable(const SigningProvider& provider, const CScript& script)\n     }\n     return false;\n }\n+\n+\n+bool PartiallySignedTransaction::IsNull() const\n+{\n+    return !tx && inputs.empty() && outputs.empty() && unknown.empty();\n+}\n+\n+void PartiallySignedTransaction::Merge(const PartiallySignedTransaction& psbt)\n+{\n+    for (unsigned int i = 0; i < inputs.size(); ++i) {\n+        inputs[i].Merge(psbt.inputs[i]);\n+    }\n+    for (unsigned int i = 0; i < outputs.size(); ++i) {\n+        outputs[i].Merge(psbt.outputs[i]);\n+    }\n+}\n+\n+bool PartiallySignedTransaction::IsSane() const\n+{\n+    for (PSBTInput input : inputs) {\n+        if (!input.IsSane()) return false;\n+    }\n+    return true;\n+}\n+\n+bool PSBTInput::IsNull() const\n+{\n+    return !non_witness_utxo && witness_utxo.IsNull() && partial_sigs.empty() && unknown.empty() && hd_keypaths.empty() && redeem_script.empty() && witness_script.empty();\n+}\n+\n+void PSBTInput::FillSignatureData(SignatureData& sigdata) const\n+{\n+    if (!final_script_sig.empty()) {\n+        sigdata.scriptSig = final_script_sig;\n+        sigdata.complete = true;\n+    }\n+    if (!final_script_witness.IsNull()) {\n+        sigdata.scriptWitness = final_script_witness;\n+        sigdata.complete = true;\n+    }\n+    if (sigdata.complete) {\n+        return;\n+    }\n+\n+    sigdata.signatures.insert(partial_sigs.begin(), partial_sigs.end());\n+    if (!redeem_script.empty()) {\n+        sigdata.redeem_script = redeem_script;\n+    }\n+    if (!witness_script.empty()) {\n+        sigdata.witness_script = witness_script;\n+    }\n+    for (const auto& key_pair : hd_keypaths) {\n+        sigdata.misc_pubkeys.emplace(key_pair.first.GetID(), key_pair.first);\n+    }\n+}\n+\n+void PSBTInput::FromSignatureData(const SignatureData& sigdata)\n+{\n+    if (sigdata.complete) {\n+        partial_sigs.clear();\n+        hd_keypaths.clear();\n+        redeem_script.clear();\n+        witness_script.clear();\n+\n+        if (!sigdata.scriptSig.empty()) {\n+            final_script_sig = sigdata.scriptSig;\n+        }\n+        if (!sigdata.scriptWitness.IsNull()) {\n+            final_script_witness = sigdata.scriptWitness;\n+        }\n+        return;\n+    }\n+\n+    partial_sigs.insert(sigdata.signatures.begin(), sigdata.signatures.end());\n+    if (redeem_script.empty() && !sigdata.redeem_script.empty()) {\n+        redeem_script = sigdata.redeem_script;\n+    }\n+    if (witness_script.empty() && !sigdata.witness_script.empty()) {\n+        witness_script = sigdata.witness_script;\n+    }\n+}\n+\n+void PSBTInput::Merge(const PSBTInput& input)\n+{\n+    if (!non_witness_utxo && input.non_witness_utxo) non_witness_utxo = input.non_witness_utxo;\n+    if (witness_utxo.IsNull() && !input.witness_utxo.IsNull()) {\n+        witness_utxo = input.witness_utxo;\n+        non_witness_utxo = nullptr; // Clear out any non-witness utxo when we set a witness one.\n+    }\n+\n+    partial_sigs.insert(input.partial_sigs.begin(), input.partial_sigs.end());\n+    hd_keypaths.insert(input.hd_keypaths.begin(), input.hd_keypaths.end());\n+    unknown.insert(input.unknown.begin(), input.unknown.end());\n+\n+    if (redeem_script.empty() && !input.redeem_script.empty()) redeem_script = input.redeem_script;\n+    if (witness_script.empty() && !input.witness_script.empty()) witness_script = input.witness_script;\n+    if (final_script_sig.empty() && !input.final_script_sig.empty()) final_script_sig = input.final_script_sig;\n+    if (final_script_witness.IsNull() && !input.final_script_witness.IsNull()) final_script_witness = input.final_script_witness;\n+}\n+\n+bool PSBTInput::IsSane() const\n+{\n+    // Cannot have both witness and non-witness utxos\n+    if (!witness_utxo.IsNull() && non_witness_utxo) return false;\n+\n+    // If we have a witness_script or a scriptWitness, we must also have a witness utxo\n+    if (!witness_script.empty() && witness_utxo.IsNull()) return false;\n+    if (!final_script_witness.IsNull() && witness_utxo.IsNull()) return false;\n+\n+    return true;\n+}\n+\n+void PSBTOutput::FillSignatureData(SignatureData& sigdata) const\n+{\n+    if (!redeem_script.empty()) {\n+        sigdata.redeem_script = redeem_script;\n+    }\n+    if (!witness_script.empty()) {\n+        sigdata.witness_script = witness_script;\n+    }\n+    for (const auto& key_pair : hd_keypaths) {\n+        sigdata.misc_pubkeys.emplace(key_pair.first.GetID(), key_pair.first);\n+    }\n+}\n+\n+void PSBTOutput::FromSignatureData(const SignatureData& sigdata)\n+{\n+    if (redeem_script.empty() && !sigdata.redeem_script.empty()) {\n+        redeem_script = sigdata.redeem_script;\n+    }\n+    if (witness_script.empty() && !sigdata.witness_script.empty()) {\n+        witness_script = sigdata.witness_script;\n+    }\n+}\n+\n+bool PSBTOutput::IsNull() const\n+{\n+    return redeem_script.empty() && witness_script.empty() && hd_keypaths.empty() && unknown.empty();\n+}\n+\n+void PSBTOutput::Merge(const PSBTOutput& output)",
    "path": "src/script/sign.cpp",
    "position": 233,
    "original_position": 689,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "dbd6d74ec6057af9afd97973d138ed44e49411dd",
    "user": {
      "login": "araspitzu",
      "id": 2931875,
      "node_id": "MDQ6VXNlcjI5MzE4NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2931875?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/araspitzu",
      "html_url": "https://github.com/araspitzu",
      "followers_url": "https://api.github.com/users/araspitzu/followers",
      "following_url": "https://api.github.com/users/araspitzu/following{/other_user}",
      "gists_url": "https://api.github.com/users/araspitzu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/araspitzu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/araspitzu/subscriptions",
      "organizations_url": "https://api.github.com/users/araspitzu/orgs",
      "repos_url": "https://api.github.com/users/araspitzu/repos",
      "events_url": "https://api.github.com/users/araspitzu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/araspitzu/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Perhaps i'm missing something but shouldn't we merge the unknowns from the output too? (as done in PSBTInput::Merge)",
    "created_at": "2018-07-05T13:37:48Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200354449",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "NONE",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200354449"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200354449"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200354449/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 609,
    "original_line": 609,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200487223",
    "pull_request_review_id": 134814973,
    "id": 200487223,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDQ4NzIyMw==",
    "diff_hunk": "@@ -73,6 +77,542 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+// Magic bytes\n+static constexpr uint8_t PSBT_MAGIC_BYTES[4] = {'p', 's', 'b', 't'};\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 39,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "dfa5afe665d95c2dbb5447d48526528d2570ecb3",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "micro-nit: period after key seems misplaced",
    "created_at": "2018-07-05T20:55:30Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200487223",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200487223"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200487223"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200487223/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 103,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200488395",
    "pull_request_review_id": 134814973,
    "id": 200488395,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDQ4ODM5NQ==",
    "diff_hunk": "@@ -73,6 +77,542 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+// Magic bytes\n+static constexpr uint8_t PSBT_MAGIC_BYTES[4] = {'p', 's', 'b', 't'};\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static constexpr uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+template<typename Stream>\n+void DeserializeHDKeypaths(Stream& s, const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)",
    "path": "src/script/sign.h",
    "position": 99,
    "original_position": 68,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "dfa5afe665d95c2dbb5447d48526528d2570ecb3",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "this deserialized a single keypath, right?\r\n\r\nUpdate description, function name to something like `DeserializeAndAppendHDKeypath`, and rename `hd_keypaths` to `hd_keypath`.",
    "created_at": "2018-07-05T21:00:12Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200488395",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200488395"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200488395"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200488395/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 145,
    "original_line": 145,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200488912",
    "pull_request_review_id": 134814973,
    "id": 200488912,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDQ4ODkxMg==",
    "diff_hunk": "@@ -73,6 +77,542 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+// Magic bytes\n+static constexpr uint8_t PSBT_MAGIC_BYTES[4] = {'p', 's', 'b', 't'};\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static constexpr uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+template<typename Stream>\n+void DeserializeHDKeypaths(Stream& s, const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    // Make sure that the key is the size of pubkey + 1\n+    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+    }\n+    // Read in the pubkey from key\n+    CPubKey pubkey(key.begin() + 1, key.end());\n+    if (!pubkey.IsFullyValid()) {\n+       throw std::ios_base::failure(\"Invalid pubkey\");\n+    }\n+    if (hd_keypaths.count(pubkey) > 0) {\n+        throw std::ios_base::failure(\"Duplicate Key, pubkey derivation path already provided\");\n+    }\n+\n+    // Read in key path\n+    uint64_t value_len = ReadCompactSize(s);\n+    std::vector<uint32_t> keypath;\n+    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+        uint32_t index;\n+        s >> index;\n+        keypath.push_back(index);\n+    }\n+\n+    // Add to map\n+    hd_keypaths.emplace(pubkey, keypath);\n+}\n+\n+// Serialize HD keypaths to a stream from a map\n+template<typename Stream>\n+void SerializeHDKeypaths(Stream& s, const std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, uint8_t type)\n+{\n+    for (auto keypath_pair : hd_keypaths) {\n+        SerializeToVector(s, type, MakeSpan(keypath_pair.first));\n+        WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+        for (auto& path : keypath_pair.second) {\n+            s << path;\n+        }\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 109,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "dfa5afe665d95c2dbb5447d48526528d2570ecb3",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "micro-nit: per-input",
    "created_at": "2018-07-05T21:02:25Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200488912",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200488912"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200488912"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200488912/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 173,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200503394",
    "pull_request_review_id": 134834157,
    "id": 200503394,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDUwMzM5NA==",
    "diff_hunk": "@@ -4391,6 +4391,339 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n+        return;\n+    }\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    std::vector<uint32_t> keypath;\n+    if (!meta.hdKeypath.empty()) {\n+        if (!ParseHDKeypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), ReadLE32(masterKey.key.GetPubKey().GetID().begin()));\n+    } else { // Single pubkeys get the master fingerprint of themselves\n+        keypath.insert(keypath.begin(), ReadLE32(vchPubKey.GetID().begin()));\n+    }\n+    hd_keypaths.emplace(vchPubKey, keypath);\n+}\n+\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type, bool sign)\n+{\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        const CTxIn& txin = txConst->vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        const uint256& txhash = txin.prevout.hash;\n+        if (pwallet->mapWallet.count(txhash)) {\n+            const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+            CTxOut utxo = wtx.tx->vout[txin.prevout.n];\n+            input.non_witness_utxo = wtx.tx;\n+            input.witness_utxo = utxo;\n+        }\n+\n+        // Get the Sighash type\n+        if (sign && input.sighash_type > 0 && input.sighash_type != sighash_type) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Specified Sighash and sighash in PSBT do not match.\");\n+        }\n+\n+        SignatureData sigdata;\n+        if (sign) {\n+            complete &= SignPSBTInput(*pwallet, *psbtx.tx, input, sigdata, i, sighash_type);\n+        } else {\n+            complete &= SignPSBTInput(PublicOnlySigningProvider(pwallet), *psbtx.tx, input, sigdata, i, sighash_type);\n+        }\n+\n+        // Drop the unnecessary UTXO\n+        if (sigdata.witness) {\n+            input.non_witness_utxo = nullptr;\n+        } else {\n+            input.witness_utxo.SetNull();\n+        }\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, input.hd_keypaths);\n+        }\n+    }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    for (unsigned int i = 0; i < txConst->vout.size(); ++i) {\n+        const CTxOut& out = txConst->vout.at(i);\n+        PSBTOutput& psbt_out = psbtx.outputs.at(i);\n+\n+        // Dummy tx so we can use ProduceSignature to get stuff out\n+        CMutableTransaction dummy_tx;\n+        dummy_tx.vin.push_back(CTxIn());\n+        dummy_tx.vout.push_back(CTxOut());\n+\n+        // Fill a SignatureData with output info\n+        SignatureData sigdata;\n+        psbt_out.FillSignatureData(sigdata);\n+\n+        MutableTransactionSignatureCreator creator(psbtx.tx.get_ptr(), 0, out.nValue, 1);\n+        ProduceSignature(*pwallet, creator, out.scriptPubKey, sigdata);\n+        psbt_out.FromSignatureData(sigdata);\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, psbt_out.hd_keypaths);\n+        }\n+    }\n+    return complete;\n+}\n+\n+UniValue walletprocesspsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)",
    "path": "src/wallet/rpcwallet.cpp",
    "position": 389,
    "original_position": 149,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "9e4077a992bc647f36f724c74ba6c595afe12419",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Fixed",
    "created_at": "2018-07-05T22:08:43Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200503394",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200503394"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200503394"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200503394/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 4544,
    "original_line": 4544,
    "side": "RIGHT",
    "in_reply_to_id": 200201430
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200503416",
    "pull_request_review_id": 134834192,
    "id": 200503416,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDUwMzQxNg==",
    "diff_hunk": "@@ -4391,6 +4391,339 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n+        return;\n+    }\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    std::vector<uint32_t> keypath;\n+    if (!meta.hdKeypath.empty()) {\n+        if (!ParseHDKeypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), ReadLE32(masterKey.key.GetPubKey().GetID().begin()));\n+    } else { // Single pubkeys get the master fingerprint of themselves\n+        keypath.insert(keypath.begin(), ReadLE32(vchPubKey.GetID().begin()));\n+    }\n+    hd_keypaths.emplace(vchPubKey, keypath);\n+}\n+\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type, bool sign)\n+{\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        const CTxIn& txin = txConst->vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        const uint256& txhash = txin.prevout.hash;\n+        if (pwallet->mapWallet.count(txhash)) {\n+            const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+            CTxOut utxo = wtx.tx->vout[txin.prevout.n];\n+            input.non_witness_utxo = wtx.tx;\n+            input.witness_utxo = utxo;\n+        }\n+\n+        // Get the Sighash type\n+        if (sign && input.sighash_type > 0 && input.sighash_type != sighash_type) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Specified Sighash and sighash in PSBT do not match.\");\n+        }\n+\n+        SignatureData sigdata;\n+        if (sign) {\n+            complete &= SignPSBTInput(*pwallet, *psbtx.tx, input, sigdata, i, sighash_type);\n+        } else {\n+            complete &= SignPSBTInput(PublicOnlySigningProvider(pwallet), *psbtx.tx, input, sigdata, i, sighash_type);\n+        }\n+\n+        // Drop the unnecessary UTXO\n+        if (sigdata.witness) {\n+            input.non_witness_utxo = nullptr;\n+        } else {\n+            input.witness_utxo.SetNull();\n+        }\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, input.hd_keypaths);\n+        }\n+    }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    for (unsigned int i = 0; i < txConst->vout.size(); ++i) {\n+        const CTxOut& out = txConst->vout.at(i);\n+        PSBTOutput& psbt_out = psbtx.outputs.at(i);\n+\n+        // Dummy tx so we can use ProduceSignature to get stuff out\n+        CMutableTransaction dummy_tx;\n+        dummy_tx.vin.push_back(CTxIn());\n+        dummy_tx.vout.push_back(CTxOut());\n+\n+        // Fill a SignatureData with output info\n+        SignatureData sigdata;\n+        psbt_out.FillSignatureData(sigdata);\n+\n+        MutableTransactionSignatureCreator creator(psbtx.tx.get_ptr(), 0, out.nValue, 1);\n+        ProduceSignature(*pwallet, creator, out.scriptPubKey, sigdata);\n+        psbt_out.FromSignatureData(sigdata);\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, psbt_out.hd_keypaths);\n+        }\n+    }\n+    return complete;\n+}\n+\n+UniValue walletprocesspsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"walletprocesspsbt \\\"psbt\\\" ( sign sighashtype )\\n\"\n+            \"\\nUpdate a PSBT with input information from our wallet and then sign inputs\\n\"\n+            \"that we can sign for.\\n\"\n+            + HelpRequiringPassphrase(pwallet) + \"\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                      (string, required) The transaction base64 string\\n\"\n+            \"2. \\\"sign\\\",                     (string, optional, default=true) Also sign the transaction when updating\\n\"\n+            \"3. \\\"sighashtype\\\"            (string, optional, default=ALL) The signature hash type to sign with if not specified by the PSBT. Must be one of\\n\"\n+            \"       \\\"ALL\\\"\\n\"\n+            \"       \\\"NONE\\\"\\n\"\n+            \"       \\\"SINGLE\\\"\\n\"\n+            \"       \\\"ALL|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"NONE|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"SINGLE|ANYONECANPAY\\\"\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"walletprocesspsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    LOCK2(cs_main, pwallet->cs_wallet);\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL, UniValue::VSTR});\n+\n+    // Unserialize the transaction\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get the sighash type\n+    int nHashType = SIGHASH_ALL;\n+    if (!request.params[2].isNull()) {\n+        static std::map<std::string, int> mapSigHashValues = {\n+            {std::string(\"ALL\"), int(SIGHASH_ALL)},\n+            {std::string(\"ALL|ANYONECANPAY\"), int(SIGHASH_ALL|SIGHASH_ANYONECANPAY)},\n+            {std::string(\"NONE\"), int(SIGHASH_NONE)},\n+            {std::string(\"NONE|ANYONECANPAY\"), int(SIGHASH_NONE|SIGHASH_ANYONECANPAY)},\n+            {std::string(\"SINGLE\"), int(SIGHASH_SINGLE)},\n+            {std::string(\"SINGLE|ANYONECANPAY\"), int(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY)},\n+        };\n+        std::string strHashType = request.params[1].get_str();\n+        if (mapSigHashValues.count(strHashType)) {\n+            nHashType = mapSigHashValues[strHashType];\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid sighash param\");\n+        }\n+    }\n+\n+    // Use CTransaction for the constant parts of the\n+    // transaction to avoid rehashing.\n+    const CTransaction txConst(*psbtx.tx);\n+\n+    // Fill transaction with our data and also sign\n+    bool sign = request.params[1].isNull() ? true : request.params[1].get_bool();\n+    bool fComplete = FillPSBT(pwallet, psbtx, &txConst, nHashType, sign);",
    "path": "src/wallet/rpcwallet.cpp",
    "position": null,
    "original_position": 213,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "9e4077a992bc647f36f724c74ba6c595afe12419",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-07-05T22:08:54Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200503416",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200503416"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200503416"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200503416/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4586,
    "side": "RIGHT",
    "in_reply_to_id": 200202117
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200503468",
    "pull_request_review_id": 134834248,
    "id": 200503468,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDUwMzQ2OA==",
    "diff_hunk": "@@ -4391,6 +4391,339 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n+        return;\n+    }\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    std::vector<uint32_t> keypath;\n+    if (!meta.hdKeypath.empty()) {\n+        if (!ParseHDKeypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), ReadLE32(masterKey.key.GetPubKey().GetID().begin()));\n+    } else { // Single pubkeys get the master fingerprint of themselves\n+        keypath.insert(keypath.begin(), ReadLE32(vchPubKey.GetID().begin()));\n+    }\n+    hd_keypaths.emplace(vchPubKey, keypath);\n+}\n+\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type, bool sign)\n+{\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        const CTxIn& txin = txConst->vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        const uint256& txhash = txin.prevout.hash;\n+        if (pwallet->mapWallet.count(txhash)) {\n+            const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+            CTxOut utxo = wtx.tx->vout[txin.prevout.n];\n+            input.non_witness_utxo = wtx.tx;\n+            input.witness_utxo = utxo;\n+        }\n+\n+        // Get the Sighash type\n+        if (sign && input.sighash_type > 0 && input.sighash_type != sighash_type) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Specified Sighash and sighash in PSBT do not match.\");\n+        }\n+\n+        SignatureData sigdata;\n+        if (sign) {\n+            complete &= SignPSBTInput(*pwallet, *psbtx.tx, input, sigdata, i, sighash_type);\n+        } else {\n+            complete &= SignPSBTInput(PublicOnlySigningProvider(pwallet), *psbtx.tx, input, sigdata, i, sighash_type);\n+        }\n+\n+        // Drop the unnecessary UTXO\n+        if (sigdata.witness) {\n+            input.non_witness_utxo = nullptr;\n+        } else {\n+            input.witness_utxo.SetNull();\n+        }\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, input.hd_keypaths);\n+        }\n+    }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    for (unsigned int i = 0; i < txConst->vout.size(); ++i) {\n+        const CTxOut& out = txConst->vout.at(i);\n+        PSBTOutput& psbt_out = psbtx.outputs.at(i);\n+\n+        // Dummy tx so we can use ProduceSignature to get stuff out\n+        CMutableTransaction dummy_tx;\n+        dummy_tx.vin.push_back(CTxIn());\n+        dummy_tx.vout.push_back(CTxOut());\n+\n+        // Fill a SignatureData with output info\n+        SignatureData sigdata;\n+        psbt_out.FillSignatureData(sigdata);\n+\n+        MutableTransactionSignatureCreator creator(psbtx.tx.get_ptr(), 0, out.nValue, 1);\n+        ProduceSignature(*pwallet, creator, out.scriptPubKey, sigdata);\n+        psbt_out.FromSignatureData(sigdata);\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, psbt_out.hd_keypaths);\n+        }\n+    }\n+    return complete;\n+}\n+\n+UniValue walletprocesspsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"walletprocesspsbt \\\"psbt\\\" ( sign sighashtype )\\n\"\n+            \"\\nUpdate a PSBT with input information from our wallet and then sign inputs\\n\"\n+            \"that we can sign for.\\n\"\n+            + HelpRequiringPassphrase(pwallet) + \"\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                      (string, required) The transaction base64 string\\n\"\n+            \"2. \\\"sign\\\",                     (string, optional, default=true) Also sign the transaction when updating\\n\"\n+            \"3. \\\"sighashtype\\\"            (string, optional, default=ALL) The signature hash type to sign with if not specified by the PSBT. Must be one of\\n\"\n+            \"       \\\"ALL\\\"\\n\"\n+            \"       \\\"NONE\\\"\\n\"\n+            \"       \\\"SINGLE\\\"\\n\"\n+            \"       \\\"ALL|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"NONE|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"SINGLE|ANYONECANPAY\\\"\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"walletprocesspsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    LOCK2(cs_main, pwallet->cs_wallet);",
    "path": "src/wallet/rpcwallet.cpp",
    "position": null,
    "original_position": 178,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "9e4077a992bc647f36f724c74ba6c595afe12419",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Removed `cs_main`, moved to `FillPSBT`.",
    "created_at": "2018-07-05T22:09:09Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200503468",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200503468"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200503468"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200503468/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4567,
    "side": "RIGHT",
    "in_reply_to_id": 200202478
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200503791",
    "pull_request_review_id": 134834642,
    "id": 200503791,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDUwMzc5MQ==",
    "diff_hunk": "@@ -4391,6 +4391,339 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n+        return;\n+    }\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    std::vector<uint32_t> keypath;\n+    if (!meta.hdKeypath.empty()) {\n+        if (!ParseHDKeypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), ReadLE32(masterKey.key.GetPubKey().GetID().begin()));\n+    } else { // Single pubkeys get the master fingerprint of themselves\n+        keypath.insert(keypath.begin(), ReadLE32(vchPubKey.GetID().begin()));\n+    }\n+    hd_keypaths.emplace(vchPubKey, keypath);\n+}\n+\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type, bool sign)\n+{\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        const CTxIn& txin = txConst->vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        const uint256& txhash = txin.prevout.hash;\n+        if (pwallet->mapWallet.count(txhash)) {\n+            const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+            CTxOut utxo = wtx.tx->vout[txin.prevout.n];\n+            input.non_witness_utxo = wtx.tx;\n+            input.witness_utxo = utxo;\n+        }\n+\n+        // Get the Sighash type\n+        if (sign && input.sighash_type > 0 && input.sighash_type != sighash_type) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Specified Sighash and sighash in PSBT do not match.\");\n+        }\n+\n+        SignatureData sigdata;\n+        if (sign) {\n+            complete &= SignPSBTInput(*pwallet, *psbtx.tx, input, sigdata, i, sighash_type);\n+        } else {\n+            complete &= SignPSBTInput(PublicOnlySigningProvider(pwallet), *psbtx.tx, input, sigdata, i, sighash_type);\n+        }\n+\n+        // Drop the unnecessary UTXO\n+        if (sigdata.witness) {\n+            input.non_witness_utxo = nullptr;\n+        } else {\n+            input.witness_utxo.SetNull();\n+        }\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, input.hd_keypaths);\n+        }\n+    }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    for (unsigned int i = 0; i < txConst->vout.size(); ++i) {\n+        const CTxOut& out = txConst->vout.at(i);\n+        PSBTOutput& psbt_out = psbtx.outputs.at(i);\n+\n+        // Dummy tx so we can use ProduceSignature to get stuff out\n+        CMutableTransaction dummy_tx;\n+        dummy_tx.vin.push_back(CTxIn());\n+        dummy_tx.vout.push_back(CTxOut());\n+\n+        // Fill a SignatureData with output info\n+        SignatureData sigdata;\n+        psbt_out.FillSignatureData(sigdata);\n+\n+        MutableTransactionSignatureCreator creator(psbtx.tx.get_ptr(), 0, out.nValue, 1);\n+        ProduceSignature(*pwallet, creator, out.scriptPubKey, sigdata);\n+        psbt_out.FromSignatureData(sigdata);\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, psbt_out.hd_keypaths);\n+        }\n+    }\n+    return complete;\n+}\n+\n+UniValue walletprocesspsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"walletprocesspsbt \\\"psbt\\\" ( sign sighashtype )\\n\"\n+            \"\\nUpdate a PSBT with input information from our wallet and then sign inputs\\n\"\n+            \"that we can sign for.\\n\"\n+            + HelpRequiringPassphrase(pwallet) + \"\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                      (string, required) The transaction base64 string\\n\"\n+            \"2. \\\"sign\\\",                     (string, optional, default=true) Also sign the transaction when updating\\n\"",
    "path": "src/wallet/rpcwallet.cpp",
    "position": null,
    "original_position": 158,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "9e4077a992bc647f36f724c74ba6c595afe12419",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Fixed",
    "created_at": "2018-07-05T22:11:03Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200503791",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200503791"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200503791"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200503791/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4547,
    "side": "RIGHT",
    "in_reply_to_id": 200202562
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200503799",
    "pull_request_review_id": 134834661,
    "id": 200503799,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDUwMzc5OQ==",
    "diff_hunk": "@@ -4391,6 +4391,339 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n+        return;\n+    }\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    std::vector<uint32_t> keypath;\n+    if (!meta.hdKeypath.empty()) {\n+        if (!ParseHDKeypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), ReadLE32(masterKey.key.GetPubKey().GetID().begin()));\n+    } else { // Single pubkeys get the master fingerprint of themselves\n+        keypath.insert(keypath.begin(), ReadLE32(vchPubKey.GetID().begin()));\n+    }\n+    hd_keypaths.emplace(vchPubKey, keypath);\n+}\n+\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type, bool sign)\n+{\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        const CTxIn& txin = txConst->vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        const uint256& txhash = txin.prevout.hash;\n+        if (pwallet->mapWallet.count(txhash)) {\n+            const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+            CTxOut utxo = wtx.tx->vout[txin.prevout.n];\n+            input.non_witness_utxo = wtx.tx;\n+            input.witness_utxo = utxo;\n+        }\n+\n+        // Get the Sighash type\n+        if (sign && input.sighash_type > 0 && input.sighash_type != sighash_type) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Specified Sighash and sighash in PSBT do not match.\");\n+        }\n+\n+        SignatureData sigdata;\n+        if (sign) {\n+            complete &= SignPSBTInput(*pwallet, *psbtx.tx, input, sigdata, i, sighash_type);\n+        } else {\n+            complete &= SignPSBTInput(PublicOnlySigningProvider(pwallet), *psbtx.tx, input, sigdata, i, sighash_type);\n+        }\n+\n+        // Drop the unnecessary UTXO\n+        if (sigdata.witness) {\n+            input.non_witness_utxo = nullptr;\n+        } else {\n+            input.witness_utxo.SetNull();\n+        }\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, input.hd_keypaths);\n+        }\n+    }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    for (unsigned int i = 0; i < txConst->vout.size(); ++i) {\n+        const CTxOut& out = txConst->vout.at(i);\n+        PSBTOutput& psbt_out = psbtx.outputs.at(i);\n+\n+        // Dummy tx so we can use ProduceSignature to get stuff out\n+        CMutableTransaction dummy_tx;\n+        dummy_tx.vin.push_back(CTxIn());\n+        dummy_tx.vout.push_back(CTxOut());\n+\n+        // Fill a SignatureData with output info\n+        SignatureData sigdata;\n+        psbt_out.FillSignatureData(sigdata);\n+\n+        MutableTransactionSignatureCreator creator(psbtx.tx.get_ptr(), 0, out.nValue, 1);\n+        ProduceSignature(*pwallet, creator, out.scriptPubKey, sigdata);\n+        psbt_out.FromSignatureData(sigdata);\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, psbt_out.hd_keypaths);\n+        }\n+    }\n+    return complete;\n+}\n+\n+UniValue walletprocesspsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"walletprocesspsbt \\\"psbt\\\" ( sign sighashtype )\\n\"",
    "path": "src/wallet/rpcwallet.cpp",
    "position": null,
    "original_position": 151,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "9e4077a992bc647f36f724c74ba6c595afe12419",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Fixed",
    "created_at": "2018-07-05T22:11:09Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200503799",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200503799"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200503799"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200503799/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4540,
    "side": "RIGHT",
    "in_reply_to_id": 200202663
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200503808",
    "pull_request_review_id": 134834671,
    "id": 200503808,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDUwMzgwOA==",
    "diff_hunk": "@@ -109,6 +109,11 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"combinerawtransaction\", 0, \"txs\" },\n     { \"fundrawtransaction\", 1, \"options\" },\n     { \"fundrawtransaction\", 2, \"iswitness\" },\n+    { \"walletcreatefundedpsbt\", 0, \"inputs\" },\n+    { \"walletcreatefundedpsbt\", 1, \"outputs\" },\n+    { \"walletcreatefundedpsbt\", 2, \"locktime\" },\n+    { \"walletcreatefundedpsbt\", 3, \"replaceable\" },\n+    { \"walletcreatefundedpsbt\", 4, \"options\" },\n     { \"createpsbt\", 0, \"inputs\" },",
    "path": "src/rpc/client.cpp",
    "position": null,
    "original_position": 9,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "9e4077a992bc647f36f724c74ba6c595afe12419",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Added",
    "created_at": "2018-07-05T22:11:12Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200503808",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200503808"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200503808"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200503808/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 120,
    "side": "RIGHT",
    "in_reply_to_id": 200202834
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200503828",
    "pull_request_review_id": 134834691,
    "id": 200503828,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDUwMzgyOA==",
    "diff_hunk": "@@ -4391,6 +4391,339 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n+        return;\n+    }\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    std::vector<uint32_t> keypath;\n+    if (!meta.hdKeypath.empty()) {\n+        if (!ParseHDKeypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), ReadLE32(masterKey.key.GetPubKey().GetID().begin()));\n+    } else { // Single pubkeys get the master fingerprint of themselves\n+        keypath.insert(keypath.begin(), ReadLE32(vchPubKey.GetID().begin()));\n+    }\n+    hd_keypaths.emplace(vchPubKey, keypath);\n+}\n+\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type, bool sign)\n+{\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        const CTxIn& txin = txConst->vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        const uint256& txhash = txin.prevout.hash;\n+        if (pwallet->mapWallet.count(txhash)) {",
    "path": "src/wallet/rpcwallet.cpp",
    "position": null,
    "original_position": 82,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "9e4077a992bc647f36f724c74ba6c595afe12419",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-07-05T22:11:17Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200503828",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200503828"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200503828"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200503828/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4471,
    "side": "RIGHT",
    "in_reply_to_id": 200202931
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200503847",
    "pull_request_review_id": 134834716,
    "id": 200503847,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDUwMzg0Nw==",
    "diff_hunk": "@@ -434,3 +466,160 @@ bool IsSolvable(const SigningProvider& provider, const CScript& script)\n     }\n     return false;\n }\n+\n+\n+bool PartiallySignedTransaction::IsNull() const\n+{\n+    return !tx && inputs.empty() && outputs.empty() && unknown.empty();\n+}\n+\n+void PartiallySignedTransaction::Merge(const PartiallySignedTransaction& psbt)\n+{\n+    for (unsigned int i = 0; i < inputs.size(); ++i) {\n+        inputs[i].Merge(psbt.inputs[i]);\n+    }\n+    for (unsigned int i = 0; i < outputs.size(); ++i) {\n+        outputs[i].Merge(psbt.outputs[i]);\n+    }\n+}\n+\n+bool PartiallySignedTransaction::IsSane() const\n+{\n+    for (PSBTInput input : inputs) {\n+        if (!input.IsSane()) return false;\n+    }\n+    return true;\n+}\n+\n+bool PSBTInput::IsNull() const\n+{\n+    return !non_witness_utxo && witness_utxo.IsNull() && partial_sigs.empty() && unknown.empty() && hd_keypaths.empty() && redeem_script.empty() && witness_script.empty();\n+}\n+\n+void PSBTInput::FillSignatureData(SignatureData& sigdata) const\n+{\n+    if (!final_script_sig.empty()) {\n+        sigdata.scriptSig = final_script_sig;\n+        sigdata.complete = true;\n+    }\n+    if (!final_script_witness.IsNull()) {\n+        sigdata.scriptWitness = final_script_witness;\n+        sigdata.complete = true;\n+    }\n+    if (sigdata.complete) {\n+        return;\n+    }\n+\n+    sigdata.signatures.insert(partial_sigs.begin(), partial_sigs.end());\n+    if (!redeem_script.empty()) {\n+        sigdata.redeem_script = redeem_script;\n+    }\n+    if (!witness_script.empty()) {\n+        sigdata.witness_script = witness_script;\n+    }\n+    for (const auto& key_pair : hd_keypaths) {\n+        sigdata.misc_pubkeys.emplace(key_pair.first.GetID(), key_pair.first);\n+    }\n+}\n+\n+void PSBTInput::FromSignatureData(const SignatureData& sigdata)\n+{\n+    if (sigdata.complete) {\n+        partial_sigs.clear();\n+        hd_keypaths.clear();\n+        redeem_script.clear();\n+        witness_script.clear();\n+\n+        if (!sigdata.scriptSig.empty()) {\n+            final_script_sig = sigdata.scriptSig;\n+        }\n+        if (!sigdata.scriptWitness.IsNull()) {\n+            final_script_witness = sigdata.scriptWitness;\n+        }\n+        return;\n+    }\n+\n+    partial_sigs.insert(sigdata.signatures.begin(), sigdata.signatures.end());\n+    if (redeem_script.empty() && !sigdata.redeem_script.empty()) {\n+        redeem_script = sigdata.redeem_script;\n+    }\n+    if (witness_script.empty() && !sigdata.witness_script.empty()) {\n+        witness_script = sigdata.witness_script;\n+    }\n+}\n+\n+void PSBTInput::Merge(const PSBTInput& input)\n+{\n+    if (!non_witness_utxo && input.non_witness_utxo) non_witness_utxo = input.non_witness_utxo;\n+    if (witness_utxo.IsNull() && !input.witness_utxo.IsNull()) {\n+        witness_utxo = input.witness_utxo;\n+        non_witness_utxo = nullptr; // Clear out any non-witness utxo when we set a witness one.\n+    }\n+\n+    partial_sigs.insert(input.partial_sigs.begin(), input.partial_sigs.end());\n+    hd_keypaths.insert(input.hd_keypaths.begin(), input.hd_keypaths.end());\n+    unknown.insert(input.unknown.begin(), input.unknown.end());\n+\n+    if (redeem_script.empty() && !input.redeem_script.empty()) redeem_script = input.redeem_script;\n+    if (witness_script.empty() && !input.witness_script.empty()) witness_script = input.witness_script;\n+    if (final_script_sig.empty() && !input.final_script_sig.empty()) final_script_sig = input.final_script_sig;\n+    if (final_script_witness.IsNull() && !input.final_script_witness.IsNull()) final_script_witness = input.final_script_witness;\n+}\n+\n+bool PSBTInput::IsSane() const\n+{\n+    // Cannot have both witness and non-witness utxos\n+    if (!witness_utxo.IsNull() && non_witness_utxo) return false;\n+\n+    // If we have a witness_script or a scriptWitness, we must also have a witness utxo\n+    if (!witness_script.empty() && witness_utxo.IsNull()) return false;\n+    if (!final_script_witness.IsNull() && witness_utxo.IsNull()) return false;\n+\n+    return true;\n+}\n+\n+void PSBTOutput::FillSignatureData(SignatureData& sigdata) const\n+{\n+    if (!redeem_script.empty()) {\n+        sigdata.redeem_script = redeem_script;\n+    }\n+    if (!witness_script.empty()) {\n+        sigdata.witness_script = witness_script;\n+    }\n+    for (const auto& key_pair : hd_keypaths) {\n+        sigdata.misc_pubkeys.emplace(key_pair.first.GetID(), key_pair.first);\n+    }\n+}\n+\n+void PSBTOutput::FromSignatureData(const SignatureData& sigdata)\n+{\n+    if (redeem_script.empty() && !sigdata.redeem_script.empty()) {\n+        redeem_script = sigdata.redeem_script;\n+    }\n+    if (witness_script.empty() && !sigdata.witness_script.empty()) {\n+        witness_script = sigdata.witness_script;\n+    }\n+}\n+\n+bool PSBTOutput::IsNull() const\n+{\n+    return redeem_script.empty() && witness_script.empty() && hd_keypaths.empty() && unknown.empty();\n+}\n+\n+void PSBTOutput::Merge(const PSBTOutput& output)",
    "path": "src/script/sign.cpp",
    "position": 233,
    "original_position": 689,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "dbd6d74ec6057af9afd97973d138ed44e49411dd",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Good catch, fixed",
    "created_at": "2018-07-05T22:11:24Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200503847",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200503847"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200503847"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200503847/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 609,
    "original_line": 609,
    "side": "RIGHT",
    "in_reply_to_id": 200354449
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200507551",
    "pull_request_review_id": 134839139,
    "id": 200507551,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDUwNzU1MQ==",
    "diff_hunk": "@@ -4391,6 +4391,339 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n+        return;\n+    }\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    std::vector<uint32_t> keypath;\n+    if (!meta.hdKeypath.empty()) {\n+        if (!ParseHDKeypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), ReadLE32(masterKey.key.GetPubKey().GetID().begin()));\n+    } else { // Single pubkeys get the master fingerprint of themselves\n+        keypath.insert(keypath.begin(), ReadLE32(vchPubKey.GetID().begin()));\n+    }\n+    hd_keypaths.emplace(vchPubKey, keypath);\n+}\n+\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type, bool sign)\n+{\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        const CTxIn& txin = txConst->vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        const uint256& txhash = txin.prevout.hash;\n+        if (pwallet->mapWallet.count(txhash)) {\n+            const CWalletTx& wtx = pwallet->mapWallet.at(txhash);\n+            CTxOut utxo = wtx.tx->vout[txin.prevout.n];\n+            input.non_witness_utxo = wtx.tx;\n+            input.witness_utxo = utxo;\n+        }\n+\n+        // Get the Sighash type\n+        if (sign && input.sighash_type > 0 && input.sighash_type != sighash_type) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Specified Sighash and sighash in PSBT do not match.\");\n+        }\n+\n+        SignatureData sigdata;\n+        if (sign) {\n+            complete &= SignPSBTInput(*pwallet, *psbtx.tx, input, sigdata, i, sighash_type);\n+        } else {\n+            complete &= SignPSBTInput(PublicOnlySigningProvider(pwallet), *psbtx.tx, input, sigdata, i, sighash_type);\n+        }\n+\n+        // Drop the unnecessary UTXO\n+        if (sigdata.witness) {\n+            input.non_witness_utxo = nullptr;\n+        } else {\n+            input.witness_utxo.SetNull();\n+        }\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, input.hd_keypaths);\n+        }\n+    }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    for (unsigned int i = 0; i < txConst->vout.size(); ++i) {\n+        const CTxOut& out = txConst->vout.at(i);\n+        PSBTOutput& psbt_out = psbtx.outputs.at(i);\n+\n+        // Dummy tx so we can use ProduceSignature to get stuff out\n+        CMutableTransaction dummy_tx;\n+        dummy_tx.vin.push_back(CTxIn());\n+        dummy_tx.vout.push_back(CTxOut());\n+\n+        // Fill a SignatureData with output info\n+        SignatureData sigdata;\n+        psbt_out.FillSignatureData(sigdata);\n+\n+        MutableTransactionSignatureCreator creator(psbtx.tx.get_ptr(), 0, out.nValue, 1);\n+        ProduceSignature(*pwallet, creator, out.scriptPubKey, sigdata);\n+        psbt_out.FromSignatureData(sigdata);\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, psbt_out.hd_keypaths);\n+        }\n+    }\n+    return complete;\n+}\n+\n+UniValue walletprocesspsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"walletprocesspsbt \\\"psbt\\\" ( sign sighashtype )\\n\"\n+            \"\\nUpdate a PSBT with input information from our wallet and then sign inputs\\n\"\n+            \"that we can sign for.\\n\"\n+            + HelpRequiringPassphrase(pwallet) + \"\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                      (string, required) The transaction base64 string\\n\"\n+            \"2. \\\"sign\\\",                     (string, optional, default=true) Also sign the transaction when updating\\n\"\n+            \"3. \\\"sighashtype\\\"            (string, optional, default=ALL) The signature hash type to sign with if not specified by the PSBT. Must be one of\\n\"\n+            \"       \\\"ALL\\\"\\n\"\n+            \"       \\\"NONE\\\"\\n\"\n+            \"       \\\"SINGLE\\\"\\n\"\n+            \"       \\\"ALL|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"NONE|ANYONECANPAY\\\"\\n\"\n+            \"       \\\"SINGLE|ANYONECANPAY\\\"\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"walletprocesspsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    LOCK2(cs_main, pwallet->cs_wallet);\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL, UniValue::VSTR});\n+\n+    // Unserialize the transaction\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get the sighash type\n+    int nHashType = SIGHASH_ALL;\n+    if (!request.params[2].isNull()) {\n+        static std::map<std::string, int> mapSigHashValues = {\n+            {std::string(\"ALL\"), int(SIGHASH_ALL)},\n+            {std::string(\"ALL|ANYONECANPAY\"), int(SIGHASH_ALL|SIGHASH_ANYONECANPAY)},\n+            {std::string(\"NONE\"), int(SIGHASH_NONE)},\n+            {std::string(\"NONE|ANYONECANPAY\"), int(SIGHASH_NONE|SIGHASH_ANYONECANPAY)},\n+            {std::string(\"SINGLE\"), int(SIGHASH_SINGLE)},\n+            {std::string(\"SINGLE|ANYONECANPAY\"), int(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY)},\n+        };\n+        std::string strHashType = request.params[1].get_str();",
    "path": "src/wallet/rpcwallet.cpp",
    "position": null,
    "original_position": 199,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "9e4077a992bc647f36f724c74ba6c595afe12419",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Moved to a new helper function.",
    "created_at": "2018-07-05T22:33:41Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200507551",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200507551"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200507551"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200507551/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4588,
    "side": "RIGHT",
    "in_reply_to_id": 200201761
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200617738",
    "pull_request_review_id": 134969494,
    "id": 200617738,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDYxNzczOA==",
    "diff_hunk": "@@ -62,24 +77,579 @@ typedef std::pair<CPubKey, std::vector<unsigned char>> SigPair;\n // in order to construct final scriptSigs and scriptWitnesses.\n struct SignatureData {\n     bool complete = false; ///< Stores whether the scriptSig and scriptWitness are complete\n+    bool witness = false; ///< Stores whether the input this SigData corresponds to is a witness input\n     CScript scriptSig; ///< The scriptSig of an input. Contains complete signatures or the traditional partial signatures format\n     CScript redeem_script; ///< The redeemScript (if any) for the input\n     CScript witness_script; ///< The witnessScript (if any) for the input. witnessScripts are used in P2WSH outputs.\n     CScriptWitness scriptWitness; ///< The scriptWitness of an input. Contains complete signatures or the traditional partial signatures format. scriptWitness is part of a transaction input per BIP 144.\n     std::map<CKeyID, SigPair> signatures; ///< BIP 174 style partial signatures for the input. May contain all signatures necessary for producing a final scriptSig or scriptWitness.\n+    std::map<CKeyID, CPubKey> misc_pubkeys;\n \n     SignatureData() {}\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+// Magic bytes\n+static constexpr uint8_t PSBT_MAGIC_BYTES[4] = {'p', 's', 'b', 't'};\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static constexpr uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+template<typename Stream>\n+void DeserializeHDKeypaths(Stream& s, const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    // Make sure that the key is the size of pubkey + 1\n+    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+    }\n+    // Read in the pubkey from key\n+    CPubKey pubkey(key.begin() + 1, key.end());\n+    if (!pubkey.IsFullyValid()) {\n+       throw std::ios_base::failure(\"Invalid pubkey\");\n+    }\n+    if (hd_keypaths.count(pubkey) > 0) {\n+        throw std::ios_base::failure(\"Duplicate Key, pubkey derivation path already provided\");\n+    }\n+\n+    // Read in key path\n+    uint64_t value_len = ReadCompactSize(s);\n+    std::vector<uint32_t> keypath;\n+    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+        uint32_t index;\n+        s >> index;\n+        keypath.push_back(index);\n+    }\n+\n+    // Add to map\n+    hd_keypaths.emplace(pubkey, keypath);\n+}\n+\n+// Serialize HD keypaths to a stream from a map\n+template<typename Stream>\n+void SerializeHDKeypaths(Stream& s, const std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, uint8_t type)",
    "path": "src/script/sign.h",
    "position": 129,
    "original_position": 129,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "8415956f703b950308e3fc1b955b84977fd9e66a",
    "user": {
      "login": "araspitzu",
      "id": 2931875,
      "node_id": "MDQ6VXNlcjI5MzE4NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2931875?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/araspitzu",
      "html_url": "https://github.com/araspitzu",
      "followers_url": "https://api.github.com/users/araspitzu/followers",
      "following_url": "https://api.github.com/users/araspitzu/following{/other_user}",
      "gists_url": "https://api.github.com/users/araspitzu/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/araspitzu/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/araspitzu/subscriptions",
      "organizations_url": "https://api.github.com/users/araspitzu/orgs",
      "repos_url": "https://api.github.com/users/araspitzu/repos",
      "events_url": "https://api.github.com/users/araspitzu/events{/privacy}",
      "received_events_url": "https://api.github.com/users/araspitzu/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I'm having some trouble matching this code to the spec, with the HD keypaths shouldn't we prefix the \"value\" (as in the key/value entry) with the fingerprint of the public key? I don't see where it's done here (and neither in 'DeserializeHDKeypaths').",
    "created_at": "2018-07-06T10:47:20Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200617738",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "NONE",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200617738"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200617738"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200617738/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 175,
    "original_line": 175,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200734682",
    "pull_request_review_id": 135113433,
    "id": 200734682,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDczNDY4Mg==",
    "diff_hunk": "@@ -62,24 +77,579 @@ typedef std::pair<CPubKey, std::vector<unsigned char>> SigPair;\n // in order to construct final scriptSigs and scriptWitnesses.\n struct SignatureData {\n     bool complete = false; ///< Stores whether the scriptSig and scriptWitness are complete\n+    bool witness = false; ///< Stores whether the input this SigData corresponds to is a witness input\n     CScript scriptSig; ///< The scriptSig of an input. Contains complete signatures or the traditional partial signatures format\n     CScript redeem_script; ///< The redeemScript (if any) for the input\n     CScript witness_script; ///< The witnessScript (if any) for the input. witnessScripts are used in P2WSH outputs.\n     CScriptWitness scriptWitness; ///< The scriptWitness of an input. Contains complete signatures or the traditional partial signatures format. scriptWitness is part of a transaction input per BIP 144.\n     std::map<CKeyID, SigPair> signatures; ///< BIP 174 style partial signatures for the input. May contain all signatures necessary for producing a final scriptSig or scriptWitness.\n+    std::map<CKeyID, CPubKey> misc_pubkeys;\n \n     SignatureData() {}\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+// Magic bytes\n+static constexpr uint8_t PSBT_MAGIC_BYTES[4] = {'p', 's', 'b', 't'};\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static constexpr uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+template<typename Stream>\n+void DeserializeHDKeypaths(Stream& s, const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    // Make sure that the key is the size of pubkey + 1\n+    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+    }\n+    // Read in the pubkey from key\n+    CPubKey pubkey(key.begin() + 1, key.end());\n+    if (!pubkey.IsFullyValid()) {\n+       throw std::ios_base::failure(\"Invalid pubkey\");\n+    }\n+    if (hd_keypaths.count(pubkey) > 0) {\n+        throw std::ios_base::failure(\"Duplicate Key, pubkey derivation path already provided\");\n+    }\n+\n+    // Read in key path\n+    uint64_t value_len = ReadCompactSize(s);\n+    std::vector<uint32_t> keypath;\n+    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+        uint32_t index;\n+        s >> index;\n+        keypath.push_back(index);\n+    }\n+\n+    // Add to map\n+    hd_keypaths.emplace(pubkey, keypath);\n+}\n+\n+// Serialize HD keypaths to a stream from a map\n+template<typename Stream>\n+void SerializeHDKeypaths(Stream& s, const std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, uint8_t type)",
    "path": "src/script/sign.h",
    "position": 129,
    "original_position": 129,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "8415956f703b950308e3fc1b955b84977fd9e66a",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Since the fingerprint is a 4 byte value, we store it with the keypaths as the first element of the `std::vector<uint32_t>`",
    "created_at": "2018-07-06T18:24:55Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200734682",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200734682"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200734682"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200734682/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 175,
    "original_line": 175,
    "side": "RIGHT",
    "in_reply_to_id": 200617738
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200797064",
    "pull_request_review_id": 135187506,
    "id": 200797064,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDc5NzA2NA==",
    "diff_hunk": "@@ -0,0 +1,159 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2014-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the Partially Signed Transaction RPCs.\n+\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+# Create one-input, one-output, no-fee transaction:\n+class PSBTTest(BitcoinTestFramework):\n+\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 3\n+\n+    def run_test(self):\n+\n+        # Get some money and activate segwit\n+        self.nodes[0].generate(500)\n+\n+        # Create and fund a raw tx for sending 10 BTC\n+        psbtx1 = self.nodes[0].walletcreatefundedpsbt([], {self.nodes[2].getnewaddress():10})['psbt']\n+\n+        # Node 1 should not be able to add anything to it but still return the psbtx same as before\n+        psbtx = self.nodes[1].walletprocesspsbt(psbtx1)['psbt']\n+        assert_equal(psbtx1, psbtx)\n+\n+        # Sign the transaction and send\n+        signed_tx = self.nodes[0].walletprocesspsbt(psbtx)['psbt']\n+        final_tx = self.nodes[0].finalizepsbt(signed_tx)['hex']\n+        self.nodes[0].sendrawtransaction(final_tx)\n+\n+        # Create p2sh, p2wpkh, and p2wsh addresses\n+        pubkey0 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())['pubkey']\n+        pubkey1 = self.nodes[1].getaddressinfo(self.nodes[1].getnewaddress())['pubkey']\n+        pubkey2 = self.nodes[2].getaddressinfo(self.nodes[2].getnewaddress())['pubkey']\n+        p2sh = self.nodes[1].addmultisigaddress(2, [pubkey0, pubkey1, pubkey2], \"\", \"legacy\")['address']\n+        p2wsh = self.nodes[1].addmultisigaddress(2, [pubkey0, pubkey1, pubkey2], \"\", \"bech32\")['address']\n+        p2wpkh = self.nodes[1].getnewaddress(\"\", \"legacy\")",
    "path": "test/functional/rpc_psbt.py",
    "position": null,
    "original_position": 41,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "8415956f703b950308e3fc1b955b84977fd9e66a",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "That doesn't look very witnessy.",
    "created_at": "2018-07-07T00:42:48Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200797064",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200797064"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200797064"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200797064/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 41,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200797566",
    "pull_request_review_id": 135188108,
    "id": 200797566,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDc5NzU2Ng==",
    "diff_hunk": "@@ -0,0 +1,159 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2014-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the Partially Signed Transaction RPCs.\n+\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+# Create one-input, one-output, no-fee transaction:\n+class PSBTTest(BitcoinTestFramework):\n+\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 3\n+\n+    def run_test(self):\n+\n+        # Get some money and activate segwit\n+        self.nodes[0].generate(500)\n+\n+        # Create and fund a raw tx for sending 10 BTC\n+        psbtx1 = self.nodes[0].walletcreatefundedpsbt([], {self.nodes[2].getnewaddress():10})['psbt']\n+\n+        # Node 1 should not be able to add anything to it but still return the psbtx same as before\n+        psbtx = self.nodes[1].walletprocesspsbt(psbtx1)['psbt']\n+        assert_equal(psbtx1, psbtx)\n+\n+        # Sign the transaction and send\n+        signed_tx = self.nodes[0].walletprocesspsbt(psbtx)['psbt']\n+        final_tx = self.nodes[0].finalizepsbt(signed_tx)['hex']\n+        self.nodes[0].sendrawtransaction(final_tx)\n+\n+        # Create p2sh, p2wpkh, and p2wsh addresses\n+        pubkey0 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())['pubkey']\n+        pubkey1 = self.nodes[1].getaddressinfo(self.nodes[1].getnewaddress())['pubkey']\n+        pubkey2 = self.nodes[2].getaddressinfo(self.nodes[2].getnewaddress())['pubkey']\n+        p2sh = self.nodes[1].addmultisigaddress(2, [pubkey0, pubkey1, pubkey2], \"\", \"legacy\")['address']\n+        p2wsh = self.nodes[1].addmultisigaddress(2, [pubkey0, pubkey1, pubkey2], \"\", \"bech32\")['address']\n+        p2wpkh = self.nodes[1].getnewaddress(\"\", \"legacy\")",
    "path": "test/functional/rpc_psbt.py",
    "position": null,
    "original_position": 41,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "8415956f703b950308e3fc1b955b84977fd9e66a",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Fixed. Also added tests for p2pkh and p2sh nested things.",
    "created_at": "2018-07-07T00:57:23Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200797566",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200797566"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200797566"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200797566/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 41,
    "side": "RIGHT",
    "in_reply_to_id": 200797064
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200825776",
    "pull_request_review_id": 135218087,
    "id": 200825776,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDgyNTc3Ng==",
    "diff_hunk": "@@ -1262,6 +1263,552 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str.substr(0, keypath_str.size() - 1); // Drop last '/'\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"          {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"       ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"        }\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 197,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "e7707b610ae7c5e22fa947d246d4e893634ea36a",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "It seems you'll need to change the type to `UniValue::VOBJ` above. Calling `pushKV` on an array has no effect (and also doesn't assert/throw anything, it seems...).",
    "created_at": "2018-07-07T23:52:06Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200825776",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200825776"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200825776"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200825776/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1422,
    "side": "RIGHT",
    "in_reply_to_id": 199983146
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200988122",
    "pull_request_review_id": 134814973,
    "id": 200988122,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDk4ODEyMg==",
    "diff_hunk": "@@ -1259,6 +1260,546 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)",
    "path": "src/rpc/rawtransaction.cpp",
    "position": 199,
    "original_position": 12,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "29df1b87e4f5e47bfd1482cdd5de2f6e268034ea",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Doesn't have to be addressed now, but I feel like this should be useful elsewhere too?",
    "created_at": "2018-07-09T12:45:32Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200988122",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200988122"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200988122"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200988122/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1247,
    "original_line": 1247,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200989422",
    "pull_request_review_id": 134814973,
    "id": 200989422,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDk4OTQyMg==",
    "diff_hunk": "@@ -1259,6 +1260,546 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : {             (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"bip32_derivs\\\" : {          (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : {                     (json object, optional) The public key with the derivation path as the value.\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"final_scriptsig\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"        }\\n\"\n+            \"       \\\"final_scriptwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"fee\\\" : fee                      (numeric, optional) The transaction fee paid if all UTXOs are present\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 126,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "29df1b87e4f5e47bfd1482cdd5de2f6e268034ea",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "clarity nit: s/all UTXOs are present/all outputs are currently unspent/",
    "created_at": "2018-07-09T12:50:17Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200989422",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200989422"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200989422"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200989422/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1377,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200993595",
    "pull_request_review_id": 134814973,
    "id": 200993595,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDk5MzU5NQ==",
    "diff_hunk": "@@ -1259,6 +1260,546 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : {             (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"bip32_derivs\\\" : {          (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : {                     (json object, optional) The public key with the derivation path as the value.\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"final_scriptsig\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"        }\\n\"\n+            \"       \\\"final_scriptwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"fee\\\" : fee                      (numeric, optional) The transaction fee paid if all UTXOs are present\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    CAmount total_in = 0;\n+    bool have_all_utxos = true;\n+    UniValue inputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {\n+        const PSBTInput& input = psbtx.inputs[i];\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"amount\", ValueFromAmount(txout.nValue));\n+            total_in += txout.nValue;\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+            total_in += input.non_witness_utxo->vout[psbtx.tx->vin[i].prevout.n].nValue;\n+        } else {\n+            have_all_utxos = false;\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                partial_sigs.pushKV(HexStr(sig.second.first), HexStr(sig.second.second));\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            UniValue scriptsig(UniValue::VOBJ);\n+            scriptsig.pushKV(\"asm\", ScriptToAsmStr(input.final_script_sig, true));\n+            scriptsig.pushKV(\"hex\", HexStr(input.final_script_sig));\n+            in.pushKV(\"final_scriptSig\", scriptsig);\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            UniValue txinwitness(UniValue::VARR);\n+            for (const auto& item : input.final_script_witness.stack) {\n+                txinwitness.push_back(HexStr(item.begin(), item.end()));\n+            }\n+            in.pushKV(\"final_scriptwitness\", txinwitness);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    CAmount output_value = 0;\n+    UniValue outputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.outputs.size(); ++i) {\n+        const PSBTOutput& output = psbtx.outputs[i];\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+\n+        // Fee calculation\n+        output_value += psbtx.tx->vout[i].nValue;\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+    if (have_all_utxos) {\n+        result.pushKV(\"fee\", ValueFromAmount(total_in - output_value));\n+    }\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"psbt\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner role.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        if (*it != merged_psbt) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+        merged_psbt.Merge(*it);\n+    }\n+    if (!merged_psbt.IsSane()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is inconsistent\");\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"psbt\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\\n\"\n+            \"Implements the Finalizer and Extractor roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 372,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "29df1b87e4f5e47bfd1482cdd5de2f6e268034ea",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I'm not sure that this argument is needed. Who is going to use this?",
    "created_at": "2018-07-09T13:04:27Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200993595",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200993595"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200993595"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200993595/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1612,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200997244",
    "pull_request_review_id": 134814973,
    "id": 200997244,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDk5NzI0NA==",
    "diff_hunk": "@@ -1259,6 +1260,546 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : {             (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"bip32_derivs\\\" : {          (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : {                     (json object, optional) The public key with the derivation path as the value.\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"final_scriptsig\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"        }\\n\"\n+            \"       \\\"final_scriptwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"fee\\\" : fee                      (numeric, optional) The transaction fee paid if all UTXOs are present\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    CAmount total_in = 0;\n+    bool have_all_utxos = true;\n+    UniValue inputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {\n+        const PSBTInput& input = psbtx.inputs[i];\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"amount\", ValueFromAmount(txout.nValue));\n+            total_in += txout.nValue;\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+            total_in += input.non_witness_utxo->vout[psbtx.tx->vin[i].prevout.n].nValue;\n+        } else {\n+            have_all_utxos = false;\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                partial_sigs.pushKV(HexStr(sig.second.first), HexStr(sig.second.second));\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            UniValue scriptsig(UniValue::VOBJ);\n+            scriptsig.pushKV(\"asm\", ScriptToAsmStr(input.final_script_sig, true));\n+            scriptsig.pushKV(\"hex\", HexStr(input.final_script_sig));\n+            in.pushKV(\"final_scriptSig\", scriptsig);\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            UniValue txinwitness(UniValue::VARR);\n+            for (const auto& item : input.final_script_witness.stack) {\n+                txinwitness.push_back(HexStr(item.begin(), item.end()));\n+            }\n+            in.pushKV(\"final_scriptwitness\", txinwitness);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    CAmount output_value = 0;\n+    UniValue outputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.outputs.size(); ++i) {\n+        const PSBTOutput& output = psbtx.outputs[i];\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+\n+        // Fee calculation\n+        output_value += psbtx.tx->vout[i].nValue;\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+    if (have_all_utxos) {\n+        result.pushKV(\"fee\", ValueFromAmount(total_in - output_value));\n+    }\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"psbt\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner role.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        if (*it != merged_psbt) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+        merged_psbt.Merge(*it);\n+    }\n+    if (!merged_psbt.IsSane()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is inconsistent\");\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"psbt\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\\n\"\n+            \"Implements the Finalizer and Extractor roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded network transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        SignatureData sigdata;\n+        complete &= SignPSBTInput(DUMMY_SIGNING_PROVIDER, *psbtx.tx, input, sigdata, i, 1);\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\n+    if (complete && extract) {",
    "path": "src/rpc/rawtransaction.cpp",
    "position": 600,
    "original_position": 408,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "29df1b87e4f5e47bfd1482cdd5de2f6e268034ea",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "help didn't make it clear it will only return one or the other. Might explain why someone would want to turn \"extract\" off",
    "created_at": "2018-07-09T13:15:44Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200997244",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200997244"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200997244"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200997244/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1648,
    "original_line": 1648,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200997677",
    "pull_request_review_id": 134814973,
    "id": 200997677,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDk5NzY3Nw==",
    "diff_hunk": "@@ -1259,6 +1260,546 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : {             (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"bip32_derivs\\\" : {          (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : {                     (json object, optional) The public key with the derivation path as the value.\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"final_scriptsig\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"        }\\n\"\n+            \"       \\\"final_scriptwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"fee\\\" : fee                      (numeric, optional) The transaction fee paid if all UTXOs are present\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    CAmount total_in = 0;\n+    bool have_all_utxos = true;\n+    UniValue inputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {\n+        const PSBTInput& input = psbtx.inputs[i];\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"amount\", ValueFromAmount(txout.nValue));\n+            total_in += txout.nValue;\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+            total_in += input.non_witness_utxo->vout[psbtx.tx->vin[i].prevout.n].nValue;\n+        } else {\n+            have_all_utxos = false;\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                partial_sigs.pushKV(HexStr(sig.second.first), HexStr(sig.second.second));\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            UniValue scriptsig(UniValue::VOBJ);\n+            scriptsig.pushKV(\"asm\", ScriptToAsmStr(input.final_script_sig, true));\n+            scriptsig.pushKV(\"hex\", HexStr(input.final_script_sig));\n+            in.pushKV(\"final_scriptSig\", scriptsig);\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            UniValue txinwitness(UniValue::VARR);\n+            for (const auto& item : input.final_script_witness.stack) {\n+                txinwitness.push_back(HexStr(item.begin(), item.end()));\n+            }\n+            in.pushKV(\"final_scriptwitness\", txinwitness);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    CAmount output_value = 0;\n+    UniValue outputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.outputs.size(); ++i) {\n+        const PSBTOutput& output = psbtx.outputs[i];\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+\n+        // Fee calculation\n+        output_value += psbtx.tx->vout[i].nValue;\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+    if (have_all_utxos) {\n+        result.pushKV(\"fee\", ValueFromAmount(total_in - output_value));\n+    }\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"psbt\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner role.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        if (*it != merged_psbt) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+        merged_psbt.Merge(*it);\n+    }\n+    if (!merged_psbt.IsSane()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is inconsistent\");\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"psbt\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\\n\"\n+            \"Implements the Finalizer and Extractor roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded network transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        SignatureData sigdata;\n+        complete &= SignPSBTInput(DUMMY_SIGNING_PROVIDER, *psbtx.tx, input, sigdata, i, 1);\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\n+    if (complete && extract) {\n+        CMutableTransaction mtx(*psbtx.tx);\n+        for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+            mtx.vin[i].scriptSig = psbtx.inputs[i].final_script_sig;\n+            mtx.vin[i].scriptWitness = psbtx.inputs[i].final_script_witness;\n+        }\n+        ssTx << mtx;\n+        result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n+    } else {\n+        ssTx << psbtx;\n+        result.push_back(Pair(\"psbt\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size())));\n+    }\n+    result.push_back(Pair(\"complete\", complete));\n+\n+    return result;\n+}\n+\n+UniValue createpsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n+        throw std::runtime_error(\n+                            \"createpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable )\\n\"\n+                            \"\\nCreates a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"\n+                            \"Implements the Creator role.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"inputs\\\"                (array, required) A json array of json objects\\n\"\n+                            \"     [\\n\"\n+                            \"       {\\n\"\n+                            \"         \\\"txid\\\":\\\"id\\\",      (string, required) The transaction id\\n\"\n+                            \"         \\\"vout\\\":n,         (numeric, required) The output number\\n\"\n+                            \"         \\\"sequence\\\":n      (numeric, optional) The sequence number\\n\"\n+                            \"       } \\n\"\n+                            \"       ,...\\n\"\n+                            \"     ]\\n\"\n+                            \"2. \\\"outputs\\\"               (array, required) a json array with outputs (key-value pairs)\\n\"\n+                            \"   [\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"address\\\": x.xxx,    (obj, optional) A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\\n\"\n+                            \"    },\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"data\\\": \\\"hex\\\"        (obj, optional) A key-value pair. The key must be \\\"data\\\", the value is hex encoded data\\n\"\n+                            \"    }\\n\"\n+                            \"    ,...                     More key-value pairs of the above form. For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n+                            \"                             accepted as second parameter.\\n\"\n+                            \"   ]\\n\"\n+                            \"3. locktime                  (numeric, optional, default=0) Raw locktime. Non-0 value also locktime-activates inputs\\n\"\n+                            \"4. replaceable               (boolean, optional, default=false) Marks this transaction as BIP125 replaceable.\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": 646,
    "original_position": 454,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "29df1b87e4f5e47bfd1482cdd5de2f6e268034ea",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "mu-nit: BIP125-replaceable\r\n\r\nPerhaps the default should be true if the sequence values are compatible? It'd be messy to break API later.",
    "created_at": "2018-07-09T13:17:12Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200997677",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200997677"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200997677"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200997677/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1694,
    "original_line": 1694,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200998753",
    "pull_request_review_id": 134814973,
    "id": 200998753,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDk5ODc1Mw==",
    "diff_hunk": "@@ -1259,6 +1260,546 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : {             (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"bip32_derivs\\\" : {          (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : {                     (json object, optional) The public key with the derivation path as the value.\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"final_scriptsig\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"        }\\n\"\n+            \"       \\\"final_scriptwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"fee\\\" : fee                      (numeric, optional) The transaction fee paid if all UTXOs are present\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    CAmount total_in = 0;\n+    bool have_all_utxos = true;\n+    UniValue inputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {\n+        const PSBTInput& input = psbtx.inputs[i];\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"amount\", ValueFromAmount(txout.nValue));\n+            total_in += txout.nValue;\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+            total_in += input.non_witness_utxo->vout[psbtx.tx->vin[i].prevout.n].nValue;\n+        } else {\n+            have_all_utxos = false;\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                partial_sigs.pushKV(HexStr(sig.second.first), HexStr(sig.second.second));\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            UniValue scriptsig(UniValue::VOBJ);\n+            scriptsig.pushKV(\"asm\", ScriptToAsmStr(input.final_script_sig, true));\n+            scriptsig.pushKV(\"hex\", HexStr(input.final_script_sig));\n+            in.pushKV(\"final_scriptSig\", scriptsig);\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            UniValue txinwitness(UniValue::VARR);\n+            for (const auto& item : input.final_script_witness.stack) {\n+                txinwitness.push_back(HexStr(item.begin(), item.end()));\n+            }\n+            in.pushKV(\"final_scriptwitness\", txinwitness);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    CAmount output_value = 0;\n+    UniValue outputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.outputs.size(); ++i) {\n+        const PSBTOutput& output = psbtx.outputs[i];\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+\n+        // Fee calculation\n+        output_value += psbtx.tx->vout[i].nValue;\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+    if (have_all_utxos) {\n+        result.pushKV(\"fee\", ValueFromAmount(total_in - output_value));\n+    }\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"psbt\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner role.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        if (*it != merged_psbt) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+        merged_psbt.Merge(*it);\n+    }\n+    if (!merged_psbt.IsSane()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is inconsistent\");\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"psbt\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\\n\"\n+            \"Implements the Finalizer and Extractor roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded network transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        SignatureData sigdata;\n+        complete &= SignPSBTInput(DUMMY_SIGNING_PROVIDER, *psbtx.tx, input, sigdata, i, 1);\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\n+    if (complete && extract) {\n+        CMutableTransaction mtx(*psbtx.tx);\n+        for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+            mtx.vin[i].scriptSig = psbtx.inputs[i].final_script_sig;\n+            mtx.vin[i].scriptWitness = psbtx.inputs[i].final_script_witness;\n+        }\n+        ssTx << mtx;\n+        result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n+    } else {\n+        ssTx << psbtx;\n+        result.push_back(Pair(\"psbt\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size())));\n+    }\n+    result.push_back(Pair(\"complete\", complete));\n+\n+    return result;\n+}\n+\n+UniValue createpsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n+        throw std::runtime_error(\n+                            \"createpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable )\\n\"\n+                            \"\\nCreates a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"\n+                            \"Implements the Creator role.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"inputs\\\"                (array, required) A json array of json objects\\n\"\n+                            \"     [\\n\"\n+                            \"       {\\n\"\n+                            \"         \\\"txid\\\":\\\"id\\\",      (string, required) The transaction id\\n\"\n+                            \"         \\\"vout\\\":n,         (numeric, required) The output number\\n\"\n+                            \"         \\\"sequence\\\":n      (numeric, optional) The sequence number\\n\"\n+                            \"       } \\n\"\n+                            \"       ,...\\n\"\n+                            \"     ]\\n\"\n+                            \"2. \\\"outputs\\\"               (array, required) a json array with outputs (key-value pairs)\\n\"\n+                            \"   [\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"address\\\": x.xxx,    (obj, optional) A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\\n\"\n+                            \"    },\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"data\\\": \\\"hex\\\"        (obj, optional) A key-value pair. The key must be \\\"data\\\", the value is hex encoded data\\n\"\n+                            \"    }\\n\"\n+                            \"    ,...                     More key-value pairs of the above form. For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n+                            \"                             accepted as second parameter.\\n\"\n+                            \"   ]\\n\"\n+                            \"3. locktime                  (numeric, optional, default=0) Raw locktime. Non-0 value also locktime-activates inputs\\n\"\n+                            \"4. replaceable               (boolean, optional, default=false) Marks this transaction as BIP125 replaceable.\\n\"\n+                            \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"        (string)  The resulting raw transaction (base64-encoded string)\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"createpsbt\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")\n+                            );\n+\n+\n+    RPCTypeCheck(request.params, {\n+        UniValue::VARR,\n+        UniValueType(), // ARR or OBJ, checked later\n+        UniValue::VNUM,\n+        UniValue::VBOOL,\n+        }, true\n+    );\n+\n+    CMutableTransaction rawTx = ConstructTransaction(request.params[0], request.params[1], request.params[2], request.params[3]);\n+\n+    // Make a blank psbt\n+    PartiallySignedTransaction psbtx;\n+    psbtx.tx = rawTx;\n+    for (unsigned int i = 0; i < rawTx.vin.size(); ++i) {\n+        psbtx.inputs.push_back(PSBTInput());\n+    }\n+    for (unsigned int i = 0; i < rawTx.vout.size(); ++i) {\n+        psbtx.outputs.push_back(PSBTOutput());\n+    }\n+\n+    // Serialize the PSBT\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue converttopsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+                            \"converttopsbt \\\"hexstring\\\" ( permitsigdata iswitness )\\n\"\n+                            \"\\nConverts a network serialized transaction to a PSBT. This should be used only with createrawtransaction and fundrawtransaction\\n\"\n+                            \"createpsbt and walletcreatefundedpsbt should be used for new applications.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"hexstring\\\"              (string, required) The hex string of a raw transaction\\n\"\n+                            \"2. permitsigdata           (boolean, optional) If true, any signatures in the input will be discarded.\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 499,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "29df1b87e4f5e47bfd1482cdd5de2f6e268034ea",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "s/will be discarded/will be discarded but processing will continue/\r\n\r\nwhat's the default value?",
    "created_at": "2018-07-09T13:20:53Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200998753",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200998753"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200998753"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200998753/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1750,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200999246",
    "pull_request_review_id": 134814973,
    "id": 200999246,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDk5OTI0Ng==",
    "diff_hunk": "@@ -1259,6 +1260,546 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : {             (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"bip32_derivs\\\" : {          (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : {                     (json object, optional) The public key with the derivation path as the value.\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"final_scriptsig\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"        }\\n\"\n+            \"       \\\"final_scriptwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"fee\\\" : fee                      (numeric, optional) The transaction fee paid if all UTXOs are present\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    CAmount total_in = 0;\n+    bool have_all_utxos = true;\n+    UniValue inputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {\n+        const PSBTInput& input = psbtx.inputs[i];\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"amount\", ValueFromAmount(txout.nValue));\n+            total_in += txout.nValue;\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+            total_in += input.non_witness_utxo->vout[psbtx.tx->vin[i].prevout.n].nValue;\n+        } else {\n+            have_all_utxos = false;\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                partial_sigs.pushKV(HexStr(sig.second.first), HexStr(sig.second.second));\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            UniValue scriptsig(UniValue::VOBJ);\n+            scriptsig.pushKV(\"asm\", ScriptToAsmStr(input.final_script_sig, true));\n+            scriptsig.pushKV(\"hex\", HexStr(input.final_script_sig));\n+            in.pushKV(\"final_scriptSig\", scriptsig);\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            UniValue txinwitness(UniValue::VARR);\n+            for (const auto& item : input.final_script_witness.stack) {\n+                txinwitness.push_back(HexStr(item.begin(), item.end()));\n+            }\n+            in.pushKV(\"final_scriptwitness\", txinwitness);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    CAmount output_value = 0;\n+    UniValue outputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.outputs.size(); ++i) {\n+        const PSBTOutput& output = psbtx.outputs[i];\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+\n+        // Fee calculation\n+        output_value += psbtx.tx->vout[i].nValue;\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+    if (have_all_utxos) {\n+        result.pushKV(\"fee\", ValueFromAmount(total_in - output_value));\n+    }\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"psbt\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner role.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        if (*it != merged_psbt) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+        merged_psbt.Merge(*it);\n+    }\n+    if (!merged_psbt.IsSane()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is inconsistent\");\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"psbt\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\\n\"\n+            \"Implements the Finalizer and Extractor roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded network transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        SignatureData sigdata;\n+        complete &= SignPSBTInput(DUMMY_SIGNING_PROVIDER, *psbtx.tx, input, sigdata, i, 1);\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\n+    if (complete && extract) {\n+        CMutableTransaction mtx(*psbtx.tx);\n+        for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+            mtx.vin[i].scriptSig = psbtx.inputs[i].final_script_sig;\n+            mtx.vin[i].scriptWitness = psbtx.inputs[i].final_script_witness;\n+        }\n+        ssTx << mtx;\n+        result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n+    } else {\n+        ssTx << psbtx;\n+        result.push_back(Pair(\"psbt\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size())));\n+    }\n+    result.push_back(Pair(\"complete\", complete));\n+\n+    return result;\n+}\n+\n+UniValue createpsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n+        throw std::runtime_error(\n+                            \"createpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable )\\n\"\n+                            \"\\nCreates a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"\n+                            \"Implements the Creator role.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"inputs\\\"                (array, required) A json array of json objects\\n\"\n+                            \"     [\\n\"\n+                            \"       {\\n\"\n+                            \"         \\\"txid\\\":\\\"id\\\",      (string, required) The transaction id\\n\"\n+                            \"         \\\"vout\\\":n,         (numeric, required) The output number\\n\"\n+                            \"         \\\"sequence\\\":n      (numeric, optional) The sequence number\\n\"\n+                            \"       } \\n\"\n+                            \"       ,...\\n\"\n+                            \"     ]\\n\"\n+                            \"2. \\\"outputs\\\"               (array, required) a json array with outputs (key-value pairs)\\n\"\n+                            \"   [\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"address\\\": x.xxx,    (obj, optional) A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\\n\"\n+                            \"    },\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"data\\\": \\\"hex\\\"        (obj, optional) A key-value pair. The key must be \\\"data\\\", the value is hex encoded data\\n\"\n+                            \"    }\\n\"\n+                            \"    ,...                     More key-value pairs of the above form. For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n+                            \"                             accepted as second parameter.\\n\"\n+                            \"   ]\\n\"\n+                            \"3. locktime                  (numeric, optional, default=0) Raw locktime. Non-0 value also locktime-activates inputs\\n\"\n+                            \"4. replaceable               (boolean, optional, default=false) Marks this transaction as BIP125 replaceable.\\n\"\n+                            \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"        (string)  The resulting raw transaction (base64-encoded string)\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"createpsbt\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")\n+                            );\n+\n+\n+    RPCTypeCheck(request.params, {\n+        UniValue::VARR,\n+        UniValueType(), // ARR or OBJ, checked later\n+        UniValue::VNUM,\n+        UniValue::VBOOL,\n+        }, true\n+    );\n+\n+    CMutableTransaction rawTx = ConstructTransaction(request.params[0], request.params[1], request.params[2], request.params[3]);\n+\n+    // Make a blank psbt\n+    PartiallySignedTransaction psbtx;\n+    psbtx.tx = rawTx;\n+    for (unsigned int i = 0; i < rawTx.vin.size(); ++i) {\n+        psbtx.inputs.push_back(PSBTInput());\n+    }\n+    for (unsigned int i = 0; i < rawTx.vout.size(); ++i) {\n+        psbtx.outputs.push_back(PSBTOutput());\n+    }\n+\n+    // Serialize the PSBT\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue converttopsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+                            \"converttopsbt \\\"hexstring\\\" ( permitsigdata iswitness )\\n\"\n+                            \"\\nConverts a network serialized transaction to a PSBT. This should be used only with createrawtransaction and fundrawtransaction\\n\"\n+                            \"createpsbt and walletcreatefundedpsbt should be used for new applications.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"hexstring\\\"              (string, required) The hex string of a raw transaction\\n\"\n+                            \"2. permitsigdata           (boolean, optional) If true, any signatures in the input will be discarded.\\n\"\n+                            \"                              If false, RPC will fail if any signatures are present.\\n\"\n+                            \"3. iswitness               (boolean, optional) Whether the transaction hex is a serialized witness transaction.\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 501,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "29df1b87e4f5e47bfd1482cdd5de2f6e268034ea",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "default value?",
    "created_at": "2018-07-09T13:22:20Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200999246",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200999246"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r200999246"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200999246/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1741,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201000800",
    "pull_request_review_id": 134814973,
    "id": 201000800,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTAwMDgwMA==",
    "diff_hunk": "@@ -28,4 +28,5 @@ bool EnsureWalletIsAvailable(CWallet *, bool avoidException);\n \n UniValue getaddressinfo(const JSONRPCRequest& request);\n UniValue signrawtransactionwithwallet(const JSONRPCRequest& request);\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type = 1, bool sign = true);",
    "path": "src/wallet/rpcwallet.h",
    "position": null,
    "original_position": 4,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "db3ce1c3b324e39bcad28ea170b3523c23e4b39f",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "why not pass by reference if it's going to be there?",
    "created_at": "2018-07-09T13:26:51Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201000800",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201000800"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201000800"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201000800/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 33,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201002334",
    "pull_request_review_id": 134814973,
    "id": 201002334,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTAwMjMzNA==",
    "diff_hunk": "@@ -4390,6 +4390,324 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n+        return;\n+    }\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    std::vector<uint32_t> keypath;\n+    if (!meta.hdKeypath.empty()) {\n+        if (!ParseHDKeypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), ReadLE32(masterKey.key.GetPubKey().GetID().begin()));\n+    } else { // Single pubkeys get the master fingerprint of themselves\n+        keypath.insert(keypath.begin(), ReadLE32(vchPubKey.GetID().begin()));\n+    }\n+    hd_keypaths.emplace(vchPubKey, keypath);\n+}\n+\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type, bool sign)\n+{\n+    LOCK(pwallet->cs_wallet);\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        const CTxIn& txin = txConst->vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        const uint256& txhash = txin.prevout.hash;\n+        const auto& it = pwallet->mapWallet.find(txhash);\n+        if (it != pwallet->mapWallet.end()) {\n+            const CWalletTx& wtx = it->second;\n+            CTxOut utxo = wtx.tx->vout[txin.prevout.n];\n+            input.non_witness_utxo = wtx.tx;\n+            input.witness_utxo = utxo;\n+        }\n+\n+        // Get the Sighash type\n+        if (sign && input.sighash_type > 0 && input.sighash_type != sighash_type) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Specified Sighash and sighash in PSBT do not match.\");\n+        }\n+\n+        SignatureData sigdata;\n+        if (sign) {\n+            complete &= SignPSBTInput(*pwallet, *psbtx.tx, input, sigdata, i, sighash_type);\n+        } else {\n+            complete &= SignPSBTInput(PublicOnlySigningProvider(pwallet), *psbtx.tx, input, sigdata, i, sighash_type);\n+        }\n+\n+        // Drop the unnecessary UTXO\n+        if (sigdata.witness) {\n+            input.non_witness_utxo = nullptr;\n+        } else {\n+            input.witness_utxo.SetNull();\n+        }\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, input.hd_keypaths);\n+        }\n+    }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    for (unsigned int i = 0; i < txConst->vout.size(); ++i) {\n+        const CTxOut& out = txConst->vout.at(i);\n+        PSBTOutput& psbt_out = psbtx.outputs.at(i);\n+\n+        // Dummy tx so we can use ProduceSignature to get stuff out\n+        CMutableTransaction dummy_tx;\n+        dummy_tx.vin.push_back(CTxIn());\n+        dummy_tx.vout.push_back(CTxOut());\n+\n+        // Fill a SignatureData with output info\n+        SignatureData sigdata;\n+        psbt_out.FillSignatureData(sigdata);\n+\n+        MutableTransactionSignatureCreator creator(psbtx.tx.get_ptr(), 0, out.nValue, 1);\n+        ProduceSignature(*pwallet, creator, out.scriptPubKey, sigdata);\n+        psbt_out.FromSignatureData(sigdata);\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, psbt_out.hd_keypaths);\n+        }\n+    }\n+    return complete;\n+}\n+\n+UniValue walletprocesspsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+            \"walletprocesspsbt \\\"psbt\\\" ( sign \\\"sighashtype\\\" )\\n\"\n+            \"\\nUpdate a PSBT with input information from our wallet and then sign inputs\\n\"\n+            \"that we can sign for.\\n\"\n+            + HelpRequiringPassphrase(pwallet) + \"\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                      (string, required) The transaction base64 string\\n\"\n+            \"2. sign,                         (boolean, optional, default=true) Also sign the transaction when updating\\n\"",
    "path": "src/wallet/rpcwallet.cpp",
    "position": null,
    "original_position": 160,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "db3ce1c3b324e39bcad28ea170b3523c23e4b39f",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "comma after sign?",
    "created_at": "2018-07-09T13:31:32Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201002334",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201002334"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201002334"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201002334/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4549,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201002855",
    "pull_request_review_id": 134814973,
    "id": 201002855,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTAwMjg1NQ==",
    "diff_hunk": "@@ -4390,6 +4390,324 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)",
    "path": "src/wallet/rpcwallet.cpp",
    "position": 277,
    "original_position": 43,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "db3ce1c3b324e39bcad28ea170b3523c23e4b39f",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "change this to passing wallet by reference as well?",
    "created_at": "2018-07-09T13:32:55Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201002855",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201002855"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201002855"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201002855/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 4432,
    "original_line": 4432,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201022307",
    "pull_request_review_id": 135441761,
    "id": 201022307,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTAyMjMwNw==",
    "diff_hunk": "@@ -73,6 +77,542 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+// Magic bytes\n+static constexpr uint8_t PSBT_MAGIC_BYTES[4] = {'p', 's', 'b', 't'};\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static constexpr uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+template<typename Stream>\n+void DeserializeHDKeypaths(Stream& s, const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)",
    "path": "src/script/sign.h",
    "position": 99,
    "original_position": 68,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "dfa5afe665d95c2dbb5447d48526528d2570ecb3",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "No, it deserializes all keypaths for one input or one output.",
    "created_at": "2018-07-09T14:28:03Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201022307",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201022307"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201022307"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201022307/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 145,
    "original_line": 145,
    "side": "RIGHT",
    "in_reply_to_id": 200488395
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201023312",
    "pull_request_review_id": 135442998,
    "id": 201023312,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTAyMzMxMg==",
    "diff_hunk": "@@ -73,6 +77,542 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+// Magic bytes\n+static constexpr uint8_t PSBT_MAGIC_BYTES[4] = {'p', 's', 'b', 't'};\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static constexpr uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+template<typename Stream>\n+void DeserializeHDKeypaths(Stream& s, const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)",
    "path": "src/script/sign.h",
    "position": 99,
    "original_position": 68,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "dfa5afe665d95c2dbb5447d48526528d2570ecb3",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I deleted this comment a while back, github reviews thought it was too good I guess",
    "created_at": "2018-07-09T14:30:44Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201023312",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201023312"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201023312"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201023312/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 145,
    "original_line": 145,
    "side": "RIGHT",
    "in_reply_to_id": 200488395
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201023601",
    "pull_request_review_id": 135443348,
    "id": 201023601,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTAyMzYwMQ==",
    "diff_hunk": "@@ -1259,6 +1260,546 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : {             (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"bip32_derivs\\\" : {          (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : {                     (json object, optional) The public key with the derivation path as the value.\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"final_scriptsig\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"        }\\n\"\n+            \"       \\\"final_scriptwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"fee\\\" : fee                      (numeric, optional) The transaction fee paid if all UTXOs are present\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 126,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "29df1b87e4f5e47bfd1482cdd5de2f6e268034ea",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "That's not what it means. The fee can be reported whenever the UTXO information for each transaction input is present in the psbt (this information is generally added by Updater roles).\n\nIt's clearly confusing though, do you have a better way of formulating this?",
    "created_at": "2018-07-09T14:31:39Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201023601",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201023601"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201023601"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201023601/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1377,
    "side": "RIGHT",
    "in_reply_to_id": 200989422
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201025682",
    "pull_request_review_id": 135445977,
    "id": 201025682,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTAyNTY4Mg==",
    "diff_hunk": "@@ -1259,6 +1260,546 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : {             (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"bip32_derivs\\\" : {          (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : {                     (json object, optional) The public key with the derivation path as the value.\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"final_scriptsig\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"        }\\n\"\n+            \"       \\\"final_scriptwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"fee\\\" : fee                      (numeric, optional) The transaction fee paid if all UTXOs are present\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 126,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "29df1b87e4f5e47bfd1482cdd5de2f6e268034ea",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "something like: \"The transaction fee paid if all UTXO slots have been filled in the PSBT\"?",
    "created_at": "2018-07-09T14:37:27Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201025682",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201025682"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201025682"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201025682/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1377,
    "side": "RIGHT",
    "in_reply_to_id": 200989422
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201120192",
    "pull_request_review_id": 135559783,
    "id": 201120192,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTEyMDE5Mg==",
    "diff_hunk": "@@ -1259,6 +1260,546 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : {             (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"bip32_derivs\\\" : {          (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : {                     (json object, optional) The public key with the derivation path as the value.\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"final_scriptsig\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"        }\\n\"\n+            \"       \\\"final_scriptwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"fee\\\" : fee                      (numeric, optional) The transaction fee paid if all UTXOs are present\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    CAmount total_in = 0;\n+    bool have_all_utxos = true;\n+    UniValue inputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {\n+        const PSBTInput& input = psbtx.inputs[i];\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"amount\", ValueFromAmount(txout.nValue));\n+            total_in += txout.nValue;\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+            total_in += input.non_witness_utxo->vout[psbtx.tx->vin[i].prevout.n].nValue;\n+        } else {\n+            have_all_utxos = false;\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                partial_sigs.pushKV(HexStr(sig.second.first), HexStr(sig.second.second));\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            UniValue scriptsig(UniValue::VOBJ);\n+            scriptsig.pushKV(\"asm\", ScriptToAsmStr(input.final_script_sig, true));\n+            scriptsig.pushKV(\"hex\", HexStr(input.final_script_sig));\n+            in.pushKV(\"final_scriptSig\", scriptsig);\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            UniValue txinwitness(UniValue::VARR);\n+            for (const auto& item : input.final_script_witness.stack) {\n+                txinwitness.push_back(HexStr(item.begin(), item.end()));\n+            }\n+            in.pushKV(\"final_scriptwitness\", txinwitness);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    CAmount output_value = 0;\n+    UniValue outputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.outputs.size(); ++i) {\n+        const PSBTOutput& output = psbtx.outputs[i];\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+\n+        // Fee calculation\n+        output_value += psbtx.tx->vout[i].nValue;\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+    if (have_all_utxos) {\n+        result.pushKV(\"fee\", ValueFromAmount(total_in - output_value));\n+    }\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"psbt\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner role.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        if (*it != merged_psbt) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+        merged_psbt.Merge(*it);\n+    }\n+    if (!merged_psbt.IsSane()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is inconsistent\");\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"psbt\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\\n\"\n+            \"Implements the Finalizer and Extractor roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded network transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        SignatureData sigdata;\n+        complete &= SignPSBTInput(DUMMY_SIGNING_PROVIDER, *psbtx.tx, input, sigdata, i, 1);\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\n+    if (complete && extract) {",
    "path": "src/rpc/rawtransaction.cpp",
    "position": 600,
    "original_position": 408,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "29df1b87e4f5e47bfd1482cdd5de2f6e268034ea",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I think the help text is fairly clear that it only has an effect if the transaction is complete. Suggestions for better help text?",
    "created_at": "2018-07-09T19:28:48Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201120192",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201120192"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201120192"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201120192/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1648,
    "original_line": 1648,
    "side": "RIGHT",
    "in_reply_to_id": 200997244
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201120687",
    "pull_request_review_id": 135560401,
    "id": 201120687,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTEyMDY4Nw==",
    "diff_hunk": "@@ -1259,6 +1260,546 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : {             (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"bip32_derivs\\\" : {          (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : {                     (json object, optional) The public key with the derivation path as the value.\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"final_scriptsig\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"        }\\n\"\n+            \"       \\\"final_scriptwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"fee\\\" : fee                      (numeric, optional) The transaction fee paid if all UTXOs are present\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    CAmount total_in = 0;\n+    bool have_all_utxos = true;\n+    UniValue inputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {\n+        const PSBTInput& input = psbtx.inputs[i];\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"amount\", ValueFromAmount(txout.nValue));\n+            total_in += txout.nValue;\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+            total_in += input.non_witness_utxo->vout[psbtx.tx->vin[i].prevout.n].nValue;\n+        } else {\n+            have_all_utxos = false;\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                partial_sigs.pushKV(HexStr(sig.second.first), HexStr(sig.second.second));\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            UniValue scriptsig(UniValue::VOBJ);\n+            scriptsig.pushKV(\"asm\", ScriptToAsmStr(input.final_script_sig, true));\n+            scriptsig.pushKV(\"hex\", HexStr(input.final_script_sig));\n+            in.pushKV(\"final_scriptSig\", scriptsig);\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            UniValue txinwitness(UniValue::VARR);\n+            for (const auto& item : input.final_script_witness.stack) {\n+                txinwitness.push_back(HexStr(item.begin(), item.end()));\n+            }\n+            in.pushKV(\"final_scriptwitness\", txinwitness);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    CAmount output_value = 0;\n+    UniValue outputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.outputs.size(); ++i) {\n+        const PSBTOutput& output = psbtx.outputs[i];\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+\n+        // Fee calculation\n+        output_value += psbtx.tx->vout[i].nValue;\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+    if (have_all_utxos) {\n+        result.pushKV(\"fee\", ValueFromAmount(total_in - output_value));\n+    }\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"psbt\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner role.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        if (*it != merged_psbt) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+        merged_psbt.Merge(*it);\n+    }\n+    if (!merged_psbt.IsSane()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is inconsistent\");\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"psbt\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\\n\"\n+            \"Implements the Finalizer and Extractor roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded network transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        SignatureData sigdata;\n+        complete &= SignPSBTInput(DUMMY_SIGNING_PROVIDER, *psbtx.tx, input, sigdata, i, 1);\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\n+    if (complete && extract) {\n+        CMutableTransaction mtx(*psbtx.tx);\n+        for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+            mtx.vin[i].scriptSig = psbtx.inputs[i].final_script_sig;\n+            mtx.vin[i].scriptWitness = psbtx.inputs[i].final_script_witness;\n+        }\n+        ssTx << mtx;\n+        result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n+    } else {\n+        ssTx << psbtx;\n+        result.push_back(Pair(\"psbt\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size())));\n+    }\n+    result.push_back(Pair(\"complete\", complete));\n+\n+    return result;\n+}\n+\n+UniValue createpsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n+        throw std::runtime_error(\n+                            \"createpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable )\\n\"\n+                            \"\\nCreates a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"\n+                            \"Implements the Creator role.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"inputs\\\"                (array, required) A json array of json objects\\n\"\n+                            \"     [\\n\"\n+                            \"       {\\n\"\n+                            \"         \\\"txid\\\":\\\"id\\\",      (string, required) The transaction id\\n\"\n+                            \"         \\\"vout\\\":n,         (numeric, required) The output number\\n\"\n+                            \"         \\\"sequence\\\":n      (numeric, optional) The sequence number\\n\"\n+                            \"       } \\n\"\n+                            \"       ,...\\n\"\n+                            \"     ]\\n\"\n+                            \"2. \\\"outputs\\\"               (array, required) a json array with outputs (key-value pairs)\\n\"\n+                            \"   [\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"address\\\": x.xxx,    (obj, optional) A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\\n\"\n+                            \"    },\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"data\\\": \\\"hex\\\"        (obj, optional) A key-value pair. The key must be \\\"data\\\", the value is hex encoded data\\n\"\n+                            \"    }\\n\"\n+                            \"    ,...                     More key-value pairs of the above form. For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n+                            \"                             accepted as second parameter.\\n\"\n+                            \"   ]\\n\"\n+                            \"3. locktime                  (numeric, optional, default=0) Raw locktime. Non-0 value also locktime-activates inputs\\n\"\n+                            \"4. replaceable               (boolean, optional, default=false) Marks this transaction as BIP125 replaceable.\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": 646,
    "original_position": 454,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "29df1b87e4f5e47bfd1482cdd5de2f6e268034ea",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "A lot of this is shared with `createrawtransaction` so changing this will also also cause `createrawtransaction`'s API to change. Having it be separate though means that there will be a lot of code duplication.",
    "created_at": "2018-07-09T19:30:48Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201120687",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201120687"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201120687"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201120687/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1694,
    "original_line": 1694,
    "side": "RIGHT",
    "in_reply_to_id": 200997677
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201121361",
    "pull_request_review_id": 135561232,
    "id": 201121361,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTEyMTM2MQ==",
    "diff_hunk": "@@ -1259,6 +1260,546 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : {             (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"bip32_derivs\\\" : {          (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : {                     (json object, optional) The public key with the derivation path as the value.\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"final_scriptsig\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"        }\\n\"\n+            \"       \\\"final_scriptwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"fee\\\" : fee                      (numeric, optional) The transaction fee paid if all UTXOs are present\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    CAmount total_in = 0;\n+    bool have_all_utxos = true;\n+    UniValue inputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {\n+        const PSBTInput& input = psbtx.inputs[i];\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"amount\", ValueFromAmount(txout.nValue));\n+            total_in += txout.nValue;\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+            total_in += input.non_witness_utxo->vout[psbtx.tx->vin[i].prevout.n].nValue;\n+        } else {\n+            have_all_utxos = false;\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                partial_sigs.pushKV(HexStr(sig.second.first), HexStr(sig.second.second));\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            UniValue scriptsig(UniValue::VOBJ);\n+            scriptsig.pushKV(\"asm\", ScriptToAsmStr(input.final_script_sig, true));\n+            scriptsig.pushKV(\"hex\", HexStr(input.final_script_sig));\n+            in.pushKV(\"final_scriptSig\", scriptsig);\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            UniValue txinwitness(UniValue::VARR);\n+            for (const auto& item : input.final_script_witness.stack) {\n+                txinwitness.push_back(HexStr(item.begin(), item.end()));\n+            }\n+            in.pushKV(\"final_scriptwitness\", txinwitness);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    CAmount output_value = 0;\n+    UniValue outputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.outputs.size(); ++i) {\n+        const PSBTOutput& output = psbtx.outputs[i];\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+\n+        // Fee calculation\n+        output_value += psbtx.tx->vout[i].nValue;\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+    if (have_all_utxos) {\n+        result.pushKV(\"fee\", ValueFromAmount(total_in - output_value));\n+    }\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"psbt\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner role.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        if (*it != merged_psbt) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+        merged_psbt.Merge(*it);\n+    }\n+    if (!merged_psbt.IsSane()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is inconsistent\");\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"psbt\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\\n\"\n+            \"Implements the Finalizer and Extractor roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded network transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        SignatureData sigdata;\n+        complete &= SignPSBTInput(DUMMY_SIGNING_PROVIDER, *psbtx.tx, input, sigdata, i, 1);\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\n+    if (complete && extract) {\n+        CMutableTransaction mtx(*psbtx.tx);\n+        for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+            mtx.vin[i].scriptSig = psbtx.inputs[i].final_script_sig;\n+            mtx.vin[i].scriptWitness = psbtx.inputs[i].final_script_witness;\n+        }\n+        ssTx << mtx;\n+        result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n+    } else {\n+        ssTx << psbtx;\n+        result.push_back(Pair(\"psbt\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size())));\n+    }\n+    result.push_back(Pair(\"complete\", complete));\n+\n+    return result;\n+}\n+\n+UniValue createpsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n+        throw std::runtime_error(\n+                            \"createpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable )\\n\"\n+                            \"\\nCreates a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"\n+                            \"Implements the Creator role.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"inputs\\\"                (array, required) A json array of json objects\\n\"\n+                            \"     [\\n\"\n+                            \"       {\\n\"\n+                            \"         \\\"txid\\\":\\\"id\\\",      (string, required) The transaction id\\n\"\n+                            \"         \\\"vout\\\":n,         (numeric, required) The output number\\n\"\n+                            \"         \\\"sequence\\\":n      (numeric, optional) The sequence number\\n\"\n+                            \"       } \\n\"\n+                            \"       ,...\\n\"\n+                            \"     ]\\n\"\n+                            \"2. \\\"outputs\\\"               (array, required) a json array with outputs (key-value pairs)\\n\"\n+                            \"   [\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"address\\\": x.xxx,    (obj, optional) A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\\n\"\n+                            \"    },\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"data\\\": \\\"hex\\\"        (obj, optional) A key-value pair. The key must be \\\"data\\\", the value is hex encoded data\\n\"\n+                            \"    }\\n\"\n+                            \"    ,...                     More key-value pairs of the above form. For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n+                            \"                             accepted as second parameter.\\n\"\n+                            \"   ]\\n\"\n+                            \"3. locktime                  (numeric, optional, default=0) Raw locktime. Non-0 value also locktime-activates inputs\\n\"\n+                            \"4. replaceable               (boolean, optional, default=false) Marks this transaction as BIP125 replaceable.\\n\"\n+                            \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"        (string)  The resulting raw transaction (base64-encoded string)\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"createpsbt\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")\n+                            );\n+\n+\n+    RPCTypeCheck(request.params, {\n+        UniValue::VARR,\n+        UniValueType(), // ARR or OBJ, checked later\n+        UniValue::VNUM,\n+        UniValue::VBOOL,\n+        }, true\n+    );\n+\n+    CMutableTransaction rawTx = ConstructTransaction(request.params[0], request.params[1], request.params[2], request.params[3]);\n+\n+    // Make a blank psbt\n+    PartiallySignedTransaction psbtx;\n+    psbtx.tx = rawTx;\n+    for (unsigned int i = 0; i < rawTx.vin.size(); ++i) {\n+        psbtx.inputs.push_back(PSBTInput());\n+    }\n+    for (unsigned int i = 0; i < rawTx.vout.size(); ++i) {\n+        psbtx.outputs.push_back(PSBTOutput());\n+    }\n+\n+    // Serialize the PSBT\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue converttopsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+                            \"converttopsbt \\\"hexstring\\\" ( permitsigdata iswitness )\\n\"\n+                            \"\\nConverts a network serialized transaction to a PSBT. This should be used only with createrawtransaction and fundrawtransaction\\n\"\n+                            \"createpsbt and walletcreatefundedpsbt should be used for new applications.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"hexstring\\\"              (string, required) The hex string of a raw transaction\\n\"\n+                            \"2. permitsigdata           (boolean, optional) If true, any signatures in the input will be discarded.\\n\"\n+                            \"                              If false, RPC will fail if any signatures are present.\\n\"\n+                            \"3. iswitness               (boolean, optional) Whether the transaction hex is a serialized witness transaction.\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 501,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "29df1b87e4f5e47bfd1482cdd5de2f6e268034ea",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "There really isn't a default value for `iswitness`. Without it being specified, both witness and non-witness are tried. If it is specified, then if it is true, only witness is tried, and false only non-witness is tried.",
    "created_at": "2018-07-09T19:33:33Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201121361",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201121361"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201121361"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201121361/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1741,
    "side": "RIGHT",
    "in_reply_to_id": 200999246
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201121529",
    "pull_request_review_id": 135561448,
    "id": 201121529,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTEyMTUyOQ==",
    "diff_hunk": "@@ -28,4 +28,5 @@ bool EnsureWalletIsAvailable(CWallet *, bool avoidException);\n \n UniValue getaddressinfo(const JSONRPCRequest& request);\n UniValue signrawtransactionwithwallet(const JSONRPCRequest& request);\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type = 1, bool sign = true);",
    "path": "src/wallet/rpcwallet.h",
    "position": null,
    "original_position": 4,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "db3ce1c3b324e39bcad28ea170b3523c23e4b39f",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Which?",
    "created_at": "2018-07-09T19:34:11Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201121529",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201121529"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201121529"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201121529/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 33,
    "side": "RIGHT",
    "in_reply_to_id": 201000800
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201121838",
    "pull_request_review_id": 135561831,
    "id": 201121838,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTEyMTgzOA==",
    "diff_hunk": "@@ -4390,6 +4390,324 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)",
    "path": "src/wallet/rpcwallet.cpp",
    "position": 277,
    "original_position": 43,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "db3ce1c3b324e39bcad28ea170b3523c23e4b39f",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Why? It comes as a pointer, why not just pass the pointer around?",
    "created_at": "2018-07-09T19:35:18Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201121838",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201121838"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201121838"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201121838/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 4432,
    "original_line": 4432,
    "side": "RIGHT",
    "in_reply_to_id": 201002855
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201121901",
    "pull_request_review_id": 135561934,
    "id": 201121901,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTEyMTkwMQ==",
    "diff_hunk": "@@ -1253,6 +1244,546 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : {             (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"bip32_derivs\\\" : {          (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : {                     (json object, optional) The public key with the derivation path as the value.\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"final_scriptsig\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"        }\\n\"\n+            \"       \\\"final_scriptwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"fee\\\" : fee                      (numeric, optional) The transaction fee paid if all UTXOs are present\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    CAmount total_in = 0;\n+    bool have_all_utxos = true;\n+    UniValue inputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {\n+        const PSBTInput& input = psbtx.inputs[i];\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"amount\", ValueFromAmount(txout.nValue));\n+            total_in += txout.nValue;\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+            total_in += input.non_witness_utxo->vout[psbtx.tx->vin[i].prevout.n].nValue;\n+        } else {\n+            have_all_utxos = false;\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                partial_sigs.pushKV(HexStr(sig.second.first), HexStr(sig.second.second));\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            UniValue scriptsig(UniValue::VOBJ);\n+            scriptsig.pushKV(\"asm\", ScriptToAsmStr(input.final_script_sig, true));\n+            scriptsig.pushKV(\"hex\", HexStr(input.final_script_sig));\n+            in.pushKV(\"final_scriptSig\", scriptsig);\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            UniValue txinwitness(UniValue::VARR);\n+            for (const auto& item : input.final_script_witness.stack) {\n+                txinwitness.push_back(HexStr(item.begin(), item.end()));\n+            }\n+            in.pushKV(\"final_scriptwitness\", txinwitness);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    CAmount output_value = 0;\n+    UniValue outputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.outputs.size(); ++i) {\n+        const PSBTOutput& output = psbtx.outputs[i];\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+\n+        // Fee calculation\n+        output_value += psbtx.tx->vout[i].nValue;\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+    if (have_all_utxos) {\n+        result.pushKV(\"fee\", ValueFromAmount(total_in - output_value));\n+    }\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"psbt\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner role.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        if (*it != merged_psbt) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+        merged_psbt.Merge(*it);\n+    }\n+    if (!merged_psbt.IsSane()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is inconsistent\");\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"psbt\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\\n\"\n+            \"Implements the Finalizer and Extractor roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 564,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "14339b0214f2976cae772ae836322d285138c353",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "`The base64-encoded partially signed transaction if network encoded transaction not extracted`",
    "created_at": "2018-07-09T19:35:35Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201121901",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201121901"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201121901"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201121901/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1612,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201122082",
    "pull_request_review_id": 135561934,
    "id": 201122082,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTEyMjA4Mg==",
    "diff_hunk": "@@ -1259,6 +1260,546 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : {             (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"bip32_derivs\\\" : {          (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : {                     (json object, optional) The public key with the derivation path as the value.\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"final_scriptsig\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"        }\\n\"\n+            \"       \\\"final_scriptwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"fee\\\" : fee                      (numeric, optional) The transaction fee paid if all UTXOs are present\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    CAmount total_in = 0;\n+    bool have_all_utxos = true;\n+    UniValue inputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {\n+        const PSBTInput& input = psbtx.inputs[i];\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"amount\", ValueFromAmount(txout.nValue));\n+            total_in += txout.nValue;\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+            total_in += input.non_witness_utxo->vout[psbtx.tx->vin[i].prevout.n].nValue;\n+        } else {\n+            have_all_utxos = false;\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                partial_sigs.pushKV(HexStr(sig.second.first), HexStr(sig.second.second));\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            UniValue scriptsig(UniValue::VOBJ);\n+            scriptsig.pushKV(\"asm\", ScriptToAsmStr(input.final_script_sig, true));\n+            scriptsig.pushKV(\"hex\", HexStr(input.final_script_sig));\n+            in.pushKV(\"final_scriptSig\", scriptsig);\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            UniValue txinwitness(UniValue::VARR);\n+            for (const auto& item : input.final_script_witness.stack) {\n+                txinwitness.push_back(HexStr(item.begin(), item.end()));\n+            }\n+            in.pushKV(\"final_scriptwitness\", txinwitness);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    CAmount output_value = 0;\n+    UniValue outputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.outputs.size(); ++i) {\n+        const PSBTOutput& output = psbtx.outputs[i];\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+\n+        // Fee calculation\n+        output_value += psbtx.tx->vout[i].nValue;\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+    if (have_all_utxos) {\n+        result.pushKV(\"fee\", ValueFromAmount(total_in - output_value));\n+    }\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"psbt\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner role.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        if (*it != merged_psbt) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+        merged_psbt.Merge(*it);\n+    }\n+    if (!merged_psbt.IsSane()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is inconsistent\");\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"psbt\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\\n\"\n+            \"Implements the Finalizer and Extractor roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded network transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        SignatureData sigdata;\n+        complete &= SignPSBTInput(DUMMY_SIGNING_PROVIDER, *psbtx.tx, input, sigdata, i, 1);\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\n+    if (complete && extract) {",
    "path": "src/rpc/rawtransaction.cpp",
    "position": 600,
    "original_position": 408,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "29df1b87e4f5e47bfd1482cdd5de2f6e268034ea",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "something like \"extract and return the complete transaction in normal network serialization instead of the PSBT.\" in addition to my other suggestion in the return values section.\r\n\r\n",
    "created_at": "2018-07-09T19:36:15Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201122082",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201122082"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201122082"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201122082/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1648,
    "original_line": 1648,
    "side": "RIGHT",
    "in_reply_to_id": 200997244
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201122102",
    "pull_request_review_id": 135562165,
    "id": 201122102,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTEyMjEwMg==",
    "diff_hunk": "@@ -1259,6 +1260,546 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : {             (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"bip32_derivs\\\" : {          (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : {                     (json object, optional) The public key with the derivation path as the value.\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"final_scriptsig\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"        }\\n\"\n+            \"       \\\"final_scriptwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"fee\\\" : fee                      (numeric, optional) The transaction fee paid if all UTXOs are present\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    CAmount total_in = 0;\n+    bool have_all_utxos = true;\n+    UniValue inputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {\n+        const PSBTInput& input = psbtx.inputs[i];\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"amount\", ValueFromAmount(txout.nValue));\n+            total_in += txout.nValue;\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+            total_in += input.non_witness_utxo->vout[psbtx.tx->vin[i].prevout.n].nValue;\n+        } else {\n+            have_all_utxos = false;\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                partial_sigs.pushKV(HexStr(sig.second.first), HexStr(sig.second.second));\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            UniValue scriptsig(UniValue::VOBJ);\n+            scriptsig.pushKV(\"asm\", ScriptToAsmStr(input.final_script_sig, true));\n+            scriptsig.pushKV(\"hex\", HexStr(input.final_script_sig));\n+            in.pushKV(\"final_scriptSig\", scriptsig);\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            UniValue txinwitness(UniValue::VARR);\n+            for (const auto& item : input.final_script_witness.stack) {\n+                txinwitness.push_back(HexStr(item.begin(), item.end()));\n+            }\n+            in.pushKV(\"final_scriptwitness\", txinwitness);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    CAmount output_value = 0;\n+    UniValue outputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.outputs.size(); ++i) {\n+        const PSBTOutput& output = psbtx.outputs[i];\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+\n+        // Fee calculation\n+        output_value += psbtx.tx->vout[i].nValue;\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+    if (have_all_utxos) {\n+        result.pushKV(\"fee\", ValueFromAmount(total_in - output_value));\n+    }\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"psbt\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner role.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        if (*it != merged_psbt) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+        merged_psbt.Merge(*it);\n+    }\n+    if (!merged_psbt.IsSane()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is inconsistent\");\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"psbt\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\\n\"\n+            \"Implements the Finalizer and Extractor roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 372,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "29df1b87e4f5e47bfd1482cdd5de2f6e268034ea",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "It is there so that each role can be done separately instead of at the same time. It's useful for testing.",
    "created_at": "2018-07-09T19:36:20Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201122102",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201122102"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201122102"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201122102/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1612,
    "side": "RIGHT",
    "in_reply_to_id": 200993595
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201122894",
    "pull_request_review_id": 135563166,
    "id": 201122894,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTEyMjg5NA==",
    "diff_hunk": "@@ -28,4 +28,5 @@ bool EnsureWalletIsAvailable(CWallet *, bool avoidException);\n \n UniValue getaddressinfo(const JSONRPCRequest& request);\n UniValue signrawtransactionwithwallet(const JSONRPCRequest& request);\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type = 1, bool sign = true);",
    "path": "src/wallet/rpcwallet.h",
    "position": null,
    "original_position": 4,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "db3ce1c3b324e39bcad28ea170b3523c23e4b39f",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "was referring to pwallet, which you dispute as an improvement",
    "created_at": "2018-07-09T19:39:40Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201122894",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201122894"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201122894"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201122894/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 33,
    "side": "RIGHT",
    "in_reply_to_id": 201000800
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201122929",
    "pull_request_review_id": 135563216,
    "id": 201122929,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTEyMjkyOQ==",
    "diff_hunk": "@@ -1259,6 +1260,546 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : {             (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"bip32_derivs\\\" : {          (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : {                     (json object, optional) The public key with the derivation path as the value.\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"final_scriptsig\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"        }\\n\"\n+            \"       \\\"final_scriptwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"fee\\\" : fee                      (numeric, optional) The transaction fee paid if all UTXOs are present\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    CAmount total_in = 0;\n+    bool have_all_utxos = true;\n+    UniValue inputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {\n+        const PSBTInput& input = psbtx.inputs[i];\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"amount\", ValueFromAmount(txout.nValue));\n+            total_in += txout.nValue;\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+            total_in += input.non_witness_utxo->vout[psbtx.tx->vin[i].prevout.n].nValue;\n+        } else {\n+            have_all_utxos = false;\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                partial_sigs.pushKV(HexStr(sig.second.first), HexStr(sig.second.second));\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            UniValue scriptsig(UniValue::VOBJ);\n+            scriptsig.pushKV(\"asm\", ScriptToAsmStr(input.final_script_sig, true));\n+            scriptsig.pushKV(\"hex\", HexStr(input.final_script_sig));\n+            in.pushKV(\"final_scriptSig\", scriptsig);\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            UniValue txinwitness(UniValue::VARR);\n+            for (const auto& item : input.final_script_witness.stack) {\n+                txinwitness.push_back(HexStr(item.begin(), item.end()));\n+            }\n+            in.pushKV(\"final_scriptwitness\", txinwitness);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    CAmount output_value = 0;\n+    UniValue outputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.outputs.size(); ++i) {\n+        const PSBTOutput& output = psbtx.outputs[i];\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+\n+        // Fee calculation\n+        output_value += psbtx.tx->vout[i].nValue;\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+    if (have_all_utxos) {\n+        result.pushKV(\"fee\", ValueFromAmount(total_in - output_value));\n+    }\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"psbt\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner role.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        if (*it != merged_psbt) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+        merged_psbt.Merge(*it);\n+    }\n+    if (!merged_psbt.IsSane()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is inconsistent\");\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"psbt\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\\n\"\n+            \"Implements the Finalizer and Extractor roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded network transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        SignatureData sigdata;\n+        complete &= SignPSBTInput(DUMMY_SIGNING_PROVIDER, *psbtx.tx, input, sigdata, i, 1);\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\n+    if (complete && extract) {\n+        CMutableTransaction mtx(*psbtx.tx);\n+        for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+            mtx.vin[i].scriptSig = psbtx.inputs[i].final_script_sig;\n+            mtx.vin[i].scriptWitness = psbtx.inputs[i].final_script_witness;\n+        }\n+        ssTx << mtx;\n+        result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n+    } else {\n+        ssTx << psbtx;\n+        result.push_back(Pair(\"psbt\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size())));\n+    }\n+    result.push_back(Pair(\"complete\", complete));\n+\n+    return result;\n+}\n+\n+UniValue createpsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n+        throw std::runtime_error(\n+                            \"createpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable )\\n\"\n+                            \"\\nCreates a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"\n+                            \"Implements the Creator role.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"inputs\\\"                (array, required) A json array of json objects\\n\"\n+                            \"     [\\n\"\n+                            \"       {\\n\"\n+                            \"         \\\"txid\\\":\\\"id\\\",      (string, required) The transaction id\\n\"\n+                            \"         \\\"vout\\\":n,         (numeric, required) The output number\\n\"\n+                            \"         \\\"sequence\\\":n      (numeric, optional) The sequence number\\n\"\n+                            \"       } \\n\"\n+                            \"       ,...\\n\"\n+                            \"     ]\\n\"\n+                            \"2. \\\"outputs\\\"               (array, required) a json array with outputs (key-value pairs)\\n\"\n+                            \"   [\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"address\\\": x.xxx,    (obj, optional) A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\\n\"\n+                            \"    },\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"data\\\": \\\"hex\\\"        (obj, optional) A key-value pair. The key must be \\\"data\\\", the value is hex encoded data\\n\"\n+                            \"    }\\n\"\n+                            \"    ,...                     More key-value pairs of the above form. For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n+                            \"                             accepted as second parameter.\\n\"\n+                            \"   ]\\n\"\n+                            \"3. locktime                  (numeric, optional, default=0) Raw locktime. Non-0 value also locktime-activates inputs\\n\"\n+                            \"4. replaceable               (boolean, optional, default=false) Marks this transaction as BIP125 replaceable.\\n\"\n+                            \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"        (string)  The resulting raw transaction (base64-encoded string)\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"createpsbt\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")\n+                            );\n+\n+\n+    RPCTypeCheck(request.params, {\n+        UniValue::VARR,\n+        UniValueType(), // ARR or OBJ, checked later\n+        UniValue::VNUM,\n+        UniValue::VBOOL,\n+        }, true\n+    );\n+\n+    CMutableTransaction rawTx = ConstructTransaction(request.params[0], request.params[1], request.params[2], request.params[3]);\n+\n+    // Make a blank psbt\n+    PartiallySignedTransaction psbtx;\n+    psbtx.tx = rawTx;\n+    for (unsigned int i = 0; i < rawTx.vin.size(); ++i) {\n+        psbtx.inputs.push_back(PSBTInput());\n+    }\n+    for (unsigned int i = 0; i < rawTx.vout.size(); ++i) {\n+        psbtx.outputs.push_back(PSBTOutput());\n+    }\n+\n+    // Serialize the PSBT\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue converttopsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+                            \"converttopsbt \\\"hexstring\\\" ( permitsigdata iswitness )\\n\"\n+                            \"\\nConverts a network serialized transaction to a PSBT. This should be used only with createrawtransaction and fundrawtransaction\\n\"\n+                            \"createpsbt and walletcreatefundedpsbt should be used for new applications.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"hexstring\\\"              (string, required) The hex string of a raw transaction\\n\"\n+                            \"2. permitsigdata           (boolean, optional) If true, any signatures in the input will be discarded.\\n\"\n+                            \"                              If false, RPC will fail if any signatures are present.\\n\"\n+                            \"3. iswitness               (boolean, optional) Whether the transaction hex is a serialized witness transaction.\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 501,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "29df1b87e4f5e47bfd1482cdd5de2f6e268034ea",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "ok, then please say that in the help",
    "created_at": "2018-07-09T19:39:52Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201122929",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201122929"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201122929"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201122929/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1741,
    "side": "RIGHT",
    "in_reply_to_id": 200999246
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201123180",
    "pull_request_review_id": 135563557,
    "id": 201123180,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTEyMzE4MA==",
    "diff_hunk": "@@ -4390,6 +4390,324 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)",
    "path": "src/wallet/rpcwallet.cpp",
    "position": 277,
    "original_position": 43,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "db3ce1c3b324e39bcad28ea170b3523c23e4b39f",
    "user": {
      "login": "instagibbs",
      "id": 5767891,
      "node_id": "MDQ6VXNlcjU3Njc4OTE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/instagibbs",
      "html_url": "https://github.com/instagibbs",
      "followers_url": "https://api.github.com/users/instagibbs/followers",
      "following_url": "https://api.github.com/users/instagibbs/following{/other_user}",
      "gists_url": "https://api.github.com/users/instagibbs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
      "organizations_url": "https://api.github.com/users/instagibbs/orgs",
      "repos_url": "https://api.github.com/users/instagibbs/repos",
      "events_url": "https://api.github.com/users/instagibbs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/instagibbs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Just not crazy about passing around pointers more than we have to.",
    "created_at": "2018-07-09T19:40:51Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201123180",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201123180"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201123180"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201123180/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 4432,
    "original_line": 4432,
    "side": "RIGHT",
    "in_reply_to_id": 201002855
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201131963",
    "pull_request_review_id": 135574101,
    "id": 201131963,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTEzMTk2Mw==",
    "diff_hunk": "@@ -73,6 +77,542 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+// Magic bytes\n+static constexpr uint8_t PSBT_MAGIC_BYTES[4] = {'p', 's', 'b', 't'};\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 39,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "dfa5afe665d95c2dbb5447d48526528d2570ecb3",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Fixed",
    "created_at": "2018-07-09T20:12:36Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201131963",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201131963"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201131963"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201131963/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 103,
    "side": "RIGHT",
    "in_reply_to_id": 200487223
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201131981",
    "pull_request_review_id": 135574122,
    "id": 201131981,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTEzMTk4MQ==",
    "diff_hunk": "@@ -73,6 +77,542 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+// Magic bytes\n+static constexpr uint8_t PSBT_MAGIC_BYTES[4] = {'p', 's', 'b', 't'};\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static constexpr uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+template<typename Stream>\n+void DeserializeHDKeypaths(Stream& s, const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    // Make sure that the key is the size of pubkey + 1\n+    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+    }\n+    // Read in the pubkey from key\n+    CPubKey pubkey(key.begin() + 1, key.end());\n+    if (!pubkey.IsFullyValid()) {\n+       throw std::ios_base::failure(\"Invalid pubkey\");\n+    }\n+    if (hd_keypaths.count(pubkey) > 0) {\n+        throw std::ios_base::failure(\"Duplicate Key, pubkey derivation path already provided\");\n+    }\n+\n+    // Read in key path\n+    uint64_t value_len = ReadCompactSize(s);\n+    std::vector<uint32_t> keypath;\n+    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+        uint32_t index;\n+        s >> index;\n+        keypath.push_back(index);\n+    }\n+\n+    // Add to map\n+    hd_keypaths.emplace(pubkey, keypath);\n+}\n+\n+// Serialize HD keypaths to a stream from a map\n+template<typename Stream>\n+void SerializeHDKeypaths(Stream& s, const std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, uint8_t type)\n+{\n+    for (auto keypath_pair : hd_keypaths) {\n+        SerializeToVector(s, type, MakeSpan(keypath_pair.first));\n+        WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+        for (auto& path : keypath_pair.second) {\n+            s << path;\n+        }\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 109,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "dfa5afe665d95c2dbb5447d48526528d2570ecb3",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Fixed",
    "created_at": "2018-07-09T20:12:41Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201131981",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201131981"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201131981"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201131981/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 173,
    "side": "RIGHT",
    "in_reply_to_id": 200488912
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201132125",
    "pull_request_review_id": 135574282,
    "id": 201132125,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTEzMjEyNQ==",
    "diff_hunk": "@@ -1259,6 +1260,546 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)",
    "path": "src/rpc/rawtransaction.cpp",
    "position": 199,
    "original_position": 12,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "29df1b87e4f5e47bfd1482cdd5de2f6e268034ea",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Maybe? It doesn't seem useful outside of this context specifically since keypaths are stored as strings in the wallet currently.",
    "created_at": "2018-07-09T20:13:16Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201132125",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201132125"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201132125"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201132125/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1247,
    "original_line": 1247,
    "side": "RIGHT",
    "in_reply_to_id": 200988122
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201132172",
    "pull_request_review_id": 135574319,
    "id": 201132172,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTEzMjE3Mg==",
    "diff_hunk": "@@ -1259,6 +1260,546 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : {             (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"bip32_derivs\\\" : {          (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : {                     (json object, optional) The public key with the derivation path as the value.\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"final_scriptsig\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"        }\\n\"\n+            \"       \\\"final_scriptwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"fee\\\" : fee                      (numeric, optional) The transaction fee paid if all UTXOs are present\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 126,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "29df1b87e4f5e47bfd1482cdd5de2f6e268034ea",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-07-09T20:13:22Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201132172",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201132172"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201132172"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201132172/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1377,
    "side": "RIGHT",
    "in_reply_to_id": 200989422
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201132203",
    "pull_request_review_id": 135574361,
    "id": 201132203,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTEzMjIwMw==",
    "diff_hunk": "@@ -1259,6 +1260,546 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : {             (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"bip32_derivs\\\" : {          (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : {                     (json object, optional) The public key with the derivation path as the value.\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"final_scriptsig\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"        }\\n\"\n+            \"       \\\"final_scriptwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"fee\\\" : fee                      (numeric, optional) The transaction fee paid if all UTXOs are present\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    CAmount total_in = 0;\n+    bool have_all_utxos = true;\n+    UniValue inputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {\n+        const PSBTInput& input = psbtx.inputs[i];\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"amount\", ValueFromAmount(txout.nValue));\n+            total_in += txout.nValue;\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+            total_in += input.non_witness_utxo->vout[psbtx.tx->vin[i].prevout.n].nValue;\n+        } else {\n+            have_all_utxos = false;\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                partial_sigs.pushKV(HexStr(sig.second.first), HexStr(sig.second.second));\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            UniValue scriptsig(UniValue::VOBJ);\n+            scriptsig.pushKV(\"asm\", ScriptToAsmStr(input.final_script_sig, true));\n+            scriptsig.pushKV(\"hex\", HexStr(input.final_script_sig));\n+            in.pushKV(\"final_scriptSig\", scriptsig);\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            UniValue txinwitness(UniValue::VARR);\n+            for (const auto& item : input.final_script_witness.stack) {\n+                txinwitness.push_back(HexStr(item.begin(), item.end()));\n+            }\n+            in.pushKV(\"final_scriptwitness\", txinwitness);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    CAmount output_value = 0;\n+    UniValue outputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.outputs.size(); ++i) {\n+        const PSBTOutput& output = psbtx.outputs[i];\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+\n+        // Fee calculation\n+        output_value += psbtx.tx->vout[i].nValue;\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+    if (have_all_utxos) {\n+        result.pushKV(\"fee\", ValueFromAmount(total_in - output_value));\n+    }\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"psbt\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner role.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        if (*it != merged_psbt) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+        merged_psbt.Merge(*it);\n+    }\n+    if (!merged_psbt.IsSane()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is inconsistent\");\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"psbt\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\\n\"\n+            \"Implements the Finalizer and Extractor roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded network transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        SignatureData sigdata;\n+        complete &= SignPSBTInput(DUMMY_SIGNING_PROVIDER, *psbtx.tx, input, sigdata, i, 1);\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\n+    if (complete && extract) {",
    "path": "src/rpc/rawtransaction.cpp",
    "position": 600,
    "original_position": 408,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "29df1b87e4f5e47bfd1482cdd5de2f6e268034ea",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-07-09T20:13:29Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201132203",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201132203"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201132203"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201132203/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1648,
    "original_line": 1648,
    "side": "RIGHT",
    "in_reply_to_id": 200997244
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201132236",
    "pull_request_review_id": 135574410,
    "id": 201132236,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTEzMjIzNg==",
    "diff_hunk": "@@ -1259,6 +1260,546 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : {             (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"bip32_derivs\\\" : {          (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : {                     (json object, optional) The public key with the derivation path as the value.\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"final_scriptsig\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"        }\\n\"\n+            \"       \\\"final_scriptwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"fee\\\" : fee                      (numeric, optional) The transaction fee paid if all UTXOs are present\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    CAmount total_in = 0;\n+    bool have_all_utxos = true;\n+    UniValue inputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {\n+        const PSBTInput& input = psbtx.inputs[i];\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"amount\", ValueFromAmount(txout.nValue));\n+            total_in += txout.nValue;\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+            total_in += input.non_witness_utxo->vout[psbtx.tx->vin[i].prevout.n].nValue;\n+        } else {\n+            have_all_utxos = false;\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                partial_sigs.pushKV(HexStr(sig.second.first), HexStr(sig.second.second));\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            UniValue scriptsig(UniValue::VOBJ);\n+            scriptsig.pushKV(\"asm\", ScriptToAsmStr(input.final_script_sig, true));\n+            scriptsig.pushKV(\"hex\", HexStr(input.final_script_sig));\n+            in.pushKV(\"final_scriptSig\", scriptsig);\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            UniValue txinwitness(UniValue::VARR);\n+            for (const auto& item : input.final_script_witness.stack) {\n+                txinwitness.push_back(HexStr(item.begin(), item.end()));\n+            }\n+            in.pushKV(\"final_scriptwitness\", txinwitness);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    CAmount output_value = 0;\n+    UniValue outputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.outputs.size(); ++i) {\n+        const PSBTOutput& output = psbtx.outputs[i];\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+\n+        // Fee calculation\n+        output_value += psbtx.tx->vout[i].nValue;\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+    if (have_all_utxos) {\n+        result.pushKV(\"fee\", ValueFromAmount(total_in - output_value));\n+    }\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"psbt\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner role.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        if (*it != merged_psbt) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+        merged_psbt.Merge(*it);\n+    }\n+    if (!merged_psbt.IsSane()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is inconsistent\");\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"psbt\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\\n\"\n+            \"Implements the Finalizer and Extractor roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded network transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        SignatureData sigdata;\n+        complete &= SignPSBTInput(DUMMY_SIGNING_PROVIDER, *psbtx.tx, input, sigdata, i, 1);\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\n+    if (complete && extract) {\n+        CMutableTransaction mtx(*psbtx.tx);\n+        for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+            mtx.vin[i].scriptSig = psbtx.inputs[i].final_script_sig;\n+            mtx.vin[i].scriptWitness = psbtx.inputs[i].final_script_witness;\n+        }\n+        ssTx << mtx;\n+        result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n+    } else {\n+        ssTx << psbtx;\n+        result.push_back(Pair(\"psbt\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size())));\n+    }\n+    result.push_back(Pair(\"complete\", complete));\n+\n+    return result;\n+}\n+\n+UniValue createpsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n+        throw std::runtime_error(\n+                            \"createpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable )\\n\"\n+                            \"\\nCreates a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"\n+                            \"Implements the Creator role.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"inputs\\\"                (array, required) A json array of json objects\\n\"\n+                            \"     [\\n\"\n+                            \"       {\\n\"\n+                            \"         \\\"txid\\\":\\\"id\\\",      (string, required) The transaction id\\n\"\n+                            \"         \\\"vout\\\":n,         (numeric, required) The output number\\n\"\n+                            \"         \\\"sequence\\\":n      (numeric, optional) The sequence number\\n\"\n+                            \"       } \\n\"\n+                            \"       ,...\\n\"\n+                            \"     ]\\n\"\n+                            \"2. \\\"outputs\\\"               (array, required) a json array with outputs (key-value pairs)\\n\"\n+                            \"   [\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"address\\\": x.xxx,    (obj, optional) A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\\n\"\n+                            \"    },\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"data\\\": \\\"hex\\\"        (obj, optional) A key-value pair. The key must be \\\"data\\\", the value is hex encoded data\\n\"\n+                            \"    }\\n\"\n+                            \"    ,...                     More key-value pairs of the above form. For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n+                            \"                             accepted as second parameter.\\n\"\n+                            \"   ]\\n\"\n+                            \"3. locktime                  (numeric, optional, default=0) Raw locktime. Non-0 value also locktime-activates inputs\\n\"\n+                            \"4. replaceable               (boolean, optional, default=false) Marks this transaction as BIP125 replaceable.\\n\"\n+                            \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"        (string)  The resulting raw transaction (base64-encoded string)\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"createpsbt\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")\n+                            );\n+\n+\n+    RPCTypeCheck(request.params, {\n+        UniValue::VARR,\n+        UniValueType(), // ARR or OBJ, checked later\n+        UniValue::VNUM,\n+        UniValue::VBOOL,\n+        }, true\n+    );\n+\n+    CMutableTransaction rawTx = ConstructTransaction(request.params[0], request.params[1], request.params[2], request.params[3]);\n+\n+    // Make a blank psbt\n+    PartiallySignedTransaction psbtx;\n+    psbtx.tx = rawTx;\n+    for (unsigned int i = 0; i < rawTx.vin.size(); ++i) {\n+        psbtx.inputs.push_back(PSBTInput());\n+    }\n+    for (unsigned int i = 0; i < rawTx.vout.size(); ++i) {\n+        psbtx.outputs.push_back(PSBTOutput());\n+    }\n+\n+    // Serialize the PSBT\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue converttopsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+                            \"converttopsbt \\\"hexstring\\\" ( permitsigdata iswitness )\\n\"\n+                            \"\\nConverts a network serialized transaction to a PSBT. This should be used only with createrawtransaction and fundrawtransaction\\n\"\n+                            \"createpsbt and walletcreatefundedpsbt should be used for new applications.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"hexstring\\\"              (string, required) The hex string of a raw transaction\\n\"\n+                            \"2. permitsigdata           (boolean, optional) If true, any signatures in the input will be discarded.\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 499,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "29df1b87e4f5e47bfd1482cdd5de2f6e268034ea",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Added default value",
    "created_at": "2018-07-09T20:13:38Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201132236",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201132236"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201132236"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201132236/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1750,
    "side": "RIGHT",
    "in_reply_to_id": 200998753
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201132261",
    "pull_request_review_id": 135574439,
    "id": 201132261,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTEzMjI2MQ==",
    "diff_hunk": "@@ -1259,6 +1260,546 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : {             (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"bip32_derivs\\\" : {          (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : {                     (json object, optional) The public key with the derivation path as the value.\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"final_scriptsig\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"        }\\n\"\n+            \"       \\\"final_scriptwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"fee\\\" : fee                      (numeric, optional) The transaction fee paid if all UTXOs are present\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    CAmount total_in = 0;\n+    bool have_all_utxos = true;\n+    UniValue inputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {\n+        const PSBTInput& input = psbtx.inputs[i];\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"amount\", ValueFromAmount(txout.nValue));\n+            total_in += txout.nValue;\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+            total_in += input.non_witness_utxo->vout[psbtx.tx->vin[i].prevout.n].nValue;\n+        } else {\n+            have_all_utxos = false;\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                partial_sigs.pushKV(HexStr(sig.second.first), HexStr(sig.second.second));\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            UniValue scriptsig(UniValue::VOBJ);\n+            scriptsig.pushKV(\"asm\", ScriptToAsmStr(input.final_script_sig, true));\n+            scriptsig.pushKV(\"hex\", HexStr(input.final_script_sig));\n+            in.pushKV(\"final_scriptSig\", scriptsig);\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            UniValue txinwitness(UniValue::VARR);\n+            for (const auto& item : input.final_script_witness.stack) {\n+                txinwitness.push_back(HexStr(item.begin(), item.end()));\n+            }\n+            in.pushKV(\"final_scriptwitness\", txinwitness);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    CAmount output_value = 0;\n+    UniValue outputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.outputs.size(); ++i) {\n+        const PSBTOutput& output = psbtx.outputs[i];\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+\n+        // Fee calculation\n+        output_value += psbtx.tx->vout[i].nValue;\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+    if (have_all_utxos) {\n+        result.pushKV(\"fee\", ValueFromAmount(total_in - output_value));\n+    }\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"psbt\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner role.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        if (*it != merged_psbt) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+        merged_psbt.Merge(*it);\n+    }\n+    if (!merged_psbt.IsSane()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is inconsistent\");\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"psbt\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\\n\"\n+            \"Implements the Finalizer and Extractor roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded network transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        SignatureData sigdata;\n+        complete &= SignPSBTInput(DUMMY_SIGNING_PROVIDER, *psbtx.tx, input, sigdata, i, 1);\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\n+    if (complete && extract) {\n+        CMutableTransaction mtx(*psbtx.tx);\n+        for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+            mtx.vin[i].scriptSig = psbtx.inputs[i].final_script_sig;\n+            mtx.vin[i].scriptWitness = psbtx.inputs[i].final_script_witness;\n+        }\n+        ssTx << mtx;\n+        result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n+    } else {\n+        ssTx << psbtx;\n+        result.push_back(Pair(\"psbt\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size())));\n+    }\n+    result.push_back(Pair(\"complete\", complete));\n+\n+    return result;\n+}\n+\n+UniValue createpsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n+        throw std::runtime_error(\n+                            \"createpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable )\\n\"\n+                            \"\\nCreates a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"\n+                            \"Implements the Creator role.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"inputs\\\"                (array, required) A json array of json objects\\n\"\n+                            \"     [\\n\"\n+                            \"       {\\n\"\n+                            \"         \\\"txid\\\":\\\"id\\\",      (string, required) The transaction id\\n\"\n+                            \"         \\\"vout\\\":n,         (numeric, required) The output number\\n\"\n+                            \"         \\\"sequence\\\":n      (numeric, optional) The sequence number\\n\"\n+                            \"       } \\n\"\n+                            \"       ,...\\n\"\n+                            \"     ]\\n\"\n+                            \"2. \\\"outputs\\\"               (array, required) a json array with outputs (key-value pairs)\\n\"\n+                            \"   [\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"address\\\": x.xxx,    (obj, optional) A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\\n\"\n+                            \"    },\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"data\\\": \\\"hex\\\"        (obj, optional) A key-value pair. The key must be \\\"data\\\", the value is hex encoded data\\n\"\n+                            \"    }\\n\"\n+                            \"    ,...                     More key-value pairs of the above form. For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n+                            \"                             accepted as second parameter.\\n\"\n+                            \"   ]\\n\"\n+                            \"3. locktime                  (numeric, optional, default=0) Raw locktime. Non-0 value also locktime-activates inputs\\n\"\n+                            \"4. replaceable               (boolean, optional, default=false) Marks this transaction as BIP125 replaceable.\\n\"\n+                            \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"        (string)  The resulting raw transaction (base64-encoded string)\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"createpsbt\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")\n+                            );\n+\n+\n+    RPCTypeCheck(request.params, {\n+        UniValue::VARR,\n+        UniValueType(), // ARR or OBJ, checked later\n+        UniValue::VNUM,\n+        UniValue::VBOOL,\n+        }, true\n+    );\n+\n+    CMutableTransaction rawTx = ConstructTransaction(request.params[0], request.params[1], request.params[2], request.params[3]);\n+\n+    // Make a blank psbt\n+    PartiallySignedTransaction psbtx;\n+    psbtx.tx = rawTx;\n+    for (unsigned int i = 0; i < rawTx.vin.size(); ++i) {\n+        psbtx.inputs.push_back(PSBTInput());\n+    }\n+    for (unsigned int i = 0; i < rawTx.vout.size(); ++i) {\n+        psbtx.outputs.push_back(PSBTOutput());\n+    }\n+\n+    // Serialize the PSBT\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue converttopsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+                            \"converttopsbt \\\"hexstring\\\" ( permitsigdata iswitness )\\n\"\n+                            \"\\nConverts a network serialized transaction to a PSBT. This should be used only with createrawtransaction and fundrawtransaction\\n\"\n+                            \"createpsbt and walletcreatefundedpsbt should be used for new applications.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"hexstring\\\"              (string, required) The hex string of a raw transaction\\n\"\n+                            \"2. permitsigdata           (boolean, optional) If true, any signatures in the input will be discarded.\\n\"\n+                            \"                              If false, RPC will fail if any signatures are present.\\n\"\n+                            \"3. iswitness               (boolean, optional) Whether the transaction hex is a serialized witness transaction.\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 501,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "29df1b87e4f5e47bfd1482cdd5de2f6e268034ea",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-07-09T20:13:43Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201132261",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201132261"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201132261"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201132261/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1741,
    "side": "RIGHT",
    "in_reply_to_id": 200999246
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201132280",
    "pull_request_review_id": 135574464,
    "id": 201132280,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTEzMjI4MA==",
    "diff_hunk": "@@ -4390,6 +4390,324 @@ UniValue sethdseed(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath)\n+{\n+    std::stringstream ss(keypath_str);\n+    std::string item;\n+    bool first = true;\n+    while (std::getline(ss, item, '/')) {\n+        if (item.compare(\"m\") == 0) {\n+            if (first) {\n+                first = false;\n+                continue;\n+            }\n+            return false;\n+        }\n+        // Finds whether it is hardened\n+        uint32_t path = 0;\n+        size_t pos = item.find(\"'\");\n+        if (pos != std::string::npos) {\n+            // The hardened tick can only be in the last index of the string\n+            if (pos != item.size() - 1) {\n+                return false;\n+            }\n+            path |= 0x80000000;\n+            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick\n+        }\n+\n+        // Ensure this is only numbers\n+        if (item.find_first_not_of( \"0123456789\" ) != std::string::npos) {\n+            return false;\n+        }\n+        uint32_t number;\n+        ParseUInt32(item, &number);\n+        path |= number;\n+\n+        keypath.push_back(path);\n+        first = false;\n+    }\n+    return true;\n+}\n+\n+void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    CPubKey vchPubKey;\n+    if (!pwallet->GetPubKey(keyID, vchPubKey)) {\n+        return;\n+    }\n+    CKeyMetadata meta;\n+    auto it = pwallet->mapKeyMetadata.find(keyID);\n+    if (it != pwallet->mapKeyMetadata.end()) {\n+        meta = it->second;\n+    }\n+    std::vector<uint32_t> keypath;\n+    if (!meta.hdKeypath.empty()) {\n+        if (!ParseHDKeypath(meta.hdKeypath, keypath)) {\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+        }\n+        // Get the proper master key id\n+        CKey key;\n+        pwallet->GetKey(meta.hd_seed_id, key);\n+        CExtKey masterKey;\n+        masterKey.SetSeed(key.begin(), key.size());\n+        // Add to map\n+        keypath.insert(keypath.begin(), ReadLE32(masterKey.key.GetPubKey().GetID().begin()));\n+    } else { // Single pubkeys get the master fingerprint of themselves\n+        keypath.insert(keypath.begin(), ReadLE32(vchPubKey.GetID().begin()));\n+    }\n+    hd_keypaths.emplace(vchPubKey, keypath);\n+}\n+\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, const CTransaction* txConst, int sighash_type, bool sign)\n+{\n+    LOCK(pwallet->cs_wallet);\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < txConst->vin.size(); ++i) {\n+        const CTxIn& txin = txConst->vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // If we don't know about this input, skip it and let someone else deal with it\n+        const uint256& txhash = txin.prevout.hash;\n+        const auto& it = pwallet->mapWallet.find(txhash);\n+        if (it != pwallet->mapWallet.end()) {\n+            const CWalletTx& wtx = it->second;\n+            CTxOut utxo = wtx.tx->vout[txin.prevout.n];\n+            input.non_witness_utxo = wtx.tx;\n+            input.witness_utxo = utxo;\n+        }\n+\n+        // Get the Sighash type\n+        if (sign && input.sighash_type > 0 && input.sighash_type != sighash_type) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Specified Sighash and sighash in PSBT do not match.\");\n+        }\n+\n+        SignatureData sigdata;\n+        if (sign) {\n+            complete &= SignPSBTInput(*pwallet, *psbtx.tx, input, sigdata, i, sighash_type);\n+        } else {\n+            complete &= SignPSBTInput(PublicOnlySigningProvider(pwallet), *psbtx.tx, input, sigdata, i, sighash_type);\n+        }\n+\n+        // Drop the unnecessary UTXO\n+        if (sigdata.witness) {\n+            input.non_witness_utxo = nullptr;\n+        } else {\n+            input.witness_utxo.SetNull();\n+        }\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, input.hd_keypaths);\n+        }\n+    }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    for (unsigned int i = 0; i < txConst->vout.size(); ++i) {\n+        const CTxOut& out = txConst->vout.at(i);\n+        PSBTOutput& psbt_out = psbtx.outputs.at(i);\n+\n+        // Dummy tx so we can use ProduceSignature to get stuff out\n+        CMutableTransaction dummy_tx;\n+        dummy_tx.vin.push_back(CTxIn());\n+        dummy_tx.vout.push_back(CTxOut());\n+\n+        // Fill a SignatureData with output info\n+        SignatureData sigdata;\n+        psbt_out.FillSignatureData(sigdata);\n+\n+        MutableTransactionSignatureCreator creator(psbtx.tx.get_ptr(), 0, out.nValue, 1);\n+        ProduceSignature(*pwallet, creator, out.scriptPubKey, sigdata);\n+        psbt_out.FromSignatureData(sigdata);\n+\n+        // Get public key paths\n+        for (const auto& pubkey_it : sigdata.misc_pubkeys) {\n+            AddKeypathToMap(pwallet, pubkey_it.first, psbt_out.hd_keypaths);\n+        }\n+    }\n+    return complete;\n+}\n+\n+UniValue walletprocesspsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+            \"walletprocesspsbt \\\"psbt\\\" ( sign \\\"sighashtype\\\" )\\n\"\n+            \"\\nUpdate a PSBT with input information from our wallet and then sign inputs\\n\"\n+            \"that we can sign for.\\n\"\n+            + HelpRequiringPassphrase(pwallet) + \"\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                      (string, required) The transaction base64 string\\n\"\n+            \"2. sign,                         (boolean, optional, default=true) Also sign the transaction when updating\\n\"",
    "path": "src/wallet/rpcwallet.cpp",
    "position": null,
    "original_position": 160,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "db3ce1c3b324e39bcad28ea170b3523c23e4b39f",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Fixed",
    "created_at": "2018-07-09T20:13:48Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201132280",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201132280"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201132280"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201132280/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 4549,
    "side": "RIGHT",
    "in_reply_to_id": 201002334
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201132334",
    "pull_request_review_id": 135574538,
    "id": 201132334,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTEzMjMzNA==",
    "diff_hunk": "@@ -1253,6 +1244,546 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : {             (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"bip32_derivs\\\" : {          (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : {                     (json object, optional) The public key with the derivation path as the value.\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"final_scriptsig\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"        }\\n\"\n+            \"       \\\"final_scriptwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"fee\\\" : fee                      (numeric, optional) The transaction fee paid if all UTXOs are present\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    CAmount total_in = 0;\n+    bool have_all_utxos = true;\n+    UniValue inputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {\n+        const PSBTInput& input = psbtx.inputs[i];\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"amount\", ValueFromAmount(txout.nValue));\n+            total_in += txout.nValue;\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+            total_in += input.non_witness_utxo->vout[psbtx.tx->vin[i].prevout.n].nValue;\n+        } else {\n+            have_all_utxos = false;\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);\n+            for (const auto& sig : input.partial_sigs) {\n+                partial_sigs.pushKV(HexStr(sig.second.first), HexStr(sig.second.second));\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            UniValue scriptsig(UniValue::VOBJ);\n+            scriptsig.pushKV(\"asm\", ScriptToAsmStr(input.final_script_sig, true));\n+            scriptsig.pushKV(\"hex\", HexStr(input.final_script_sig));\n+            in.pushKV(\"final_scriptSig\", scriptsig);\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            UniValue txinwitness(UniValue::VARR);\n+            for (const auto& item : input.final_script_witness.stack) {\n+                txinwitness.push_back(HexStr(item.begin(), item.end()));\n+            }\n+            in.pushKV(\"final_scriptwitness\", txinwitness);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : input.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        in.pushKV(\"unknown\", unknowns);\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    CAmount output_value = 0;\n+    UniValue outputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.outputs.size(); ++i) {\n+        const PSBTOutput& output = psbtx.outputs[i];\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        UniValue unknowns(UniValue::VOBJ);\n+        for (auto entry : output.unknown) {\n+            unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+        }\n+        out.pushKV(\"unknown\", unknowns);\n+\n+        outputs.push_back(out);\n+\n+        // Fee calculation\n+        output_value += psbtx.tx->vout[i].nValue;\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+    if (have_all_utxos) {\n+        result.pushKV(\"fee\", ValueFromAmount(total_in - output_value));\n+    }\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"psbt\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner role.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        if (*it != merged_psbt) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+        merged_psbt.Merge(*it);\n+    }\n+    if (!merged_psbt.IsSane()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is inconsistent\");\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"psbt\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\\n\"\n+            \"Implements the Finalizer and Extractor roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 564,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "14339b0214f2976cae772ae836322d285138c353",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done (kind of)",
    "created_at": "2018-07-09T20:14:02Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201132334",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201132334"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201132334"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201132334/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1612,
    "side": "RIGHT",
    "in_reply_to_id": 201121901
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201135298",
    "pull_request_review_id": 135578268,
    "id": 201135298,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTEzNTI5OA==",
    "diff_hunk": "@@ -1262,6 +1263,552 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str.substr(0, keypath_str.size() - 1); // Drop last '/'\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"       \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"          {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"       ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {           (json object)\\n\"\n+            \"            \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"            \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"            \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"            \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"            \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"              \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"               ,...\\n\"\n+            \"            ],\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"script\\\" : {            (json object)\\n\"\n+            \"            \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"            \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"        }\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VARR);",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 197,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "e7707b610ae7c5e22fa947d246d4e893634ea36a",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Fixed",
    "created_at": "2018-07-09T20:25:09Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201135298",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201135298"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201135298"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201135298/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1422,
    "side": "RIGHT",
    "in_reply_to_id": 199983146
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201408039",
    "pull_request_review_id": 135905054,
    "id": 201408039,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTQwODAzOQ==",
    "diff_hunk": "@@ -0,0 +1,171 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2014-2016 The Bitcoin Core developers",
    "path": "test/functional/rpc_psbt.py",
    "position": null,
    "original_position": 2,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "52a5f17a685e78ab28aab1d989003fe6c09760a2",
    "user": {
      "login": "Sjors",
      "id": 10217,
      "node_id": "MDQ6VXNlcjEwMjE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Sjors",
      "html_url": "https://github.com/Sjors",
      "followers_url": "https://api.github.com/users/Sjors/followers",
      "following_url": "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url": "https://api.github.com/users/Sjors/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
      "organizations_url": "https://api.github.com/users/Sjors/orgs",
      "repos_url": "https://api.github.com/users/Sjors/repos",
      "events_url": "https://api.github.com/users/Sjors/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Sjors/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Nit: 2018",
    "created_at": "2018-07-10T16:22:54Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201408039",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201408039"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201408039"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201408039/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 2,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201411672",
    "pull_request_review_id": 135905054,
    "id": 201411672,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTQxMTY3Mg==",
    "diff_hunk": "@@ -0,0 +1,171 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2014-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the Partially Signed Transaction RPCs.\n+\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+# Create one-input, one-output, no-fee transaction:\n+class PSBTTest(BitcoinTestFramework):\n+\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 3\n+\n+    def run_test(self):\n+\n+        # Get some money and activate segwit\n+        self.nodes[0].generate(500)",
    "path": "test/functional/rpc_psbt.py",
    "position": null,
    "original_position": 21,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "52a5f17a685e78ab28aab1d989003fe6c09760a2",
    "user": {
      "login": "Sjors",
      "id": 10217,
      "node_id": "MDQ6VXNlcjEwMjE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Sjors",
      "html_url": "https://github.com/Sjors",
      "followers_url": "https://api.github.com/users/Sjors/followers",
      "following_url": "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url": "https://api.github.com/users/Sjors/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
      "organizations_url": "https://api.github.com/users/Sjors/orgs",
      "repos_url": "https://api.github.com/users/Sjors/repos",
      "events_url": "https://api.github.com/users/Sjors/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Sjors/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "SegWit is activated immediately in Regtest by default these days (`nStartTime ... ALWAYS_ACTIVE` ). If you change `setup_clean_chain = True` to `False`, you can leave out this `generate()` line completely.",
    "created_at": "2018-07-10T16:34:12Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201411672",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201411672"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201411672"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201411672/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 21,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201417187",
    "pull_request_review_id": 135905054,
    "id": 201417187,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTQxNzE4Nw==",
    "diff_hunk": "@@ -0,0 +1,171 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2014-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the Partially Signed Transaction RPCs.\n+\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+# Create one-input, one-output, no-fee transaction:\n+class PSBTTest(BitcoinTestFramework):\n+\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 3\n+\n+    def run_test(self):\n+\n+        # Get some money and activate segwit\n+        self.nodes[0].generate(500)\n+\n+        # Create and fund a raw tx for sending 10 BTC\n+        psbtx1 = self.nodes[0].walletcreatefundedpsbt([], {self.nodes[2].getnewaddress():10})['psbt']\n+\n+        # Node 1 should not be able to add anything to it but still return the psbtx same as before\n+        psbtx = self.nodes[1].walletprocesspsbt(psbtx1)['psbt']\n+        assert_equal(psbtx1, psbtx)\n+\n+        # Sign the transaction and send\n+        signed_tx = self.nodes[0].walletprocesspsbt(psbtx)['psbt']\n+        final_tx = self.nodes[0].finalizepsbt(signed_tx)['hex']\n+        self.nodes[0].sendrawtransaction(final_tx)\n+\n+        # Create p2sh, p2wpkh, and p2wsh addresses\n+        pubkey0 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())['pubkey']\n+        pubkey1 = self.nodes[1].getaddressinfo(self.nodes[1].getnewaddress())['pubkey']\n+        pubkey2 = self.nodes[2].getaddressinfo(self.nodes[2].getnewaddress())['pubkey']\n+        p2sh = self.nodes[1].addmultisigaddress(2, [pubkey0, pubkey1, pubkey2], \"\", \"legacy\")['address']\n+        p2wsh = self.nodes[1].addmultisigaddress(2, [pubkey0, pubkey1, pubkey2], \"\", \"bech32\")['address']\n+        p2sh_p2wsh = self.nodes[1].addmultisigaddress(2, [pubkey0, pubkey1, pubkey2], \"\", \"p2sh-segwit\")['address']\n+        p2wpkh = self.nodes[1].getnewaddress(\"\", \"bech32\")\n+        p2pkh = self.nodes[1].getnewaddress(\"\", \"legacy\")\n+        p2sh_p2wpkh = self.nodes[1].getnewaddress(\"\", \"p2sh-segwit\")\n+\n+        # fund those addresses\n+        rawtx = self.nodes[0].createrawtransaction([], {p2sh:10, p2wsh:10, p2wpkh:10, p2sh_p2wsh:10, p2sh_p2wpkh:10, p2pkh:10})\n+        rawtx = self.nodes[0].fundrawtransaction(rawtx, {\"changePosition\":3})\n+        signed_tx = self.nodes[0].signrawtransactionwithwallet(rawtx['hex'])['hex']\n+        txid = self.nodes[0].sendrawtransaction(signed_tx)\n+        self.nodes[0].generate(6)\n+        self.sync_all()\n+\n+        # Find the output pos\n+        p2sh_pos = -1\n+        p2wsh_pos = -1\n+        p2wpkh_pos = -1\n+        p2pkh_pos = -1\n+        p2sh_p2wsh_pos = -1\n+        p2sh_p2wpkh_pos = -1\n+        decoded = self.nodes[0].decoderawtransaction(signed_tx)\n+        for out in decoded['vout']:\n+            if out['scriptPubKey']['addresses'][0] == p2sh:\n+                p2sh_pos = out['n']\n+            elif out['scriptPubKey']['addresses'][0] == p2wsh:\n+                p2wsh_pos = out['n']\n+            elif out['scriptPubKey']['addresses'][0] == p2wpkh:\n+                p2wpkh_pos = out['n']\n+            elif out['scriptPubKey']['addresses'][0] == p2sh_p2wsh:\n+                p2sh_p2wsh_pos = out['n']\n+            elif out['scriptPubKey']['addresses'][0] == p2sh_p2wpkh:\n+                p2sh_p2wpkh_pos = out['n']\n+            elif out['scriptPubKey']['addresses'][0] == p2pkh:\n+                p2pkh_pos = out['n']\n+\n+        # spend single key from node 1\n+        rawtx = self.nodes[1].walletcreatefundedpsbt([{\"txid\":txid,\"vout\":p2wpkh_pos},{\"txid\":txid,\"vout\":p2sh_p2wpkh_pos},{\"txid\":txid,\"vout\":p2pkh_pos}], {self.nodes[1].getnewaddress():29.99})['psbt']\n+        walletprocesspsbt_out = self.nodes[1].walletprocesspsbt(rawtx)\n+        assert_equal(walletprocesspsbt_out['complete'], True)\n+        self.nodes[1].sendrawtransaction(self.nodes[1].finalizepsbt(walletprocesspsbt_out['psbt'])['hex'])\n+\n+        # partially sign multisig things with node 1\n+        psbtx = self.nodes[1].walletcreatefundedpsbt([{\"txid\":txid,\"vout\":p2wsh_pos},{\"txid\":txid,\"vout\":p2sh_pos},{\"txid\":txid,\"vout\":p2sh_p2wsh_pos}], {self.nodes[1].getnewaddress():29.99})['psbt']\n+        walletprocesspsbt_out = self.nodes[1].walletprocesspsbt(psbtx)\n+        psbtx = walletprocesspsbt_out['psbt']\n+        assert_equal(walletprocesspsbt_out['complete'], False)\n+\n+        # partially sign with node 2. This should be complete and sendable\n+        walletprocesspsbt_out = self.nodes[2].walletprocesspsbt(psbtx)\n+        assert_equal(walletprocesspsbt_out['complete'], True)\n+        self.nodes[2].sendrawtransaction(self.nodes[2].finalizepsbt(walletprocesspsbt_out['psbt'])['hex'])\n+\n+        # check that walletprocesspsbt fails to decode a non-psbt\n+        rawtx = self.nodes[1].createrawtransaction([{\"txid\":txid,\"vout\":p2wpkh_pos}], {self.nodes[1].getnewaddress():9.99})\n+        assert_raises_rpc_error(-22, \"TX decode failed\", self.nodes[1].walletprocesspsbt, rawtx)\n+\n+        # Convert a non-psbt to psbt and make sure we can decode it\n+        rawtx = self.nodes[0].createrawtransaction([], {self.nodes[1].getnewaddress():10})\n+        rawtx = self.nodes[0].fundrawtransaction(rawtx)\n+        new_psbt = self.nodes[0].converttopsbt(rawtx['hex'])\n+        self.nodes[0].decodepsbt(new_psbt)\n+\n+        # Make sure that a psbt with signatures cannot be converted\n+        signedtx = self.nodes[0].signrawtransactionwithwallet(rawtx['hex'])\n+        assert_raises_rpc_error(-22, \"Inputs must not have scriptSigs and scriptWitnesses\", self.nodes[0].converttopsbt, signedtx['hex'])\n+\n+        # Explicilty allow converting non-empty txs\n+        new_psbt = self.nodes[0].converttopsbt(rawtx['hex'])\n+        self.nodes[0].decodepsbt(new_psbt)\n+\n+        # BIP 174 Test Vectors",
    "path": "test/functional/rpc_psbt.py",
    "position": null,
    "original_position": 111,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "52a5f17a685e78ab28aab1d989003fe6c09760a2",
    "user": {
      "login": "Sjors",
      "id": 10217,
      "node_id": "MDQ6VXNlcjEwMjE3",
      "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Sjors",
      "html_url": "https://github.com/Sjors",
      "followers_url": "https://api.github.com/users/Sjors/followers",
      "following_url": "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url": "https://api.github.com/users/Sjors/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
      "organizations_url": "https://api.github.com/users/Sjors/orgs",
      "repos_url": "https://api.github.com/users/Sjors/repos",
      "events_url": "https://api.github.com/users/Sjors/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Sjors/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Move to `test/functional/data/psbt.json`?",
    "created_at": "2018-07-10T16:51:21Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201417187",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201417187"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201417187"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201417187/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 135,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201521967",
    "pull_request_review_id": 136041490,
    "id": 201521967,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTUyMTk2Nw==",
    "diff_hunk": "@@ -0,0 +1,171 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2014-2016 The Bitcoin Core developers",
    "path": "test/functional/rpc_psbt.py",
    "position": null,
    "original_position": 2,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "52a5f17a685e78ab28aab1d989003fe6c09760a2",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Fixed",
    "created_at": "2018-07-10T23:03:31Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201521967",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201521967"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201521967"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201521967/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 2,
    "side": "RIGHT",
    "in_reply_to_id": 201408039
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201521984",
    "pull_request_review_id": 136041506,
    "id": 201521984,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTUyMTk4NA==",
    "diff_hunk": "@@ -0,0 +1,171 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2014-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the Partially Signed Transaction RPCs.\n+\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+# Create one-input, one-output, no-fee transaction:\n+class PSBTTest(BitcoinTestFramework):\n+\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 3\n+\n+    def run_test(self):\n+\n+        # Get some money and activate segwit\n+        self.nodes[0].generate(500)",
    "path": "test/functional/rpc_psbt.py",
    "position": null,
    "original_position": 21,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "52a5f17a685e78ab28aab1d989003fe6c09760a2",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-07-10T23:03:36Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201521984",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201521984"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201521984"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201521984/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 21,
    "side": "RIGHT",
    "in_reply_to_id": 201411672
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201521993",
    "pull_request_review_id": 136041523,
    "id": 201521993,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTUyMTk5Mw==",
    "diff_hunk": "@@ -0,0 +1,171 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2014-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the Partially Signed Transaction RPCs.\n+\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+# Create one-input, one-output, no-fee transaction:\n+class PSBTTest(BitcoinTestFramework):\n+\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 3\n+\n+    def run_test(self):\n+\n+        # Get some money and activate segwit\n+        self.nodes[0].generate(500)\n+\n+        # Create and fund a raw tx for sending 10 BTC\n+        psbtx1 = self.nodes[0].walletcreatefundedpsbt([], {self.nodes[2].getnewaddress():10})['psbt']\n+\n+        # Node 1 should not be able to add anything to it but still return the psbtx same as before\n+        psbtx = self.nodes[1].walletprocesspsbt(psbtx1)['psbt']\n+        assert_equal(psbtx1, psbtx)\n+\n+        # Sign the transaction and send\n+        signed_tx = self.nodes[0].walletprocesspsbt(psbtx)['psbt']\n+        final_tx = self.nodes[0].finalizepsbt(signed_tx)['hex']\n+        self.nodes[0].sendrawtransaction(final_tx)\n+\n+        # Create p2sh, p2wpkh, and p2wsh addresses\n+        pubkey0 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())['pubkey']\n+        pubkey1 = self.nodes[1].getaddressinfo(self.nodes[1].getnewaddress())['pubkey']\n+        pubkey2 = self.nodes[2].getaddressinfo(self.nodes[2].getnewaddress())['pubkey']\n+        p2sh = self.nodes[1].addmultisigaddress(2, [pubkey0, pubkey1, pubkey2], \"\", \"legacy\")['address']\n+        p2wsh = self.nodes[1].addmultisigaddress(2, [pubkey0, pubkey1, pubkey2], \"\", \"bech32\")['address']\n+        p2sh_p2wsh = self.nodes[1].addmultisigaddress(2, [pubkey0, pubkey1, pubkey2], \"\", \"p2sh-segwit\")['address']\n+        p2wpkh = self.nodes[1].getnewaddress(\"\", \"bech32\")\n+        p2pkh = self.nodes[1].getnewaddress(\"\", \"legacy\")\n+        p2sh_p2wpkh = self.nodes[1].getnewaddress(\"\", \"p2sh-segwit\")\n+\n+        # fund those addresses\n+        rawtx = self.nodes[0].createrawtransaction([], {p2sh:10, p2wsh:10, p2wpkh:10, p2sh_p2wsh:10, p2sh_p2wpkh:10, p2pkh:10})\n+        rawtx = self.nodes[0].fundrawtransaction(rawtx, {\"changePosition\":3})\n+        signed_tx = self.nodes[0].signrawtransactionwithwallet(rawtx['hex'])['hex']\n+        txid = self.nodes[0].sendrawtransaction(signed_tx)\n+        self.nodes[0].generate(6)\n+        self.sync_all()\n+\n+        # Find the output pos\n+        p2sh_pos = -1\n+        p2wsh_pos = -1\n+        p2wpkh_pos = -1\n+        p2pkh_pos = -1\n+        p2sh_p2wsh_pos = -1\n+        p2sh_p2wpkh_pos = -1\n+        decoded = self.nodes[0].decoderawtransaction(signed_tx)\n+        for out in decoded['vout']:\n+            if out['scriptPubKey']['addresses'][0] == p2sh:\n+                p2sh_pos = out['n']\n+            elif out['scriptPubKey']['addresses'][0] == p2wsh:\n+                p2wsh_pos = out['n']\n+            elif out['scriptPubKey']['addresses'][0] == p2wpkh:\n+                p2wpkh_pos = out['n']\n+            elif out['scriptPubKey']['addresses'][0] == p2sh_p2wsh:\n+                p2sh_p2wsh_pos = out['n']\n+            elif out['scriptPubKey']['addresses'][0] == p2sh_p2wpkh:\n+                p2sh_p2wpkh_pos = out['n']\n+            elif out['scriptPubKey']['addresses'][0] == p2pkh:\n+                p2pkh_pos = out['n']\n+\n+        # spend single key from node 1\n+        rawtx = self.nodes[1].walletcreatefundedpsbt([{\"txid\":txid,\"vout\":p2wpkh_pos},{\"txid\":txid,\"vout\":p2sh_p2wpkh_pos},{\"txid\":txid,\"vout\":p2pkh_pos}], {self.nodes[1].getnewaddress():29.99})['psbt']\n+        walletprocesspsbt_out = self.nodes[1].walletprocesspsbt(rawtx)\n+        assert_equal(walletprocesspsbt_out['complete'], True)\n+        self.nodes[1].sendrawtransaction(self.nodes[1].finalizepsbt(walletprocesspsbt_out['psbt'])['hex'])\n+\n+        # partially sign multisig things with node 1\n+        psbtx = self.nodes[1].walletcreatefundedpsbt([{\"txid\":txid,\"vout\":p2wsh_pos},{\"txid\":txid,\"vout\":p2sh_pos},{\"txid\":txid,\"vout\":p2sh_p2wsh_pos}], {self.nodes[1].getnewaddress():29.99})['psbt']\n+        walletprocesspsbt_out = self.nodes[1].walletprocesspsbt(psbtx)\n+        psbtx = walletprocesspsbt_out['psbt']\n+        assert_equal(walletprocesspsbt_out['complete'], False)\n+\n+        # partially sign with node 2. This should be complete and sendable\n+        walletprocesspsbt_out = self.nodes[2].walletprocesspsbt(psbtx)\n+        assert_equal(walletprocesspsbt_out['complete'], True)\n+        self.nodes[2].sendrawtransaction(self.nodes[2].finalizepsbt(walletprocesspsbt_out['psbt'])['hex'])\n+\n+        # check that walletprocesspsbt fails to decode a non-psbt\n+        rawtx = self.nodes[1].createrawtransaction([{\"txid\":txid,\"vout\":p2wpkh_pos}], {self.nodes[1].getnewaddress():9.99})\n+        assert_raises_rpc_error(-22, \"TX decode failed\", self.nodes[1].walletprocesspsbt, rawtx)\n+\n+        # Convert a non-psbt to psbt and make sure we can decode it\n+        rawtx = self.nodes[0].createrawtransaction([], {self.nodes[1].getnewaddress():10})\n+        rawtx = self.nodes[0].fundrawtransaction(rawtx)\n+        new_psbt = self.nodes[0].converttopsbt(rawtx['hex'])\n+        self.nodes[0].decodepsbt(new_psbt)\n+\n+        # Make sure that a psbt with signatures cannot be converted\n+        signedtx = self.nodes[0].signrawtransactionwithwallet(rawtx['hex'])\n+        assert_raises_rpc_error(-22, \"Inputs must not have scriptSigs and scriptWitnesses\", self.nodes[0].converttopsbt, signedtx['hex'])\n+\n+        # Explicilty allow converting non-empty txs\n+        new_psbt = self.nodes[0].converttopsbt(rawtx['hex'])\n+        self.nodes[0].decodepsbt(new_psbt)\n+\n+        # BIP 174 Test Vectors",
    "path": "test/functional/rpc_psbt.py",
    "position": null,
    "original_position": 111,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "52a5f17a685e78ab28aab1d989003fe6c09760a2",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-07-10T23:03:40Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201521993",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201521993"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r201521993"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/201521993/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 135,
    "side": "RIGHT",
    "in_reply_to_id": 201417187
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202474322",
    "pull_request_review_id": 137192033,
    "id": 202474322,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjQ3NDMyMg==",
    "diff_hunk": "@@ -62,24 +77,579 @@ typedef std::pair<CPubKey, std::vector<unsigned char>> SigPair;\n // in order to construct final scriptSigs and scriptWitnesses.\n struct SignatureData {\n     bool complete = false; ///< Stores whether the scriptSig and scriptWitness are complete\n+    bool witness = false; ///< Stores whether the input this SigData corresponds to is a witness input\n     CScript scriptSig; ///< The scriptSig of an input. Contains complete signatures or the traditional partial signatures format\n     CScript redeem_script; ///< The redeemScript (if any) for the input\n     CScript witness_script; ///< The witnessScript (if any) for the input. witnessScripts are used in P2WSH outputs.\n     CScriptWitness scriptWitness; ///< The scriptWitness of an input. Contains complete signatures or the traditional partial signatures format. scriptWitness is part of a transaction input per BIP 144.\n     std::map<CKeyID, SigPair> signatures; ///< BIP 174 style partial signatures for the input. May contain all signatures necessary for producing a final scriptSig or scriptWitness.\n+    std::map<CKeyID, CPubKey> misc_pubkeys;\n \n     SignatureData() {}\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+// Magic bytes\n+static constexpr uint8_t PSBT_MAGIC_BYTES[4] = {'p', 's', 'b', 't'};\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key which indicates that this is the separator. The separator has no value.\n+static constexpr uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+template<typename Stream>\n+void DeserializeHDKeypaths(Stream& s, const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    // Make sure that the key is the size of pubkey + 1\n+    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+    }\n+    // Read in the pubkey from key\n+    CPubKey pubkey(key.begin() + 1, key.end());\n+    if (!pubkey.IsFullyValid()) {\n+       throw std::ios_base::failure(\"Invalid pubkey\");\n+    }\n+    if (hd_keypaths.count(pubkey) > 0) {\n+        throw std::ios_base::failure(\"Duplicate Key, pubkey derivation path already provided\");\n+    }\n+\n+    // Read in key path\n+    uint64_t value_len = ReadCompactSize(s);\n+    std::vector<uint32_t> keypath;\n+    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+        uint32_t index;\n+        s >> index;\n+        keypath.push_back(index);\n+    }\n+\n+    // Add to map\n+    hd_keypaths.emplace(pubkey, keypath);\n+}\n+\n+// Serialize HD keypaths to a stream from a map\n+template<typename Stream>\n+void SerializeHDKeypaths(Stream& s, const std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, uint8_t type)\n+{\n+    for (auto keypath_pair : hd_keypaths) {\n+        SerializeToVector(s, type, MakeSpan(keypath_pair.first));\n+        WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+        for (auto& path : keypath_pair.second) {\n+            s << path;\n+        }\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per-input information */\n+struct PSBTInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    void FillSignatureData(SignatureData& sigdata) const;\n+    void FromSignatureData(const SignatureData& sigdata);\n+    void Merge(const PSBTInput& input);\n+    bool IsSane() const;\n+    PSBTInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            SerializeHDKeypaths(s, hd_keypaths, PSBT_IN_BIP32_DERIVATION);\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // Read\n+            std::vector<unsigned char> key;\n+            s >> key;\n+\n+            // the key is empty if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key.empty()) return;\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    std::vector<unsigned char> sig;\n+                    s >> sig;\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, std::move(sig)));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    DeserializeHDKeypaths(s, key, hd_keypaths);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    std::vector<unsigned char> val_bytes;\n+                    s >> val_bytes;\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PSBTInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput\n+{\n+    CScript redeem_script;\n+    CScript witness_script;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    void FillSignatureData(SignatureData& sigdata) const;\n+    void FromSignatureData(const SignatureData& sigdata);\n+    void Merge(const PSBTOutput& output);\n+    bool IsSane() const;\n+    PSBTOutput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the redeem script\n+        if (!redeem_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_REDEEMSCRIPT);\n+            s << redeem_script;\n+        }\n+\n+        // Write the witness script\n+        if (!witness_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_WITNESSSCRIPT);\n+            s << witness_script;\n+        }\n+\n+        // Write any hd keypaths\n+        SerializeHDKeypaths(s, hd_keypaths, PSBT_OUT_BIP32_DERIVATION);\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // Read\n+            std::vector<unsigned char> key;\n+            s >> key;\n+\n+            // the key is empty if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key.empty()) return;\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_OUT_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_OUT_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_OUT_BIP32_DERIVATION:\n+                {\n+                    DeserializeHDKeypaths(s, key, hd_keypaths);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default: {\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    std::vector<unsigned char> val_bytes;\n+                    s >> val_bytes;\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PSBTOutput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    boost::optional<CMutableTransaction> tx;\n+    std::vector<PSBTInput> inputs;\n+    std::vector<PSBTOutput> outputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    void Merge(const PartiallySignedTransaction& psbt);\n+    bool IsSane() const;\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in) : tx(psbt_in.tx), inputs(psbt_in.inputs), outputs(psbt_in.outputs), unknown(psbt_in.unknown) {}\n+\n+    // Only checks if they refer to the same transaction\n+    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return a.tx->GetHash() == b.tx->GetHash();\n+    }\n+    friend bool operator!=(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return !(a == b);\n+    }\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // unsigned tx flag\n+        SerializeToVector(s, PSBT_GLOBAL_UNSIGNED_TX);\n+\n+        // Write serialized tx to a stream\n+        SerializeToVector(s, *tx);\n+\n+        // Write the unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        // Write inputs\n+        for (const PSBTInput& input : inputs) {\n+            s << input;\n+        }\n+        // Write outputs\n+        for (const PSBTOutput& output : outputs) {\n+            s << output;\n+        }\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read the magic bytes\n+        uint8_t magic[4];\n+        s >> magic;\n+        if (!std::equal(magic, magic + 4, PSBT_MAGIC_BYTES)) {\n+            throw std::ios_base::failure(\"Invalid PSBT magic bytes\");\n+        }\n+        unsigned char magic_sep;\n+        s >> magic_sep;",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 504,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "96237e8c759ef80e8c004868a604a839bf1f05b0",
    "user": {
      "login": "nodech",
      "id": 1651122,
      "node_id": "MDQ6VXNlcjE2NTExMjI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1651122?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nodech",
      "html_url": "https://github.com/nodech",
      "followers_url": "https://api.github.com/users/nodech/followers",
      "following_url": "https://api.github.com/users/nodech/following{/other_user}",
      "gists_url": "https://api.github.com/users/nodech/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nodech/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nodech/subscriptions",
      "organizations_url": "https://api.github.com/users/nodech/orgs",
      "repos_url": "https://api.github.com/users/nodech/repos",
      "events_url": "https://api.github.com/users/nodech/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nodech/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Does not `magic_sep` need to be `0xff` ?",
    "created_at": "2018-07-13T21:13:52Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r202474322",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "NONE",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202474322"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r202474322"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202474322/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 550,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202477190",
    "pull_request_review_id": 137195450,
    "id": 202477190,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjQ3NzE5MA==",
    "diff_hunk": "@@ -62,24 +77,579 @@ typedef std::pair<CPubKey, std::vector<unsigned char>> SigPair;\n // in order to construct final scriptSigs and scriptWitnesses.\n struct SignatureData {\n     bool complete = false; ///< Stores whether the scriptSig and scriptWitness are complete\n+    bool witness = false; ///< Stores whether the input this SigData corresponds to is a witness input\n     CScript scriptSig; ///< The scriptSig of an input. Contains complete signatures or the traditional partial signatures format\n     CScript redeem_script; ///< The redeemScript (if any) for the input\n     CScript witness_script; ///< The witnessScript (if any) for the input. witnessScripts are used in P2WSH outputs.\n     CScriptWitness scriptWitness; ///< The scriptWitness of an input. Contains complete signatures or the traditional partial signatures format. scriptWitness is part of a transaction input per BIP 144.\n     std::map<CKeyID, SigPair> signatures; ///< BIP 174 style partial signatures for the input. May contain all signatures necessary for producing a final scriptSig or scriptWitness.\n+    std::map<CKeyID, CPubKey> misc_pubkeys;\n \n     SignatureData() {}\n     explicit SignatureData(const CScript& script) : scriptSig(script) {}\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+// Magic bytes\n+static constexpr uint8_t PSBT_MAGIC_BYTES[4] = {'p', 's', 'b', 't'};\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key which indicates that this is the separator. The separator has no value.\n+static constexpr uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+template<typename Stream>\n+void DeserializeHDKeypaths(Stream& s, const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)\n+{\n+    // Make sure that the key is the size of pubkey + 1\n+    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+    }\n+    // Read in the pubkey from key\n+    CPubKey pubkey(key.begin() + 1, key.end());\n+    if (!pubkey.IsFullyValid()) {\n+       throw std::ios_base::failure(\"Invalid pubkey\");\n+    }\n+    if (hd_keypaths.count(pubkey) > 0) {\n+        throw std::ios_base::failure(\"Duplicate Key, pubkey derivation path already provided\");\n+    }\n+\n+    // Read in key path\n+    uint64_t value_len = ReadCompactSize(s);\n+    std::vector<uint32_t> keypath;\n+    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+        uint32_t index;\n+        s >> index;\n+        keypath.push_back(index);\n+    }\n+\n+    // Add to map\n+    hd_keypaths.emplace(pubkey, keypath);\n+}\n+\n+// Serialize HD keypaths to a stream from a map\n+template<typename Stream>\n+void SerializeHDKeypaths(Stream& s, const std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, uint8_t type)\n+{\n+    for (auto keypath_pair : hd_keypaths) {\n+        SerializeToVector(s, type, MakeSpan(keypath_pair.first));\n+        WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+        for (auto& path : keypath_pair.second) {\n+            s << path;\n+        }\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per-input information */\n+struct PSBTInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    void FillSignatureData(SignatureData& sigdata) const;\n+    void FromSignatureData(const SignatureData& sigdata);\n+    void Merge(const PSBTInput& input);\n+    bool IsSane() const;\n+    PSBTInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            SerializeHDKeypaths(s, hd_keypaths, PSBT_IN_BIP32_DERIVATION);\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // Read\n+            std::vector<unsigned char> key;\n+            s >> key;\n+\n+            // the key is empty if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key.empty()) return;\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    std::vector<unsigned char> sig;\n+                    s >> sig;\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, std::move(sig)));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    DeserializeHDKeypaths(s, key, hd_keypaths);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    std::vector<unsigned char> val_bytes;\n+                    s >> val_bytes;\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PSBTInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput\n+{\n+    CScript redeem_script;\n+    CScript witness_script;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    void FillSignatureData(SignatureData& sigdata) const;\n+    void FromSignatureData(const SignatureData& sigdata);\n+    void Merge(const PSBTOutput& output);\n+    bool IsSane() const;\n+    PSBTOutput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the redeem script\n+        if (!redeem_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_REDEEMSCRIPT);\n+            s << redeem_script;\n+        }\n+\n+        // Write the witness script\n+        if (!witness_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_WITNESSSCRIPT);\n+            s << witness_script;\n+        }\n+\n+        // Write any hd keypaths\n+        SerializeHDKeypaths(s, hd_keypaths, PSBT_OUT_BIP32_DERIVATION);\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // Read\n+            std::vector<unsigned char> key;\n+            s >> key;\n+\n+            // the key is empty if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key.empty()) return;\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_OUT_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_OUT_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_OUT_BIP32_DERIVATION:\n+                {\n+                    DeserializeHDKeypaths(s, key, hd_keypaths);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default: {\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    std::vector<unsigned char> val_bytes;\n+                    s >> val_bytes;\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PSBTOutput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    boost::optional<CMutableTransaction> tx;\n+    std::vector<PSBTInput> inputs;\n+    std::vector<PSBTOutput> outputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    void Merge(const PartiallySignedTransaction& psbt);\n+    bool IsSane() const;\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in) : tx(psbt_in.tx), inputs(psbt_in.inputs), outputs(psbt_in.outputs), unknown(psbt_in.unknown) {}\n+\n+    // Only checks if they refer to the same transaction\n+    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return a.tx->GetHash() == b.tx->GetHash();\n+    }\n+    friend bool operator!=(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return !(a == b);\n+    }\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // unsigned tx flag\n+        SerializeToVector(s, PSBT_GLOBAL_UNSIGNED_TX);\n+\n+        // Write serialized tx to a stream\n+        SerializeToVector(s, *tx);\n+\n+        // Write the unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        // Write inputs\n+        for (const PSBTInput& input : inputs) {\n+            s << input;\n+        }\n+        // Write outputs\n+        for (const PSBTOutput& output : outputs) {\n+            s << output;\n+        }\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read the magic bytes\n+        uint8_t magic[4];\n+        s >> magic;\n+        if (!std::equal(magic, magic + 4, PSBT_MAGIC_BYTES)) {\n+            throw std::ios_base::failure(\"Invalid PSBT magic bytes\");\n+        }\n+        unsigned char magic_sep;\n+        s >> magic_sep;",
    "path": "src/script/sign.h",
    "position": null,
    "original_position": 504,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "96237e8c759ef80e8c004868a604a839bf1f05b0",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Good catch. I have fixed this by adding 0xff to the magic bytes so it will be checked above.",
    "created_at": "2018-07-13T21:27:57Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r202477190",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202477190"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r202477190"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202477190/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 550,
    "side": "RIGHT",
    "in_reply_to_id": 202474322
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202842057",
    "pull_request_review_id": 137617602,
    "id": 202842057,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjg0MjA1Nw==",
    "diff_hunk": "@@ -1259,6 +1260,551 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : {             (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"bip32_derivs\\\" : {          (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : {                     (json object, optional) The public key with the derivation path as the value.\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"final_scriptsig\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"        }\\n\"\n+            \"       \\\"final_scriptwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"fee\\\" : fee                      (numeric, optional) The transaction fee paid if all UTXOs slots in the PSBT have been filled.\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    CAmount total_in = 0;\n+    bool have_all_utxos = true;\n+    UniValue inputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {\n+        const PSBTInput& input = psbtx.inputs[i];\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"amount\", ValueFromAmount(txout.nValue));\n+            total_in += txout.nValue;\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+            total_in += input.non_witness_utxo->vout[psbtx.tx->vin[i].prevout.n].nValue;\n+        } else {\n+            have_all_utxos = false;\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VOBJ);\n+            for (const auto& sig : input.partial_sigs) {\n+                partial_sigs.pushKV(HexStr(sig.second.first), HexStr(sig.second.second));\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            UniValue scriptsig(UniValue::VOBJ);\n+            scriptsig.pushKV(\"asm\", ScriptToAsmStr(input.final_script_sig, true));\n+            scriptsig.pushKV(\"hex\", HexStr(input.final_script_sig));\n+            in.pushKV(\"final_scriptSig\", scriptsig);\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            UniValue txinwitness(UniValue::VARR);\n+            for (const auto& item : input.final_script_witness.stack) {\n+                txinwitness.push_back(HexStr(item.begin(), item.end()));\n+            }\n+            in.pushKV(\"final_scriptwitness\", txinwitness);\n+        }\n+\n+        // Unknown data\n+        if (input.unknown.size() > 0) {\n+            UniValue unknowns(UniValue::VOBJ);\n+            for (auto entry : input.unknown) {\n+                unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+            }\n+            in.pushKV(\"unknown\", unknowns);\n+        }\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    CAmount output_value = 0;\n+    UniValue outputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.outputs.size(); ++i) {\n+        const PSBTOutput& output = psbtx.outputs[i];\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        if (output.unknown.size() > 0) {\n+            UniValue unknowns(UniValue::VOBJ);\n+            for (auto entry : output.unknown) {\n+                unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+            }\n+            out.pushKV(\"unknown\", unknowns);\n+        }\n+\n+        outputs.push_back(out);\n+\n+        // Fee calculation\n+        output_value += psbtx.tx->vout[i].nValue;\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+    if (have_all_utxos) {\n+        result.pushKV(\"fee\", ValueFromAmount(total_in - output_value));\n+    }\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"psbt\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner role.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        if (*it != merged_psbt) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+        merged_psbt.Merge(*it);\n+    }\n+    if (!merged_psbt.IsSane()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is inconsistent\");\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"psbt\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction. Otherwise a PSBT will be\\n\"\n+            \"created which has the final_scriptSig and final_scriptWitness fields filled for inputs that are complete.\\n\"\n+            \"Implements the Finalizer and Extractor roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization instead of the PSBT.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction if not extracted\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded network transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        SignatureData sigdata;\n+        complete &= SignPSBTInput(DUMMY_SIGNING_PROVIDER, *psbtx.tx, input, sigdata, i, 1);\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\n+    if (complete && extract) {\n+        CMutableTransaction mtx(*psbtx.tx);\n+        for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+            mtx.vin[i].scriptSig = psbtx.inputs[i].final_script_sig;\n+            mtx.vin[i].scriptWitness = psbtx.inputs[i].final_script_witness;\n+        }\n+        ssTx << mtx;\n+        result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n+    } else {\n+        ssTx << psbtx;\n+        result.push_back(Pair(\"psbt\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size())));\n+    }\n+    result.push_back(Pair(\"complete\", complete));\n+\n+    return result;\n+}\n+\n+UniValue createpsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n+        throw std::runtime_error(\n+                            \"createpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable )\\n\"\n+                            \"\\nCreates a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"\n+                            \"Implements the Creator role.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"inputs\\\"                (array, required) A json array of json objects\\n\"\n+                            \"     [\\n\"\n+                            \"       {\\n\"\n+                            \"         \\\"txid\\\":\\\"id\\\",      (string, required) The transaction id\\n\"\n+                            \"         \\\"vout\\\":n,         (numeric, required) The output number\\n\"\n+                            \"         \\\"sequence\\\":n      (numeric, optional) The sequence number\\n\"\n+                            \"       } \\n\"\n+                            \"       ,...\\n\"\n+                            \"     ]\\n\"\n+                            \"2. \\\"outputs\\\"               (array, required) a json array with outputs (key-value pairs)\\n\"\n+                            \"   [\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"address\\\": x.xxx,    (obj, optional) A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\\n\"\n+                            \"    },\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"data\\\": \\\"hex\\\"        (obj, optional) A key-value pair. The key must be \\\"data\\\", the value is hex encoded data\\n\"\n+                            \"    }\\n\"\n+                            \"    ,...                     More key-value pairs of the above form. For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n+                            \"                             accepted as second parameter.\\n\"\n+                            \"   ]\\n\"\n+                            \"3. locktime                  (numeric, optional, default=0) Raw locktime. Non-0 value also locktime-activates inputs\\n\"\n+                            \"4. replaceable               (boolean, optional, default=false) Marks this transaction as BIP125 replaceable.\\n\"\n+                            \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"        (string)  The resulting raw transaction (base64-encoded string)\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"createpsbt\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")\n+                            );\n+\n+\n+    RPCTypeCheck(request.params, {\n+        UniValue::VARR,\n+        UniValueType(), // ARR or OBJ, checked later\n+        UniValue::VNUM,\n+        UniValue::VBOOL,\n+        }, true\n+    );\n+\n+    CMutableTransaction rawTx = ConstructTransaction(request.params[0], request.params[1], request.params[2], request.params[3]);\n+\n+    // Make a blank psbt\n+    PartiallySignedTransaction psbtx;\n+    psbtx.tx = rawTx;\n+    for (unsigned int i = 0; i < rawTx.vin.size(); ++i) {\n+        psbtx.inputs.push_back(PSBTInput());\n+    }\n+    for (unsigned int i = 0; i < rawTx.vout.size(); ++i) {\n+        psbtx.outputs.push_back(PSBTOutput());\n+    }\n+\n+    // Serialize the PSBT\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue converttopsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+                            \"converttopsbt \\\"hexstring\\\" ( permitsigdata iswitness )\\n\"\n+                            \"\\nConverts a network serialized transaction to a PSBT. This should be used only with createrawtransaction and fundrawtransaction\\n\"\n+                            \"createpsbt and walletcreatefundedpsbt should be used for new applications.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"hexstring\\\"              (string, required) The hex string of a raw transaction\\n\"\n+                            \"2. permitsigdata           (boolean, optional, default=false) If true, any signatures in the input will be discarde and conversion.\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 504,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "3e3fb6e737739defb62459d6325ac8babfc76d8e",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Typo: discarde",
    "created_at": "2018-07-16T22:16:20Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r202842057",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202842057"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r202842057"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202842057/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1739,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202842625",
    "pull_request_review_id": 137617602,
    "id": 202842625,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjg0MjYyNQ==",
    "diff_hunk": "@@ -1259,6 +1260,551 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : {             (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"bip32_derivs\\\" : {          (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : {                     (json object, optional) The public key with the derivation path as the value.\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"final_scriptsig\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"        }\\n\"\n+            \"       \\\"final_scriptwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"fee\\\" : fee                      (numeric, optional) The transaction fee paid if all UTXOs slots in the PSBT have been filled.\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    CAmount total_in = 0;\n+    bool have_all_utxos = true;\n+    UniValue inputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {\n+        const PSBTInput& input = psbtx.inputs[i];\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"amount\", ValueFromAmount(txout.nValue));\n+            total_in += txout.nValue;\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+            total_in += input.non_witness_utxo->vout[psbtx.tx->vin[i].prevout.n].nValue;\n+        } else {\n+            have_all_utxos = false;\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VOBJ);\n+            for (const auto& sig : input.partial_sigs) {\n+                partial_sigs.pushKV(HexStr(sig.second.first), HexStr(sig.second.second));\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            UniValue scriptsig(UniValue::VOBJ);\n+            scriptsig.pushKV(\"asm\", ScriptToAsmStr(input.final_script_sig, true));\n+            scriptsig.pushKV(\"hex\", HexStr(input.final_script_sig));\n+            in.pushKV(\"final_scriptSig\", scriptsig);\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            UniValue txinwitness(UniValue::VARR);\n+            for (const auto& item : input.final_script_witness.stack) {\n+                txinwitness.push_back(HexStr(item.begin(), item.end()));\n+            }\n+            in.pushKV(\"final_scriptwitness\", txinwitness);\n+        }\n+\n+        // Unknown data\n+        if (input.unknown.size() > 0) {\n+            UniValue unknowns(UniValue::VOBJ);\n+            for (auto entry : input.unknown) {\n+                unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+            }\n+            in.pushKV(\"unknown\", unknowns);\n+        }\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    CAmount output_value = 0;\n+    UniValue outputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.outputs.size(); ++i) {\n+        const PSBTOutput& output = psbtx.outputs[i];\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        if (output.unknown.size() > 0) {\n+            UniValue unknowns(UniValue::VOBJ);\n+            for (auto entry : output.unknown) {\n+                unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+            }\n+            out.pushKV(\"unknown\", unknowns);\n+        }\n+\n+        outputs.push_back(out);\n+\n+        // Fee calculation\n+        output_value += psbtx.tx->vout[i].nValue;\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+    if (have_all_utxos) {\n+        result.pushKV(\"fee\", ValueFromAmount(total_in - output_value));\n+    }\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"psbt\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner role.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        if (*it != merged_psbt) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+        merged_psbt.Merge(*it);\n+    }\n+    if (!merged_psbt.IsSane()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is inconsistent\");\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"psbt\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction. Otherwise a PSBT will be\\n\"\n+            \"created which has the final_scriptSig and final_scriptWitness fields filled for inputs that are complete.\\n\"\n+            \"Implements the Finalizer and Extractor roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization instead of the PSBT.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction if not extracted\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded network transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        SignatureData sigdata;\n+        complete &= SignPSBTInput(DUMMY_SIGNING_PROVIDER, *psbtx.tx, input, sigdata, i, 1);\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\n+    if (complete && extract) {\n+        CMutableTransaction mtx(*psbtx.tx);\n+        for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+            mtx.vin[i].scriptSig = psbtx.inputs[i].final_script_sig;\n+            mtx.vin[i].scriptWitness = psbtx.inputs[i].final_script_witness;\n+        }\n+        ssTx << mtx;\n+        result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n+    } else {\n+        ssTx << psbtx;\n+        result.push_back(Pair(\"psbt\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size())));\n+    }\n+    result.push_back(Pair(\"complete\", complete));\n+\n+    return result;\n+}\n+\n+UniValue createpsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n+        throw std::runtime_error(\n+                            \"createpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable )\\n\"\n+                            \"\\nCreates a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"\n+                            \"Implements the Creator role.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"inputs\\\"                (array, required) A json array of json objects\\n\"\n+                            \"     [\\n\"\n+                            \"       {\\n\"\n+                            \"         \\\"txid\\\":\\\"id\\\",      (string, required) The transaction id\\n\"\n+                            \"         \\\"vout\\\":n,         (numeric, required) The output number\\n\"\n+                            \"         \\\"sequence\\\":n      (numeric, optional) The sequence number\\n\"\n+                            \"       } \\n\"\n+                            \"       ,...\\n\"\n+                            \"     ]\\n\"\n+                            \"2. \\\"outputs\\\"               (array, required) a json array with outputs (key-value pairs)\\n\"\n+                            \"   [\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"address\\\": x.xxx,    (obj, optional) A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\\n\"\n+                            \"    },\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"data\\\": \\\"hex\\\"        (obj, optional) A key-value pair. The key must be \\\"data\\\", the value is hex encoded data\\n\"\n+                            \"    }\\n\"\n+                            \"    ,...                     More key-value pairs of the above form. For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n+                            \"                             accepted as second parameter.\\n\"\n+                            \"   ]\\n\"\n+                            \"3. locktime                  (numeric, optional, default=0) Raw locktime. Non-0 value also locktime-activates inputs\\n\"\n+                            \"4. replaceable               (boolean, optional, default=false) Marks this transaction as BIP125 replaceable.\\n\"\n+                            \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"        (string)  The resulting raw transaction (base64-encoded string)\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"createpsbt\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")\n+                            );\n+\n+\n+    RPCTypeCheck(request.params, {\n+        UniValue::VARR,\n+        UniValueType(), // ARR or OBJ, checked later\n+        UniValue::VNUM,\n+        UniValue::VBOOL,\n+        }, true\n+    );\n+\n+    CMutableTransaction rawTx = ConstructTransaction(request.params[0], request.params[1], request.params[2], request.params[3]);\n+\n+    // Make a blank psbt\n+    PartiallySignedTransaction psbtx;\n+    psbtx.tx = rawTx;\n+    for (unsigned int i = 0; i < rawTx.vin.size(); ++i) {\n+        psbtx.inputs.push_back(PSBTInput());\n+    }\n+    for (unsigned int i = 0; i < rawTx.vout.size(); ++i) {\n+        psbtx.outputs.push_back(PSBTOutput());\n+    }\n+\n+    // Serialize the PSBT\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue converttopsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+                            \"converttopsbt \\\"hexstring\\\" ( permitsigdata iswitness )\\n\"\n+                            \"\\nConverts a network serialized transaction to a PSBT. This should be used only with createrawtransaction and fundrawtransaction\\n\"\n+                            \"createpsbt and walletcreatefundedpsbt should be used for new applications.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"hexstring\\\"              (string, required) The hex string of a raw transaction\\n\"\n+                            \"2. permitsigdata           (boolean, optional, default=false) If true, any signatures in the input will be discarde and conversion.\\n\"\n+                            \"                              will continue. If false, RPC will fail if any signatures are present.\\n\"\n+                            \"3. iswitness               (boolean, optional) Whether the transaction hex is a serialized witness transaction.\\n\"\n+                            \"                              If iswitness is not present, heuristic tests will be used in decoding. Only has an effect if\\n\"\n+                            \"                              permitsigdata is true\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"        (string)  The resulting raw transaction (base64-encoded string)\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nCreate a transaction\\n\"\n+                            + HelpExampleCli(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\") +\n+                            \"\\nConvert the transaction to a PSBT\\n\"\n+                            + HelpExampleCli(\"converttopsbt\", \"\\\"rawtransaction\\\"\")\n+                            );\n+\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL, UniValue::VBOOL}, true);\n+\n+    // parse hex string from parameter\n+    CMutableTransaction tx;\n+    bool permitsigdata = request.params[1].isNull() ? false : request.params[1].get_bool();\n+    bool iswitness = request.params[2].isNull() ? true : request.params[2].get_bool();\n+    bool try_witness = permitsigdata ? iswitness : true;",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 525,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "3e3fb6e737739defb62459d6325ac8babfc76d8e",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This seems wrong. With the current code, if permitsigdata is false it will try both witness and no_witness (where it should only permit non-witness, I think?). Further, when iswitness is not specified, it will only try witness.\r\n\r\nI think it should be something like:\r\n\r\n```c++\r\nbool witness_specified = !request.params[2].isNull();\r\nbool iswitness = witness_specified ? request.params[2].get_bool() : false;\r\nbool try_witness = permitsigdata ? (witness_specified ? iswitness : true) : false;\r\nbool try_no_witness = permitsigdata ? (witness_specified ? !iswitness : true) : true;\r\n```",
    "created_at": "2018-07-16T22:18:59Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r202842625",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202842625"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r202842625"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202842625/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1776,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202843597",
    "pull_request_review_id": 137617602,
    "id": 202843597,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjg0MzU5Nw==",
    "diff_hunk": "@@ -1259,6 +1260,551 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : {             (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"bip32_derivs\\\" : {          (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : {                     (json object, optional) The public key with the derivation path as the value.\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"final_scriptsig\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"        }\\n\"\n+            \"       \\\"final_scriptwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"fee\\\" : fee                      (numeric, optional) The transaction fee paid if all UTXOs slots in the PSBT have been filled.\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    CAmount total_in = 0;\n+    bool have_all_utxos = true;\n+    UniValue inputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {\n+        const PSBTInput& input = psbtx.inputs[i];\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"amount\", ValueFromAmount(txout.nValue));\n+            total_in += txout.nValue;\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+            total_in += input.non_witness_utxo->vout[psbtx.tx->vin[i].prevout.n].nValue;\n+        } else {\n+            have_all_utxos = false;\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VOBJ);\n+            for (const auto& sig : input.partial_sigs) {\n+                partial_sigs.pushKV(HexStr(sig.second.first), HexStr(sig.second.second));\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            UniValue scriptsig(UniValue::VOBJ);\n+            scriptsig.pushKV(\"asm\", ScriptToAsmStr(input.final_script_sig, true));\n+            scriptsig.pushKV(\"hex\", HexStr(input.final_script_sig));\n+            in.pushKV(\"final_scriptSig\", scriptsig);\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            UniValue txinwitness(UniValue::VARR);\n+            for (const auto& item : input.final_script_witness.stack) {\n+                txinwitness.push_back(HexStr(item.begin(), item.end()));\n+            }\n+            in.pushKV(\"final_scriptwitness\", txinwitness);\n+        }\n+\n+        // Unknown data\n+        if (input.unknown.size() > 0) {\n+            UniValue unknowns(UniValue::VOBJ);\n+            for (auto entry : input.unknown) {\n+                unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+            }\n+            in.pushKV(\"unknown\", unknowns);\n+        }\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    CAmount output_value = 0;\n+    UniValue outputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.outputs.size(); ++i) {\n+        const PSBTOutput& output = psbtx.outputs[i];\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        if (output.unknown.size() > 0) {\n+            UniValue unknowns(UniValue::VOBJ);\n+            for (auto entry : output.unknown) {\n+                unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+            }\n+            out.pushKV(\"unknown\", unknowns);\n+        }\n+\n+        outputs.push_back(out);\n+\n+        // Fee calculation\n+        output_value += psbtx.tx->vout[i].nValue;\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+    if (have_all_utxos) {\n+        result.pushKV(\"fee\", ValueFromAmount(total_in - output_value));\n+    }\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"psbt\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner role.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        if (*it != merged_psbt) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+        merged_psbt.Merge(*it);\n+    }\n+    if (!merged_psbt.IsSane()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is inconsistent\");\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"psbt\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction. Otherwise a PSBT will be\\n\"\n+            \"created which has the final_scriptSig and final_scriptWitness fields filled for inputs that are complete.\\n\"\n+            \"Implements the Finalizer and Extractor roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization instead of the PSBT.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction if not extracted\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded network transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        SignatureData sigdata;\n+        complete &= SignPSBTInput(DUMMY_SIGNING_PROVIDER, *psbtx.tx, input, sigdata, i, 1);\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\n+    if (complete && extract) {\n+        CMutableTransaction mtx(*psbtx.tx);\n+        for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+            mtx.vin[i].scriptSig = psbtx.inputs[i].final_script_sig;\n+            mtx.vin[i].scriptWitness = psbtx.inputs[i].final_script_witness;\n+        }\n+        ssTx << mtx;\n+        result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n+    } else {\n+        ssTx << psbtx;\n+        result.push_back(Pair(\"psbt\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size())));\n+    }\n+    result.push_back(Pair(\"complete\", complete));\n+\n+    return result;\n+}\n+\n+UniValue createpsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n+        throw std::runtime_error(\n+                            \"createpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable )\\n\"\n+                            \"\\nCreates a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 435,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "3e3fb6e737739defb62459d6325ac8babfc76d8e",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "No inputs will be added.",
    "created_at": "2018-07-16T22:23:35Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r202843597",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202843597"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r202843597"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202843597/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1686,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202844097",
    "pull_request_review_id": 137617602,
    "id": 202844097,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjg0NDA5Nw==",
    "diff_hunk": "@@ -1755,8 +1739,9 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n                             \"2. permitsigdata           (boolean, optional, default=false) If true, any signatures in the input will be discarde and conversion.\\n\"\n                             \"                              will continue. If false, RPC will fail if any signatures are present.\\n\"\n                             \"3. iswitness               (boolean, optional) Whether the transaction hex is a serialized witness transaction.\\n\"\n-                            \"                              If iswitness is not present, heuristic tests will be used in decoding. Only has an effect if\\n\"\n-                            \"                              permitsigdata is true\\n\"\n+                            \"                              If iswitness is not present, heuristic tests will be used in decoding. If true, only witness deserializaion\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 31,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "4afc08e4722e691e01ef4f35855012f51e5f6f7f",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Nit: RPC documentation is being changed in unrelated wallet RPC commit.",
    "created_at": "2018-07-16T22:25:33Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r202844097",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202844097"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r202844097"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202844097/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1742,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202852273",
    "pull_request_review_id": 137628881,
    "id": 202852273,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjg1MjI3Mw==",
    "diff_hunk": "@@ -1259,6 +1260,551 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : {             (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"bip32_derivs\\\" : {          (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : {                     (json object, optional) The public key with the derivation path as the value.\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"final_scriptsig\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"        }\\n\"\n+            \"       \\\"final_scriptwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"fee\\\" : fee                      (numeric, optional) The transaction fee paid if all UTXOs slots in the PSBT have been filled.\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    CAmount total_in = 0;\n+    bool have_all_utxos = true;\n+    UniValue inputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {\n+        const PSBTInput& input = psbtx.inputs[i];\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"amount\", ValueFromAmount(txout.nValue));\n+            total_in += txout.nValue;\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+            total_in += input.non_witness_utxo->vout[psbtx.tx->vin[i].prevout.n].nValue;\n+        } else {\n+            have_all_utxos = false;\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VOBJ);\n+            for (const auto& sig : input.partial_sigs) {\n+                partial_sigs.pushKV(HexStr(sig.second.first), HexStr(sig.second.second));\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            UniValue scriptsig(UniValue::VOBJ);\n+            scriptsig.pushKV(\"asm\", ScriptToAsmStr(input.final_script_sig, true));\n+            scriptsig.pushKV(\"hex\", HexStr(input.final_script_sig));\n+            in.pushKV(\"final_scriptSig\", scriptsig);\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            UniValue txinwitness(UniValue::VARR);\n+            for (const auto& item : input.final_script_witness.stack) {\n+                txinwitness.push_back(HexStr(item.begin(), item.end()));\n+            }\n+            in.pushKV(\"final_scriptwitness\", txinwitness);\n+        }\n+\n+        // Unknown data\n+        if (input.unknown.size() > 0) {\n+            UniValue unknowns(UniValue::VOBJ);\n+            for (auto entry : input.unknown) {\n+                unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+            }\n+            in.pushKV(\"unknown\", unknowns);\n+        }\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    CAmount output_value = 0;\n+    UniValue outputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.outputs.size(); ++i) {\n+        const PSBTOutput& output = psbtx.outputs[i];\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        if (output.unknown.size() > 0) {\n+            UniValue unknowns(UniValue::VOBJ);\n+            for (auto entry : output.unknown) {\n+                unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+            }\n+            out.pushKV(\"unknown\", unknowns);\n+        }\n+\n+        outputs.push_back(out);\n+\n+        // Fee calculation\n+        output_value += psbtx.tx->vout[i].nValue;\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+    if (have_all_utxos) {\n+        result.pushKV(\"fee\", ValueFromAmount(total_in - output_value));\n+    }\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"psbt\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner role.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        if (*it != merged_psbt) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+        merged_psbt.Merge(*it);\n+    }\n+    if (!merged_psbt.IsSane()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is inconsistent\");\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"psbt\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction. Otherwise a PSBT will be\\n\"\n+            \"created which has the final_scriptSig and final_scriptWitness fields filled for inputs that are complete.\\n\"\n+            \"Implements the Finalizer and Extractor roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization instead of the PSBT.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction if not extracted\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded network transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        SignatureData sigdata;\n+        complete &= SignPSBTInput(DUMMY_SIGNING_PROVIDER, *psbtx.tx, input, sigdata, i, 1);\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\n+    if (complete && extract) {\n+        CMutableTransaction mtx(*psbtx.tx);\n+        for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+            mtx.vin[i].scriptSig = psbtx.inputs[i].final_script_sig;\n+            mtx.vin[i].scriptWitness = psbtx.inputs[i].final_script_witness;\n+        }\n+        ssTx << mtx;\n+        result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n+    } else {\n+        ssTx << psbtx;\n+        result.push_back(Pair(\"psbt\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size())));\n+    }\n+    result.push_back(Pair(\"complete\", complete));\n+\n+    return result;\n+}\n+\n+UniValue createpsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n+        throw std::runtime_error(\n+                            \"createpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable )\\n\"\n+                            \"\\nCreates a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"\n+                            \"Implements the Creator role.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"inputs\\\"                (array, required) A json array of json objects\\n\"\n+                            \"     [\\n\"\n+                            \"       {\\n\"\n+                            \"         \\\"txid\\\":\\\"id\\\",      (string, required) The transaction id\\n\"\n+                            \"         \\\"vout\\\":n,         (numeric, required) The output number\\n\"\n+                            \"         \\\"sequence\\\":n      (numeric, optional) The sequence number\\n\"\n+                            \"       } \\n\"\n+                            \"       ,...\\n\"\n+                            \"     ]\\n\"\n+                            \"2. \\\"outputs\\\"               (array, required) a json array with outputs (key-value pairs)\\n\"\n+                            \"   [\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"address\\\": x.xxx,    (obj, optional) A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\\n\"\n+                            \"    },\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"data\\\": \\\"hex\\\"        (obj, optional) A key-value pair. The key must be \\\"data\\\", the value is hex encoded data\\n\"\n+                            \"    }\\n\"\n+                            \"    ,...                     More key-value pairs of the above form. For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n+                            \"                             accepted as second parameter.\\n\"\n+                            \"   ]\\n\"\n+                            \"3. locktime                  (numeric, optional, default=0) Raw locktime. Non-0 value also locktime-activates inputs\\n\"\n+                            \"4. replaceable               (boolean, optional, default=false) Marks this transaction as BIP125 replaceable.\\n\"\n+                            \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"        (string)  The resulting raw transaction (base64-encoded string)\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"createpsbt\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")\n+                            );\n+\n+\n+    RPCTypeCheck(request.params, {\n+        UniValue::VARR,\n+        UniValueType(), // ARR or OBJ, checked later\n+        UniValue::VNUM,\n+        UniValue::VBOOL,\n+        }, true\n+    );\n+\n+    CMutableTransaction rawTx = ConstructTransaction(request.params[0], request.params[1], request.params[2], request.params[3]);\n+\n+    // Make a blank psbt\n+    PartiallySignedTransaction psbtx;\n+    psbtx.tx = rawTx;\n+    for (unsigned int i = 0; i < rawTx.vin.size(); ++i) {\n+        psbtx.inputs.push_back(PSBTInput());\n+    }\n+    for (unsigned int i = 0; i < rawTx.vout.size(); ++i) {\n+        psbtx.outputs.push_back(PSBTOutput());\n+    }\n+\n+    // Serialize the PSBT\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue converttopsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+                            \"converttopsbt \\\"hexstring\\\" ( permitsigdata iswitness )\\n\"\n+                            \"\\nConverts a network serialized transaction to a PSBT. This should be used only with createrawtransaction and fundrawtransaction\\n\"\n+                            \"createpsbt and walletcreatefundedpsbt should be used for new applications.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"hexstring\\\"              (string, required) The hex string of a raw transaction\\n\"\n+                            \"2. permitsigdata           (boolean, optional, default=false) If true, any signatures in the input will be discarde and conversion.\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 504,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "3e3fb6e737739defb62459d6325ac8babfc76d8e",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Fixed",
    "created_at": "2018-07-16T23:07:54Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r202852273",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202852273"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r202852273"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202852273/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1739,
    "side": "RIGHT",
    "in_reply_to_id": 202842057
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202852393",
    "pull_request_review_id": 137629029,
    "id": 202852393,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjg1MjM5Mw==",
    "diff_hunk": "@@ -1259,6 +1260,551 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : {             (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"bip32_derivs\\\" : {          (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : {                     (json object, optional) The public key with the derivation path as the value.\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"final_scriptsig\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"        }\\n\"\n+            \"       \\\"final_scriptwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"fee\\\" : fee                      (numeric, optional) The transaction fee paid if all UTXOs slots in the PSBT have been filled.\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    CAmount total_in = 0;\n+    bool have_all_utxos = true;\n+    UniValue inputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {\n+        const PSBTInput& input = psbtx.inputs[i];\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"amount\", ValueFromAmount(txout.nValue));\n+            total_in += txout.nValue;\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+            total_in += input.non_witness_utxo->vout[psbtx.tx->vin[i].prevout.n].nValue;\n+        } else {\n+            have_all_utxos = false;\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VOBJ);\n+            for (const auto& sig : input.partial_sigs) {\n+                partial_sigs.pushKV(HexStr(sig.second.first), HexStr(sig.second.second));\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            UniValue scriptsig(UniValue::VOBJ);\n+            scriptsig.pushKV(\"asm\", ScriptToAsmStr(input.final_script_sig, true));\n+            scriptsig.pushKV(\"hex\", HexStr(input.final_script_sig));\n+            in.pushKV(\"final_scriptSig\", scriptsig);\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            UniValue txinwitness(UniValue::VARR);\n+            for (const auto& item : input.final_script_witness.stack) {\n+                txinwitness.push_back(HexStr(item.begin(), item.end()));\n+            }\n+            in.pushKV(\"final_scriptwitness\", txinwitness);\n+        }\n+\n+        // Unknown data\n+        if (input.unknown.size() > 0) {\n+            UniValue unknowns(UniValue::VOBJ);\n+            for (auto entry : input.unknown) {\n+                unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+            }\n+            in.pushKV(\"unknown\", unknowns);\n+        }\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    CAmount output_value = 0;\n+    UniValue outputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.outputs.size(); ++i) {\n+        const PSBTOutput& output = psbtx.outputs[i];\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        if (output.unknown.size() > 0) {\n+            UniValue unknowns(UniValue::VOBJ);\n+            for (auto entry : output.unknown) {\n+                unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+            }\n+            out.pushKV(\"unknown\", unknowns);\n+        }\n+\n+        outputs.push_back(out);\n+\n+        // Fee calculation\n+        output_value += psbtx.tx->vout[i].nValue;\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+    if (have_all_utxos) {\n+        result.pushKV(\"fee\", ValueFromAmount(total_in - output_value));\n+    }\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"psbt\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner role.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        if (*it != merged_psbt) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+        merged_psbt.Merge(*it);\n+    }\n+    if (!merged_psbt.IsSane()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is inconsistent\");\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"psbt\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction. Otherwise a PSBT will be\\n\"\n+            \"created which has the final_scriptSig and final_scriptWitness fields filled for inputs that are complete.\\n\"\n+            \"Implements the Finalizer and Extractor roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization instead of the PSBT.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction if not extracted\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded network transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        SignatureData sigdata;\n+        complete &= SignPSBTInput(DUMMY_SIGNING_PROVIDER, *psbtx.tx, input, sigdata, i, 1);\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\n+    if (complete && extract) {\n+        CMutableTransaction mtx(*psbtx.tx);\n+        for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+            mtx.vin[i].scriptSig = psbtx.inputs[i].final_script_sig;\n+            mtx.vin[i].scriptWitness = psbtx.inputs[i].final_script_witness;\n+        }\n+        ssTx << mtx;\n+        result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n+    } else {\n+        ssTx << psbtx;\n+        result.push_back(Pair(\"psbt\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size())));\n+    }\n+    result.push_back(Pair(\"complete\", complete));\n+\n+    return result;\n+}\n+\n+UniValue createpsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n+        throw std::runtime_error(\n+                            \"createpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable )\\n\"\n+                            \"\\nCreates a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"\n+                            \"Implements the Creator role.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"inputs\\\"                (array, required) A json array of json objects\\n\"\n+                            \"     [\\n\"\n+                            \"       {\\n\"\n+                            \"         \\\"txid\\\":\\\"id\\\",      (string, required) The transaction id\\n\"\n+                            \"         \\\"vout\\\":n,         (numeric, required) The output number\\n\"\n+                            \"         \\\"sequence\\\":n      (numeric, optional) The sequence number\\n\"\n+                            \"       } \\n\"\n+                            \"       ,...\\n\"\n+                            \"     ]\\n\"\n+                            \"2. \\\"outputs\\\"               (array, required) a json array with outputs (key-value pairs)\\n\"\n+                            \"   [\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"address\\\": x.xxx,    (obj, optional) A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\\n\"\n+                            \"    },\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"data\\\": \\\"hex\\\"        (obj, optional) A key-value pair. The key must be \\\"data\\\", the value is hex encoded data\\n\"\n+                            \"    }\\n\"\n+                            \"    ,...                     More key-value pairs of the above form. For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n+                            \"                             accepted as second parameter.\\n\"\n+                            \"   ]\\n\"\n+                            \"3. locktime                  (numeric, optional, default=0) Raw locktime. Non-0 value also locktime-activates inputs\\n\"\n+                            \"4. replaceable               (boolean, optional, default=false) Marks this transaction as BIP125 replaceable.\\n\"\n+                            \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"        (string)  The resulting raw transaction (base64-encoded string)\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"createpsbt\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")\n+                            );\n+\n+\n+    RPCTypeCheck(request.params, {\n+        UniValue::VARR,\n+        UniValueType(), // ARR or OBJ, checked later\n+        UniValue::VNUM,\n+        UniValue::VBOOL,\n+        }, true\n+    );\n+\n+    CMutableTransaction rawTx = ConstructTransaction(request.params[0], request.params[1], request.params[2], request.params[3]);\n+\n+    // Make a blank psbt\n+    PartiallySignedTransaction psbtx;\n+    psbtx.tx = rawTx;\n+    for (unsigned int i = 0; i < rawTx.vin.size(); ++i) {\n+        psbtx.inputs.push_back(PSBTInput());\n+    }\n+    for (unsigned int i = 0; i < rawTx.vout.size(); ++i) {\n+        psbtx.outputs.push_back(PSBTOutput());\n+    }\n+\n+    // Serialize the PSBT\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue converttopsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+                            \"converttopsbt \\\"hexstring\\\" ( permitsigdata iswitness )\\n\"\n+                            \"\\nConverts a network serialized transaction to a PSBT. This should be used only with createrawtransaction and fundrawtransaction\\n\"\n+                            \"createpsbt and walletcreatefundedpsbt should be used for new applications.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"hexstring\\\"              (string, required) The hex string of a raw transaction\\n\"\n+                            \"2. permitsigdata           (boolean, optional, default=false) If true, any signatures in the input will be discarde and conversion.\\n\"\n+                            \"                              will continue. If false, RPC will fail if any signatures are present.\\n\"\n+                            \"3. iswitness               (boolean, optional) Whether the transaction hex is a serialized witness transaction.\\n\"\n+                            \"                              If iswitness is not present, heuristic tests will be used in decoding. Only has an effect if\\n\"\n+                            \"                              permitsigdata is true\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"psbt\\\"        (string)  The resulting raw transaction (base64-encoded string)\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nCreate a transaction\\n\"\n+                            + HelpExampleCli(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\") +\n+                            \"\\nConvert the transaction to a PSBT\\n\"\n+                            + HelpExampleCli(\"converttopsbt\", \"\\\"rawtransaction\\\"\")\n+                            );\n+\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL, UniValue::VBOOL}, true);\n+\n+    // parse hex string from parameter\n+    CMutableTransaction tx;\n+    bool permitsigdata = request.params[1].isNull() ? false : request.params[1].get_bool();\n+    bool iswitness = request.params[2].isNull() ? true : request.params[2].get_bool();\n+    bool try_witness = permitsigdata ? iswitness : true;",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 525,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "3e3fb6e737739defb62459d6325ac8babfc76d8e",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done",
    "created_at": "2018-07-16T23:08:38Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r202852393",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202852393"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r202852393"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202852393/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1776,
    "side": "RIGHT",
    "in_reply_to_id": 202842625
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202852425",
    "pull_request_review_id": 137629076,
    "id": 202852425,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjg1MjQyNQ==",
    "diff_hunk": "@@ -1259,6 +1260,551 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m\";\n+    for (uint32_t num : keypath) {\n+        keypath_str += \"/\";\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"psbt\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"            (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"    \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"     ...\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"amount\\\" : x.xxx,           (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"address\\\" : \\\"address\\\"     (string) Bitcoin address if there is one\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : {             (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : \\\"signature\\\",           (string) The public key and signature that corresponds to it.\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type to be used\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"bip32_derivs\\\" : {          (json object, optional)\\n\"\n+            \"        \\\"pubkey\\\" : {                     (json object, optional) The public key with the derivation path as the value.\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      }\\n\"\n+            \"      \\\"final_scriptsig\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"        }\\n\"\n+            \"       \\\"final_scriptwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"outputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"redeem_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"        }\\n\"\n+            \"      \\\"witness_script\\\" : {       (json object, optional)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"      }\\n\"\n+            \"      \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"          \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"          \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"          }\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ],\\n\"\n+            \"      \\\"unknown\\\" : {                (json object) The unknown global fields\\n\"\n+            \"        \\\"key\\\" : \\\"value\\\"            (key-value pair) An unknown key-value pair\\n\"\n+            \"         ...\\n\"\n+            \"      },\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"  \\\"fee\\\" : fee                      (numeric, optional) The transaction fee paid if all UTXOs slots in the PSBT have been filled.\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"psbt\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(*psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // Unknown data\n+    UniValue unknowns(UniValue::VOBJ);\n+    for (auto entry : psbtx.unknown) {\n+        unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+    }\n+    result.pushKV(\"unknown\", unknowns);\n+\n+    // inputs\n+    CAmount total_in = 0;\n+    bool have_all_utxos = true;\n+    UniValue inputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {\n+        const PSBTInput& input = psbtx.inputs[i];\n+        UniValue in(UniValue::VOBJ);\n+        // UTXOs\n+        if (!input.witness_utxo.IsNull()) {\n+            const CTxOut& txout = input.witness_utxo;\n+\n+            UniValue out(UniValue::VOBJ);\n+\n+            out.pushKV(\"amount\", ValueFromAmount(txout.nValue));\n+            total_in += txout.nValue;\n+\n+            UniValue o(UniValue::VOBJ);\n+            ScriptToUniv(txout.scriptPubKey, o, true);\n+            out.pushKV(\"scriptPubKey\", o);\n+            in.pushKV(\"witness_utxo\", out);\n+        } else if (input.non_witness_utxo) {\n+            UniValue non_wit(UniValue::VOBJ);\n+            TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+            in.pushKV(\"non_witness_utxo\", non_wit);\n+            total_in += input.non_witness_utxo->vout[psbtx.tx->vin[i].prevout.n].nValue;\n+        } else {\n+            have_all_utxos = false;\n+        }\n+\n+        // Partial sigs\n+        if (!input.partial_sigs.empty()) {\n+            UniValue partial_sigs(UniValue::VOBJ);\n+            for (const auto& sig : input.partial_sigs) {\n+                partial_sigs.pushKV(HexStr(sig.second.first), HexStr(sig.second.second));\n+            }\n+            in.pushKV(\"partial_signatures\", partial_sigs);\n+        }\n+\n+        // Sighash\n+        if (input.sighash_type > 0) {\n+            in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+        }\n+\n+        // Redeem script and witness script\n+        if (!input.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.redeem_script, r, false);\n+            in.pushKV(\"redeem_script\", r);\n+        }\n+        if (!input.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(input.witness_script, r, false);\n+            in.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!input.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : input.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            in.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Final scriptSig and scriptwitness\n+        if (!input.final_script_sig.empty()) {\n+            UniValue scriptsig(UniValue::VOBJ);\n+            scriptsig.pushKV(\"asm\", ScriptToAsmStr(input.final_script_sig, true));\n+            scriptsig.pushKV(\"hex\", HexStr(input.final_script_sig));\n+            in.pushKV(\"final_scriptSig\", scriptsig);\n+        }\n+        if (!input.final_script_witness.IsNull()) {\n+            UniValue txinwitness(UniValue::VARR);\n+            for (const auto& item : input.final_script_witness.stack) {\n+                txinwitness.push_back(HexStr(item.begin(), item.end()));\n+            }\n+            in.pushKV(\"final_scriptwitness\", txinwitness);\n+        }\n+\n+        // Unknown data\n+        if (input.unknown.size() > 0) {\n+            UniValue unknowns(UniValue::VOBJ);\n+            for (auto entry : input.unknown) {\n+                unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+            }\n+            in.pushKV(\"unknown\", unknowns);\n+        }\n+\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    CAmount output_value = 0;\n+    UniValue outputs(UniValue::VARR);\n+    for (unsigned int i = 0; i < psbtx.outputs.size(); ++i) {\n+        const PSBTOutput& output = psbtx.outputs[i];\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.redeem_script, r, false);\n+            out.pushKV(\"redeem_script\", r);\n+        }\n+        if (!output.witness_script.empty()) {\n+            UniValue r(UniValue::VOBJ);\n+            ScriptToUniv(output.witness_script, r, false);\n+            out.pushKV(\"witness_script\", r);\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", strprintf(\"%08x\", bswap_32(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+\n+        // Unknown data\n+        if (output.unknown.size() > 0) {\n+            UniValue unknowns(UniValue::VOBJ);\n+            for (auto entry : output.unknown) {\n+                unknowns.pushKV(HexStr(entry.first), HexStr(entry.second));\n+            }\n+            out.pushKV(\"unknown\", unknowns);\n+        }\n+\n+        outputs.push_back(out);\n+\n+        // Fee calculation\n+        output_value += psbtx.tx->vout[i].nValue;\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+    if (have_all_utxos) {\n+        result.pushKV(\"fee\", ValueFromAmount(total_in - output_value));\n+    }\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"psbt\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+            \"Implements the Combiner role.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of base64 strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"psbt\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"  \\\"psbt\\\"          (string) The base64-encoded partially signed transaction\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::string error;\n+        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        if (*it != merged_psbt) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+        merged_psbt.Merge(*it);\n+    }\n+    if (!merged_psbt.IsSane()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is inconsistent\");\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbt;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"psbt\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction. Otherwise a PSBT will be\\n\"\n+            \"created which has the final_scriptSig and final_scriptWitness fields filled for inputs that are complete.\\n\"\n+            \"Implements the Finalizer and Extractor roles.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"psbt\\\"                 (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization instead of the PSBT.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction if not extracted\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded network transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::string error;\n+    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        SignatureData sigdata;\n+        complete &= SignPSBTInput(DUMMY_SIGNING_PROVIDER, *psbtx.tx, input, sigdata, i, 1);\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\n+    if (complete && extract) {\n+        CMutableTransaction mtx(*psbtx.tx);\n+        for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+            mtx.vin[i].scriptSig = psbtx.inputs[i].final_script_sig;\n+            mtx.vin[i].scriptWitness = psbtx.inputs[i].final_script_witness;\n+        }\n+        ssTx << mtx;\n+        result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n+    } else {\n+        ssTx << psbtx;\n+        result.push_back(Pair(\"psbt\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size())));\n+    }\n+    result.push_back(Pair(\"complete\", complete));\n+\n+    return result;\n+}\n+\n+UniValue createpsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n+        throw std::runtime_error(\n+                            \"createpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable )\\n\"\n+                            \"\\nCreates a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 435,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "3e3fb6e737739defb62459d6325ac8babfc76d8e",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Fixed",
    "created_at": "2018-07-16T23:08:50Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r202852425",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202852425"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r202852425"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202852425/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1686,
    "side": "RIGHT",
    "in_reply_to_id": 202843597
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202852450",
    "pull_request_review_id": 137629107,
    "id": 202852450,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjg1MjQ1MA==",
    "diff_hunk": "@@ -1755,8 +1739,9 @@ UniValue converttopsbt(const JSONRPCRequest& request)\n                             \"2. permitsigdata           (boolean, optional, default=false) If true, any signatures in the input will be discarde and conversion.\\n\"\n                             \"                              will continue. If false, RPC will fail if any signatures are present.\\n\"\n                             \"3. iswitness               (boolean, optional) Whether the transaction hex is a serialized witness transaction.\\n\"\n-                            \"                              If iswitness is not present, heuristic tests will be used in decoding. Only has an effect if\\n\"\n-                            \"                              permitsigdata is true\\n\"\n+                            \"                              If iswitness is not present, heuristic tests will be used in decoding. If true, only witness deserializaion\\n\"",
    "path": "src/rpc/rawtransaction.cpp",
    "position": null,
    "original_position": 31,
    "commit_id": "020628e3a4e88e36647eaf92bac4b3552796ac6a",
    "original_commit_id": "4afc08e4722e691e01ef4f35855012f51e5f6f7f",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following{/other_user}",
      "gists_url": "https://api.github.com/users/achow101/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/achow101/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events{/privacy}",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Fixed",
    "created_at": "2018-07-16T23:08:59Z",
    "updated_at": "2018-07-17T00:05:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r202852450",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202852450"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r202852450"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202852450/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 1742,
    "side": "RIGHT",
    "in_reply_to_id": 202844097
  }
]