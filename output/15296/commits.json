[
  {
    "sha": "43206239a8fab767849129368560afc4ac901047",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0MzIwNjIzOWE4ZmFiNzY3ODQ5MTI5MzY4NTYwYWZjNGFjOTAxMDQ3",
    "commit": {
      "author": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2019-01-30T20:53:11Z"
      },
      "committer": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2019-02-15T08:38:07Z"
      },
      "message": "tests: Add script checking for deterministic line coverage",
      "tree": {
        "sha": "c9c478414117aa6e8655ed306695ae52a1ea08cb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c9c478414117aa6e8655ed306695ae52a1ea08cb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/43206239a8fab767849129368560afc4ac901047",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/43206239a8fab767849129368560afc4ac901047",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/43206239a8fab767849129368560afc4ac901047",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/43206239a8fab767849129368560afc4ac901047/comments",
    "author": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1933e38c1a08d479130d11d9fc08bc7c73a82575",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1933e38c1a08d479130d11d9fc08bc7c73a82575",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1933e38c1a08d479130d11d9fc08bc7c73a82575"
      }
    ],
    "stats": {
      "total": 151,
      "additions": 151,
      "deletions": 0
    },
    "files": [
      {
        "sha": "16d03e1fffc749fc29afebc181e3561012bd1517",
        "filename": "contrib/devtools/test_deterministic_coverage.sh",
        "status": "added",
        "additions": 151,
        "deletions": 0,
        "changes": 151,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/43206239a8fab767849129368560afc4ac901047/contrib/devtools/test_deterministic_coverage.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/43206239a8fab767849129368560afc4ac901047/contrib/devtools/test_deterministic_coverage.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/test_deterministic_coverage.sh?ref=43206239a8fab767849129368560afc4ac901047",
        "patch": "@@ -0,0 +1,151 @@\n+#!/usr/bin/env bash\n+#\n+# Copyright (c) 2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+# Test for deterministic coverage across unit test runs.\n+\n+export LC_ALL=C\n+\n+# Use GCOV_EXECUTABLE=\"gcov\" if compiling with gcc.\n+# Use GCOV_EXECUTABLE=\"llvm-cov gcov\" if compiling with clang.\n+GCOV_EXECUTABLE=\"gcov\"\n+\n+# Disable tests known to cause non-deterministic behaviour and document the source or point of non-determinism.\n+NON_DETERMINISTIC_TESTS=(\n+    \"coinselector_tests/knapsack_solver_test\"                 # coinselector_tests.cpp: if (equal_sets(setCoinsRet, setCoinsRet2))\n+    \"denialofservice_tests/DoS_mapOrphans\"                    # denialofservice_tests.cpp: it = mapOrphanTransactions.lower_bound(InsecureRand256());\n+    \"fs_tests/fsbridge_fstream\"                               # deterministic test failure?\n+    \"miner_tests/CreateNewBlock_validity\"                     # validation.cpp: if (GetMainSignals().CallbacksPending() > 10)\n+    \"scheduler_tests/manythreads\"                             # scheduler.cpp: CScheduler::serviceQueue()\n+    \"scheduler_tests/singlethreadedscheduler_ordered\"         # scheduler.cpp: CScheduler::serviceQueue()\n+    \"tx_validationcache_tests/checkinputs_test\"               # validation.cpp: if (GetMainSignals().CallbacksPending() > 10)\n+    \"tx_validationcache_tests/tx_mempool_block_doublespend\"   # validation.cpp: if (GetMainSignals().CallbacksPending() > 10)\n+    \"txindex_tests/txindex_initial_sync\"                      # validation.cpp: if (GetMainSignals().CallbacksPending() > 10)\n+    \"txvalidation_tests/tx_mempool_reject_coinbase\"           # validation.cpp: if (GetMainSignals().CallbacksPending() > 10)\n+    \"validation_block_tests/processnewblock_signals_ordering\" # validation.cpp: if (GetMainSignals().CallbacksPending() > 10)\n+    \"wallet_tests/coin_mark_dirty_immature_credit\"            # validation.cpp: if (GetMainSignals().CallbacksPending() > 10)\n+    \"wallet_tests/dummy_input_size_test\"                      # validation.cpp: if (GetMainSignals().CallbacksPending() > 10)\n+    \"wallet_tests/importmulti_rescan\"                         # validation.cpp: if (GetMainSignals().CallbacksPending() > 10)\n+    \"wallet_tests/importwallet_rescan\"                        # validation.cpp: if (GetMainSignals().CallbacksPending() > 10)\n+    \"wallet_tests/ListCoins\"                                  # validation.cpp: if (GetMainSignals().CallbacksPending() > 10)\n+    \"wallet_tests/scan_for_wallet_transactions\"               # validation.cpp: if (GetMainSignals().CallbacksPending() > 10)\n+    \"wallet_tests/wallet_disableprivkeys\"                     # validation.cpp: if (GetMainSignals().CallbacksPending() > 10)\n+)\n+\n+TEST_BITCOIN_BINARY=\"src/test/test_bitcoin\"\n+\n+print_usage() {\n+    echo \"Usage: $0 [custom test filter (default: all but known non-deterministic tests)] [number of test runs (default: 2)]\"\n+}\n+\n+N_TEST_RUNS=2\n+BOOST_TEST_RUN_FILTERS=\"\"\n+if [[ $# != 0 ]]; then\n+    if [[ $1 == \"--help\" ]]; then\n+        print_usage\n+        exit\n+    fi\n+    PARSED_ARGUMENTS=0\n+    if [[ $1 =~ [a-z] ]]; then\n+        BOOST_TEST_RUN_FILTERS=$1\n+        PARSED_ARGUMENTS=$((PARSED_ARGUMENTS + 1))\n+        shift\n+    fi\n+    if [[ $1 =~ ^[0-9]+$ ]]; then\n+        N_TEST_RUNS=$1\n+        PARSED_ARGUMENTS=$((PARSED_ARGUMENTS + 1))\n+        shift\n+    fi\n+    if [[ ${PARSED_ARGUMENTS} == 0 || $# -gt 2 || ${N_TEST_RUNS} -lt 2 ]]; then\n+        print_usage\n+        exit\n+    fi\n+fi\n+if [[ ${BOOST_TEST_RUN_FILTERS} == \"\" ]]; then\n+    BOOST_TEST_RUN_FILTERS=\"$(IFS=\":\"; echo \"!${NON_DETERMINISTIC_TESTS[*]}\" | sed 's/:/:!/g')\"\n+else\n+    echo \"Using Boost test filter: ${BOOST_TEST_RUN_FILTERS}\"\n+    echo\n+fi\n+\n+if ! command -v gcov > /dev/null; then\n+    echo \"Error: gcov not installed. Exiting.\"\n+    exit 1\n+fi\n+\n+if ! command -v gcovr > /dev/null; then\n+    echo \"Error: gcovr not installed. Exiting.\"\n+    exit 1\n+fi\n+\n+if [[ ! -e ${TEST_BITCOIN_BINARY} ]]; then\n+    echo \"Error: Executable ${TEST_BITCOIN_BINARY} not found. Run \\\"./configure --enable-lcov\\\" and compile.\"\n+    exit 1\n+fi\n+\n+get_file_suffix_count() {\n+    find src/ -type f -name \"*.$1\" | wc -l\n+}\n+\n+if [[ $(get_file_suffix_count gcno) == 0 ]]; then\n+    echo \"Error: Could not find any *.gcno files. The *.gcno files are generated by the compiler. Run \\\"./configure --enable-lcov\\\" and re-compile.\"\n+    exit 1\n+fi\n+\n+get_covr_filename() {\n+    echo \"gcovr.run-$1.txt\"\n+}\n+\n+TEST_RUN_ID=0\n+while [[ ${TEST_RUN_ID} -lt ${N_TEST_RUNS} ]]; do\n+    TEST_RUN_ID=$((TEST_RUN_ID + 1))\n+    echo \"[$(date +\"%Y-%m-%d %H:%M:%S\")] Measuring coverage, run #${TEST_RUN_ID} of ${N_TEST_RUNS}\"\n+    find src/ -type f -name \"*.gcda\" -exec rm {} \\;\n+    if [[ $(get_file_suffix_count gcda) != 0 ]]; then\n+        echo \"Error: Stale *.gcda files found. Exiting.\"\n+        exit 1\n+    fi\n+    TEST_OUTPUT_TEMPFILE=$(mktemp)\n+    if ! BOOST_TEST_RUN_FILTERS=\"${BOOST_TEST_RUN_FILTERS}\" ${TEST_BITCOIN_BINARY} > \"${TEST_OUTPUT_TEMPFILE}\" 2>&1; then\n+        cat \"${TEST_OUTPUT_TEMPFILE}\"\n+        rm \"${TEST_OUTPUT_TEMPFILE}\"\n+        exit 1\n+    fi\n+    rm \"${TEST_OUTPUT_TEMPFILE}\"\n+    if [[ $(get_file_suffix_count gcda) == 0 ]]; then\n+        echo \"Error: Running the test suite did not create any *.gcda files. The gcda files are generated when the instrumented test programs are executed. Run \\\"./configure --enable-lcov\\\" and re-compile.\"\n+        exit 1\n+    fi\n+    GCOVR_TEMPFILE=$(mktemp)\n+    if ! gcovr --gcov-executable \"${GCOV_EXECUTABLE}\" -r src/ > \"${GCOVR_TEMPFILE}\"; then\n+        echo \"Error: gcovr failed. Output written to ${GCOVR_TEMPFILE}. Exiting.\"\n+        exit 1\n+    fi\n+    GCOVR_FILENAME=$(get_covr_filename ${TEST_RUN_ID})\n+    mv \"${GCOVR_TEMPFILE}\" \"${GCOVR_FILENAME}\"\n+    if grep -E \"^TOTAL *0 *0 \" \"${GCOVR_FILENAME}\"; then\n+        echo \"Error: Spurious gcovr output. Make sure the correct GCOV_EXECUTABLE variable is set in $0 (\\\"gcov\\\" for gcc, \\\"llvm-cov gcov\\\" for clang).\"\n+        exit 1\n+    fi\n+    if [[ ${TEST_RUN_ID} != 1 ]]; then\n+        COVERAGE_DIFF=$(diff -u \"$(get_covr_filename 1)\" \"${GCOVR_FILENAME}\")\n+        if [[ ${COVERAGE_DIFF} != \"\" ]]; then\n+            echo\n+            echo \"The line coverage is non-deterministic between runs. Exiting.\"\n+            echo\n+            echo \"The test suite must be deterministic in the sense that the set of lines executed at least\"\n+            echo \"once must be identical between runs. This is a necessary condition for meaningful\"\n+            echo \"coverage measuring.\"\n+            echo\n+            echo \"${COVERAGE_DIFF}\"\n+            exit 1\n+        fi\n+        rm \"${GCOVR_FILENAME}\"\n+    fi\n+done\n+\n+echo\n+echo \"Coverage test passed: Deterministic coverage across ${N_TEST_RUNS} runs.\"\n+exit"
      }
    ]
  }
]