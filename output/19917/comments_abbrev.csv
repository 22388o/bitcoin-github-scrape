promag,2020-09-08 14:04:04,@hebasto this is an example of stuff that I think we can do before moving locks around. The first and second commits refactor `ReattemptInitialBroadcast` to drop unlock/lock in each iteration.,https://github.com/bitcoin/bitcoin/pull/19917#issuecomment-688897981,688897981,
promag,2020-09-08 14:04:35,@vasild @ryanofsky your comment here would be nice too.,https://github.com/bitcoin/bitcoin/pull/19917#issuecomment-688898389,688898389,
hebasto,2020-09-08 15:50:10,Why draft?,https://github.com/bitcoin/bitcoin/pull/19917#issuecomment-688969167,688969167,
promag,2020-09-08 15:52:23,"Yeah I don't mind setting it ready for review, the goal was to show an example rather than adding noise to your PR.",https://github.com/bitcoin/bitcoin/pull/19917#issuecomment-688970636,688970636,
hebasto,2020-09-08 15:55:14,"> Yeah I don't mind setting it ready for review, the goal was to show an example rather than adding noise to your PR.\n\nI'll be happy to postpone #19872 until this PR is reviewed and merged :)",https://github.com/bitcoin/bitcoin/pull/19917#issuecomment-688972446,688972446,
hebasto,2020-09-08 17:55:30,Concept ACK.,https://github.com/bitcoin/bitcoin/pull/19917#issuecomment-689040546,689040546,
vasild,2020-09-08 19:13:43,"The changes in `PeerManager::ReattemptInitialBroadcast()` will execute `CTxMemPool::GetUnbroadcastTxs()` and `CTxMemPool::exists()` under `CTxMemPool::cs` whereas previously they were not called under this mutex. Both methods acquire the mutex themselves. So this adds more recursive mutex locks.\n\nWhat is the purpose of this patch? There is no description and commit messages are a bit scarce, m",https://github.com/bitcoin/bitcoin/pull/19917#issuecomment-689081363,689081363,
promag,2020-09-08 19:28:01,@vasild sure I can detail the intention. See https://github.com/bitcoin/bitcoin/pull/19917#discussion_r485027956.,https://github.com/bitcoin/bitcoin/pull/19917#issuecomment-689087764,689087764,
hebasto,2020-09-09 07:19:42,@promag To fix TSan errors consider comparing dde441c11a07b9ff72dbcfda896c61adf33ae228 with 049d8c54f4f14996c347d099bbad855c0aa74bb6.,https://github.com/bitcoin/bitcoin/pull/19917#issuecomment-689360687,689360687,
DrahtBot,2020-09-16 00:14:12,"<!--cf906140f33d8803c4a75a2196329ecb-->\nüêô This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a ""draft"".</sub>",https://github.com/bitcoin/bitcoin/pull/19917#issuecomment-693095452,693095452,
promag,2020-11-07 11:47:00,Rebase hell.,https://github.com/bitcoin/bitcoin/pull/19917#issuecomment-723435932,723435932,
promag,2020-09-08 15:54:57,This approach is also a small step towards removing the lock from `GetUnbroadcastTxs` and `exists`.,https://github.com/bitcoin/bitcoin/pull/19917#discussion_r485027956,485027956,src/net_processing.cpp
hebasto,2020-09-08 16:25:42,"8f30df2002f00b7613e602bc576285974d8f2bcf\nDoes this approach decrease concurrency wrt to `::cs_main` uninterruptible locking?",https://github.com/bitcoin/bitcoin/pull/19917#discussion_r485047637,485047637,src/net_processing.cpp
promag,2020-09-08 17:43:17,`RelayTransaction` doesn't hold `cs_main` that long.,https://github.com/bitcoin/bitcoin/pull/19917#discussion_r485091674,485091674,src/net_processing.cpp
promag,2020-09-08 21:08:48,Done in fb2dca415f6ac74d79292296831ccc33c485230b and dde441c11a07b9ff72dbcfda896c61adf33ae228.,https://github.com/bitcoin/bitcoin/pull/19917#discussion_r485197268,485197268,src/net_processing.cpp
vasild,2020-09-09 06:59:49,missing `return`?,https://github.com/bitcoin/bitcoin/pull/19917#discussion_r485381915,485381915,src/txmempool.cpp
vasild,2020-09-09 08:06:33,"This can be simplified to:\n\n```cpp\nvoid PeerManager::ReattemptInitialBroadcast(CScheduler& scheduler) const\n{\n    for (const auto& elem : WITH_LOCK(m_mempool.cs, return m_mempool.GetUnbroadcastTxs())) {\n        LOCK(cs_main);\n        RelayTransaction(elem.first, elem.second, m_connman);\n    } \n\n    // Schedule next run for 10-15 minutes in the future.\n    ...\n}\n```\n\nB",https://github.com/bitcoin/bitcoin/pull/19917#discussion_r485418310,485418310,src/net_processing.cpp
promag,2020-09-09 08:13:00,But is it really necessary to have `cs_main` lock in each iteration?,https://github.com/bitcoin/bitcoin/pull/19917#discussion_r485422236,485422236,src/net_processing.cpp
vasild,2020-09-09 08:51:49,"Since it was locked in each iteration before this PR, the question should rather be ""If we move `LOCK(cs_main)` before the loop, why would we do that?""\n\nThe frequent lock/unlock allows other threads to proceed. I don't see a reason to change it.",https://github.com/bitcoin/bitcoin/pull/19917#discussion_r485447727,485447727,src/net_processing.cpp
hebasto,2020-09-10 08:47:10,"> The frequent lock/unlock allows other threads to proceed. I don't see a reason to change it.\n\nAgree (https://github.com/bitcoin/bitcoin/pull/19917#discussion_r485047637).",https://github.com/bitcoin/bitcoin/pull/19917#discussion_r486171314,486171314,src/net_processing.cpp
promag,2020-09-10 13:57:04,"@vasild I don't agree with that. Other threads can proceed but the current thread will wait unnecessarily in each iteration for the lock and as such other things will be delayed, not mentioning the mutex overhead. See https://stackoverflow.com/a/3652428.\n\nIn this case `RelayTransaction` is pretty quick, nothing that can potentially cause a big lock on `cs_main`.",https://github.com/bitcoin/bitcoin/pull/19917#discussion_r486364727,486364727,src/net_processing.cpp
