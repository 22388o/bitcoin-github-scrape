[
  {
    "sha": "08ce33f8e95efa81b37ddc6b3350462c61bbfd51",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowOGNlMzNmOGU5NWVmYTgxYjM3ZGRjNmIzMzUwNDYyYzYxYmJmZDUx",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-08-16T16:17:34Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2017-08-17T13:17:09Z"
      },
      "message": "qa: Move wait_until to util",
      "tree": {
        "sha": "6aba3f369154013dc943169a89320fb8364af1a6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6aba3f369154013dc943169a89320fb8364af1a6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/08ce33f8e95efa81b37ddc6b3350462c61bbfd51",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/08ce33f8e95efa81b37ddc6b3350462c61bbfd51",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/08ce33f8e95efa81b37ddc6b3350462c61bbfd51",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/08ce33f8e95efa81b37ddc6b3350462c61bbfd51/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "22e301a3d56dc9e6878380ee92c7d19ca43119d2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/22e301a3d56dc9e6878380ee92c7d19ca43119d2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/22e301a3d56dc9e6878380ee92c7d19ca43119d2"
      }
    ],
    "stats": {
      "total": 167,
      "additions": 78,
      "deletions": 89
    },
    "files": [
      {
        "sha": "65ae8de554b64f36a71969efd036d385a6ed8738",
        "filename": "test/functional/bip65-cltv-p2p.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/08ce33f8e95efa81b37ddc6b3350462c61bbfd51/test/functional/bip65-cltv-p2p.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/08ce33f8e95efa81b37ddc6b3350462c61bbfd51/test/functional/bip65-cltv-p2p.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bip65-cltv-p2p.py?ref=08ce33f8e95efa81b37ddc6b3350462c61bbfd51",
        "patch": "@@ -109,7 +109,7 @@ def run_test(self):\n         node0.send_and_ping(msg_block(block))\n         assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n \n-        assert wait_until(lambda: \"reject\" in node0.last_message.keys())\n+        wait_until(lambda: \"reject\" in node0.last_message.keys(), lock=mininode_lock)\n         with mininode_lock:\n             assert_equal(node0.last_message[\"reject\"].code, REJECT_OBSOLETE)\n             assert_equal(node0.last_message[\"reject\"].reason, b'bad-version(0x00000003)')\n@@ -138,7 +138,7 @@ def run_test(self):\n         node0.send_and_ping(msg_block(block))\n         assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n \n-        assert wait_until (lambda: \"reject\" in node0.last_message.keys())\n+        wait_until(lambda: \"reject\" in node0.last_message.keys(), lock=mininode_lock)\n         with mininode_lock:\n             assert node0.last_message[\"reject\"].code in [REJECT_INVALID, REJECT_NONSTANDARD]\n             assert_equal(node0.last_message[\"reject\"].data, block.sha256)"
      },
      {
        "sha": "9775970893091240f6ba57a9c5310a83dca6ab4b",
        "filename": "test/functional/bipdersig-p2p.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/08ce33f8e95efa81b37ddc6b3350462c61bbfd51/test/functional/bipdersig-p2p.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/08ce33f8e95efa81b37ddc6b3350462c61bbfd51/test/functional/bipdersig-p2p.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bipdersig-p2p.py?ref=08ce33f8e95efa81b37ddc6b3350462c61bbfd51",
        "patch": "@@ -98,7 +98,7 @@ def run_test(self):\n         node0.send_and_ping(msg_block(block))\n         assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n \n-        assert wait_until(lambda: \"reject\" in node0.last_message.keys())\n+        wait_until(lambda: \"reject\" in node0.last_message.keys(), lock=mininode_lock)\n         with mininode_lock:\n             assert_equal(node0.last_message[\"reject\"].code, REJECT_OBSOLETE)\n             assert_equal(node0.last_message[\"reject\"].reason, b'bad-version(0x00000002)')\n@@ -128,7 +128,7 @@ def run_test(self):\n         node0.send_and_ping(msg_block(block))\n         assert_equal(int(self.nodes[0].getbestblockhash(), 16), tip)\n \n-        assert wait_until (lambda: \"reject\" in node0.last_message.keys())\n+        wait_until(lambda: \"reject\" in node0.last_message.keys(), lock=mininode_lock)\n         with mininode_lock:\n             # We can receive different reject messages depending on whether\n             # bitcoind is running with multiple script check threads. If script"
      },
      {
        "sha": "19723226d3ca2dd4a3b1877f533879756c4d14dc",
        "filename": "test/functional/disconnect_ban.py",
        "status": "modified",
        "additions": 9,
        "deletions": 7,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/08ce33f8e95efa81b37ddc6b3350462c61bbfd51/test/functional/disconnect_ban.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/08ce33f8e95efa81b37ddc6b3350462c61bbfd51/test/functional/disconnect_ban.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/disconnect_ban.py?ref=08ce33f8e95efa81b37ddc6b3350462c61bbfd51",
        "patch": "@@ -5,11 +5,13 @@\n \"\"\"Test node disconnect and ban behavior\"\"\"\n import time\n \n-from test_framework.mininode import wait_until\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import (assert_equal,\n-                                 assert_raises_jsonrpc,\n-                                 connect_nodes_bi)\n+from test_framework.util import (\n+    assert_equal,\n+    assert_raises_jsonrpc,\n+    connect_nodes_bi,\n+    wait_until,\n+)\n \n class DisconnectBanTest(BitcoinTestFramework):\n \n@@ -24,7 +26,7 @@ def run_test(self):\n         self.log.info(\"setban: successfully ban single IP address\")\n         assert_equal(len(self.nodes[1].getpeerinfo()), 2)  # node1 should have 2 connections to node0 at this point\n         self.nodes[1].setban(\"127.0.0.1\", \"add\")\n-        assert wait_until(lambda: len(self.nodes[1].getpeerinfo()) == 0, timeout=10)\n+        wait_until(lambda: len(self.nodes[1].getpeerinfo()) == 0, timeout=10)\n         assert_equal(len(self.nodes[1].getpeerinfo()), 0)  # all nodes must be disconnected at this point\n         assert_equal(len(self.nodes[1].listbanned()), 1)\n \n@@ -90,7 +92,7 @@ def run_test(self):\n         self.log.info(\"disconnectnode: successfully disconnect node by address\")\n         address1 = self.nodes[0].getpeerinfo()[0]['addr']\n         self.nodes[0].disconnectnode(address=address1)\n-        assert wait_until(lambda: len(self.nodes[0].getpeerinfo()) == 1, timeout=10)\n+        wait_until(lambda: len(self.nodes[0].getpeerinfo()) == 1, timeout=10)\n         assert not [node for node in self.nodes[0].getpeerinfo() if node['addr'] == address1]\n \n         self.log.info(\"disconnectnode: successfully reconnect node\")\n@@ -101,7 +103,7 @@ def run_test(self):\n         self.log.info(\"disconnectnode: successfully disconnect node by node id\")\n         id1 = self.nodes[0].getpeerinfo()[0]['id']\n         self.nodes[0].disconnectnode(nodeid=id1)\n-        assert wait_until(lambda: len(self.nodes[0].getpeerinfo()) == 1, timeout=10)\n+        wait_until(lambda: len(self.nodes[0].getpeerinfo()) == 1, timeout=10)\n         assert not [node for node in self.nodes[0].getpeerinfo() if node['id'] == id1]\n \n if __name__ == '__main__':"
      },
      {
        "sha": "4f9e0a7dd2ea42548e9f98018da6d3635a7aa3a0",
        "filename": "test/functional/example_test.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/08ce33f8e95efa81b37ddc6b3350462c61bbfd51/test/functional/example_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/08ce33f8e95efa81b37ddc6b3350462c61bbfd51/test/functional/example_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/example_test.py?ref=08ce33f8e95efa81b37ddc6b3350462c61bbfd51",
        "patch": "@@ -23,13 +23,13 @@\n     mininode_lock,\n     msg_block,\n     msg_getdata,\n-    wait_until,\n )\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n     connect_nodes,\n     p2p_port,\n+    wait_until,\n )\n \n # NodeConnCB is a class containing callbacks to be executed when a P2P\n@@ -209,7 +209,7 @@ def run_test(self):\n \n         # wait_until() will loop until a predicate condition is met. Use it to test properties of the\n         # NodeConnCB objects.\n-        assert wait_until(lambda: sorted(blocks) == sorted(list(node2.block_receive_map.keys())), timeout=5)\n+        wait_until(lambda: sorted(blocks) == sorted(list(node2.block_receive_map.keys())), timeout=5, lock=mininode_lock)\n \n         self.log.info(\"Check that each block was received only once\")\n         # The network thread uses a global lock on data access to the NodeConn objects when sending and receiving"
      },
      {
        "sha": "807edeb7a83227a78b1ccaf4e7aec0da63e3bb21",
        "filename": "test/functional/mempool_persist.py",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/08ce33f8e95efa81b37ddc6b3350462c61bbfd51/test/functional/mempool_persist.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/08ce33f8e95efa81b37ddc6b3350462c61bbfd51/test/functional/mempool_persist.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_persist.py?ref=08ce33f8e95efa81b37ddc6b3350462c61bbfd51",
        "patch": "@@ -32,7 +32,6 @@\n \"\"\"\n import time\n \n-from test_framework.mininode import wait_until\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import *\n \n@@ -69,7 +68,7 @@ def run_test(self):\n         self.nodes.append(self.start_node(1, self.options.tmpdir))\n         # Give bitcoind a second to reload the mempool\n         time.sleep(1)\n-        assert wait_until(lambda: len(self.nodes[0].getrawmempool()) == 5)\n+        wait_until(lambda: len(self.nodes[0].getrawmempool()) == 5)\n         assert_equal(len(self.nodes[1].getrawmempool()), 0)\n \n         self.log.debug(\"Stop-start node0 with -persistmempool=0. Verify that it doesn't load its mempool.dat file.\")\n@@ -84,7 +83,7 @@ def run_test(self):\n         self.stop_nodes()\n         self.nodes = []\n         self.nodes.append(self.start_node(0, self.options.tmpdir))\n-        assert wait_until(lambda: len(self.nodes[0].getrawmempool()) == 5)\n+        wait_until(lambda: len(self.nodes[0].getrawmempool()) == 5)\n \n if __name__ == '__main__':\n     MempoolPersistTest().main()"
      },
      {
        "sha": "c5c264765a3f0e243284904505c4875c3e546538",
        "filename": "test/functional/p2p-compactblocks.py",
        "status": "modified",
        "additions": 16,
        "deletions": 31,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/08ce33f8e95efa81b37ddc6b3350462c61bbfd51/test/functional/p2p-compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/08ce33f8e95efa81b37ddc6b3350462c61bbfd51/test/functional/p2p-compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-compactblocks.py?ref=08ce33f8e95efa81b37ddc6b3350462c61bbfd51",
        "patch": "@@ -70,27 +70,23 @@ def send_header_for_blocks(self, new_blocks):\n     def request_headers_and_sync(self, locator, hashstop=0):\n         self.clear_block_announcement()\n         self.get_headers(locator, hashstop)\n-        assert wait_until(self.received_block_announcement, timeout=30)\n+        wait_until(self.received_block_announcement, timeout=30, lock=mininode_lock)\n         self.clear_block_announcement()\n \n     # Block until a block announcement for a particular block hash is\n     # received.\n     def wait_for_block_announcement(self, block_hash, timeout=30):\n         def received_hash():\n             return (block_hash in self.announced_blockhashes)\n-        return wait_until(received_hash, timeout=timeout)\n+        wait_until(received_hash, timeout=timeout, lock=mininode_lock)\n \n     def send_await_disconnect(self, message, timeout=30):\n         \"\"\"Sends a message to the node and wait for disconnect.\n \n         This is used when we want to send a message into the node that we expect\n         will get us disconnected, eg an invalid block.\"\"\"\n         self.send_message(message)\n-        success = wait_until(lambda: not self.connected, timeout=timeout)\n-        if not success:\n-            logger.error(\"send_await_disconnect failed!\")\n-            raise AssertionError(\"send_await_disconnect failed!\")\n-        return success\n+        wait_until(lambda: not self.connected, timeout=timeout, lock=mininode_lock)\n \n class CompactBlocksTest(BitcoinTestFramework):\n     def __init__(self):\n@@ -150,9 +146,7 @@ def test_sendcmpct(self, node, test_node, preferred_version, old_node=None):\n         # Make sure we get a SENDCMPCT message from our peer\n         def received_sendcmpct():\n             return (len(test_node.last_sendcmpct) > 0)\n-        got_message = wait_until(received_sendcmpct, timeout=30)\n-        assert(received_sendcmpct())\n-        assert(got_message)\n+        wait_until(received_sendcmpct, timeout=30, lock=mininode_lock)\n         with mininode_lock:\n             # Check that the first version received is the preferred one\n             assert_equal(test_node.last_sendcmpct[0].version, preferred_version)\n@@ -167,7 +161,6 @@ def check_announcement_of_new_block(node, peer, predicate):\n             block_hash = int(node.generate(1)[0], 16)\n             peer.wait_for_block_announcement(block_hash, timeout=30)\n             assert(peer.block_announced)\n-            assert(got_message)\n \n             with mininode_lock:\n                 assert predicate(peer), (\n@@ -282,7 +275,7 @@ def test_compactblock_construction(self, node, test_node, version, use_witness_a\n \n         # Wait until we've seen the block announcement for the resulting tip\n         tip = int(node.getbestblockhash(), 16)\n-        assert(test_node.wait_for_block_announcement(tip))\n+        test_node.wait_for_block_announcement(tip)\n \n         # Make sure we will receive a fast-announce compact block\n         self.request_cb_announcements(test_node, node, version)\n@@ -297,8 +290,7 @@ def test_compactblock_construction(self, node, test_node, version, use_witness_a\n         block.rehash()\n \n         # Wait until the block was announced (via compact blocks)\n-        wait_until(test_node.received_block_announcement, timeout=30)\n-        assert(test_node.received_block_announcement())\n+        wait_until(test_node.received_block_announcement, timeout=30, lock=mininode_lock)\n \n         # Now fetch and check the compact block\n         header_and_shortids = None\n@@ -314,8 +306,7 @@ def test_compactblock_construction(self, node, test_node, version, use_witness_a\n             inv = CInv(4, block_hash)  # 4 == \"CompactBlock\"\n             test_node.send_message(msg_getdata([inv]))\n \n-        wait_until(test_node.received_block_announcement, timeout=30)\n-        assert(test_node.received_block_announcement())\n+        wait_until(test_node.received_block_announcement, timeout=30, lock=mininode_lock)\n \n         # Now fetch and check the compact block\n         header_and_shortids = None\n@@ -386,13 +377,11 @@ def test_compactblock_requests(self, node, test_node, version, segwit):\n \n             if announce == \"inv\":\n                 test_node.send_message(msg_inv([CInv(2, block.sha256)]))\n-                success = wait_until(lambda: \"getheaders\" in test_node.last_message, timeout=30)\n-                assert(success)\n+                wait_until(lambda: \"getheaders\" in test_node.last_message, timeout=30, lock=mininode_lock)\n                 test_node.send_header_for_blocks([block])\n             else:\n                 test_node.send_header_for_blocks([block])\n-            success = wait_until(lambda: \"getdata\" in test_node.last_message, timeout=30)\n-            assert(success)\n+            wait_until(lambda: \"getdata\" in test_node.last_message, timeout=30, lock=mininode_lock)\n             assert_equal(len(test_node.last_message[\"getdata\"].inv), 1)\n             assert_equal(test_node.last_message[\"getdata\"].inv[0].type, 4)\n             assert_equal(test_node.last_message[\"getdata\"].inv[0].hash, block.sha256)\n@@ -571,8 +560,7 @@ def test_incorrect_blocktxn_response(self, node, test_node, version):\n         assert_equal(int(node.getbestblockhash(), 16), block.hashPrevBlock)\n \n         # We should receive a getdata request\n-        success = wait_until(lambda: \"getdata\" in test_node.last_message, timeout=10)\n-        assert(success)\n+        wait_until(lambda: \"getdata\" in test_node.last_message, timeout=10, lock=mininode_lock)\n         assert_equal(len(test_node.last_message[\"getdata\"].inv), 1)\n         assert(test_node.last_message[\"getdata\"].inv[0].type == 2 or test_node.last_message[\"getdata\"].inv[0].type == 2|MSG_WITNESS_FLAG)\n         assert_equal(test_node.last_message[\"getdata\"].inv[0].hash, block.sha256)\n@@ -599,8 +587,7 @@ def test_getblocktxn_handler(self, node, test_node, version):\n             num_to_request = random.randint(1, len(block.vtx))\n             msg.block_txn_request.from_absolute(sorted(random.sample(range(len(block.vtx)), num_to_request)))\n             test_node.send_message(msg)\n-            success = wait_until(lambda: \"blocktxn\" in test_node.last_message, timeout=10)\n-            assert(success)\n+            wait_until(lambda: \"blocktxn\" in test_node.last_message, timeout=10, lock=mininode_lock)\n \n             [tx.calc_sha256() for tx in block.vtx]\n             with mininode_lock:\n@@ -639,22 +626,20 @@ def test_compactblocks_not_at_tip(self, node, test_node):\n         for i in range(MAX_CMPCTBLOCK_DEPTH + 1):\n             test_node.clear_block_announcement()\n             new_blocks.append(node.generate(1)[0])\n-            wait_until(test_node.received_block_announcement, timeout=30)\n+            wait_until(test_node.received_block_announcement, timeout=30, lock=mininode_lock)\n \n         test_node.clear_block_announcement()\n         test_node.send_message(msg_getdata([CInv(4, int(new_blocks[0], 16))]))\n-        success = wait_until(lambda: \"cmpctblock\" in test_node.last_message, timeout=30)\n-        assert(success)\n+        wait_until(lambda: \"cmpctblock\" in test_node.last_message, timeout=30, lock=mininode_lock)\n \n         test_node.clear_block_announcement()\n         node.generate(1)\n-        wait_until(test_node.received_block_announcement, timeout=30)\n+        wait_until(test_node.received_block_announcement, timeout=30, lock=mininode_lock)\n         test_node.clear_block_announcement()\n         with mininode_lock:\n             test_node.last_message.pop(\"block\", None)\n         test_node.send_message(msg_getdata([CInv(4, int(new_blocks[0], 16))]))\n-        success = wait_until(lambda: \"block\" in test_node.last_message, timeout=30)\n-        assert(success)\n+        wait_until(lambda: \"block\" in test_node.last_message, timeout=30, lock=mininode_lock)\n         with mininode_lock:\n             test_node.last_message[\"block\"].block.calc_sha256()\n             assert_equal(test_node.last_message[\"block\"].block.sha256, int(new_blocks[0], 16))\n@@ -705,7 +690,7 @@ def test_end_to_end_block_relay(self, node, listeners):\n         node.submitblock(ToHex(block))\n \n         for l in listeners:\n-            wait_until(lambda: l.received_block_announcement(), timeout=30)\n+            wait_until(lambda: l.received_block_announcement(), timeout=30, lock=mininode_lock)\n         with mininode_lock:\n             for l in listeners:\n                 assert \"cmpctblock\" in l.last_message"
      },
      {
        "sha": "f0d4d9a8b86cc0bcf1a8f78c6e0dc8e4255b38d8",
        "filename": "test/functional/p2p-leaktests.py",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/08ce33f8e95efa81b37ddc6b3350462c61bbfd51/test/functional/p2p-leaktests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/08ce33f8e95efa81b37ddc6b3350462c61bbfd51/test/functional/p2p-leaktests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-leaktests.py?ref=08ce33f8e95efa81b37ddc6b3350462c61bbfd51",
        "patch": "@@ -119,11 +119,11 @@ def run_test(self):\n \n         NetworkThread().start()  # Start up network handling in another thread\n \n-        assert wait_until(lambda: no_version_bannode.ever_connected, timeout=10)\n-        assert wait_until(lambda: no_version_idlenode.ever_connected, timeout=10)\n-        assert wait_until(lambda: no_verack_idlenode.version_received, timeout=10)\n-        assert wait_until(lambda: unsupported_service_bit5_node.ever_connected, timeout=10)\n-        assert wait_until(lambda: unsupported_service_bit7_node.ever_connected, timeout=10)\n+        wait_until(lambda: no_version_bannode.ever_connected, timeout=10, lock=mininode_lock)\n+        wait_until(lambda: no_version_idlenode.ever_connected, timeout=10, lock=mininode_lock)\n+        wait_until(lambda: no_verack_idlenode.version_received, timeout=10, lock=mininode_lock)\n+        wait_until(lambda: unsupported_service_bit5_node.ever_connected, timeout=10, lock=mininode_lock)\n+        wait_until(lambda: unsupported_service_bit7_node.ever_connected, timeout=10, lock=mininode_lock)\n \n         # Mine a block and make sure that it's not sent to the connected nodes\n         self.nodes[0].generate(1)\n@@ -158,8 +158,8 @@ def run_test(self):\n         allowed_service_bit5_node.add_connection(connections[5])\n         allowed_service_bit7_node.add_connection(connections[6])\n \n-        assert wait_until(lambda: allowed_service_bit5_node.message_count[\"verack\"], timeout=10)\n-        assert wait_until(lambda: allowed_service_bit7_node.message_count[\"verack\"], timeout=10)\n+        wait_until(lambda: allowed_service_bit5_node.message_count[\"verack\"], timeout=10, lock=mininode_lock)\n+        wait_until(lambda: allowed_service_bit7_node.message_count[\"verack\"], timeout=10, lock=mininode_lock)\n \n if __name__ == '__main__':\n     P2PLeakTest().main()"
      },
      {
        "sha": "6451b097c07d33e9022195eeac34c50b44355390",
        "filename": "test/functional/sendheaders.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/08ce33f8e95efa81b37ddc6b3350462c61bbfd51/test/functional/sendheaders.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/08ce33f8e95efa81b37ddc6b3350462c61bbfd51/test/functional/sendheaders.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/sendheaders.py?ref=08ce33f8e95efa81b37ddc6b3350462c61bbfd51",
        "patch": "@@ -128,7 +128,7 @@ def check_last_announcement(self, headers=None, inv=None):\n         expect_headers = headers if headers != None else []\n         expect_inv = inv if inv != None else []\n         test_function = lambda: self.block_announced\n-        assert(wait_until(test_function, timeout=60))\n+        wait_until(test_function, timeout=60, lock=mininode_lock)\n         with mininode_lock:\n             self.block_announced = False\n \n@@ -155,12 +155,12 @@ def wait_for_getdata(self, hash_list, timeout=60):\n             return\n \n         test_function = lambda: \"getdata\" in self.last_message and [x.hash for x in self.last_message[\"getdata\"].inv] == hash_list\n-        assert(wait_until(test_function, timeout=timeout))\n+        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n         return\n \n     def wait_for_block_announcement(self, block_hash, timeout=60):\n         test_function = lambda: self.last_blockhash_announced == block_hash\n-        assert(wait_until(test_function, timeout=timeout))\n+        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n         return\n \n     def send_header_for_blocks(self, new_blocks):"
      },
      {
        "sha": "bfbc0c3b034095e7ffb22a80e37748d318d63e0a",
        "filename": "test/functional/test_framework/comptool.py",
        "status": "modified",
        "additions": 5,
        "deletions": 7,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/08ce33f8e95efa81b37ddc6b3350462c61bbfd51/test/functional/test_framework/comptool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/08ce33f8e95efa81b37ddc6b3350462c61bbfd51/test/functional/test_framework/comptool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/comptool.py?ref=08ce33f8e95efa81b37ddc6b3350462c61bbfd51",
        "patch": "@@ -19,7 +19,7 @@\n \n from .mininode import *\n from .blockstore import BlockStore, TxStore\n-from .util import p2p_port\n+from .util import p2p_port, wait_until\n \n import logging\n \n@@ -189,15 +189,15 @@ def clear_all_connections(self):\n     def wait_for_disconnections(self):\n         def disconnected():\n             return all(node.closed for node in self.test_nodes)\n-        return wait_until(disconnected, timeout=10)\n+        wait_until(disconnected, timeout=10, lock=mininode_lock)\n \n     def wait_for_verack(self):\n         return all(node.wait_for_verack() for node in self.test_nodes)\n \n     def wait_for_pings(self, counter):\n         def received_pongs():\n             return all(node.received_ping_response(counter) for node in self.test_nodes)\n-        return wait_until(received_pongs)\n+        wait_until(received_pongs, lock=mininode_lock)\n \n     # sync_blocks: Wait for all connections to request the blockhash given\n     # then send get_headers to find out the tip of each node, and synchronize\n@@ -210,8 +210,7 @@ def blocks_requested():\n             )\n \n         # --> error if not requested\n-        if not wait_until(blocks_requested, attempts=20*num_blocks):\n-            raise AssertionError(\"Not all nodes requested block\")\n+        wait_until(blocks_requested, attempts=20*num_blocks, lock=mininode_lock)\n \n         # Send getheaders message\n         [ c.cb.send_getheaders() for c in self.connections ]\n@@ -231,8 +230,7 @@ def transaction_requested():\n             )\n \n         # --> error if not requested\n-        if not wait_until(transaction_requested, attempts=20*num_events):\n-            raise AssertionError(\"Not all nodes requested transaction\")\n+        wait_until(transaction_requested, attempts=20*num_events, lock=mininode_lock)\n \n         # Get the mempool\n         [ c.cb.send_mempool() for c in self.connections ]"
      },
      {
        "sha": "d0753276db2b61172a791b40bd3b6c6aac1ddfb4",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 8,
        "deletions": 25,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/08ce33f8e95efa81b37ddc6b3350462c61bbfd51/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/08ce33f8e95efa81b37ddc6b3350462c61bbfd51/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=08ce33f8e95efa81b37ddc6b3350462c61bbfd51",
        "patch": "@@ -35,7 +35,7 @@\n from threading import RLock, Thread\n \n from test_framework.siphash import siphash256\n-from test_framework.util import hex_str_to_bytes, bytes_to_hex_str\n+from test_framework.util import hex_str_to_bytes, bytes_to_hex_str, wait_until\n \n BIP0031_VERSION = 60000\n MY_VERSION = 70014  # past bip-31 for ping/pong\n@@ -1358,23 +1358,6 @@ def __repr__(self):\n         return \"msg_reject: %s %d %s [%064x]\" \\\n             % (self.message, self.code, self.reason, self.data)\n \n-# Helper function\n-def wait_until(predicate, *, attempts=float('inf'), timeout=float('inf')):\n-    if attempts == float('inf') and timeout == float('inf'):\n-        timeout = 60\n-    attempt = 0\n-    elapsed = 0\n-\n-    while attempt < attempts and elapsed < timeout:\n-        with mininode_lock:\n-            if predicate():\n-                return True\n-        attempt += 1\n-        elapsed += 0.05\n-        time.sleep(0.05)\n-\n-    return False\n-\n class msg_feefilter(object):\n     command = b\"feefilter\"\n \n@@ -1591,21 +1574,21 @@ def add_connection(self, conn):\n \n     def wait_for_disconnect(self, timeout=60):\n         test_function = lambda: not self.connected\n-        assert wait_until(test_function, timeout=timeout)\n+        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n \n     # Message receiving helper methods\n \n     def wait_for_block(self, blockhash, timeout=60):\n         test_function = lambda: self.last_message.get(\"block\") and self.last_message[\"block\"].block.rehash() == blockhash\n-        assert wait_until(test_function, timeout=timeout)\n+        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n \n     def wait_for_getdata(self, timeout=60):\n         test_function = lambda: self.last_message.get(\"getdata\")\n-        assert wait_until(test_function, timeout=timeout)\n+        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n \n     def wait_for_getheaders(self, timeout=60):\n         test_function = lambda: self.last_message.get(\"getheaders\")\n-        assert wait_until(test_function, timeout=timeout)\n+        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n \n     def wait_for_inv(self, expected_inv, timeout=60):\n         \"\"\"Waits for an INV message and checks that the first inv object in the message was as expected.\"\"\"\n@@ -1614,11 +1597,11 @@ def wait_for_inv(self, expected_inv, timeout=60):\n         test_function = lambda: self.last_message.get(\"inv\") and \\\n                                 self.last_message[\"inv\"].inv[0].type == expected_inv[0].type and \\\n                                 self.last_message[\"inv\"].inv[0].hash == expected_inv[0].hash\n-        assert wait_until(test_function, timeout=timeout)\n+        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n \n     def wait_for_verack(self, timeout=60):\n         test_function = lambda: self.message_count[\"verack\"]\n-        assert wait_until(test_function, timeout=timeout)\n+        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n \n     # Message sending helper functions\n \n@@ -1636,7 +1619,7 @@ def send_and_ping(self, message):\n     def sync_with_ping(self, timeout=60):\n         self.send_message(msg_ping(nonce=self.ping_counter))\n         test_function = lambda: self.last_message.get(\"pong\") and self.last_message[\"pong\"].nonce == self.ping_counter\n-        assert wait_until(test_function, timeout=timeout)\n+        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n         self.ping_counter += 1\n         return True\n "
      },
      {
        "sha": "a14cda07d0cbd7b23f1bb9ec9fe5cf94bff90895",
        "filename": "test/functional/test_framework/util.py",
        "status": "modified",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/08ce33f8e95efa81b37ddc6b3350462c61bbfd51/test/functional/test_framework/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/08ce33f8e95efa81b37ddc6b3350462c61bbfd51/test/functional/test_framework/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/util.py?ref=08ce33f8e95efa81b37ddc6b3350462c61bbfd51",
        "patch": "@@ -157,6 +157,28 @@ def str_to_b64str(string):\n def satoshi_round(amount):\n     return Decimal(amount).quantize(Decimal('0.00000001'), rounding=ROUND_DOWN)\n \n+def wait_until(predicate, *, attempts=float('inf'), timeout=float('inf'), lock=None):\n+    if attempts == float('inf') and timeout == float('inf'):\n+        timeout = 60\n+    attempt = 0\n+    timeout += time.time()\n+\n+    while attempt < attempts and time.time() < timeout:\n+        if lock:\n+            with lock:\n+                if predicate():\n+                    return\n+        else:\n+            if predicate():\n+                return\n+        attempt += 1\n+        time.sleep(0.05)\n+\n+    # Print the cause of the timeout\n+    assert_greater_than(attempts, attempt)\n+    assert_greater_than(timeout, time.time())\n+    raise RuntimeError('Unreachable')\n+\n # RPC/P2P connection constants and functions\n ############################################\n "
      }
    ]
  }
]