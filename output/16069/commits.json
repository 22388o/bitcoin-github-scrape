[
  {
    "sha": "fabf534b2de6a2a261dff704d6f2c980ef54f26f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYWJmNTM0YjJkZTZhMmEyNjFkZmY3MDRkNmYyYzk4MGVmNTRmMjZm",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2019-05-21T19:33:31Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2019-06-11T15:00:20Z"
      },
      "message": "test: Split large tests into smaller compile units",
      "tree": {
        "sha": "9cbe4226b4730442c9da5d8c73fe7672a8120815",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9cbe4226b4730442c9da5d8c73fe7672a8120815"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fabf534b2de6a2a261dff704d6f2c980ef54f26f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUgSsAv+JvfJ+wJ1juybwtBfcjKvJPZYTitJPLH/0FdH13+MONYcSljhba2PwRh/\na671T88OlAJ8n4TgeaTjKEKrA8PrC4HDHfeHH6C1rMnsN67YR6s7YRqyBb64xGn1\nypxIEsSfJLounqx8hZnFgyg/k5OgtYM0j1O0ujWGR8hl4LLUt66Ht0wQZCbMEvN7\npgnDAIwfS0ksjKfBvi4OqFIP+Wjf8/isGFKsG3EMA0KnmTU341itDIwOeUiRzhqi\nc12NPlb45iRngyuZF4C2NGHfBrH2WvkQOc4w3Dtl8g0S926REJF1oxS41pyxTAL5\nLG28AJcThpD6t4GhQAFAyMc6rRBEcJYctV9BWfmumxKtFvLi1L0eQBWOxmDNND/S\n6f+OeaClrK/oBhWfmbTCz670VLqcLnuIaiCzeyU1Ew0NSOIFXFftkwJe6fFLMUT2\nwKo8L94l2/4uLrLXMULj6KLCOl27SR9+pkJAr4Gf30nbBXfmT7MrCu4lJS8w9j7Z\naN424CWl\n=QJ8b\n-----END PGP SIGNATURE-----",
        "payload": "tree 9cbe4226b4730442c9da5d8c73fe7672a8120815\nparent 8a503a6c6dd419921373f45d7aa6f1787c9b8884\nauthor MarcoFalke <falke.marco@gmail.com> 1558467211 -0400\ncommitter MarcoFalke <falke.marco@gmail.com> 1560265220 -0400\n\ntest: Split large tests into smaller compile units\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fabf534b2de6a2a261dff704d6f2c980ef54f26f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fabf534b2de6a2a261dff704d6f2c980ef54f26f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fabf534b2de6a2a261dff704d6f2c980ef54f26f/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8a503a6c6dd419921373f45d7aa6f1787c9b8884",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8a503a6c6dd419921373f45d7aa6f1787c9b8884",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8a503a6c6dd419921373f45d7aa6f1787c9b8884"
      }
    ],
    "stats": {
      "total": 2903,
      "additions": 1484,
      "deletions": 1419
    },
    "files": [
      {
        "sha": "7ea7694867d528ba36f072a7e6379959bc7b2a93",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fabf534b2de6a2a261dff704d6f2c980ef54f26f/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fabf534b2de6a2a261dff704d6f2c980ef54f26f/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=fabf534b2de6a2a261dff704d6f2c980ef54f26f",
        "patch": "@@ -84,6 +84,7 @@ BITCOIN_TESTS =\\\n   test/addrman_tests.cpp \\\n   test/amount_tests.cpp \\\n   test/allocator_tests.cpp \\\n+  test/args_tests.cpp \\\n   test/base32_tests.cpp \\\n   test/base58_tests.cpp \\\n   test/base64_tests.cpp \\\n@@ -129,6 +130,7 @@ BITCOIN_TESTS =\\\n   test/rpc_tests.cpp \\\n   test/sanity_tests.cpp \\\n   test/scheduler_tests.cpp \\\n+  test/script_eval_tests.cpp \\\n   test/script_p2sh_tests.cpp \\\n   test/script_tests.cpp \\\n   test/script_standard_tests.cpp \\"
      },
      {
        "sha": "b9ea3de0e0ab36e43b63308d3ef70f2a8283ff9c",
        "filename": "src/test/args_tests.cpp",
        "status": "added",
        "additions": 760,
        "deletions": 0,
        "changes": 760,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fabf534b2de6a2a261dff704d6f2c980ef54f26f/src/test/args_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fabf534b2de6a2a261dff704d6f2c980ef54f26f/src/test/args_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/args_tests.cpp?ref=fabf534b2de6a2a261dff704d6f2c980ef54f26f",
        "patch": "@@ -0,0 +1,760 @@\n+// Copyright (c) 2011-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <test/setup_common.h>\n+#include <test/util.h>\n+#include <util/system.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(args_tests, BasicTestingSetup)\n+\n+struct TestArgsManager : public ArgsManager\n+{\n+    TestArgsManager() { m_network_only_args.clear(); }\n+    std::map<std::string, std::vector<std::string> >& GetOverrideArgs() { return m_override_args; }\n+    std::map<std::string, std::vector<std::string> >& GetConfigArgs() { return m_config_args; }\n+    void ReadConfigString(const std::string str_config)\n+    {\n+        std::istringstream streamConfig(str_config);\n+        {\n+            LOCK(cs_args);\n+            m_config_args.clear();\n+            m_config_sections.clear();\n+        }\n+        std::string error;\n+        BOOST_REQUIRE(ReadConfigStream(streamConfig, \"\", error));\n+    }\n+    void SetNetworkOnlyArg(const std::string arg)\n+    {\n+        LOCK(cs_args);\n+        m_network_only_args.insert(arg);\n+    }\n+    void SetupArgs(int argv, const char* args[])\n+    {\n+        for (int i = 0; i < argv; ++i) {\n+            AddArg(args[i], \"\", false, OptionsCategory::OPTIONS);\n+        }\n+    }\n+    using ArgsManager::ReadConfigStream;\n+    using ArgsManager::cs_args;\n+    using ArgsManager::m_network;\n+};\n+\n+BOOST_AUTO_TEST_CASE(util_ParseParameters)\n+{\n+    TestArgsManager testArgs;\n+    const char* avail_args[] = {\"-a\", \"-b\", \"-ccc\", \"-d\"};\n+    const char *argv_test[] = {\"-ignored\", \"-a\", \"-b\", \"-ccc=argument\", \"-ccc=multiple\", \"f\", \"-d=e\"};\n+\n+    std::string error;\n+    testArgs.SetupArgs(4, avail_args);\n+    BOOST_CHECK(testArgs.ParseParameters(0, (char**)argv_test, error));\n+    BOOST_CHECK(testArgs.GetOverrideArgs().empty() && testArgs.GetConfigArgs().empty());\n+\n+    BOOST_CHECK(testArgs.ParseParameters(1, (char**)argv_test, error));\n+    BOOST_CHECK(testArgs.GetOverrideArgs().empty() && testArgs.GetConfigArgs().empty());\n+\n+    BOOST_CHECK(testArgs.ParseParameters(7, (char**)argv_test, error));\n+    // expectation: -ignored is ignored (program name argument),\n+    // -a, -b and -ccc end up in map, -d ignored because it is after\n+    // a non-option argument (non-GNU option parsing)\n+    BOOST_CHECK(testArgs.GetOverrideArgs().size() == 3 && testArgs.GetConfigArgs().empty());\n+    BOOST_CHECK(testArgs.IsArgSet(\"-a\") && testArgs.IsArgSet(\"-b\") && testArgs.IsArgSet(\"-ccc\")\n+                && !testArgs.IsArgSet(\"f\") && !testArgs.IsArgSet(\"-d\"));\n+    BOOST_CHECK(testArgs.GetOverrideArgs().count(\"-a\") && testArgs.GetOverrideArgs().count(\"-b\") && testArgs.GetOverrideArgs().count(\"-ccc\")\n+                && !testArgs.GetOverrideArgs().count(\"f\") && !testArgs.GetOverrideArgs().count(\"-d\"));\n+\n+    BOOST_CHECK(testArgs.GetOverrideArgs()[\"-a\"].size() == 1);\n+    BOOST_CHECK(testArgs.GetOverrideArgs()[\"-a\"].front() == \"\");\n+    BOOST_CHECK(testArgs.GetOverrideArgs()[\"-ccc\"].size() == 2);\n+    BOOST_CHECK(testArgs.GetOverrideArgs()[\"-ccc\"].front() == \"argument\");\n+    BOOST_CHECK(testArgs.GetOverrideArgs()[\"-ccc\"].back() == \"multiple\");\n+    BOOST_CHECK(testArgs.GetArgs(\"-ccc\").size() == 2);\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_GetBoolArg)\n+{\n+    TestArgsManager testArgs;\n+    const char* avail_args[] = {\"-a\", \"-b\", \"-c\", \"-d\", \"-e\", \"-f\"};\n+    const char *argv_test[] = {\n+        \"ignored\", \"-a\", \"-nob\", \"-c=0\", \"-d=1\", \"-e=false\", \"-f=true\"};\n+    std::string error;\n+    testArgs.SetupArgs(6, avail_args);\n+    BOOST_CHECK(testArgs.ParseParameters(7, (char**)argv_test, error));\n+\n+    // Each letter should be set.\n+    for (const char opt : \"abcdef\")\n+        BOOST_CHECK(testArgs.IsArgSet({'-', opt}) || !opt);\n+\n+    // Nothing else should be in the map\n+    BOOST_CHECK(testArgs.GetOverrideArgs().size() == 6 &&\n+                testArgs.GetConfigArgs().empty());\n+\n+    // The -no prefix should get stripped on the way in.\n+    BOOST_CHECK(!testArgs.IsArgSet(\"-nob\"));\n+\n+    // The -b option is flagged as negated, and nothing else is\n+    BOOST_CHECK(testArgs.IsArgNegated(\"-b\"));\n+    BOOST_CHECK(!testArgs.IsArgNegated(\"-a\"));\n+\n+    // Check expected values.\n+    BOOST_CHECK(testArgs.GetBoolArg(\"-a\", false) == true);\n+    BOOST_CHECK(testArgs.GetBoolArg(\"-b\", true) == false);\n+    BOOST_CHECK(testArgs.GetBoolArg(\"-c\", true) == false);\n+    BOOST_CHECK(testArgs.GetBoolArg(\"-d\", false) == true);\n+    BOOST_CHECK(testArgs.GetBoolArg(\"-e\", true) == false);\n+    BOOST_CHECK(testArgs.GetBoolArg(\"-f\", true) == false);\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_GetBoolArgEdgeCases)\n+{\n+    // Test some awful edge cases that hopefully no user will ever exercise.\n+    TestArgsManager testArgs;\n+\n+    // Params test\n+    const char* avail_args[] = {\"-foo\", \"-bar\"};\n+    const char *argv_test[] = {\"ignored\", \"-nofoo\", \"-foo\", \"-nobar=0\"};\n+    testArgs.SetupArgs(2, avail_args);\n+    std::string error;\n+    BOOST_CHECK(testArgs.ParseParameters(4, (char**)argv_test, error));\n+\n+    // This was passed twice, second one overrides the negative setting.\n+    BOOST_CHECK(!testArgs.IsArgNegated(\"-foo\"));\n+    BOOST_CHECK(testArgs.GetArg(\"-foo\", \"xxx\") == \"\");\n+\n+    // A double negative is a positive, and not marked as negated.\n+    BOOST_CHECK(!testArgs.IsArgNegated(\"-bar\"));\n+    BOOST_CHECK(testArgs.GetArg(\"-bar\", \"xxx\") == \"1\");\n+\n+    // Config test\n+    const char *conf_test = \"nofoo=1\\nfoo=1\\nnobar=0\\n\";\n+    BOOST_CHECK(testArgs.ParseParameters(1, (char**)argv_test, error));\n+    testArgs.ReadConfigString(conf_test);\n+\n+    // This was passed twice, second one overrides the negative setting,\n+    // and the value.\n+    BOOST_CHECK(!testArgs.IsArgNegated(\"-foo\"));\n+    BOOST_CHECK(testArgs.GetArg(\"-foo\", \"xxx\") == \"1\");\n+\n+    // A double negative is a positive, and does not count as negated.\n+    BOOST_CHECK(!testArgs.IsArgNegated(\"-bar\"));\n+    BOOST_CHECK(testArgs.GetArg(\"-bar\", \"xxx\") == \"1\");\n+\n+    // Combined test\n+    const char *combo_test_args[] = {\"ignored\", \"-nofoo\", \"-bar\"};\n+    const char *combo_test_conf = \"foo=1\\nnobar=1\\n\";\n+    BOOST_CHECK(testArgs.ParseParameters(3, (char**)combo_test_args, error));\n+    testArgs.ReadConfigString(combo_test_conf);\n+\n+    // Command line overrides, but doesn't erase old setting\n+    BOOST_CHECK(testArgs.IsArgNegated(\"-foo\"));\n+    BOOST_CHECK(testArgs.GetArg(\"-foo\", \"xxx\") == \"0\");\n+    BOOST_CHECK(testArgs.GetArgs(\"-foo\").size() == 0);\n+\n+    // Command line overrides, but doesn't erase old setting\n+    BOOST_CHECK(!testArgs.IsArgNegated(\"-bar\"));\n+    BOOST_CHECK(testArgs.GetArg(\"-bar\", \"xxx\") == \"\");\n+    BOOST_CHECK(testArgs.GetArgs(\"-bar\").size() == 1\n+                && testArgs.GetArgs(\"-bar\").front() == \"\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_ReadConfigStream)\n+{\n+    const char *str_config =\n+       \"a=\\n\"\n+       \"b=1\\n\"\n+       \"ccc=argument\\n\"\n+       \"ccc=multiple\\n\"\n+       \"d=e\\n\"\n+       \"nofff=1\\n\"\n+       \"noggg=0\\n\"\n+       \"h=1\\n\"\n+       \"noh=1\\n\"\n+       \"noi=1\\n\"\n+       \"i=1\\n\"\n+       \"sec1.ccc=extend1\\n\"\n+       \"\\n\"\n+       \"[sec1]\\n\"\n+       \"ccc=extend2\\n\"\n+       \"d=eee\\n\"\n+       \"h=1\\n\"\n+       \"[sec2]\\n\"\n+       \"ccc=extend3\\n\"\n+       \"iii=2\\n\";\n+\n+    TestArgsManager test_args;\n+    const char* avail_args[] = {\"-a\", \"-b\", \"-ccc\", \"-d\", \"-e\", \"-fff\", \"-ggg\", \"-h\", \"-i\", \"-iii\"};\n+    test_args.SetupArgs(10, avail_args);\n+\n+    test_args.ReadConfigString(str_config);\n+    // expectation: a, b, ccc, d, fff, ggg, h, i end up in map\n+    // so do sec1.ccc, sec1.d, sec1.h, sec2.ccc, sec2.iii\n+\n+    BOOST_CHECK(test_args.GetOverrideArgs().empty());\n+    BOOST_CHECK(test_args.GetConfigArgs().size() == 13);\n+\n+    BOOST_CHECK(test_args.GetConfigArgs().count(\"-a\")\n+                && test_args.GetConfigArgs().count(\"-b\")\n+                && test_args.GetConfigArgs().count(\"-ccc\")\n+                && test_args.GetConfigArgs().count(\"-d\")\n+                && test_args.GetConfigArgs().count(\"-fff\")\n+                && test_args.GetConfigArgs().count(\"-ggg\")\n+                && test_args.GetConfigArgs().count(\"-h\")\n+                && test_args.GetConfigArgs().count(\"-i\")\n+               );\n+    BOOST_CHECK(test_args.GetConfigArgs().count(\"-sec1.ccc\")\n+                && test_args.GetConfigArgs().count(\"-sec1.h\")\n+                && test_args.GetConfigArgs().count(\"-sec2.ccc\")\n+                && test_args.GetConfigArgs().count(\"-sec2.iii\")\n+               );\n+\n+    BOOST_CHECK(test_args.IsArgSet(\"-a\")\n+                && test_args.IsArgSet(\"-b\")\n+                && test_args.IsArgSet(\"-ccc\")\n+                && test_args.IsArgSet(\"-d\")\n+                && test_args.IsArgSet(\"-fff\")\n+                && test_args.IsArgSet(\"-ggg\")\n+                && test_args.IsArgSet(\"-h\")\n+                && test_args.IsArgSet(\"-i\")\n+                && !test_args.IsArgSet(\"-zzz\")\n+                && !test_args.IsArgSet(\"-iii\")\n+               );\n+\n+    BOOST_CHECK(test_args.GetArg(\"-a\", \"xxx\") == \"\"\n+                && test_args.GetArg(\"-b\", \"xxx\") == \"1\"\n+                && test_args.GetArg(\"-ccc\", \"xxx\") == \"argument\"\n+                && test_args.GetArg(\"-d\", \"xxx\") == \"e\"\n+                && test_args.GetArg(\"-fff\", \"xxx\") == \"0\"\n+                && test_args.GetArg(\"-ggg\", \"xxx\") == \"1\"\n+                && test_args.GetArg(\"-h\", \"xxx\") == \"0\"\n+                && test_args.GetArg(\"-i\", \"xxx\") == \"1\"\n+                && test_args.GetArg(\"-zzz\", \"xxx\") == \"xxx\"\n+                && test_args.GetArg(\"-iii\", \"xxx\") == \"xxx\"\n+               );\n+\n+    for (const bool def : {false, true}) {\n+        BOOST_CHECK(test_args.GetBoolArg(\"-a\", def)\n+                     && test_args.GetBoolArg(\"-b\", def)\n+                     && !test_args.GetBoolArg(\"-ccc\", def)\n+                     && !test_args.GetBoolArg(\"-d\", def)\n+                     && !test_args.GetBoolArg(\"-fff\", def)\n+                     && test_args.GetBoolArg(\"-ggg\", def)\n+                     && !test_args.GetBoolArg(\"-h\", def)\n+                     && test_args.GetBoolArg(\"-i\", def)\n+                     && test_args.GetBoolArg(\"-zzz\", def) == def\n+                     && test_args.GetBoolArg(\"-iii\", def) == def\n+                   );\n+    }\n+\n+    BOOST_CHECK(test_args.GetArgs(\"-a\").size() == 1\n+                && test_args.GetArgs(\"-a\").front() == \"\");\n+    BOOST_CHECK(test_args.GetArgs(\"-b\").size() == 1\n+                && test_args.GetArgs(\"-b\").front() == \"1\");\n+    BOOST_CHECK(test_args.GetArgs(\"-ccc\").size() == 2\n+                && test_args.GetArgs(\"-ccc\").front() == \"argument\"\n+                && test_args.GetArgs(\"-ccc\").back() == \"multiple\");\n+    BOOST_CHECK(test_args.GetArgs(\"-fff\").size() == 0);\n+    BOOST_CHECK(test_args.GetArgs(\"-nofff\").size() == 0);\n+    BOOST_CHECK(test_args.GetArgs(\"-ggg\").size() == 1\n+                && test_args.GetArgs(\"-ggg\").front() == \"1\");\n+    BOOST_CHECK(test_args.GetArgs(\"-noggg\").size() == 0);\n+    BOOST_CHECK(test_args.GetArgs(\"-h\").size() == 0);\n+    BOOST_CHECK(test_args.GetArgs(\"-noh\").size() == 0);\n+    BOOST_CHECK(test_args.GetArgs(\"-i\").size() == 1\n+                && test_args.GetArgs(\"-i\").front() == \"1\");\n+    BOOST_CHECK(test_args.GetArgs(\"-noi\").size() == 0);\n+    BOOST_CHECK(test_args.GetArgs(\"-zzz\").size() == 0);\n+\n+    BOOST_CHECK(!test_args.IsArgNegated(\"-a\"));\n+    BOOST_CHECK(!test_args.IsArgNegated(\"-b\"));\n+    BOOST_CHECK(!test_args.IsArgNegated(\"-ccc\"));\n+    BOOST_CHECK(!test_args.IsArgNegated(\"-d\"));\n+    BOOST_CHECK(test_args.IsArgNegated(\"-fff\"));\n+    BOOST_CHECK(!test_args.IsArgNegated(\"-ggg\"));\n+    BOOST_CHECK(test_args.IsArgNegated(\"-h\")); // last setting takes precedence\n+    BOOST_CHECK(!test_args.IsArgNegated(\"-i\")); // last setting takes precedence\n+    BOOST_CHECK(!test_args.IsArgNegated(\"-zzz\"));\n+\n+    // Test sections work\n+    test_args.SelectConfigNetwork(\"sec1\");\n+\n+    // same as original\n+    BOOST_CHECK(test_args.GetArg(\"-a\", \"xxx\") == \"\"\n+                && test_args.GetArg(\"-b\", \"xxx\") == \"1\"\n+                && test_args.GetArg(\"-fff\", \"xxx\") == \"0\"\n+                && test_args.GetArg(\"-ggg\", \"xxx\") == \"1\"\n+                && test_args.GetArg(\"-zzz\", \"xxx\") == \"xxx\"\n+                && test_args.GetArg(\"-iii\", \"xxx\") == \"xxx\"\n+               );\n+    // d is overridden\n+    BOOST_CHECK(test_args.GetArg(\"-d\", \"xxx\") == \"eee\");\n+    // section-specific setting\n+    BOOST_CHECK(test_args.GetArg(\"-h\", \"xxx\") == \"1\");\n+    // section takes priority for multiple values\n+    BOOST_CHECK(test_args.GetArg(\"-ccc\", \"xxx\") == \"extend1\");\n+    // check multiple values works\n+    const std::vector<std::string> sec1_ccc_expected = {\"extend1\",\"extend2\",\"argument\",\"multiple\"};\n+    const auto& sec1_ccc_res = test_args.GetArgs(\"-ccc\");\n+    BOOST_CHECK_EQUAL_COLLECTIONS(sec1_ccc_res.begin(), sec1_ccc_res.end(), sec1_ccc_expected.begin(), sec1_ccc_expected.end());\n+\n+    test_args.SelectConfigNetwork(\"sec2\");\n+\n+    // same as original\n+    BOOST_CHECK(test_args.GetArg(\"-a\", \"xxx\") == \"\"\n+                && test_args.GetArg(\"-b\", \"xxx\") == \"1\"\n+                && test_args.GetArg(\"-d\", \"xxx\") == \"e\"\n+                && test_args.GetArg(\"-fff\", \"xxx\") == \"0\"\n+                && test_args.GetArg(\"-ggg\", \"xxx\") == \"1\"\n+                && test_args.GetArg(\"-zzz\", \"xxx\") == \"xxx\"\n+                && test_args.GetArg(\"-h\", \"xxx\") == \"0\"\n+               );\n+    // section-specific setting\n+    BOOST_CHECK(test_args.GetArg(\"-iii\", \"xxx\") == \"2\");\n+    // section takes priority for multiple values\n+    BOOST_CHECK(test_args.GetArg(\"-ccc\", \"xxx\") == \"extend3\");\n+    // check multiple values works\n+    const std::vector<std::string> sec2_ccc_expected = {\"extend3\",\"argument\",\"multiple\"};\n+    const auto& sec2_ccc_res = test_args.GetArgs(\"-ccc\");\n+    BOOST_CHECK_EQUAL_COLLECTIONS(sec2_ccc_res.begin(), sec2_ccc_res.end(), sec2_ccc_expected.begin(), sec2_ccc_expected.end());\n+\n+    // Test section only options\n+\n+    test_args.SetNetworkOnlyArg(\"-d\");\n+    test_args.SetNetworkOnlyArg(\"-ccc\");\n+    test_args.SetNetworkOnlyArg(\"-h\");\n+\n+    test_args.SelectConfigNetwork(CBaseChainParams::MAIN);\n+    BOOST_CHECK(test_args.GetArg(\"-d\", \"xxx\") == \"e\");\n+    BOOST_CHECK(test_args.GetArgs(\"-ccc\").size() == 2);\n+    BOOST_CHECK(test_args.GetArg(\"-h\", \"xxx\") == \"0\");\n+\n+    test_args.SelectConfigNetwork(\"sec1\");\n+    BOOST_CHECK(test_args.GetArg(\"-d\", \"xxx\") == \"eee\");\n+    BOOST_CHECK(test_args.GetArgs(\"-d\").size() == 1);\n+    BOOST_CHECK(test_args.GetArgs(\"-ccc\").size() == 2);\n+    BOOST_CHECK(test_args.GetArg(\"-h\", \"xxx\") == \"1\");\n+\n+    test_args.SelectConfigNetwork(\"sec2\");\n+    BOOST_CHECK(test_args.GetArg(\"-d\", \"xxx\") == \"xxx\");\n+    BOOST_CHECK(test_args.GetArgs(\"-d\").size() == 0);\n+    BOOST_CHECK(test_args.GetArgs(\"-ccc\").size() == 1);\n+    BOOST_CHECK(test_args.GetArg(\"-h\", \"xxx\") == \"0\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_GetArg)\n+{\n+    TestArgsManager testArgs;\n+    testArgs.GetOverrideArgs().clear();\n+    testArgs.GetOverrideArgs()[\"strtest1\"] = {\"string...\"};\n+    // strtest2 undefined on purpose\n+    testArgs.GetOverrideArgs()[\"inttest1\"] = {\"12345\"};\n+    testArgs.GetOverrideArgs()[\"inttest2\"] = {\"81985529216486895\"};\n+    // inttest3 undefined on purpose\n+    testArgs.GetOverrideArgs()[\"booltest1\"] = {\"\"};\n+    // booltest2 undefined on purpose\n+    testArgs.GetOverrideArgs()[\"booltest3\"] = {\"0\"};\n+    testArgs.GetOverrideArgs()[\"booltest4\"] = {\"1\"};\n+\n+    // priorities\n+    testArgs.GetOverrideArgs()[\"pritest1\"] = {\"a\", \"b\"};\n+    testArgs.GetConfigArgs()[\"pritest2\"] = {\"a\", \"b\"};\n+    testArgs.GetOverrideArgs()[\"pritest3\"] = {\"a\"};\n+    testArgs.GetConfigArgs()[\"pritest3\"] = {\"b\"};\n+    testArgs.GetOverrideArgs()[\"pritest4\"] = {\"a\",\"b\"};\n+    testArgs.GetConfigArgs()[\"pritest4\"] = {\"c\",\"d\"};\n+\n+    BOOST_CHECK_EQUAL(testArgs.GetArg(\"strtest1\", \"default\"), \"string...\");\n+    BOOST_CHECK_EQUAL(testArgs.GetArg(\"strtest2\", \"default\"), \"default\");\n+    BOOST_CHECK_EQUAL(testArgs.GetArg(\"inttest1\", -1), 12345);\n+    BOOST_CHECK_EQUAL(testArgs.GetArg(\"inttest2\", -1), 81985529216486895LL);\n+    BOOST_CHECK_EQUAL(testArgs.GetArg(\"inttest3\", -1), -1);\n+    BOOST_CHECK_EQUAL(testArgs.GetBoolArg(\"booltest1\", false), true);\n+    BOOST_CHECK_EQUAL(testArgs.GetBoolArg(\"booltest2\", false), false);\n+    BOOST_CHECK_EQUAL(testArgs.GetBoolArg(\"booltest3\", false), false);\n+    BOOST_CHECK_EQUAL(testArgs.GetBoolArg(\"booltest4\", false), true);\n+\n+    BOOST_CHECK_EQUAL(testArgs.GetArg(\"pritest1\", \"default\"), \"b\");\n+    BOOST_CHECK_EQUAL(testArgs.GetArg(\"pritest2\", \"default\"), \"a\");\n+    BOOST_CHECK_EQUAL(testArgs.GetArg(\"pritest3\", \"default\"), \"a\");\n+    BOOST_CHECK_EQUAL(testArgs.GetArg(\"pritest4\", \"default\"), \"b\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_GetChainName)\n+{\n+    TestArgsManager test_args;\n+    const char* avail_args[] = {\"-testnet\", \"-regtest\"};\n+    test_args.SetupArgs(2, avail_args);\n+\n+    const char* argv_testnet[] = {\"cmd\", \"-testnet\"};\n+    const char* argv_regtest[] = {\"cmd\", \"-regtest\"};\n+    const char* argv_test_no_reg[] = {\"cmd\", \"-testnet\", \"-noregtest\"};\n+    const char* argv_both[] = {\"cmd\", \"-testnet\", \"-regtest\"};\n+\n+    // equivalent to \"-testnet\"\n+    // regtest in testnet section is ignored\n+    const char* testnetconf = \"testnet=1\\nregtest=0\\n[test]\\nregtest=1\";\n+    std::string error;\n+\n+    BOOST_CHECK(test_args.ParseParameters(0, (char**)argv_testnet, error));\n+    BOOST_CHECK_EQUAL(test_args.GetChainName(), \"main\");\n+\n+    BOOST_CHECK(test_args.ParseParameters(2, (char**)argv_testnet, error));\n+    BOOST_CHECK_EQUAL(test_args.GetChainName(), \"test\");\n+\n+    BOOST_CHECK(test_args.ParseParameters(2, (char**)argv_regtest, error));\n+    BOOST_CHECK_EQUAL(test_args.GetChainName(), \"regtest\");\n+\n+    BOOST_CHECK(test_args.ParseParameters(3, (char**)argv_test_no_reg, error));\n+    BOOST_CHECK_EQUAL(test_args.GetChainName(), \"test\");\n+\n+    BOOST_CHECK(test_args.ParseParameters(3, (char**)argv_both, error));\n+    BOOST_CHECK_THROW(test_args.GetChainName(), std::runtime_error);\n+\n+    BOOST_CHECK(test_args.ParseParameters(0, (char**)argv_testnet, error));\n+    test_args.ReadConfigString(testnetconf);\n+    BOOST_CHECK_EQUAL(test_args.GetChainName(), \"test\");\n+\n+    BOOST_CHECK(test_args.ParseParameters(2, (char**)argv_testnet, error));\n+    test_args.ReadConfigString(testnetconf);\n+    BOOST_CHECK_EQUAL(test_args.GetChainName(), \"test\");\n+\n+    BOOST_CHECK(test_args.ParseParameters(2, (char**)argv_regtest, error));\n+    test_args.ReadConfigString(testnetconf);\n+    BOOST_CHECK_THROW(test_args.GetChainName(), std::runtime_error);\n+\n+    BOOST_CHECK(test_args.ParseParameters(3, (char**)argv_test_no_reg, error));\n+    test_args.ReadConfigString(testnetconf);\n+    BOOST_CHECK_EQUAL(test_args.GetChainName(), \"test\");\n+\n+    BOOST_CHECK(test_args.ParseParameters(3, (char**)argv_both, error));\n+    test_args.ReadConfigString(testnetconf);\n+    BOOST_CHECK_THROW(test_args.GetChainName(), std::runtime_error);\n+\n+    // check setting the network to test (and thus making\n+    // [test] regtest=1 potentially relevant) doesn't break things\n+    test_args.SelectConfigNetwork(\"test\");\n+\n+    BOOST_CHECK(test_args.ParseParameters(0, (char**)argv_testnet, error));\n+    test_args.ReadConfigString(testnetconf);\n+    BOOST_CHECK_EQUAL(test_args.GetChainName(), \"test\");\n+\n+    BOOST_CHECK(test_args.ParseParameters(2, (char**)argv_testnet, error));\n+    test_args.ReadConfigString(testnetconf);\n+    BOOST_CHECK_EQUAL(test_args.GetChainName(), \"test\");\n+\n+    BOOST_CHECK(test_args.ParseParameters(2, (char**)argv_regtest, error));\n+    test_args.ReadConfigString(testnetconf);\n+    BOOST_CHECK_THROW(test_args.GetChainName(), std::runtime_error);\n+\n+    BOOST_CHECK(test_args.ParseParameters(2, (char**)argv_test_no_reg, error));\n+    test_args.ReadConfigString(testnetconf);\n+    BOOST_CHECK_EQUAL(test_args.GetChainName(), \"test\");\n+\n+    BOOST_CHECK(test_args.ParseParameters(3, (char**)argv_both, error));\n+    test_args.ReadConfigString(testnetconf);\n+    BOOST_CHECK_THROW(test_args.GetChainName(), std::runtime_error);\n+}\n+\n+// Test different ways settings can be merged, and verify results. This test can\n+// be used to confirm that updates to settings code don't change behavior\n+// unintentionally.\n+//\n+// The test covers:\n+//\n+// - Combining different setting actions. Possible actions are: configuring a\n+//   setting, negating a setting (adding \"-no\" prefix), and configuring/negating\n+//   settings in a network section (adding \"main.\" or \"test.\" prefixes).\n+//\n+// - Combining settings from command line arguments and a config file.\n+//\n+// - Combining SoftSet and ForceSet calls.\n+//\n+// - Testing \"main\" and \"test\" network values to make sure settings from network\n+//   sections are applied and to check for mainnet-specific behaviors like\n+//   inheriting settings from the default section.\n+//\n+// - Testing network-specific settings like \"-wallet\", that may be ignored\n+//   outside a network section, and non-network specific settings like \"-server\"\n+//   that aren't sensitive to the network.\n+//\n+struct ArgsMergeTestingSetup : public BasicTestingSetup {\n+    //! Max number of actions to sequence together. Can decrease this when\n+    //! debugging to make test results easier to understand.\n+    static constexpr int MAX_ACTIONS = 3;\n+\n+    enum Action { NONE, SET, NEGATE, SECTION_SET, SECTION_NEGATE };\n+    using ActionList = Action[MAX_ACTIONS];\n+\n+    //! Enumerate all possible test configurations.\n+    template <typename Fn>\n+    void ForEachMergeSetup(Fn&& fn)\n+    {\n+        ActionList arg_actions = {};\n+        ForEachNoDup(arg_actions, SET, SECTION_NEGATE, [&] {\n+            ActionList conf_actions = {};\n+            ForEachNoDup(conf_actions, SET, SECTION_NEGATE, [&] {\n+                for (bool soft_set : {false, true}) {\n+                    for (bool force_set : {false, true}) {\n+                        for (const std::string& section : {CBaseChainParams::MAIN, CBaseChainParams::TESTNET}) {\n+                            for (const std::string& network : {CBaseChainParams::MAIN, CBaseChainParams::TESTNET}) {\n+                                for (bool net_specific : {false, true}) {\n+                                    fn(arg_actions, conf_actions, soft_set, force_set, section, network, net_specific);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            });\n+        });\n+    }\n+\n+    //! Translate actions into a list of <key>=<value> setting strings.\n+    std::vector<std::string> GetValues(const ActionList& actions,\n+        const std::string& section,\n+        const std::string& name,\n+        const std::string& value_prefix)\n+    {\n+        std::vector<std::string> values;\n+        int suffix = 0;\n+        for (Action action : actions) {\n+            if (action == NONE) break;\n+            std::string prefix;\n+            if (action == SECTION_SET || action == SECTION_NEGATE) prefix = section + \".\";\n+            if (action == SET || action == SECTION_SET) {\n+                for (int i = 0; i < 2; ++i) {\n+                    values.push_back(prefix + name + \"=\" + value_prefix + std::to_string(++suffix));\n+                }\n+            }\n+            if (action == NEGATE || action == SECTION_NEGATE) {\n+                values.push_back(prefix + \"no\" + name + \"=1\");\n+            }\n+        }\n+        return values;\n+    }\n+};\n+\n+// Regression test covering different ways config settings can be merged. The\n+// test parses and merges settings, representing the results as strings that get\n+// compared against an expected hash. To debug, the result strings can be dumped\n+// to a file (see comments below).\n+BOOST_FIXTURE_TEST_CASE(util_ArgsMerge, ArgsMergeTestingSetup)\n+{\n+    CHash256 out_sha;\n+    FILE* out_file = nullptr;\n+    if (const char* out_path = getenv(\"ARGS_MERGE_TEST_OUT\")) {\n+        out_file = fsbridge::fopen(out_path, \"w\");\n+        if (!out_file) throw std::system_error(errno, std::generic_category(), \"fopen failed\");\n+    }\n+\n+    ForEachMergeSetup([&](const ActionList& arg_actions, const ActionList& conf_actions, bool soft_set, bool force_set,\n+                          const std::string& section, const std::string& network, bool net_specific) {\n+        TestArgsManager parser;\n+        LOCK(parser.cs_args);\n+\n+        std::string desc = \"net=\";\n+        desc += network;\n+        parser.m_network = network;\n+\n+        const std::string& name = net_specific ? \"wallet\" : \"server\";\n+        const std::string key = \"-\" + name;\n+        parser.AddArg(key, name, false, OptionsCategory::OPTIONS);\n+        if (net_specific) parser.SetNetworkOnlyArg(key);\n+\n+        auto args = GetValues(arg_actions, section, name, \"a\");\n+        std::vector<const char*> argv = {\"ignored\"};\n+        for (auto& arg : args) {\n+            arg.insert(0, \"-\");\n+            desc += \" \";\n+            desc += arg;\n+            argv.push_back(arg.c_str());\n+        }\n+        std::string error;\n+        BOOST_CHECK(parser.ParseParameters(argv.size(), argv.data(), error));\n+        BOOST_CHECK_EQUAL(error, \"\");\n+\n+        std::string conf;\n+        for (auto& conf_val : GetValues(conf_actions, section, name, \"c\")) {\n+            desc += \" \";\n+            desc += conf_val;\n+            conf += conf_val;\n+            conf += \"\\n\";\n+        }\n+        std::istringstream conf_stream(conf);\n+        BOOST_CHECK(parser.ReadConfigStream(conf_stream, \"filepath\", error));\n+        BOOST_CHECK_EQUAL(error, \"\");\n+\n+        if (soft_set) {\n+            desc += \" soft\";\n+            parser.SoftSetArg(key, \"soft1\");\n+            parser.SoftSetArg(key, \"soft2\");\n+        }\n+\n+        if (force_set) {\n+            desc += \" force\";\n+            parser.ForceSetArg(key, \"force1\");\n+            parser.ForceSetArg(key, \"force2\");\n+        }\n+\n+        desc += \" || \";\n+\n+        if (!parser.IsArgSet(key)) {\n+            desc += \"unset\";\n+            BOOST_CHECK(!parser.IsArgNegated(key));\n+            BOOST_CHECK_EQUAL(parser.GetArg(key, \"default\"), \"default\");\n+            BOOST_CHECK(parser.GetArgs(key).empty());\n+        } else if (parser.IsArgNegated(key)) {\n+            desc += \"negated\";\n+            BOOST_CHECK_EQUAL(parser.GetArg(key, \"default\"), \"0\");\n+            BOOST_CHECK(parser.GetArgs(key).empty());\n+        } else {\n+            desc += parser.GetArg(key, \"default\");\n+            desc += \" |\";\n+            for (const auto& arg : parser.GetArgs(key)) {\n+                desc += \" \";\n+                desc += arg;\n+            }\n+        }\n+\n+        std::set<std::string> ignored = parser.GetUnsuitableSectionOnlyArgs();\n+        if (!ignored.empty()) {\n+            desc += \" | ignored\";\n+            for (const auto& arg : ignored) {\n+                desc += \" \";\n+                desc += arg;\n+            }\n+        }\n+\n+        desc += \"\\n\";\n+\n+        out_sha.Write((const unsigned char*)desc.data(), desc.size());\n+        if (out_file) {\n+            BOOST_REQUIRE(fwrite(desc.data(), 1, desc.size(), out_file) == desc.size());\n+        }\n+    });\n+\n+    if (out_file) {\n+        if (fclose(out_file)) throw std::system_error(errno, std::generic_category(), \"fclose failed\");\n+        out_file = nullptr;\n+    }\n+\n+    unsigned char out_sha_bytes[CSHA256::OUTPUT_SIZE];\n+    out_sha.Finalize(out_sha_bytes);\n+    std::string out_sha_hex = HexStr(std::begin(out_sha_bytes), std::end(out_sha_bytes));\n+\n+    // If check below fails, should manually dump the results with:\n+    //\n+    //   ARGS_MERGE_TEST_OUT=results.txt ./test_bitcoin --run_test=util_tests/util_ArgsMerge\n+    //\n+    // And verify diff against previous results to make sure the changes are expected.\n+    //\n+    // Results file is formatted like:\n+    //\n+    //   <input> || <IsArgSet/IsArgNegated/GetArg output> | <GetArgs output> | <GetUnsuitable output>\n+    BOOST_CHECK_EQUAL(out_sha_hex, \"b835eef5977d69114eb039a976201f8c7121f34fe2b7ea2b73cafb516e5c9dc8\");\n+}\n+\n+// Similar test as above, but for ArgsManager::GetChainName function.\n+struct ChainMergeTestingSetup : public BasicTestingSetup {\n+    static constexpr int MAX_ACTIONS = 2;\n+\n+    enum Action { NONE, ENABLE_TEST, DISABLE_TEST, NEGATE_TEST, ENABLE_REG, DISABLE_REG, NEGATE_REG };\n+    using ActionList = Action[MAX_ACTIONS];\n+\n+    //! Enumerate all possible test configurations.\n+    template <typename Fn>\n+    void ForEachMergeSetup(Fn&& fn)\n+    {\n+        ActionList arg_actions = {};\n+        ForEachNoDup(arg_actions, ENABLE_TEST, NEGATE_REG, [&] {\n+            ActionList conf_actions = {};\n+            ForEachNoDup(conf_actions, ENABLE_TEST, NEGATE_REG, [&] { fn(arg_actions, conf_actions); });\n+        });\n+    }\n+};\n+\n+BOOST_FIXTURE_TEST_CASE(util_ChainMerge, ChainMergeTestingSetup)\n+{\n+    CHash256 out_sha;\n+    FILE* out_file = nullptr;\n+    if (const char* out_path = getenv(\"CHAIN_MERGE_TEST_OUT\")) {\n+        out_file = fsbridge::fopen(out_path, \"w\");\n+        if (!out_file) throw std::system_error(errno, std::generic_category(), \"fopen failed\");\n+    }\n+\n+    ForEachMergeSetup([&](const ActionList& arg_actions, const ActionList& conf_actions) {\n+        TestArgsManager parser;\n+        LOCK(parser.cs_args);\n+        parser.AddArg(\"-regtest\", \"regtest\", false, OptionsCategory::OPTIONS);\n+        parser.AddArg(\"-testnet\", \"testnet\", false, OptionsCategory::OPTIONS);\n+\n+        auto arg = [](Action action) { return action == ENABLE_TEST  ? \"-testnet=1\"   :\n+                                              action == DISABLE_TEST ? \"-testnet=0\"   :\n+                                              action == NEGATE_TEST  ? \"-notestnet=1\" :\n+                                              action == ENABLE_REG   ? \"-regtest=1\"   :\n+                                              action == DISABLE_REG  ? \"-regtest=0\"   :\n+                                              action == NEGATE_REG   ? \"-noregtest=1\" : nullptr; };\n+\n+        std::string desc;\n+        std::vector<const char*> argv = {\"ignored\"};\n+        for (Action action : arg_actions) {\n+            const char* argstr = arg(action);\n+            if (!argstr) break;\n+            argv.push_back(argstr);\n+            desc += \" \";\n+            desc += argv.back();\n+        }\n+        std::string error;\n+        BOOST_CHECK(parser.ParseParameters(argv.size(), argv.data(), error));\n+        BOOST_CHECK_EQUAL(error, \"\");\n+\n+        std::string conf;\n+        for (Action action : conf_actions) {\n+            const char* argstr = arg(action);\n+            if (!argstr) break;\n+            desc += \" \";\n+            desc += argstr + 1;\n+            conf += argstr + 1;\n+        }\n+        std::istringstream conf_stream(conf);\n+        BOOST_CHECK(parser.ReadConfigStream(conf_stream, \"filepath\", error));\n+        BOOST_CHECK_EQUAL(error, \"\");\n+\n+        desc += \" || \";\n+        try {\n+            desc += parser.GetChainName();\n+        } catch (const std::runtime_error& e) {\n+            desc += \"error: \";\n+            desc += e.what();\n+        }\n+        desc += \"\\n\";\n+\n+        out_sha.Write((const unsigned char*)desc.data(), desc.size());\n+        if (out_file) {\n+            BOOST_REQUIRE(fwrite(desc.data(), 1, desc.size(), out_file) == desc.size());\n+        }\n+    });\n+\n+    if (out_file) {\n+        if (fclose(out_file)) throw std::system_error(errno, std::generic_category(), \"fclose failed\");\n+        out_file = nullptr;\n+    }\n+\n+    unsigned char out_sha_bytes[CSHA256::OUTPUT_SIZE];\n+    out_sha.Finalize(out_sha_bytes);\n+    std::string out_sha_hex = HexStr(std::begin(out_sha_bytes), std::end(out_sha_bytes));\n+\n+    // If check below fails, should manually dump the results with:\n+    //\n+    //   CHAIN_MERGE_TEST_OUT=results.txt ./test_bitcoin --run_test=util_tests/util_ChainMerge\n+    //\n+    // And verify diff against previous results to make sure the changes are expected.\n+    //\n+    // Results file is formatted like:\n+    //\n+    //   <input> || <output>\n+    BOOST_CHECK_EQUAL(out_sha_hex, \"b284f4b4a15dd6bf8c06213a69a004b1960388e1d9917173927db52ac220927f\");\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "65a95dde474550fef3df593b163cc8809604c727",
        "filename": "src/test/rpc_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 7,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fabf534b2de6a2a261dff704d6f2c980ef54f26f/src/test/rpc_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fabf534b2de6a2a261dff704d6f2c980ef54f26f/src/test/rpc_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/rpc_tests.cpp?ref=fabf534b2de6a2a261dff704d6f2c980ef54f26f",
        "patch": "@@ -2,23 +2,20 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include <rpc/server.h>\n-#include <rpc/client.h>\n-#include <rpc/util.h>\n-\n #include <core_io.h>\n #include <init.h>\n #include <interfaces/chain.h>\n-\n+#include <rpc/blockchain.h>\n+#include <rpc/client.h>\n+#include <rpc/server.h>\n+#include <rpc/util.h>\n #include <test/setup_common.h>\n \n #include <boost/algorithm/string.hpp>\n #include <boost/test/unit_test.hpp>\n \n #include <univalue.h>\n \n-#include <rpc/blockchain.h>\n-\n UniValue CallRPC(std::string args)\n {\n     std::vector<std::string> vArgs;"
      },
      {
        "sha": "2dc5a1304aa19f634a771b51a7e8d0c80a170df4",
        "filename": "src/test/script_eval_tests.cpp",
        "status": "added",
        "additions": 716,
        "deletions": 0,
        "changes": 716,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fabf534b2de6a2a261dff704d6f2c980ef54f26f/src/test/script_eval_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fabf534b2de6a2a261dff704d6f2c980ef54f26f/src/test/script_eval_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_eval_tests.cpp?ref=fabf534b2de6a2a261dff704d6f2c980ef54f26f",
        "patch": "@@ -0,0 +1,716 @@\n+// Copyright (c) 2011-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <core_io.h>\n+#include <key.h>\n+#include <keystore.h>\n+#include <script/script.h>\n+#include <script/script_error.h>\n+#include <script/sign.h>\n+#include <test/setup_common.h>\n+\n+#if defined(HAVE_CONSENSUS_LIB)\n+#include <script/bitcoinconsensus.h>\n+#endif\n+\n+#include <boost/test/unit_test.hpp>\n+\n+static const unsigned int gFlags = SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC;\n+\n+BOOST_FIXTURE_TEST_SUITE(script_eval_tests, BasicTestingSetup)\n+\n+static CMutableTransaction BuildCreditingTransaction(const CScript& scriptPubKey, int nValue = 0)\n+{\n+    CMutableTransaction txCredit;\n+    txCredit.nVersion = 1;\n+    txCredit.nLockTime = 0;\n+    txCredit.vin.resize(1);\n+    txCredit.vout.resize(1);\n+    txCredit.vin[0].prevout.SetNull();\n+    txCredit.vin[0].scriptSig = CScript() << CScriptNum(0) << CScriptNum(0);\n+    txCredit.vin[0].nSequence = CTxIn::SEQUENCE_FINAL;\n+    txCredit.vout[0].scriptPubKey = scriptPubKey;\n+    txCredit.vout[0].nValue = nValue;\n+\n+    return txCredit;\n+}\n+\n+static CMutableTransaction BuildSpendingTransaction(const CScript& scriptSig, const CScriptWitness& scriptWitness, const CTransaction& txCredit)\n+{\n+    CMutableTransaction txSpend;\n+    txSpend.nVersion = 1;\n+    txSpend.nLockTime = 0;\n+    txSpend.vin.resize(1);\n+    txSpend.vout.resize(1);\n+    txSpend.vin[0].scriptWitness = scriptWitness;\n+    txSpend.vin[0].prevout.hash = txCredit.GetHash();\n+    txSpend.vin[0].prevout.n = 0;\n+    txSpend.vin[0].scriptSig = scriptSig;\n+    txSpend.vin[0].nSequence = CTxIn::SEQUENCE_FINAL;\n+    txSpend.vout[0].scriptPubKey = CScript();\n+    txSpend.vout[0].nValue = txCredit.vout[0].nValue;\n+\n+    return txSpend;\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_PushData)\n+{\n+    // Check that PUSHDATA1, PUSHDATA2, and PUSHDATA4 create the same value on\n+    // the stack as the 1-75 opcodes do.\n+    static const unsigned char direct[] = { 1, 0x5a };\n+    static const unsigned char pushdata1[] = { OP_PUSHDATA1, 1, 0x5a };\n+    static const unsigned char pushdata2[] = { OP_PUSHDATA2, 1, 0, 0x5a };\n+    static const unsigned char pushdata4[] = { OP_PUSHDATA4, 1, 0, 0, 0, 0x5a };\n+\n+    ScriptError err;\n+    std::vector<std::vector<unsigned char> > directStack;\n+    BOOST_CHECK(EvalScript(directStack, CScript(direct, direct + sizeof(direct)), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SigVersion::BASE, &err));\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n+\n+    std::vector<std::vector<unsigned char> > pushdata1Stack;\n+    BOOST_CHECK(EvalScript(pushdata1Stack, CScript(pushdata1, pushdata1 + sizeof(pushdata1)), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SigVersion::BASE, &err));\n+    BOOST_CHECK(pushdata1Stack == directStack);\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n+\n+    std::vector<std::vector<unsigned char> > pushdata2Stack;\n+    BOOST_CHECK(EvalScript(pushdata2Stack, CScript(pushdata2, pushdata2 + sizeof(pushdata2)), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SigVersion::BASE, &err));\n+    BOOST_CHECK(pushdata2Stack == directStack);\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n+\n+    std::vector<std::vector<unsigned char> > pushdata4Stack;\n+    BOOST_CHECK(EvalScript(pushdata4Stack, CScript(pushdata4, pushdata4 + sizeof(pushdata4)), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SigVersion::BASE, &err));\n+    BOOST_CHECK(pushdata4Stack == directStack);\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n+\n+    const std::vector<unsigned char> pushdata1_trunc{OP_PUSHDATA1, 1};\n+    const std::vector<unsigned char> pushdata2_trunc{OP_PUSHDATA2, 1, 0};\n+    const std::vector<unsigned char> pushdata4_trunc{OP_PUSHDATA4, 1, 0, 0, 0};\n+\n+    std::vector<std::vector<unsigned char>> stack_ignore;\n+    BOOST_CHECK(!EvalScript(stack_ignore, CScript(pushdata1_trunc.begin(), pushdata1_trunc.end()), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SigVersion::BASE, &err));\n+    BOOST_CHECK_EQUAL(err, SCRIPT_ERR_BAD_OPCODE);\n+    BOOST_CHECK(!EvalScript(stack_ignore, CScript(pushdata2_trunc.begin(), pushdata2_trunc.end()), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SigVersion::BASE, &err));\n+    BOOST_CHECK_EQUAL(err, SCRIPT_ERR_BAD_OPCODE);\n+    BOOST_CHECK(!EvalScript(stack_ignore, CScript(pushdata4_trunc.begin(), pushdata4_trunc.end()), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SigVersion::BASE, &err));\n+    BOOST_CHECK_EQUAL(err, SCRIPT_ERR_BAD_OPCODE);\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_cltv_truncated)\n+{\n+    const auto script_cltv_trunc = CScript() << OP_CHECKLOCKTIMEVERIFY;\n+\n+    std::vector<std::vector<unsigned char>> stack_ignore;\n+    ScriptError err;\n+    BOOST_CHECK(!EvalScript(stack_ignore, script_cltv_trunc, SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, BaseSignatureChecker(), SigVersion::BASE, &err));\n+    BOOST_CHECK_EQUAL(err, SCRIPT_ERR_INVALID_STACK_OPERATION);\n+}\n+\n+static CScript\n+sign_multisig(const CScript& scriptPubKey, const std::vector<CKey>& keys, const CTransaction& transaction)\n+{\n+    uint256 hash = SignatureHash(scriptPubKey, transaction, 0, SIGHASH_ALL, 0, SigVersion::BASE);\n+\n+    CScript result;\n+    //\n+    // NOTE: CHECKMULTISIG has an unfortunate bug; it requires\n+    // one extra item on the stack, before the signatures.\n+    // Putting OP_0 on the stack is the workaround;\n+    // fixing the bug would mean splitting the block chain (old\n+    // clients would not accept new CHECKMULTISIG transactions,\n+    // and vice-versa)\n+    //\n+    result << OP_0;\n+    for (const CKey &key : keys)\n+    {\n+        std::vector<unsigned char> vchSig;\n+        BOOST_CHECK(key.Sign(hash, vchSig));\n+        vchSig.push_back((unsigned char)SIGHASH_ALL);\n+        result << vchSig;\n+    }\n+    return result;\n+}\n+static CScript\n+sign_multisig(const CScript& scriptPubKey, const CKey& key, const CTransaction& transaction)\n+{\n+    std::vector<CKey> keys;\n+    keys.push_back(key);\n+    return sign_multisig(scriptPubKey, keys, transaction);\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG12)\n+{\n+    ScriptError err;\n+    CKey key1, key2, key3;\n+    key1.MakeNewKey(true);\n+    key2.MakeNewKey(false);\n+    key3.MakeNewKey(true);\n+\n+    CScript scriptPubKey12;\n+    scriptPubKey12 << OP_1 << ToByteVector(key1.GetPubKey()) << ToByteVector(key2.GetPubKey()) << OP_2 << OP_CHECKMULTISIG;\n+\n+    const CTransaction txFrom12{BuildCreditingTransaction(scriptPubKey12)};\n+    CMutableTransaction txTo12 = BuildSpendingTransaction(CScript(), CScriptWitness(), txFrom12);\n+\n+    CScript goodsig1 = sign_multisig(scriptPubKey12, key1, CTransaction(txTo12));\n+    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey12, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n+    txTo12.vout[0].nValue = 2;\n+    BOOST_CHECK(!VerifyScript(goodsig1, scriptPubKey12, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n+\n+    CScript goodsig2 = sign_multisig(scriptPubKey12, key2, CTransaction(txTo12));\n+    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey12, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n+\n+    CScript badsig1 = sign_multisig(scriptPubKey12, key3, CTransaction(txTo12));\n+    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey12, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG23)\n+{\n+    ScriptError err;\n+    CKey key1, key2, key3, key4;\n+    key1.MakeNewKey(true);\n+    key2.MakeNewKey(false);\n+    key3.MakeNewKey(true);\n+    key4.MakeNewKey(false);\n+\n+    CScript scriptPubKey23;\n+    scriptPubKey23 << OP_2 << ToByteVector(key1.GetPubKey()) << ToByteVector(key2.GetPubKey()) << ToByteVector(key3.GetPubKey()) << OP_3 << OP_CHECKMULTISIG;\n+\n+    const CTransaction txFrom23{BuildCreditingTransaction(scriptPubKey23)};\n+    CMutableTransaction txTo23 = BuildSpendingTransaction(CScript(), CScriptWitness(), txFrom23);\n+\n+    std::vector<CKey> keys;\n+    keys.push_back(key1); keys.push_back(key2);\n+    CScript goodsig1 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n+    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n+\n+    keys.clear();\n+    keys.push_back(key1); keys.push_back(key3);\n+    CScript goodsig2 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n+    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n+\n+    keys.clear();\n+    keys.push_back(key2); keys.push_back(key3);\n+    CScript goodsig3 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n+    BOOST_CHECK(VerifyScript(goodsig3, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n+\n+    keys.clear();\n+    keys.push_back(key2); keys.push_back(key2); // Can't re-use sig\n+    CScript badsig1 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n+    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n+\n+    keys.clear();\n+    keys.push_back(key2); keys.push_back(key1); // sigs must be in correct order\n+    CScript badsig2 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n+    BOOST_CHECK(!VerifyScript(badsig2, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n+\n+    keys.clear();\n+    keys.push_back(key3); keys.push_back(key2); // sigs must be in correct order\n+    CScript badsig3 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n+    BOOST_CHECK(!VerifyScript(badsig3, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n+\n+    keys.clear();\n+    keys.push_back(key4); keys.push_back(key2); // sigs must match pubkeys\n+    CScript badsig4 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n+    BOOST_CHECK(!VerifyScript(badsig4, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n+\n+    keys.clear();\n+    keys.push_back(key1); keys.push_back(key4); // sigs must match pubkeys\n+    CScript badsig5 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n+    BOOST_CHECK(!VerifyScript(badsig5, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n+\n+    keys.clear(); // Must have signatures\n+    CScript badsig6 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n+    BOOST_CHECK(!VerifyScript(badsig6, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_INVALID_STACK_OPERATION, ScriptErrorString(err));\n+}\n+\n+/* Wrapper around ProduceSignature to combine two scriptsigs */\n+SignatureData CombineSignatures(const CTxOut& txout, const CMutableTransaction& tx, const SignatureData& scriptSig1, const SignatureData& scriptSig2)\n+{\n+    SignatureData data;\n+    data.MergeSignatureData(scriptSig1);\n+    data.MergeSignatureData(scriptSig2);\n+    ProduceSignature(DUMMY_SIGNING_PROVIDER, MutableTransactionSignatureCreator(&tx, 0, txout.nValue), txout.scriptPubKey, data);\n+    return data;\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_combineSigs)\n+{\n+    // Test the ProduceSignature's ability to combine signatures function\n+    CBasicKeyStore keystore;\n+    std::vector<CKey> keys;\n+    std::vector<CPubKey> pubkeys;\n+    for (int i = 0; i < 3; i++)\n+    {\n+        CKey key;\n+        key.MakeNewKey(i%2 == 1);\n+        keys.push_back(key);\n+        pubkeys.push_back(key.GetPubKey());\n+        BOOST_CHECK(keystore.AddKey(key));\n+    }\n+\n+    CMutableTransaction txFrom = BuildCreditingTransaction(GetScriptForDestination(PKHash(keys[0].GetPubKey())));\n+    CMutableTransaction txTo = BuildSpendingTransaction(CScript(), CScriptWitness(), CTransaction(txFrom));\n+    CScript& scriptPubKey = txFrom.vout[0].scriptPubKey;\n+    SignatureData scriptSig;\n+\n+    SignatureData empty;\n+    SignatureData combined = CombineSignatures(txFrom.vout[0], txTo, empty, empty);\n+    BOOST_CHECK(combined.scriptSig.empty());\n+\n+    // Single signature case:\n+    BOOST_CHECK(SignSignature(keystore, CTransaction(txFrom), txTo, 0, SIGHASH_ALL)); // changes scriptSig\n+    scriptSig = DataFromTransaction(txTo, 0, txFrom.vout[0]);\n+    combined = CombineSignatures(txFrom.vout[0], txTo, scriptSig, empty);\n+    BOOST_CHECK(combined.scriptSig == scriptSig.scriptSig);\n+    combined = CombineSignatures(txFrom.vout[0], txTo, empty, scriptSig);\n+    BOOST_CHECK(combined.scriptSig == scriptSig.scriptSig);\n+    SignatureData scriptSigCopy = scriptSig;\n+    // Signing again will give a different, valid signature:\n+    BOOST_CHECK(SignSignature(keystore, CTransaction(txFrom), txTo, 0, SIGHASH_ALL));\n+    scriptSig = DataFromTransaction(txTo, 0, txFrom.vout[0]);\n+    combined = CombineSignatures(txFrom.vout[0], txTo, scriptSigCopy, scriptSig);\n+    BOOST_CHECK(combined.scriptSig == scriptSigCopy.scriptSig || combined.scriptSig == scriptSig.scriptSig);\n+\n+    // P2SH, single-signature case:\n+    CScript pkSingle; pkSingle << ToByteVector(keys[0].GetPubKey()) << OP_CHECKSIG;\n+    BOOST_CHECK(keystore.AddCScript(pkSingle));\n+    scriptPubKey = GetScriptForDestination(ScriptHash(pkSingle));\n+    BOOST_CHECK(SignSignature(keystore, CTransaction(txFrom), txTo, 0, SIGHASH_ALL));\n+    scriptSig = DataFromTransaction(txTo, 0, txFrom.vout[0]);\n+    combined = CombineSignatures(txFrom.vout[0], txTo, scriptSig, empty);\n+    BOOST_CHECK(combined.scriptSig == scriptSig.scriptSig);\n+    combined = CombineSignatures(txFrom.vout[0], txTo, empty, scriptSig);\n+    BOOST_CHECK(combined.scriptSig == scriptSig.scriptSig);\n+    scriptSigCopy = scriptSig;\n+    BOOST_CHECK(SignSignature(keystore, CTransaction(txFrom), txTo, 0, SIGHASH_ALL));\n+    scriptSig = DataFromTransaction(txTo, 0, txFrom.vout[0]);\n+    combined = CombineSignatures(txFrom.vout[0], txTo, scriptSigCopy, scriptSig);\n+    BOOST_CHECK(combined.scriptSig == scriptSigCopy.scriptSig || combined.scriptSig == scriptSig.scriptSig);\n+\n+    // Hardest case:  Multisig 2-of-3\n+    scriptPubKey = GetScriptForMultisig(2, pubkeys);\n+    BOOST_CHECK(keystore.AddCScript(scriptPubKey));\n+    BOOST_CHECK(SignSignature(keystore, CTransaction(txFrom), txTo, 0, SIGHASH_ALL));\n+    scriptSig = DataFromTransaction(txTo, 0, txFrom.vout[0]);\n+    combined = CombineSignatures(txFrom.vout[0], txTo, scriptSig, empty);\n+    BOOST_CHECK(combined.scriptSig == scriptSig.scriptSig);\n+    combined = CombineSignatures(txFrom.vout[0], txTo, empty, scriptSig);\n+    BOOST_CHECK(combined.scriptSig == scriptSig.scriptSig);\n+\n+    // A couple of partially-signed versions:\n+    std::vector<unsigned char> sig1;\n+    uint256 hash1 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_ALL, 0, SigVersion::BASE);\n+    BOOST_CHECK(keys[0].Sign(hash1, sig1));\n+    sig1.push_back(SIGHASH_ALL);\n+    std::vector<unsigned char> sig2;\n+    uint256 hash2 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_NONE, 0, SigVersion::BASE);\n+    BOOST_CHECK(keys[1].Sign(hash2, sig2));\n+    sig2.push_back(SIGHASH_NONE);\n+    std::vector<unsigned char> sig3;\n+    uint256 hash3 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_SINGLE, 0, SigVersion::BASE);\n+    BOOST_CHECK(keys[2].Sign(hash3, sig3));\n+    sig3.push_back(SIGHASH_SINGLE);\n+\n+    // Not fussy about order (or even existence) of placeholders or signatures:\n+    CScript partial1a = CScript() << OP_0 << sig1 << OP_0;\n+    CScript partial1b = CScript() << OP_0 << OP_0 << sig1;\n+    CScript partial2a = CScript() << OP_0 << sig2;\n+    CScript partial2b = CScript() << sig2 << OP_0;\n+    CScript partial3a = CScript() << sig3;\n+    CScript partial3b = CScript() << OP_0 << OP_0 << sig3;\n+    CScript partial3c = CScript() << OP_0 << sig3 << OP_0;\n+    CScript complete12 = CScript() << OP_0 << sig1 << sig2;\n+    CScript complete13 = CScript() << OP_0 << sig1 << sig3;\n+    CScript complete23 = CScript() << OP_0 << sig2 << sig3;\n+    SignatureData partial1_sigs;\n+    partial1_sigs.signatures.emplace(keys[0].GetPubKey().GetID(), SigPair(keys[0].GetPubKey(), sig1));\n+    SignatureData partial2_sigs;\n+    partial2_sigs.signatures.emplace(keys[1].GetPubKey().GetID(), SigPair(keys[1].GetPubKey(), sig2));\n+    SignatureData partial3_sigs;\n+    partial3_sigs.signatures.emplace(keys[2].GetPubKey().GetID(), SigPair(keys[2].GetPubKey(), sig3));\n+\n+    combined = CombineSignatures(txFrom.vout[0], txTo, partial1_sigs, partial1_sigs);\n+    BOOST_CHECK(combined.scriptSig == partial1a);\n+    combined = CombineSignatures(txFrom.vout[0], txTo, partial1_sigs, partial2_sigs);\n+    BOOST_CHECK(combined.scriptSig == complete12);\n+    combined = CombineSignatures(txFrom.vout[0], txTo, partial2_sigs, partial1_sigs);\n+    BOOST_CHECK(combined.scriptSig == complete12);\n+    combined = CombineSignatures(txFrom.vout[0], txTo, partial1_sigs, partial2_sigs);\n+    BOOST_CHECK(combined.scriptSig == complete12);\n+    combined = CombineSignatures(txFrom.vout[0], txTo, partial3_sigs, partial1_sigs);\n+    BOOST_CHECK(combined.scriptSig == complete13);\n+    combined = CombineSignatures(txFrom.vout[0], txTo, partial2_sigs, partial3_sigs);\n+    BOOST_CHECK(combined.scriptSig == complete23);\n+    combined = CombineSignatures(txFrom.vout[0], txTo, partial3_sigs, partial2_sigs);\n+    BOOST_CHECK(combined.scriptSig == complete23);\n+    combined = CombineSignatures(txFrom.vout[0], txTo, partial3_sigs, partial3_sigs);\n+    BOOST_CHECK(combined.scriptSig == partial3c);\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_standard_push)\n+{\n+    ScriptError err;\n+    for (int i=0; i<67000; i++) {\n+        CScript script;\n+        script << i;\n+        BOOST_CHECK_MESSAGE(script.IsPushOnly(), \"Number \" << i << \" is not pure push.\");\n+        BOOST_CHECK_MESSAGE(VerifyScript(script, CScript() << OP_1, nullptr, SCRIPT_VERIFY_MINIMALDATA, BaseSignatureChecker(), &err), \"Number \" << i << \" push is not minimal data.\");\n+        BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n+    }\n+\n+    for (unsigned int i=0; i<=MAX_SCRIPT_ELEMENT_SIZE; i++) {\n+        std::vector<unsigned char> data(i, '\\111');\n+        CScript script;\n+        script << data;\n+        BOOST_CHECK_MESSAGE(script.IsPushOnly(), \"Length \" << i << \" is not pure push.\");\n+        BOOST_CHECK_MESSAGE(VerifyScript(script, CScript() << OP_1, nullptr, SCRIPT_VERIFY_MINIMALDATA, BaseSignatureChecker(), &err), \"Length \" << i << \" push is not minimal data.\");\n+        BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_IsPushOnly_on_invalid_scripts)\n+{\n+    // IsPushOnly returns false when given a script containing only pushes that\n+    // are invalid due to truncation. IsPushOnly() is consensus critical\n+    // because P2SH evaluation uses it, although this specific behavior should\n+    // not be consensus critical as the P2SH evaluation would fail first due to\n+    // the invalid push. Still, it doesn't hurt to test it explicitly.\n+    static const unsigned char direct[] = { 1 };\n+    BOOST_CHECK(!CScript(direct, direct+sizeof(direct)).IsPushOnly());\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_GetScriptAsm)\n+{\n+    BOOST_CHECK_EQUAL(\"OP_CHECKLOCKTIMEVERIFY\", ScriptToAsmStr(CScript() << OP_NOP2, true));\n+    BOOST_CHECK_EQUAL(\"OP_CHECKLOCKTIMEVERIFY\", ScriptToAsmStr(CScript() << OP_CHECKLOCKTIMEVERIFY, true));\n+    BOOST_CHECK_EQUAL(\"OP_CHECKLOCKTIMEVERIFY\", ScriptToAsmStr(CScript() << OP_NOP2));\n+    BOOST_CHECK_EQUAL(\"OP_CHECKLOCKTIMEVERIFY\", ScriptToAsmStr(CScript() << OP_CHECKLOCKTIMEVERIFY));\n+\n+    std::string derSig(\"304502207fa7a6d1e0ee81132a269ad84e68d695483745cde8b541e3bf630749894e342a022100c1f7ab20e13e22fb95281a870f3dcf38d782e53023ee313d741ad0cfbc0c5090\");\n+    std::string pubKey(\"03b0da749730dc9b4b1f4a14d6902877a92541f5368778853d9c4a0cb7802dcfb2\");\n+    std::vector<unsigned char> vchPubKey = ToByteVector(ParseHex(pubKey));\n+\n+    BOOST_CHECK_EQUAL(derSig + \"00 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"00\")) << vchPubKey, true));\n+    BOOST_CHECK_EQUAL(derSig + \"80 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"80\")) << vchPubKey, true));\n+    BOOST_CHECK_EQUAL(derSig + \"[ALL] \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"01\")) << vchPubKey, true));\n+    BOOST_CHECK_EQUAL(derSig + \"[NONE] \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"02\")) << vchPubKey, true));\n+    BOOST_CHECK_EQUAL(derSig + \"[SINGLE] \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"03\")) << vchPubKey, true));\n+    BOOST_CHECK_EQUAL(derSig + \"[ALL|ANYONECANPAY] \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"81\")) << vchPubKey, true));\n+    BOOST_CHECK_EQUAL(derSig + \"[NONE|ANYONECANPAY] \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"82\")) << vchPubKey, true));\n+    BOOST_CHECK_EQUAL(derSig + \"[SINGLE|ANYONECANPAY] \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"83\")) << vchPubKey, true));\n+\n+    BOOST_CHECK_EQUAL(derSig + \"00 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"00\")) << vchPubKey));\n+    BOOST_CHECK_EQUAL(derSig + \"80 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"80\")) << vchPubKey));\n+    BOOST_CHECK_EQUAL(derSig + \"01 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"01\")) << vchPubKey));\n+    BOOST_CHECK_EQUAL(derSig + \"02 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"02\")) << vchPubKey));\n+    BOOST_CHECK_EQUAL(derSig + \"03 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"03\")) << vchPubKey));\n+    BOOST_CHECK_EQUAL(derSig + \"81 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"81\")) << vchPubKey));\n+    BOOST_CHECK_EQUAL(derSig + \"82 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"82\")) << vchPubKey));\n+    BOOST_CHECK_EQUAL(derSig + \"83 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"83\")) << vchPubKey));\n+}\n+\n+static CScript\n+ScriptFromHex(const char* hex)\n+{\n+    std::vector<unsigned char> data = ParseHex(hex);\n+    return CScript(data.begin(), data.end());\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(script_FindAndDelete)\n+{\n+    // Exercise the FindAndDelete functionality\n+    CScript s;\n+    CScript d;\n+    CScript expect;\n+\n+    s = CScript() << OP_1 << OP_2;\n+    d = CScript(); // delete nothing should be a no-op\n+    expect = s;\n+    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 0);\n+    BOOST_CHECK(s == expect);\n+\n+    s = CScript() << OP_1 << OP_2 << OP_3;\n+    d = CScript() << OP_2;\n+    expect = CScript() << OP_1 << OP_3;\n+    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 1);\n+    BOOST_CHECK(s == expect);\n+\n+    s = CScript() << OP_3 << OP_1 << OP_3 << OP_3 << OP_4 << OP_3;\n+    d = CScript() << OP_3;\n+    expect = CScript() << OP_1 << OP_4;\n+    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 4);\n+    BOOST_CHECK(s == expect);\n+\n+    s = ScriptFromHex(\"0302ff03\"); // PUSH 0x02ff03 onto stack\n+    d = ScriptFromHex(\"0302ff03\");\n+    expect = CScript();\n+    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 1);\n+    BOOST_CHECK(s == expect);\n+\n+    s = ScriptFromHex(\"0302ff030302ff03\"); // PUSH 0x2ff03 PUSH 0x2ff03\n+    d = ScriptFromHex(\"0302ff03\");\n+    expect = CScript();\n+    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 2);\n+    BOOST_CHECK(s == expect);\n+\n+    s = ScriptFromHex(\"0302ff030302ff03\");\n+    d = ScriptFromHex(\"02\");\n+    expect = s; // FindAndDelete matches entire opcodes\n+    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 0);\n+    BOOST_CHECK(s == expect);\n+\n+    s = ScriptFromHex(\"0302ff030302ff03\");\n+    d = ScriptFromHex(\"ff\");\n+    expect = s;\n+    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 0);\n+    BOOST_CHECK(s == expect);\n+\n+    // This is an odd edge case: strip of the push-three-bytes\n+    // prefix, leaving 02ff03 which is push-two-bytes:\n+    s = ScriptFromHex(\"0302ff030302ff03\");\n+    d = ScriptFromHex(\"03\");\n+    expect = CScript() << ParseHex(\"ff03\") << ParseHex(\"ff03\");\n+    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 2);\n+    BOOST_CHECK(s == expect);\n+\n+    // Byte sequence that spans multiple opcodes:\n+    s = ScriptFromHex(\"02feed5169\"); // PUSH(0xfeed) OP_1 OP_VERIFY\n+    d = ScriptFromHex(\"feed51\");\n+    expect = s;\n+    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 0); // doesn't match 'inside' opcodes\n+    BOOST_CHECK(s == expect);\n+\n+    s = ScriptFromHex(\"02feed5169\"); // PUSH(0xfeed) OP_1 OP_VERIFY\n+    d = ScriptFromHex(\"02feed51\");\n+    expect = ScriptFromHex(\"69\");\n+    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 1);\n+    BOOST_CHECK(s == expect);\n+\n+    s = ScriptFromHex(\"516902feed5169\");\n+    d = ScriptFromHex(\"feed51\");\n+    expect = s;\n+    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 0);\n+    BOOST_CHECK(s == expect);\n+\n+    s = ScriptFromHex(\"516902feed5169\");\n+    d = ScriptFromHex(\"02feed51\");\n+    expect = ScriptFromHex(\"516969\");\n+    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 1);\n+    BOOST_CHECK(s == expect);\n+\n+    s = CScript() << OP_0 << OP_0 << OP_1 << OP_1;\n+    d = CScript() << OP_0 << OP_1;\n+    expect = CScript() << OP_0 << OP_1; // FindAndDelete is single-pass\n+    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 1);\n+    BOOST_CHECK(s == expect);\n+\n+    s = CScript() << OP_0 << OP_0 << OP_1 << OP_0 << OP_1 << OP_1;\n+    d = CScript() << OP_0 << OP_1;\n+    expect = CScript() << OP_0 << OP_1; // FindAndDelete is single-pass\n+    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 2);\n+    BOOST_CHECK(s == expect);\n+\n+    // Another weird edge case:\n+    // End with invalid push (not enough data)...\n+    s = ScriptFromHex(\"0003feed\");\n+    d = ScriptFromHex(\"03feed\"); // ... can remove the invalid push\n+    expect = ScriptFromHex(\"00\");\n+    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 1);\n+    BOOST_CHECK(s == expect);\n+\n+    s = ScriptFromHex(\"0003feed\");\n+    d = ScriptFromHex(\"00\");\n+    expect = ScriptFromHex(\"03feed\");\n+    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 1);\n+    BOOST_CHECK(s == expect);\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_HasValidOps)\n+{\n+    // Exercise the HasValidOps functionality\n+    CScript script;\n+    script = ScriptFromHex(\"76a9141234567890abcdefa1a2a3a4a5a6a7a8a9a0aaab88ac\"); // Normal script\n+    BOOST_CHECK(script.HasValidOps());\n+    script = ScriptFromHex(\"76a914ff34567890abcdefa1a2a3a4a5a6a7a8a9a0aaab88ac\");\n+    BOOST_CHECK(script.HasValidOps());\n+    script = ScriptFromHex(\"ff88ac\"); // Script with OP_INVALIDOPCODE explicit\n+    BOOST_CHECK(!script.HasValidOps());\n+    script = ScriptFromHex(\"88acc0\"); // Script with undefined opcode\n+    BOOST_CHECK(!script.HasValidOps());\n+}\n+\n+BOOST_AUTO_TEST_CASE(script_can_append_self)\n+{\n+    CScript s, d;\n+\n+    s = ScriptFromHex(\"00\");\n+    s += s;\n+    d = ScriptFromHex(\"0000\");\n+    BOOST_CHECK(s == d);\n+\n+    // check doubling a script that's large enough to require reallocation\n+    static const char hex[] = \"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f\";\n+    s = CScript() << ParseHex(hex) << OP_CHECKSIG;\n+    d = CScript() << ParseHex(hex) << OP_CHECKSIG << ParseHex(hex) << OP_CHECKSIG;\n+    s += s;\n+    BOOST_CHECK(s == d);\n+}\n+\n+\n+#if defined(HAVE_CONSENSUS_LIB)\n+\n+/* Test simple (successful) usage of bitcoinconsensus_verify_script */\n+BOOST_AUTO_TEST_CASE(bitcoinconsensus_verify_script_returns_true)\n+{\n+    unsigned int libconsensus_flags = 0;\n+    int nIn = 0;\n+\n+    CScript scriptPubKey;\n+    CScript scriptSig;\n+    CScriptWitness wit;\n+\n+    scriptPubKey << OP_1;\n+    CTransaction creditTx = BuildCreditingTransaction(scriptPubKey, 1);\n+    CTransaction spendTx = BuildSpendingTransaction(scriptSig, wit, creditTx);\n+\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << spendTx;\n+\n+    bitcoinconsensus_error err;\n+    int result = bitcoinconsensus_verify_script(scriptPubKey.data(), scriptPubKey.size(), (const unsigned char*)&stream[0], stream.size(), nIn, libconsensus_flags, &err);\n+    BOOST_CHECK_EQUAL(result, 1);\n+    BOOST_CHECK_EQUAL(err, bitcoinconsensus_ERR_OK);\n+}\n+\n+/* Test bitcoinconsensus_verify_script returns invalid tx index err*/\n+BOOST_AUTO_TEST_CASE(bitcoinconsensus_verify_script_tx_index_err)\n+{\n+    unsigned int libconsensus_flags = 0;\n+    int nIn = 3;\n+\n+    CScript scriptPubKey;\n+    CScript scriptSig;\n+    CScriptWitness wit;\n+\n+    scriptPubKey << OP_EQUAL;\n+    CTransaction creditTx = BuildCreditingTransaction(scriptPubKey, 1);\n+    CTransaction spendTx = BuildSpendingTransaction(scriptSig, wit, creditTx);\n+\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << spendTx;\n+\n+    bitcoinconsensus_error err;\n+    int result = bitcoinconsensus_verify_script(scriptPubKey.data(), scriptPubKey.size(), (const unsigned char*)&stream[0], stream.size(), nIn, libconsensus_flags, &err);\n+    BOOST_CHECK_EQUAL(result, 0);\n+    BOOST_CHECK_EQUAL(err, bitcoinconsensus_ERR_TX_INDEX);\n+}\n+\n+/* Test bitcoinconsensus_verify_script returns tx size mismatch err*/\n+BOOST_AUTO_TEST_CASE(bitcoinconsensus_verify_script_tx_size)\n+{\n+    unsigned int libconsensus_flags = 0;\n+    int nIn = 0;\n+\n+    CScript scriptPubKey;\n+    CScript scriptSig;\n+    CScriptWitness wit;\n+\n+    scriptPubKey << OP_EQUAL;\n+    CTransaction creditTx = BuildCreditingTransaction(scriptPubKey, 1);\n+    CTransaction spendTx = BuildSpendingTransaction(scriptSig, wit, creditTx);\n+\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << spendTx;\n+\n+    bitcoinconsensus_error err;\n+    int result = bitcoinconsensus_verify_script(scriptPubKey.data(), scriptPubKey.size(), (const unsigned char*)&stream[0], stream.size() * 2, nIn, libconsensus_flags, &err);\n+    BOOST_CHECK_EQUAL(result, 0);\n+    BOOST_CHECK_EQUAL(err, bitcoinconsensus_ERR_TX_SIZE_MISMATCH);\n+}\n+\n+/* Test bitcoinconsensus_verify_script returns invalid tx serialization error */\n+BOOST_AUTO_TEST_CASE(bitcoinconsensus_verify_script_tx_serialization)\n+{\n+    unsigned int libconsensus_flags = 0;\n+    int nIn = 0;\n+\n+    CScript scriptPubKey;\n+    CScript scriptSig;\n+    CScriptWitness wit;\n+\n+    scriptPubKey << OP_EQUAL;\n+    CTransaction creditTx = BuildCreditingTransaction(scriptPubKey, 1);\n+    CTransaction spendTx = BuildSpendingTransaction(scriptSig, wit, creditTx);\n+\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << 0xffffffff;\n+\n+    bitcoinconsensus_error err;\n+    int result = bitcoinconsensus_verify_script(scriptPubKey.data(), scriptPubKey.size(), (const unsigned char*)&stream[0], stream.size(), nIn, libconsensus_flags, &err);\n+    BOOST_CHECK_EQUAL(result, 0);\n+    BOOST_CHECK_EQUAL(err, bitcoinconsensus_ERR_TX_DESERIALIZE);\n+}\n+\n+/* Test bitcoinconsensus_verify_script returns amount required error */\n+BOOST_AUTO_TEST_CASE(bitcoinconsensus_verify_script_amount_required_err)\n+{\n+    unsigned int libconsensus_flags = bitcoinconsensus_SCRIPT_FLAGS_VERIFY_WITNESS;\n+    int nIn = 0;\n+\n+    CScript scriptPubKey;\n+    CScript scriptSig;\n+    CScriptWitness wit;\n+\n+    scriptPubKey << OP_EQUAL;\n+    CTransaction creditTx = BuildCreditingTransaction(scriptPubKey, 1);\n+    CTransaction spendTx = BuildSpendingTransaction(scriptSig, wit, creditTx);\n+\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << spendTx;\n+\n+    bitcoinconsensus_error err;\n+    int result = bitcoinconsensus_verify_script(scriptPubKey.data(), scriptPubKey.size(), (const unsigned char*)&stream[0], stream.size(), nIn, libconsensus_flags, &err);\n+    BOOST_CHECK_EQUAL(result, 0);\n+    BOOST_CHECK_EQUAL(err, bitcoinconsensus_ERR_AMOUNT_REQUIRED);\n+}\n+\n+/* Test bitcoinconsensus_verify_script returns invalid flags err */\n+BOOST_AUTO_TEST_CASE(bitcoinconsensus_verify_script_invalid_flags)\n+{\n+    unsigned int libconsensus_flags = 1 << 3;\n+    int nIn = 0;\n+\n+    CScript scriptPubKey;\n+    CScript scriptSig;\n+    CScriptWitness wit;\n+\n+    scriptPubKey << OP_EQUAL;\n+    CTransaction creditTx = BuildCreditingTransaction(scriptPubKey, 1);\n+    CTransaction spendTx = BuildSpendingTransaction(scriptSig, wit, creditTx);\n+\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << spendTx;\n+\n+    bitcoinconsensus_error err;\n+    int result = bitcoinconsensus_verify_script(scriptPubKey.data(), scriptPubKey.size(), (const unsigned char*)&stream[0], stream.size(), nIn, libconsensus_flags, &err);\n+    BOOST_CHECK_EQUAL(result, 0);\n+    BOOST_CHECK_EQUAL(err, bitcoinconsensus_ERR_INVALID_FLAGS);\n+}\n+\n+#endif\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "c31371783e48202c5d92c3504fe0ae591a41a806",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 665,
        "changes": 667,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fabf534b2de6a2a261dff704d6f2c980ef54f26f/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fabf534b2de6a2a261dff704d6f2c980ef54f26f/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=fabf534b2de6a2a261dff704d6f2c980ef54f26f",
        "patch": "@@ -5,13 +5,9 @@\n #include <test/data/script_tests.json.h>\n \n #include <core_io.h>\n-#include <key.h>\n-#include <keystore.h>\n #include <script/script.h>\n #include <script/script_error.h>\n #include <script/sign.h>\n-#include <util/system.h>\n-#include <util/strencodings.h>\n #include <test/setup_common.h>\n #include <rpc/util.h>\n \n@@ -121,7 +117,7 @@ static ScriptError_t ParseScriptError(const std::string &name)\n \n BOOST_FIXTURE_TEST_SUITE(script_tests, BasicTestingSetup)\n \n-CMutableTransaction BuildCreditingTransaction(const CScript& scriptPubKey, int nValue = 0)\n+static CMutableTransaction BuildCreditingTransaction(const CScript& scriptPubKey, int nValue = 0)\n {\n     CMutableTransaction txCredit;\n     txCredit.nVersion = 1;\n@@ -137,7 +133,7 @@ CMutableTransaction BuildCreditingTransaction(const CScript& scriptPubKey, int n\n     return txCredit;\n }\n \n-CMutableTransaction BuildSpendingTransaction(const CScript& scriptSig, const CScriptWitness& scriptWitness, const CTransaction& txCredit)\n+static CMutableTransaction BuildSpendingTransaction(const CScript& scriptSig, const CScriptWitness& scriptWitness, const CTransaction& txCredit)\n {\n     CMutableTransaction txSpend;\n     txSpend.nVersion = 1;\n@@ -1003,663 +999,4 @@ BOOST_AUTO_TEST_CASE(script_json_test)\n     }\n }\n \n-BOOST_AUTO_TEST_CASE(script_PushData)\n-{\n-    // Check that PUSHDATA1, PUSHDATA2, and PUSHDATA4 create the same value on\n-    // the stack as the 1-75 opcodes do.\n-    static const unsigned char direct[] = { 1, 0x5a };\n-    static const unsigned char pushdata1[] = { OP_PUSHDATA1, 1, 0x5a };\n-    static const unsigned char pushdata2[] = { OP_PUSHDATA2, 1, 0, 0x5a };\n-    static const unsigned char pushdata4[] = { OP_PUSHDATA4, 1, 0, 0, 0, 0x5a };\n-\n-    ScriptError err;\n-    std::vector<std::vector<unsigned char> > directStack;\n-    BOOST_CHECK(EvalScript(directStack, CScript(direct, direct + sizeof(direct)), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SigVersion::BASE, &err));\n-    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n-\n-    std::vector<std::vector<unsigned char> > pushdata1Stack;\n-    BOOST_CHECK(EvalScript(pushdata1Stack, CScript(pushdata1, pushdata1 + sizeof(pushdata1)), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SigVersion::BASE, &err));\n-    BOOST_CHECK(pushdata1Stack == directStack);\n-    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n-\n-    std::vector<std::vector<unsigned char> > pushdata2Stack;\n-    BOOST_CHECK(EvalScript(pushdata2Stack, CScript(pushdata2, pushdata2 + sizeof(pushdata2)), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SigVersion::BASE, &err));\n-    BOOST_CHECK(pushdata2Stack == directStack);\n-    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n-\n-    std::vector<std::vector<unsigned char> > pushdata4Stack;\n-    BOOST_CHECK(EvalScript(pushdata4Stack, CScript(pushdata4, pushdata4 + sizeof(pushdata4)), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SigVersion::BASE, &err));\n-    BOOST_CHECK(pushdata4Stack == directStack);\n-    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n-\n-    const std::vector<unsigned char> pushdata1_trunc{OP_PUSHDATA1, 1};\n-    const std::vector<unsigned char> pushdata2_trunc{OP_PUSHDATA2, 1, 0};\n-    const std::vector<unsigned char> pushdata4_trunc{OP_PUSHDATA4, 1, 0, 0, 0};\n-\n-    std::vector<std::vector<unsigned char>> stack_ignore;\n-    BOOST_CHECK(!EvalScript(stack_ignore, CScript(pushdata1_trunc.begin(), pushdata1_trunc.end()), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SigVersion::BASE, &err));\n-    BOOST_CHECK_EQUAL(err, SCRIPT_ERR_BAD_OPCODE);\n-    BOOST_CHECK(!EvalScript(stack_ignore, CScript(pushdata2_trunc.begin(), pushdata2_trunc.end()), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SigVersion::BASE, &err));\n-    BOOST_CHECK_EQUAL(err, SCRIPT_ERR_BAD_OPCODE);\n-    BOOST_CHECK(!EvalScript(stack_ignore, CScript(pushdata4_trunc.begin(), pushdata4_trunc.end()), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SigVersion::BASE, &err));\n-    BOOST_CHECK_EQUAL(err, SCRIPT_ERR_BAD_OPCODE);\n-}\n-\n-BOOST_AUTO_TEST_CASE(script_cltv_truncated)\n-{\n-    const auto script_cltv_trunc = CScript() << OP_CHECKLOCKTIMEVERIFY;\n-\n-    std::vector<std::vector<unsigned char>> stack_ignore;\n-    ScriptError err;\n-    BOOST_CHECK(!EvalScript(stack_ignore, script_cltv_trunc, SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, BaseSignatureChecker(), SigVersion::BASE, &err));\n-    BOOST_CHECK_EQUAL(err, SCRIPT_ERR_INVALID_STACK_OPERATION);\n-}\n-\n-static CScript\n-sign_multisig(const CScript& scriptPubKey, const std::vector<CKey>& keys, const CTransaction& transaction)\n-{\n-    uint256 hash = SignatureHash(scriptPubKey, transaction, 0, SIGHASH_ALL, 0, SigVersion::BASE);\n-\n-    CScript result;\n-    //\n-    // NOTE: CHECKMULTISIG has an unfortunate bug; it requires\n-    // one extra item on the stack, before the signatures.\n-    // Putting OP_0 on the stack is the workaround;\n-    // fixing the bug would mean splitting the block chain (old\n-    // clients would not accept new CHECKMULTISIG transactions,\n-    // and vice-versa)\n-    //\n-    result << OP_0;\n-    for (const CKey &key : keys)\n-    {\n-        std::vector<unsigned char> vchSig;\n-        BOOST_CHECK(key.Sign(hash, vchSig));\n-        vchSig.push_back((unsigned char)SIGHASH_ALL);\n-        result << vchSig;\n-    }\n-    return result;\n-}\n-static CScript\n-sign_multisig(const CScript& scriptPubKey, const CKey& key, const CTransaction& transaction)\n-{\n-    std::vector<CKey> keys;\n-    keys.push_back(key);\n-    return sign_multisig(scriptPubKey, keys, transaction);\n-}\n-\n-BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG12)\n-{\n-    ScriptError err;\n-    CKey key1, key2, key3;\n-    key1.MakeNewKey(true);\n-    key2.MakeNewKey(false);\n-    key3.MakeNewKey(true);\n-\n-    CScript scriptPubKey12;\n-    scriptPubKey12 << OP_1 << ToByteVector(key1.GetPubKey()) << ToByteVector(key2.GetPubKey()) << OP_2 << OP_CHECKMULTISIG;\n-\n-    const CTransaction txFrom12{BuildCreditingTransaction(scriptPubKey12)};\n-    CMutableTransaction txTo12 = BuildSpendingTransaction(CScript(), CScriptWitness(), txFrom12);\n-\n-    CScript goodsig1 = sign_multisig(scriptPubKey12, key1, CTransaction(txTo12));\n-    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey12, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n-    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n-    txTo12.vout[0].nValue = 2;\n-    BOOST_CHECK(!VerifyScript(goodsig1, scriptPubKey12, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n-    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n-\n-    CScript goodsig2 = sign_multisig(scriptPubKey12, key2, CTransaction(txTo12));\n-    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey12, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n-    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n-\n-    CScript badsig1 = sign_multisig(scriptPubKey12, key3, CTransaction(txTo12));\n-    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey12, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n-    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n-}\n-\n-BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG23)\n-{\n-    ScriptError err;\n-    CKey key1, key2, key3, key4;\n-    key1.MakeNewKey(true);\n-    key2.MakeNewKey(false);\n-    key3.MakeNewKey(true);\n-    key4.MakeNewKey(false);\n-\n-    CScript scriptPubKey23;\n-    scriptPubKey23 << OP_2 << ToByteVector(key1.GetPubKey()) << ToByteVector(key2.GetPubKey()) << ToByteVector(key3.GetPubKey()) << OP_3 << OP_CHECKMULTISIG;\n-\n-    const CTransaction txFrom23{BuildCreditingTransaction(scriptPubKey23)};\n-    CMutableTransaction txTo23 = BuildSpendingTransaction(CScript(), CScriptWitness(), txFrom23);\n-\n-    std::vector<CKey> keys;\n-    keys.push_back(key1); keys.push_back(key2);\n-    CScript goodsig1 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n-    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n-    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n-\n-    keys.clear();\n-    keys.push_back(key1); keys.push_back(key3);\n-    CScript goodsig2 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n-    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n-    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n-\n-    keys.clear();\n-    keys.push_back(key2); keys.push_back(key3);\n-    CScript goodsig3 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n-    BOOST_CHECK(VerifyScript(goodsig3, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n-    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n-\n-    keys.clear();\n-    keys.push_back(key2); keys.push_back(key2); // Can't re-use sig\n-    CScript badsig1 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n-    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n-    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n-\n-    keys.clear();\n-    keys.push_back(key2); keys.push_back(key1); // sigs must be in correct order\n-    CScript badsig2 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n-    BOOST_CHECK(!VerifyScript(badsig2, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n-    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n-\n-    keys.clear();\n-    keys.push_back(key3); keys.push_back(key2); // sigs must be in correct order\n-    CScript badsig3 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n-    BOOST_CHECK(!VerifyScript(badsig3, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n-    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n-\n-    keys.clear();\n-    keys.push_back(key4); keys.push_back(key2); // sigs must match pubkeys\n-    CScript badsig4 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n-    BOOST_CHECK(!VerifyScript(badsig4, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n-    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n-\n-    keys.clear();\n-    keys.push_back(key1); keys.push_back(key4); // sigs must match pubkeys\n-    CScript badsig5 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n-    BOOST_CHECK(!VerifyScript(badsig5, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n-    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n-\n-    keys.clear(); // Must have signatures\n-    CScript badsig6 = sign_multisig(scriptPubKey23, keys, CTransaction(txTo23));\n-    BOOST_CHECK(!VerifyScript(badsig6, scriptPubKey23, nullptr, gFlags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n-    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_INVALID_STACK_OPERATION, ScriptErrorString(err));\n-}\n-\n-/* Wrapper around ProduceSignature to combine two scriptsigs */\n-SignatureData CombineSignatures(const CTxOut& txout, const CMutableTransaction& tx, const SignatureData& scriptSig1, const SignatureData& scriptSig2)\n-{\n-    SignatureData data;\n-    data.MergeSignatureData(scriptSig1);\n-    data.MergeSignatureData(scriptSig2);\n-    ProduceSignature(DUMMY_SIGNING_PROVIDER, MutableTransactionSignatureCreator(&tx, 0, txout.nValue), txout.scriptPubKey, data);\n-    return data;\n-}\n-\n-BOOST_AUTO_TEST_CASE(script_combineSigs)\n-{\n-    // Test the ProduceSignature's ability to combine signatures function\n-    CBasicKeyStore keystore;\n-    std::vector<CKey> keys;\n-    std::vector<CPubKey> pubkeys;\n-    for (int i = 0; i < 3; i++)\n-    {\n-        CKey key;\n-        key.MakeNewKey(i%2 == 1);\n-        keys.push_back(key);\n-        pubkeys.push_back(key.GetPubKey());\n-        BOOST_CHECK(keystore.AddKey(key));\n-    }\n-\n-    CMutableTransaction txFrom = BuildCreditingTransaction(GetScriptForDestination(PKHash(keys[0].GetPubKey())));\n-    CMutableTransaction txTo = BuildSpendingTransaction(CScript(), CScriptWitness(), CTransaction(txFrom));\n-    CScript& scriptPubKey = txFrom.vout[0].scriptPubKey;\n-    SignatureData scriptSig;\n-\n-    SignatureData empty;\n-    SignatureData combined = CombineSignatures(txFrom.vout[0], txTo, empty, empty);\n-    BOOST_CHECK(combined.scriptSig.empty());\n-\n-    // Single signature case:\n-    BOOST_CHECK(SignSignature(keystore, CTransaction(txFrom), txTo, 0, SIGHASH_ALL)); // changes scriptSig\n-    scriptSig = DataFromTransaction(txTo, 0, txFrom.vout[0]);\n-    combined = CombineSignatures(txFrom.vout[0], txTo, scriptSig, empty);\n-    BOOST_CHECK(combined.scriptSig == scriptSig.scriptSig);\n-    combined = CombineSignatures(txFrom.vout[0], txTo, empty, scriptSig);\n-    BOOST_CHECK(combined.scriptSig == scriptSig.scriptSig);\n-    SignatureData scriptSigCopy = scriptSig;\n-    // Signing again will give a different, valid signature:\n-    BOOST_CHECK(SignSignature(keystore, CTransaction(txFrom), txTo, 0, SIGHASH_ALL));\n-    scriptSig = DataFromTransaction(txTo, 0, txFrom.vout[0]);\n-    combined = CombineSignatures(txFrom.vout[0], txTo, scriptSigCopy, scriptSig);\n-    BOOST_CHECK(combined.scriptSig == scriptSigCopy.scriptSig || combined.scriptSig == scriptSig.scriptSig);\n-\n-    // P2SH, single-signature case:\n-    CScript pkSingle; pkSingle << ToByteVector(keys[0].GetPubKey()) << OP_CHECKSIG;\n-    BOOST_CHECK(keystore.AddCScript(pkSingle));\n-    scriptPubKey = GetScriptForDestination(ScriptHash(pkSingle));\n-    BOOST_CHECK(SignSignature(keystore, CTransaction(txFrom), txTo, 0, SIGHASH_ALL));\n-    scriptSig = DataFromTransaction(txTo, 0, txFrom.vout[0]);\n-    combined = CombineSignatures(txFrom.vout[0], txTo, scriptSig, empty);\n-    BOOST_CHECK(combined.scriptSig == scriptSig.scriptSig);\n-    combined = CombineSignatures(txFrom.vout[0], txTo, empty, scriptSig);\n-    BOOST_CHECK(combined.scriptSig == scriptSig.scriptSig);\n-    scriptSigCopy = scriptSig;\n-    BOOST_CHECK(SignSignature(keystore, CTransaction(txFrom), txTo, 0, SIGHASH_ALL));\n-    scriptSig = DataFromTransaction(txTo, 0, txFrom.vout[0]);\n-    combined = CombineSignatures(txFrom.vout[0], txTo, scriptSigCopy, scriptSig);\n-    BOOST_CHECK(combined.scriptSig == scriptSigCopy.scriptSig || combined.scriptSig == scriptSig.scriptSig);\n-\n-    // Hardest case:  Multisig 2-of-3\n-    scriptPubKey = GetScriptForMultisig(2, pubkeys);\n-    BOOST_CHECK(keystore.AddCScript(scriptPubKey));\n-    BOOST_CHECK(SignSignature(keystore, CTransaction(txFrom), txTo, 0, SIGHASH_ALL));\n-    scriptSig = DataFromTransaction(txTo, 0, txFrom.vout[0]);\n-    combined = CombineSignatures(txFrom.vout[0], txTo, scriptSig, empty);\n-    BOOST_CHECK(combined.scriptSig == scriptSig.scriptSig);\n-    combined = CombineSignatures(txFrom.vout[0], txTo, empty, scriptSig);\n-    BOOST_CHECK(combined.scriptSig == scriptSig.scriptSig);\n-\n-    // A couple of partially-signed versions:\n-    std::vector<unsigned char> sig1;\n-    uint256 hash1 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_ALL, 0, SigVersion::BASE);\n-    BOOST_CHECK(keys[0].Sign(hash1, sig1));\n-    sig1.push_back(SIGHASH_ALL);\n-    std::vector<unsigned char> sig2;\n-    uint256 hash2 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_NONE, 0, SigVersion::BASE);\n-    BOOST_CHECK(keys[1].Sign(hash2, sig2));\n-    sig2.push_back(SIGHASH_NONE);\n-    std::vector<unsigned char> sig3;\n-    uint256 hash3 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_SINGLE, 0, SigVersion::BASE);\n-    BOOST_CHECK(keys[2].Sign(hash3, sig3));\n-    sig3.push_back(SIGHASH_SINGLE);\n-\n-    // Not fussy about order (or even existence) of placeholders or signatures:\n-    CScript partial1a = CScript() << OP_0 << sig1 << OP_0;\n-    CScript partial1b = CScript() << OP_0 << OP_0 << sig1;\n-    CScript partial2a = CScript() << OP_0 << sig2;\n-    CScript partial2b = CScript() << sig2 << OP_0;\n-    CScript partial3a = CScript() << sig3;\n-    CScript partial3b = CScript() << OP_0 << OP_0 << sig3;\n-    CScript partial3c = CScript() << OP_0 << sig3 << OP_0;\n-    CScript complete12 = CScript() << OP_0 << sig1 << sig2;\n-    CScript complete13 = CScript() << OP_0 << sig1 << sig3;\n-    CScript complete23 = CScript() << OP_0 << sig2 << sig3;\n-    SignatureData partial1_sigs;\n-    partial1_sigs.signatures.emplace(keys[0].GetPubKey().GetID(), SigPair(keys[0].GetPubKey(), sig1));\n-    SignatureData partial2_sigs;\n-    partial2_sigs.signatures.emplace(keys[1].GetPubKey().GetID(), SigPair(keys[1].GetPubKey(), sig2));\n-    SignatureData partial3_sigs;\n-    partial3_sigs.signatures.emplace(keys[2].GetPubKey().GetID(), SigPair(keys[2].GetPubKey(), sig3));\n-\n-    combined = CombineSignatures(txFrom.vout[0], txTo, partial1_sigs, partial1_sigs);\n-    BOOST_CHECK(combined.scriptSig == partial1a);\n-    combined = CombineSignatures(txFrom.vout[0], txTo, partial1_sigs, partial2_sigs);\n-    BOOST_CHECK(combined.scriptSig == complete12);\n-    combined = CombineSignatures(txFrom.vout[0], txTo, partial2_sigs, partial1_sigs);\n-    BOOST_CHECK(combined.scriptSig == complete12);\n-    combined = CombineSignatures(txFrom.vout[0], txTo, partial1_sigs, partial2_sigs);\n-    BOOST_CHECK(combined.scriptSig == complete12);\n-    combined = CombineSignatures(txFrom.vout[0], txTo, partial3_sigs, partial1_sigs);\n-    BOOST_CHECK(combined.scriptSig == complete13);\n-    combined = CombineSignatures(txFrom.vout[0], txTo, partial2_sigs, partial3_sigs);\n-    BOOST_CHECK(combined.scriptSig == complete23);\n-    combined = CombineSignatures(txFrom.vout[0], txTo, partial3_sigs, partial2_sigs);\n-    BOOST_CHECK(combined.scriptSig == complete23);\n-    combined = CombineSignatures(txFrom.vout[0], txTo, partial3_sigs, partial3_sigs);\n-    BOOST_CHECK(combined.scriptSig == partial3c);\n-}\n-\n-BOOST_AUTO_TEST_CASE(script_standard_push)\n-{\n-    ScriptError err;\n-    for (int i=0; i<67000; i++) {\n-        CScript script;\n-        script << i;\n-        BOOST_CHECK_MESSAGE(script.IsPushOnly(), \"Number \" << i << \" is not pure push.\");\n-        BOOST_CHECK_MESSAGE(VerifyScript(script, CScript() << OP_1, nullptr, SCRIPT_VERIFY_MINIMALDATA, BaseSignatureChecker(), &err), \"Number \" << i << \" push is not minimal data.\");\n-        BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n-    }\n-\n-    for (unsigned int i=0; i<=MAX_SCRIPT_ELEMENT_SIZE; i++) {\n-        std::vector<unsigned char> data(i, '\\111');\n-        CScript script;\n-        script << data;\n-        BOOST_CHECK_MESSAGE(script.IsPushOnly(), \"Length \" << i << \" is not pure push.\");\n-        BOOST_CHECK_MESSAGE(VerifyScript(script, CScript() << OP_1, nullptr, SCRIPT_VERIFY_MINIMALDATA, BaseSignatureChecker(), &err), \"Length \" << i << \" push is not minimal data.\");\n-        BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n-    }\n-}\n-\n-BOOST_AUTO_TEST_CASE(script_IsPushOnly_on_invalid_scripts)\n-{\n-    // IsPushOnly returns false when given a script containing only pushes that\n-    // are invalid due to truncation. IsPushOnly() is consensus critical\n-    // because P2SH evaluation uses it, although this specific behavior should\n-    // not be consensus critical as the P2SH evaluation would fail first due to\n-    // the invalid push. Still, it doesn't hurt to test it explicitly.\n-    static const unsigned char direct[] = { 1 };\n-    BOOST_CHECK(!CScript(direct, direct+sizeof(direct)).IsPushOnly());\n-}\n-\n-BOOST_AUTO_TEST_CASE(script_GetScriptAsm)\n-{\n-    BOOST_CHECK_EQUAL(\"OP_CHECKLOCKTIMEVERIFY\", ScriptToAsmStr(CScript() << OP_NOP2, true));\n-    BOOST_CHECK_EQUAL(\"OP_CHECKLOCKTIMEVERIFY\", ScriptToAsmStr(CScript() << OP_CHECKLOCKTIMEVERIFY, true));\n-    BOOST_CHECK_EQUAL(\"OP_CHECKLOCKTIMEVERIFY\", ScriptToAsmStr(CScript() << OP_NOP2));\n-    BOOST_CHECK_EQUAL(\"OP_CHECKLOCKTIMEVERIFY\", ScriptToAsmStr(CScript() << OP_CHECKLOCKTIMEVERIFY));\n-\n-    std::string derSig(\"304502207fa7a6d1e0ee81132a269ad84e68d695483745cde8b541e3bf630749894e342a022100c1f7ab20e13e22fb95281a870f3dcf38d782e53023ee313d741ad0cfbc0c5090\");\n-    std::string pubKey(\"03b0da749730dc9b4b1f4a14d6902877a92541f5368778853d9c4a0cb7802dcfb2\");\n-    std::vector<unsigned char> vchPubKey = ToByteVector(ParseHex(pubKey));\n-\n-    BOOST_CHECK_EQUAL(derSig + \"00 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"00\")) << vchPubKey, true));\n-    BOOST_CHECK_EQUAL(derSig + \"80 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"80\")) << vchPubKey, true));\n-    BOOST_CHECK_EQUAL(derSig + \"[ALL] \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"01\")) << vchPubKey, true));\n-    BOOST_CHECK_EQUAL(derSig + \"[NONE] \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"02\")) << vchPubKey, true));\n-    BOOST_CHECK_EQUAL(derSig + \"[SINGLE] \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"03\")) << vchPubKey, true));\n-    BOOST_CHECK_EQUAL(derSig + \"[ALL|ANYONECANPAY] \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"81\")) << vchPubKey, true));\n-    BOOST_CHECK_EQUAL(derSig + \"[NONE|ANYONECANPAY] \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"82\")) << vchPubKey, true));\n-    BOOST_CHECK_EQUAL(derSig + \"[SINGLE|ANYONECANPAY] \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"83\")) << vchPubKey, true));\n-\n-    BOOST_CHECK_EQUAL(derSig + \"00 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"00\")) << vchPubKey));\n-    BOOST_CHECK_EQUAL(derSig + \"80 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"80\")) << vchPubKey));\n-    BOOST_CHECK_EQUAL(derSig + \"01 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"01\")) << vchPubKey));\n-    BOOST_CHECK_EQUAL(derSig + \"02 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"02\")) << vchPubKey));\n-    BOOST_CHECK_EQUAL(derSig + \"03 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"03\")) << vchPubKey));\n-    BOOST_CHECK_EQUAL(derSig + \"81 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"81\")) << vchPubKey));\n-    BOOST_CHECK_EQUAL(derSig + \"82 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"82\")) << vchPubKey));\n-    BOOST_CHECK_EQUAL(derSig + \"83 \" + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + \"83\")) << vchPubKey));\n-}\n-\n-static CScript\n-ScriptFromHex(const char* hex)\n-{\n-    std::vector<unsigned char> data = ParseHex(hex);\n-    return CScript(data.begin(), data.end());\n-}\n-\n-\n-BOOST_AUTO_TEST_CASE(script_FindAndDelete)\n-{\n-    // Exercise the FindAndDelete functionality\n-    CScript s;\n-    CScript d;\n-    CScript expect;\n-\n-    s = CScript() << OP_1 << OP_2;\n-    d = CScript(); // delete nothing should be a no-op\n-    expect = s;\n-    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 0);\n-    BOOST_CHECK(s == expect);\n-\n-    s = CScript() << OP_1 << OP_2 << OP_3;\n-    d = CScript() << OP_2;\n-    expect = CScript() << OP_1 << OP_3;\n-    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 1);\n-    BOOST_CHECK(s == expect);\n-\n-    s = CScript() << OP_3 << OP_1 << OP_3 << OP_3 << OP_4 << OP_3;\n-    d = CScript() << OP_3;\n-    expect = CScript() << OP_1 << OP_4;\n-    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 4);\n-    BOOST_CHECK(s == expect);\n-\n-    s = ScriptFromHex(\"0302ff03\"); // PUSH 0x02ff03 onto stack\n-    d = ScriptFromHex(\"0302ff03\");\n-    expect = CScript();\n-    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 1);\n-    BOOST_CHECK(s == expect);\n-\n-    s = ScriptFromHex(\"0302ff030302ff03\"); // PUSH 0x2ff03 PUSH 0x2ff03\n-    d = ScriptFromHex(\"0302ff03\");\n-    expect = CScript();\n-    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 2);\n-    BOOST_CHECK(s == expect);\n-\n-    s = ScriptFromHex(\"0302ff030302ff03\");\n-    d = ScriptFromHex(\"02\");\n-    expect = s; // FindAndDelete matches entire opcodes\n-    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 0);\n-    BOOST_CHECK(s == expect);\n-\n-    s = ScriptFromHex(\"0302ff030302ff03\");\n-    d = ScriptFromHex(\"ff\");\n-    expect = s;\n-    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 0);\n-    BOOST_CHECK(s == expect);\n-\n-    // This is an odd edge case: strip of the push-three-bytes\n-    // prefix, leaving 02ff03 which is push-two-bytes:\n-    s = ScriptFromHex(\"0302ff030302ff03\");\n-    d = ScriptFromHex(\"03\");\n-    expect = CScript() << ParseHex(\"ff03\") << ParseHex(\"ff03\");\n-    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 2);\n-    BOOST_CHECK(s == expect);\n-\n-    // Byte sequence that spans multiple opcodes:\n-    s = ScriptFromHex(\"02feed5169\"); // PUSH(0xfeed) OP_1 OP_VERIFY\n-    d = ScriptFromHex(\"feed51\");\n-    expect = s;\n-    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 0); // doesn't match 'inside' opcodes\n-    BOOST_CHECK(s == expect);\n-\n-    s = ScriptFromHex(\"02feed5169\"); // PUSH(0xfeed) OP_1 OP_VERIFY\n-    d = ScriptFromHex(\"02feed51\");\n-    expect = ScriptFromHex(\"69\");\n-    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 1);\n-    BOOST_CHECK(s == expect);\n-\n-    s = ScriptFromHex(\"516902feed5169\");\n-    d = ScriptFromHex(\"feed51\");\n-    expect = s;\n-    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 0);\n-    BOOST_CHECK(s == expect);\n-\n-    s = ScriptFromHex(\"516902feed5169\");\n-    d = ScriptFromHex(\"02feed51\");\n-    expect = ScriptFromHex(\"516969\");\n-    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 1);\n-    BOOST_CHECK(s == expect);\n-\n-    s = CScript() << OP_0 << OP_0 << OP_1 << OP_1;\n-    d = CScript() << OP_0 << OP_1;\n-    expect = CScript() << OP_0 << OP_1; // FindAndDelete is single-pass\n-    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 1);\n-    BOOST_CHECK(s == expect);\n-\n-    s = CScript() << OP_0 << OP_0 << OP_1 << OP_0 << OP_1 << OP_1;\n-    d = CScript() << OP_0 << OP_1;\n-    expect = CScript() << OP_0 << OP_1; // FindAndDelete is single-pass\n-    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 2);\n-    BOOST_CHECK(s == expect);\n-\n-    // Another weird edge case:\n-    // End with invalid push (not enough data)...\n-    s = ScriptFromHex(\"0003feed\");\n-    d = ScriptFromHex(\"03feed\"); // ... can remove the invalid push\n-    expect = ScriptFromHex(\"00\");\n-    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 1);\n-    BOOST_CHECK(s == expect);\n-\n-    s = ScriptFromHex(\"0003feed\");\n-    d = ScriptFromHex(\"00\");\n-    expect = ScriptFromHex(\"03feed\");\n-    BOOST_CHECK_EQUAL(FindAndDelete(s, d), 1);\n-    BOOST_CHECK(s == expect);\n-}\n-\n-BOOST_AUTO_TEST_CASE(script_HasValidOps)\n-{\n-    // Exercise the HasValidOps functionality\n-    CScript script;\n-    script = ScriptFromHex(\"76a9141234567890abcdefa1a2a3a4a5a6a7a8a9a0aaab88ac\"); // Normal script\n-    BOOST_CHECK(script.HasValidOps());\n-    script = ScriptFromHex(\"76a914ff34567890abcdefa1a2a3a4a5a6a7a8a9a0aaab88ac\");\n-    BOOST_CHECK(script.HasValidOps());\n-    script = ScriptFromHex(\"ff88ac\"); // Script with OP_INVALIDOPCODE explicit\n-    BOOST_CHECK(!script.HasValidOps());\n-    script = ScriptFromHex(\"88acc0\"); // Script with undefined opcode\n-    BOOST_CHECK(!script.HasValidOps());\n-}\n-\n-BOOST_AUTO_TEST_CASE(script_can_append_self)\n-{\n-    CScript s, d;\n-\n-    s = ScriptFromHex(\"00\");\n-    s += s;\n-    d = ScriptFromHex(\"0000\");\n-    BOOST_CHECK(s == d);\n-\n-    // check doubling a script that's large enough to require reallocation\n-    static const char hex[] = \"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f\";\n-    s = CScript() << ParseHex(hex) << OP_CHECKSIG;\n-    d = CScript() << ParseHex(hex) << OP_CHECKSIG << ParseHex(hex) << OP_CHECKSIG;\n-    s += s;\n-    BOOST_CHECK(s == d);\n-}\n-\n-\n-#if defined(HAVE_CONSENSUS_LIB)\n-\n-/* Test simple (successful) usage of bitcoinconsensus_verify_script */\n-BOOST_AUTO_TEST_CASE(bitcoinconsensus_verify_script_returns_true)\n-{\n-    unsigned int libconsensus_flags = 0;\n-    int nIn = 0;\n-\n-    CScript scriptPubKey;\n-    CScript scriptSig;\n-    CScriptWitness wit;\n-\n-    scriptPubKey << OP_1;\n-    CTransaction creditTx = BuildCreditingTransaction(scriptPubKey, 1);\n-    CTransaction spendTx = BuildSpendingTransaction(scriptSig, wit, creditTx);\n-\n-    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n-    stream << spendTx;\n-\n-    bitcoinconsensus_error err;\n-    int result = bitcoinconsensus_verify_script(scriptPubKey.data(), scriptPubKey.size(), (const unsigned char*)&stream[0], stream.size(), nIn, libconsensus_flags, &err);\n-    BOOST_CHECK_EQUAL(result, 1);\n-    BOOST_CHECK_EQUAL(err, bitcoinconsensus_ERR_OK);\n-}\n-\n-/* Test bitcoinconsensus_verify_script returns invalid tx index err*/\n-BOOST_AUTO_TEST_CASE(bitcoinconsensus_verify_script_tx_index_err)\n-{\n-    unsigned int libconsensus_flags = 0;\n-    int nIn = 3;\n-\n-    CScript scriptPubKey;\n-    CScript scriptSig;\n-    CScriptWitness wit;\n-\n-    scriptPubKey << OP_EQUAL;\n-    CTransaction creditTx = BuildCreditingTransaction(scriptPubKey, 1);\n-    CTransaction spendTx = BuildSpendingTransaction(scriptSig, wit, creditTx);\n-\n-    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n-    stream << spendTx;\n-\n-    bitcoinconsensus_error err;\n-    int result = bitcoinconsensus_verify_script(scriptPubKey.data(), scriptPubKey.size(), (const unsigned char*)&stream[0], stream.size(), nIn, libconsensus_flags, &err);\n-    BOOST_CHECK_EQUAL(result, 0);\n-    BOOST_CHECK_EQUAL(err, bitcoinconsensus_ERR_TX_INDEX);\n-}\n-\n-/* Test bitcoinconsensus_verify_script returns tx size mismatch err*/\n-BOOST_AUTO_TEST_CASE(bitcoinconsensus_verify_script_tx_size)\n-{\n-    unsigned int libconsensus_flags = 0;\n-    int nIn = 0;\n-\n-    CScript scriptPubKey;\n-    CScript scriptSig;\n-    CScriptWitness wit;\n-\n-    scriptPubKey << OP_EQUAL;\n-    CTransaction creditTx = BuildCreditingTransaction(scriptPubKey, 1);\n-    CTransaction spendTx = BuildSpendingTransaction(scriptSig, wit, creditTx);\n-\n-    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n-    stream << spendTx;\n-\n-    bitcoinconsensus_error err;\n-    int result = bitcoinconsensus_verify_script(scriptPubKey.data(), scriptPubKey.size(), (const unsigned char*)&stream[0], stream.size() * 2, nIn, libconsensus_flags, &err);\n-    BOOST_CHECK_EQUAL(result, 0);\n-    BOOST_CHECK_EQUAL(err, bitcoinconsensus_ERR_TX_SIZE_MISMATCH);\n-}\n-\n-/* Test bitcoinconsensus_verify_script returns invalid tx serialization error */\n-BOOST_AUTO_TEST_CASE(bitcoinconsensus_verify_script_tx_serialization)\n-{\n-    unsigned int libconsensus_flags = 0;\n-    int nIn = 0;\n-\n-    CScript scriptPubKey;\n-    CScript scriptSig;\n-    CScriptWitness wit;\n-\n-    scriptPubKey << OP_EQUAL;\n-    CTransaction creditTx = BuildCreditingTransaction(scriptPubKey, 1);\n-    CTransaction spendTx = BuildSpendingTransaction(scriptSig, wit, creditTx);\n-\n-    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n-    stream << 0xffffffff;\n-\n-    bitcoinconsensus_error err;\n-    int result = bitcoinconsensus_verify_script(scriptPubKey.data(), scriptPubKey.size(), (const unsigned char*)&stream[0], stream.size(), nIn, libconsensus_flags, &err);\n-    BOOST_CHECK_EQUAL(result, 0);\n-    BOOST_CHECK_EQUAL(err, bitcoinconsensus_ERR_TX_DESERIALIZE);\n-}\n-\n-/* Test bitcoinconsensus_verify_script returns amount required error */\n-BOOST_AUTO_TEST_CASE(bitcoinconsensus_verify_script_amount_required_err)\n-{\n-    unsigned int libconsensus_flags = bitcoinconsensus_SCRIPT_FLAGS_VERIFY_WITNESS;\n-    int nIn = 0;\n-\n-    CScript scriptPubKey;\n-    CScript scriptSig;\n-    CScriptWitness wit;\n-\n-    scriptPubKey << OP_EQUAL;\n-    CTransaction creditTx = BuildCreditingTransaction(scriptPubKey, 1);\n-    CTransaction spendTx = BuildSpendingTransaction(scriptSig, wit, creditTx);\n-\n-    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n-    stream << spendTx;\n-\n-    bitcoinconsensus_error err;\n-    int result = bitcoinconsensus_verify_script(scriptPubKey.data(), scriptPubKey.size(), (const unsigned char*)&stream[0], stream.size(), nIn, libconsensus_flags, &err);\n-    BOOST_CHECK_EQUAL(result, 0);\n-    BOOST_CHECK_EQUAL(err, bitcoinconsensus_ERR_AMOUNT_REQUIRED);\n-}\n-\n-/* Test bitcoinconsensus_verify_script returns invalid flags err */\n-BOOST_AUTO_TEST_CASE(bitcoinconsensus_verify_script_invalid_flags)\n-{\n-    unsigned int libconsensus_flags = 1 << 3;\n-    int nIn = 0;\n-\n-    CScript scriptPubKey;\n-    CScript scriptSig;\n-    CScriptWitness wit;\n-\n-    scriptPubKey << OP_EQUAL;\n-    CTransaction creditTx = BuildCreditingTransaction(scriptPubKey, 1);\n-    CTransaction spendTx = BuildSpendingTransaction(scriptSig, wit, creditTx);\n-\n-    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n-    stream << spendTx;\n-\n-    bitcoinconsensus_error err;\n-    int result = bitcoinconsensus_verify_script(scriptPubKey.data(), scriptPubKey.size(), (const unsigned char*)&stream[0], stream.size(), nIn, libconsensus_flags, &err);\n-    BOOST_CHECK_EQUAL(result, 0);\n-    BOOST_CHECK_EQUAL(err, bitcoinconsensus_ERR_INVALID_FLAGS);\n-}\n-\n-#endif\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "1dbba7ba99537f03632f56b639b1c25c74a516cf",
        "filename": "src/test/util_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 747,
        "changes": 747,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fabf534b2de6a2a261dff704d6f2c980ef54f26f/src/test/util_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fabf534b2de6a2a261dff704d6f2c980ef54f26f/src/test/util_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util_tests.cpp?ref=fabf534b2de6a2a261dff704d6f2c980ef54f26f",
        "patch": "@@ -132,753 +132,6 @@ BOOST_AUTO_TEST_CASE(util_FormatISO8601Date)\n     BOOST_CHECK_EQUAL(FormatISO8601Date(1317425777), \"2011-09-30\");\n }\n \n-struct TestArgsManager : public ArgsManager\n-{\n-    TestArgsManager() { m_network_only_args.clear(); }\n-    std::map<std::string, std::vector<std::string> >& GetOverrideArgs() { return m_override_args; }\n-    std::map<std::string, std::vector<std::string> >& GetConfigArgs() { return m_config_args; }\n-    void ReadConfigString(const std::string str_config)\n-    {\n-        std::istringstream streamConfig(str_config);\n-        {\n-            LOCK(cs_args);\n-            m_config_args.clear();\n-            m_config_sections.clear();\n-        }\n-        std::string error;\n-        BOOST_REQUIRE(ReadConfigStream(streamConfig, \"\", error));\n-    }\n-    void SetNetworkOnlyArg(const std::string arg)\n-    {\n-        LOCK(cs_args);\n-        m_network_only_args.insert(arg);\n-    }\n-    void SetupArgs(int argv, const char* args[])\n-    {\n-        for (int i = 0; i < argv; ++i) {\n-            AddArg(args[i], \"\", false, OptionsCategory::OPTIONS);\n-        }\n-    }\n-    using ArgsManager::ReadConfigStream;\n-    using ArgsManager::cs_args;\n-    using ArgsManager::m_network;\n-};\n-\n-BOOST_AUTO_TEST_CASE(util_ParseParameters)\n-{\n-    TestArgsManager testArgs;\n-    const char* avail_args[] = {\"-a\", \"-b\", \"-ccc\", \"-d\"};\n-    const char *argv_test[] = {\"-ignored\", \"-a\", \"-b\", \"-ccc=argument\", \"-ccc=multiple\", \"f\", \"-d=e\"};\n-\n-    std::string error;\n-    testArgs.SetupArgs(4, avail_args);\n-    BOOST_CHECK(testArgs.ParseParameters(0, (char**)argv_test, error));\n-    BOOST_CHECK(testArgs.GetOverrideArgs().empty() && testArgs.GetConfigArgs().empty());\n-\n-    BOOST_CHECK(testArgs.ParseParameters(1, (char**)argv_test, error));\n-    BOOST_CHECK(testArgs.GetOverrideArgs().empty() && testArgs.GetConfigArgs().empty());\n-\n-    BOOST_CHECK(testArgs.ParseParameters(7, (char**)argv_test, error));\n-    // expectation: -ignored is ignored (program name argument),\n-    // -a, -b and -ccc end up in map, -d ignored because it is after\n-    // a non-option argument (non-GNU option parsing)\n-    BOOST_CHECK(testArgs.GetOverrideArgs().size() == 3 && testArgs.GetConfigArgs().empty());\n-    BOOST_CHECK(testArgs.IsArgSet(\"-a\") && testArgs.IsArgSet(\"-b\") && testArgs.IsArgSet(\"-ccc\")\n-                && !testArgs.IsArgSet(\"f\") && !testArgs.IsArgSet(\"-d\"));\n-    BOOST_CHECK(testArgs.GetOverrideArgs().count(\"-a\") && testArgs.GetOverrideArgs().count(\"-b\") && testArgs.GetOverrideArgs().count(\"-ccc\")\n-                && !testArgs.GetOverrideArgs().count(\"f\") && !testArgs.GetOverrideArgs().count(\"-d\"));\n-\n-    BOOST_CHECK(testArgs.GetOverrideArgs()[\"-a\"].size() == 1);\n-    BOOST_CHECK(testArgs.GetOverrideArgs()[\"-a\"].front() == \"\");\n-    BOOST_CHECK(testArgs.GetOverrideArgs()[\"-ccc\"].size() == 2);\n-    BOOST_CHECK(testArgs.GetOverrideArgs()[\"-ccc\"].front() == \"argument\");\n-    BOOST_CHECK(testArgs.GetOverrideArgs()[\"-ccc\"].back() == \"multiple\");\n-    BOOST_CHECK(testArgs.GetArgs(\"-ccc\").size() == 2);\n-}\n-\n-BOOST_AUTO_TEST_CASE(util_GetBoolArg)\n-{\n-    TestArgsManager testArgs;\n-    const char* avail_args[] = {\"-a\", \"-b\", \"-c\", \"-d\", \"-e\", \"-f\"};\n-    const char *argv_test[] = {\n-        \"ignored\", \"-a\", \"-nob\", \"-c=0\", \"-d=1\", \"-e=false\", \"-f=true\"};\n-    std::string error;\n-    testArgs.SetupArgs(6, avail_args);\n-    BOOST_CHECK(testArgs.ParseParameters(7, (char**)argv_test, error));\n-\n-    // Each letter should be set.\n-    for (const char opt : \"abcdef\")\n-        BOOST_CHECK(testArgs.IsArgSet({'-', opt}) || !opt);\n-\n-    // Nothing else should be in the map\n-    BOOST_CHECK(testArgs.GetOverrideArgs().size() == 6 &&\n-                testArgs.GetConfigArgs().empty());\n-\n-    // The -no prefix should get stripped on the way in.\n-    BOOST_CHECK(!testArgs.IsArgSet(\"-nob\"));\n-\n-    // The -b option is flagged as negated, and nothing else is\n-    BOOST_CHECK(testArgs.IsArgNegated(\"-b\"));\n-    BOOST_CHECK(!testArgs.IsArgNegated(\"-a\"));\n-\n-    // Check expected values.\n-    BOOST_CHECK(testArgs.GetBoolArg(\"-a\", false) == true);\n-    BOOST_CHECK(testArgs.GetBoolArg(\"-b\", true) == false);\n-    BOOST_CHECK(testArgs.GetBoolArg(\"-c\", true) == false);\n-    BOOST_CHECK(testArgs.GetBoolArg(\"-d\", false) == true);\n-    BOOST_CHECK(testArgs.GetBoolArg(\"-e\", true) == false);\n-    BOOST_CHECK(testArgs.GetBoolArg(\"-f\", true) == false);\n-}\n-\n-BOOST_AUTO_TEST_CASE(util_GetBoolArgEdgeCases)\n-{\n-    // Test some awful edge cases that hopefully no user will ever exercise.\n-    TestArgsManager testArgs;\n-\n-    // Params test\n-    const char* avail_args[] = {\"-foo\", \"-bar\"};\n-    const char *argv_test[] = {\"ignored\", \"-nofoo\", \"-foo\", \"-nobar=0\"};\n-    testArgs.SetupArgs(2, avail_args);\n-    std::string error;\n-    BOOST_CHECK(testArgs.ParseParameters(4, (char**)argv_test, error));\n-\n-    // This was passed twice, second one overrides the negative setting.\n-    BOOST_CHECK(!testArgs.IsArgNegated(\"-foo\"));\n-    BOOST_CHECK(testArgs.GetArg(\"-foo\", \"xxx\") == \"\");\n-\n-    // A double negative is a positive, and not marked as negated.\n-    BOOST_CHECK(!testArgs.IsArgNegated(\"-bar\"));\n-    BOOST_CHECK(testArgs.GetArg(\"-bar\", \"xxx\") == \"1\");\n-\n-    // Config test\n-    const char *conf_test = \"nofoo=1\\nfoo=1\\nnobar=0\\n\";\n-    BOOST_CHECK(testArgs.ParseParameters(1, (char**)argv_test, error));\n-    testArgs.ReadConfigString(conf_test);\n-\n-    // This was passed twice, second one overrides the negative setting,\n-    // and the value.\n-    BOOST_CHECK(!testArgs.IsArgNegated(\"-foo\"));\n-    BOOST_CHECK(testArgs.GetArg(\"-foo\", \"xxx\") == \"1\");\n-\n-    // A double negative is a positive, and does not count as negated.\n-    BOOST_CHECK(!testArgs.IsArgNegated(\"-bar\"));\n-    BOOST_CHECK(testArgs.GetArg(\"-bar\", \"xxx\") == \"1\");\n-\n-    // Combined test\n-    const char *combo_test_args[] = {\"ignored\", \"-nofoo\", \"-bar\"};\n-    const char *combo_test_conf = \"foo=1\\nnobar=1\\n\";\n-    BOOST_CHECK(testArgs.ParseParameters(3, (char**)combo_test_args, error));\n-    testArgs.ReadConfigString(combo_test_conf);\n-\n-    // Command line overrides, but doesn't erase old setting\n-    BOOST_CHECK(testArgs.IsArgNegated(\"-foo\"));\n-    BOOST_CHECK(testArgs.GetArg(\"-foo\", \"xxx\") == \"0\");\n-    BOOST_CHECK(testArgs.GetArgs(\"-foo\").size() == 0);\n-\n-    // Command line overrides, but doesn't erase old setting\n-    BOOST_CHECK(!testArgs.IsArgNegated(\"-bar\"));\n-    BOOST_CHECK(testArgs.GetArg(\"-bar\", \"xxx\") == \"\");\n-    BOOST_CHECK(testArgs.GetArgs(\"-bar\").size() == 1\n-                && testArgs.GetArgs(\"-bar\").front() == \"\");\n-}\n-\n-BOOST_AUTO_TEST_CASE(util_ReadConfigStream)\n-{\n-    const char *str_config =\n-       \"a=\\n\"\n-       \"b=1\\n\"\n-       \"ccc=argument\\n\"\n-       \"ccc=multiple\\n\"\n-       \"d=e\\n\"\n-       \"nofff=1\\n\"\n-       \"noggg=0\\n\"\n-       \"h=1\\n\"\n-       \"noh=1\\n\"\n-       \"noi=1\\n\"\n-       \"i=1\\n\"\n-       \"sec1.ccc=extend1\\n\"\n-       \"\\n\"\n-       \"[sec1]\\n\"\n-       \"ccc=extend2\\n\"\n-       \"d=eee\\n\"\n-       \"h=1\\n\"\n-       \"[sec2]\\n\"\n-       \"ccc=extend3\\n\"\n-       \"iii=2\\n\";\n-\n-    TestArgsManager test_args;\n-    const char* avail_args[] = {\"-a\", \"-b\", \"-ccc\", \"-d\", \"-e\", \"-fff\", \"-ggg\", \"-h\", \"-i\", \"-iii\"};\n-    test_args.SetupArgs(10, avail_args);\n-\n-    test_args.ReadConfigString(str_config);\n-    // expectation: a, b, ccc, d, fff, ggg, h, i end up in map\n-    // so do sec1.ccc, sec1.d, sec1.h, sec2.ccc, sec2.iii\n-\n-    BOOST_CHECK(test_args.GetOverrideArgs().empty());\n-    BOOST_CHECK(test_args.GetConfigArgs().size() == 13);\n-\n-    BOOST_CHECK(test_args.GetConfigArgs().count(\"-a\")\n-                && test_args.GetConfigArgs().count(\"-b\")\n-                && test_args.GetConfigArgs().count(\"-ccc\")\n-                && test_args.GetConfigArgs().count(\"-d\")\n-                && test_args.GetConfigArgs().count(\"-fff\")\n-                && test_args.GetConfigArgs().count(\"-ggg\")\n-                && test_args.GetConfigArgs().count(\"-h\")\n-                && test_args.GetConfigArgs().count(\"-i\")\n-               );\n-    BOOST_CHECK(test_args.GetConfigArgs().count(\"-sec1.ccc\")\n-                && test_args.GetConfigArgs().count(\"-sec1.h\")\n-                && test_args.GetConfigArgs().count(\"-sec2.ccc\")\n-                && test_args.GetConfigArgs().count(\"-sec2.iii\")\n-               );\n-\n-    BOOST_CHECK(test_args.IsArgSet(\"-a\")\n-                && test_args.IsArgSet(\"-b\")\n-                && test_args.IsArgSet(\"-ccc\")\n-                && test_args.IsArgSet(\"-d\")\n-                && test_args.IsArgSet(\"-fff\")\n-                && test_args.IsArgSet(\"-ggg\")\n-                && test_args.IsArgSet(\"-h\")\n-                && test_args.IsArgSet(\"-i\")\n-                && !test_args.IsArgSet(\"-zzz\")\n-                && !test_args.IsArgSet(\"-iii\")\n-               );\n-\n-    BOOST_CHECK(test_args.GetArg(\"-a\", \"xxx\") == \"\"\n-                && test_args.GetArg(\"-b\", \"xxx\") == \"1\"\n-                && test_args.GetArg(\"-ccc\", \"xxx\") == \"argument\"\n-                && test_args.GetArg(\"-d\", \"xxx\") == \"e\"\n-                && test_args.GetArg(\"-fff\", \"xxx\") == \"0\"\n-                && test_args.GetArg(\"-ggg\", \"xxx\") == \"1\"\n-                && test_args.GetArg(\"-h\", \"xxx\") == \"0\"\n-                && test_args.GetArg(\"-i\", \"xxx\") == \"1\"\n-                && test_args.GetArg(\"-zzz\", \"xxx\") == \"xxx\"\n-                && test_args.GetArg(\"-iii\", \"xxx\") == \"xxx\"\n-               );\n-\n-    for (const bool def : {false, true}) {\n-        BOOST_CHECK(test_args.GetBoolArg(\"-a\", def)\n-                     && test_args.GetBoolArg(\"-b\", def)\n-                     && !test_args.GetBoolArg(\"-ccc\", def)\n-                     && !test_args.GetBoolArg(\"-d\", def)\n-                     && !test_args.GetBoolArg(\"-fff\", def)\n-                     && test_args.GetBoolArg(\"-ggg\", def)\n-                     && !test_args.GetBoolArg(\"-h\", def)\n-                     && test_args.GetBoolArg(\"-i\", def)\n-                     && test_args.GetBoolArg(\"-zzz\", def) == def\n-                     && test_args.GetBoolArg(\"-iii\", def) == def\n-                   );\n-    }\n-\n-    BOOST_CHECK(test_args.GetArgs(\"-a\").size() == 1\n-                && test_args.GetArgs(\"-a\").front() == \"\");\n-    BOOST_CHECK(test_args.GetArgs(\"-b\").size() == 1\n-                && test_args.GetArgs(\"-b\").front() == \"1\");\n-    BOOST_CHECK(test_args.GetArgs(\"-ccc\").size() == 2\n-                && test_args.GetArgs(\"-ccc\").front() == \"argument\"\n-                && test_args.GetArgs(\"-ccc\").back() == \"multiple\");\n-    BOOST_CHECK(test_args.GetArgs(\"-fff\").size() == 0);\n-    BOOST_CHECK(test_args.GetArgs(\"-nofff\").size() == 0);\n-    BOOST_CHECK(test_args.GetArgs(\"-ggg\").size() == 1\n-                && test_args.GetArgs(\"-ggg\").front() == \"1\");\n-    BOOST_CHECK(test_args.GetArgs(\"-noggg\").size() == 0);\n-    BOOST_CHECK(test_args.GetArgs(\"-h\").size() == 0);\n-    BOOST_CHECK(test_args.GetArgs(\"-noh\").size() == 0);\n-    BOOST_CHECK(test_args.GetArgs(\"-i\").size() == 1\n-                && test_args.GetArgs(\"-i\").front() == \"1\");\n-    BOOST_CHECK(test_args.GetArgs(\"-noi\").size() == 0);\n-    BOOST_CHECK(test_args.GetArgs(\"-zzz\").size() == 0);\n-\n-    BOOST_CHECK(!test_args.IsArgNegated(\"-a\"));\n-    BOOST_CHECK(!test_args.IsArgNegated(\"-b\"));\n-    BOOST_CHECK(!test_args.IsArgNegated(\"-ccc\"));\n-    BOOST_CHECK(!test_args.IsArgNegated(\"-d\"));\n-    BOOST_CHECK(test_args.IsArgNegated(\"-fff\"));\n-    BOOST_CHECK(!test_args.IsArgNegated(\"-ggg\"));\n-    BOOST_CHECK(test_args.IsArgNegated(\"-h\")); // last setting takes precedence\n-    BOOST_CHECK(!test_args.IsArgNegated(\"-i\")); // last setting takes precedence\n-    BOOST_CHECK(!test_args.IsArgNegated(\"-zzz\"));\n-\n-    // Test sections work\n-    test_args.SelectConfigNetwork(\"sec1\");\n-\n-    // same as original\n-    BOOST_CHECK(test_args.GetArg(\"-a\", \"xxx\") == \"\"\n-                && test_args.GetArg(\"-b\", \"xxx\") == \"1\"\n-                && test_args.GetArg(\"-fff\", \"xxx\") == \"0\"\n-                && test_args.GetArg(\"-ggg\", \"xxx\") == \"1\"\n-                && test_args.GetArg(\"-zzz\", \"xxx\") == \"xxx\"\n-                && test_args.GetArg(\"-iii\", \"xxx\") == \"xxx\"\n-               );\n-    // d is overridden\n-    BOOST_CHECK(test_args.GetArg(\"-d\", \"xxx\") == \"eee\");\n-    // section-specific setting\n-    BOOST_CHECK(test_args.GetArg(\"-h\", \"xxx\") == \"1\");\n-    // section takes priority for multiple values\n-    BOOST_CHECK(test_args.GetArg(\"-ccc\", \"xxx\") == \"extend1\");\n-    // check multiple values works\n-    const std::vector<std::string> sec1_ccc_expected = {\"extend1\",\"extend2\",\"argument\",\"multiple\"};\n-    const auto& sec1_ccc_res = test_args.GetArgs(\"-ccc\");\n-    BOOST_CHECK_EQUAL_COLLECTIONS(sec1_ccc_res.begin(), sec1_ccc_res.end(), sec1_ccc_expected.begin(), sec1_ccc_expected.end());\n-\n-    test_args.SelectConfigNetwork(\"sec2\");\n-\n-    // same as original\n-    BOOST_CHECK(test_args.GetArg(\"-a\", \"xxx\") == \"\"\n-                && test_args.GetArg(\"-b\", \"xxx\") == \"1\"\n-                && test_args.GetArg(\"-d\", \"xxx\") == \"e\"\n-                && test_args.GetArg(\"-fff\", \"xxx\") == \"0\"\n-                && test_args.GetArg(\"-ggg\", \"xxx\") == \"1\"\n-                && test_args.GetArg(\"-zzz\", \"xxx\") == \"xxx\"\n-                && test_args.GetArg(\"-h\", \"xxx\") == \"0\"\n-               );\n-    // section-specific setting\n-    BOOST_CHECK(test_args.GetArg(\"-iii\", \"xxx\") == \"2\");\n-    // section takes priority for multiple values\n-    BOOST_CHECK(test_args.GetArg(\"-ccc\", \"xxx\") == \"extend3\");\n-    // check multiple values works\n-    const std::vector<std::string> sec2_ccc_expected = {\"extend3\",\"argument\",\"multiple\"};\n-    const auto& sec2_ccc_res = test_args.GetArgs(\"-ccc\");\n-    BOOST_CHECK_EQUAL_COLLECTIONS(sec2_ccc_res.begin(), sec2_ccc_res.end(), sec2_ccc_expected.begin(), sec2_ccc_expected.end());\n-\n-    // Test section only options\n-\n-    test_args.SetNetworkOnlyArg(\"-d\");\n-    test_args.SetNetworkOnlyArg(\"-ccc\");\n-    test_args.SetNetworkOnlyArg(\"-h\");\n-\n-    test_args.SelectConfigNetwork(CBaseChainParams::MAIN);\n-    BOOST_CHECK(test_args.GetArg(\"-d\", \"xxx\") == \"e\");\n-    BOOST_CHECK(test_args.GetArgs(\"-ccc\").size() == 2);\n-    BOOST_CHECK(test_args.GetArg(\"-h\", \"xxx\") == \"0\");\n-\n-    test_args.SelectConfigNetwork(\"sec1\");\n-    BOOST_CHECK(test_args.GetArg(\"-d\", \"xxx\") == \"eee\");\n-    BOOST_CHECK(test_args.GetArgs(\"-d\").size() == 1);\n-    BOOST_CHECK(test_args.GetArgs(\"-ccc\").size() == 2);\n-    BOOST_CHECK(test_args.GetArg(\"-h\", \"xxx\") == \"1\");\n-\n-    test_args.SelectConfigNetwork(\"sec2\");\n-    BOOST_CHECK(test_args.GetArg(\"-d\", \"xxx\") == \"xxx\");\n-    BOOST_CHECK(test_args.GetArgs(\"-d\").size() == 0);\n-    BOOST_CHECK(test_args.GetArgs(\"-ccc\").size() == 1);\n-    BOOST_CHECK(test_args.GetArg(\"-h\", \"xxx\") == \"0\");\n-}\n-\n-BOOST_AUTO_TEST_CASE(util_GetArg)\n-{\n-    TestArgsManager testArgs;\n-    testArgs.GetOverrideArgs().clear();\n-    testArgs.GetOverrideArgs()[\"strtest1\"] = {\"string...\"};\n-    // strtest2 undefined on purpose\n-    testArgs.GetOverrideArgs()[\"inttest1\"] = {\"12345\"};\n-    testArgs.GetOverrideArgs()[\"inttest2\"] = {\"81985529216486895\"};\n-    // inttest3 undefined on purpose\n-    testArgs.GetOverrideArgs()[\"booltest1\"] = {\"\"};\n-    // booltest2 undefined on purpose\n-    testArgs.GetOverrideArgs()[\"booltest3\"] = {\"0\"};\n-    testArgs.GetOverrideArgs()[\"booltest4\"] = {\"1\"};\n-\n-    // priorities\n-    testArgs.GetOverrideArgs()[\"pritest1\"] = {\"a\", \"b\"};\n-    testArgs.GetConfigArgs()[\"pritest2\"] = {\"a\", \"b\"};\n-    testArgs.GetOverrideArgs()[\"pritest3\"] = {\"a\"};\n-    testArgs.GetConfigArgs()[\"pritest3\"] = {\"b\"};\n-    testArgs.GetOverrideArgs()[\"pritest4\"] = {\"a\",\"b\"};\n-    testArgs.GetConfigArgs()[\"pritest4\"] = {\"c\",\"d\"};\n-\n-    BOOST_CHECK_EQUAL(testArgs.GetArg(\"strtest1\", \"default\"), \"string...\");\n-    BOOST_CHECK_EQUAL(testArgs.GetArg(\"strtest2\", \"default\"), \"default\");\n-    BOOST_CHECK_EQUAL(testArgs.GetArg(\"inttest1\", -1), 12345);\n-    BOOST_CHECK_EQUAL(testArgs.GetArg(\"inttest2\", -1), 81985529216486895LL);\n-    BOOST_CHECK_EQUAL(testArgs.GetArg(\"inttest3\", -1), -1);\n-    BOOST_CHECK_EQUAL(testArgs.GetBoolArg(\"booltest1\", false), true);\n-    BOOST_CHECK_EQUAL(testArgs.GetBoolArg(\"booltest2\", false), false);\n-    BOOST_CHECK_EQUAL(testArgs.GetBoolArg(\"booltest3\", false), false);\n-    BOOST_CHECK_EQUAL(testArgs.GetBoolArg(\"booltest4\", false), true);\n-\n-    BOOST_CHECK_EQUAL(testArgs.GetArg(\"pritest1\", \"default\"), \"b\");\n-    BOOST_CHECK_EQUAL(testArgs.GetArg(\"pritest2\", \"default\"), \"a\");\n-    BOOST_CHECK_EQUAL(testArgs.GetArg(\"pritest3\", \"default\"), \"a\");\n-    BOOST_CHECK_EQUAL(testArgs.GetArg(\"pritest4\", \"default\"), \"b\");\n-}\n-\n-BOOST_AUTO_TEST_CASE(util_GetChainName)\n-{\n-    TestArgsManager test_args;\n-    const char* avail_args[] = {\"-testnet\", \"-regtest\"};\n-    test_args.SetupArgs(2, avail_args);\n-\n-    const char* argv_testnet[] = {\"cmd\", \"-testnet\"};\n-    const char* argv_regtest[] = {\"cmd\", \"-regtest\"};\n-    const char* argv_test_no_reg[] = {\"cmd\", \"-testnet\", \"-noregtest\"};\n-    const char* argv_both[] = {\"cmd\", \"-testnet\", \"-regtest\"};\n-\n-    // equivalent to \"-testnet\"\n-    // regtest in testnet section is ignored\n-    const char* testnetconf = \"testnet=1\\nregtest=0\\n[test]\\nregtest=1\";\n-    std::string error;\n-\n-    BOOST_CHECK(test_args.ParseParameters(0, (char**)argv_testnet, error));\n-    BOOST_CHECK_EQUAL(test_args.GetChainName(), \"main\");\n-\n-    BOOST_CHECK(test_args.ParseParameters(2, (char**)argv_testnet, error));\n-    BOOST_CHECK_EQUAL(test_args.GetChainName(), \"test\");\n-\n-    BOOST_CHECK(test_args.ParseParameters(2, (char**)argv_regtest, error));\n-    BOOST_CHECK_EQUAL(test_args.GetChainName(), \"regtest\");\n-\n-    BOOST_CHECK(test_args.ParseParameters(3, (char**)argv_test_no_reg, error));\n-    BOOST_CHECK_EQUAL(test_args.GetChainName(), \"test\");\n-\n-    BOOST_CHECK(test_args.ParseParameters(3, (char**)argv_both, error));\n-    BOOST_CHECK_THROW(test_args.GetChainName(), std::runtime_error);\n-\n-    BOOST_CHECK(test_args.ParseParameters(0, (char**)argv_testnet, error));\n-    test_args.ReadConfigString(testnetconf);\n-    BOOST_CHECK_EQUAL(test_args.GetChainName(), \"test\");\n-\n-    BOOST_CHECK(test_args.ParseParameters(2, (char**)argv_testnet, error));\n-    test_args.ReadConfigString(testnetconf);\n-    BOOST_CHECK_EQUAL(test_args.GetChainName(), \"test\");\n-\n-    BOOST_CHECK(test_args.ParseParameters(2, (char**)argv_regtest, error));\n-    test_args.ReadConfigString(testnetconf);\n-    BOOST_CHECK_THROW(test_args.GetChainName(), std::runtime_error);\n-\n-    BOOST_CHECK(test_args.ParseParameters(3, (char**)argv_test_no_reg, error));\n-    test_args.ReadConfigString(testnetconf);\n-    BOOST_CHECK_EQUAL(test_args.GetChainName(), \"test\");\n-\n-    BOOST_CHECK(test_args.ParseParameters(3, (char**)argv_both, error));\n-    test_args.ReadConfigString(testnetconf);\n-    BOOST_CHECK_THROW(test_args.GetChainName(), std::runtime_error);\n-\n-    // check setting the network to test (and thus making\n-    // [test] regtest=1 potentially relevant) doesn't break things\n-    test_args.SelectConfigNetwork(\"test\");\n-\n-    BOOST_CHECK(test_args.ParseParameters(0, (char**)argv_testnet, error));\n-    test_args.ReadConfigString(testnetconf);\n-    BOOST_CHECK_EQUAL(test_args.GetChainName(), \"test\");\n-\n-    BOOST_CHECK(test_args.ParseParameters(2, (char**)argv_testnet, error));\n-    test_args.ReadConfigString(testnetconf);\n-    BOOST_CHECK_EQUAL(test_args.GetChainName(), \"test\");\n-\n-    BOOST_CHECK(test_args.ParseParameters(2, (char**)argv_regtest, error));\n-    test_args.ReadConfigString(testnetconf);\n-    BOOST_CHECK_THROW(test_args.GetChainName(), std::runtime_error);\n-\n-    BOOST_CHECK(test_args.ParseParameters(2, (char**)argv_test_no_reg, error));\n-    test_args.ReadConfigString(testnetconf);\n-    BOOST_CHECK_EQUAL(test_args.GetChainName(), \"test\");\n-\n-    BOOST_CHECK(test_args.ParseParameters(3, (char**)argv_both, error));\n-    test_args.ReadConfigString(testnetconf);\n-    BOOST_CHECK_THROW(test_args.GetChainName(), std::runtime_error);\n-}\n-\n-// Test different ways settings can be merged, and verify results. This test can\n-// be used to confirm that updates to settings code don't change behavior\n-// unintentionally.\n-//\n-// The test covers:\n-//\n-// - Combining different setting actions. Possible actions are: configuring a\n-//   setting, negating a setting (adding \"-no\" prefix), and configuring/negating\n-//   settings in a network section (adding \"main.\" or \"test.\" prefixes).\n-//\n-// - Combining settings from command line arguments and a config file.\n-//\n-// - Combining SoftSet and ForceSet calls.\n-//\n-// - Testing \"main\" and \"test\" network values to make sure settings from network\n-//   sections are applied and to check for mainnet-specific behaviors like\n-//   inheriting settings from the default section.\n-//\n-// - Testing network-specific settings like \"-wallet\", that may be ignored\n-//   outside a network section, and non-network specific settings like \"-server\"\n-//   that aren't sensitive to the network.\n-//\n-struct ArgsMergeTestingSetup : public BasicTestingSetup {\n-    //! Max number of actions to sequence together. Can decrease this when\n-    //! debugging to make test results easier to understand.\n-    static constexpr int MAX_ACTIONS = 3;\n-\n-    enum Action { NONE, SET, NEGATE, SECTION_SET, SECTION_NEGATE };\n-    using ActionList = Action[MAX_ACTIONS];\n-\n-    //! Enumerate all possible test configurations.\n-    template <typename Fn>\n-    void ForEachMergeSetup(Fn&& fn)\n-    {\n-        ActionList arg_actions = {};\n-        ForEachNoDup(arg_actions, SET, SECTION_NEGATE, [&] {\n-            ActionList conf_actions = {};\n-            ForEachNoDup(conf_actions, SET, SECTION_NEGATE, [&] {\n-                for (bool soft_set : {false, true}) {\n-                    for (bool force_set : {false, true}) {\n-                        for (const std::string& section : {CBaseChainParams::MAIN, CBaseChainParams::TESTNET}) {\n-                            for (const std::string& network : {CBaseChainParams::MAIN, CBaseChainParams::TESTNET}) {\n-                                for (bool net_specific : {false, true}) {\n-                                    fn(arg_actions, conf_actions, soft_set, force_set, section, network, net_specific);\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-            });\n-        });\n-    }\n-\n-    //! Translate actions into a list of <key>=<value> setting strings.\n-    std::vector<std::string> GetValues(const ActionList& actions,\n-        const std::string& section,\n-        const std::string& name,\n-        const std::string& value_prefix)\n-    {\n-        std::vector<std::string> values;\n-        int suffix = 0;\n-        for (Action action : actions) {\n-            if (action == NONE) break;\n-            std::string prefix;\n-            if (action == SECTION_SET || action == SECTION_NEGATE) prefix = section + \".\";\n-            if (action == SET || action == SECTION_SET) {\n-                for (int i = 0; i < 2; ++i) {\n-                    values.push_back(prefix + name + \"=\" + value_prefix + std::to_string(++suffix));\n-                }\n-            }\n-            if (action == NEGATE || action == SECTION_NEGATE) {\n-                values.push_back(prefix + \"no\" + name + \"=1\");\n-            }\n-        }\n-        return values;\n-    }\n-};\n-\n-// Regression test covering different ways config settings can be merged. The\n-// test parses and merges settings, representing the results as strings that get\n-// compared against an expected hash. To debug, the result strings can be dumped\n-// to a file (see comments below).\n-BOOST_FIXTURE_TEST_CASE(util_ArgsMerge, ArgsMergeTestingSetup)\n-{\n-    CHash256 out_sha;\n-    FILE* out_file = nullptr;\n-    if (const char* out_path = getenv(\"ARGS_MERGE_TEST_OUT\")) {\n-        out_file = fsbridge::fopen(out_path, \"w\");\n-        if (!out_file) throw std::system_error(errno, std::generic_category(), \"fopen failed\");\n-    }\n-\n-    ForEachMergeSetup([&](const ActionList& arg_actions, const ActionList& conf_actions, bool soft_set, bool force_set,\n-                          const std::string& section, const std::string& network, bool net_specific) {\n-        TestArgsManager parser;\n-        LOCK(parser.cs_args);\n-\n-        std::string desc = \"net=\";\n-        desc += network;\n-        parser.m_network = network;\n-\n-        const std::string& name = net_specific ? \"wallet\" : \"server\";\n-        const std::string key = \"-\" + name;\n-        parser.AddArg(key, name, false, OptionsCategory::OPTIONS);\n-        if (net_specific) parser.SetNetworkOnlyArg(key);\n-\n-        auto args = GetValues(arg_actions, section, name, \"a\");\n-        std::vector<const char*> argv = {\"ignored\"};\n-        for (auto& arg : args) {\n-            arg.insert(0, \"-\");\n-            desc += \" \";\n-            desc += arg;\n-            argv.push_back(arg.c_str());\n-        }\n-        std::string error;\n-        BOOST_CHECK(parser.ParseParameters(argv.size(), argv.data(), error));\n-        BOOST_CHECK_EQUAL(error, \"\");\n-\n-        std::string conf;\n-        for (auto& conf_val : GetValues(conf_actions, section, name, \"c\")) {\n-            desc += \" \";\n-            desc += conf_val;\n-            conf += conf_val;\n-            conf += \"\\n\";\n-        }\n-        std::istringstream conf_stream(conf);\n-        BOOST_CHECK(parser.ReadConfigStream(conf_stream, \"filepath\", error));\n-        BOOST_CHECK_EQUAL(error, \"\");\n-\n-        if (soft_set) {\n-            desc += \" soft\";\n-            parser.SoftSetArg(key, \"soft1\");\n-            parser.SoftSetArg(key, \"soft2\");\n-        }\n-\n-        if (force_set) {\n-            desc += \" force\";\n-            parser.ForceSetArg(key, \"force1\");\n-            parser.ForceSetArg(key, \"force2\");\n-        }\n-\n-        desc += \" || \";\n-\n-        if (!parser.IsArgSet(key)) {\n-            desc += \"unset\";\n-            BOOST_CHECK(!parser.IsArgNegated(key));\n-            BOOST_CHECK_EQUAL(parser.GetArg(key, \"default\"), \"default\");\n-            BOOST_CHECK(parser.GetArgs(key).empty());\n-        } else if (parser.IsArgNegated(key)) {\n-            desc += \"negated\";\n-            BOOST_CHECK_EQUAL(parser.GetArg(key, \"default\"), \"0\");\n-            BOOST_CHECK(parser.GetArgs(key).empty());\n-        } else {\n-            desc += parser.GetArg(key, \"default\");\n-            desc += \" |\";\n-            for (const auto& arg : parser.GetArgs(key)) {\n-                desc += \" \";\n-                desc += arg;\n-            }\n-        }\n-\n-        std::set<std::string> ignored = parser.GetUnsuitableSectionOnlyArgs();\n-        if (!ignored.empty()) {\n-            desc += \" | ignored\";\n-            for (const auto& arg : ignored) {\n-                desc += \" \";\n-                desc += arg;\n-            }\n-        }\n-\n-        desc += \"\\n\";\n-\n-        out_sha.Write((const unsigned char*)desc.data(), desc.size());\n-        if (out_file) {\n-            BOOST_REQUIRE(fwrite(desc.data(), 1, desc.size(), out_file) == desc.size());\n-        }\n-    });\n-\n-    if (out_file) {\n-        if (fclose(out_file)) throw std::system_error(errno, std::generic_category(), \"fclose failed\");\n-        out_file = nullptr;\n-    }\n-\n-    unsigned char out_sha_bytes[CSHA256::OUTPUT_SIZE];\n-    out_sha.Finalize(out_sha_bytes);\n-    std::string out_sha_hex = HexStr(std::begin(out_sha_bytes), std::end(out_sha_bytes));\n-\n-    // If check below fails, should manually dump the results with:\n-    //\n-    //   ARGS_MERGE_TEST_OUT=results.txt ./test_bitcoin --run_test=util_tests/util_ArgsMerge\n-    //\n-    // And verify diff against previous results to make sure the changes are expected.\n-    //\n-    // Results file is formatted like:\n-    //\n-    //   <input> || <IsArgSet/IsArgNegated/GetArg output> | <GetArgs output> | <GetUnsuitable output>\n-    BOOST_CHECK_EQUAL(out_sha_hex, \"b835eef5977d69114eb039a976201f8c7121f34fe2b7ea2b73cafb516e5c9dc8\");\n-}\n-\n-// Similar test as above, but for ArgsManager::GetChainName function.\n-struct ChainMergeTestingSetup : public BasicTestingSetup {\n-    static constexpr int MAX_ACTIONS = 2;\n-\n-    enum Action { NONE, ENABLE_TEST, DISABLE_TEST, NEGATE_TEST, ENABLE_REG, DISABLE_REG, NEGATE_REG };\n-    using ActionList = Action[MAX_ACTIONS];\n-\n-    //! Enumerate all possible test configurations.\n-    template <typename Fn>\n-    void ForEachMergeSetup(Fn&& fn)\n-    {\n-        ActionList arg_actions = {};\n-        ForEachNoDup(arg_actions, ENABLE_TEST, NEGATE_REG, [&] {\n-            ActionList conf_actions = {};\n-            ForEachNoDup(conf_actions, ENABLE_TEST, NEGATE_REG, [&] { fn(arg_actions, conf_actions); });\n-        });\n-    }\n-};\n-\n-BOOST_FIXTURE_TEST_CASE(util_ChainMerge, ChainMergeTestingSetup)\n-{\n-    CHash256 out_sha;\n-    FILE* out_file = nullptr;\n-    if (const char* out_path = getenv(\"CHAIN_MERGE_TEST_OUT\")) {\n-        out_file = fsbridge::fopen(out_path, \"w\");\n-        if (!out_file) throw std::system_error(errno, std::generic_category(), \"fopen failed\");\n-    }\n-\n-    ForEachMergeSetup([&](const ActionList& arg_actions, const ActionList& conf_actions) {\n-        TestArgsManager parser;\n-        LOCK(parser.cs_args);\n-        parser.AddArg(\"-regtest\", \"regtest\", false, OptionsCategory::OPTIONS);\n-        parser.AddArg(\"-testnet\", \"testnet\", false, OptionsCategory::OPTIONS);\n-\n-        auto arg = [](Action action) { return action == ENABLE_TEST  ? \"-testnet=1\"   :\n-                                              action == DISABLE_TEST ? \"-testnet=0\"   :\n-                                              action == NEGATE_TEST  ? \"-notestnet=1\" :\n-                                              action == ENABLE_REG   ? \"-regtest=1\"   :\n-                                              action == DISABLE_REG  ? \"-regtest=0\"   :\n-                                              action == NEGATE_REG   ? \"-noregtest=1\" : nullptr; };\n-\n-        std::string desc;\n-        std::vector<const char*> argv = {\"ignored\"};\n-        for (Action action : arg_actions) {\n-            const char* argstr = arg(action);\n-            if (!argstr) break;\n-            argv.push_back(argstr);\n-            desc += \" \";\n-            desc += argv.back();\n-        }\n-        std::string error;\n-        BOOST_CHECK(parser.ParseParameters(argv.size(), argv.data(), error));\n-        BOOST_CHECK_EQUAL(error, \"\");\n-\n-        std::string conf;\n-        for (Action action : conf_actions) {\n-            const char* argstr = arg(action);\n-            if (!argstr) break;\n-            desc += \" \";\n-            desc += argstr + 1;\n-            conf += argstr + 1;\n-        }\n-        std::istringstream conf_stream(conf);\n-        BOOST_CHECK(parser.ReadConfigStream(conf_stream, \"filepath\", error));\n-        BOOST_CHECK_EQUAL(error, \"\");\n-\n-        desc += \" || \";\n-        try {\n-            desc += parser.GetChainName();\n-        } catch (const std::runtime_error& e) {\n-            desc += \"error: \";\n-            desc += e.what();\n-        }\n-        desc += \"\\n\";\n-\n-        out_sha.Write((const unsigned char*)desc.data(), desc.size());\n-        if (out_file) {\n-            BOOST_REQUIRE(fwrite(desc.data(), 1, desc.size(), out_file) == desc.size());\n-        }\n-    });\n-\n-    if (out_file) {\n-        if (fclose(out_file)) throw std::system_error(errno, std::generic_category(), \"fclose failed\");\n-        out_file = nullptr;\n-    }\n-\n-    unsigned char out_sha_bytes[CSHA256::OUTPUT_SIZE];\n-    out_sha.Finalize(out_sha_bytes);\n-    std::string out_sha_hex = HexStr(std::begin(out_sha_bytes), std::end(out_sha_bytes));\n-\n-    // If check below fails, should manually dump the results with:\n-    //\n-    //   CHAIN_MERGE_TEST_OUT=results.txt ./test_bitcoin --run_test=util_tests/util_ChainMerge\n-    //\n-    // And verify diff against previous results to make sure the changes are expected.\n-    //\n-    // Results file is formatted like:\n-    //\n-    //   <input> || <output>\n-    BOOST_CHECK_EQUAL(out_sha_hex, \"b284f4b4a15dd6bf8c06213a69a004b1960388e1d9917173927db52ac220927f\");\n-}\n-\n BOOST_AUTO_TEST_CASE(util_FormatMoney)\n {\n     BOOST_CHECK_EQUAL(FormatMoney(0), \"0.00\");"
      }
    ]
  }
]