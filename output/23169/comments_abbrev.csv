practicalswift,2021-10-04 09:15:59,"Concept ACK on fixing the unitialized read (`bitbuf`) which can be tested with Valgrind using the following patch:\n\n```patch\ndiff --git a/src/random.cpp b/src/random.cpp\nindex 174f4cef3..73e946783 100644\n--- a/src/random.cpp\n+++ b/src/random.cpp\n@@ -693,13 +693,30 @@ FastRandomContext::FastRandomContext(bool fDeterministic) noexcept : requires_se\n     rng.SetKey(seed.begin(), 32);",https://github.com/bitcoin/bitcoin/pull/23169#issuecomment-933298687,933298687,
laanwj,2021-10-04 10:45:42,"As it has historically been a source of some very serious vulnerabilities I'm somewhat concerned around fixing uninitialized value warnings in random functionality. Please review this carefully.\nConcept ACK of course.",https://github.com/bitcoin/bitcoin/pull/23169#issuecomment-933362868,933362868,
MarcoFalke,2021-10-04 11:02:05,"Yeah, would have been good if `FastRandomContext` used this from the beginning. For reference, chacha20 FastRandom was introduced in #9792",https://github.com/bitcoin/bitcoin/pull/23169#issuecomment-933373193,933373193,
laanwj,2021-11-15 14:17:48,Code review ACK f46225ea5cadcb94cbaf7b77346bfef622d35eed,https://github.com/bitcoin/bitcoin/pull/23169#issuecomment-968954723,968954723,
MarcoFalke,2021-11-16 08:34:01,"I still don't understand this.\n\nReading https://github.com/bitcoin/bitcoin/pull/23169#issuecomment-933298687 tells me that the issue is (also) bytebuf, but you are fixing bitbuf and leave bytebuf an uninitialized  read?",https://github.com/bitcoin/bitcoin/pull/23169#issuecomment-970039035,970039035,
martinus,2021-11-18 17:44:11,"My change was only about the undefined behavior issue, because assigning from an uninitialized variable that's not a `char` is undefined behavior. As far as I understand it with bytebuf that's not undefined behavior but just reading uninitialized memory: https://eel.is/c++draft/basic.indet#example-1\n\nI've rebased and updated the PR though to get rid of reading uninitialized memory as well in 1",https://github.com/bitcoin/bitcoin/pull/23169#issuecomment-973108042,973108042,
sipa,2021-11-18 17:47:34,"If the buffer sizes are initialized, I'm pretty sure the uninitialized area of the byte buffer itself will never be read from (because it will be filled before any read happens). So I'm in favor of not initializing the byte buffer, giving analysis tools a chance to detect bugs with it.",https://github.com/bitcoin/bitcoin/pull/23169#issuecomment-973110717,973110717,
MarcoFalke,2021-11-18 18:00:51,"Jup, I agree, see https://github.com/bitcoin/bitcoin/pull/23169#discussion_r721261844.\n\n\nNow that you removed the initialization, the pull request title etc should be updated? (The current patch does not change initialization)",https://github.com/bitcoin/bitcoin/pull/23169#issuecomment-973120875,973120875,
martinus,2021-11-19 06:48:11,"Right, I've updated the title",https://github.com/bitcoin/bitcoin/pull/23169#issuecomment-973798193,973798193,
MarcoFalke,2021-10-04 06:52:59,The goal of leaving this uninitialized is to have memory sanitizers yell. By initializing you disable memory sanitizers.,https://github.com/bitcoin/bitcoin/pull/23169#discussion_r721084621,721084621,src/test/fuzz/float.cpp
MarcoFalke,2021-10-04 06:53:10,Same,https://github.com/bitcoin/bitcoin/pull/23169#discussion_r721084719,721084719,src/test/fuzz/string.cpp
MarcoFalke,2021-10-04 06:55:58,"One workaround would be to make this optional, then `return *Assert(tmp);` (or `tmp.value()`). But I am not sure if this is worth it.",https://github.com/bitcoin/bitcoin/pull/23169#discussion_r721086211,721086211,src/test/fuzz/float.cpp
martinus,2021-10-04 07:51:28,ah I didn't think about that. I'll remove this commit,https://github.com/bitcoin/bitcoin/pull/23169#discussion_r721118976,721118976,src/test/fuzz/float.cpp
MarcoFalke,2021-10-04 11:10:02,shouldn't this be left uninitialized? With this patch memory sanitizer will fail to detect logic errors.,https://github.com/bitcoin/bitcoin/pull/23169#discussion_r721261844,721261844,src/random.h
martinus,2021-10-06 15:56:42,"I'm not sure msan would catch any error here. If I understand it correctly, msan can only catch uninitialized memory when a branch is involved. I played a bit with this sample code which loops over uninitialized memory and prints a result:\n\n```cpp\n#include <iostream>\n\nstruct Foo {\n  unsigned char bytebuf[1024 * 1024];\n};\n\nint main() {\n  Foo f; // uninitialized\n  uint64_t x = ",https://github.com/bitcoin/bitcoin/pull/23169#discussion_r723426294,723426294,src/random.h
MarcoFalke,2021-10-06 17:33:32,I don't thinks the shortcomings of one memory sanitizer tool should be used as an argument to disable other sanitizer tools as well. `valgrind` detects this (with or without the if).,https://github.com/bitcoin/bitcoin/pull/23169#discussion_r723530754,723530754,src/random.h
practicalswift,2021-10-07 11:29:09,"Not a comment on these specific changes, but as a more general comment: note that `VALGRIND_MAKE_MEM_UNDEFINED` (Valgrind) and `__msan_poison` (MSAN) can be used to mark memory regions as uninitialized from a tooling perspective (regardless of actual status).\n\nExample use: https://github.com/kriskwiatkowski/pqc/blob/main/src/common/ct_check.h",https://github.com/bitcoin/bitcoin/pull/23169#discussion_r724091496,724091496,src/random.h
martinus,2021-10-09 07:51:05,I've removed the initialization of bytebuf in f46225ea5cadcb94cbaf7b77346bfef622d35eed,https://github.com/bitcoin/bitcoin/pull/23169#discussion_r725451367,725451367,src/random.h
