[
  {
    "sha": "e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNjJjY2RlNGY3ZDJiMmIxNzI1YTgyZmVmZjJmMmE2YWFhOWMyMTkz",
    "commit": {
      "author": {
        "name": "sanch0panza",
        "email": "sanch0panza@protonmail.com",
        "date": "2017-05-21T11:32:58Z"
      },
      "committer": {
        "name": "sanch0panza",
        "email": "sanch0panza@protonmail.com",
        "date": "2017-05-25T09:40:04Z"
      },
      "message": "Implement BIP135 (generalized versionbits)\n\nThis is an implementation of https://github.com/bitcoin/bips/blob/master/bip-0135.mediawiki .\n\nIt extends the BIP9 state machine processing with configurable per-bit\nwindow size, activation threshold and grace period parameters\n(minlockedblocks and minlockedtime).\n\nThe built-in deployments are parameterized to maintain backward compatibility,\nand the existing BIP9 tests are retained unmodified except for a minor fix\nmade to `versionbits_tests` to improve the disjointness checks for configured bits).\n\nA `bip135_forks` section has been added to the `getblockchaininfo` RPC output,\nleaving the existing `bip9_softforks` section for backward compatibility.\n\nThe check for 'unknown versions being mined' has been altered to take into\naccount that for unknown bits, we can no longer rely on a 95% activation\nthreshold. The `p2p-versionbits-warning` test has been modified accordingly -\nthe new logic warns when an unknown bit exceeds 50/100 of the last blocks.\n\nNOTE: This implementation contains a specific feature which is not covered by the\nspecification (and thus not strictly required for BIP135): the optional loading of\nfork configuration from a CSV file (using `-forks=datafile` command line option)\nand the ability to dump out the built-in configuration in CSV format\n(`-dumpforks` option). This has been retained from the original reference\nimplementation since it makes testing and adaptation of the configuration easier.",
      "tree": {
        "sha": "0b88deed8563e22567227d663a85be362f9cfb55",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0b88deed8563e22567227d663a85be362f9cfb55"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/comments",
    "author": {
      "login": "sanch0panza",
      "id": 26766668,
      "node_id": "MDQ6VXNlcjI2NzY2NjY4",
      "avatar_url": "https://avatars.githubusercontent.com/u/26766668?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sanch0panza",
      "html_url": "https://github.com/sanch0panza",
      "followers_url": "https://api.github.com/users/sanch0panza/followers",
      "following_url": "https://api.github.com/users/sanch0panza/following{/other_user}",
      "gists_url": "https://api.github.com/users/sanch0panza/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sanch0panza/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sanch0panza/subscriptions",
      "organizations_url": "https://api.github.com/users/sanch0panza/orgs",
      "repos_url": "https://api.github.com/users/sanch0panza/repos",
      "events_url": "https://api.github.com/users/sanch0panza/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sanch0panza/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sanch0panza",
      "id": 26766668,
      "node_id": "MDQ6VXNlcjI2NzY2NjY4",
      "avatar_url": "https://avatars.githubusercontent.com/u/26766668?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sanch0panza",
      "html_url": "https://github.com/sanch0panza",
      "followers_url": "https://api.github.com/users/sanch0panza/followers",
      "following_url": "https://api.github.com/users/sanch0panza/following{/other_user}",
      "gists_url": "https://api.github.com/users/sanch0panza/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sanch0panza/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sanch0panza/subscriptions",
      "organizations_url": "https://api.github.com/users/sanch0panza/orgs",
      "repos_url": "https://api.github.com/users/sanch0panza/repos",
      "events_url": "https://api.github.com/users/sanch0panza/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sanch0panza/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4314544d46e8e46c3c9da60f1d18297f52f58418",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4314544d46e8e46c3c9da60f1d18297f52f58418",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4314544d46e8e46c3c9da60f1d18297f52f58418"
      }
    ],
    "stats": {
      "total": 2490,
      "additions": 2302,
      "deletions": 188
    },
    "files": [
      {
        "sha": "cfbea9491414e42e8cde237bbe46b59205a6fdbb",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193",
        "patch": "@@ -99,6 +99,7 @@ BITCOIN_CORE_H = \\\n   core_io.h \\\n   core_memusage.h \\\n   cuckoocache.h \\\n+  forks_csv.h \\\n   fs.h \\\n   httprpc.h \\\n   httpserver.h \\\n@@ -187,6 +188,7 @@ libbitcoin_server_a_SOURCES = \\\n   chain.cpp \\\n   checkpoints.cpp \\\n   consensus/tx_verify.cpp \\\n+  forks_csv.cpp \\\n   httprpc.cpp \\\n   httpserver.cpp \\\n   init.cpp \\\n@@ -305,6 +307,7 @@ libbitcoin_common_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n libbitcoin_common_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libbitcoin_common_a_SOURCES = \\\n   base58.cpp \\\n+  chain.cpp \\\n   chainparams.cpp \\\n   coins.cpp \\\n   compressor.cpp \\\n@@ -319,6 +322,7 @@ libbitcoin_common_a_SOURCES = \\\n   scheduler.cpp \\\n   script/sign.cpp \\\n   script/standard.cpp \\\n+  versionbits.cpp \\\n   warnings.cpp \\\n   $(BITCOIN_CORE_H)\n "
      },
      {
        "sha": "e562a24722a947dd33931b96c7dd653884799708",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193",
        "patch": "@@ -41,6 +41,8 @@ BITCOIN_TESTS =\\\n   test/crypto_tests.cpp \\\n   test/cuckoocache_tests.cpp \\\n   test/DoS_tests.cpp \\\n+  test/forkscsv_tests.cpp \\\n+  test/genversionbits_tests.cpp \\\n   test/getarg_tests.cpp \\\n   test/hash_tests.cpp \\\n   test/key_tests.cpp \\"
      },
      {
        "sha": "7dd1a08d499e1dfcedc660a305a98de3c7f9a0b4",
        "filename": "src/bitcoind.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 1,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/bitcoind.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/bitcoind.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoind.cpp?ref=e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193",
        "patch": "@@ -1,5 +1,5 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2016 The Bitcoin Core developers\n+// Copyright (c) 2009-2017 The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -19,8 +19,10 @@\n #include \"httpserver.h\"\n #include \"httprpc.h\"\n #include \"utilstrencodings.h\"\n+#include \"forks_csv.h\"\n \n #include <boost/algorithm/string/predicate.hpp>\n+#include <boost/filesystem.hpp>\n #include <boost/thread.hpp>\n \n #include <stdio.h>\n@@ -95,6 +97,18 @@ bool AppInit(int argc, char* argv[])\n         return true;\n     }\n \n+    // bip135 begin\n+    // dump default deployment info and exit, if requested\n+    if (IsArgSet(\"-dumpforks\")) {\n+        std::string strVersion = \"# \" + strprintf(_(\"%s Daemon\"), _(PACKAGE_NAME)) + \" \" + _(\"version\") + \" \" + FormatFullVersion();\n+        fprintf(stdout, \"%s\\n%s\", strVersion.c_str(), FORKS_CSV_FILE_HEADER);\n+        fprintf(stdout, \"%s\", NetworkDeploymentInfoCSV(CBaseChainParams::MAIN).c_str());\n+        fprintf(stdout, \"%s\", NetworkDeploymentInfoCSV(CBaseChainParams::TESTNET).c_str());\n+        fprintf(stdout, \"%s\", NetworkDeploymentInfoCSV(CBaseChainParams::REGTEST).c_str());\n+        return true;\n+    }\n+    // bip135 end\n+\n     try\n     {\n         if (!fs::is_directory(GetDataDir(false)))"
      },
      {
        "sha": "d4af914d64e218699a67b131bbb74f005dd4c4fc",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 129,
        "deletions": 27,
        "changes": 156,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193",
        "patch": "@@ -1,10 +1,11 @@\n // Copyright (c) 2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2016 The Bitcoin Core developers\n+// Copyright (c) 2009-2017 The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"chainparams.h\"\n #include \"consensus/merkle.h\"\n+#include \"versionbits.h\"  // bip135 added\n \n #include \"tinyformat.h\"\n #include \"util.h\"\n@@ -86,21 +87,27 @@ class CMainParams : public CChainParams {\n         consensus.nPowTargetSpacing = 10 * 60;\n         consensus.fPowAllowMinDifficultyBlocks = false;\n         consensus.fPowNoRetargeting = false;\n-        consensus.nRuleChangeActivationThreshold = 1916; // 95% of 2016\n-        consensus.nMinerConfirmationWindow = 2016; // nPowTargetTimespan / nPowTargetSpacing\n-        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].bit = 28;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601; // January 1, 2008\n-        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 1230767999; // December 31, 2008\n \n         // Deployment of BIP68, BIP112, and BIP113.\n         consensus.vDeployments[Consensus::DEPLOYMENT_CSV].bit = 0;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nStartTime = 1462060800; // May 1st, 2016\n-        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nTimeout = 1493596800; // May 1st, 2017\n+        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nStartTime = 1462060800LL; // May 1st, 2016\n+        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nTimeout = 1493596800LL; // May 1st, 2017\n+        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].windowsize = 2016;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].threshold = 1916; // 95% of 2016\n \n         // Deployment of SegWit (BIP141, BIP143, and BIP147)\n         consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].bit = 1;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nStartTime = 1479168000; // November 15th, 2016.\n-        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout = 1510704000; // November 15th, 2017.\n+        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nStartTime = 1479168000LL; // November 15th, 2016.\n+        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout = 1510704000LL; // November 15th, 2017.\n+        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].windowsize = 2016;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].threshold = 1916; // 95% of 2016\n+\n+        // testing bit\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].bit = 28;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601LL; // January 1, 2008\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 1230767999LL; // December 31, 2008\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].windowsize = 2016;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].threshold = 1916; // 95% of 2016\n \n         // The best chain should have at least this much work.\n         consensus.nMinimumChainWork = uint256S(\"0x0000000000000000000000000000000000000000003f94d1ad391682fe038bf5\");\n@@ -189,21 +196,25 @@ class CTestNetParams : public CChainParams {\n         consensus.nPowTargetSpacing = 10 * 60;\n         consensus.fPowAllowMinDifficultyBlocks = true;\n         consensus.fPowNoRetargeting = false;\n-        consensus.nRuleChangeActivationThreshold = 1512; // 75% for testchains\n-        consensus.nMinerConfirmationWindow = 2016; // nPowTargetTimespan / nPowTargetSpacing\n-        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].bit = 28;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601; // January 1, 2008\n-        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 1230767999; // December 31, 2008\n-\n         // Deployment of BIP68, BIP112, and BIP113.\n         consensus.vDeployments[Consensus::DEPLOYMENT_CSV].bit = 0;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nStartTime = 1456790400; // March 1st, 2016\n-        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nTimeout = 1493596800; // May 1st, 2017\n+        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nStartTime = 1456790400LL; // March 1st, 2016\n+        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nTimeout = 1493596800LL; // May 1st, 2017\n+        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].windowsize = 2016;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].threshold = 1512; // 75% of 2016\n \n         // Deployment of SegWit (BIP141, BIP143, and BIP147)\n         consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].bit = 1;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nStartTime = 1462060800; // May 1st 2016\n-        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout = 1493596800; // May 1st 2017\n+        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nStartTime = 1462060800LL; // May 1st 2016\n+        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout = 1493596800LL; // May 1st 2017\n+        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].windowsize = 2016;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].threshold = 1512; // 75% of 2016\n+\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].bit = 28;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601LL; // January 1, 2008\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 1230767999LL; // December 31, 2008\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].windowsize = 2016;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].threshold = 1512; // 75% of 2016\n \n         // The best chain should have at least this much work.\n         consensus.nMinimumChainWork = uint256S(\"0x00000000000000000000000000000000000000000000001f057509eba81aed91\");\n@@ -276,17 +287,24 @@ class CRegTestParams : public CChainParams {\n         consensus.nPowTargetSpacing = 10 * 60;\n         consensus.fPowAllowMinDifficultyBlocks = true;\n         consensus.fPowNoRetargeting = true;\n-        consensus.nRuleChangeActivationThreshold = 108; // 75% for testchains\n-        consensus.nMinerConfirmationWindow = 144; // Faster than normal for regtest (144 instead of 2016)\n-        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].bit = 28;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 0;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 999999999999ULL;\n         consensus.vDeployments[Consensus::DEPLOYMENT_CSV].bit = 0;\n         consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nStartTime = 0;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nTimeout = 999999999999ULL;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nTimeout = 999999999999LL;\n+        // Faster than normal for regtest (144 instead of 2016 blocks)\n+        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].windowsize = 144;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].threshold = 108; // 75% of 144\n+\n         consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].bit = 1;\n         consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nStartTime = 0;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout = 999999999999ULL;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout = 999999999999LL;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].windowsize = 144;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].threshold = 108; // 75% of 144\n+\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].bit = 28;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 0;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 999999999999LL;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].windowsize = 144;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].threshold = 108; // 75% of 144\n \n         // The best chain should have at least this much work.\n         consensus.nMinimumChainWork = uint256S(\"0x00\");\n@@ -339,6 +357,25 @@ const CChainParams &Params() {\n     return *globalChainParams;\n }\n \n+CChainParams& Params(const std::string& chain)\n+{\n+    CChainParams *chainparams;\n+\n+    if (chain == CBaseChainParams::MAIN) {\n+        chainparams = new CMainParams();\n+        return (CChainParams&) *chainparams;\n+    }\n+    else if (chain == CBaseChainParams::TESTNET) {\n+        chainparams = new CTestNetParams();\n+        return (CChainParams&) *chainparams;\n+    }\n+    else if (chain == CBaseChainParams::REGTEST) {\n+        chainparams = new CRegTestParams();\n+        return (CChainParams&) *chainparams;\n+    }\n+    throw std::runtime_error(strprintf(\"%s: Unknown chain %s.\", __func__, chain));\n+}\n+\n std::unique_ptr<CChainParams> CreateChainParams(const std::string& chain)\n {\n     if (chain == CBaseChainParams::MAIN)\n@@ -361,3 +398,68 @@ void UpdateBIP9Parameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_\n     globalChainParams->UpdateBIP9Parameters(d, nStartTime, nTimeout);\n }\n  \n+// bip135 begin\n+/**\n+ * Return true if a deployment is considered to be configured for the network.\n+ * Deployments with a zero-length name, or a windowsize or threshold equal to\n+ * zero are not considered to be configured, and will be reported as 'unknown'\n+ * if signals are detected for them.\n+ * Unconfigured deployments can be ignored to save processing time, e.g.\n+ * in ComputeBlockVersion() when computing the default block version to emit.\n+ */\n+bool isConfiguredDeployment(const Consensus::Params& consensusParams, const int bit)\n+{\n+    const Consensus::BIP9Deployment *vdeployments = consensusParams.vDeployments;\n+    const struct BIP9DeploymentInfo& vbinfo = VersionBitsDeploymentInfo[bit];\n+\n+    if (strlen(vbinfo.name) == 0)\n+        return false;\n+\n+    if (vdeployments[bit].windowsize == 0 || vdeployments[bit].threshold == 0)\n+    {\n+        return false;\n+    }\n+    return true;\n+}\n+\n+/**\n+ * Return a string representing CSV-formatted deployments for the network.\n+ * Only configured deployments satisfying isConfiguredDeployment() are included.\n+ */\n+const std::string NetworkDeploymentInfoCSV(const std::string& network)\n+{\n+    const Consensus::Params& consensusParams = Params(network).GetConsensus();\n+    const Consensus::BIP9Deployment *vdeployments = consensusParams.vDeployments;\n+\n+    std::string networkInfoStr;\n+    networkInfoStr = \"# deployment info for network '\" + network + \"':\\n\";\n+\n+    for (int bit = 0; bit < Consensus::MAX_VERSION_BITS_DEPLOYMENTS; bit++)\n+    {\n+        const struct BIP9DeploymentInfo& vbinfo = VersionBitsDeploymentInfo[bit];\n+        if (isConfiguredDeployment(consensusParams, bit)) {\n+            networkInfoStr += network + \",\";\n+            networkInfoStr += std::to_string(bit) + \",\";\n+            networkInfoStr += std::string(vbinfo.name) + \",\";\n+            networkInfoStr += std::to_string(vdeployments[bit].nStartTime) + \",\";\n+            networkInfoStr += std::to_string(vdeployments[bit].nTimeout) + \",\";\n+            networkInfoStr += std::to_string(vdeployments[bit].windowsize) + \",\";\n+            networkInfoStr += std::to_string(vdeployments[bit].threshold) + \",\";\n+            networkInfoStr += std::to_string(vdeployments[bit].minlockedblocks) + \",\";\n+            networkInfoStr += std::to_string(vdeployments[bit].minlockedtime) + \",\";\n+            networkInfoStr += (vbinfo.gbt_force ? \"true\" : \"false\");\n+            networkInfoStr += \"\\n\";\n+        }\n+    }\n+    return networkInfoStr;\n+}\n+\n+/**\n+ * Return a modifiable reference to the chain params, to be updated by the\n+ * CSV deployment data reading routine.\n+ */\n+CChainParams &ModifiableParams() {\n+    assert(globalChainParams);\n+    return *globalChainParams;\n+}\n+// bip135 end"
      },
      {
        "sha": "8274fbfac41991dee5ab3fdf3e90e50759d3fa84",
        "filename": "src/chainparams.h",
        "status": "modified",
        "additions": 25,
        "deletions": 1,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/chainparams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/chainparams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.h?ref=e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193",
        "patch": "@@ -1,5 +1,5 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2016 The Bitcoin Core developers\n+// Copyright (c) 2009-2017 The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -58,6 +58,8 @@ class CChainParams\n     };\n \n     const Consensus::Params& GetConsensus() const { return consensus; }\n+    /** Modifiable consensus parameters added by bip135 */\n+    Consensus::Params& GetModifiableConsensus() { return consensus; }\n     const CMessageHeader::MessageStartChars& MessageStart() const { return pchMessageStart; }\n     int GetDefaultPort() const { return nDefaultPort; }\n \n@@ -109,12 +111,34 @@ std::unique_ptr<CChainParams> CreateChainParams(const std::string& chain);\n  */\n const CChainParams &Params();\n \n+CChainParams& Params(const std::string& chain);\n+\n /**\n  * Sets the params returned by Params() to those for the given BIP70 chain name.\n  * @throws std::runtime_error when the chain is not supported.\n  */\n void SelectParams(const std::string& chain);\n \n+// bip135 begin\n+/**\n+ * Return the currently selected parameters. Can be changed by reading in\n+ * some additional config files (e.g. CSV deployment data)\n+ */\n+CChainParams &ModifiableParams();\n+\n+/**\n+ * Returns true if a deployment is considered active on a particular network\n+ */\n+\n+bool isConfiguredDeployment(const Consensus::Params& consensusParams, const int bit);\n+\n+/**\n+ * Dump the fork deployment parameters for the given BIP70 chain name.\n+ * @throws std::runtime_error when the chain is not supported.\n+ */\n+const std::string NetworkDeploymentInfoCSV(const std::string& chain);\n+// bip135 end\n+\n /**\n  * Allows modifying the BIP9 regtest parameters.\n  */"
      },
      {
        "sha": "faa02c0d89ed9c5a5ecd50d1ba31417d167380e1",
        "filename": "src/consensus/params.h",
        "status": "modified",
        "additions": 86,
        "deletions": 7,
        "changes": 93,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/consensus/params.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/consensus/params.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/params.h?ref=e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193",
        "patch": "@@ -1,5 +1,5 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2016 The Bitcoin Core developers\n+// Copyright (c) 2009-2017 The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -14,9 +14,44 @@ namespace Consensus {\n \n enum DeploymentPos\n {\n-    DEPLOYMENT_TESTDUMMY,\n-    DEPLOYMENT_CSV, // Deployment of BIP68, BIP112, and BIP113.\n-    DEPLOYMENT_SEGWIT, // Deployment of BIP141, BIP143, and BIP147.\n+    // bip135 begin\n+    // List of deployment bits. Known allocated bits should be described by a\n+    // name, even if their deployment logic is not implemented by the client.\n+    // (their info is nevertheless useful for awareness and event logging)\n+    // When a bit goes back to being unused, it should be renamed to\n+    // DEPLOYMENT_UNASSIGNED_BIT_x .\n+    // NOTE: Also add new deployments to VersionBitsDeploymentInfo in versionbits.cpp\n+    DEPLOYMENT_CSV = 0,  // bit 0 - deployment of BIP68, BIP112, and BIP113.\n+    DEPLOYMENT_SEGWIT,   // bit 1 - Segregated Witness (BIP141, BIP143, BIP147)\n+    // begin unassigned bits. Rename bits when allocated.\n+    DEPLOYMENT_UNASSIGNED_BIT_2,\n+    DEPLOYMENT_UNASSIGNED_BIT_3,\n+    DEPLOYMENT_UNASSIGNED_BIT_4,\n+    DEPLOYMENT_UNASSIGNED_BIT_5,\n+    DEPLOYMENT_UNASSIGNED_BIT_6,\n+    DEPLOYMENT_UNASSIGNED_BIT_7,\n+    DEPLOYMENT_UNASSIGNED_BIT_8,\n+    DEPLOYMENT_UNASSIGNED_BIT_9,\n+    DEPLOYMENT_UNASSIGNED_BIT_10,\n+    DEPLOYMENT_UNASSIGNED_BIT_11,\n+    DEPLOYMENT_UNASSIGNED_BIT_12,\n+    DEPLOYMENT_UNASSIGNED_BIT_13,\n+    DEPLOYMENT_UNASSIGNED_BIT_14,\n+    DEPLOYMENT_UNASSIGNED_BIT_15,\n+    DEPLOYMENT_UNASSIGNED_BIT_16,\n+    DEPLOYMENT_UNASSIGNED_BIT_17,\n+    DEPLOYMENT_UNASSIGNED_BIT_18,\n+    DEPLOYMENT_UNASSIGNED_BIT_19,\n+    DEPLOYMENT_UNASSIGNED_BIT_20,\n+    DEPLOYMENT_UNASSIGNED_BIT_21,\n+    DEPLOYMENT_UNASSIGNED_BIT_22,\n+    DEPLOYMENT_UNASSIGNED_BIT_23,\n+    DEPLOYMENT_UNASSIGNED_BIT_24,\n+    DEPLOYMENT_UNASSIGNED_BIT_25,\n+    DEPLOYMENT_UNASSIGNED_BIT_26,\n+    DEPLOYMENT_UNASSIGNED_BIT_27,\n+    DEPLOYMENT_TESTDUMMY,  // bit 28 - used for deployment testing purposes\n+    // bip135 end\n     // NOTE: Also add new deployments to VersionBitsDeploymentInfo in versionbits.cpp\n     MAX_VERSION_BITS_DEPLOYMENTS\n };\n@@ -31,6 +66,16 @@ struct BIP9Deployment {\n     int64_t nStartTime;\n     /** Timeout/expiry MedianTime for the deployment attempt. */\n     int64_t nTimeout;\n+    // bip135 begin added parameters\n+    /** Window size (in blocks) for generalized versionbits signal tallying */\n+    int windowsize;\n+    /** Threshold (in blocks / window) for generalized versionbits lock-in */\n+    int threshold;\n+    /** Minimum number of blocks to remain in locked-in state */\n+    int minlockedblocks;\n+    /** Minimum duration (in seconds based on MTP) to remain in locked-in state */\n+    int64_t minlockedtime;\n+    // bip135 end added parameters\n };\n \n /**\n@@ -51,9 +96,43 @@ struct Params {\n      * (nPowTargetTimespan / nPowTargetSpacing) which is also used for BIP9 deployments.\n      * Examples: 1916 for 95%, 1512 for testchains.\n      */\n-    uint32_t nRuleChangeActivationThreshold;\n-    uint32_t nMinerConfirmationWindow;\n-    BIP9Deployment vDeployments[MAX_VERSION_BITS_DEPLOYMENTS];\n+    /**\n+     * Deployment parameters for the 29 bits (0..28) defined by bip135\n+     */\n+    // bip135 begin\n+    // fully initialize array\n+    BIP9Deployment vDeployments[MAX_VERSION_BITS_DEPLOYMENTS] = {\n+            { 0, 0LL, 0LL, 0, 0, 0, 0LL },  // deployment on bit 0\n+            { 1, 0LL, 0LL, 0, 0, 0, 0LL },  // deployment on bit 1\n+            { 2, 0LL, 0LL, 0, 0, 0, 0LL },  // deployment on bit 2\n+            { 3, 0LL, 0LL, 0, 0, 0, 0LL },  // deployment on bit 3\n+            { 4, 0LL, 0LL, 0, 0, 0, 0LL },  // deployment on bit 4\n+            { 5, 0LL, 0LL, 0, 0, 0, 0LL },  // deployment on bit 5\n+            { 6, 0LL, 0LL, 0, 0, 0, 0LL },  // deployment on bit 6\n+            { 7, 0LL, 0LL, 0, 0, 0, 0LL },  // deployment on bit 7\n+            { 8, 0LL, 0LL, 0, 0, 0, 0LL },  // deployment on bit 8\n+            { 9, 0LL, 0LL, 0, 0, 0, 0LL },  // deployment on bit 9\n+            { 10, 0LL, 0LL, 0, 0, 0, 0LL }, // deployment on bit 10\n+            { 11, 0LL, 0LL, 0, 0, 0, 0LL }, // deployment on bit 11\n+            { 12, 0LL, 0LL, 0, 0, 0, 0LL }, // deployment on bit 12\n+            { 13, 0LL, 0LL, 0, 0, 0, 0LL }, // deployment on bit 13\n+            { 14, 0LL, 0LL, 0, 0, 0, 0LL }, // deployment on bit 14\n+            { 15, 0LL, 0LL, 0, 0, 0, 0LL }, // deployment on bit 15\n+            { 16, 0LL, 0LL, 0, 0, 0, 0LL }, // deployment on bit 16\n+            { 17, 0LL, 0LL, 0, 0, 0, 0LL }, // deployment on bit 17\n+            { 18, 0LL, 0LL, 0, 0, 0, 0LL }, // deployment on bit 18\n+            { 19, 0LL, 0LL, 0, 0, 0, 0LL }, // deployment on bit 19\n+            { 20, 0LL, 0LL, 0, 0, 0, 0LL }, // deployment on bit 20\n+            { 21, 0LL, 0LL, 0, 0, 0, 0LL }, // deployment on bit 21\n+            { 22, 0LL, 0LL, 0, 0, 0, 0LL }, // deployment on bit 22\n+            { 23, 0LL, 0LL, 0, 0, 0, 0LL }, // deployment on bit 23\n+            { 24, 0LL, 0LL, 0, 0, 0, 0LL }, // deployment on bit 24\n+            { 25, 0LL, 0LL, 0, 0, 0, 0LL }, // deployment on bit 25\n+            { 26, 0LL, 0LL, 0, 0, 0, 0LL }, // deployment on bit 26\n+            { 27, 0LL, 0LL, 0, 0, 0, 0LL }, // deployment on bit 27\n+            { 28, 0LL, 0LL, 0, 0, 0, 0LL }, // deployment on bit 28\n+    };\n+    // bip135 end\n     /** Proof of work parameters */\n     uint256 powLimit;\n     bool fPowAllowMinDifficultyBlocks;"
      },
      {
        "sha": "1552bb97757e8ec46dd83638ae9b6e0d51542548",
        "filename": "src/forks_csv.cpp",
        "status": "added",
        "additions": 240,
        "deletions": 0,
        "changes": 240,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/forks_csv.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/forks_csv.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/forks_csv.cpp?ref=e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193",
        "patch": "@@ -0,0 +1,240 @@\n+// Copyright (c) 2017 The Bitcoin developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <inttypes.h>\n+#include <string>\n+#include <boost/algorithm/string.hpp>\n+\n+#include \"fast-cpp-csv-parser/csv.h\"\n+\n+#include \"chainparamsbase.h\"\n+#include \"forks_csv.h\"\n+#include \"util.h\"\n+\n+\n+using namespace std;\n+using namespace io;\n+\n+// bip135 begin\n+/** File header for -dumpforks output */\n+const char *FORKS_CSV_FILE_HEADER = \\\n+    \"# forks.csv - Fork deployment configuration (from built-in defaults)\\n\" \\\n+    \"# This file defines the known consensus changes tracked by the software\\n\" \\\n+    \"# MODIFY AT OWN RISK - EXERCISE EXTREME CARE\\n\" \\\n+    \"# Line format:\\n\" \\\n+    \"# network,bit,name,starttime,timeout,windowsize,threshold,minlockedblocks,minlockedtime,gbtforce\\n\";\n+// bip135 end\n+\n+/**\n+ * Read deployment CSV file and update consensus parameters\n+ */\n+bool ReadForksCsv(string activeNetworkID, istream& csvInput, Consensus::Params& consensusParams)\n+{\n+    string network, name, gbtforce;\n+    int bit, windowsize, threshold, minlockedblocks;\n+    int64_t starttime, timeout, minlockedtime;\n+    bool errors_found = false;\n+\n+    // set up CSV reader instance\n+    CSVReader<10,\n+              trim_chars<' ', '\\t'>,\n+              double_quote_escape<',','\\\"'>,\n+              throw_on_overflow,\n+              single_line_comment<'#', ';'> > in(FORKS_CSV_FILENAME, csvInput);\n+\n+    // set meaning of fields - header in file should remain commented out\n+    in.set_header(\"network\",\n+                  \"bit\",\n+                  \"name\",\n+                  \"starttime\",\n+                  \"timeout\",\n+                  \"windowsize\",\n+                  \"threshold\",\n+                  \"minlockedblocks\",\n+                  \"minlockedtime\",\n+                  \"gbtforce\");\n+\n+    // read lines, skipping comments\n+    try {\n+        while(in.read_row(network,\n+                          bit,\n+                          name,\n+                          starttime,\n+                          timeout,\n+                          windowsize,\n+                          threshold,\n+                          minlockedblocks,\n+                          minlockedtime,\n+                          gbtforce))\n+        {\n+\n+            bool line_validates_ok = true;\n+            ostringstream errStringStream;\n+            // prepare an error message prefix string\n+            errStringStream << \"Error: \" << FORKS_CSV_FILENAME << \":\" << in.get_file_line() << \" \";\n+\n+            // validate all the input fields (if there was an error the parser\n+            // would throw an exception that is handled below\n+            if (!ValidateNetwork(network)) {\n+                string errStr = errStringStream.str() + \"unknown network name '\" + network + \"'\";\n+                LineValidationError(errStr);\n+                line_validates_ok = false;\n+            }\n+\n+            if (!ValidateBit(bit)) {\n+                string errStr = errStringStream.str() + \"invalid bit number (\" + to_string(bit) + \")\";\n+                LineValidationError(errStr);\n+                line_validates_ok = false;\n+            }\n+\n+            if (!ValidateForkName(name)) {\n+                string errStr = errStringStream.str() + \"invalid fork name '\" + name + \"'\";\n+                LineValidationError(errStr);\n+                line_validates_ok = false;\n+            }\n+\n+            if (!ValidateTimes(starttime, timeout)) {\n+                string errStr = errStringStream.str() + \"invalid starttime/timeout\";\n+                LineValidationError(errStr);\n+                line_validates_ok = false;\n+            }\n+\n+            if (!ValidateWindowSize(windowsize)) {\n+                string errStr = errStringStream.str() + \"invalid window size (\"+ to_string(windowsize) + \")\";\n+                LineValidationError(errStr);\n+                line_validates_ok = false;\n+            }\n+\n+            if (!ValidateThreshold(threshold, windowsize)) {\n+                string errStr = errStringStream.str() + \"invalid threshold (\"+ to_string(threshold) + \")\";\n+                LineValidationError(errStr);\n+                line_validates_ok = false;\n+            }\n+\n+            if (!line_validates_ok) {\n+                // set errors and skip to next line if current one did not validate.\n+                errors_found = true;\n+                continue;\n+            }\n+            else {\n+                // Can do more overall validation of the line data here.\n+                // This is not yet implemented.\n+            }\n+\n+            // update the fork parameters only if matching the active network\n+            // the rest are validated, but not activated.\n+            // NOTE: ValidateOverallParams() is stubbed.\n+            if (network == activeNetworkID && ValidateOverallParams(network)) {\n+                assert(bit >= 0 && bit < VERSIONBITS_NUM_BITS);\n+                // update deployment params for current network\n+                BIP9DeploymentInfo& vbinfo = VersionBitsDeploymentInfo[bit];\n+\n+                // copy the data\n+                if (name.length()) {\n+                    char* c = new char[name.length() + 1];\n+                    strncpy(c, name.c_str(), name.length());\n+                    c[name.length()] = 0;\n+                    vbinfo.name = c;\n+                }\n+                consensusParams.vDeployments[bit].bit = bit;\n+                consensusParams.vDeployments[bit].nStartTime = starttime;\n+                consensusParams.vDeployments[bit].nTimeout = timeout;\n+                consensusParams.vDeployments[bit].windowsize = windowsize;\n+                consensusParams.vDeployments[bit].threshold = threshold;\n+                consensusParams.vDeployments[bit].minlockedblocks = minlockedblocks;\n+                consensusParams.vDeployments[bit].minlockedtime = minlockedtime;\n+            }\n+        }\n+    }\n+    catch (const std::exception& e) {\n+        string errStr = e.what();\n+        LineValidationError(errStr);\n+        return false;\n+    }\n+    return (!errors_found);\n+}\n+\n+\n+bool ValidateNetwork(const string& networkname)\n+{\n+    // check that network is one we know about\n+    if (networkname == CBaseChainParams::MAIN)\n+        return true;\n+    else if (networkname == CBaseChainParams::TESTNET)\n+        return true;\n+    else if (networkname == CBaseChainParams::REGTEST)\n+        return true;\n+    else\n+        return false;\n+}\n+\n+\n+bool ValidateForkName(const string& forkname)\n+{\n+    return (forkname.length() > 0);\n+}\n+\n+\n+bool ValidateGBTForce(const string& gbtforce)\n+{\n+    string gbtforceLower(gbtforce);\n+    boost::algorithm::to_lower(gbtforceLower);\n+    if (gbtforceLower == \"false\" || gbtforceLower == \"true\")\n+        return true;\n+    else\n+        return false;\n+}\n+\n+\n+bool ValidateBit(int bit)\n+{\n+    return (bit >= 0 && bit < VERSIONBITS_NUM_BITS);\n+}\n+\n+\n+bool ValidateWindowSize(int windowsize)\n+{\n+    return (windowsize > 1);\n+}\n+\n+\n+bool ValidateThreshold(int threshold, int window)\n+{\n+    return (ValidateWindowSize(window) && threshold > 0 && threshold <= window);\n+}\n+\n+\n+bool ValidateTimes(int64_t starttime, int64_t timeout)\n+{\n+    return (starttime >= 0 && starttime < timeout);\n+}\n+\n+\n+bool ValidateMinLockedBlocks(int minlockedblocks)\n+{\n+    return (minlockedblocks >= 0);\n+}\n+\n+\n+bool ValidateMinLockedTime(int64_t minlockedtime)\n+{\n+    return (minlockedtime >= 0);\n+}\n+\n+\n+bool ValidateOverallParams(const string& checkNetworkID)\n+{\n+    // Stubbed function which should cross-check all parameters for the\n+    // given network and return true only if they are correct and consistent.\n+    //\n+    // This includes checks like duplicate bits or fork names, and disjointness\n+    // of time ranges of forks.\n+    return true;\n+}\n+\n+\n+void LineValidationError(string errmsg)\n+{\n+    LogPrintf(\"%s\\n\", errmsg);\n+}"
      },
      {
        "sha": "31e7aaba4404332465e018f66cf704af4d0f170d",
        "filename": "src/forks_csv.h",
        "status": "added",
        "additions": 52,
        "deletions": 0,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/forks_csv.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/forks_csv.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/forks_csv.h?ref=e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193",
        "patch": "@@ -0,0 +1,52 @@\n+// Copyright (c) 2017 The Bitcoin developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_FORKS_CSV\n+#define BITCOIN_FORKS_CSV\n+\n+#include <fstream>\n+\n+#include \"consensus/params.h\"\n+#include \"versionbits.h\"\n+\n+extern const char *const FORKS_CSV_FILENAME;  // from util.cpp\n+extern const char *FORKS_CSV_FILE_HEADER;\n+\n+\n+/**\n+ * Reads the CSV file and updates data in the consensus params.\n+ * Returns true if the data validated correctly, or false if any validation errors.\n+ * Validation errors should result in caller aborting safely rather than\n+ * proceeding on possibly incomplete fork data.\n+ */\n+extern bool ReadForksCsv(std::string activeNetworkID, std::istream& csvInput, Consensus::Params& consensusParams);\n+\n+/**\n+ * individual deployment line item validation functions.\n+ * Each function returns true if items checked are ok, false otherwise.\n+ */\n+bool ValidateNetwork(const std::string& networkname);\n+bool ValidateForkName(const std::string& forkname);\n+bool ValidateGBTForce(const std::string& gbtforce);\n+bool ValidateBit(const int bit);\n+bool ValidateWindowSize(const int windowsize);\n+bool ValidateThreshold(const int threshold, const int window);\n+bool ValidateTimes(const int64_t starttime, const int64_t timeout);\n+bool ValidateMinLockedBlocks(const int minlockedblocks);\n+bool ValidateMinLockedTime(const int64_t minlockedtime);\n+\n+/**\n+ * Validate the deployment parameters for the entire network altogether.\n+ * This can catch things like repeated name / bits, overlapping deployment times\n+ * etc.\n+ */\n+bool ValidateOverallParams(const std::string& checkNetworkID);\n+\n+/**\n+ * Print an error message if validation of a line fails on an item.\n+ * This is logged both to file and to stderr to alert the operator.\n+ */\n+void LineValidationError(std::string errmsg);\n+\n+#endif"
      },
      {
        "sha": "10831f538b32011dbb5e16b5c2ab3a9388040e60",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 48,
        "deletions": 2,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193",
        "patch": "@@ -16,6 +16,7 @@\n #include \"checkpoints.h\"\n #include \"compat/sanity.h\"\n #include \"consensus/validation.h\"\n+#include \"forks_csv.h\"\n #include \"fs.h\"\n #include \"httpserver.h\"\n #include \"httprpc.h\"\n@@ -346,6 +347,10 @@ std::string HelpMessage(HelpMessageMode mode)\n         strUsage += HelpMessageOpt(\"-blocksonly\", strprintf(_(\"Whether to operate in a blocks only mode (default: %u)\"), DEFAULT_BLOCKSONLY));\n     strUsage +=HelpMessageOpt(\"-assumevalid=<hex>\", strprintf(_(\"If this block is in the chain assume that it and its ancestors are valid and potentially skip their script verification (0 to verify all, default: %s, testnet: %s)\"), defaultChainParams->GetConsensus().defaultAssumeValid.GetHex(), testnetChainParams->GetConsensus().defaultAssumeValid.GetHex()));\n     strUsage += HelpMessageOpt(\"-conf=<file>\", strprintf(_(\"Specify configuration file (default: %s)\"), BITCOIN_CONF_FILENAME));\n+    // bip135 begin\n+    strUsage += HelpMessageOpt(\"-forks=<file>\", strprintf(_(\"Specify fork deployment file (default: %s)\"), FORKS_CSV_FILENAME));\n+    strUsage += HelpMessageOpt(\"-dumpforks\", _(\"Dump built-in fork deployment data in CSV format and exit\"));\n+    // bip135 end\n     if (mode == HMM_BITCOIND)\n     {\n #if HAVE_DECL_DAEMON\n@@ -887,8 +892,11 @@ bool AppInitBasicSetup()\n \n bool AppInitParameterInteraction()\n {\n-    const CChainParams& chainparams = Params();\n     // ********************************************************* Step 2: parameter interactions\n+    // bip135 begin\n+    // changed from const to modifiable so that deployment params can be updated\n+    CChainParams& chainparams = ModifiableParams();\n+    // bip135 end\n \n     // also see: InitParameterInteraction()\n \n@@ -1181,7 +1189,7 @@ bool AppInitSanityChecks()\n \n bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n {\n-    const CChainParams& chainparams = Params();\n+    CChainParams& chainparams = ModifiableParams();  // bip135 changed\n     // ********************************************************* Step 4a: application initialization\n     // After daemonization get the data directory lock again and hold on to it until exit\n     // This creates a slight window for a race condition to happen, however this condition is harmless: it\n@@ -1210,6 +1218,44 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n     LogPrintf(\"Using config file %s\\n\", GetConfigFile(GetArg(\"-conf\", BITCOIN_CONF_FILENAME)).string());\n     LogPrintf(\"Using at most %i automatic connections (%i file descriptors available)\\n\", nMaxConnections, nFD);\n \n+    // bip135 begin\n+    // check for fork deployment CSV file, read it\n+    std::string ForksCsvFile = GetForksCsvFile().string();\n+\n+    if (boost::filesystem::exists(ForksCsvFile))\n+    {\n+        std::ifstream csvFile;\n+        bool CsvReadOk = true;\n+        try\n+        {\n+            csvFile.open(ForksCsvFile.c_str(), std::ios::in);\n+            if ( csvFile.fail()) {\n+                throw std::runtime_error(\"unable to open deployment file for reading\");\n+            }\n+\n+            LogPrintf(\"Reading deployment configuration CSV file at '%s'\\n\", ForksCsvFile);\n+            // read the CSV file and apply the parameters for current network\n+            CsvReadOk = ReadForksCsv(chainparams.NetworkIDString(), csvFile, chainparams.GetModifiableConsensus());\n+            csvFile.close();\n+        }\n+        catch (const std::exception& e)\n+        {\n+            LogPrintf(\"Unable to read '%s'\\n\", ForksCsvFile);\n+            // if unable to read file which is present: abort\n+            return InitError(strprintf(_(\"Warning: Could not open deployment configuration CSV file '%s' for reading\"), ForksCsvFile));\n+        }\n+        // if the deployments data doesn't validate correctly, shut down for safety reasons.\n+        if (!CsvReadOk) {\n+            LogPrintf(\"Validation of '%s' failed\\n\", ForksCsvFile);\n+            return InitError(strprintf(_(\"Deployment configuration file '%s' contained invalid data - see debug.log\"), ForksCsvFile));\n+        }\n+    }\n+    else {\n+        // be noisy, but don't fail if file is absent - use built-in defaults\n+        LogPrintf(\"No deployment configuration found at '%s' - using defaults\\n\", ForksCsvFile);\n+    }\n+    // bip135 end\n+\n     InitSignatureCache();\n \n     LogPrintf(\"Using %u threads for script verification\\n\", nScriptCheckThreads);"
      },
      {
        "sha": "a86279cec92d140f6e50e8277f73cf80f0432da2",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 54,
        "deletions": 4,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193",
        "patch": "@@ -1077,7 +1077,7 @@ static UniValue BIP9SoftForkDesc(const Consensus::Params& consensusParams, Conse\n     if (THRESHOLD_STARTED == thresholdState)\n     {\n         UniValue statsUV(UniValue::VOBJ);\n-        BIP9Stats statsStruct = VersionBitsTipStatistics(consensusParams, id);\n+        ForkStats statsStruct = VersionBitsTipStatistics(consensusParams, id);\n         statsUV.push_back(Pair(\"period\", statsStruct.period));\n         statsUV.push_back(Pair(\"threshold\", statsStruct.threshold));\n         statsUV.push_back(Pair(\"elapsed\", statsStruct.elapsed));\n@@ -1088,6 +1088,29 @@ static UniValue BIP9SoftForkDesc(const Consensus::Params& consensusParams, Conse\n     return rv;\n }\n \n+// bip135 begin\n+static UniValue BIP135ForkDesc(const Consensus::Params& consensusParams, Consensus::DeploymentPos id)\n+{\n+    UniValue rv(UniValue::VOBJ);\n+    rv.push_back(Pair(\"bit\", (int)id));\n+    const ThresholdState thresholdState = VersionBitsTipState(consensusParams, id);\n+    switch (thresholdState) {\n+    case THRESHOLD_DEFINED: rv.push_back(Pair(\"status\", \"defined\")); break;\n+    case THRESHOLD_STARTED: rv.push_back(Pair(\"status\", \"started\")); break;\n+    case THRESHOLD_LOCKED_IN: rv.push_back(Pair(\"status\", \"locked_in\")); break;\n+    case THRESHOLD_ACTIVE: rv.push_back(Pair(\"status\", \"active\")); break;\n+    case THRESHOLD_FAILED: rv.push_back(Pair(\"status\", \"failed\")); break;\n+    }\n+    rv.push_back(Pair(\"startTime\", consensusParams.vDeployments[id].nStartTime));\n+    rv.push_back(Pair(\"timeout\", consensusParams.vDeployments[id].nTimeout));\n+    rv.push_back(Pair(\"windowsize\", consensusParams.vDeployments[id].windowsize));\n+    rv.push_back(Pair(\"threshold\", consensusParams.vDeployments[id].threshold));\n+    rv.push_back(Pair(\"minlockedblocks\", consensusParams.vDeployments[id].minlockedblocks));\n+    rv.push_back(Pair(\"minlockedtime\", consensusParams.vDeployments[id].minlockedtime));\n+    return rv;\n+}\n+// bip135 end\n+\n void BIP9SoftForkDescPushBack(UniValue& bip9_softforks, const std::string &name, const Consensus::Params& consensusParams, Consensus::DeploymentPos id)\n {\n     // Deployments with timeout value of 0 are hidden.\n@@ -1126,7 +1149,7 @@ UniValue getblockchaininfo(const JSONRPCRequest& request)\n             \"  ],\\n\"\n             \"  \\\"bip9_softforks\\\": {          (object) status of BIP9 softforks in progress\\n\"\n             \"     \\\"xxxx\\\" : {                (string) name of the softfork\\n\"\n-            \"        \\\"status\\\": \\\"xxxx\\\",    (string) one of \\\"defined\\\", \\\"started\\\", \\\"locked_in\\\", \\\"active\\\", \\\"failed\\\"\\n\"\n+            \"        \\\"status\\\": \\\"xxxx\\\",      (string) one of \\\"defined\\\", \\\"started\\\", \\\"locked_in\\\", \\\"active\\\", \\\"failed\\\"\\n\"\n             \"        \\\"bit\\\": xx,             (numeric) the bit (0-28) in the block version field used to signal this softfork (only for \\\"started\\\" status)\\n\"\n             \"        \\\"startTime\\\": xx,       (numeric) the minimum median time past of a block at which the bit gains its meaning\\n\"\n             \"        \\\"timeout\\\": xx,         (numeric) the median time past of a block at which the deployment is considered failed if not yet locked in\\n\"\n@@ -1140,6 +1163,19 @@ UniValue getblockchaininfo(const JSONRPCRequest& request)\n             \"        }\\n\"\n             \"     }\\n\"\n             \"  }\\n\"\n+            // bip135 begin\n+            \"  \\\"bip135_forks\\\": {            (object) status of BIP135 forks in progress\\n\"\n+            \"     \\\"xxxx\\\" : {                (string) name of the fork\\n\"\n+            \"        \\\"status\\\": \\\"xxxx\\\",      (string) one of \\\"defined\\\", \\\"started\\\", \\\"locked_in\\\", \\\"active\\\", \\\"failed\\\"\\n\"\n+            \"        \\\"bit\\\": xx,             (numeric) the bit (0-28) in the block version field used to signal this fork (only for \\\"started\\\" status)\\n\"\n+            \"        \\\"startTime\\\": xx,       (numeric) the minimum median time past of a block at which the bit gains its meaning\\n\"\n+            \"        \\\"windowsize\\\": xx,      (numeric) the number of blocks over which the fork status is tallied\\n\"\n+            \"        \\\"threshold\\\": xx,       (numeric) the number of blocks in a window that must signal for fork to lock in\\n\"\n+            \"        \\\"minlockedblocks\\\": xx, (numeric) the minimum number of blocks to elapse after lock-in and before activation\\n\"\n+            \"        \\\"minlockedtime\\\": xx,   (numeric) the minimum number of seconds to elapse after median time past of lock-in until activation\\n\"\n+            \"     }\\n\"\n+            \"  }\\n\"\n+            // bip135 end\n             \"}\\n\"\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"getblockchaininfo\", \"\")\n@@ -1163,13 +1199,27 @@ UniValue getblockchaininfo(const JSONRPCRequest& request)\n     CBlockIndex* tip = chainActive.Tip();\n     UniValue softforks(UniValue::VARR);\n     UniValue bip9_softforks(UniValue::VOBJ);\n+    UniValue bip135_forks(UniValue::VOBJ);  // bip135 added\n     softforks.push_back(SoftForkDesc(\"bip34\", 2, tip, consensusParams));\n     softforks.push_back(SoftForkDesc(\"bip66\", 3, tip, consensusParams));\n     softforks.push_back(SoftForkDesc(\"bip65\", 4, tip, consensusParams));\n-    BIP9SoftForkDescPushBack(bip9_softforks, \"csv\", consensusParams, Consensus::DEPLOYMENT_CSV);\n-    BIP9SoftForkDescPushBack(bip9_softforks, \"segwit\", consensusParams, Consensus::DEPLOYMENT_SEGWIT);\n+    // bip135 begin : add all the configured forks\n+    assert (Consensus::MAX_VERSION_BITS_DEPLOYMENTS <= VERSIONBITS_NUM_BITS);\n+    for (int i = 0; i < Consensus::MAX_VERSION_BITS_DEPLOYMENTS; i++)\n+    {\n+        Consensus::DeploymentPos bit = static_cast<Consensus::DeploymentPos>(i);\n+        const struct BIP9DeploymentInfo& vbinfo = VersionBitsDeploymentInfo[bit];\n+        if (isConfiguredDeployment(consensusParams, bit)) {\n+            bip9_softforks.push_back(Pair(vbinfo.name, BIP9SoftForkDesc(consensusParams, bit)));\n+            bip135_forks.push_back(Pair(vbinfo.name, BIP135ForkDesc(consensusParams, bit)));\n+        }\n+    }\n+\n     obj.push_back(Pair(\"softforks\",             softforks));\n     obj.push_back(Pair(\"bip9_softforks\", bip9_softforks));\n+    // to maintain backward compat initially, we introduce a new list for the full BIP135 data\n+    obj.push_back(Pair(\"bip135_forks\", bip135_forks));\n+    // bip135 end\n \n     if (fPruneMode)\n     {"
      },
      {
        "sha": "3047c2983c16a3468463480973b70cdd779a094e",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 34,
        "deletions": 32,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193",
        "patch": "@@ -616,42 +616,44 @@ UniValue getblocktemplate(const JSONRPCRequest& request)\n     UniValue aRules(UniValue::VARR);\n     UniValue vbavailable(UniValue::VOBJ);\n     for (int j = 0; j < (int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; ++j) {\n-        Consensus::DeploymentPos pos = Consensus::DeploymentPos(j);\n-        ThresholdState state = VersionBitsState(pindexPrev, consensusParams, pos, versionbitscache);\n-        switch (state) {\n-            case THRESHOLD_DEFINED:\n-            case THRESHOLD_FAILED:\n-                // Not exposed to GBT at all\n-                break;\n-            case THRESHOLD_LOCKED_IN:\n-                // Ensure bit is set in block version\n-                pblock->nVersion |= VersionBitsMask(consensusParams, pos);\n-                // FALL THROUGH to get vbavailable set...\n-            case THRESHOLD_STARTED:\n-            {\n-                const struct BIP9DeploymentInfo& vbinfo = VersionBitsDeploymentInfo[pos];\n-                vbavailable.push_back(Pair(gbt_vb_name(pos), consensusParams.vDeployments[pos].bit));\n-                if (setClientRules.find(vbinfo.name) == setClientRules.end()) {\n-                    if (!vbinfo.gbt_force) {\n-                        // If the client doesn't support this, don't indicate it in the [default] version\n-                        pblock->nVersion &= ~VersionBitsMask(consensusParams, pos);\n+        if (Params().NetworkIDString() != CBaseChainParams::REGTEST || j != Consensus::DEPLOYMENT_TESTDUMMY) {\n+            Consensus::DeploymentPos pos = Consensus::DeploymentPos(j);\n+            ThresholdState state = VersionBitsState(pindexPrev, consensusParams, pos, versionbitscache);\n+            switch (state) {\n+                case THRESHOLD_DEFINED:\n+                case THRESHOLD_FAILED:\n+                    // Not exposed to GBT at all\n+                    break;\n+                case THRESHOLD_LOCKED_IN:\n+                    // Ensure bit is set in block version\n+                    pblock->nVersion |= VersionBitsMask(consensusParams, pos);\n+                    // FALL THROUGH to get vbavailable set...\n+                case THRESHOLD_STARTED:\n+                {\n+                    const struct BIP9DeploymentInfo& vbinfo = VersionBitsDeploymentInfo[pos];\n+                    vbavailable.push_back(Pair(gbt_vb_name(pos), consensusParams.vDeployments[pos].bit));\n+                    if (setClientRules.find(vbinfo.name) == setClientRules.end()) {\n+                        if (!vbinfo.gbt_force) {\n+                            // If the client doesn't support this, don't indicate it in the [default] version\n+                            pblock->nVersion &= ~VersionBitsMask(consensusParams, pos);\n+                        }\n                     }\n+                    break;\n                 }\n-                break;\n-            }\n-            case THRESHOLD_ACTIVE:\n-            {\n-                // Add to rules only\n-                const struct BIP9DeploymentInfo& vbinfo = VersionBitsDeploymentInfo[pos];\n-                aRules.push_back(gbt_vb_name(pos));\n-                if (setClientRules.find(vbinfo.name) == setClientRules.end()) {\n-                    // Not supported by the client; make sure it's safe to proceed\n-                    if (!vbinfo.gbt_force) {\n-                        // If we do anything other than throw an exception here, be sure version/force isn't sent to old clients\n-                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Support for '%s' rule requires explicit client support\", vbinfo.name));\n+                case THRESHOLD_ACTIVE:\n+                {\n+                    // Add to rules only\n+                    const struct BIP9DeploymentInfo& vbinfo = VersionBitsDeploymentInfo[pos];\n+                    aRules.push_back(gbt_vb_name(pos));\n+                    if (setClientRules.find(vbinfo.name) == setClientRules.end()) {\n+                        // Not supported by the client; make sure it's safe to proceed\n+                        if (!vbinfo.gbt_force) {\n+                            // If we do anything other than throw an exception here, be sure version/force isn't sent to old clients\n+                            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Support for '%s' rule requires explicit client support\", vbinfo.name));\n+                        }\n                     }\n+                    break;\n                 }\n-                break;\n             }\n         }\n     }"
      },
      {
        "sha": "718f733cc205778975dcff94a1635ec684a2fd33",
        "filename": "src/test/forkscsv_tests.cpp",
        "status": "added",
        "additions": 170,
        "deletions": 0,
        "changes": 170,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/test/forkscsv_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/test/forkscsv_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/forkscsv_tests.cpp?ref=e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193",
        "patch": "@@ -0,0 +1,170 @@\n+// Copyright (c) 2017 The Bitcoin developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <limits>\n+#include <string>\n+\n+#include \"chainparams.h\"\n+#include \"forks_csv.h\"\n+#include \"test/test_bitcoin.h\"\n+\n+#include <boost/test/unit_test.hpp>\n+\n+namespace utf = boost::unit_test;\n+\n+\n+BOOST_FIXTURE_TEST_SUITE(forkscsv_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(forkscsv_read_test)\n+{\n+    CChainParams& params = ModifiableParams();\n+\n+    // read of emptiness should be ok for now.\n+    // In a better implementation, overall file validation should warn the user\n+    // if no data lines were found in the file.\n+    std::istringstream is_0(\"\");\n+    BOOST_CHECK(ReadForksCsv(\"main\", is_0, params.GetModifiableConsensus()));\n+\n+    std::istringstream is_1(\n+            \"# deployment info for network 'main':\\n\"\n+            \"main,0,csv,1462060800,1493596800,2016,1916,0,0,true\\n\"\n+            \"main,28,testdummy,1199145601,1230767999,2016,1916,0,0,false\\n\");\n+    BOOST_CHECK(ReadForksCsv(\"main\", is_1, params.GetModifiableConsensus()));\n+\n+    std::istringstream is_2(\n+            \"# deployment info for network 'main':\\n\"\n+            \"main,0,csv,1462060800,1493596800,2016,1916,0,0,true\\n\"\n+            \"main,1,segwit,1479168000,1510704000,2016,1916,0,0,true\\n\"\n+            \"main,28,testdummy,1199145601,1230767999,2016,1916,0,0,false\\n\");\n+    BOOST_CHECK(ReadForksCsv(\"main\", is_2, params.GetModifiableConsensus()));\n+}\n+\n+/**\n+ * Test CSV dump of built-in defaults.\n+ * NOTE: the dump of 'main' data in this test depends on forkscsv_read_test\n+ * as long as the 'segwit' line is not built-in.\n+ * That is why an explicit dependency has been declared here.\n+ */\n+BOOST_AUTO_TEST_CASE(forkscsv_dumpforks_test, * utf::depends_on(\"forkscsv_tests/forkscsv_read_test\"))\n+{\n+    BOOST_CHECK(NetworkDeploymentInfoCSV(CBaseChainParams::MAIN) == std::string(\n+            \"# deployment info for network 'main':\\n\"\n+            \"main,0,csv,1462060800,1493596800,2016,1916,0,0,true\\n\"\n+            \"main,1,segwit,1479168000,1510704000,2016,1916,0,0,true\\n\"\n+            \"main,28,testdummy,1199145601,1230767999,2016,1916,0,0,false\\n\"));\n+\n+    BOOST_CHECK(NetworkDeploymentInfoCSV(CBaseChainParams::TESTNET) == std::string(\n+            \"# deployment info for network 'test':\\n\"\n+            \"test,0,csv,1456790400,1493596800,2016,1512,0,0,true\\n\"\n+            \"test,1,segwit,1462060800,1493596800,2016,1512,0,0,true\\n\"\n+            \"test,28,testdummy,1199145601,1230767999,2016,1512,0,0,false\\n\"));\n+\n+    BOOST_CHECK(NetworkDeploymentInfoCSV(CBaseChainParams::REGTEST) == std::string(\n+            \"# deployment info for network 'regtest':\\n\"\n+            \"regtest,0,csv,0,999999999999,144,108,0,0,true\\n\"\n+            \"regtest,1,segwit,0,999999999999,144,108,0,0,true\\n\"\n+            \"regtest,28,testdummy,0,999999999999,144,108,0,0,false\\n\"));\n+\n+    BOOST_CHECK_THROW( NetworkDeploymentInfoCSV(\"_foo_\"), std::runtime_error );\n+}\n+\n+/**\n+ * Test validation of CSV input fields\n+ */\n+BOOST_AUTO_TEST_CASE(forkscsv_validation_test)\n+{\n+    // bit number\n+    for (int num = 0; num < VERSIONBITS_NUM_BITS; num++) {\n+        BOOST_CHECK(ValidateBit(num));\n+    }\n+    BOOST_CHECK(!ValidateBit(VERSIONBITS_NUM_BITS + 1));\n+    BOOST_CHECK(!ValidateBit(-1));\n+\n+    // network name\n+    BOOST_CHECK(ValidateNetwork(CBaseChainParams::MAIN));\n+    BOOST_CHECK(ValidateNetwork(CBaseChainParams::TESTNET));\n+    BOOST_CHECK(ValidateNetwork(CBaseChainParams::REGTEST));\n+    BOOST_CHECK(!ValidateNetwork(\"nonexistent_net\"));\n+    BOOST_CHECK(!ValidateNetwork(\"\"));\n+\n+    // gbt_force\n+    BOOST_CHECK(ValidateGBTForce(\"true\"));\n+    BOOST_CHECK(ValidateGBTForce(\"false\"));\n+    BOOST_CHECK(ValidateGBTForce(\"True\"));\n+    BOOST_CHECK(ValidateGBTForce(\"False\"));\n+    BOOST_CHECK(ValidateGBTForce(\"TRUE\"));\n+    BOOST_CHECK(ValidateGBTForce(\"FALSE\"));\n+    BOOST_CHECK(!ValidateGBTForce(\"oui\"));\n+    BOOST_CHECK(!ValidateGBTForce(\"non\"));\n+    BOOST_CHECK(!ValidateGBTForce(\"\"));\n+\n+    // fork name\n+    BOOST_CHECK(ValidateForkName(\"a_fork\"));\n+    BOOST_CHECK(ValidateForkName(\"a fork\"));\n+    BOOST_CHECK(ValidateForkName(\"segwit\"));\n+    BOOST_CHECK(!ValidateForkName(\"\"));\n+\n+    // window size\n+    BOOST_CHECK(!ValidateWindowSize(0));\n+    BOOST_CHECK(!ValidateWindowSize(1));\n+    BOOST_CHECK(!ValidateWindowSize(-1));\n+    BOOST_CHECK(ValidateWindowSize(2));\n+    BOOST_CHECK(ValidateWindowSize(3));\n+    BOOST_CHECK(ValidateWindowSize(100));\n+    BOOST_CHECK(ValidateWindowSize(10000));\n+    BOOST_CHECK(ValidateWindowSize(std::numeric_limits<int>::max()));\n+#pragma GCC diagnostic ignored \"-Woverflow\"\n+    BOOST_CHECK(!ValidateWindowSize(1 + std::numeric_limits<int>::max()));\n+#pragma GCC diagnostic pop\n+\n+    // threshold size (2nd param is window)\n+    BOOST_CHECK(!ValidateThreshold(1,1));   // 1 is not valid window size\n+    BOOST_CHECK(!ValidateThreshold(0,1));   // 1 is not valid window size, 0 is not valid threshold\n+    BOOST_CHECK(!ValidateThreshold(0,2));   // 0 is not valid threshold\n+    BOOST_CHECK(ValidateThreshold(1,2));\n+    BOOST_CHECK(!ValidateThreshold(-1,2));\n+    BOOST_CHECK(!ValidateThreshold(2,1));\n+    BOOST_CHECK(ValidateThreshold(2,2));\n+    BOOST_CHECK(ValidateThreshold(1,100));\n+    BOOST_CHECK(ValidateThreshold(50,100));\n+    BOOST_CHECK(ValidateThreshold(99,100));\n+    BOOST_CHECK(ValidateThreshold(100,100));\n+    BOOST_CHECK(!ValidateThreshold(101,100));\n+    BOOST_CHECK(ValidateThreshold(1916,2016));\n+    BOOST_CHECK(ValidateThreshold(2016,2016));\n+    BOOST_CHECK(ValidateThreshold(2016,2016));\n+    BOOST_CHECK(!ValidateThreshold(2017,2016));\n+    BOOST_CHECK(ValidateThreshold(1, std::numeric_limits<int>::max()));\n+\n+    // starttime / timeout\n+    BOOST_CHECK(!ValidateTimes(0, 0));     // starttime must be strictly less than timeout\n+    BOOST_CHECK(ValidateTimes(0, 1));      // starttime must be strictly less than timeout\n+    BOOST_CHECK(ValidateTimes(100, 1001)); // starttime must be strictly less than timeout\n+    BOOST_CHECK(ValidateTimes(0, 1001));   // starttime must be strictly less than timeout\n+    BOOST_CHECK(ValidateTimes(0, std::numeric_limits<int64_t>::max()));\n+    BOOST_CHECK(ValidateTimes(std::numeric_limits<int64_t>::max() - 1,\n+                              std::numeric_limits<int64_t>::max()));\n+\n+    // minlockedblocks\n+    BOOST_CHECK(ValidateMinLockedBlocks(0));   // zero is ok\n+    BOOST_CHECK(ValidateMinLockedBlocks(1));\n+    BOOST_CHECK(ValidateMinLockedBlocks(100));\n+    BOOST_CHECK(!ValidateMinLockedBlocks(-1));\n+    BOOST_CHECK(ValidateMinLockedBlocks(std::numeric_limits<int>::max()));\n+#pragma GCC diagnostic ignored \"-Woverflow\"\n+    BOOST_CHECK(!ValidateMinLockedBlocks(1 + std::numeric_limits<int>::max()));\n+#pragma GCC diagnostic pop\n+\n+    // minlockedtime\n+    BOOST_CHECK(ValidateMinLockedTime(0));   // zero is ok\n+    BOOST_CHECK(ValidateMinLockedTime(1));\n+    BOOST_CHECK(ValidateMinLockedTime(100));\n+    BOOST_CHECK(!ValidateMinLockedTime(-1));\n+    BOOST_CHECK(ValidateMinLockedTime(std::numeric_limits<int64_t>::max()));\n+#pragma GCC diagnostic ignored \"-Woverflow\"\n+    BOOST_CHECK(!ValidateMinLockedTime(1 + std::numeric_limits<int64_t>::max()));\n+#pragma GCC diagnostic pop\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "2eaea952d1761061e3076349a68900cf0df18d0a",
        "filename": "src/test/genversionbits_tests.cpp",
        "status": "added",
        "additions": 400,
        "deletions": 0,
        "changes": 400,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/test/genversionbits_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/test/genversionbits_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/genversionbits_tests.cpp?ref=e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193",
        "patch": "@@ -0,0 +1,400 @@\n+// Copyright (c) 2017 The Bitcoin developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"chain.h\"\n+#include \"random.h\"\n+#include \"versionbits.h\"\n+#include \"test/test_bitcoin.h\"\n+#include \"test/test_random.h\"\n+#include \"chainparams.h\"\n+#include \"chainparamsbase.h\"\n+//#include \"main.h\"  // bip135 obsolete\n+#include \"validation.h\"\n+#include \"consensus/params.h\"\n+\n+#include <boost/test/unit_test.hpp>\n+\n+/* Define a virtual block time, one block per 10 minutes after Nov 14 2014, 0:55:36am */\n+int32_t GenVBTestTime(int nHeight) { return 1415926536 + 600 * nHeight; }\n+\n+#define TEST_BIT 8\n+\n+#define SELECTED_CHAIN CBaseChainParams::MAIN\n+\n+\n+// a checker which enforced some minlockedblocks\n+class TestConditionCheckerMinBlocks : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache cache;\n+\n+protected:\n+    int64_t BeginTime(const Consensus::Params& params) const { return GenVBTestTime(10000); }\n+    int64_t EndTime(const Consensus::Params& params) const { return GenVBTestTime(20000); }\n+    int Period(const Consensus::Params& params) const { return 1000; }\n+    int Threshold(const Consensus::Params& params) const { return 900; }\n+    int MinLockedBlocks(const Consensus::Params& params) const { return 1001; }\n+    int64_t MinLockedTime(const Consensus::Params& params) const { return 0; }\n+\n+    // test for fork bit\n+    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const { return (pindex->nVersion & (1 << TEST_BIT)); }\n+\n+public:\n+    ThresholdState GetState(const CBlockIndex* pindexPrev) const {\n+        return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, ModifiableParams().GetModifiableConsensus(), cache);\n+    }\n+};\n+\n+// a checker which enforced some minlockedtime\n+class TestConditionCheckerMinTime : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache cache;\n+\n+protected:\n+    int64_t BeginTime(const Consensus::Params& params) const { return GenVBTestTime(10000); }\n+    int64_t EndTime(const Consensus::Params& params) const { return GenVBTestTime(20000); }\n+    int Period(const Consensus::Params& params) const { return 1000; }\n+    int Threshold(const Consensus::Params& params) const { return 900; }\n+    int MinLockedBlocks(const Consensus::Params& params) const { return 0; }\n+    int64_t MinLockedTime(const Consensus::Params& params) const { return 5000 * 600; }  // this is a minimum *duration* after lock-in time\n+\n+    // test for fork bit\n+    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const { return (pindex->nVersion & (1 << TEST_BIT)); }\n+\n+public:\n+    ThresholdState GetState(const CBlockIndex* pindexPrev) const {\n+        return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, ModifiableParams().GetModifiableConsensus(), cache);\n+    }\n+};\n+\n+\n+#define CHECKERS 6\n+\n+class GenVersionBitsTesterMinBlocks\n+{\n+public:\n+    // A fake blockchain\n+    std::vector<CBlockIndex*> vpblock;\n+\n+    // 6 independent checkers for the same bit.\n+    // The first one performs all checks, the second only 50%, the third only 25%, etc...\n+    // This is to test whether lack of cached information leads to the same results.\n+    TestConditionCheckerMinBlocks checker[CHECKERS];\n+\n+    // Test counter (to identify failures)\n+    int num;\n+\n+    GenVersionBitsTesterMinBlocks() : num(0) {}\n+\n+    GenVersionBitsTesterMinBlocks& Reset() {\n+        for (unsigned int i = 0; i < vpblock.size(); i++) {\n+            delete vpblock[i];\n+        }\n+        for (unsigned int i = 0; i < CHECKERS; i++) {\n+            checker[i] = TestConditionCheckerMinBlocks();\n+        }\n+        vpblock.clear();\n+        return *this;\n+    }\n+\n+    ~GenVersionBitsTesterMinBlocks() {\n+         Reset();\n+    }\n+\n+    /**\n+     * Create fake blocks in the test chain\n+     * @param height up to which to mine\n+     * @param nTime this time to enter in mined block\n+     * @param nVersion block versions are set to this\n+     */\n+    GenVersionBitsTesterMinBlocks& Mine(unsigned int height, int32_t nTime, int32_t nVersion) {\n+        while (vpblock.size() < height) {\n+            CBlockIndex* pindex = new CBlockIndex();\n+            pindex->nHeight = vpblock.size();\n+            pindex->pprev = vpblock.size() > 0 ? vpblock.back() : NULL;\n+            pindex->nTime = nTime;\n+            pindex->nVersion = nVersion;\n+            pindex->BuildSkip();\n+            vpblock.push_back(pindex);\n+        }\n+        return *this;\n+    }\n+\n+    GenVersionBitsTesterMinBlocks& TestDefined() {\n+        for (int i = 0; i < CHECKERS; i++) {\n+            if ((insecure_rand() & ((1 << i) - 1)) == 0) {\n+                BOOST_CHECK_MESSAGE(checker[i].GetState(vpblock.empty() ? NULL : vpblock.back()) == THRESHOLD_DEFINED, strprintf(\"Test %i for DEFINED\", num));\n+            }\n+        }\n+        num++;\n+        return *this;\n+    }\n+\n+    GenVersionBitsTesterMinBlocks& TestStarted() {\n+        for (int i = 0; i < CHECKERS; i++) {\n+            if ((insecure_rand() & ((1 << i) - 1)) == 0) {\n+                BOOST_CHECK_MESSAGE(checker[i].GetState(vpblock.empty() ? NULL : vpblock.back()) == THRESHOLD_STARTED, strprintf(\"Test %i for STARTED\", num));\n+            }\n+        }\n+        num++;\n+        return *this;\n+    }\n+\n+    GenVersionBitsTesterMinBlocks& TestLockedIn() {\n+        for (int i = 0; i < CHECKERS; i++) {\n+            if ((insecure_rand() & ((1 << i) - 1)) == 0) {\n+                BOOST_CHECK_MESSAGE(checker[i].GetState(vpblock.empty() ? NULL : vpblock.back()) == THRESHOLD_LOCKED_IN, strprintf(\"Test %i for LOCKED_IN\", num));\n+            }\n+        }\n+        num++;\n+        return *this;\n+    }\n+\n+    GenVersionBitsTesterMinBlocks& TestActive() {\n+        for (int i = 0; i < CHECKERS; i++) {\n+            if ((insecure_rand() & ((1 << i) - 1)) == 0) {\n+                BOOST_CHECK_MESSAGE(checker[i].GetState(vpblock.empty() ? NULL : vpblock.back()) == THRESHOLD_ACTIVE, strprintf(\"Test %i for ACTIVE\", num));\n+            }\n+        }\n+        num++;\n+        return *this;\n+    }\n+    GenVersionBitsTesterMinBlocks& TestFailed() {\n+        for (int i = 0; i < CHECKERS; i++) {\n+            if ((insecure_rand() & ((1 << i) - 1)) == 0) {\n+                BOOST_CHECK_MESSAGE(checker[i].GetState(vpblock.empty() ? NULL : vpblock.back()) == THRESHOLD_FAILED, strprintf(\"Test %i for FAILED\", num));\n+            }\n+        }\n+        num++;\n+        return *this;\n+    }\n+\n+    CBlockIndex * Tip() { return vpblock.size() ? vpblock.back() : NULL; }\n+};\n+\n+\n+class GenVersionBitsTesterMinTime\n+{\n+public:\n+    // A fake blockchain\n+    std::vector<CBlockIndex*> vpblock;\n+\n+    // 6 independent checkers for the same bit.\n+    // The first one performs all checks, the second only 50%, the third only 25%, etc...\n+    // This is to test whether lack of cached information leads to the same results.\n+    TestConditionCheckerMinTime checker[CHECKERS];\n+\n+    // Test counter (to identify failures)\n+    int num;\n+\n+    GenVersionBitsTesterMinTime() : num(0) {}\n+\n+    GenVersionBitsTesterMinTime& Reset() {\n+        for (unsigned int i = 0; i < vpblock.size(); i++) {\n+            delete vpblock[i];\n+        }\n+        for (unsigned int i = 0; i < CHECKERS; i++) {\n+            checker[i] = TestConditionCheckerMinTime();\n+        }\n+        vpblock.clear();\n+        return *this;\n+    }\n+\n+    ~GenVersionBitsTesterMinTime() {\n+         Reset();\n+    }\n+\n+    /**\n+     * Create fake blocks in the test chain\n+     * @param height up to which to mine\n+     * @param nTime this time to enter in mined block\n+     * @param nVersion block versions are set to this\n+     */\n+    GenVersionBitsTesterMinTime& Mine(unsigned int height, int32_t nTime, int32_t nVersion) {\n+        while (vpblock.size() < height) {\n+            CBlockIndex* pindex = new CBlockIndex();\n+            pindex->nHeight = vpblock.size();\n+            pindex->pprev = vpblock.size() > 0 ? vpblock.back() : NULL;\n+            pindex->nTime = nTime;\n+            pindex->nVersion = nVersion;\n+            pindex->BuildSkip();\n+            vpblock.push_back(pindex);\n+        }\n+        return *this;\n+    }\n+\n+    GenVersionBitsTesterMinTime& TestDefined() {\n+        for (int i = 0; i < CHECKERS; i++) {\n+            if ((insecure_rand() & ((1 << i) - 1)) == 0) {\n+                BOOST_CHECK_MESSAGE(checker[i].GetState(vpblock.empty() ? NULL : vpblock.back()) == THRESHOLD_DEFINED, strprintf(\"Test %i for DEFINED\", num));\n+            }\n+        }\n+        num++;\n+        return *this;\n+    }\n+\n+    GenVersionBitsTesterMinTime& TestStarted() {\n+        for (int i = 0; i < CHECKERS; i++) {\n+            if ((insecure_rand() & ((1 << i) - 1)) == 0) {\n+                BOOST_CHECK_MESSAGE(checker[i].GetState(vpblock.empty() ? NULL : vpblock.back()) == THRESHOLD_STARTED, strprintf(\"Test %i for STARTED\", num));\n+            }\n+        }\n+        num++;\n+        return *this;\n+    }\n+\n+    GenVersionBitsTesterMinTime& TestLockedIn() {\n+        for (int i = 0; i < CHECKERS; i++) {\n+            if ((insecure_rand() & ((1 << i) - 1)) == 0) {\n+                BOOST_CHECK_MESSAGE(checker[i].GetState(vpblock.empty() ? NULL : vpblock.back()) == THRESHOLD_LOCKED_IN, strprintf(\"Test %i for LOCKED_IN\", num));\n+            }\n+        }\n+        num++;\n+        return *this;\n+    }\n+\n+    GenVersionBitsTesterMinTime& TestActive() {\n+        for (int i = 0; i < CHECKERS; i++) {\n+            if ((insecure_rand() & ((1 << i) - 1)) == 0) {\n+                BOOST_CHECK_MESSAGE(checker[i].GetState(vpblock.empty() ? NULL : vpblock.back()) == THRESHOLD_ACTIVE, strprintf(\"Test %i for ACTIVE\", num));\n+            }\n+        }\n+        num++;\n+        return *this;\n+    }\n+    GenVersionBitsTesterMinTime& TestFailed() {\n+        for (int i = 0; i < CHECKERS; i++) {\n+            if ((insecure_rand() & ((1 << i) - 1)) == 0) {\n+                BOOST_CHECK_MESSAGE(checker[i].GetState(vpblock.empty() ? NULL : vpblock.back()) == THRESHOLD_FAILED, strprintf(\"Test %i for FAILED\", num));\n+            }\n+        }\n+        num++;\n+        return *this;\n+    }\n+\n+    CBlockIndex * Tip() { return vpblock.size() ? vpblock.back() : NULL; }\n+};\n+\n+\n+BOOST_FIXTURE_TEST_SUITE(genversionbits_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(genversionbits_minblocks_test)\n+{\n+    // NOTE: the index i is not used in this loop. The high number of iterations\n+    // is probably because the testing is probabilistic in terms of the checkers\n+    // finding an error, and they wanted to cover the bases.\n+    for (int i = 0; i < 64; i++) {\n+        // DEFINED -> FAILED\n+        GenVersionBitsTesterMinBlocks().TestDefined()\n+                           .Mine(1, GenVBTestTime(1), 0x100).TestDefined()\n+                           .Mine(11, GenVBTestTime(11), 0x100).TestDefined()\n+                           .Mine(989, GenVBTestTime(989), 0x100).TestDefined()\n+                           .Mine(999, GenVBTestTime(20000), 0x100).TestDefined()\n+                           .Mine(1000, GenVBTestTime(20000), 0x100).TestFailed()\n+                           .Mine(1999, GenVBTestTime(30001), 0x100).TestFailed()\n+                           .Mine(2000, GenVBTestTime(30002), 0x100).TestFailed()\n+                           .Mine(2001, GenVBTestTime(30003), 0x100).TestFailed()\n+                           .Mine(2999, GenVBTestTime(30004), 0x100).TestFailed()\n+                           .Mine(3000, GenVBTestTime(30005), 0x100).TestFailed()\n+\n+        // DEFINED -> STARTED -> FAILED\n+                           .Reset().TestDefined()\n+                           .Mine(1, GenVBTestTime(1), 0).TestDefined()\n+                           .Mine(1000, GenVBTestTime(10000) - 1, 0x100).TestDefined() // One second more and it would be defined\n+                           .Mine(2000, GenVBTestTime(10000), 0x100).TestStarted() // So that's what happens the next period\n+                           .Mine(2051, GenVBTestTime(10010), 0).TestStarted() // 51 old blocks\n+                           .Mine(2950, GenVBTestTime(10020), 0x100).TestStarted() // 899 new blocks\n+                           .Mine(3000, GenVBTestTime(20000), 0).TestFailed() // 50 old blocks (so 899 out of the past 1000)\n+                           .Mine(4000, GenVBTestTime(20010), 0x100).TestFailed()\n+\n+        // DEFINED -> STARTED -> FAILED while threshold reached\n+                           .Reset().TestDefined()\n+                           .Mine(1, GenVBTestTime(1), 0).TestDefined()\n+                           .Mine(1000, GenVBTestTime(10000) - 1, 0x101).TestDefined() // One second more and it would be defined\n+                           .Mine(2000, GenVBTestTime(10000), 0x101).TestStarted() // So that's what happens the next period\n+                           .Mine(2999, GenVBTestTime(30000), 0x100).TestStarted() // 999 new blocks\n+                           .Mine(3000, GenVBTestTime(30000), 0x100).TestFailed() // 1 new block (so 1000 out of the past 1000 are new)\n+                           .Mine(3999, GenVBTestTime(30001), 0).TestFailed()\n+                           .Mine(4000, GenVBTestTime(30002), 0).TestFailed()\n+                           .Mine(14333, GenVBTestTime(30003), 0).TestFailed()\n+                           .Mine(24000, GenVBTestTime(40000), 0).TestFailed()\n+\n+        // DEFINED -> STARTED -> LOCKEDIN at the last minute -> ACTIVE\n+                           .Reset().TestDefined()\n+                           .Mine(1, GenVBTestTime(1), 0).TestDefined()\n+                           .Mine(1000, GenVBTestTime(10000) - 1, 0x101).TestDefined() // One second more and it would be defined\n+                           .Mine(2000, GenVBTestTime(10000), 0x101).TestStarted() // So that's what happens the next period\n+                           .Mine(2050, GenVBTestTime(10010), 0x200).TestStarted() // 50 old blocks\n+                           .Mine(2950, GenVBTestTime(10020), 0x100).TestStarted() // 900 new blocks\n+                           .Mine(2999, GenVBTestTime(19999), 0x200).TestStarted() // 49 old blocks\n+                           .Mine(3000, GenVBTestTime(20000), 0x200).TestLockedIn() // 1 old block (so 900 out of the past 1000)\n+                           .Mine(3001, GenVBTestTime(20001), 0).TestLockedIn() // still locked in\n+                           .Mine(3999, GenVBTestTime(30000), 0).TestLockedIn() // wait at least minlockedblocks = 1001, so not active at next\n+                           .Mine(4000, GenVBTestTime(30001), 0).TestLockedIn() // need to remain locked in until next sync at 5000\n+                           .Mine(4999, GenVBTestTime(30002), 0).TestLockedIn() // last locked in block\n+                           .Mine(5000, GenVBTestTime(30002), 0).TestActive()\n+                           .Mine(24000, GenVBTestTime(40000), 0).TestActive();\n+    }\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(genversionbits_mintime_test)\n+{\n+    for (int i = 0; i < 64; i++) {\n+        // DEFINED -> FAILED\n+        GenVersionBitsTesterMinTime().TestDefined()\n+                           .Mine(1, GenVBTestTime(1), 0x100).TestDefined()\n+                           .Mine(11, GenVBTestTime(11), 0x100).TestDefined()\n+                           .Mine(989, GenVBTestTime(989), 0x100).TestDefined()\n+                           .Mine(999, GenVBTestTime(20000), 0x100).TestDefined()\n+                           .Mine(1000, GenVBTestTime(20000), 0x100).TestFailed()\n+                           .Mine(1999, GenVBTestTime(30001), 0x100).TestFailed()\n+                           .Mine(2000, GenVBTestTime(30002), 0x100).TestFailed()\n+                           .Mine(2001, GenVBTestTime(30003), 0x100).TestFailed()\n+                           .Mine(2999, GenVBTestTime(30004), 0x100).TestFailed()\n+                           .Mine(3000, GenVBTestTime(30005), 0x100).TestFailed()\n+\n+        // DEFINED -> STARTED -> FAILED\n+                           .Reset().TestDefined()\n+                           .Mine(1, GenVBTestTime(1), 0).TestDefined()\n+                           .Mine(1000, GenVBTestTime(10000) - 1, 0x100).TestDefined() // One second more and it would be defined\n+                           .Mine(2000, GenVBTestTime(10000), 0x100).TestStarted() // So that's what happens the next period\n+                           .Mine(2051, GenVBTestTime(10010), 0).TestStarted() // 51 old blocks\n+                           .Mine(2950, GenVBTestTime(10020), 0x100).TestStarted() // 899 new blocks\n+                           .Mine(3000, GenVBTestTime(20000), 0).TestFailed() // 50 old blocks (so 899 out of the past 1000)\n+                           .Mine(4000, GenVBTestTime(20010), 0x100).TestFailed()\n+\n+        // DEFINED -> STARTED -> FAILED while threshold reached\n+                           .Reset().TestDefined()\n+                           .Mine(1, GenVBTestTime(1), 0).TestDefined()\n+                           .Mine(1000, GenVBTestTime(10000) - 1, 0x101).TestDefined() // One second more and it would be defined\n+                           .Mine(2000, GenVBTestTime(10000), 0x101).TestStarted() // So that's what happens the next period\n+                           .Mine(2999, GenVBTestTime(30000), 0x100).TestStarted() // 999 new blocks\n+                           .Mine(3000, GenVBTestTime(30000), 0x100).TestFailed() // 1 new block (so 1000 out of the past 1000 are new)\n+                           .Mine(3999, GenVBTestTime(30001), 0).TestFailed()\n+                           .Mine(4000, GenVBTestTime(30002), 0).TestFailed()\n+                           .Mine(14333, GenVBTestTime(30003), 0).TestFailed()\n+                           .Mine(24000, GenVBTestTime(40000), 0).TestFailed()\n+\n+        // DEFINED -> STARTED -> LOCKEDIN at the last minute -> ACTIVE\n+                           .Reset().TestDefined()\n+                           .Mine(1, GenVBTestTime(1), 0).TestDefined()\n+                           .Mine(1000, GenVBTestTime(10000) - 1, 0x101).TestDefined() // One second more and it would be defined\n+                           .Mine(2000, GenVBTestTime(10000), 0x101).TestStarted() // So that's what happens the next period\n+                           .Mine(2050, GenVBTestTime(10010), 0x200).TestStarted() // 50 old blocks\n+                           .Mine(2950, GenVBTestTime(10020), 0x100).TestStarted() // 900 new blocks\n+                           .Mine(2999, GenVBTestTime(19999), 0x200).TestStarted() // 49 old blocks. Actual lock-in time will be 19999\n+                           .Mine(3000, GenVBTestTime(20000), 0x200).TestLockedIn() // 1 old block (so 900 out of the past 1000)\n+                           .Mine(3001, GenVBTestTime(20001), 0).TestLockedIn() // still locked in\n+                           .Mine(4000, GenVBTestTime(21000), 0).TestLockedIn() // need to remain locked at least 5000s after lock-in time @ 20000s\n+                           .Mine(8000, GenVBTestTime(22002), 0).TestLockedIn() // still locked in more than 5000 blocks later if time not passed\n+                           .Mine(9000, GenVBTestTime(24998), 0).TestLockedIn() // 1 sec prior to minimum lock-in duration - still remain locked in\n+                           .Mine(9001, GenVBTestTime(24999), 0).TestLockedIn()\n+                           .Mine(9999, GenVBTestTime(24999), 0).TestLockedIn()\n+                           .Mine(10000, GenVBTestTime(24999), 0).TestActive(); // activate at 10000 after full period of times > lock-in + 5000\n+    }\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "d1772300d9c5f938fc266ffb3573724e4bb730af",
        "filename": "src/test/versionbits_tests.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 5,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/test/versionbits_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/test/versionbits_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/versionbits_tests.cpp?ref=e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193",
        "patch": "@@ -1,4 +1,4 @@\n-// Copyright (c) 2014-2016 The Bitcoin Core developers\n+// Copyright (c) 2014-2017 The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -27,6 +27,10 @@ class TestConditionChecker : public AbstractThresholdConditionChecker\n     int64_t EndTime(const Consensus::Params& params) const { return TestTime(20000); }\n     int Period(const Consensus::Params& params) const { return 1000; }\n     int Threshold(const Consensus::Params& params) const { return 900; }\n+    // bip135 begin\n+    int MinLockedBlocks(const Consensus::Params& params) const { return 0; }\n+    int64_t MinLockedTime(const Consensus::Params& params) const { return 0; }\n+    // bip135 end\n     bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const { return (pindex->nVersion & 0x100); }\n \n     ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, paramsDummy, cache); }\n@@ -223,12 +227,21 @@ BOOST_AUTO_TEST_CASE(versionbits_test)\n         // end time of that soft fork.  (Alternatively, the end time of that\n         // activated soft fork could be later changed to be earlier to avoid\n         // overlap.)\n-        for (int j=i+1; j<(int) Consensus::MAX_VERSION_BITS_DEPLOYMENTS; j++) {\n-            if (VersionBitsMask(mainnetParams, (Consensus::DeploymentPos)j) == bitmask) {\n-                BOOST_CHECK(mainnetParams.vDeployments[j].nStartTime > mainnetParams.vDeployments[i].nTimeout ||\n-                        mainnetParams.vDeployments[i].nStartTime > mainnetParams.vDeployments[j].nTimeout);\n+        // bip135 begin fix disjointness check\n+        if (isConfiguredDeployment(mainnetParams, i)) {\n+            BOOST_CHECK(mainnetParams.vDeployments[i].nStartTime <= mainnetParams.vDeployments[i].nTimeout);\n+            for (int j=0; j<(int) Consensus::MAX_VERSION_BITS_DEPLOYMENTS; j++) {\n+                // only check a bit for disjointness if it is in use\n+                if (i != j && isConfiguredDeployment(mainnetParams, j) && VersionBitsMask(mainnetParams, (Consensus::DeploymentPos)j) == bitmask) {\n+                    BOOST_CHECK(mainnetParams.vDeployments[j].nStartTime <= mainnetParams.vDeployments[j].nTimeout);\n+                    BOOST_CHECK((mainnetParams.vDeployments[i].nStartTime < mainnetParams.vDeployments[j].nStartTime &&\n+                                 mainnetParams.vDeployments[i].nTimeout < mainnetParams.vDeployments[j].nTimeout)\n+                             || (mainnetParams.vDeployments[j].nStartTime < mainnetParams.vDeployments[i].nStartTime &&\n+                                 mainnetParams.vDeployments[j].nTimeout < mainnetParams.vDeployments[i].nTimeout));\n+                }\n             }\n         }\n+        // bip135 end\n     }\n }\n "
      },
      {
        "sha": "cc7d07391540854c647bec3ccf092927503d4a5c",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193",
        "patch": "@@ -90,6 +90,7 @@\n \n const char * const BITCOIN_CONF_FILENAME = \"bitcoin.conf\";\n const char * const BITCOIN_PID_FILENAME = \"bitcoind.pid\";\n+const char * const FORKS_CSV_FILENAME = \"forks.csv\";  // bip135 added\n \n ArgsManager gArgs;\n bool fPrintToConsole = false;\n@@ -596,6 +597,19 @@ fs::path GetConfigFile(const std::string& confPath)\n     return pathConfigFile;\n }\n \n+// bip135 added\n+/**\n+ * Function to return expected path of FORKS_CSV_FILENAME\n+ */\n+fs::path GetForksCsvFile()\n+{\n+    boost::filesystem::path pathCsvFile(GetArg(\"-forks\", FORKS_CSV_FILENAME));\n+    if (!pathCsvFile.is_complete())\n+        pathCsvFile = GetDataDir(false) / pathCsvFile;\n+\n+    return pathCsvFile;\n+}\n+\n void ArgsManager::ReadConfigFile(const std::string& confPath)\n {\n     fs::ifstream streamConfig(GetConfigFile(confPath));"
      },
      {
        "sha": "9dda158b41fad774f1a14987d4ced31f0331857f",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193",
        "patch": "@@ -53,6 +53,7 @@ extern CTranslationInterface translationInterface;\n \n extern const char * const BITCOIN_CONF_FILENAME;\n extern const char * const BITCOIN_PID_FILENAME;\n+extern const char * const FORKS_CSV_FILENAME;  // bip135 added\n \n extern std::atomic<uint32_t> logCategories;\n \n@@ -158,6 +159,7 @@ fs::path GetDefaultDataDir();\n const fs::path &GetDataDir(bool fNetSpecific = true);\n void ClearDatadirCache();\n fs::path GetConfigFile(const std::string& confPath);\n+fs::path GetForksCsvFile();  // bip135 added\n #ifndef WIN32\n fs::path GetPidFile();\n void CreatePidFile(const fs::path &path, pid_t pid);"
      },
      {
        "sha": "836cbf0bb122dfe9cc41db1521a6a2014c081fb1",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 117,
        "deletions": 48,
        "changes": 165,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193",
        "patch": "@@ -1399,41 +1399,42 @@ int32_t ComputeBlockVersion(const CBlockIndex* pindexPrev, const Consensus::Para\n     int32_t nVersion = VERSIONBITS_TOP_BITS;\n \n     for (int i = 0; i < (int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; i++) {\n-        ThresholdState state = VersionBitsState(pindexPrev, params, (Consensus::DeploymentPos)i, versionbitscache);\n-        if (state == THRESHOLD_LOCKED_IN || state == THRESHOLD_STARTED) {\n-            nVersion |= VersionBitsMask(params, (Consensus::DeploymentPos)i);\n+        // bip135 begin\n+        // guard this because not all deployments have window/threshold\n+        if (isConfiguredDeployment(params, i))\n+        {\n+            ThresholdState state = VersionBitsState(pindexPrev, params, (Consensus::DeploymentPos)i, versionbitscache);\n+            // activate the bits that are STARTED or LOCKED_IN according to their deployments\n+            if (state == THRESHOLD_LOCKED_IN || state == THRESHOLD_STARTED) {\n+                nVersion |= VersionBitsMask(params, (Consensus::DeploymentPos)i);\n+            }\n         }\n+        // bip135 end\n     }\n \n     return nVersion;\n }\n \n-/**\n- * Threshold condition checker that triggers when unknown versionbits are seen on the network.\n- */\n-class WarningBitsConditionChecker : public AbstractThresholdConditionChecker\n-{\n-private:\n-    int bit;\n-\n-public:\n-    WarningBitsConditionChecker(int bitIn) : bit(bitIn) {}\n+// bip135 : removed WarningBitsConditionChecker - no longer needed\n \n-    int64_t BeginTime(const Consensus::Params& params) const { return 0; }\n-    int64_t EndTime(const Consensus::Params& params) const { return std::numeric_limits<int64_t>::max(); }\n-    int Period(const Consensus::Params& params) const { return params.nMinerConfirmationWindow; }\n-    int Threshold(const Consensus::Params& params) const { return params.nRuleChangeActivationThreshold; }\n+// Protected by cs_main\n+static ThresholdConditionCache warningcache[VERSIONBITS_NUM_BITS];\n \n-    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const\n-    {\n-        return ((pindex->nVersion & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS) &&\n-               ((pindex->nVersion >> bit) & 1) != 0 &&\n-               ((ComputeBlockVersion(pindex->pprev, params) >> bit) & 1) == 0;\n-    }\n+// bip135 begin\n+// keep track of count over last 100\n+struct UnknownForkData {\n+    int UnknownForkSignalStrength {0};\n+    bool UnknownForkSignalFirstDetected {false};\n+    bool UnknownForkSignalLost {false};\n+    bool UnknownForkSignalAt25Percent {false};\n+    bool UnknownForkSignalAt50Percent {false};\n+    bool UnknownForkSignalAt70Percent {false};\n+    bool UnknownForkSignalAt90Percent {false};\n+    bool UnknownForkSignalAt95Percent {false};\n };\n \n-// Protected by cs_main\n-static ThresholdConditionCache warningcache[VERSIONBITS_NUM_BITS];\n+static UnknownForkData unknownFork[VERSIONBITS_NUM_BITS];\n+// bip135 end\n \n static int64_t nTimeCheck = 0;\n static int64_t nTimeForks = 0;\n@@ -1816,6 +1817,7 @@ void PruneAndFlush() {\n \n /** Update chainActive and related internal data structures. */\n void static UpdateTip(CBlockIndex *pindexNew, const CChainParams& chainParams) {\n+    //const CChainParams& chainParams = Params(); // bip135?\n     chainActive.SetTip(pindexNew);\n \n     // New best block\n@@ -1828,34 +1830,100 @@ void static UpdateTip(CBlockIndex *pindexNew, const CChainParams& chainParams) {\n     if (!IsInitialBlockDownload())\n     {\n         int nUpgraded = 0;\n+        bool upgradedEval = false;  // bip135 added\n         const CBlockIndex* pindex = chainActive.Tip();\n-        for (int bit = 0; bit < VERSIONBITS_NUM_BITS; bit++) {\n-            WarningBitsConditionChecker checker(bit);\n-            ThresholdState state = checker.GetStateFor(pindex, chainParams.GetConsensus(), warningcache[bit]);\n-            if (state == THRESHOLD_ACTIVE || state == THRESHOLD_LOCKED_IN) {\n-                if (state == THRESHOLD_ACTIVE) {\n-                    std::string strWarning = strprintf(_(\"Warning: unknown new rules activated (versionbit %i)\"), bit);\n-                    SetMiscWarning(strWarning);\n-                    if (!fWarned) {\n-                        AlertNotify(strWarning);\n-                        fWarned = true;\n+        // bip135 begin\n+        int32_t anUnexpectedVersion = 0;\n+        // start unexpected version / new fork signal checks only after BIT_WARNING_WINDOW block height\n+        if (pindex->nHeight >= BIT_WARNING_WINDOW) {\n+            for (int bit = 0; bit < VERSIONBITS_NUM_BITS; bit++)\n+            {\n+                if (!isConfiguredDeployment(chainParams.GetConsensus(), bit)) {\n+                    const CBlockIndex* iindex = pindex;  // iterating index, reset to chain tip\n+                    // set count for this bit to 0\n+                    unknownFork[bit].UnknownForkSignalStrength = 0;\n+                    for (int i = 0; i < BIT_WARNING_WINDOW && iindex != NULL; i++)\n+                    {\n+                        unknownFork[bit].UnknownForkSignalStrength += ((iindex->nVersion >> bit) & 0x1);\n+                        if (!upgradedEval) {\n+                            // do the old \"unexpected block version\" counting only during first bit walk\n+                            int32_t nExpectedVersion = ComputeBlockVersion(pindex->pprev, chainParams.GetConsensus());\n+\n+                            if (iindex->nVersion > VERSIONBITS_LAST_OLD_BLOCK_VERSION\n+                                                        && (iindex->nVersion & ~nExpectedVersion) != 0)\n+                            {\n+                                anUnexpectedVersion = iindex->nVersion;\n+                                ++nUpgraded;\n+                            }\n+                        }\n+                        iindex = iindex->pprev;\n+                    }\n+                    upgradedEval = true;  // only do the unexpected version checks once during bit loop\n+                    if (unknownFork[bit].UnknownForkSignalFirstDetected && !unknownFork[bit].UnknownForkSignalLost\n+                            && unknownFork[bit].UnknownForkSignalStrength == 0) {\n+                        // report a lost signal\n+                        LogPrintf(\"%s: signal lost for unknown fork (versionbit %i)\\n\",\n+                                __func__, bit);\n+                        unknownFork[bit].UnknownForkSignalFirstDetected = true;\n+                        unknownFork[bit].UnknownForkSignalLost = true; // set it so that we don't report on it again\n+                    }\n+                    // report newly gained / regained signal\n+                    else if ((!unknownFork[bit].UnknownForkSignalFirstDetected || unknownFork[bit].UnknownForkSignalLost)\n+                            && unknownFork[bit].UnknownForkSignalStrength > 0) {\n+                        // report a newly detected signal\n+                        LogPrintf(\"%s: new signal detected for unknown fork (versionbit %i) - strength %d/%d\\n\",\n+                                __func__, bit, unknownFork[bit].UnknownForkSignalStrength, BIT_WARNING_WINDOW);\n+                        unknownFork[bit].UnknownForkSignalFirstDetected = true; // set it so that we don't report on it again\n+                        unknownFork[bit].UnknownForkSignalLost = false;\n+                    }\n+                    else if (unknownFork[bit].UnknownForkSignalStrength >= 95 && !unknownFork[bit].UnknownForkSignalAt95Percent)\n+                    {\n+                        LogPrintf(\"%s: signal for unknown fork (versionbit %i) >= 95%% - strength %d/%d\\n\",\n+                                __func__, bit, unknownFork[bit].UnknownForkSignalStrength, BIT_WARNING_WINDOW);\n+                        unknownFork[bit].UnknownForkSignalAt95Percent = true;\n+                    }\n+                    else if (unknownFork[bit].UnknownForkSignalStrength >= 90 && !unknownFork[bit].UnknownForkSignalAt90Percent)\n+                    {\n+                        LogPrintf(\"%s: signal for unknown fork (versionbit %i) >= 90%% - strength %d/%d\\n\",\n+                                __func__, bit, unknownFork[bit].UnknownForkSignalStrength, BIT_WARNING_WINDOW);\n+                        unknownFork[bit].UnknownForkSignalAt90Percent = true;\n+                        unknownFork[bit].UnknownForkSignalAt95Percent = false;\n+                    }\n+                    else if (unknownFork[bit].UnknownForkSignalStrength >= 70 && !unknownFork[bit].UnknownForkSignalAt70Percent)\n+                    {\n+                        LogPrintf(\"%s: signal for unknown fork (versionbit %i) >= 70%% - strength %d/%d\\n\",\n+                                __func__, bit, unknownFork[bit].UnknownForkSignalStrength, BIT_WARNING_WINDOW);\n+                        unknownFork[bit].UnknownForkSignalAt70Percent = true;\n+                        unknownFork[bit].UnknownForkSignalAt90Percent = false;\n+                        unknownFork[bit].UnknownForkSignalAt95Percent = false;\n+                    }\n+                    else if (unknownFork[bit].UnknownForkSignalStrength >= 50 && !unknownFork[bit].UnknownForkSignalAt50Percent)\n+                    {\n+                        LogPrintf(\"%s: signal for unknown fork (versionbit %i) >= 50%% - strength %d/%d\\n\",\n+                                __func__, bit, unknownFork[bit].UnknownForkSignalStrength, BIT_WARNING_WINDOW);\n+                        unknownFork[bit].UnknownForkSignalAt50Percent = true;\n+                        unknownFork[bit].UnknownForkSignalAt70Percent = false;\n+                        unknownFork[bit].UnknownForkSignalAt90Percent = false;\n+                        unknownFork[bit].UnknownForkSignalAt95Percent = false;\n+                    }\n+                    else if (unknownFork[bit].UnknownForkSignalStrength >= 25 && !unknownFork[bit].UnknownForkSignalAt25Percent)\n+                    {\n+                        LogPrintf(\"%s: signal for unknown fork (versionbit %i) >= 25%% - strength %d/%d\\n\",\n+                                __func__, bit, unknownFork[bit].UnknownForkSignalStrength, BIT_WARNING_WINDOW);\n+                        unknownFork[bit].UnknownForkSignalAt25Percent = true;\n+                        unknownFork[bit].UnknownForkSignalAt50Percent = false;\n+                        unknownFork[bit].UnknownForkSignalAt70Percent = false;\n+                        unknownFork[bit].UnknownForkSignalAt90Percent = false;\n+                        unknownFork[bit].UnknownForkSignalAt95Percent = false;\n+                        fWarned = false;  // turn off to repeat the warning when > 50% again\n                     }\n-                } else {\n-                    warningMessages.push_back(strprintf(\"unknown new rules are about to activate (versionbit %i)\", bit));\n                 }\n             }\n         }\n-        // Check the version of the last 100 blocks to see if we need to upgrade:\n-        for (int i = 0; i < 100 && pindex != NULL; i++)\n-        {\n-            int32_t nExpectedVersion = ComputeBlockVersion(pindex->pprev, chainParams.GetConsensus());\n-            if (pindex->nVersion > VERSIONBITS_LAST_OLD_BLOCK_VERSION && (pindex->nVersion & ~nExpectedVersion) != 0)\n-                ++nUpgraded;\n-            pindex = pindex->pprev;\n-        }\n+\n         if (nUpgraded > 0)\n-            warningMessages.push_back(strprintf(\"%d of last 100 blocks have unexpected version\", nUpgraded));\n-        if (nUpgraded > 100/2)\n+            warningMessages.push_back(strprintf(\"%d of last 100 blocks have unexpected version. One example: 0x%x\", nUpgraded, anUnexpectedVersion));\n+        if (nUpgraded > BIT_WARNING_WINDOW / 2)\n         {\n             std::string strWarning = _(\"Warning: Unknown block versions being mined! It's possible unknown rules are in effect\");\n             // notify GetWarnings(), called by Qt and the JSON-RPC code to warn the user:\n@@ -1865,6 +1933,7 @@ void static UpdateTip(CBlockIndex *pindexNew, const CChainParams& chainParams) {\n                 fWarned = true;\n             }\n         }\n+        // bip135 end\n     }\n     LogPrintf(\"%s: new best=%s height=%d version=0x%08x log2_work=%.8g tx=%lu date='%s' progress=%f cache=%.1fMiB(%utx)\", __func__,\n       chainActive.Tip()->GetBlockHash().ToString(), chainActive.Height(), chainActive.Tip()->nVersion,\n@@ -3934,7 +4003,7 @@ ThresholdState VersionBitsTipState(const Consensus::Params& params, Consensus::D\n     return VersionBitsState(chainActive.Tip(), params, pos, versionbitscache);\n }\n \n-BIP9Stats VersionBitsTipStatistics(const Consensus::Params& params, Consensus::DeploymentPos pos)\n+ForkStats VersionBitsTipStatistics(const Consensus::Params& params, Consensus::DeploymentPos pos)\n {\n     LOCK(cs_main);\n     return VersionBitsStatistics(chainActive.Tip(), params, pos);"
      },
      {
        "sha": "ab9130c2a406a13a3e3a4688a116f66a23069575",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193",
        "patch": "@@ -340,7 +340,7 @@ std::string FormatStateMessage(const CValidationState &state);\n ThresholdState VersionBitsTipState(const Consensus::Params& params, Consensus::DeploymentPos pos);\n \n /** Get the numerical statistics for the BIP9 state for a given deployment at the current tip. */\n-BIP9Stats VersionBitsTipStatistics(const Consensus::Params& params, Consensus::DeploymentPos pos);\n+ForkStats VersionBitsTipStatistics(const Consensus::Params& params, Consensus::DeploymentPos pos);\n \n /** Get the block height at which the BIP9 deployment switched into the state for the block building on the current tip. */\n int VersionBitsTipStateSinceHeight(const Consensus::Params& params, Consensus::DeploymentPos pos);"
      },
      {
        "sha": "f5390a0e316cffb593b208742f09312d30f7da48",
        "filename": "src/versionbits.cpp",
        "status": "modified",
        "additions": 162,
        "deletions": 17,
        "changes": 179,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/versionbits.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/versionbits.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/versionbits.cpp?ref=e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193",
        "patch": "@@ -1,58 +1,189 @@\n-// Copyright (c) 2016 The Bitcoin Core developers\n+// Copyright (c) 2016-2017 The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"versionbits.h\"\n #include \"consensus/params.h\"\n \n-const struct BIP9DeploymentInfo VersionBitsDeploymentInfo[Consensus::MAX_VERSION_BITS_DEPLOYMENTS] = {\n+// bip135 begin fill out entire table\n+struct BIP9DeploymentInfo VersionBitsDeploymentInfo[Consensus::MAX_VERSION_BITS_DEPLOYMENTS] = {\n     {\n-        /*.name =*/ \"testdummy\",\n+        /*.name =*/ (char *) \"csv\",\n         /*.gbt_force =*/ true,\n     },\n     {\n-        /*.name =*/ \"csv\",\n+        /*.name =*/ (char *) \"segwit\",\n         /*.gbt_force =*/ true,\n     },\n     {\n-        /*.name =*/ \"segwit\",\n-        /*.gbt_force =*/ true,\n+        /*.name =*/ (char *) \"\",          // unallocated bit 2\n+        /*.gbt_force =*/ false,\n+    },\n+    {\n+        /*.name =*/ (char *) \"\",          // unallocated bit 3\n+        /*.gbt_force =*/ false,\n+    },\n+    {\n+        /*.name =*/ (char *) \"\",          // unallocated bit 4\n+        /*.gbt_force =*/ false,\n+    },\n+    {\n+        /*.name =*/ (char *) \"\",          // unallocated bit 5\n+        /*.gbt_force =*/ false,\n+    },\n+    {\n+        /*.name =*/ (char *) \"\",          // unallocated bit 6\n+        /*.gbt_force =*/ false,\n+    },\n+    {\n+        /*.name =*/ (char *) \"\",          // unallocated bit 7\n+        /*.gbt_force =*/ false,\n+    },\n+    {\n+        /*.name =*/ (char *) \"\",          // unallocated bit 8\n+        /*.gbt_force =*/ false,\n+    },\n+    {\n+        /*.name =*/ (char *) \"\",          // unallocated bit 9\n+        /*.gbt_force =*/ false,\n+    },\n+    {\n+        /*.name =*/ (char *) \"\",          // unallocated bit 10\n+        /*.gbt_force =*/ false,\n+    },\n+    {\n+        /*.name =*/ (char *) \"\",          // unallocated bit 11\n+        /*.gbt_force =*/ false,\n+    },\n+    {\n+        /*.name =*/ (char *) \"\",          // unallocated bit 12\n+        /*.gbt_force =*/ false,\n+    },\n+    {\n+        /*.name =*/ (char *) \"\",          // unallocated bit 13\n+        /*.gbt_force =*/ false,\n+    },\n+    {\n+        /*.name =*/ (char *) \"\",          // unallocated bit 14\n+        /*.gbt_force =*/ false,\n+    },\n+    {\n+        /*.name =*/ (char *) \"\",          // unallocated bit 15\n+        /*.gbt_force =*/ false,\n+    },\n+    {\n+        /*.name =*/ (char *) \"\",          // unallocated bit 16\n+        /*.gbt_force =*/ false,\n+    },\n+    {\n+        /*.name =*/ (char *) \"\",          // unallocated bit 17\n+        /*.gbt_force =*/ false,\n+    },\n+    {\n+        /*.name =*/ (char *) \"\",          // unallocated bit 18\n+        /*.gbt_force =*/ false,\n+    },\n+    {\n+        /*.name =*/ (char *) \"\",          // unallocated bit 19\n+        /*.gbt_force =*/ false,\n+    },\n+    {\n+        /*.name =*/ (char *) \"\",          // unallocated bit 20\n+        /*.gbt_force =*/ false,\n+    },\n+    {\n+        /*.name =*/ (char *) \"\",          // unallocated bit 21\n+        /*.gbt_force =*/ false,\n+    },\n+    {\n+        /*.name =*/ (char *) \"\",          // unallocated bit 22\n+        /*.gbt_force =*/ false,\n+    },\n+    {\n+        /*.name =*/ (char *) \"\",          // unallocated bit 23\n+        /*.gbt_force =*/ false,\n+    },\n+    {\n+        /*.name =*/ (char *) \"\",          // unallocated bit 24\n+        /*.gbt_force =*/ false,\n+    },\n+    {\n+        /*.name =*/ (char *) \"\",          // unallocated bit 25\n+        /*.gbt_force =*/ false,\n+    },\n+    {\n+        /*.name =*/ (char *) \"\",          // unallocated bit 26\n+        /*.gbt_force =*/ false,\n+    },\n+    {\n+        /*.name =*/ (char *) \"\",          // unallocated bit 27\n+        /*.gbt_force =*/ false,\n+    },\n+    {\n+        /*.name =*/ (char *) \"testdummy\", // unallocated bit 28\n+        /*.gbt_force =*/ false,\n     }\n };\n+// bip135 end\n \n+\n+// bip135 begin\n+// major adaptations to generalize and support new grace period parameters\n ThresholdState AbstractThresholdConditionChecker::GetStateFor(const CBlockIndex* pindexPrev, const Consensus::Params& params, ThresholdConditionCache& cache) const\n {\n     int nPeriod = Period(params);\n     int nThreshold = Threshold(params);\n     int64_t nTimeStart = BeginTime(params);\n     int64_t nTimeTimeout = EndTime(params);\n+    int nMinLockedBlocks = MinLockedBlocks(params);\n+    int64_t nMinLockedTime = MinLockedTime(params);\n+    int64_t nActualLockinTime = 0;\n+    int nActualLockinBlock = 0;\n+\n+    if (nPeriod == 0)\n+    {\n+        // we cannot do anything further -this deployment is not really defined.\n+        return THRESHOLD_DEFINED;\n+    }\n \n     // A block's state is always the same as that of the first of its period, so it is computed based on a pindexPrev whose height equals a multiple of nPeriod - 1.\n     if (pindexPrev != NULL) {\n+        assert(nPeriod);\n         pindexPrev = pindexPrev->GetAncestor(pindexPrev->nHeight - ((pindexPrev->nHeight + 1) % nPeriod));\n     }\n \n-    // Walk backwards in steps of nPeriod to find a pindexPrev whose information is known\n+    // Walk backwards in steps of nPeriod to find a pindexPrev which was DEFINED\n     std::vector<const CBlockIndex*> vToCompute;\n-    while (cache.count(pindexPrev) == 0) {\n+    bool backAtDefined = (cache.count(pindexPrev) && cache[pindexPrev] == THRESHOLD_DEFINED);\n+    while (!backAtDefined) {\n         if (pindexPrev == NULL) {\n             // The genesis block is by definition defined.\n             cache[pindexPrev] = THRESHOLD_DEFINED;\n             break;\n         }\n         if (pindexPrev->GetMedianTimePast() < nTimeStart) {\n-            // Optimization: don't recompute down further, as we know every earlier block will be before the start time\n+            // Optimizaton: don't recompute down further, as we know every\n+            // earlier block will be before the start time\n             cache[pindexPrev] = THRESHOLD_DEFINED;\n             break;\n         }\n+\n+        // push the pindex for later forward walking\n         vToCompute.push_back(pindexPrev);\n+        // go back one more period\n         pindexPrev = pindexPrev->GetAncestor(pindexPrev->nHeight - nPeriod);\n+\n+        if (cache.count(pindexPrev) > 0 && cache[pindexPrev] == THRESHOLD_DEFINED) {\n+            backAtDefined = true;\n+        }\n     }\n \n     // At this point, cache[pindexPrev] is known\n     assert(cache.count(pindexPrev));\n-    ThresholdState state = cache[pindexPrev];\n \n+    // initialize starting state for forward walk\n+    ThresholdState state = cache[pindexPrev];\n+    assert(state == THRESHOLD_DEFINED);\n     // Now walk forward and compute the state of descendants of pindexPrev\n     while (!vToCompute.empty()) {\n         ThresholdState stateNext = state;\n@@ -84,12 +215,23 @@ ThresholdState AbstractThresholdConditionChecker::GetStateFor(const CBlockIndex*\n                 }\n                 if (count >= nThreshold) {\n                     stateNext = THRESHOLD_LOCKED_IN;\n+                    // bip135: make a note of lock-in time & height\n+                    // this will be used for assessing grace period conditions.\n+                    nActualLockinBlock = pindexPrev->nHeight;\n+                    nActualLockinTime = pindexPrev->GetMedianTimePast();\n                 }\n                 break;\n             }\n             case THRESHOLD_LOCKED_IN: {\n-                // Always progresses into ACTIVE.\n-                stateNext = THRESHOLD_ACTIVE;\n+                // bip135: Progress to ACTIVE only once all grace conditions are met.\n+                if (pindexPrev->GetMedianTimePast() >= nActualLockinTime + nMinLockedTime\n+                        && pindexPrev->nHeight >= nActualLockinBlock + nMinLockedBlocks) {\n+                    stateNext = THRESHOLD_ACTIVE;\n+                }\n+                else {\n+                    // bip135: if grace not yet met, remain in LOCKED_IN\n+                    stateNext = THRESHOLD_LOCKED_IN;\n+                }\n                 break;\n             }\n             case THRESHOLD_FAILED:\n@@ -103,11 +245,12 @@ ThresholdState AbstractThresholdConditionChecker::GetStateFor(const CBlockIndex*\n \n     return state;\n }\n+// bip135 end\n \n // return the numerical statistics of blocks signalling the specified BIP9 condition in this current period\n-BIP9Stats AbstractThresholdConditionChecker::GetStateStatisticsFor(const CBlockIndex* pindex, const Consensus::Params& params) const\n+ForkStats AbstractThresholdConditionChecker::GetStateStatisticsFor(const CBlockIndex* pindex, const Consensus::Params& params) const\n {\n-    BIP9Stats stats;\n+    ForkStats stats;\n \n     stats.period = Period(params);\n     stats.threshold = Threshold(params);\n@@ -176,8 +319,10 @@ class VersionBitsConditionChecker : public AbstractThresholdConditionChecker {\n protected:\n     int64_t BeginTime(const Consensus::Params& params) const { return params.vDeployments[id].nStartTime; }\n     int64_t EndTime(const Consensus::Params& params) const { return params.vDeployments[id].nTimeout; }\n-    int Period(const Consensus::Params& params) const { return params.nMinerConfirmationWindow; }\n-    int Threshold(const Consensus::Params& params) const { return params.nRuleChangeActivationThreshold; }\n+    int Period(const Consensus::Params& params) const { return params.vDeployments[id].windowsize; }\n+    int Threshold(const Consensus::Params& params) const { return params.vDeployments[id].threshold; }\n+    int MinLockedBlocks(const Consensus::Params& params) const { return params.vDeployments[id].minlockedblocks; }\n+    int64_t MinLockedTime(const Consensus::Params& params) const { return params.vDeployments[id].minlockedtime; }\n \n     bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const\n     {\n@@ -196,7 +341,7 @@ ThresholdState VersionBitsState(const CBlockIndex* pindexPrev, const Consensus::\n     return VersionBitsConditionChecker(pos).GetStateFor(pindexPrev, params, cache.caches[pos]);\n }\n \n-BIP9Stats VersionBitsStatistics(const CBlockIndex* pindexPrev, const Consensus::Params& params, Consensus::DeploymentPos pos)\n+ForkStats VersionBitsStatistics(const CBlockIndex* pindexPrev, const Consensus::Params& params, Consensus::DeploymentPos pos)\n {\n     return VersionBitsConditionChecker(pos).GetStateStatisticsFor(pindexPrev, params);\n }"
      },
      {
        "sha": "89557d23e681965595eb75b998934fa5068621de",
        "filename": "src/versionbits.h",
        "status": "modified",
        "additions": 31,
        "deletions": 21,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/versionbits.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/src/versionbits.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/versionbits.h?ref=e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193",
        "patch": "@@ -1,4 +1,4 @@\n-// Copyright (c) 2016 The Bitcoin Core developers\n+// Copyright (c) 2016-2017 The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -16,50 +16,60 @@ static const int32_t VERSIONBITS_TOP_BITS = 0x20000000UL;\n static const int32_t VERSIONBITS_TOP_MASK = 0xE0000000UL;\n /** Total bits available for versionbits */\n static const int32_t VERSIONBITS_NUM_BITS = 29;\n+/** Size of window to use for assessing warning of unknown bits */\n+static const int BIT_WARNING_WINDOW = 100;\n+/** Threshold to use for assessing warning of unknown bits */\n+static const int BIT_WARNING_THRESHOLD = 50;\n \n+// bip135: assigned numbers to these enum values\n enum ThresholdState {\n-    THRESHOLD_DEFINED,\n-    THRESHOLD_STARTED,\n-    THRESHOLD_LOCKED_IN,\n-    THRESHOLD_ACTIVE,\n-    THRESHOLD_FAILED,\n+    THRESHOLD_DEFINED = 0,\n+    THRESHOLD_STARTED = 1,\n+    THRESHOLD_LOCKED_IN = 2,\n+    THRESHOLD_ACTIVE = 3,\n+    THRESHOLD_FAILED = 4,\n };\n \n-// A map that gives the state for blocks whose height is a multiple of Period().\n-// The map is indexed by the block's parent, however, so all keys in the map\n-// will either be NULL or a block with (height + 1) % Period() == 0.\n+// A map that gives the state for blocks.\n+// The map is indexed by the block's parent.\n typedef std::map<const CBlockIndex*, ThresholdState> ThresholdConditionCache;\n \n-struct BIP9DeploymentInfo {\n+// bip135 begin renamed\n+struct ForkDeploymentInfo {\n     /** Deployment name */\n-    const char *name;\n+    char *name;   // bip135: removed const to allow update from CSV\n     /** Whether GBT clients can safely ignore this rule in simplified usage */\n     bool gbt_force;\n };\n \n-struct BIP9Stats {\n+struct ForkStats {\n     int period;\n     int threshold;\n     int elapsed;\n     int count;\n     bool possible;\n };\n \n-extern const struct BIP9DeploymentInfo VersionBitsDeploymentInfo[];\n+extern struct ForkDeploymentInfo VersionBitsDeploymentInfo[];\n+// bip135 end\n \n /**\n- * Abstract class that implements BIP9-style threshold logic, and caches results.\n+ * Abstract class that implements BIP135-style threshold logic, and caches results.\n  */\n class AbstractThresholdConditionChecker {\n protected:\n-    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const =0;\n-    virtual int64_t BeginTime(const Consensus::Params& params) const =0;\n-    virtual int64_t EndTime(const Consensus::Params& params) const =0;\n-    virtual int Period(const Consensus::Params& params) const =0;\n-    virtual int Threshold(const Consensus::Params& params) const =0;\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const = 0;\n+    virtual int64_t BeginTime(const Consensus::Params& params) const = 0;\n+    virtual int64_t EndTime(const Consensus::Params& params) const = 0;\n+    virtual int Period(const Consensus::Params& params) const = 0;\n+    virtual int Threshold(const Consensus::Params& params) const = 0;\n+    // bip135 begin\n+    virtual int MinLockedBlocks(const Consensus::Params& params) const = 0;\n+    virtual int64_t MinLockedTime(const Consensus::Params& params) const = 0;\n+    // bip135 end\n \n public:\n-    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindex, const Consensus::Params& params) const;\n+    ForkStats GetStateStatisticsFor(const CBlockIndex* pindex, const Consensus::Params& params) const;\n     // Note that the functions below take a pindexPrev as input: they compute information for block B based on its parent.\n     ThresholdState GetStateFor(const CBlockIndex* pindexPrev, const Consensus::Params& params, ThresholdConditionCache& cache) const;\n     int GetStateSinceHeightFor(const CBlockIndex* pindexPrev, const Consensus::Params& params, ThresholdConditionCache& cache) const;\n@@ -73,7 +83,7 @@ struct VersionBitsCache\n };\n \n ThresholdState VersionBitsState(const CBlockIndex* pindexPrev, const Consensus::Params& params, Consensus::DeploymentPos pos, VersionBitsCache& cache);\n-BIP9Stats VersionBitsStatistics(const CBlockIndex* pindexPrev, const Consensus::Params& params, Consensus::DeploymentPos pos);\n+ForkStats VersionBitsStatistics(const CBlockIndex* pindexPrev, const Consensus::Params& params, Consensus::DeploymentPos pos);\n int VersionBitsStateSinceHeight(const CBlockIndex* pindexPrev, const Consensus::Params& params, Consensus::DeploymentPos pos, VersionBitsCache& cache);\n uint32_t VersionBitsMask(const Consensus::Params& params, Consensus::DeploymentPos pos);\n "
      },
      {
        "sha": "9036149b3169e1184122e94ef0db5ba0d5b0e1e6",
        "filename": "test/functional/bip135-grace.py",
        "status": "added",
        "additions": 368,
        "deletions": 0,
        "changes": 368,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/test/functional/bip135-grace.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/test/functional/bip135-grace.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bip135-grace.py?ref=e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193",
        "patch": "@@ -0,0 +1,368 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2015 The Bitcoin Core developers\n+# Copyright (c) 2015-2017 The Bitcoin Unlimited developers\n+# Copyright (c) 2017 The Bitcoin developers\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+from test_framework.util import sync_blocks\n+from test_framework.test_framework import ComparisonTestFramework\n+from test_framework.util import *\n+from test_framework.mininode import CTransaction, NetworkThread\n+from test_framework.blocktools import create_coinbase, create_block\n+from test_framework.comptool import TestInstance, TestManager\n+from test_framework.script import CScript, OP_1NEGATE, OP_CHECKSEQUENCEVERIFY, OP_DROP\n+from io import BytesIO\n+import time\n+import itertools\n+import tempfile\n+\n+'''\n+This test exercises BIP135 fork grace periods.\n+It uses a single node with custom forks.csv file.\n+\n+It is adapted from bip135-genvbvoting-forks on BU, which was\n+derived from bip9-softforks.\n+'''\n+\n+\n+class BIP135ForksTest(ComparisonTestFramework):\n+\n+    def __init__(self):\n+        super().__init__()\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.defined_forks = [ \"bip135test%d\" % i for i in range(0,22) ]\n+\n+    def setup_network(self):\n+        '''\n+        sets up with a custom forks.csv to test threshold / grace conditions\n+        also recomputes deployment start times since node is shut down and\n+        restarted between main test sections.\n+        '''\n+        # write a custom forks.csv file containing test deployments.\n+        # blocks are 1 second apart by default in this regtest\n+        fork_csv_filename = os.path.join(self.options.tmpdir, \"forks.csv\")\n+        # forks.csv fields:\n+        # network,bit,name,starttime,timeout,windowsize,threshold,minlockedblocks,minlockedtime,gbtforce\n+        with open(fork_csv_filename, 'wt') as fh:\n+            # use current time to compute offset starttimes\n+            self.init_time = int(time.time())\n+            # starttimes are offset by 30 seconds from init_time\n+            self.fork_starttime = self.init_time + 30\n+            fh.write(\n+            \"# deployment info for network 'regtest':\\n\" +\n+\n+            ########## THRESHOLD TESTING BITS (1-6) ############\n+\n+            # bit 0: test 'csv' fork renaming/reparameterization\n+            \"regtest,0,bip135test0,%d,999999999999,144,108,0,0,true\\n\" % (self.fork_starttime) +\n+\n+            # bit 1: test minimum threshold\n+            \"regtest,1,bip135test1,%d,999999999999,100,1,0,0,true\\n\" % (self.fork_starttime) +\n+\n+            # bit 2: small threshold\n+            \"regtest,2,bip135test2,%d,999999999999,100,10,0,0,true\\n\" % (self.fork_starttime) +\n+\n+            # bit 3: supermajority threshold\n+            \"regtest,3,bip135test3,%d,999999999999,100,75,0,0,true\\n\" % (self.fork_starttime) +\n+\n+            # bit 4: high threshold\n+            \"regtest,4,bip135test4,%d,999999999999,100,95,0,0,true\\n\" % (self.fork_starttime) +\n+\n+            # bit 5: max-but-one threshold\n+            \"regtest,5,bip135test5,%d,999999999999,100,99,0,0,true\\n\" % (self.fork_starttime) +\n+\n+            # bit 6: max threshold\n+            \"regtest,6,bip135test6,%d,999999999999,100,100,0,0,true\\n\" % (self.fork_starttime) +\n+\n+            ########## GRACE PERIOD TESTING BITS (7-21) ############\n+\n+            # bit 7: one minlockedblock\n+            \"regtest,7,bip135test7,%d,999999999999,10,9,1,0,true\\n\" % (self.fork_starttime) +\n+\n+            # bit 8: half a window of minlockedblocks\n+            \"regtest,8,bip135test8,%d,999999999999,10,9,5,0,true\\n\" % (self.fork_starttime) +\n+\n+            # bit 9: full window of minlockedblocks\n+            \"regtest,9,bip135test9,%d,999999999999,10,9,10,0,true\\n\" % (self.fork_starttime) +\n+\n+            # bit 10: just over full window of minlockedblocks\n+            \"regtest,10,bip135test10,%d,999999999999,10,9,11,0,true\\n\" % (self.fork_starttime) +\n+\n+            # bit 11: one second minlockedtime\n+            \"regtest,11,bip135test11,%d,999999999999,10,9,0,1,true\\n\" % (self.fork_starttime) +\n+\n+            # bit 12: half window of minlockedtime\n+            \"regtest,12,bip135test12,%d,999999999999,10,9,0,%d,true\\n\" % (self.fork_starttime, 5) +\n+\n+            # bit 13: just under one full window of minlockedtime\n+            \"regtest,13,bip135test13,%d,999999999999,10,9,0,%d,true\\n\" % (self.fork_starttime, 9) +\n+\n+            # bit 14: exactly one window of minlockedtime\n+            \"regtest,14,bip135test14,%d,999999999999,10,9,0,%d,true\\n\" % (self.fork_starttime, 10) +\n+\n+            # bit 15: just over one window of minlockedtime\n+            \"regtest,15,bip135test15,%d,999999999999,10,9,0,%d,true\\n\" % (self.fork_starttime, 11) +\n+\n+            # bit 16: one and a half window of minlockedtime\n+            \"regtest,16,bip135test16,%d,999999999999,10,9,0,%d,true\\n\" % (self.fork_starttime, 15) +\n+\n+            # bit 17: one window of minblockedblocks plus one window of minlockedtime\n+            \"regtest,17,bip135test17,%d,999999999999,10,9,10,%d,true\\n\" % (self.fork_starttime, 10) +\n+\n+            # bit 18: one window of minblockedblocks plus just under two windows of minlockedtime\n+            \"regtest,18,bip135test18,%d,999999999999,10,9,10,%d,true\\n\" % (self.fork_starttime, 19) +\n+\n+            # bit 19: one window of minblockedblocks plus two windows of minlockedtime\n+            \"regtest,19,bip135test19,%d,999999999999,10,9,10,%d,true\\n\" % (self.fork_starttime, 20) +\n+\n+            # bit 20: two windows of minblockedblocks plus two windows of minlockedtime\n+            \"regtest,20,bip135test20,%d,999999999999,10,9,20,%d,true\\n\" % (self.fork_starttime, 21) +\n+\n+            # bit 21: just over two windows of minblockedblocks plus two windows of minlockedtime\n+            \"regtest,21,bip135test21,%d,999999999999,10,9,21,%d,true\\n\" % (self.fork_starttime, 20) +\n+\n+            ########## NOT USED SO FAR ############\n+            \"regtest,22,bip135test22,%d,999999999999,100,9,0,0,true\\n\" % (self.fork_starttime)\n+            )\n+\n+        self.nodes = start_nodes(1, self.options.tmpdir,\n+                                 extra_args=[['-debug', '-whitelist=127.0.0.1',\n+                                              \"-forks=%s\" % fork_csv_filename]],\n+                                 binary=[self.options.testbinary])\n+\n+    def run_test(self):\n+        self.test = TestManager(self, self.options.tmpdir)\n+        self.test.add_all_connections(self.nodes)\n+        NetworkThread().start() # Start up network handling in another thread\n+        self.test.run()\n+\n+    def create_transaction(self, node, coinbase, to_address, amount):\n+        from_txid = node.getblock(coinbase)['tx'][0]\n+        inputs = [{ \"txid\" : from_txid, \"vout\" : 0}]\n+        outputs = { to_address : amount }\n+        rawtx = node.createrawtransaction(inputs, outputs)\n+        tx = CTransaction()\n+        f = BytesIO(hex_str_to_bytes(rawtx))\n+        tx.deserialize(f)\n+        tx.nVersion = 2\n+        return tx\n+\n+    def sign_transaction(self, node, tx):\n+        signresult = node.signrawtransaction(bytes_to_hex_str(tx.serialize()))\n+        tx = CTransaction()\n+        f = BytesIO(hex_str_to_bytes(signresult['hex']))\n+        tx.deserialize(f)\n+        return tx\n+\n+    def generate_blocks(self, number, version, test_blocks = []):\n+        for i in range(number):\n+            #print (\"generate_blocks: creating block on tip %x, height %d, time %d\" % (self.tip, self.height, self.last_block_time + 1))\n+            block = create_block(self.tip, create_coinbase(self.height), self.last_block_time + 1)\n+            block.nVersion = version\n+            block.rehash()\n+            block.solve()\n+            test_blocks.append([block, True])\n+            self.last_block_time += 1\n+            self.tip = block.sha256\n+            self.height += 1\n+        return test_blocks\n+\n+    def get_bip135_status(self, key):\n+        info = self.nodes[0].getblockchaininfo()\n+        return info['bip135_forks'][key]\n+\n+    def print_rpc_status(self):\n+        for f in self.defined_forks:\n+            info = self.nodes[0].getblockchaininfo()\n+            print(info['bip135_forks'][f])\n+\n+    def test_BIP135GraceConditions(self):\n+\n+        # the fork bits used to check grace period conditions\n+        gracebits = self.defined_forks[7:22]\n+\n+        print(\"begin test_BIP135GraceConditions test\")\n+        node = self.nodes[0]\n+        self.tip = int(\"0x\" + node.getbestblockhash(), 0)\n+        header = node.getblockheader(\"0x%x\" % self.tip)\n+        assert_equal(header['height'], 0)\n+\n+        # Test 1\n+        # generate a block, seems necessary to get RPC working\n+        self.coinbase_blocks = self.nodes[0].generate(1)\n+        self.height = 2\n+        self.last_block_time = int(time.time())\n+        self.tip = int(\"0x\" + node.getbestblockhash(), 0)\n+        test_blocks = self.generate_blocks(1, 0x20000000)  # do not set bit 0 yet\n+        yield TestInstance(test_blocks, sync_every_block=False)\n+\n+        bcinfo = self.nodes[0].getblockchaininfo()\n+        # check bits 7-15 , they should be in DEFINED\n+        for f in gracebits:\n+            assert_equal(bcinfo['bip135_forks'][f]['bit'], int(f[10:]))\n+            assert_equal(bcinfo['bip135_forks'][f]['status'], 'defined')\n+\n+        # move to starttime\n+        moved_to_started = False\n+        bcinfo = self.nodes[0].getblockchaininfo()\n+        tip_mediantime = int(bcinfo['mediantime'])\n+        while tip_mediantime < self.fork_starttime or self.height % 10:\n+            test_blocks = self.generate_blocks(1, 0x20000000)\n+            yield TestInstance(test_blocks, sync_every_block=False)\n+            time.sleep(3)  # need to actually give daemon a little time to change the state\n+            bcinfo = self.nodes[0].getblockchaininfo()\n+            tip_mediantime = int(bcinfo['mediantime'])\n+            for f in gracebits:\n+                # transition to STARTED must occur if this is true\n+                if tip_mediantime >= self.fork_starttime and self.height % 10 == 0:\n+                    moved_to_started = True\n+                    time.sleep(3)  # need to actually give daemon a little time to change the state\n+\n+                if moved_to_started:\n+                    assert_equal(bcinfo['bip135_forks'][f]['status'], 'started')\n+                else:\n+                    assert_equal(bcinfo['bip135_forks'][f]['status'], 'defined')\n+\n+        # lock all of them them in by producing 9 signaling blocks out of 10\n+        test_blocks = self.generate_blocks(9, 0x203fff80)\n+        # tenth block doesn't need to signal\n+        test_blocks = self.generate_blocks(1, 0x20000000, test_blocks)\n+        yield TestInstance(test_blocks, sync_every_block=False)\n+        # check bits 7-15 , they should all be in LOCKED_IN\n+        bcinfo = self.nodes[0].getblockchaininfo()\n+        print(\"checking all grace period forks are locked in\")\n+        for f in gracebits:\n+            assert_equal(bcinfo['bip135_forks'][f]['status'], 'locked_in')\n+\n+        # now we just check that they turn ACTIVE only when their configured\n+        # conditions are all met. Reminder: window size is 10 blocks, inter-\n+        # block time is 1 sec for the synthesized chain.\n+        #\n+        # Grace conditions for the bits 7-21:\n+        # -----------------------------------\n+        # bit 7:  minlockedblocks= 1, minlockedtime= 0  -> activate next sync\n+        # bit 8:  minlockedblocks= 5, minlockedtime= 0  -> activate next sync\n+        # bit 9:  minlockedblocks=10, minlockedtime= 0  -> activate next sync\n+        # bit 10: minlockedblocks=11, minlockedtime= 0  -> activate next plus one sync\n+        # bit 11: minlockedblocks= 0, minlockedtime= 1  -> activate next sync\n+        # bit 12: minlockedblocks= 0, minlockedtime= 5  -> activate next sync\n+        # bit 13: minlockedblocks= 0, minlockedtime= 9  -> activate next sync\n+        # bit 14: minlockedblocks= 0, minlockedtime=10  -> activate next sync\n+        # bit 15: minlockedblocks= 0, minlockedtime=11  -> activate next plus one sync\n+        # bit 16: minlockedblocks= 0, minlockedtime=15  -> activate next plus one sync\n+        # bit 17: minlockedblocks=10, minlockedtime=10  -> activate next sync\n+        # bit 18: minlockedblocks=10, minlockedtime=19  -> activate next plus one sync\n+        # bit 19: minlockedblocks=10, minlockedtime=20  -> activate next plus one sync\n+        # bit 20: minlockedblocks=20, minlockedtime=21  -> activate next plus two sync\n+        # bit 21: minlockedblocks=21, minlockedtime=20  -> activate next plus two sync\n+\n+        # check the forks supposed to activate just one period after lock-in (\"at next sync\")\n+\n+        test_blocks = self.generate_blocks(10, 0x20000000)\n+        yield TestInstance(test_blocks, sync_every_block=False)\n+        time.sleep(3)\n+        bcinfo = self.nodes[0].getblockchaininfo()\n+        activation_states = [ bcinfo['bip135_forks'][f]['status'] for f in gracebits ]\n+        assert_equal(activation_states, ['active',\n+                                         'active',\n+                                         'active',\n+                                         'locked_in',\n+                                         'active',\n+                                         'active',\n+                                         'active',\n+                                         'active',\n+                                         'locked_in',\n+                                         'locked_in',\n+                                         'active',\n+                                         'locked_in',\n+                                         'locked_in',\n+                                         'locked_in',\n+                                         'locked_in'\n+                                         ])\n+\n+        # check the ones supposed to activate at next+1 sync\n+        test_blocks = self.generate_blocks(10, 0x20000000)\n+        yield TestInstance(test_blocks, sync_every_block=False)\n+        time.sleep(3)\n+        bcinfo = self.nodes[0].getblockchaininfo()\n+        activation_states = [ bcinfo['bip135_forks'][f]['status'] for f in gracebits ]\n+        assert_equal(activation_states, ['active',\n+                                         'active',\n+                                         'active',\n+                                         'active',\n+                                         'active',\n+                                         'active',\n+                                         'active',\n+                                         'active',\n+                                         'active',\n+                                         'active',\n+                                         'active',\n+                                         'active',\n+                                         'active',\n+                                         'locked_in',\n+                                         'locked_in'\n+                                         ])\n+\n+        # check the ones supposed to activate at next+2 period\n+        test_blocks = self.generate_blocks(10, 0x20000000)\n+        yield TestInstance(test_blocks, sync_every_block=False)\n+        time.sleep(3)\n+        bcinfo = self.nodes[0].getblockchaininfo()\n+        activation_states = [ bcinfo['bip135_forks'][f]['status'] for f in gracebits ]\n+        assert_equal(activation_states, ['active',\n+                                         'active',\n+                                         'active',\n+                                         'active',\n+                                         'active',\n+                                         'active',\n+                                         'active',\n+                                         'active',\n+                                         'active',\n+                                         'active',\n+                                         'active',\n+                                         'active',\n+                                         'active',\n+                                         'active',\n+                                         'active'  # locked_in\n+                                         ])\n+\n+        # check the ones supposed to activate at next+2 period\n+        test_blocks = self.generate_blocks(10, 0x20000000)\n+        yield TestInstance(test_blocks, sync_every_block=False)\n+        time.sleep(3)\n+        bcinfo = self.nodes[0].getblockchaininfo()\n+        activation_states = [ bcinfo['bip135_forks'][f]['status'] for f in gracebits ]\n+        assert_equal(activation_states, ['active',\n+                                         'active',\n+                                         'active',\n+                                         'active',\n+                                         'active',\n+                                         'active',\n+                                         'active',\n+                                         'active',\n+                                         'active',\n+                                         'active',\n+                                         'active',\n+                                         'active',\n+                                         'active',\n+                                         'active',\n+                                         'active'\n+                                         ])\n+\n+\n+    def get_tests(self):\n+        '''\n+        run various tests\n+        '''\n+        # CSV (bit 0) for backward compatibility with BIP9\n+        for test in itertools.chain(\n+                self.test_BIP135GraceConditions(), # test grace periods\n+        ):\n+            yield test\n+\n+\n+\n+if __name__ == '__main__':\n+    BIP135ForksTest().main()"
      },
      {
        "sha": "f991d23caa5931185cf44e0f7e1e3dee6501746f",
        "filename": "test/functional/bip135-threshold.py",
        "status": "added",
        "additions": 318,
        "deletions": 0,
        "changes": 318,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/test/functional/bip135-threshold.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/test/functional/bip135-threshold.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bip135-threshold.py?ref=e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193",
        "patch": "@@ -0,0 +1,318 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2015 The Bitcoin Core developers\n+# Copyright (c) 2015-2017 The Bitcoin Unlimited developers\n+# Copyright (c) 2017 The Bitcoin developers\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+from test_framework.util import sync_blocks\n+from test_framework.test_framework import ComparisonTestFramework\n+from test_framework.util import *\n+from test_framework.mininode import CTransaction, NetworkThread\n+from test_framework.blocktools import create_coinbase, create_block\n+from test_framework.comptool import TestInstance, TestManager\n+from test_framework.script import CScript, OP_1NEGATE, OP_CHECKSEQUENCEVERIFY, OP_DROP\n+from io import BytesIO\n+import time\n+import itertools\n+import tempfile\n+\n+'''\n+This test exercises BIP135 fork activation thresholds.\n+It uses a single node with custom forks.csv file.\n+\n+It is adapted from bip135-genvbvoting-forks on BU, which was\n+derived from bip9-softforks.\n+'''\n+\n+\n+class BIP135ForksTest(ComparisonTestFramework):\n+\n+    def __init__(self):\n+        super().__init__()\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.defined_forks = [ \"bip135test%d\" % i for i in range(0,8) ]\n+\n+    def setup_network(self):\n+        '''\n+        sets up with a custom forks.csv to test threshold / grace conditions\n+        also recomputes deployment start times since node is shut down and\n+        restarted between main test sections.\n+        '''\n+        # write a custom forks.csv file containing test deployments.\n+        # blocks are 1 second apart by default in this regtest\n+        fork_csv_filename = os.path.join(self.options.tmpdir, \"forks.csv\")\n+        # forks.csv fields:\n+        # network,bit,name,starttime,timeout,windowsize,threshold,minlockedblocks,minlockedtime,gbtforce\n+        with open(fork_csv_filename, 'wt') as fh:\n+            # use current time to compute offset starttimes\n+            self.init_time = int(time.time())\n+            # starttimes are offset by 30 seconds from init_time\n+            self.fork_starttime = self.init_time + 30\n+            fh.write(\n+            \"# deployment info for network 'regtest':\\n\" +\n+\n+            ########## THRESHOLD TESTING BITS (1-6) ############\n+\n+            # bit 0: test 'csv' fork renaming/reparameterization\n+            \"regtest,0,bip135test0,%d,999999999999,144,108,0,0,true\\n\" % (self.fork_starttime) +\n+\n+            # bit 1: test 'segwit' fork renaming/reparameterization\n+            \"regtest,1,bip135test1,%d,999999999999,144,108,0,0,true\\n\" % (self.fork_starttime) +\n+\n+            # bit 2: test minimum threshold\n+            \"regtest,2,bip135test2,%d,999999999999,100,1,0,0,true\\n\" % (self.fork_starttime) +\n+\n+            # bit 3: small threshold\n+            \"regtest,3,bip135test3,%d,999999999999,100,10,0,0,true\\n\" % (self.fork_starttime) +\n+\n+            # bit 4: supermajority threshold\n+            \"regtest,4,bip135test4,%d,999999999999,100,75,0,0,true\\n\" % (self.fork_starttime) +\n+\n+            # bit 5: high threshold\n+            \"regtest,5,bip135test5,%d,999999999999,100,95,0,0,true\\n\" % (self.fork_starttime) +\n+\n+            # bit 6: max-but-one threshold\n+            \"regtest,6,bip135test6,%d,999999999999,100,99,0,0,true\\n\" % (self.fork_starttime) +\n+\n+            # bit 7: max threshold\n+            \"regtest,7,bip135test7,%d,999999999999,100,100,0,0,true\\n\" % (self.fork_starttime)\n+\n+            )\n+\n+        self.nodes = start_nodes(1, self.options.tmpdir,\n+                                 extra_args=[['-debug=all', '-whitelist=127.0.0.1',\n+                                              \"-forks=%s\" % fork_csv_filename]],\n+                                 binary=[self.options.testbinary])\n+\n+    def run_test(self):\n+        self.test = TestManager(self, self.options.tmpdir)\n+        self.test.add_all_connections(self.nodes)\n+        NetworkThread().start() # Start up network handling in another thread\n+        self.test.run()\n+\n+    def create_transaction(self, node, coinbase, to_address, amount):\n+        from_txid = node.getblock(coinbase)['tx'][0]\n+        inputs = [{ \"txid\" : from_txid, \"vout\" : 0}]\n+        outputs = { to_address : amount }\n+        rawtx = node.createrawtransaction(inputs, outputs)\n+        tx = CTransaction()\n+        f = BytesIO(hex_str_to_bytes(rawtx))\n+        tx.deserialize(f)\n+        tx.nVersion = 2\n+        return tx\n+\n+    def sign_transaction(self, node, tx):\n+        signresult = node.signrawtransaction(bytes_to_hex_str(tx.serialize()))\n+        tx = CTransaction()\n+        f = BytesIO(hex_str_to_bytes(signresult['hex']))\n+        tx.deserialize(f)\n+        return tx\n+\n+    def generate_blocks(self, number, version, test_blocks = []):\n+        for i in range(number):\n+            old_tip = self.tip\n+            block = create_block(self.tip, create_coinbase(self.height), self.last_block_time + 1)\n+            block.nVersion = version\n+            block.rehash()\n+            block.solve()\n+            test_blocks.append([block, True])\n+            self.last_block_time += 1\n+            self.tip = block.sha256\n+            self.height += 1\n+            #print (\"generate_blocks: created block %x on tip %x, height %d, time %d\" % (self.tip, old_tip, self.height-1, self.last_block_time))\n+        return test_blocks\n+\n+    def get_bip135_status(self, key):\n+        info = self.nodes[0].getblockchaininfo()\n+        return info['bip135_forks'][key]\n+\n+    def print_rpc_status(self):\n+        for f in self.defined_forks:\n+            info = self.nodes[0].getblockchaininfo()\n+            print(info['bip135_forks'][f])\n+\n+    def test_BIP135Thresholds(self):\n+\n+        print(\"test_BIP135Thresholds: begin\")\n+        node = self.nodes[0]\n+        self.tip = int(\"0x\" + node.getbestblockhash(), 0)\n+        header = node.getblockheader(\"0x%x\" % self.tip)\n+        assert_equal(header['height'], 0)\n+\n+        # Test 1\n+        # generate a block, seems necessary to get RPC working\n+        self.coinbase_blocks = self.nodes[0].generate(1)\n+        self.height = 2\n+        self.last_block_time = int(time.time())\n+        self.tip = int(\"0x\" + node.getbestblockhash(), 0)\n+        test_blocks = self.generate_blocks(1, 0x20000000)  # do not set bit 0 yet\n+        yield TestInstance(test_blocks, sync_every_block=False)\n+\n+        # Test 2\n+        # check initial DEFINED state\n+        # check initial forks status and getblocktemplate\n+        print(\"begin test 2\")\n+        tmpl = self.nodes[0].getblocktemplate({})\n+        assert_equal(tmpl['vbrequired'], 0)\n+        assert_equal(tmpl['version'], 0x20000000)\n+        print(\"initial getblocktemplate:\\n%s\" % tmpl)\n+\n+        test_blocks = []\n+        bcinfo = self.nodes[0].getblockchaininfo()\n+        tip_mediantime = int(bcinfo['mediantime'])\n+        while tip_mediantime < self.fork_starttime or self.height < 100:\n+            for f in self.defined_forks:\n+                assert_equal(self.get_bip135_status(f)['bit'], int(f[10:]))\n+                assert_equal(self.get_bip135_status(f)['status'], 'defined')\n+                assert(f not in tmpl['rules'])\n+                assert(f not in tmpl['vbavailable'])\n+            test_blocks = self.generate_blocks(1, 0x20000001)\n+            yield TestInstance(test_blocks, sync_every_block=False)\n+            bcinfo = self.nodes[0].getblockchaininfo()\n+            tip_mediantime = int(bcinfo['mediantime'])\n+\n+        # Test 3\n+        # Advance from DEFINED to STARTED\n+        print(\"begin test 3\")\n+        test_blocks = self.generate_blocks(1, 0x20000001)\n+        for f in self.defined_forks:\n+            if int(f[10:]) > 1:\n+                assert_equal(self.get_bip135_status(f)['status'], 'started')\n+                assert(f not in tmpl['rules'])\n+                assert(f not in tmpl['vbavailable'])\n+            elif int(f[10:]) == 0: # bit 0 only becomes started at height 144\n+                assert_equal(self.get_bip135_status(f)['status'], 'defined')\n+\n+        yield TestInstance(test_blocks, sync_every_block=False)\n+\n+        # Test 4\n+        # Advance from DEFINED to STARTED\n+        print(\"begin test 4\")\n+        test_blocks = self.generate_blocks(1, 0x20000001)\n+        yield TestInstance(test_blocks, sync_every_block=False)\n+\n+        for f in self.defined_forks:\n+            info = node.getblockchaininfo()\n+            print(info['bip135_forks'][f])\n+\n+        # Test 5..?\n+        # Advance from DEFINED to STARTED\n+        print(\"begin test 5 .. x - move to height 144 for bit 0 start\")\n+        # we are not yet at height 144, so bit 0 is still defined\n+        assert_equal(self.get_bip135_status(self.defined_forks[0])['status'], 'defined')\n+        # move up until it starts\n+        while self.height < 144:\n+            #print(\"last block time has not reached fork_starttime, difference: %d\" % (self.fork_starttime - self.last_block_time))\n+            test_blocks = self.generate_blocks(1, 0x20000001)\n+            yield TestInstance(test_blocks, sync_every_block=False)\n+            if int(f[10:]) > 0:\n+                assert_equal(self.get_bip135_status(f)['status'], 'started')\n+                assert(f not in tmpl['rules'])\n+                assert(f not in tmpl['vbavailable'])\n+            else: # bit 0 only becomes started at height 144\n+                assert_equal(self.get_bip135_status(f)['status'], 'defined')\n+\n+        # generate block 144\n+        test_blocks = []\n+        # now it should be started\n+\n+        yield TestInstance(test_blocks, sync_every_block=False)\n+        assert_equal(self.get_bip135_status(self.defined_forks[0])['status'], 'started')\n+\n+        tmpl = self.nodes[0].getblocktemplate({})\n+        assert(self.defined_forks[0] not in tmpl['rules'])\n+        assert_equal(tmpl['vbavailable'][self.defined_forks[0]], 0)\n+        assert_equal(tmpl['vbrequired'], 0)\n+        assert(tmpl['version'] & 0x20000000 + 2**0)\n+\n+        # move to start of new 100 block window\n+        # start signaling for bit 7 so we can get a full 100 block window for it\n+        # over the next period\n+        test_blocks = self.generate_blocks(100 - (self.height % 100), 0x20000080)\n+        yield TestInstance(test_blocks, sync_every_block=False)\n+        assert(self.height % 100 == 0)\n+\n+        # generate enough of bits 2-7 in next 100 blocks to lock in fork bits 2-7\n+        # bit 0 will only be locked in at next multiple of 144\n+        test_blocks = []\n+        # 1 block total for bit 2\n+        test_blocks = self.generate_blocks(1, 0x200000FD)\n+        yield TestInstance(test_blocks, sync_every_block=False)\n+        # check still STARTED until we get to multiple of window size\n+        assert_equal(self.get_bip135_status(self.defined_forks[1])['status'], 'started')\n+\n+        # 10 blocks total for bit 3\n+        test_blocks = self.generate_blocks(9, 0x200000F9)\n+        yield TestInstance(test_blocks, sync_every_block=False)\n+        assert_equal(self.get_bip135_status(self.defined_forks[2])['status'], 'started')\n+\n+        # 75 blocks total for bit 4\n+        test_blocks = self.generate_blocks(65, 0x200000F1)\n+        yield TestInstance(test_blocks, sync_every_block=False)\n+        assert_equal(self.get_bip135_status(self.defined_forks[3])['status'], 'started')\n+\n+        # 95 blocks total for bit 5\n+        test_blocks = self.generate_blocks(20, 0x200000E1)\n+        yield TestInstance(test_blocks, sync_every_block=False)\n+        assert_equal(self.get_bip135_status(self.defined_forks[4])['status'], 'started')\n+\n+        # 99 blocks total for bit 6\n+        test_blocks = self.generate_blocks(4, 0x200000C1)\n+        yield TestInstance(test_blocks, sync_every_block=False)\n+        assert_equal(self.get_bip135_status(self.defined_forks[5])['status'], 'started')\n+\n+        # 100 blocks total for bit 7\n+        test_blocks = self.generate_blocks(1, 0x20000081)\n+        yield TestInstance(test_blocks, sync_every_block=False)\n+        assert(self.height % 100 == 0)\n+\n+        # debug trace\n+        for f in self.defined_forks[2:]:\n+            info = node.getblockchaininfo()\n+            print(info['bip135_forks'][f])\n+            assert_equal(self.get_bip135_status(f)['status'], 'locked_in')\n+\n+        assert_equal(self.get_bip135_status(self.defined_forks[0])['status'], 'started')\n+        # move until bit 0 locks in\n+        print(\"moving until bit 0 locks in\")\n+        one_hundreds_active = False  # to count the 100-block bits 1-6 going active after 100 more\n+        while self.height % 144 != 0:\n+            test_blocks = self.generate_blocks(1, 0x20000001)\n+            yield TestInstance(test_blocks, sync_every_block=False)\n+            continue\n+            bcinfo = self.nodes[0].getblockchaininfo()\n+            # check bit 0 - it is locked in after this loop exits\n+            if self.height % 144:\n+                assert_equal(bcinfo['bip135_forks'][self.defined_forks[0]]['status'], 'started')\n+            else:\n+                assert_equal(bcinfo['bip135_forks'][self.defined_forks[0]]['status'], 'locked_in')\n+            # bits 1-6 should remain LOCKED_IN\n+            for f in self.defined_forks[2:]:\n+                if self.height % 100:\n+                    if not one_hundreds_active:\n+                        assert_equal(bcinfo['bip135_forks'][f]['status'], 'locked_in')\n+                    else:\n+                        assert_equal(bcinfo['bip135_forks'][f]['status'], 'active')\n+                else:\n+                    # mark them expected active henceforth\n+                    one_hundreds_active = True\n+                    assert_equal(bcinfo['bip135_forks'][f]['status'], 'active')\n+\n+        assert_equal(self.get_bip135_status(self.defined_forks[0])['status'], 'locked_in')\n+\n+    def get_tests(self):\n+        '''\n+        run various tests\n+        '''\n+        # CSV (bit 0) for backward compatibility with BIP9\n+        for test in itertools.chain(\n+                self.test_BIP135Thresholds(),  # test thresholds on other bits\n+        ):\n+            yield test\n+\n+\n+\n+if __name__ == '__main__':\n+    BIP135ForksTest().main()"
      },
      {
        "sha": "04369fc860a91b1578941a77c7177cee3c95dd15",
        "filename": "test/functional/p2p-versionbits-warning.py",
        "status": "modified",
        "additions": 10,
        "deletions": 22,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/test/functional/p2p-versionbits-warning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/test/functional/p2p-versionbits-warning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-versionbits-warning.py?ref=e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193",
        "patch": "@@ -14,13 +14,17 @@\n import re\n from test_framework.blocktools import create_block, create_coinbase\n \n-VB_PERIOD = 144 # versionbits period length for regtest\n-VB_THRESHOLD = 108 # versionbits activation threshold for regtest\n+# bip135 begin\n+# modified from 108/144 to 51/100 for new unknown versions algo\n+VB_PERIOD = 100 # unknown versionbits period length\n+VB_THRESHOLD = 51 # unknown versionbits warning level\n+# bip135 end\n VB_TOP_BITS = 0x20000000\n VB_UNKNOWN_BIT = 27 # Choose a bit unassigned to any deployment\n \n WARN_UNKNOWN_RULES_MINED = \"Unknown block versions being mined! It's possible unknown rules are in effect\"\n-WARN_UNKNOWN_RULES_ACTIVE = \"unknown new rules activated (versionbit {})\".format(VB_UNKNOWN_BIT)\n+# After BIP135, a client cannot know whether an unknown version bit has gone ACTIVE\n+# since the activation threshold of unknown bits is ... unknown.\n VB_PATTERN = re.compile(\"^Warning.*versionbit\")\n \n class TestNode(NodeConnCB):\n@@ -97,33 +101,17 @@ def run_test(self):\n         self.send_blocks_with_version(test_node, VB_THRESHOLD, nVersion)\n         self.nodes[0].generate(VB_PERIOD - VB_THRESHOLD)\n         # Might not get a versionbits-related alert yet, as we should\n-        # have gotten a different alert due to more than 51/100 blocks\n+        # have gotten a different alert due to more than 50/100 blocks\n         # being of unexpected version.\n         # Check that get*info() shows some kind of error.\n         assert(WARN_UNKNOWN_RULES_MINED in self.nodes[0].getinfo()[\"errors\"])\n         assert(WARN_UNKNOWN_RULES_MINED in self.nodes[0].getmininginfo()[\"errors\"])\n         assert(WARN_UNKNOWN_RULES_MINED in self.nodes[0].getnetworkinfo()[\"warnings\"])\n \n-        # Mine a period worth of expected blocks so the generic block-version warning\n-        # is cleared, and restart the node. This should move the versionbit state\n-        # to ACTIVE.\n-        self.nodes[0].generate(VB_PERIOD)\n-        stop_nodes(self.nodes)\n-        # Empty out the alert file\n-        with open(self.alert_filename, 'w', encoding='utf8') as _:\n-            pass\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, self.extra_args)\n-\n-        # Connecting one block should be enough to generate an error.\n-        self.nodes[0].generate(1)\n-        assert(WARN_UNKNOWN_RULES_ACTIVE in self.nodes[0].getinfo()[\"errors\"])\n-        assert(WARN_UNKNOWN_RULES_ACTIVE in self.nodes[0].getmininginfo()[\"errors\"])\n-        assert(WARN_UNKNOWN_RULES_ACTIVE in self.nodes[0].getnetworkinfo()[\"warnings\"])\n-        stop_nodes(self.nodes)\n-        self.test_versionbits_in_alert_file()\n+        # BIP135: removed obsolete check for error on activation of unknown bit\n \n         # Test framework expects the node to still be running...\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, self.extra_args)\n+        #self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, self.extra_args)\n \n if __name__ == '__main__':\n     VersionBitsWarningTest().main()"
      },
      {
        "sha": "e10cfa9a5e59ac7ba5aeb4e1716b7531942c7d37",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193",
        "patch": "@@ -120,9 +120,11 @@\n     # vv Tests less than 20m vv\n     'smartfees.py',\n     # vv Tests less than 5m vv\n+    'bip135-grace.py',\n     'maxuploadtarget.py',\n     'mempool_packages.py',\n     # vv Tests less than 2m vv\n+    'bip135-threshold.py',\n     'bip68-sequence.py',\n     'getblocktemplate_longpoll.py',\n     'p2p-timeouts.py',"
      }
    ]
  },
  {
    "sha": "7d9a32e93e967190c786c07f51298a0ebddcf79d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ZDlhMzJlOTNlOTY3MTkwYzc4NmMwN2Y1MTI5OGEwZWJkZGNmNzlk",
    "commit": {
      "author": {
        "name": "sanch0panza",
        "email": "sanch0panza@protonmail.com",
        "date": "2017-05-24T18:40:30Z"
      },
      "committer": {
        "name": "sanch0panza",
        "email": "sanch0panza@protonmail.com",
        "date": "2017-05-25T09:40:15Z"
      },
      "message": "[review] Remove unnecessary enum values",
      "tree": {
        "sha": "7fbce94700f56ce1d70eabf31a90938791fb2786",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7fbce94700f56ce1d70eabf31a90938791fb2786"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7d9a32e93e967190c786c07f51298a0ebddcf79d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7d9a32e93e967190c786c07f51298a0ebddcf79d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7d9a32e93e967190c786c07f51298a0ebddcf79d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7d9a32e93e967190c786c07f51298a0ebddcf79d/comments",
    "author": {
      "login": "sanch0panza",
      "id": 26766668,
      "node_id": "MDQ6VXNlcjI2NzY2NjY4",
      "avatar_url": "https://avatars.githubusercontent.com/u/26766668?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sanch0panza",
      "html_url": "https://github.com/sanch0panza",
      "followers_url": "https://api.github.com/users/sanch0panza/followers",
      "following_url": "https://api.github.com/users/sanch0panza/following{/other_user}",
      "gists_url": "https://api.github.com/users/sanch0panza/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sanch0panza/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sanch0panza/subscriptions",
      "organizations_url": "https://api.github.com/users/sanch0panza/orgs",
      "repos_url": "https://api.github.com/users/sanch0panza/repos",
      "events_url": "https://api.github.com/users/sanch0panza/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sanch0panza/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sanch0panza",
      "id": 26766668,
      "node_id": "MDQ6VXNlcjI2NzY2NjY4",
      "avatar_url": "https://avatars.githubusercontent.com/u/26766668?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sanch0panza",
      "html_url": "https://github.com/sanch0panza",
      "followers_url": "https://api.github.com/users/sanch0panza/followers",
      "following_url": "https://api.github.com/users/sanch0panza/following{/other_user}",
      "gists_url": "https://api.github.com/users/sanch0panza/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sanch0panza/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sanch0panza/subscriptions",
      "organizations_url": "https://api.github.com/users/sanch0panza/orgs",
      "repos_url": "https://api.github.com/users/sanch0panza/repos",
      "events_url": "https://api.github.com/users/sanch0panza/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sanch0panza/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e62ccde4f7d2b2b1725a82feff2f2a6aaa9c2193"
      }
    ],
    "stats": {
      "total": 10,
      "additions": 5,
      "deletions": 5
    },
    "files": [
      {
        "sha": "9bed674c657f5a468293cb4deb33d23c78242fa5",
        "filename": "src/versionbits.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d9a32e93e967190c786c07f51298a0ebddcf79d/src/versionbits.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d9a32e93e967190c786c07f51298a0ebddcf79d/src/versionbits.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/versionbits.h?ref=7d9a32e93e967190c786c07f51298a0ebddcf79d",
        "patch": "@@ -23,11 +23,11 @@ static const int BIT_WARNING_THRESHOLD = 50;\n \n // bip135: assigned numbers to these enum values\n enum ThresholdState {\n-    THRESHOLD_DEFINED = 0,\n-    THRESHOLD_STARTED = 1,\n-    THRESHOLD_LOCKED_IN = 2,\n-    THRESHOLD_ACTIVE = 3,\n-    THRESHOLD_FAILED = 4,\n+    THRESHOLD_DEFINED,\n+    THRESHOLD_STARTED,\n+    THRESHOLD_LOCKED_IN,\n+    THRESHOLD_ACTIVE,\n+    THRESHOLD_FAILED\n };\n \n // A map that gives the state for blocks."
      }
    ]
  },
  {
    "sha": "3e014d73e613669595e1559a35d1bc5b7f57bd2e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozZTAxNGQ3M2U2MTM2Njk1OTVlMTU1OWEzNWQxYmM1YjdmNTdiZDJl",
    "commit": {
      "author": {
        "name": "sanch0panza",
        "email": "sanch0panza@protonmail.com",
        "date": "2017-05-24T19:29:51Z"
      },
      "committer": {
        "name": "sanch0panza",
        "email": "sanch0panza@protonmail.com",
        "date": "2017-05-25T09:40:15Z"
      },
      "message": "[ext review] Remove sleeps in test\n\nRemoved irrelevant part of header comment",
      "tree": {
        "sha": "bc76222c6d74c9f8cffadb41f73cd9da2194caf6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bc76222c6d74c9f8cffadb41f73cd9da2194caf6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3e014d73e613669595e1559a35d1bc5b7f57bd2e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3e014d73e613669595e1559a35d1bc5b7f57bd2e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3e014d73e613669595e1559a35d1bc5b7f57bd2e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3e014d73e613669595e1559a35d1bc5b7f57bd2e/comments",
    "author": {
      "login": "sanch0panza",
      "id": 26766668,
      "node_id": "MDQ6VXNlcjI2NzY2NjY4",
      "avatar_url": "https://avatars.githubusercontent.com/u/26766668?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sanch0panza",
      "html_url": "https://github.com/sanch0panza",
      "followers_url": "https://api.github.com/users/sanch0panza/followers",
      "following_url": "https://api.github.com/users/sanch0panza/following{/other_user}",
      "gists_url": "https://api.github.com/users/sanch0panza/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sanch0panza/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sanch0panza/subscriptions",
      "organizations_url": "https://api.github.com/users/sanch0panza/orgs",
      "repos_url": "https://api.github.com/users/sanch0panza/repos",
      "events_url": "https://api.github.com/users/sanch0panza/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sanch0panza/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sanch0panza",
      "id": 26766668,
      "node_id": "MDQ6VXNlcjI2NzY2NjY4",
      "avatar_url": "https://avatars.githubusercontent.com/u/26766668?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sanch0panza",
      "html_url": "https://github.com/sanch0panza",
      "followers_url": "https://api.github.com/users/sanch0panza/followers",
      "following_url": "https://api.github.com/users/sanch0panza/following{/other_user}",
      "gists_url": "https://api.github.com/users/sanch0panza/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sanch0panza/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sanch0panza/subscriptions",
      "organizations_url": "https://api.github.com/users/sanch0panza/orgs",
      "repos_url": "https://api.github.com/users/sanch0panza/repos",
      "events_url": "https://api.github.com/users/sanch0panza/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sanch0panza/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7d9a32e93e967190c786c07f51298a0ebddcf79d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7d9a32e93e967190c786c07f51298a0ebddcf79d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7d9a32e93e967190c786c07f51298a0ebddcf79d"
      }
    ],
    "stats": {
      "total": 55,
      "additions": 10,
      "deletions": 45
    },
    "files": [
      {
        "sha": "47de779f34db50affa2bd1687879e46c172f001b",
        "filename": "test/functional/bip135-grace.py",
        "status": "modified",
        "additions": 9,
        "deletions": 43,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3e014d73e613669595e1559a35d1bc5b7f57bd2e/test/functional/bip135-grace.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3e014d73e613669595e1559a35d1bc5b7f57bd2e/test/functional/bip135-grace.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bip135-grace.py?ref=3e014d73e613669595e1559a35d1bc5b7f57bd2e",
        "patch": "@@ -21,8 +21,7 @@\n This test exercises BIP135 fork grace periods.\n It uses a single node with custom forks.csv file.\n \n-It is adapted from bip135-genvbvoting-forks on BU, which was\n-derived from bip9-softforks.\n+It is originally derived from bip9-softforks.\n '''\n \n \n@@ -32,7 +31,7 @@ def __init__(self):\n         super().__init__()\n         self.setup_clean_chain = True\n         self.num_nodes = 1\n-        self.defined_forks = [ \"bip135test%d\" % i for i in range(0,22) ]\n+        self.defined_forks = [ \"bip135test%d\" % i for i in range(7,22) ]\n \n     def setup_network(self):\n         '''\n@@ -53,29 +52,6 @@ def setup_network(self):\n             fh.write(\n             \"# deployment info for network 'regtest':\\n\" +\n \n-            ########## THRESHOLD TESTING BITS (1-6) ############\n-\n-            # bit 0: test 'csv' fork renaming/reparameterization\n-            \"regtest,0,bip135test0,%d,999999999999,144,108,0,0,true\\n\" % (self.fork_starttime) +\n-\n-            # bit 1: test minimum threshold\n-            \"regtest,1,bip135test1,%d,999999999999,100,1,0,0,true\\n\" % (self.fork_starttime) +\n-\n-            # bit 2: small threshold\n-            \"regtest,2,bip135test2,%d,999999999999,100,10,0,0,true\\n\" % (self.fork_starttime) +\n-\n-            # bit 3: supermajority threshold\n-            \"regtest,3,bip135test3,%d,999999999999,100,75,0,0,true\\n\" % (self.fork_starttime) +\n-\n-            # bit 4: high threshold\n-            \"regtest,4,bip135test4,%d,999999999999,100,95,0,0,true\\n\" % (self.fork_starttime) +\n-\n-            # bit 5: max-but-one threshold\n-            \"regtest,5,bip135test5,%d,999999999999,100,99,0,0,true\\n\" % (self.fork_starttime) +\n-\n-            # bit 6: max threshold\n-            \"regtest,6,bip135test6,%d,999999999999,100,100,0,0,true\\n\" % (self.fork_starttime) +\n-\n             ########## GRACE PERIOD TESTING BITS (7-21) ############\n \n             # bit 7: one minlockedblock\n@@ -179,10 +155,6 @@ def print_rpc_status(self):\n             print(info['bip135_forks'][f])\n \n     def test_BIP135GraceConditions(self):\n-\n-        # the fork bits used to check grace period conditions\n-        gracebits = self.defined_forks[7:22]\n-\n         print(\"begin test_BIP135GraceConditions test\")\n         node = self.nodes[0]\n         self.tip = int(\"0x\" + node.getbestblockhash(), 0)\n@@ -200,7 +172,7 @@ def test_BIP135GraceConditions(self):\n \n         bcinfo = self.nodes[0].getblockchaininfo()\n         # check bits 7-15 , they should be in DEFINED\n-        for f in gracebits:\n+        for f in self.defined_forks:\n             assert_equal(bcinfo['bip135_forks'][f]['bit'], int(f[10:]))\n             assert_equal(bcinfo['bip135_forks'][f]['status'], 'defined')\n \n@@ -211,14 +183,12 @@ def test_BIP135GraceConditions(self):\n         while tip_mediantime < self.fork_starttime or self.height % 10:\n             test_blocks = self.generate_blocks(1, 0x20000000)\n             yield TestInstance(test_blocks, sync_every_block=False)\n-            time.sleep(3)  # need to actually give daemon a little time to change the state\n             bcinfo = self.nodes[0].getblockchaininfo()\n             tip_mediantime = int(bcinfo['mediantime'])\n-            for f in gracebits:\n+            for f in self.defined_forks:\n                 # transition to STARTED must occur if this is true\n                 if tip_mediantime >= self.fork_starttime and self.height % 10 == 0:\n                     moved_to_started = True\n-                    time.sleep(3)  # need to actually give daemon a little time to change the state\n \n                 if moved_to_started:\n                     assert_equal(bcinfo['bip135_forks'][f]['status'], 'started')\n@@ -233,7 +203,7 @@ def test_BIP135GraceConditions(self):\n         # check bits 7-15 , they should all be in LOCKED_IN\n         bcinfo = self.nodes[0].getblockchaininfo()\n         print(\"checking all grace period forks are locked in\")\n-        for f in gracebits:\n+        for f in self.defined_forks:\n             assert_equal(bcinfo['bip135_forks'][f]['status'], 'locked_in')\n \n         # now we just check that they turn ACTIVE only when their configured\n@@ -262,9 +232,8 @@ def test_BIP135GraceConditions(self):\n \n         test_blocks = self.generate_blocks(10, 0x20000000)\n         yield TestInstance(test_blocks, sync_every_block=False)\n-        time.sleep(3)\n         bcinfo = self.nodes[0].getblockchaininfo()\n-        activation_states = [ bcinfo['bip135_forks'][f]['status'] for f in gracebits ]\n+        activation_states = [ bcinfo['bip135_forks'][f]['status'] for f in self.defined_forks ]\n         assert_equal(activation_states, ['active',\n                                          'active',\n                                          'active',\n@@ -285,9 +254,8 @@ def test_BIP135GraceConditions(self):\n         # check the ones supposed to activate at next+1 sync\n         test_blocks = self.generate_blocks(10, 0x20000000)\n         yield TestInstance(test_blocks, sync_every_block=False)\n-        time.sleep(3)\n         bcinfo = self.nodes[0].getblockchaininfo()\n-        activation_states = [ bcinfo['bip135_forks'][f]['status'] for f in gracebits ]\n+        activation_states = [ bcinfo['bip135_forks'][f]['status'] for f in self.defined_forks ]\n         assert_equal(activation_states, ['active',\n                                          'active',\n                                          'active',\n@@ -308,9 +276,8 @@ def test_BIP135GraceConditions(self):\n         # check the ones supposed to activate at next+2 period\n         test_blocks = self.generate_blocks(10, 0x20000000)\n         yield TestInstance(test_blocks, sync_every_block=False)\n-        time.sleep(3)\n         bcinfo = self.nodes[0].getblockchaininfo()\n-        activation_states = [ bcinfo['bip135_forks'][f]['status'] for f in gracebits ]\n+        activation_states = [ bcinfo['bip135_forks'][f]['status'] for f in self.defined_forks ]\n         assert_equal(activation_states, ['active',\n                                          'active',\n                                          'active',\n@@ -331,9 +298,8 @@ def test_BIP135GraceConditions(self):\n         # check the ones supposed to activate at next+2 period\n         test_blocks = self.generate_blocks(10, 0x20000000)\n         yield TestInstance(test_blocks, sync_every_block=False)\n-        time.sleep(3)\n         bcinfo = self.nodes[0].getblockchaininfo()\n-        activation_states = [ bcinfo['bip135_forks'][f]['status'] for f in gracebits ]\n+        activation_states = [ bcinfo['bip135_forks'][f]['status'] for f in self.defined_forks ]\n         assert_equal(activation_states, ['active',\n                                          'active',\n                                          'active',"
      },
      {
        "sha": "5aabab2a0fc8173647d4e956383515fd71b80ccc",
        "filename": "test/functional/bip135-threshold.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3e014d73e613669595e1559a35d1bc5b7f57bd2e/test/functional/bip135-threshold.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3e014d73e613669595e1559a35d1bc5b7f57bd2e/test/functional/bip135-threshold.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bip135-threshold.py?ref=3e014d73e613669595e1559a35d1bc5b7f57bd2e",
        "patch": "@@ -21,8 +21,7 @@\n This test exercises BIP135 fork activation thresholds.\n It uses a single node with custom forks.csv file.\n \n-It is adapted from bip135-genvbvoting-forks on BU, which was\n-derived from bip9-softforks.\n+It is originally derived from bip9-softforks.\n '''\n \n "
      }
    ]
  },
  {
    "sha": "6db7ca76a959b43dcfd6c07cd502b16bcf8762a0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2ZGI3Y2E3NmE5NTliNDNkY2ZkNmMwN2NkNTAyYjE2YmNmODc2MmEw",
    "commit": {
      "author": {
        "name": "sanch0panza",
        "email": "sanch0panza@protonmail.com",
        "date": "2017-05-24T19:37:27Z"
      },
      "committer": {
        "name": "sanch0panza",
        "email": "sanch0panza@protonmail.com",
        "date": "2017-05-25T09:40:15Z"
      },
      "message": "[ext review] Shorten statements to single return expression",
      "tree": {
        "sha": "3077e68a0f5cf7365026afc8305f27494a8921c5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3077e68a0f5cf7365026afc8305f27494a8921c5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6db7ca76a959b43dcfd6c07cd502b16bcf8762a0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6db7ca76a959b43dcfd6c07cd502b16bcf8762a0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6db7ca76a959b43dcfd6c07cd502b16bcf8762a0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6db7ca76a959b43dcfd6c07cd502b16bcf8762a0/comments",
    "author": {
      "login": "sanch0panza",
      "id": 26766668,
      "node_id": "MDQ6VXNlcjI2NzY2NjY4",
      "avatar_url": "https://avatars.githubusercontent.com/u/26766668?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sanch0panza",
      "html_url": "https://github.com/sanch0panza",
      "followers_url": "https://api.github.com/users/sanch0panza/followers",
      "following_url": "https://api.github.com/users/sanch0panza/following{/other_user}",
      "gists_url": "https://api.github.com/users/sanch0panza/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sanch0panza/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sanch0panza/subscriptions",
      "organizations_url": "https://api.github.com/users/sanch0panza/orgs",
      "repos_url": "https://api.github.com/users/sanch0panza/repos",
      "events_url": "https://api.github.com/users/sanch0panza/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sanch0panza/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sanch0panza",
      "id": 26766668,
      "node_id": "MDQ6VXNlcjI2NzY2NjY4",
      "avatar_url": "https://avatars.githubusercontent.com/u/26766668?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sanch0panza",
      "html_url": "https://github.com/sanch0panza",
      "followers_url": "https://api.github.com/users/sanch0panza/followers",
      "following_url": "https://api.github.com/users/sanch0panza/following{/other_user}",
      "gists_url": "https://api.github.com/users/sanch0panza/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sanch0panza/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sanch0panza/subscriptions",
      "organizations_url": "https://api.github.com/users/sanch0panza/orgs",
      "repos_url": "https://api.github.com/users/sanch0panza/repos",
      "events_url": "https://api.github.com/users/sanch0panza/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sanch0panza/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3e014d73e613669595e1559a35d1bc5b7f57bd2e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3e014d73e613669595e1559a35d1bc5b7f57bd2e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3e014d73e613669595e1559a35d1bc5b7f57bd2e"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 1,
      "deletions": 5
    },
    "files": [
      {
        "sha": "9c2f1e5ab764a4de87f489bd60b5d3681bdd093d",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 5,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6db7ca76a959b43dcfd6c07cd502b16bcf8762a0/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6db7ca76a959b43dcfd6c07cd502b16bcf8762a0/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=6db7ca76a959b43dcfd6c07cd502b16bcf8762a0",
        "patch": "@@ -415,11 +415,7 @@ bool isConfiguredDeployment(const Consensus::Params& consensusParams, const int\n     if (strlen(vbinfo.name) == 0)\n         return false;\n \n-    if (vdeployments[bit].windowsize == 0 || vdeployments[bit].threshold == 0)\n-    {\n-        return false;\n-    }\n-    return true;\n+    return (vdeployments[bit].windowsize != 0 && vdeployments[bit].threshold != 0);\n }\n \n /**"
      }
    ]
  },
  {
    "sha": "967c52b02005bbf15eaab1d9a1e2444a5990edec",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NjdjNTJiMDIwMDViYmYxNWVhYWIxZDlhMWUyNDQ0YTU5OTBlZGVj",
    "commit": {
      "author": {
        "name": "sanch0panza",
        "email": "sanch0panza@protonmail.com",
        "date": "2017-05-24T20:10:16Z"
      },
      "committer": {
        "name": "sanch0panza",
        "email": "sanch0panza@protonmail.com",
        "date": "2017-05-25T09:40:15Z"
      },
      "message": "Fix up comments, remove obsolete commented-out section",
      "tree": {
        "sha": "e58e453c4226dcc38b2a37a3b4742066e5b1af0c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e58e453c4226dcc38b2a37a3b4742066e5b1af0c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/967c52b02005bbf15eaab1d9a1e2444a5990edec",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/967c52b02005bbf15eaab1d9a1e2444a5990edec",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/967c52b02005bbf15eaab1d9a1e2444a5990edec",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/967c52b02005bbf15eaab1d9a1e2444a5990edec/comments",
    "author": {
      "login": "sanch0panza",
      "id": 26766668,
      "node_id": "MDQ6VXNlcjI2NzY2NjY4",
      "avatar_url": "https://avatars.githubusercontent.com/u/26766668?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sanch0panza",
      "html_url": "https://github.com/sanch0panza",
      "followers_url": "https://api.github.com/users/sanch0panza/followers",
      "following_url": "https://api.github.com/users/sanch0panza/following{/other_user}",
      "gists_url": "https://api.github.com/users/sanch0panza/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sanch0panza/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sanch0panza/subscriptions",
      "organizations_url": "https://api.github.com/users/sanch0panza/orgs",
      "repos_url": "https://api.github.com/users/sanch0panza/repos",
      "events_url": "https://api.github.com/users/sanch0panza/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sanch0panza/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sanch0panza",
      "id": 26766668,
      "node_id": "MDQ6VXNlcjI2NzY2NjY4",
      "avatar_url": "https://avatars.githubusercontent.com/u/26766668?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sanch0panza",
      "html_url": "https://github.com/sanch0panza",
      "followers_url": "https://api.github.com/users/sanch0panza/followers",
      "following_url": "https://api.github.com/users/sanch0panza/following{/other_user}",
      "gists_url": "https://api.github.com/users/sanch0panza/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sanch0panza/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sanch0panza/subscriptions",
      "organizations_url": "https://api.github.com/users/sanch0panza/orgs",
      "repos_url": "https://api.github.com/users/sanch0panza/repos",
      "events_url": "https://api.github.com/users/sanch0panza/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sanch0panza/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6db7ca76a959b43dcfd6c07cd502b16bcf8762a0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6db7ca76a959b43dcfd6c07cd502b16bcf8762a0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6db7ca76a959b43dcfd6c07cd502b16bcf8762a0"
      }
    ],
    "stats": {
      "total": 9,
      "additions": 2,
      "deletions": 7
    },
    "files": [
      {
        "sha": "953c0408f55e514e770c6411dac75bf28d77c84f",
        "filename": "test/functional/p2p-versionbits-warning.py",
        "status": "modified",
        "additions": 2,
        "deletions": 7,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/967c52b02005bbf15eaab1d9a1e2444a5990edec/test/functional/p2p-versionbits-warning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/967c52b02005bbf15eaab1d9a1e2444a5990edec/test/functional/p2p-versionbits-warning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-versionbits-warning.py?ref=967c52b02005bbf15eaab1d9a1e2444a5990edec",
        "patch": "@@ -1,11 +1,11 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2016 The Bitcoin Core developers\n+# Copyright (c) 2016-2017 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test version bits warning system.\n \n Generate chains with block versions that appear to be signalling unknown\n-soft-forks, and test that warning alerts are generated.\n+forks, and test that warning alerts are generated.\n \"\"\"\n \n from test_framework.mininode import *\n@@ -108,10 +108,5 @@ def run_test(self):\n         assert(WARN_UNKNOWN_RULES_MINED in self.nodes[0].getmininginfo()[\"errors\"])\n         assert(WARN_UNKNOWN_RULES_MINED in self.nodes[0].getnetworkinfo()[\"warnings\"])\n \n-        # BIP135: removed obsolete check for error on activation of unknown bit\n-\n-        # Test framework expects the node to still be running...\n-        #self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, self.extra_args)\n-\n if __name__ == '__main__':\n     VersionBitsWarningTest().main()"
      }
    ]
  },
  {
    "sha": "6d361c1b3e70d3dca30e3c630045145d4ae8fe11",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2ZDM2MWMxYjNlNzBkM2RjYTMwZTNjNjMwMDQ1MTQ1ZDRhZThmZTEx",
    "commit": {
      "author": {
        "name": "sanch0panza",
        "email": "sanch0panza@protonmail.com",
        "date": "2017-05-24T20:32:14Z"
      },
      "committer": {
        "name": "sanch0panza",
        "email": "sanch0panza@protonmail.com",
        "date": "2017-05-25T09:42:24Z"
      },
      "message": "Renaming of BIP9Deployment* to ForkDeployment*",
      "tree": {
        "sha": "a77e03413d1a58b8369261f7211d81b371227420",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a77e03413d1a58b8369261f7211d81b371227420"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6d361c1b3e70d3dca30e3c630045145d4ae8fe11",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6d361c1b3e70d3dca30e3c630045145d4ae8fe11",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6d361c1b3e70d3dca30e3c630045145d4ae8fe11",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6d361c1b3e70d3dca30e3c630045145d4ae8fe11/comments",
    "author": {
      "login": "sanch0panza",
      "id": 26766668,
      "node_id": "MDQ6VXNlcjI2NzY2NjY4",
      "avatar_url": "https://avatars.githubusercontent.com/u/26766668?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sanch0panza",
      "html_url": "https://github.com/sanch0panza",
      "followers_url": "https://api.github.com/users/sanch0panza/followers",
      "following_url": "https://api.github.com/users/sanch0panza/following{/other_user}",
      "gists_url": "https://api.github.com/users/sanch0panza/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sanch0panza/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sanch0panza/subscriptions",
      "organizations_url": "https://api.github.com/users/sanch0panza/orgs",
      "repos_url": "https://api.github.com/users/sanch0panza/repos",
      "events_url": "https://api.github.com/users/sanch0panza/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sanch0panza/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sanch0panza",
      "id": 26766668,
      "node_id": "MDQ6VXNlcjI2NzY2NjY4",
      "avatar_url": "https://avatars.githubusercontent.com/u/26766668?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sanch0panza",
      "html_url": "https://github.com/sanch0panza",
      "followers_url": "https://api.github.com/users/sanch0panza/followers",
      "following_url": "https://api.github.com/users/sanch0panza/following{/other_user}",
      "gists_url": "https://api.github.com/users/sanch0panza/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sanch0panza/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sanch0panza/subscriptions",
      "organizations_url": "https://api.github.com/users/sanch0panza/orgs",
      "repos_url": "https://api.github.com/users/sanch0panza/repos",
      "events_url": "https://api.github.com/users/sanch0panza/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sanch0panza/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "967c52b02005bbf15eaab1d9a1e2444a5990edec",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/967c52b02005bbf15eaab1d9a1e2444a5990edec",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/967c52b02005bbf15eaab1d9a1e2444a5990edec"
      }
    ],
    "stats": {
      "total": 35,
      "additions": 15,
      "deletions": 20
    },
    "files": [
      {
        "sha": "3650eec729dc5c4591a67b898824f0be2b623287",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6d361c1b3e70d3dca30e3c630045145d4ae8fe11/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6d361c1b3e70d3dca30e3c630045145d4ae8fe11/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=6d361c1b3e70d3dca30e3c630045145d4ae8fe11",
        "patch": "@@ -409,8 +409,8 @@ void UpdateBIP9Parameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_\n  */\n bool isConfiguredDeployment(const Consensus::Params& consensusParams, const int bit)\n {\n-    const Consensus::BIP9Deployment *vdeployments = consensusParams.vDeployments;\n-    const struct BIP9DeploymentInfo& vbinfo = VersionBitsDeploymentInfo[bit];\n+    const Consensus::ForkDeployment *vdeployments = consensusParams.vDeployments;\n+    const struct ForkDeploymentInfo& vbinfo = VersionBitsDeploymentInfo[bit];\n \n     if (strlen(vbinfo.name) == 0)\n         return false;\n@@ -425,14 +425,14 @@ bool isConfiguredDeployment(const Consensus::Params& consensusParams, const int\n const std::string NetworkDeploymentInfoCSV(const std::string& network)\n {\n     const Consensus::Params& consensusParams = Params(network).GetConsensus();\n-    const Consensus::BIP9Deployment *vdeployments = consensusParams.vDeployments;\n+    const Consensus::ForkDeployment *vdeployments = consensusParams.vDeployments;\n \n     std::string networkInfoStr;\n     networkInfoStr = \"# deployment info for network '\" + network + \"':\\n\";\n \n     for (int bit = 0; bit < Consensus::MAX_VERSION_BITS_DEPLOYMENTS; bit++)\n     {\n-        const struct BIP9DeploymentInfo& vbinfo = VersionBitsDeploymentInfo[bit];\n+        const struct ForkDeploymentInfo& vbinfo = VersionBitsDeploymentInfo[bit];\n         if (isConfiguredDeployment(consensusParams, bit)) {\n             networkInfoStr += network + \",\";\n             networkInfoStr += std::to_string(bit) + \",\";"
      },
      {
        "sha": "f23e806de3738b64a7680bd226ea2cc6b1ac33ba",
        "filename": "src/consensus/params.h",
        "status": "modified",
        "additions": 3,
        "deletions": 8,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6d361c1b3e70d3dca30e3c630045145d4ae8fe11/src/consensus/params.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6d361c1b3e70d3dca30e3c630045145d4ae8fe11/src/consensus/params.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/params.h?ref=6d361c1b3e70d3dca30e3c630045145d4ae8fe11",
        "patch": "@@ -57,9 +57,9 @@ enum DeploymentPos\n };\n \n /**\n- * Struct for each individual consensus rule change using BIP9.\n+ * Struct for each individual consensus rule change using BIP135.\n  */\n-struct BIP9Deployment {\n+struct ForkDeployment {\n     /** Bit position to select the particular bit in nVersion. */\n     int bit;\n     /** Start MedianTime for version bits miner confirmation. Can be a date in the past */\n@@ -91,17 +91,12 @@ struct Params {\n     int BIP65Height;\n     /** Block height at which BIP66 becomes active */\n     int BIP66Height;\n-    /**\n-     * Minimum blocks including miner confirmation of the total of 2016 blocks in a retargeting period,\n-     * (nPowTargetTimespan / nPowTargetSpacing) which is also used for BIP9 deployments.\n-     * Examples: 1916 for 95%, 1512 for testchains.\n-     */\n     /**\n      * Deployment parameters for the 29 bits (0..28) defined by bip135\n      */\n     // bip135 begin\n     // fully initialize array\n-    BIP9Deployment vDeployments[MAX_VERSION_BITS_DEPLOYMENTS] = {\n+    ForkDeployment vDeployments[MAX_VERSION_BITS_DEPLOYMENTS] = {\n             { 0, 0LL, 0LL, 0, 0, 0, 0LL },  // deployment on bit 0\n             { 1, 0LL, 0LL, 0, 0, 0, 0LL },  // deployment on bit 1\n             { 2, 0LL, 0LL, 0, 0, 0, 0LL },  // deployment on bit 2"
      },
      {
        "sha": "4e1525ab8f0a96556c761e488914137fd3c551f8",
        "filename": "src/forks_csv.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6d361c1b3e70d3dca30e3c630045145d4ae8fe11/src/forks_csv.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6d361c1b3e70d3dca30e3c630045145d4ae8fe11/src/forks_csv.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/forks_csv.cpp?ref=6d361c1b3e70d3dca30e3c630045145d4ae8fe11",
        "patch": "@@ -128,7 +128,7 @@ bool ReadForksCsv(string activeNetworkID, istream& csvInput, Consensus::Params&\n             if (network == activeNetworkID && ValidateOverallParams(network)) {\n                 assert(bit >= 0 && bit < VERSIONBITS_NUM_BITS);\n                 // update deployment params for current network\n-                BIP9DeploymentInfo& vbinfo = VersionBitsDeploymentInfo[bit];\n+                ForkDeploymentInfo& vbinfo = VersionBitsDeploymentInfo[bit];\n \n                 // copy the data\n                 if (name.length()) {"
      },
      {
        "sha": "43062b56cb002b67cc22d5f1f5c0dcd477164b1f",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6d361c1b3e70d3dca30e3c630045145d4ae8fe11/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6d361c1b3e70d3dca30e3c630045145d4ae8fe11/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=6d361c1b3e70d3dca30e3c630045145d4ae8fe11",
        "patch": "@@ -1208,7 +1208,7 @@ UniValue getblockchaininfo(const JSONRPCRequest& request)\n     for (int i = 0; i < Consensus::MAX_VERSION_BITS_DEPLOYMENTS; i++)\n     {\n         Consensus::DeploymentPos bit = static_cast<Consensus::DeploymentPos>(i);\n-        const struct BIP9DeploymentInfo& vbinfo = VersionBitsDeploymentInfo[bit];\n+        const struct ForkDeploymentInfo& vbinfo = VersionBitsDeploymentInfo[bit];\n         if (isConfiguredDeployment(consensusParams, bit)) {\n             bip9_softforks.push_back(Pair(vbinfo.name, BIP9SoftForkDesc(consensusParams, bit)));\n             bip135_forks.push_back(Pair(vbinfo.name, BIP135ForkDesc(consensusParams, bit)));"
      },
      {
        "sha": "ddbac60a05f6c5793bfcdba6aeca1896cec95551",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6d361c1b3e70d3dca30e3c630045145d4ae8fe11/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6d361c1b3e70d3dca30e3c630045145d4ae8fe11/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=6d361c1b3e70d3dca30e3c630045145d4ae8fe11",
        "patch": "@@ -303,7 +303,7 @@ static UniValue BIP22ValidationResult(const CValidationState& state)\n }\n \n std::string gbt_vb_name(const Consensus::DeploymentPos pos) {\n-    const struct BIP9DeploymentInfo& vbinfo = VersionBitsDeploymentInfo[pos];\n+    const struct ForkDeploymentInfo& vbinfo = VersionBitsDeploymentInfo[pos];\n     std::string s = vbinfo.name;\n     if (!vbinfo.gbt_force) {\n         s.insert(s.begin(), '!');\n@@ -515,7 +515,7 @@ UniValue getblocktemplate(const JSONRPCRequest& request)\n         // TODO: Maybe recheck connections/IBD and (if something wrong) send an expires-immediately template to stop miners?\n     }\n \n-    const struct BIP9DeploymentInfo& segwit_info = VersionBitsDeploymentInfo[Consensus::DEPLOYMENT_SEGWIT];\n+    const struct ForkDeploymentInfo& segwit_info = VersionBitsDeploymentInfo[Consensus::DEPLOYMENT_SEGWIT];\n     // If the caller is indicating segwit support, then allow CreateNewBlock()\n     // to select witness transactions, after segwit activates (otherwise\n     // don't).\n@@ -630,7 +630,7 @@ UniValue getblocktemplate(const JSONRPCRequest& request)\n                     // FALL THROUGH to get vbavailable set...\n                 case THRESHOLD_STARTED:\n                 {\n-                    const struct BIP9DeploymentInfo& vbinfo = VersionBitsDeploymentInfo[pos];\n+                    const struct ForkDeploymentInfo& vbinfo = VersionBitsDeploymentInfo[pos];\n                     vbavailable.push_back(Pair(gbt_vb_name(pos), consensusParams.vDeployments[pos].bit));\n                     if (setClientRules.find(vbinfo.name) == setClientRules.end()) {\n                         if (!vbinfo.gbt_force) {\n@@ -643,7 +643,7 @@ UniValue getblocktemplate(const JSONRPCRequest& request)\n                 case THRESHOLD_ACTIVE:\n                 {\n                     // Add to rules only\n-                    const struct BIP9DeploymentInfo& vbinfo = VersionBitsDeploymentInfo[pos];\n+                    const struct ForkDeploymentInfo& vbinfo = VersionBitsDeploymentInfo[pos];\n                     aRules.push_back(gbt_vb_name(pos));\n                     if (setClientRules.find(vbinfo.name) == setClientRules.end()) {\n                         // Not supported by the client; make sure it's safe to proceed\n@@ -666,7 +666,7 @@ UniValue getblocktemplate(const JSONRPCRequest& request)\n         // If VB is supported by the client, nMaxVersionPreVB is -1, so we won't get here\n         // Because BIP 34 changed how the generation transaction is serialized, we can only use version/force back to v2 blocks\n         // This is safe to do [otherwise-]unconditionally only because we are throwing an exception above if a non-force deployment gets activated\n-        // Note that this can probably also be removed entirely after the first BIP9 non-force deployment (ie, probably segwit) gets activated\n+        // Note that this can probably also be removed entirely after the first BIP9/BIP135 non-force deployment (ie, probably segwit) gets activated\n         aMutable.push_back(\"version/force\");\n     }\n "
      },
      {
        "sha": "0e7f283a8e0a57341a2b78c88b8f0f49444c61b9",
        "filename": "src/versionbits.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6d361c1b3e70d3dca30e3c630045145d4ae8fe11/src/versionbits.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6d361c1b3e70d3dca30e3c630045145d4ae8fe11/src/versionbits.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/versionbits.cpp?ref=6d361c1b3e70d3dca30e3c630045145d4ae8fe11",
        "patch": "@@ -6,7 +6,7 @@\n #include \"consensus/params.h\"\n \n // bip135 begin fill out entire table\n-struct BIP9DeploymentInfo VersionBitsDeploymentInfo[Consensus::MAX_VERSION_BITS_DEPLOYMENTS] = {\n+struct ForkDeploymentInfo VersionBitsDeploymentInfo[Consensus::MAX_VERSION_BITS_DEPLOYMENTS] = {\n     {\n         /*.name =*/ (char *) \"csv\",\n         /*.gbt_force =*/ true,"
      }
    ]
  },
  {
    "sha": "00e830d3e6c801626aef47212bf0a0e7ffbb4644",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMGU4MzBkM2U2YzgwMTYyNmFlZjQ3MjEyYmYwYTBlN2ZmYmI0NjQ0",
    "commit": {
      "author": {
        "name": "sanch0panza",
        "email": "sanch0panza@protonmail.com",
        "date": "2017-05-24T20:35:47Z"
      },
      "committer": {
        "name": "sanch0panza",
        "email": "sanch0panza@protonmail.com",
        "date": "2017-05-25T09:43:37Z"
      },
      "message": "Update BIP9 reference to BIP135 in comments",
      "tree": {
        "sha": "86c29ac7d40979ed3083d05c7cf783b095a0f848",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/86c29ac7d40979ed3083d05c7cf783b095a0f848"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/00e830d3e6c801626aef47212bf0a0e7ffbb4644",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00e830d3e6c801626aef47212bf0a0e7ffbb4644",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/00e830d3e6c801626aef47212bf0a0e7ffbb4644",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00e830d3e6c801626aef47212bf0a0e7ffbb4644/comments",
    "author": {
      "login": "sanch0panza",
      "id": 26766668,
      "node_id": "MDQ6VXNlcjI2NzY2NjY4",
      "avatar_url": "https://avatars.githubusercontent.com/u/26766668?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sanch0panza",
      "html_url": "https://github.com/sanch0panza",
      "followers_url": "https://api.github.com/users/sanch0panza/followers",
      "following_url": "https://api.github.com/users/sanch0panza/following{/other_user}",
      "gists_url": "https://api.github.com/users/sanch0panza/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sanch0panza/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sanch0panza/subscriptions",
      "organizations_url": "https://api.github.com/users/sanch0panza/orgs",
      "repos_url": "https://api.github.com/users/sanch0panza/repos",
      "events_url": "https://api.github.com/users/sanch0panza/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sanch0panza/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sanch0panza",
      "id": 26766668,
      "node_id": "MDQ6VXNlcjI2NzY2NjY4",
      "avatar_url": "https://avatars.githubusercontent.com/u/26766668?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sanch0panza",
      "html_url": "https://github.com/sanch0panza",
      "followers_url": "https://api.github.com/users/sanch0panza/followers",
      "following_url": "https://api.github.com/users/sanch0panza/following{/other_user}",
      "gists_url": "https://api.github.com/users/sanch0panza/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sanch0panza/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sanch0panza/subscriptions",
      "organizations_url": "https://api.github.com/users/sanch0panza/orgs",
      "repos_url": "https://api.github.com/users/sanch0panza/repos",
      "events_url": "https://api.github.com/users/sanch0panza/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sanch0panza/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6d361c1b3e70d3dca30e3c630045145d4ae8fe11",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6d361c1b3e70d3dca30e3c630045145d4ae8fe11",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6d361c1b3e70d3dca30e3c630045145d4ae8fe11"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 3,
      "deletions": 3
    },
    "files": [
      {
        "sha": "b786c225a921c5254dde25d2e02b22231e814cff",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00e830d3e6c801626aef47212bf0a0e7ffbb4644/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00e830d3e6c801626aef47212bf0a0e7ffbb4644/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=00e830d3e6c801626aef47212bf0a0e7ffbb4644",
        "patch": "@@ -336,13 +336,13 @@ bool AcceptToMemoryPoolWithTime(CTxMemPool& pool, CValidationState &state, const\n /** Convert CValidationState to a human-readable message for logging */\n std::string FormatStateMessage(const CValidationState &state);\n \n-/** Get the BIP9 state for a given deployment at the current tip. */\n+/** Get the BIP135 state for a given deployment at the current tip. */\n ThresholdState VersionBitsTipState(const Consensus::Params& params, Consensus::DeploymentPos pos);\n \n-/** Get the numerical statistics for the BIP9 state for a given deployment at the current tip. */\n+/** Get the numerical statistics for the BIP135 state for a given deployment at the current tip. */\n ForkStats VersionBitsTipStatistics(const Consensus::Params& params, Consensus::DeploymentPos pos);\n \n-/** Get the block height at which the BIP9 deployment switched into the state for the block building on the current tip. */\n+/** Get the block height at which the BIP135 deployment switched into the state for the block building on the current tip. */\n int VersionBitsTipStateSinceHeight(const Consensus::Params& params, Consensus::DeploymentPos pos);\n \n "
      }
    ]
  },
  {
    "sha": "54ffc57af91917e7fafd9a24e1fcb38a42fee36c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1NGZmYzU3YWY5MTkxN2U3ZmFmZDlhMjRlMWZjYjM4YTQyZmVlMzZj",
    "commit": {
      "author": {
        "name": "sanch0panza",
        "email": "sanch0panza@protonmail.com",
        "date": "2017-05-25T09:45:32Z"
      },
      "committer": {
        "name": "sanch0panza",
        "email": "sanch0panza@protonmail.com",
        "date": "2017-05-25T09:45:32Z"
      },
      "message": "Squashed 'src/fast-cpp-csv-parser/' content from commit 769c042\n\ngit-subtree-dir: src/fast-cpp-csv-parser\ngit-subtree-split: 769c042c453bd94537bba7bb276453c13ec4db1b",
      "tree": {
        "sha": "f02cf5301bb010067b5ad155e84d65ff7942d9e8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f02cf5301bb010067b5ad155e84d65ff7942d9e8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/54ffc57af91917e7fafd9a24e1fcb38a42fee36c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/54ffc57af91917e7fafd9a24e1fcb38a42fee36c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/54ffc57af91917e7fafd9a24e1fcb38a42fee36c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/54ffc57af91917e7fafd9a24e1fcb38a42fee36c/comments",
    "author": {
      "login": "sanch0panza",
      "id": 26766668,
      "node_id": "MDQ6VXNlcjI2NzY2NjY4",
      "avatar_url": "https://avatars.githubusercontent.com/u/26766668?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sanch0panza",
      "html_url": "https://github.com/sanch0panza",
      "followers_url": "https://api.github.com/users/sanch0panza/followers",
      "following_url": "https://api.github.com/users/sanch0panza/following{/other_user}",
      "gists_url": "https://api.github.com/users/sanch0panza/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sanch0panza/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sanch0panza/subscriptions",
      "organizations_url": "https://api.github.com/users/sanch0panza/orgs",
      "repos_url": "https://api.github.com/users/sanch0panza/repos",
      "events_url": "https://api.github.com/users/sanch0panza/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sanch0panza/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sanch0panza",
      "id": 26766668,
      "node_id": "MDQ6VXNlcjI2NzY2NjY4",
      "avatar_url": "https://avatars.githubusercontent.com/u/26766668?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sanch0panza",
      "html_url": "https://github.com/sanch0panza",
      "followers_url": "https://api.github.com/users/sanch0panza/followers",
      "following_url": "https://api.github.com/users/sanch0panza/following{/other_user}",
      "gists_url": "https://api.github.com/users/sanch0panza/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sanch0panza/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sanch0panza/subscriptions",
      "organizations_url": "https://api.github.com/users/sanch0panza/orgs",
      "repos_url": "https://api.github.com/users/sanch0panza/repos",
      "events_url": "https://api.github.com/users/sanch0panza/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sanch0panza/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [],
    "stats": {
      "total": 1545,
      "additions": 1545,
      "deletions": 0
    },
    "files": [
      {
        "sha": "da603a96be217c7a8ca2542b351a5a95d3c30c78",
        "filename": "LICENSE",
        "status": "added",
        "additions": 28,
        "deletions": 0,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54ffc57af91917e7fafd9a24e1fcb38a42fee36c/LICENSE",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54ffc57af91917e7fafd9a24e1fcb38a42fee36c/LICENSE",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/LICENSE?ref=54ffc57af91917e7fafd9a24e1fcb38a42fee36c",
        "patch": "@@ -0,0 +1,28 @@\n+Copyright (c) 2015, ben-strasser\n+All rights reserved.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are met:\n+\n+* Redistributions of source code must retain the above copyright notice, this\n+  list of conditions and the following disclaimer.\n+\n+* Redistributions in binary form must reproduce the above copyright notice,\n+  this list of conditions and the following disclaimer in the documentation\n+  and/or other materials provided with the distribution.\n+\n+* Neither the name of fast-cpp-csv-parser nor the names of its\n+  contributors may be used to endorse or promote products derived from\n+  this software without specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+"
      },
      {
        "sha": "d929341ab1dd920b6e24999074ff67d5dc382df2",
        "filename": "README.md",
        "status": "added",
        "additions": 268,
        "deletions": 0,
        "changes": 268,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54ffc57af91917e7fafd9a24e1fcb38a42fee36c/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54ffc57af91917e7fafd9a24e1fcb38a42fee36c/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/README.md?ref=54ffc57af91917e7fafd9a24e1fcb38a42fee36c",
        "patch": "@@ -0,0 +1,268 @@\n+# Fast C++ CSV Parser\n+\n+This is a small, easy-to-use and fast header-only library for reading comma separated value (CSV) files. \n+\n+## Features\n+\n+  * Automatically rearranges columns by parsing the header line.\n+  * Disk I/O and CSV-parsing are overlapped using threads for efficiency.\n+  * Parsing features such as escaped strings can be enabled and disabled at compile time using templates. You only pay in speed for the features you actually use.\n+  * Can read multiple GB files in reasonable time.\n+  * Support for custom columns separators (i.e. Tab separated value files are supported), quote escaped strings, automatic space trimming. \n+  * Works with `*`nix and Windows newlines and automatically ignores UTF-8 BOMs.\n+  * Exception classes with enough context to format useful error messages. what() returns error messages ready to be shown to a user. \n+\n+## Getting Started\n+\n+The following small example should contain most of the syntax you need to use the library.\n+\n+```cpp\n+# include \"csv.h\"\n+\n+int main(){\n+  io::CSVReader<3> in(\"ram.csv\");\n+  in.read_header(io::ignore_extra_column, \"vendor\", \"size\", \"speed\");\n+  std::string vendor; int size; double speed;\n+  while(in.read_row(vendor, size, speed)){\n+    // do stuff with the data\n+  }\n+}\n+```\n+\n+## Installation\n+\n+The library only needs a standard conformant C++11 compiler. It has no further dependencies. The library is completely contained inside a single header file and therefore it is sufficient to copy this file to some place on your include path. The library does not have to be explicitly build. \n+\n+Note however, that threads are used and some compiler (for example GCC) require you to link against additional librarie to make it work. With GCC it is important to add -lpthread as the last item when linking, i.e. the order in \n+\n+```\n+g++ -std=c++0x a.o b.o -o prog -lpthread\n+```\n+\n+is important. If you for some reason do not want to use threads you can define CSV_IO_NO_THREAD before including the header.\n+\n+Remember that the library makes use of C++11 features and therefore you have to enable support for it (f.e. add -std=c++0x or -std=gnu++0x). \n+\n+The library was developed and tested with GCC 4.6.1\n+\n+Note that VS2013 is not C++11 compilant and will therefore not work out of the box. See [here](https://code.google.com/p/fast-cpp-csv-parser/issues/detail?id=6) for what needs to be adjusted to make the code work.\n+\n+## Documentation\n+\n+The libary provides two classes: \n+\n+  * `LineReader`: A class to efficiently read large files line by line.\n+  * `CSVReader`: A class that efficiently reads large CSV files.\n+\n+Note that everything is contained in the `io` namespace.\n+\n+### `LineReader`\n+\n+```cpp\n+class LineReader{\n+public:\n+  // Constructors\n+  LineReader(some_string_type file_name);\n+  LineReader(some_string_type file_name, std::FILE*source);\n+  LineReader(some_string_type file_name, std::istream&source);\n+  LineReader(some_string_type file_name, std::unique_ptr<ByteSourceBase>source);\n+\n+  // Reading\n+  char*next_line();\n+\n+  // File Location\n+  void set_file_line(unsigned);\n+  unsigned get_file_line(unsigned)const;\n+  void set_file_name(some_string_type file_name);\n+  const char*get_truncated_file_name()const;\n+};\n+```\n+\n+The constructor takes a file name and optionally a data source. If no data source is provided the function tries to open the file with the given name and throws an `error::can_not_open_file exception` on failure. If a data source is provided then the file name is only used to format error messages. In that case you can essentially put any string there. Using a string that describes the data source results in more informative error messages.\n+\n+`some_string_type` can be a `std::string` or a `char*`. If the data source is a `std::FILE*` then the library will take care of calling `std::fclose`. If it is a `std::istream` then the stream is not closed by the library. For best performance open the streams in binary mode. However using text mode also works. `ByteSourceBase` provides an interface that you can use to implement further data sources. \n+\n+```\n+class ByteSourceBase{\n+public:\n+  virtual int read(char*buffer, int size)=0;\n+  virtual ~ByteSourceBase(){}\n+};\n+```\n+\n+The read function should fill the provided buffer with at most `size` bytes from the data source. It should return the number of bytes actually written to the buffer. If data source has run out of bytes (because for example an end of file was reached) then the function should return 0. If a fatal error occures then you can throw an exception. Note that the function can be called both from the main and the worker thread. However, it is guarenteed that they do not call the function at the same time. \n+\n+Lines are read by calling the `next_line` function. It returns a pointer to a null terminated C-string that contains the line. If the end of file is reached a null pointer is returned. The newline character is not included in the string. You may modify the string as long as you do not write past the null terminator. The string stays valid until the destructor is called or until next_line is called again. Windows and `*`nix newlines are handled transparently. UTF-8 BOMs are automatically ignored and missing newlines at the end of the file are no problem.\n+\n+**Important:** There is a limit of 2^24-1 characters per line. If this limit is exceeded a `error::line_length_limit_exceeded` exception is thrown.\n+\n+Looping over all the lines in a file can be done in the following way.\n+```cpp\n+LineReader in(...);\n+while(char*line = in.next_line()){\n+  ...\n+}\n+```\n+\n+The remaining functions are mainly used used to format error messages. The file line indicates the current position in the file, i.e., after the first `next_line` call it is 1 and after the second 2. Before the first call it is 0. The file name is truncated as internally C-strings are used to avoid `std::bad_alloc` exceptions during error reporting.\n+\n+**Note:** It is not possible to exchange the line termination character.\n+\n+### `CSVReader`\n+\n+`CSVReader` uses policies. These are classes with only static members to allow core functionality to be exchanged in an efficient way.\n+\n+```cpp\n+template<\n+  unsigned column_count,\n+  class trim_policy = trim_chars<' ', '\\t'>, \n+  class quote_policy = no_quote_escape<','>,\n+  class overflow_policy = throw_on_overflow,\n+  class comment_policy = no_comment\n+>\n+class CSVReader{\n+public:\n+  // Constructors\n+  // same as for LineReader\n+\n+  // Parsing Header\n+  void read_header(ignore_column ignore_policy, some_string_type col_name1, some_string_type col_name2, ...);\n+  void set_header(some_string_type col_name1, some_string_type col_name2, ...);\n+  bool has_column(some_string_type col_name)const;\n+\n+  // Read\n+  char*next_line();\n+  bool read_row(ColType1&col1, ColType2&col2, ...);\n+\n+  // File Location \n+  void set_file_line(unsigned);\n+  unsigned get_file_line()const;\n+  void set_file_name(some_string_type file_name);\n+  const char*get_truncated_file_name()const;\n+};\n+```\n+\n+The `column_count` template parameter indicates how many columns you want to read from the CSV file. This must not necessarily coincide with the actual number of columns in the file. The three policies govern various aspects of the parsing.\n+\n+The trim policy indicates what characters should be ignored at the begin and the end of every column. The default ignores spaces and tabs. This makes sure that\n+\n+```\n+a,b,c\n+1,2,3\n+```\n+\n+is interpreted in the same way as\n+\n+```\n+  a, b,   c\n+1  , 2,   3\n+```\n+\n+The trim_chars can take any number of template parameters. For example `trim_chars<' ', '\\t', '_'> `is also valid. If no character should be trimmed use `trim_chars<>`.\n+\n+The quote policy indicates how string should be escaped. It also specifies the column separator. The predefined policies are:\n+\n+  * `no_quote_escape<sep>` : Strings are not escaped. \"`sep`\" is used as column separator.\n+  * `double_quote_escape<sep, quote>` : Strings are escaped using quotes. Quotes are escaped using two consecutive quotes. \"`sep`\" is used as column separator and \"`quote`\" as quoting character.\n+\n+**Important**: When combining trimming and quoting the rows are first trimmed and then unquoted. A consequence is that spaces inside the quotes will be conserved. If you want to get rid of spaces inside the quotes, you need to remove them yourself.\n+\n+**Important**: Quoting can be quite expensive. Disable it if you do not need it.\n+\n+The overflow policy indicates what should be done if the integers in the input are too large to fit into the variables. There following policies are predefined:\n+\n+  * `throw_on_overflow` : Throw an `error::integer_overflow` or `error::integer_underflow` exception.\n+  * `ignore_overflow` : Do nothing and let the overflow happen.\n+  * `set_to_max_on_overflow` : Set the value to `numeric_limits<...>::max()` (or to the min-pendant).\n+\n+The comment policy allows to skip lines based on some criteria. Valid predefined policies are:\n+\n+  * `no_comment` : Do not ignore any line.\n+  * `empty_line_comment` : Ignore all lines that are empty or only contains spaces and tabs. \n+  * `single_line_comment<com1, com2, ...>` : Ignore all lines that start with com1 or com2 or ... as the first character. There may not be any space between the beginning of the line and the comment character. \n+  * `single_and_empty_line_comment<com1, com2, ...>` : Ignore all empty lines and single line comments.\n+\n+Examples:\n+\n+  * `CSVReader<4, trim_chars<' '>, double_quote_escape<',','\\\"'> >` reads 4 columns from a normal CSV file with string escaping enabled.\n+  * `CSVReader<3, trim_chars<' '>, no_quote_escape<'\\t'>, single_line_comment<'#'> >` reads 3 columns from a tab separated file with string escaping disabled. Lines starting with a # are ignored.\n+\n+The constructors and the file location functions are exactly the same as for `LineReader`. See its documentation for details.\n+\n+There are three methods that deal with headers. The `read_header` methods reads a line from the file and rearranges the columns to match that order. It also checks whether all necessary columns are present. The `set_header` method does *not* read any input. Use it if the file does not have any header. Obviously it is impossible to rearrange columns or check for their availability when using it. The order in the file and in the program must match when using `set_header`. The `has_column` method checks whether a column is present in the file. The first argument of `read_header` is a bitfield that determines how the function should react to column mismatches. The default behavior is to throw an `error::extra_column_in_header` exception if the file contains more columns than expected and an `error::missing_column_in_header` when there are not enough. This behavior can be altered using the following flags.\n+\n+  * `ignore_no_column`: The default behavior, no flags are set\n+  * `ignore_extra_column`: If a column with a name is in the file but not in the argument list, then it is silently ignored.\n+  * `ignore_missing_column`: If a column with a name is not in the file but is in the argument list, then `read_row` will not modify the corresponding variable. \n+\n+When using `ignore_column_missing` it is a good idea to initialize the variables passed to `read_row` with a default value, for example:\n+\n+```cpp\n+// The file only contains column \"a\"\n+CSVReader<2>in(...);\n+in.read_header(ignore_missing_column, \"a\", \"b\");\n+int a,b = 42;\n+while(in.read_row(a,b)){\n+  // a contains the value from the file\n+  // b is left unchanged by read_row, i.e., it is 42\n+}\n+```\n+\n+If only some columns are optional or their default value depends on other columns you have to use `has_column`, for example:\n+\n+```cpp\n+// The file only contains the columns \"a\" and \"b\"\n+CSVReader<2>in(...);\n+in.read_header(ignore_missing_column, \"a\", \"b\", \"sum\");\n+if(!in.has_column(\"a\") || !in.has_column(\"b\"))\n+  throw my_neat_error_class();\n+bool has_sum = in.has_column(\"sum\");\n+int a,b,sum;\n+while(in.read_row(a,b,sum)){\n+  if(!has_sum)\n+    sum = a+b;\n+}\n+```\n+\n+**Important**: Do not call `has_column` from within the read-loop. It would work correctly but significantly slowdown processing.\n+\n+If two columns have the same name an error::duplicated_column_in_header exception is thrown. If `read_header` is called but the file is empty a `error::header_missing` exception is thrown.\n+\n+The `next_line` functions reads a line without parsing it. It works analogous to `LineReader::next_line`. This can be used to skip broken lines in a CSV file. However, in nearly all applications you will want to use the `read_row` function.\n+\n+The `read_row` function reads a line, splits it into the columns and arranges them correctly. It trims the entries and unescapes them. If requested the content is interpreted as integer or as floating point. The variables passed to read_row may be of the following types.\n+\n+  * builtin signed integer: These are `signed char`, `short`, `int`, `long` and `long long`. The input must be encoded as a base 10 ASCII number optionally preceded by a + or -. The function detects whether the integer is too large would overflow (or underflow) and behaves as indicated by overflow_policy.\n+  * builtin unsigned integer: Just as the signed counterparts except that a leading + or - is not allowed.\n+  * builtin floating point: These are `float`, `double` and `long double`. The input may have a leading + or -. The number must be base 10 encoded. The decimal point may either be a dot or a comma. (Note that a comma will only work if it is not also used as column separator or the number is escaped.) A base 10 exponent may be specified using the \"1e10\" syntax. The \"e\" may be lower- or uppercase. Examples for valid floating points are \"1\", \"-42.42\" and \"+123.456E789\". The input is rounded to the next floating point or infinity if it is too large or small.\n+  * `char`: The column content must be a single character.\n+  * `std::string`: The column content is assigned to the string. The std::string is filled with the trimmed and unescaped version.\n+  * `char*`: A pointer directly into the buffer. The string is trimmed and unescaped and null terminated. This pointer stays valid until read_row is called again or the CSVReader is destroyed. Use this for user defined types. \n+\n+Note that there is no inherent overhead to using `char*` and then interpreting it compared to using one of the parsers directly build into `CSVReader`. The builtin number parsers are pure convenience. If you need a slightly different syntax then use `char*` and do the parsing yourself.\n+\n+## FAQ\n+\n+Q: The library is throwing a std::system_error with code -1. How to get it to work?\n+\n+A: Your compiler's std::thread implementation is broken. Define CSV\\_IO\\_NO\\_THREAD to disable threading support.\n+\n+\n+Q: My values are not just ints or strings. I want to parse my customized type. Is this possible?\n+\n+A: Read a `char*` and parse the string. At first this seems expensive but it is not as the pointer you get points directly into the memory buffer. In fact there is no inherent reason why a custom int-parser realized this way must be any slower than the int-parser build into the library. By reading a `char*` the library takes care of column reordering and quote escaping and leaves the actual parsing to you. Note that using a std::string is slower as it involves a memory copy.\n+\n+\n+Q: I get lots of compiler errors when compiling the header! Please fix it. :(\n+\n+A: Have you enabled the C++11 mode of your compiler? If you use GCC you have to add -std=c++0x to the commandline. If this does not resolve the problem, then please open a ticket.\n+\n+\n+Q: The library crashes when parsing large files! Please fix it. :(\n+\n+A: When using GCC have you linked against -lpthread? Read the installation section for details on how to do this. If this does not resolve the issue then please open a ticket. (The reason why it only crashes only on large files is that the first chuck is read synchronous and if the whole file fits into this chuck then no asynchronous call is performed.) Alternatively you can define CSV\\_IO\\_NO\\_THREAD.\n+\n+\n+Q: Does the library support UTF?\n+\n+A: The library has basic UTF-8 support, or to be more precise it does not break when passing UTF-8 strings through it. If you read a `char*` then you get a pointer to the UTF-8 string. You will have to decode the string on your own. The separator, quoting, and commenting characters used by the library can only be ASCII characters."
      },
      {
        "sha": "2fcc738fa1376479358cb7a777c0e0bb373ba031",
        "filename": "csv.h",
        "status": "added",
        "additions": 1249,
        "deletions": 0,
        "changes": 1249,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54ffc57af91917e7fafd9a24e1fcb38a42fee36c/csv.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54ffc57af91917e7fafd9a24e1fcb38a42fee36c/csv.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/csv.h?ref=54ffc57af91917e7fafd9a24e1fcb38a42fee36c",
        "patch": "@@ -0,0 +1,1249 @@\n+// Copyright: (2012-2015) Ben Strasser <code@ben-strasser.net>\n+// License: BSD-3\n+//\n+// All rights reserved.\n+//\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are met:\n+//\n+// 1. Redistributions of source code must retain the above copyright notice,\n+//    this list of conditions and the following disclaimer.\n+//\n+//2. Redistributions in binary form must reproduce the above copyright notice,\n+//   this list of conditions and the following disclaimer in the documentation\n+//   and/or other materials provided with the distribution.\n+//\n+//3. Neither the name of the copyright holder nor the names of its contributors\n+//   may be used to endorse or promote products derived from this software\n+//   without specific prior written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+// POSSIBILITY OF SUCH DAMAGE.\n+\n+#ifndef CSV_H\n+#define CSV_H\n+\n+#include <vector>\n+#include <string>\n+#include <cstring>\n+#include <algorithm>\n+#include <utility>\n+#include <cstdio>\n+#include <exception>\n+#ifndef CSV_IO_NO_THREAD\n+#include <mutex>\n+#include <thread>\n+#include <condition_variable>\n+#endif\n+#include <memory>\n+#include <cassert>\n+#include <cerrno>\n+#include <istream>\n+\n+namespace io{\n+        ////////////////////////////////////////////////////////////////////////////\n+        //                                 LineReader                             //\n+        ////////////////////////////////////////////////////////////////////////////\n+\n+        namespace error{\n+                struct base : std::exception{\n+                        virtual void format_error_message()const = 0;                          \n+                       \n+                        const char*what()const throw(){\n+                                format_error_message();\n+                                return error_message_buffer;\n+                        }\n+\n+                        mutable char error_message_buffer[256];\n+                };\n+\n+                const int max_file_name_length = 255;\n+\n+                struct with_file_name{\n+                        with_file_name(){\n+                                std::memset(file_name, 0, max_file_name_length+1);\n+                        }\n+                       \n+                        void set_file_name(const char*file_name){\n+                                std::strncpy(this->file_name, file_name, max_file_name_length);\n+                                this->file_name[max_file_name_length] = '\\0';\n+                        }\n+\n+                        char file_name[max_file_name_length+1];\n+                };\n+\n+                struct with_file_line{\n+                        with_file_line(){\n+                                file_line = -1;\n+                        }\n+                       \n+                        void set_file_line(int file_line){\n+                                this->file_line = file_line;\n+                        }\n+\n+                        int file_line;\n+                };\n+\n+                struct with_errno{\n+                        with_errno(){\n+                                errno_value = 0;\n+                        }\n+                       \n+                        void set_errno(int errno_value){\n+                                this->errno_value = errno_value;\n+                        }\n+\n+                        int errno_value;\n+                };\n+\n+                struct can_not_open_file :\n+                        base,\n+                        with_file_name,\n+                        with_errno{\n+                        void format_error_message()const{\n+                                if(errno_value != 0)\n+                                        std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n+                                                \"Can not open file \\\"%s\\\" because \\\"%s\\\".\"\n+                                                , file_name, std::strerror(errno_value));\n+                                else\n+                                        std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n+                                                \"Can not open file \\\"%s\\\".\"\n+                                                , file_name);\n+                        }\n+                };\n+\n+                struct line_length_limit_exceeded :\n+                        base,\n+                        with_file_name,\n+                        with_file_line{\n+                        void format_error_message()const{\n+                                std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n+                                        \"Line number %d in file \\\"%s\\\" exceeds the maximum length of 2^24-1.\"\n+                                        , file_line, file_name);\n+                        }\n+                };\n+        }\n+\n+        class ByteSourceBase{\n+        public:\n+                virtual int read(char*buffer, int size)=0;\n+                virtual ~ByteSourceBase(){}\n+        };\n+\n+        namespace detail{\n+\n+                class OwningStdIOByteSourceBase : public ByteSourceBase{\n+                public:\n+                        explicit OwningStdIOByteSourceBase(FILE*file):file(file){\n+                                // Tell the std library that we want to do the buffering ourself.\n+                                std::setvbuf(file, 0, _IONBF, 0);\n+                        }\n+\n+                        int read(char*buffer, int size){\n+                                return std::fread(buffer, 1, size, file);\n+                        }\n+\n+                        ~OwningStdIOByteSourceBase(){\n+                                std::fclose(file);\n+                        }\n+\n+                private:\n+                        FILE*file;\n+                };\n+\n+                class NonOwningIStreamByteSource : public ByteSourceBase{\n+                public:\n+                        explicit NonOwningIStreamByteSource(std::istream&in):in(in){}\n+\n+                        int read(char*buffer, int size){\n+                                in.read(buffer, size);\n+                                return in.gcount();\n+                        }\n+\n+                        ~NonOwningIStreamByteSource(){}\n+\n+                private:\n+                       std::istream&in;\n+                };\n+\n+                class NonOwningStringByteSource : public ByteSourceBase{\n+                public:\n+                        NonOwningStringByteSource(const char*str, long long size):str(str), remaining_byte_count(size){}\n+\n+                        int read(char*buffer, int desired_byte_count){\n+                                int to_copy_byte_count = desired_byte_count;\n+                                if(remaining_byte_count < to_copy_byte_count)\n+                                        to_copy_byte_count = remaining_byte_count;\n+                                std::memcpy(buffer, str, to_copy_byte_count);\n+                                remaining_byte_count -= to_copy_byte_count;\n+                                str += to_copy_byte_count;\n+                                return to_copy_byte_count;\n+                        }\n+\n+                        ~NonOwningStringByteSource(){}\n+\n+                private:\n+                        const char*str;\n+                        long long remaining_byte_count;\n+                };\n+\n+                #ifndef CSV_IO_NO_THREAD\n+                class AsynchronousReader{\n+                public:\n+                        void init(std::unique_ptr<ByteSourceBase>arg_byte_source){\n+                                std::unique_lock<std::mutex>guard(lock);\n+                                byte_source = std::move(arg_byte_source);\n+                                desired_byte_count = -1;\n+                                termination_requested = false;\n+                                worker = std::thread(\n+                                        [&]{\n+                                                std::unique_lock<std::mutex>guard(lock);\n+                                                try{\n+                                                        for(;;){\n+                                                                read_requested_condition.wait(\n+                                                                        guard, \n+                                                                        [&]{\n+                                                                                return desired_byte_count != -1 || termination_requested;\n+                                                                        }\n+                                                                );\n+                                                                if(termination_requested)\n+                                                                        return;\n+\n+                                                                read_byte_count = byte_source->read(buffer, desired_byte_count);\n+                                                                desired_byte_count = -1;\n+                                                                if(read_byte_count == 0)\n+                                                                        break;\n+                                                                read_finished_condition.notify_one();\n+                                                        }\n+                                                }catch(...){\n+                                                        read_error = std::current_exception();\n+                                                }\n+                                                read_finished_condition.notify_one();\n+                                        }\n+                                );\n+                        }\n+\n+                        bool is_valid()const{\n+                                return byte_source != nullptr;\n+                        }\n+\n+                        void start_read(char*arg_buffer, int arg_desired_byte_count){\n+                                std::unique_lock<std::mutex>guard(lock);\n+                                buffer = arg_buffer;\n+                                desired_byte_count = arg_desired_byte_count;\n+                                read_byte_count = -1;\n+                                read_requested_condition.notify_one();\n+                        }\n+\n+                        int finish_read(){\n+                                std::unique_lock<std::mutex>guard(lock);\n+                                read_finished_condition.wait(\n+                                        guard, \n+                                        [&]{\n+                                                return read_byte_count != -1 || read_error;\n+                                        }\n+                                );\n+                                if(read_error)\n+                                        std::rethrow_exception(read_error);\n+                                else\n+                                        return read_byte_count;\n+                        }\n+\n+                        ~AsynchronousReader(){\n+                                if(byte_source != nullptr){\n+                                        {\n+                                                std::unique_lock<std::mutex>guard(lock);\n+                                                termination_requested = true;\n+                                        }\n+                                        read_requested_condition.notify_one();\n+                                        worker.join();\n+                                }\n+                        }\n+\n+                private:           \n+                        std::unique_ptr<ByteSourceBase>byte_source;\n+\n+                        std::thread worker;\n+\n+                        bool termination_requested;\n+                        std::exception_ptr read_error;\n+                        char*buffer;\n+                        int desired_byte_count;\n+                        int read_byte_count;\n+\n+                        std::mutex lock;\n+                        std::condition_variable read_finished_condition;\n+                        std::condition_variable read_requested_condition;  \n+                };\n+                #endif\n+\n+                class SynchronousReader{\n+                public:\n+                        void init(std::unique_ptr<ByteSourceBase>arg_byte_source){\n+                                byte_source = std::move(arg_byte_source);\n+                        }\n+\n+                        bool is_valid()const{\n+                                return byte_source != nullptr;\n+                        }\n+\n+                        void start_read(char*arg_buffer, int arg_desired_byte_count){\n+                                buffer = arg_buffer;\n+                                desired_byte_count = arg_desired_byte_count;\n+                        }\n+\n+                        int finish_read(){\n+                                return byte_source->read(buffer, desired_byte_count);\n+                        }\n+                private:\n+                        std::unique_ptr<ByteSourceBase>byte_source;\n+                        char*buffer;\n+                        int desired_byte_count;\n+                };\n+        }\n+\n+        class LineReader{\n+        private:\n+                static const int block_len = 1<<24;\n+                std::unique_ptr<char[]>buffer; // must be constructed before (and thus destructed after) the reader!\n+                #ifdef CSV_IO_NO_THREAD\n+                detail::SynchronousReader reader;\n+                #else\n+                detail::AsynchronousReader reader;\n+                #endif\n+                int data_begin;\n+                int data_end;\n+\n+                char file_name[error::max_file_name_length+1];\n+                unsigned file_line;\n+\n+                static std::unique_ptr<ByteSourceBase> open_file(const char*file_name){\n+                        // We open the file in binary mode as it makes no difference under *nix\n+                        // and under Windows we handle \\r\\n newlines ourself.\n+                        FILE*file = std::fopen(file_name, \"rb\");\n+                        if(file == 0){\n+                                int x = errno; // store errno as soon as possible, doing it after constructor call can fail.\n+                                error::can_not_open_file err;\n+                                err.set_errno(x);\n+                                err.set_file_name(file_name);\n+                                throw err;\n+                        }\n+                        return std::unique_ptr<ByteSourceBase>(new detail::OwningStdIOByteSourceBase(file));\n+                }\n+\n+                void init(std::unique_ptr<ByteSourceBase>byte_source){\n+                        file_line = 0;\n+\n+                        buffer = std::unique_ptr<char[]>(new char[3*block_len]);\n+                        data_begin = 0;\n+                        data_end = byte_source->read(buffer.get(), 2*block_len);\n+\n+                        // Ignore UTF-8 BOM\n+                        if(data_end >= 3 && buffer[0] == '\\xEF' && buffer[1] == '\\xBB' && buffer[2] == '\\xBF')\n+                                data_begin = 3;\n+\n+                        if(data_end == 2*block_len){\n+                                reader.init(std::move(byte_source));\n+                                reader.start_read(buffer.get() + 2*block_len, block_len);\n+                        }\n+                }\n+\n+        public:\n+                LineReader() = delete;\n+                LineReader(const LineReader&) = delete;\n+                LineReader&operator=(const LineReader&) = delete;\n+\n+                explicit LineReader(const char*file_name){\n+                        set_file_name(file_name);\n+                        init(open_file(file_name));\n+                }\n+\n+                explicit LineReader(const std::string&file_name){\n+                        set_file_name(file_name.c_str());\n+                        init(open_file(file_name.c_str()));\n+                }\n+\n+                LineReader(const char*file_name, std::unique_ptr<ByteSourceBase>byte_source){\n+                        set_file_name(file_name);\n+                        init(std::move(byte_source));\n+                }\n+\n+                LineReader(const std::string&file_name, std::unique_ptr<ByteSourceBase>byte_source){\n+                        set_file_name(file_name.c_str());\n+                        init(std::move(byte_source));\n+                }\n+\n+                LineReader(const char*file_name, const char*data_begin, const char*data_end){\n+                        set_file_name(file_name);\n+                        init(std::unique_ptr<ByteSourceBase>(new detail::NonOwningStringByteSource(data_begin, data_end-data_begin)));\n+                }\n+\n+                LineReader(const std::string&file_name, const char*data_begin, const char*data_end){\n+                        set_file_name(file_name.c_str());\n+                        init(std::unique_ptr<ByteSourceBase>(new detail::NonOwningStringByteSource(data_begin, data_end-data_begin)));\n+                }\n+\n+                LineReader(const char*file_name, FILE*file){\n+                        set_file_name(file_name);\n+                        init(std::unique_ptr<ByteSourceBase>(new detail::OwningStdIOByteSourceBase(file)));\n+                }\n+\n+                LineReader(const std::string&file_name, FILE*file){\n+                        set_file_name(file_name.c_str());\n+                        init(std::unique_ptr<ByteSourceBase>(new detail::OwningStdIOByteSourceBase(file)));\n+                }\n+\n+                LineReader(const char*file_name, std::istream&in){\n+                        set_file_name(file_name);\n+                        init(std::unique_ptr<ByteSourceBase>(new detail::NonOwningIStreamByteSource(in)));\n+                }\n+\n+                LineReader(const std::string&file_name, std::istream&in){\n+                        set_file_name(file_name.c_str());\n+                        init(std::unique_ptr<ByteSourceBase>(new detail::NonOwningIStreamByteSource(in)));\n+                }\n+\n+                void set_file_name(const std::string&file_name){\n+                        set_file_name(file_name.c_str());\n+                }\n+\n+                void set_file_name(const char*file_name){\n+                        strncpy(this->file_name, file_name, error::max_file_name_length);\n+                        this->file_name[error::max_file_name_length] = '\\0';\n+                }\n+\n+                const char*get_truncated_file_name()const{\n+                        return file_name;\n+                }\n+\n+                void set_file_line(unsigned file_line){\n+                        this->file_line = file_line;\n+                }\n+\n+                unsigned get_file_line()const{\n+                        return file_line;\n+                }\n+\n+                char*next_line(){\n+                        if(data_begin == data_end)\n+                                return 0;\n+\n+                        ++file_line;\n+\n+                        assert(data_begin < data_end);\n+                        assert(data_end <= block_len*2);\n+\n+                        if(data_begin >= block_len){\n+                                std::memcpy(buffer.get(), buffer.get()+block_len, block_len);\n+                                data_begin -= block_len;\n+                                data_end -= block_len;\n+                                if(reader.is_valid())\n+                                {\n+                                        data_end += reader.finish_read();\n+                                        std::memcpy(buffer.get()+block_len, buffer.get()+2*block_len, block_len);\n+                                        reader.start_read(buffer.get() + 2*block_len, block_len);\n+                                }\n+                        }\n+\n+                        int line_end = data_begin;\n+                        while(buffer[line_end] != '\\n' && line_end != data_end){\n+                                ++line_end;\n+                        }\n+\n+                        if(line_end - data_begin + 1 > block_len){\n+                                error::line_length_limit_exceeded err;\n+                                err.set_file_name(file_name);\n+                                err.set_file_line(file_line);\n+                                throw err;\n+                        }\n+\n+                        if(buffer[line_end] == '\\n'){\n+                                buffer[line_end] = '\\0';\n+                        }else{\n+                                // some files are missing the newline at the end of the\n+                                // last line\n+                                ++data_end;\n+                                buffer[line_end] = '\\0';\n+                        }\n+\n+                        // handle windows \\r\\n-line breaks\n+                        if(line_end != data_begin && buffer[line_end-1] == '\\r')\n+                                buffer[line_end-1] = '\\0';\n+\n+                        char*ret = buffer.get() + data_begin;\n+                        data_begin = line_end+1;\n+                        return ret;\n+                }\n+        };\n+\n+\n+        ////////////////////////////////////////////////////////////////////////////\n+        //                                 CSV                                    //\n+        ////////////////////////////////////////////////////////////////////////////\n+\n+        namespace error{\n+                const int max_column_name_length = 63;\n+                struct with_column_name{\n+                        with_column_name(){\n+                                std::memset(column_name, 0, max_column_name_length+1);\n+                        }\n+                       \n+                        void set_column_name(const char*column_name){\n+                                std::strncpy(this->column_name, column_name, max_column_name_length);\n+                                this->column_name[max_column_name_length] = '\\0';\n+                        }\n+\n+                        char column_name[max_column_name_length+1];\n+                };\n+\n+\n+                const int max_column_content_length = 63;\n+\n+                struct with_column_content{\n+                        with_column_content(){\n+                                std::memset(column_content, 0, max_column_content_length+1);\n+                        }\n+                       \n+                        void set_column_content(const char*column_content){\n+                                std::strncpy(this->column_content, column_content, max_column_content_length);\n+                                this->column_content[max_column_content_length] = '\\0';\n+                        }\n+\n+                        char column_content[max_column_content_length+1];\n+                };\n+\n+\n+                struct extra_column_in_header :\n+                        base,\n+                        with_file_name,\n+                        with_column_name{\n+                        void format_error_message()const{\n+                                std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n+                                        \"Extra column \\\"%s\\\" in header of file \\\"%s\\\".\"\n+                                        , column_name, file_name);\n+                        }\n+                };\n+\n+                struct missing_column_in_header :\n+                        base,\n+                        with_file_name,\n+                        with_column_name{\n+                        void format_error_message()const{\n+                                std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n+                                        \"Missing column \\\"%s\\\" in header of file \\\"%s\\\".\"\n+                                        , column_name, file_name);\n+                        }\n+                };\n+\n+                struct duplicated_column_in_header :\n+                        base,\n+                        with_file_name,\n+                        with_column_name{\n+                        void format_error_message()const{\n+                                std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n+                                        \"Duplicated column \\\"%s\\\" in header of file \\\"%s\\\".\"\n+                                        , column_name, file_name);\n+                        }\n+                };\n+\n+                struct header_missing :\n+                        base,\n+                        with_file_name{\n+                        void format_error_message()const{\n+                                std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n+                                        \"Header missing in file \\\"%s\\\".\"\n+                                        , file_name);\n+                        }\n+                };\n+\n+                struct too_few_columns :\n+                        base,\n+                        with_file_name,\n+                        with_file_line{\n+                        void format_error_message()const{\n+                                std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n+                                        \"Too few columns in line %d in file \\\"%s\\\".\"\n+                                        , file_line, file_name);\n+                        }\n+                };\n+\n+                struct too_many_columns :\n+                        base,\n+                        with_file_name,\n+                        with_file_line{\n+                        void format_error_message()const{\n+                                std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n+                                        \"Too many columns in line %d in file \\\"%s\\\".\"\n+                                        , file_line, file_name);\n+                        }\n+                };\n+\n+                struct escaped_string_not_closed :\n+                        base,\n+                        with_file_name,\n+                        with_file_line{\n+                        void format_error_message()const{\n+                                std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n+                                        \"Escaped string was not closed in line %d in file \\\"%s\\\".\"\n+                                        , file_line, file_name);\n+                        }\n+                };\n+\n+                struct integer_must_be_positive :\n+                        base,\n+                        with_file_name,\n+                        with_file_line,\n+                        with_column_name,\n+                        with_column_content{\n+                        void format_error_message()const{\n+                                std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n+                                        \"The integer \\\"%s\\\" must be positive or 0 in column \\\"%s\\\" in file \\\"%s\\\" in line \\\"%d\\\".\"\n+                                        , column_content, column_name, file_name, file_line);\n+                        }\n+                };\n+\n+                struct no_digit :\n+                        base,\n+                        with_file_name,\n+                        with_file_line,\n+                        with_column_name,\n+                        with_column_content{\n+                        void format_error_message()const{\n+                                std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n+                                        \"The integer \\\"%s\\\" contains an invalid digit in column \\\"%s\\\" in file \\\"%s\\\" in line \\\"%d\\\".\"\n+                                        , column_content, column_name, file_name, file_line);\n+                        }\n+                };\n+\n+                struct integer_overflow :\n+                        base,\n+                        with_file_name,\n+                        with_file_line,\n+                        with_column_name,\n+                        with_column_content{\n+                        void format_error_message()const{\n+                                std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n+                                        \"The integer \\\"%s\\\" overflows in column \\\"%s\\\" in file \\\"%s\\\" in line \\\"%d\\\".\"\n+                                        , column_content, column_name, file_name, file_line);\n+                        }\n+                };\n+\n+                struct integer_underflow :\n+                        base,\n+                        with_file_name,\n+                        with_file_line,\n+                        with_column_name,\n+                        with_column_content{\n+                        void format_error_message()const{\n+                                std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n+                                        \"The integer \\\"%s\\\" underflows in column \\\"%s\\\" in file \\\"%s\\\" in line \\\"%d\\\".\"\n+                                        , column_content, column_name, file_name, file_line);\n+                        }\n+                };\n+\n+                struct invalid_single_character :\n+                        base,\n+                        with_file_name,\n+                        with_file_line,\n+                        with_column_name,\n+                        with_column_content{\n+                        void format_error_message()const{\n+                                std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n+                                        \"The content \\\"%s\\\" of column \\\"%s\\\" in file \\\"%s\\\" in line \\\"%d\\\" is not a single character.\"\n+                                        , column_content, column_name, file_name, file_line);\n+                        }\n+                };\n+        }\n+\n+        typedef unsigned ignore_column;\n+        static const ignore_column ignore_no_column = 0;\n+        static const ignore_column ignore_extra_column = 1;\n+        static const ignore_column ignore_missing_column = 2;\n+\n+        template<char ... trim_char_list>\n+        struct trim_chars{\n+        private:\n+                constexpr static bool is_trim_char(char){\n+                        return false;\n+                }\n+       \n+                template<class ...OtherTrimChars>\n+                constexpr static bool is_trim_char(char c, char trim_char, OtherTrimChars...other_trim_chars){\n+                        return c == trim_char || is_trim_char(c, other_trim_chars...);\n+                }\n+\n+        public:\n+                static void trim(char*&str_begin, char*&str_end){\n+                        while(is_trim_char(*str_begin, trim_char_list...) && str_begin != str_end)\n+                                ++str_begin;\n+                        while(is_trim_char(*(str_end-1), trim_char_list...) && str_begin != str_end)\n+                                --str_end;\n+                        *str_end = '\\0';\n+                }\n+        };\n+\n+\n+        struct no_comment{\n+                static bool is_comment(const char*){\n+                        return false;\n+                }\n+        };\n+\n+        template<char ... comment_start_char_list>\n+        struct single_line_comment{\n+        private:\n+                constexpr static bool is_comment_start_char(char){\n+                        return false;\n+                }\n+       \n+                template<class ...OtherCommentStartChars>\n+                constexpr static bool is_comment_start_char(char c, char comment_start_char, OtherCommentStartChars...other_comment_start_chars){\n+                        return c == comment_start_char || is_comment_start_char(c, other_comment_start_chars...);\n+                }\n+\n+        public:\n+\n+                static bool is_comment(const char*line){\n+                        return is_comment_start_char(*line, comment_start_char_list...);\n+                }\n+        };\n+\n+        struct empty_line_comment{\n+                static bool is_comment(const char*line){\n+                        if(*line == '\\0')\n+                                return true;\n+                        while(*line == ' ' || *line == '\\t'){\n+                                ++line;\n+                                if(*line == 0)\n+                                        return true;\n+                        }\n+                        return false;\n+                }\n+        };\n+\n+        template<char ... comment_start_char_list>\n+        struct single_and_empty_line_comment{\n+                static bool is_comment(const char*line){\n+                        return single_line_comment<comment_start_char_list...>::is_comment(line) || empty_line_comment::is_comment(line);\n+                }\n+        };\n+\n+        template<char sep>\n+        struct no_quote_escape{\n+                static const char*find_next_column_end(const char*col_begin){\n+                        while(*col_begin != sep && *col_begin != '\\0')\n+                                ++col_begin;\n+                        return col_begin;\n+                }\n+\n+                static void unescape(char*&, char*&){\n+\n+                }\n+        };\n+\n+        template<char sep, char quote>\n+        struct double_quote_escape{\n+                static const char*find_next_column_end(const char*col_begin){\n+                        while(*col_begin != sep && *col_begin != '\\0')\n+                                if(*col_begin != quote)\n+                                        ++col_begin;\n+                                else{\n+                                        do{\n+                                                ++col_begin;\n+                                                while(*col_begin != quote){\n+                                                        if(*col_begin == '\\0')\n+                                                                throw error::escaped_string_not_closed();\n+                                                        ++col_begin;\n+                                                }\n+                                                ++col_begin;\n+                                        }while(*col_begin == quote);\n+                                }      \n+                        return col_begin;      \n+                }\n+\n+                static void unescape(char*&col_begin, char*&col_end){\n+                        if(col_end - col_begin >= 2){\n+                                if(*col_begin == quote && *(col_end-1) == quote){\n+                                        ++col_begin;\n+                                        --col_end;\n+                                        char*out = col_begin;\n+                                        for(char*in = col_begin; in!=col_end; ++in){\n+                                                if(*in == quote && (in+1) != col_end && *(in+1) == quote){\n+                                                         ++in;\n+                                                }\n+                                                *out = *in;\n+                                                ++out;\n+                                        }\n+                                        col_end = out;\n+                                        *col_end = '\\0';\n+                                }\n+                        }\n+                       \n+                }\n+        };\n+\n+        struct throw_on_overflow{\n+                template<class T>\n+                static void on_overflow(T&){\n+                        throw error::integer_overflow();\n+                }\n+               \n+                template<class T>\n+                static void on_underflow(T&){\n+                        throw error::integer_underflow();\n+                }\n+        };\n+\n+        struct ignore_overflow{\n+                template<class T>\n+                static void on_overflow(T&){}\n+               \n+                template<class T>\n+                static void on_underflow(T&){}\n+        };\n+\n+        struct set_to_max_on_overflow{\n+                template<class T>\n+                static void on_overflow(T&x){\n+                        x = std::numeric_limits<T>::max();\n+                }\n+               \n+                template<class T>\n+                static void on_underflow(T&x){\n+                        x = std::numeric_limits<T>::min();\n+                }\n+        };\n+\n+\n+        namespace detail{\n+                template<class quote_policy>\n+                void chop_next_column(\n+                        char*&line, char*&col_begin, char*&col_end\n+                ){\n+                        assert(line != nullptr);\n+\n+                        col_begin = line;\n+                        // the col_begin + (... - col_begin) removes the constness\n+                        col_end = col_begin + (quote_policy::find_next_column_end(col_begin) - col_begin);\n+                       \n+                        if(*col_end == '\\0'){\n+                                line = nullptr;\n+                        }else{\n+                                *col_end = '\\0';\n+                                line = col_end + 1;    \n+                        }\n+                }\n+\n+                template<class trim_policy, class quote_policy>\n+                void parse_line(\n+                        char*line,\n+                        char**sorted_col,\n+                        const std::vector<int>&col_order\n+                ){\n+                        for(std::size_t i=0; i<col_order.size(); ++i){\n+                                if(line == nullptr)\n+                                        throw ::io::error::too_few_columns();\n+                                char*col_begin, *col_end;\n+                                chop_next_column<quote_policy>(line, col_begin, col_end);\n+\n+                                if(col_order[i] != -1){\n+                                        trim_policy::trim(col_begin, col_end);\n+                                        quote_policy::unescape(col_begin, col_end);\n+                                                               \n+                                        sorted_col[col_order[i]] = col_begin;\n+                                }\n+                        }\n+                        if(line != nullptr)\n+                                throw ::io::error::too_many_columns();\n+                }\n+\n+                template<unsigned column_count, class trim_policy, class quote_policy>\n+                void parse_header_line(\n+                        char*line,\n+                        std::vector<int>&col_order,\n+                        const std::string*col_name,\n+                        ignore_column ignore_policy\n+                ){\n+                        col_order.clear();\n+\n+                        bool found[column_count];\n+                        std::fill(found, found + column_count, false);\n+                        while(line){\n+                                char*col_begin,*col_end;\n+                                chop_next_column<quote_policy>(line, col_begin, col_end);\n+\n+                                trim_policy::trim(col_begin, col_end);\n+                                quote_policy::unescape(col_begin, col_end);\n+                               \n+                                for(unsigned i=0; i<column_count; ++i)\n+                                        if(col_begin == col_name[i]){\n+                                                if(found[i]){\n+                                                        error::duplicated_column_in_header err;\n+                                                        err.set_column_name(col_begin);\n+                                                        throw err;\n+                                                }\n+                                                found[i] = true;\n+                                                col_order.push_back(i);\n+                                                col_begin = 0;\n+                                                break;\n+                                        }\n+                                if(col_begin){\n+                                        if(ignore_policy & ::io::ignore_extra_column)\n+                                                col_order.push_back(-1);\n+                                        else{\n+                                                error::extra_column_in_header err;\n+                                                err.set_column_name(col_begin);\n+                                                throw err;\n+                                        }\n+                                }\n+                        }\n+                        if(!(ignore_policy & ::io::ignore_missing_column)){\n+                                for(unsigned i=0; i<column_count; ++i){\n+                                        if(!found[i]){\n+                                                error::missing_column_in_header err;\n+                                                err.set_column_name(col_name[i].c_str());\n+                                                throw err;\n+                                        }\n+                                }\n+                        }\n+                }\n+\n+                template<class overflow_policy>\n+                void parse(char*col, char &x){\n+                        if(!*col)\n+                                throw error::invalid_single_character();\n+                        x = *col;\n+                        ++col;\n+                        if(*col)\n+                                throw error::invalid_single_character();\n+                }\n+               \n+                template<class overflow_policy>\n+                void parse(char*col, std::string&x){\n+                        x = col;\n+                }\n+\n+                template<class overflow_policy>\n+                void parse(char*col, const char*&x){\n+                        x = col;\n+                }\n+\n+                template<class overflow_policy>\n+                void parse(char*col, char*&x){\n+                        x = col;\n+                }\n+\n+                template<class overflow_policy, class T>\n+                void parse_unsigned_integer(const char*col, T&x){\n+                        x = 0;\n+                        while(*col != '\\0'){\n+                                if('0' <= *col && *col <= '9'){\n+                                        T y = *col - '0';\n+                                        if(x > (std::numeric_limits<T>::max()-y)/10){\n+                                                overflow_policy::on_overflow(x);\n+                                                return;\n+                                        }\n+                                        x = 10*x+y;\n+                                }else\n+                                        throw error::no_digit();\n+                                ++col;\n+                        }\n+                }\n+\n+                template<class overflow_policy>void parse(char*col, unsigned char &x)\n+                        {parse_unsigned_integer<overflow_policy>(col, x);}\n+                template<class overflow_policy>void parse(char*col, unsigned short &x)\n+                        {parse_unsigned_integer<overflow_policy>(col, x);}\n+                template<class overflow_policy>void parse(char*col, unsigned int &x)\n+                        {parse_unsigned_integer<overflow_policy>(col, x);}\n+                template<class overflow_policy>void parse(char*col, unsigned long &x)\n+                        {parse_unsigned_integer<overflow_policy>(col, x);}\n+                template<class overflow_policy>void parse(char*col, unsigned long long &x)\n+                        {parse_unsigned_integer<overflow_policy>(col, x);}\n+               \n+                template<class overflow_policy, class T>\n+                void parse_signed_integer(const char*col, T&x){\n+                        if(*col == '-'){\n+                                ++col;\n+\n+                                x = 0;\n+                                while(*col != '\\0'){\n+                                        if('0' <= *col && *col <= '9'){\n+                                                T y = *col - '0';\n+                                                if(x < (std::numeric_limits<T>::min()+y)/10){\n+                                                        overflow_policy::on_underflow(x);\n+                                                        return;\n+                                                }\n+                                                x = 10*x-y;\n+                                        }else\n+                                                throw error::no_digit();\n+                                        ++col;\n+                                }\n+                                return;\n+                        }else if(*col == '+')\n+                                ++col;\n+                        parse_unsigned_integer<overflow_policy>(col, x);\n+                }      \n+\n+                template<class overflow_policy>void parse(char*col, signed char &x)\n+                        {parse_signed_integer<overflow_policy>(col, x);}\n+                template<class overflow_policy>void parse(char*col, signed short &x)\n+                        {parse_signed_integer<overflow_policy>(col, x);}\n+                template<class overflow_policy>void parse(char*col, signed int &x)\n+                        {parse_signed_integer<overflow_policy>(col, x);}\n+                template<class overflow_policy>void parse(char*col, signed long &x)\n+                        {parse_signed_integer<overflow_policy>(col, x);}\n+                template<class overflow_policy>void parse(char*col, signed long long &x)\n+                        {parse_signed_integer<overflow_policy>(col, x);}\n+\n+                template<class T>\n+                void parse_float(const char*col, T&x){\n+                        bool is_neg = false;\n+                        if(*col == '-'){\n+                                is_neg = true;\n+                                ++col;\n+                        }else if(*col == '+')\n+                                ++col;\n+\n+                        x = 0;\n+                        while('0' <= *col && *col <= '9'){\n+                                int y = *col - '0';\n+                                x *= 10;\n+                                x += y;\n+                                ++col;\n+                        }\n+                       \n+                        if(*col == '.'|| *col == ','){\n+                                ++col;\n+                                T pos = 1;\n+                                while('0' <= *col && *col <= '9'){\n+                                        pos /= 10;\n+                                        int y = *col - '0';\n+                                        ++col;\n+                                        x += y*pos;\n+                                }\n+                        }\n+\n+                        if(*col == 'e' || *col == 'E'){\n+                                ++col;\n+                                int e;\n+\n+                                parse_signed_integer<set_to_max_on_overflow>(col, e);\n+                               \n+                                if(e != 0){\n+                                        T base;\n+                                        if(e < 0){\n+                                                base = 0.1;\n+                                                e = -e;\n+                                        }else{\n+                                                base = 10;\n+                                        }\n+       \n+                                        while(e != 1){\n+                                                if((e & 1) == 0){\n+                                                        base = base*base;\n+                                                        e >>= 1;\n+                                                }else{\n+                                                        x *= base;\n+                                                        --e;\n+                                                }\n+                                        }\n+                                        x *= base;\n+                                }\n+                        }else{\n+                                if(*col != '\\0')\n+                                        throw error::no_digit();\n+                        }\n+\n+                        if(is_neg)\n+                                x = -x;\n+                }\n+\n+                template<class overflow_policy> void parse(char*col, float&x) { parse_float(col, x); }\n+                template<class overflow_policy> void parse(char*col, double&x) { parse_float(col, x); }\n+                template<class overflow_policy> void parse(char*col, long double&x) { parse_float(col, x); }\n+\n+                template<class overflow_policy, class T>\n+                void parse(char*col, T&x){\n+                        // GCC evalutes \"false\" when reading the template and\n+                        // \"sizeof(T)!=sizeof(T)\" only when instantiating it. This is why\n+                        // this strange construct is used.\n+                        static_assert(sizeof(T)!=sizeof(T),\n+                                \"Can not parse this type. Only buildin integrals, floats, char, char*, const char* and std::string are supported\");\n+                }\n+\n+        }\n+\n+        template<unsigned column_count,\n+                class trim_policy = trim_chars<' ', '\\t'>,\n+                class quote_policy = no_quote_escape<','>,\n+                class overflow_policy = throw_on_overflow,\n+                class comment_policy = no_comment\n+        >\n+        class CSVReader{\n+        private:\n+                LineReader in;\n+\n+                char*(row[column_count]);\n+                std::string column_names[column_count];\n+\n+                std::vector<int>col_order;\n+\n+                template<class ...ColNames>\n+                void set_column_names(std::string s, ColNames...cols){\n+                        column_names[column_count-sizeof...(ColNames)-1] = std::move(s);\n+                        set_column_names(std::forward<ColNames>(cols)...);\n+                }\n+\n+                void set_column_names(){}\n+\n+\n+        public:\n+                CSVReader() = delete;\n+                CSVReader(const CSVReader&) = delete;\n+                CSVReader&operator=(const CSVReader&);\n+\n+                template<class ...Args>\n+                explicit CSVReader(Args&&...args):in(std::forward<Args>(args)...){\n+                        std::fill(row, row+column_count, nullptr);\n+                        col_order.resize(column_count);\n+                        for(unsigned i=0; i<column_count; ++i)\n+                                col_order[i] = i;\n+                        for(unsigned i=1; i<=column_count; ++i)\n+                                column_names[i-1] = \"col\"+std::to_string(i);\n+                }\n+\n+\t\tchar*next_line(){\n+\t\t\treturn in.next_line();\n+\t\t}\n+\n+                template<class ...ColNames>\n+                void read_header(ignore_column ignore_policy, ColNames...cols){\n+                        static_assert(sizeof...(ColNames)>=column_count, \"not enough column names specified\");\n+                        static_assert(sizeof...(ColNames)<=column_count, \"too many column names specified\");\n+                        try{\n+                                set_column_names(std::forward<ColNames>(cols)...);\n+\n+                                char*line;\n+                                do{\n+                                        line = in.next_line();\n+                                        if(!line)\n+                                                throw error::header_missing();\n+                                }while(comment_policy::is_comment(line));\n+\n+                                detail::parse_header_line\n+                                        <column_count, trim_policy, quote_policy>\n+                                        (line, col_order, column_names, ignore_policy);\n+                        }catch(error::with_file_name&err){\n+                                err.set_file_name(in.get_truncated_file_name());\n+                                throw;\n+                        }\n+                }\n+\n+                template<class ...ColNames>\n+                void set_header(ColNames...cols){\n+                        static_assert(sizeof...(ColNames)>=column_count,\n+                                \"not enough column names specified\");\n+                        static_assert(sizeof...(ColNames)<=column_count,\n+                                \"too many column names specified\");\n+                        set_column_names(std::forward<ColNames>(cols)...);\n+                        std::fill(row, row+column_count, nullptr);\n+                        col_order.resize(column_count);\n+                        for(unsigned i=0; i<column_count; ++i)\n+                                col_order[i] = i;\n+                }\n+\n+                bool has_column(const std::string&name) const {\n+                        return col_order.end() != std::find(\n+                                col_order.begin(), col_order.end(),\n+                                        std::find(std::begin(column_names), std::end(column_names), name)\n+                                - std::begin(column_names));\n+                }\n+\n+                void set_file_name(const std::string&file_name){\n+                        in.set_file_name(file_name);\n+                }\n+\n+                void set_file_name(const char*file_name){\n+                        in.set_file_name(file_name);\n+                }\n+\n+                const char*get_truncated_file_name()const{\n+                        return in.get_truncated_file_name();\n+                }\n+\n+                void set_file_line(unsigned file_line){\n+                        in.set_file_line(file_line);\n+                }\n+\n+                unsigned get_file_line()const{\n+                        return in.get_file_line();\n+                }\n+\n+        private:\n+                void parse_helper(std::size_t){}\n+\n+                template<class T, class ...ColType>\n+                void parse_helper(std::size_t r, T&t, ColType&...cols){                        \n+                        if(row[r]){\n+                                try{\n+                                        try{\n+                                                ::io::detail::parse<overflow_policy>(row[r], t);\n+                                        }catch(error::with_column_content&err){\n+                                                err.set_column_content(row[r]);\n+                                                throw;\n+                                        }\n+                                }catch(error::with_column_name&err){\n+                                        err.set_column_name(column_names[r].c_str());\n+                                        throw;\n+                                }\n+                        }\n+                        parse_helper(r+1, cols...);\n+                }\n+\n+       \n+        public:\n+                template<class ...ColType>\n+                bool read_row(ColType& ...cols){\n+                        static_assert(sizeof...(ColType)>=column_count,\n+                                \"not enough columns specified\");\n+                        static_assert(sizeof...(ColType)<=column_count,\n+                                \"too many columns specified\");\n+                        try{\n+                                try{\n+       \n+                                        char*line;\n+                                        do{\n+                                                line = in.next_line();\n+                                                if(!line)\n+                                                        return false;\n+                                        }while(comment_policy::is_comment(line));\n+                                       \n+                                        detail::parse_line<trim_policy, quote_policy>\n+                                                (line, row, col_order);\n+               \n+                                        parse_helper(0, cols...);\n+                                }catch(error::with_file_name&err){\n+                                        err.set_file_name(in.get_truncated_file_name());\n+                                        throw;\n+                                }\n+                        }catch(error::with_file_line&err){\n+                                err.set_file_line(in.get_file_line());\n+                                throw;\n+                        }\n+\n+                        return true;\n+                }\n+        };\n+}\n+#endif\n+"
      }
    ]
  },
  {
    "sha": "dfe8ce957f51b4407a7b2362de4c25d838500993",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkZmU4Y2U5NTdmNTFiNDQwN2E3YjIzNjJkZTRjMjVkODM4NTAwOTkz",
    "commit": {
      "author": {
        "name": "sanch0panza",
        "email": "sanch0panza@protonmail.com",
        "date": "2017-05-25T09:45:32Z"
      },
      "committer": {
        "name": "sanch0panza",
        "email": "sanch0panza@protonmail.com",
        "date": "2017-05-25T09:51:03Z"
      },
      "message": "Subtree import of Ben Strasser's fast CSV parser into src/fast-cpp-csv-parser\n\nMerge commit '54ffc57af91917e7fafd9a24e1fcb38a42fee36c' as 'src/fast-cpp-csv-parser'\n\nCommand used:\ngit subtree add --squash --prefix src/fast-cpp-csv-parser https://github.com/ben-strasser/fast-cpp-csv-parser master",
      "tree": {
        "sha": "e8381cc6cb18d7a26bbb6ee1c6a87fca857eee28",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e8381cc6cb18d7a26bbb6ee1c6a87fca857eee28"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dfe8ce957f51b4407a7b2362de4c25d838500993",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dfe8ce957f51b4407a7b2362de4c25d838500993",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/dfe8ce957f51b4407a7b2362de4c25d838500993",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dfe8ce957f51b4407a7b2362de4c25d838500993/comments",
    "author": {
      "login": "sanch0panza",
      "id": 26766668,
      "node_id": "MDQ6VXNlcjI2NzY2NjY4",
      "avatar_url": "https://avatars.githubusercontent.com/u/26766668?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sanch0panza",
      "html_url": "https://github.com/sanch0panza",
      "followers_url": "https://api.github.com/users/sanch0panza/followers",
      "following_url": "https://api.github.com/users/sanch0panza/following{/other_user}",
      "gists_url": "https://api.github.com/users/sanch0panza/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sanch0panza/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sanch0panza/subscriptions",
      "organizations_url": "https://api.github.com/users/sanch0panza/orgs",
      "repos_url": "https://api.github.com/users/sanch0panza/repos",
      "events_url": "https://api.github.com/users/sanch0panza/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sanch0panza/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sanch0panza",
      "id": 26766668,
      "node_id": "MDQ6VXNlcjI2NzY2NjY4",
      "avatar_url": "https://avatars.githubusercontent.com/u/26766668?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sanch0panza",
      "html_url": "https://github.com/sanch0panza",
      "followers_url": "https://api.github.com/users/sanch0panza/followers",
      "following_url": "https://api.github.com/users/sanch0panza/following{/other_user}",
      "gists_url": "https://api.github.com/users/sanch0panza/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sanch0panza/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sanch0panza/subscriptions",
      "organizations_url": "https://api.github.com/users/sanch0panza/orgs",
      "repos_url": "https://api.github.com/users/sanch0panza/repos",
      "events_url": "https://api.github.com/users/sanch0panza/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sanch0panza/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "00e830d3e6c801626aef47212bf0a0e7ffbb4644",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00e830d3e6c801626aef47212bf0a0e7ffbb4644",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/00e830d3e6c801626aef47212bf0a0e7ffbb4644"
      },
      {
        "sha": "54ffc57af91917e7fafd9a24e1fcb38a42fee36c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/54ffc57af91917e7fafd9a24e1fcb38a42fee36c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/54ffc57af91917e7fafd9a24e1fcb38a42fee36c"
      }
    ],
    "stats": {
      "total": 1545,
      "additions": 1545,
      "deletions": 0
    },
    "files": [
      {
        "sha": "da603a96be217c7a8ca2542b351a5a95d3c30c78",
        "filename": "src/fast-cpp-csv-parser/LICENSE",
        "status": "added",
        "additions": 28,
        "deletions": 0,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dfe8ce957f51b4407a7b2362de4c25d838500993/src/fast-cpp-csv-parser/LICENSE",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dfe8ce957f51b4407a7b2362de4c25d838500993/src/fast-cpp-csv-parser/LICENSE",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/fast-cpp-csv-parser/LICENSE?ref=dfe8ce957f51b4407a7b2362de4c25d838500993",
        "patch": "@@ -0,0 +1,28 @@\n+Copyright (c) 2015, ben-strasser\n+All rights reserved.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are met:\n+\n+* Redistributions of source code must retain the above copyright notice, this\n+  list of conditions and the following disclaimer.\n+\n+* Redistributions in binary form must reproduce the above copyright notice,\n+  this list of conditions and the following disclaimer in the documentation\n+  and/or other materials provided with the distribution.\n+\n+* Neither the name of fast-cpp-csv-parser nor the names of its\n+  contributors may be used to endorse or promote products derived from\n+  this software without specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+"
      },
      {
        "sha": "d929341ab1dd920b6e24999074ff67d5dc382df2",
        "filename": "src/fast-cpp-csv-parser/README.md",
        "status": "added",
        "additions": 268,
        "deletions": 0,
        "changes": 268,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dfe8ce957f51b4407a7b2362de4c25d838500993/src/fast-cpp-csv-parser/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dfe8ce957f51b4407a7b2362de4c25d838500993/src/fast-cpp-csv-parser/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/fast-cpp-csv-parser/README.md?ref=dfe8ce957f51b4407a7b2362de4c25d838500993",
        "patch": "@@ -0,0 +1,268 @@\n+# Fast C++ CSV Parser\n+\n+This is a small, easy-to-use and fast header-only library for reading comma separated value (CSV) files. \n+\n+## Features\n+\n+  * Automatically rearranges columns by parsing the header line.\n+  * Disk I/O and CSV-parsing are overlapped using threads for efficiency.\n+  * Parsing features such as escaped strings can be enabled and disabled at compile time using templates. You only pay in speed for the features you actually use.\n+  * Can read multiple GB files in reasonable time.\n+  * Support for custom columns separators (i.e. Tab separated value files are supported), quote escaped strings, automatic space trimming. \n+  * Works with `*`nix and Windows newlines and automatically ignores UTF-8 BOMs.\n+  * Exception classes with enough context to format useful error messages. what() returns error messages ready to be shown to a user. \n+\n+## Getting Started\n+\n+The following small example should contain most of the syntax you need to use the library.\n+\n+```cpp\n+# include \"csv.h\"\n+\n+int main(){\n+  io::CSVReader<3> in(\"ram.csv\");\n+  in.read_header(io::ignore_extra_column, \"vendor\", \"size\", \"speed\");\n+  std::string vendor; int size; double speed;\n+  while(in.read_row(vendor, size, speed)){\n+    // do stuff with the data\n+  }\n+}\n+```\n+\n+## Installation\n+\n+The library only needs a standard conformant C++11 compiler. It has no further dependencies. The library is completely contained inside a single header file and therefore it is sufficient to copy this file to some place on your include path. The library does not have to be explicitly build. \n+\n+Note however, that threads are used and some compiler (for example GCC) require you to link against additional librarie to make it work. With GCC it is important to add -lpthread as the last item when linking, i.e. the order in \n+\n+```\n+g++ -std=c++0x a.o b.o -o prog -lpthread\n+```\n+\n+is important. If you for some reason do not want to use threads you can define CSV_IO_NO_THREAD before including the header.\n+\n+Remember that the library makes use of C++11 features and therefore you have to enable support for it (f.e. add -std=c++0x or -std=gnu++0x). \n+\n+The library was developed and tested with GCC 4.6.1\n+\n+Note that VS2013 is not C++11 compilant and will therefore not work out of the box. See [here](https://code.google.com/p/fast-cpp-csv-parser/issues/detail?id=6) for what needs to be adjusted to make the code work.\n+\n+## Documentation\n+\n+The libary provides two classes: \n+\n+  * `LineReader`: A class to efficiently read large files line by line.\n+  * `CSVReader`: A class that efficiently reads large CSV files.\n+\n+Note that everything is contained in the `io` namespace.\n+\n+### `LineReader`\n+\n+```cpp\n+class LineReader{\n+public:\n+  // Constructors\n+  LineReader(some_string_type file_name);\n+  LineReader(some_string_type file_name, std::FILE*source);\n+  LineReader(some_string_type file_name, std::istream&source);\n+  LineReader(some_string_type file_name, std::unique_ptr<ByteSourceBase>source);\n+\n+  // Reading\n+  char*next_line();\n+\n+  // File Location\n+  void set_file_line(unsigned);\n+  unsigned get_file_line(unsigned)const;\n+  void set_file_name(some_string_type file_name);\n+  const char*get_truncated_file_name()const;\n+};\n+```\n+\n+The constructor takes a file name and optionally a data source. If no data source is provided the function tries to open the file with the given name and throws an `error::can_not_open_file exception` on failure. If a data source is provided then the file name is only used to format error messages. In that case you can essentially put any string there. Using a string that describes the data source results in more informative error messages.\n+\n+`some_string_type` can be a `std::string` or a `char*`. If the data source is a `std::FILE*` then the library will take care of calling `std::fclose`. If it is a `std::istream` then the stream is not closed by the library. For best performance open the streams in binary mode. However using text mode also works. `ByteSourceBase` provides an interface that you can use to implement further data sources. \n+\n+```\n+class ByteSourceBase{\n+public:\n+  virtual int read(char*buffer, int size)=0;\n+  virtual ~ByteSourceBase(){}\n+};\n+```\n+\n+The read function should fill the provided buffer with at most `size` bytes from the data source. It should return the number of bytes actually written to the buffer. If data source has run out of bytes (because for example an end of file was reached) then the function should return 0. If a fatal error occures then you can throw an exception. Note that the function can be called both from the main and the worker thread. However, it is guarenteed that they do not call the function at the same time. \n+\n+Lines are read by calling the `next_line` function. It returns a pointer to a null terminated C-string that contains the line. If the end of file is reached a null pointer is returned. The newline character is not included in the string. You may modify the string as long as you do not write past the null terminator. The string stays valid until the destructor is called or until next_line is called again. Windows and `*`nix newlines are handled transparently. UTF-8 BOMs are automatically ignored and missing newlines at the end of the file are no problem.\n+\n+**Important:** There is a limit of 2^24-1 characters per line. If this limit is exceeded a `error::line_length_limit_exceeded` exception is thrown.\n+\n+Looping over all the lines in a file can be done in the following way.\n+```cpp\n+LineReader in(...);\n+while(char*line = in.next_line()){\n+  ...\n+}\n+```\n+\n+The remaining functions are mainly used used to format error messages. The file line indicates the current position in the file, i.e., after the first `next_line` call it is 1 and after the second 2. Before the first call it is 0. The file name is truncated as internally C-strings are used to avoid `std::bad_alloc` exceptions during error reporting.\n+\n+**Note:** It is not possible to exchange the line termination character.\n+\n+### `CSVReader`\n+\n+`CSVReader` uses policies. These are classes with only static members to allow core functionality to be exchanged in an efficient way.\n+\n+```cpp\n+template<\n+  unsigned column_count,\n+  class trim_policy = trim_chars<' ', '\\t'>, \n+  class quote_policy = no_quote_escape<','>,\n+  class overflow_policy = throw_on_overflow,\n+  class comment_policy = no_comment\n+>\n+class CSVReader{\n+public:\n+  // Constructors\n+  // same as for LineReader\n+\n+  // Parsing Header\n+  void read_header(ignore_column ignore_policy, some_string_type col_name1, some_string_type col_name2, ...);\n+  void set_header(some_string_type col_name1, some_string_type col_name2, ...);\n+  bool has_column(some_string_type col_name)const;\n+\n+  // Read\n+  char*next_line();\n+  bool read_row(ColType1&col1, ColType2&col2, ...);\n+\n+  // File Location \n+  void set_file_line(unsigned);\n+  unsigned get_file_line()const;\n+  void set_file_name(some_string_type file_name);\n+  const char*get_truncated_file_name()const;\n+};\n+```\n+\n+The `column_count` template parameter indicates how many columns you want to read from the CSV file. This must not necessarily coincide with the actual number of columns in the file. The three policies govern various aspects of the parsing.\n+\n+The trim policy indicates what characters should be ignored at the begin and the end of every column. The default ignores spaces and tabs. This makes sure that\n+\n+```\n+a,b,c\n+1,2,3\n+```\n+\n+is interpreted in the same way as\n+\n+```\n+  a, b,   c\n+1  , 2,   3\n+```\n+\n+The trim_chars can take any number of template parameters. For example `trim_chars<' ', '\\t', '_'> `is also valid. If no character should be trimmed use `trim_chars<>`.\n+\n+The quote policy indicates how string should be escaped. It also specifies the column separator. The predefined policies are:\n+\n+  * `no_quote_escape<sep>` : Strings are not escaped. \"`sep`\" is used as column separator.\n+  * `double_quote_escape<sep, quote>` : Strings are escaped using quotes. Quotes are escaped using two consecutive quotes. \"`sep`\" is used as column separator and \"`quote`\" as quoting character.\n+\n+**Important**: When combining trimming and quoting the rows are first trimmed and then unquoted. A consequence is that spaces inside the quotes will be conserved. If you want to get rid of spaces inside the quotes, you need to remove them yourself.\n+\n+**Important**: Quoting can be quite expensive. Disable it if you do not need it.\n+\n+The overflow policy indicates what should be done if the integers in the input are too large to fit into the variables. There following policies are predefined:\n+\n+  * `throw_on_overflow` : Throw an `error::integer_overflow` or `error::integer_underflow` exception.\n+  * `ignore_overflow` : Do nothing and let the overflow happen.\n+  * `set_to_max_on_overflow` : Set the value to `numeric_limits<...>::max()` (or to the min-pendant).\n+\n+The comment policy allows to skip lines based on some criteria. Valid predefined policies are:\n+\n+  * `no_comment` : Do not ignore any line.\n+  * `empty_line_comment` : Ignore all lines that are empty or only contains spaces and tabs. \n+  * `single_line_comment<com1, com2, ...>` : Ignore all lines that start with com1 or com2 or ... as the first character. There may not be any space between the beginning of the line and the comment character. \n+  * `single_and_empty_line_comment<com1, com2, ...>` : Ignore all empty lines and single line comments.\n+\n+Examples:\n+\n+  * `CSVReader<4, trim_chars<' '>, double_quote_escape<',','\\\"'> >` reads 4 columns from a normal CSV file with string escaping enabled.\n+  * `CSVReader<3, trim_chars<' '>, no_quote_escape<'\\t'>, single_line_comment<'#'> >` reads 3 columns from a tab separated file with string escaping disabled. Lines starting with a # are ignored.\n+\n+The constructors and the file location functions are exactly the same as for `LineReader`. See its documentation for details.\n+\n+There are three methods that deal with headers. The `read_header` methods reads a line from the file and rearranges the columns to match that order. It also checks whether all necessary columns are present. The `set_header` method does *not* read any input. Use it if the file does not have any header. Obviously it is impossible to rearrange columns or check for their availability when using it. The order in the file and in the program must match when using `set_header`. The `has_column` method checks whether a column is present in the file. The first argument of `read_header` is a bitfield that determines how the function should react to column mismatches. The default behavior is to throw an `error::extra_column_in_header` exception if the file contains more columns than expected and an `error::missing_column_in_header` when there are not enough. This behavior can be altered using the following flags.\n+\n+  * `ignore_no_column`: The default behavior, no flags are set\n+  * `ignore_extra_column`: If a column with a name is in the file but not in the argument list, then it is silently ignored.\n+  * `ignore_missing_column`: If a column with a name is not in the file but is in the argument list, then `read_row` will not modify the corresponding variable. \n+\n+When using `ignore_column_missing` it is a good idea to initialize the variables passed to `read_row` with a default value, for example:\n+\n+```cpp\n+// The file only contains column \"a\"\n+CSVReader<2>in(...);\n+in.read_header(ignore_missing_column, \"a\", \"b\");\n+int a,b = 42;\n+while(in.read_row(a,b)){\n+  // a contains the value from the file\n+  // b is left unchanged by read_row, i.e., it is 42\n+}\n+```\n+\n+If only some columns are optional or their default value depends on other columns you have to use `has_column`, for example:\n+\n+```cpp\n+// The file only contains the columns \"a\" and \"b\"\n+CSVReader<2>in(...);\n+in.read_header(ignore_missing_column, \"a\", \"b\", \"sum\");\n+if(!in.has_column(\"a\") || !in.has_column(\"b\"))\n+  throw my_neat_error_class();\n+bool has_sum = in.has_column(\"sum\");\n+int a,b,sum;\n+while(in.read_row(a,b,sum)){\n+  if(!has_sum)\n+    sum = a+b;\n+}\n+```\n+\n+**Important**: Do not call `has_column` from within the read-loop. It would work correctly but significantly slowdown processing.\n+\n+If two columns have the same name an error::duplicated_column_in_header exception is thrown. If `read_header` is called but the file is empty a `error::header_missing` exception is thrown.\n+\n+The `next_line` functions reads a line without parsing it. It works analogous to `LineReader::next_line`. This can be used to skip broken lines in a CSV file. However, in nearly all applications you will want to use the `read_row` function.\n+\n+The `read_row` function reads a line, splits it into the columns and arranges them correctly. It trims the entries and unescapes them. If requested the content is interpreted as integer or as floating point. The variables passed to read_row may be of the following types.\n+\n+  * builtin signed integer: These are `signed char`, `short`, `int`, `long` and `long long`. The input must be encoded as a base 10 ASCII number optionally preceded by a + or -. The function detects whether the integer is too large would overflow (or underflow) and behaves as indicated by overflow_policy.\n+  * builtin unsigned integer: Just as the signed counterparts except that a leading + or - is not allowed.\n+  * builtin floating point: These are `float`, `double` and `long double`. The input may have a leading + or -. The number must be base 10 encoded. The decimal point may either be a dot or a comma. (Note that a comma will only work if it is not also used as column separator or the number is escaped.) A base 10 exponent may be specified using the \"1e10\" syntax. The \"e\" may be lower- or uppercase. Examples for valid floating points are \"1\", \"-42.42\" and \"+123.456E789\". The input is rounded to the next floating point or infinity if it is too large or small.\n+  * `char`: The column content must be a single character.\n+  * `std::string`: The column content is assigned to the string. The std::string is filled with the trimmed and unescaped version.\n+  * `char*`: A pointer directly into the buffer. The string is trimmed and unescaped and null terminated. This pointer stays valid until read_row is called again or the CSVReader is destroyed. Use this for user defined types. \n+\n+Note that there is no inherent overhead to using `char*` and then interpreting it compared to using one of the parsers directly build into `CSVReader`. The builtin number parsers are pure convenience. If you need a slightly different syntax then use `char*` and do the parsing yourself.\n+\n+## FAQ\n+\n+Q: The library is throwing a std::system_error with code -1. How to get it to work?\n+\n+A: Your compiler's std::thread implementation is broken. Define CSV\\_IO\\_NO\\_THREAD to disable threading support.\n+\n+\n+Q: My values are not just ints or strings. I want to parse my customized type. Is this possible?\n+\n+A: Read a `char*` and parse the string. At first this seems expensive but it is not as the pointer you get points directly into the memory buffer. In fact there is no inherent reason why a custom int-parser realized this way must be any slower than the int-parser build into the library. By reading a `char*` the library takes care of column reordering and quote escaping and leaves the actual parsing to you. Note that using a std::string is slower as it involves a memory copy.\n+\n+\n+Q: I get lots of compiler errors when compiling the header! Please fix it. :(\n+\n+A: Have you enabled the C++11 mode of your compiler? If you use GCC you have to add -std=c++0x to the commandline. If this does not resolve the problem, then please open a ticket.\n+\n+\n+Q: The library crashes when parsing large files! Please fix it. :(\n+\n+A: When using GCC have you linked against -lpthread? Read the installation section for details on how to do this. If this does not resolve the issue then please open a ticket. (The reason why it only crashes only on large files is that the first chuck is read synchronous and if the whole file fits into this chuck then no asynchronous call is performed.) Alternatively you can define CSV\\_IO\\_NO\\_THREAD.\n+\n+\n+Q: Does the library support UTF?\n+\n+A: The library has basic UTF-8 support, or to be more precise it does not break when passing UTF-8 strings through it. If you read a `char*` then you get a pointer to the UTF-8 string. You will have to decode the string on your own. The separator, quoting, and commenting characters used by the library can only be ASCII characters."
      },
      {
        "sha": "2fcc738fa1376479358cb7a777c0e0bb373ba031",
        "filename": "src/fast-cpp-csv-parser/csv.h",
        "status": "added",
        "additions": 1249,
        "deletions": 0,
        "changes": 1249,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dfe8ce957f51b4407a7b2362de4c25d838500993/src/fast-cpp-csv-parser/csv.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dfe8ce957f51b4407a7b2362de4c25d838500993/src/fast-cpp-csv-parser/csv.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/fast-cpp-csv-parser/csv.h?ref=dfe8ce957f51b4407a7b2362de4c25d838500993",
        "patch": "@@ -0,0 +1,1249 @@\n+// Copyright: (2012-2015) Ben Strasser <code@ben-strasser.net>\n+// License: BSD-3\n+//\n+// All rights reserved.\n+//\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are met:\n+//\n+// 1. Redistributions of source code must retain the above copyright notice,\n+//    this list of conditions and the following disclaimer.\n+//\n+//2. Redistributions in binary form must reproduce the above copyright notice,\n+//   this list of conditions and the following disclaimer in the documentation\n+//   and/or other materials provided with the distribution.\n+//\n+//3. Neither the name of the copyright holder nor the names of its contributors\n+//   may be used to endorse or promote products derived from this software\n+//   without specific prior written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+// POSSIBILITY OF SUCH DAMAGE.\n+\n+#ifndef CSV_H\n+#define CSV_H\n+\n+#include <vector>\n+#include <string>\n+#include <cstring>\n+#include <algorithm>\n+#include <utility>\n+#include <cstdio>\n+#include <exception>\n+#ifndef CSV_IO_NO_THREAD\n+#include <mutex>\n+#include <thread>\n+#include <condition_variable>\n+#endif\n+#include <memory>\n+#include <cassert>\n+#include <cerrno>\n+#include <istream>\n+\n+namespace io{\n+        ////////////////////////////////////////////////////////////////////////////\n+        //                                 LineReader                             //\n+        ////////////////////////////////////////////////////////////////////////////\n+\n+        namespace error{\n+                struct base : std::exception{\n+                        virtual void format_error_message()const = 0;                          \n+                       \n+                        const char*what()const throw(){\n+                                format_error_message();\n+                                return error_message_buffer;\n+                        }\n+\n+                        mutable char error_message_buffer[256];\n+                };\n+\n+                const int max_file_name_length = 255;\n+\n+                struct with_file_name{\n+                        with_file_name(){\n+                                std::memset(file_name, 0, max_file_name_length+1);\n+                        }\n+                       \n+                        void set_file_name(const char*file_name){\n+                                std::strncpy(this->file_name, file_name, max_file_name_length);\n+                                this->file_name[max_file_name_length] = '\\0';\n+                        }\n+\n+                        char file_name[max_file_name_length+1];\n+                };\n+\n+                struct with_file_line{\n+                        with_file_line(){\n+                                file_line = -1;\n+                        }\n+                       \n+                        void set_file_line(int file_line){\n+                                this->file_line = file_line;\n+                        }\n+\n+                        int file_line;\n+                };\n+\n+                struct with_errno{\n+                        with_errno(){\n+                                errno_value = 0;\n+                        }\n+                       \n+                        void set_errno(int errno_value){\n+                                this->errno_value = errno_value;\n+                        }\n+\n+                        int errno_value;\n+                };\n+\n+                struct can_not_open_file :\n+                        base,\n+                        with_file_name,\n+                        with_errno{\n+                        void format_error_message()const{\n+                                if(errno_value != 0)\n+                                        std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n+                                                \"Can not open file \\\"%s\\\" because \\\"%s\\\".\"\n+                                                , file_name, std::strerror(errno_value));\n+                                else\n+                                        std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n+                                                \"Can not open file \\\"%s\\\".\"\n+                                                , file_name);\n+                        }\n+                };\n+\n+                struct line_length_limit_exceeded :\n+                        base,\n+                        with_file_name,\n+                        with_file_line{\n+                        void format_error_message()const{\n+                                std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n+                                        \"Line number %d in file \\\"%s\\\" exceeds the maximum length of 2^24-1.\"\n+                                        , file_line, file_name);\n+                        }\n+                };\n+        }\n+\n+        class ByteSourceBase{\n+        public:\n+                virtual int read(char*buffer, int size)=0;\n+                virtual ~ByteSourceBase(){}\n+        };\n+\n+        namespace detail{\n+\n+                class OwningStdIOByteSourceBase : public ByteSourceBase{\n+                public:\n+                        explicit OwningStdIOByteSourceBase(FILE*file):file(file){\n+                                // Tell the std library that we want to do the buffering ourself.\n+                                std::setvbuf(file, 0, _IONBF, 0);\n+                        }\n+\n+                        int read(char*buffer, int size){\n+                                return std::fread(buffer, 1, size, file);\n+                        }\n+\n+                        ~OwningStdIOByteSourceBase(){\n+                                std::fclose(file);\n+                        }\n+\n+                private:\n+                        FILE*file;\n+                };\n+\n+                class NonOwningIStreamByteSource : public ByteSourceBase{\n+                public:\n+                        explicit NonOwningIStreamByteSource(std::istream&in):in(in){}\n+\n+                        int read(char*buffer, int size){\n+                                in.read(buffer, size);\n+                                return in.gcount();\n+                        }\n+\n+                        ~NonOwningIStreamByteSource(){}\n+\n+                private:\n+                       std::istream&in;\n+                };\n+\n+                class NonOwningStringByteSource : public ByteSourceBase{\n+                public:\n+                        NonOwningStringByteSource(const char*str, long long size):str(str), remaining_byte_count(size){}\n+\n+                        int read(char*buffer, int desired_byte_count){\n+                                int to_copy_byte_count = desired_byte_count;\n+                                if(remaining_byte_count < to_copy_byte_count)\n+                                        to_copy_byte_count = remaining_byte_count;\n+                                std::memcpy(buffer, str, to_copy_byte_count);\n+                                remaining_byte_count -= to_copy_byte_count;\n+                                str += to_copy_byte_count;\n+                                return to_copy_byte_count;\n+                        }\n+\n+                        ~NonOwningStringByteSource(){}\n+\n+                private:\n+                        const char*str;\n+                        long long remaining_byte_count;\n+                };\n+\n+                #ifndef CSV_IO_NO_THREAD\n+                class AsynchronousReader{\n+                public:\n+                        void init(std::unique_ptr<ByteSourceBase>arg_byte_source){\n+                                std::unique_lock<std::mutex>guard(lock);\n+                                byte_source = std::move(arg_byte_source);\n+                                desired_byte_count = -1;\n+                                termination_requested = false;\n+                                worker = std::thread(\n+                                        [&]{\n+                                                std::unique_lock<std::mutex>guard(lock);\n+                                                try{\n+                                                        for(;;){\n+                                                                read_requested_condition.wait(\n+                                                                        guard, \n+                                                                        [&]{\n+                                                                                return desired_byte_count != -1 || termination_requested;\n+                                                                        }\n+                                                                );\n+                                                                if(termination_requested)\n+                                                                        return;\n+\n+                                                                read_byte_count = byte_source->read(buffer, desired_byte_count);\n+                                                                desired_byte_count = -1;\n+                                                                if(read_byte_count == 0)\n+                                                                        break;\n+                                                                read_finished_condition.notify_one();\n+                                                        }\n+                                                }catch(...){\n+                                                        read_error = std::current_exception();\n+                                                }\n+                                                read_finished_condition.notify_one();\n+                                        }\n+                                );\n+                        }\n+\n+                        bool is_valid()const{\n+                                return byte_source != nullptr;\n+                        }\n+\n+                        void start_read(char*arg_buffer, int arg_desired_byte_count){\n+                                std::unique_lock<std::mutex>guard(lock);\n+                                buffer = arg_buffer;\n+                                desired_byte_count = arg_desired_byte_count;\n+                                read_byte_count = -1;\n+                                read_requested_condition.notify_one();\n+                        }\n+\n+                        int finish_read(){\n+                                std::unique_lock<std::mutex>guard(lock);\n+                                read_finished_condition.wait(\n+                                        guard, \n+                                        [&]{\n+                                                return read_byte_count != -1 || read_error;\n+                                        }\n+                                );\n+                                if(read_error)\n+                                        std::rethrow_exception(read_error);\n+                                else\n+                                        return read_byte_count;\n+                        }\n+\n+                        ~AsynchronousReader(){\n+                                if(byte_source != nullptr){\n+                                        {\n+                                                std::unique_lock<std::mutex>guard(lock);\n+                                                termination_requested = true;\n+                                        }\n+                                        read_requested_condition.notify_one();\n+                                        worker.join();\n+                                }\n+                        }\n+\n+                private:           \n+                        std::unique_ptr<ByteSourceBase>byte_source;\n+\n+                        std::thread worker;\n+\n+                        bool termination_requested;\n+                        std::exception_ptr read_error;\n+                        char*buffer;\n+                        int desired_byte_count;\n+                        int read_byte_count;\n+\n+                        std::mutex lock;\n+                        std::condition_variable read_finished_condition;\n+                        std::condition_variable read_requested_condition;  \n+                };\n+                #endif\n+\n+                class SynchronousReader{\n+                public:\n+                        void init(std::unique_ptr<ByteSourceBase>arg_byte_source){\n+                                byte_source = std::move(arg_byte_source);\n+                        }\n+\n+                        bool is_valid()const{\n+                                return byte_source != nullptr;\n+                        }\n+\n+                        void start_read(char*arg_buffer, int arg_desired_byte_count){\n+                                buffer = arg_buffer;\n+                                desired_byte_count = arg_desired_byte_count;\n+                        }\n+\n+                        int finish_read(){\n+                                return byte_source->read(buffer, desired_byte_count);\n+                        }\n+                private:\n+                        std::unique_ptr<ByteSourceBase>byte_source;\n+                        char*buffer;\n+                        int desired_byte_count;\n+                };\n+        }\n+\n+        class LineReader{\n+        private:\n+                static const int block_len = 1<<24;\n+                std::unique_ptr<char[]>buffer; // must be constructed before (and thus destructed after) the reader!\n+                #ifdef CSV_IO_NO_THREAD\n+                detail::SynchronousReader reader;\n+                #else\n+                detail::AsynchronousReader reader;\n+                #endif\n+                int data_begin;\n+                int data_end;\n+\n+                char file_name[error::max_file_name_length+1];\n+                unsigned file_line;\n+\n+                static std::unique_ptr<ByteSourceBase> open_file(const char*file_name){\n+                        // We open the file in binary mode as it makes no difference under *nix\n+                        // and under Windows we handle \\r\\n newlines ourself.\n+                        FILE*file = std::fopen(file_name, \"rb\");\n+                        if(file == 0){\n+                                int x = errno; // store errno as soon as possible, doing it after constructor call can fail.\n+                                error::can_not_open_file err;\n+                                err.set_errno(x);\n+                                err.set_file_name(file_name);\n+                                throw err;\n+                        }\n+                        return std::unique_ptr<ByteSourceBase>(new detail::OwningStdIOByteSourceBase(file));\n+                }\n+\n+                void init(std::unique_ptr<ByteSourceBase>byte_source){\n+                        file_line = 0;\n+\n+                        buffer = std::unique_ptr<char[]>(new char[3*block_len]);\n+                        data_begin = 0;\n+                        data_end = byte_source->read(buffer.get(), 2*block_len);\n+\n+                        // Ignore UTF-8 BOM\n+                        if(data_end >= 3 && buffer[0] == '\\xEF' && buffer[1] == '\\xBB' && buffer[2] == '\\xBF')\n+                                data_begin = 3;\n+\n+                        if(data_end == 2*block_len){\n+                                reader.init(std::move(byte_source));\n+                                reader.start_read(buffer.get() + 2*block_len, block_len);\n+                        }\n+                }\n+\n+        public:\n+                LineReader() = delete;\n+                LineReader(const LineReader&) = delete;\n+                LineReader&operator=(const LineReader&) = delete;\n+\n+                explicit LineReader(const char*file_name){\n+                        set_file_name(file_name);\n+                        init(open_file(file_name));\n+                }\n+\n+                explicit LineReader(const std::string&file_name){\n+                        set_file_name(file_name.c_str());\n+                        init(open_file(file_name.c_str()));\n+                }\n+\n+                LineReader(const char*file_name, std::unique_ptr<ByteSourceBase>byte_source){\n+                        set_file_name(file_name);\n+                        init(std::move(byte_source));\n+                }\n+\n+                LineReader(const std::string&file_name, std::unique_ptr<ByteSourceBase>byte_source){\n+                        set_file_name(file_name.c_str());\n+                        init(std::move(byte_source));\n+                }\n+\n+                LineReader(const char*file_name, const char*data_begin, const char*data_end){\n+                        set_file_name(file_name);\n+                        init(std::unique_ptr<ByteSourceBase>(new detail::NonOwningStringByteSource(data_begin, data_end-data_begin)));\n+                }\n+\n+                LineReader(const std::string&file_name, const char*data_begin, const char*data_end){\n+                        set_file_name(file_name.c_str());\n+                        init(std::unique_ptr<ByteSourceBase>(new detail::NonOwningStringByteSource(data_begin, data_end-data_begin)));\n+                }\n+\n+                LineReader(const char*file_name, FILE*file){\n+                        set_file_name(file_name);\n+                        init(std::unique_ptr<ByteSourceBase>(new detail::OwningStdIOByteSourceBase(file)));\n+                }\n+\n+                LineReader(const std::string&file_name, FILE*file){\n+                        set_file_name(file_name.c_str());\n+                        init(std::unique_ptr<ByteSourceBase>(new detail::OwningStdIOByteSourceBase(file)));\n+                }\n+\n+                LineReader(const char*file_name, std::istream&in){\n+                        set_file_name(file_name);\n+                        init(std::unique_ptr<ByteSourceBase>(new detail::NonOwningIStreamByteSource(in)));\n+                }\n+\n+                LineReader(const std::string&file_name, std::istream&in){\n+                        set_file_name(file_name.c_str());\n+                        init(std::unique_ptr<ByteSourceBase>(new detail::NonOwningIStreamByteSource(in)));\n+                }\n+\n+                void set_file_name(const std::string&file_name){\n+                        set_file_name(file_name.c_str());\n+                }\n+\n+                void set_file_name(const char*file_name){\n+                        strncpy(this->file_name, file_name, error::max_file_name_length);\n+                        this->file_name[error::max_file_name_length] = '\\0';\n+                }\n+\n+                const char*get_truncated_file_name()const{\n+                        return file_name;\n+                }\n+\n+                void set_file_line(unsigned file_line){\n+                        this->file_line = file_line;\n+                }\n+\n+                unsigned get_file_line()const{\n+                        return file_line;\n+                }\n+\n+                char*next_line(){\n+                        if(data_begin == data_end)\n+                                return 0;\n+\n+                        ++file_line;\n+\n+                        assert(data_begin < data_end);\n+                        assert(data_end <= block_len*2);\n+\n+                        if(data_begin >= block_len){\n+                                std::memcpy(buffer.get(), buffer.get()+block_len, block_len);\n+                                data_begin -= block_len;\n+                                data_end -= block_len;\n+                                if(reader.is_valid())\n+                                {\n+                                        data_end += reader.finish_read();\n+                                        std::memcpy(buffer.get()+block_len, buffer.get()+2*block_len, block_len);\n+                                        reader.start_read(buffer.get() + 2*block_len, block_len);\n+                                }\n+                        }\n+\n+                        int line_end = data_begin;\n+                        while(buffer[line_end] != '\\n' && line_end != data_end){\n+                                ++line_end;\n+                        }\n+\n+                        if(line_end - data_begin + 1 > block_len){\n+                                error::line_length_limit_exceeded err;\n+                                err.set_file_name(file_name);\n+                                err.set_file_line(file_line);\n+                                throw err;\n+                        }\n+\n+                        if(buffer[line_end] == '\\n'){\n+                                buffer[line_end] = '\\0';\n+                        }else{\n+                                // some files are missing the newline at the end of the\n+                                // last line\n+                                ++data_end;\n+                                buffer[line_end] = '\\0';\n+                        }\n+\n+                        // handle windows \\r\\n-line breaks\n+                        if(line_end != data_begin && buffer[line_end-1] == '\\r')\n+                                buffer[line_end-1] = '\\0';\n+\n+                        char*ret = buffer.get() + data_begin;\n+                        data_begin = line_end+1;\n+                        return ret;\n+                }\n+        };\n+\n+\n+        ////////////////////////////////////////////////////////////////////////////\n+        //                                 CSV                                    //\n+        ////////////////////////////////////////////////////////////////////////////\n+\n+        namespace error{\n+                const int max_column_name_length = 63;\n+                struct with_column_name{\n+                        with_column_name(){\n+                                std::memset(column_name, 0, max_column_name_length+1);\n+                        }\n+                       \n+                        void set_column_name(const char*column_name){\n+                                std::strncpy(this->column_name, column_name, max_column_name_length);\n+                                this->column_name[max_column_name_length] = '\\0';\n+                        }\n+\n+                        char column_name[max_column_name_length+1];\n+                };\n+\n+\n+                const int max_column_content_length = 63;\n+\n+                struct with_column_content{\n+                        with_column_content(){\n+                                std::memset(column_content, 0, max_column_content_length+1);\n+                        }\n+                       \n+                        void set_column_content(const char*column_content){\n+                                std::strncpy(this->column_content, column_content, max_column_content_length);\n+                                this->column_content[max_column_content_length] = '\\0';\n+                        }\n+\n+                        char column_content[max_column_content_length+1];\n+                };\n+\n+\n+                struct extra_column_in_header :\n+                        base,\n+                        with_file_name,\n+                        with_column_name{\n+                        void format_error_message()const{\n+                                std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n+                                        \"Extra column \\\"%s\\\" in header of file \\\"%s\\\".\"\n+                                        , column_name, file_name);\n+                        }\n+                };\n+\n+                struct missing_column_in_header :\n+                        base,\n+                        with_file_name,\n+                        with_column_name{\n+                        void format_error_message()const{\n+                                std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n+                                        \"Missing column \\\"%s\\\" in header of file \\\"%s\\\".\"\n+                                        , column_name, file_name);\n+                        }\n+                };\n+\n+                struct duplicated_column_in_header :\n+                        base,\n+                        with_file_name,\n+                        with_column_name{\n+                        void format_error_message()const{\n+                                std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n+                                        \"Duplicated column \\\"%s\\\" in header of file \\\"%s\\\".\"\n+                                        , column_name, file_name);\n+                        }\n+                };\n+\n+                struct header_missing :\n+                        base,\n+                        with_file_name{\n+                        void format_error_message()const{\n+                                std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n+                                        \"Header missing in file \\\"%s\\\".\"\n+                                        , file_name);\n+                        }\n+                };\n+\n+                struct too_few_columns :\n+                        base,\n+                        with_file_name,\n+                        with_file_line{\n+                        void format_error_message()const{\n+                                std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n+                                        \"Too few columns in line %d in file \\\"%s\\\".\"\n+                                        , file_line, file_name);\n+                        }\n+                };\n+\n+                struct too_many_columns :\n+                        base,\n+                        with_file_name,\n+                        with_file_line{\n+                        void format_error_message()const{\n+                                std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n+                                        \"Too many columns in line %d in file \\\"%s\\\".\"\n+                                        , file_line, file_name);\n+                        }\n+                };\n+\n+                struct escaped_string_not_closed :\n+                        base,\n+                        with_file_name,\n+                        with_file_line{\n+                        void format_error_message()const{\n+                                std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n+                                        \"Escaped string was not closed in line %d in file \\\"%s\\\".\"\n+                                        , file_line, file_name);\n+                        }\n+                };\n+\n+                struct integer_must_be_positive :\n+                        base,\n+                        with_file_name,\n+                        with_file_line,\n+                        with_column_name,\n+                        with_column_content{\n+                        void format_error_message()const{\n+                                std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n+                                        \"The integer \\\"%s\\\" must be positive or 0 in column \\\"%s\\\" in file \\\"%s\\\" in line \\\"%d\\\".\"\n+                                        , column_content, column_name, file_name, file_line);\n+                        }\n+                };\n+\n+                struct no_digit :\n+                        base,\n+                        with_file_name,\n+                        with_file_line,\n+                        with_column_name,\n+                        with_column_content{\n+                        void format_error_message()const{\n+                                std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n+                                        \"The integer \\\"%s\\\" contains an invalid digit in column \\\"%s\\\" in file \\\"%s\\\" in line \\\"%d\\\".\"\n+                                        , column_content, column_name, file_name, file_line);\n+                        }\n+                };\n+\n+                struct integer_overflow :\n+                        base,\n+                        with_file_name,\n+                        with_file_line,\n+                        with_column_name,\n+                        with_column_content{\n+                        void format_error_message()const{\n+                                std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n+                                        \"The integer \\\"%s\\\" overflows in column \\\"%s\\\" in file \\\"%s\\\" in line \\\"%d\\\".\"\n+                                        , column_content, column_name, file_name, file_line);\n+                        }\n+                };\n+\n+                struct integer_underflow :\n+                        base,\n+                        with_file_name,\n+                        with_file_line,\n+                        with_column_name,\n+                        with_column_content{\n+                        void format_error_message()const{\n+                                std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n+                                        \"The integer \\\"%s\\\" underflows in column \\\"%s\\\" in file \\\"%s\\\" in line \\\"%d\\\".\"\n+                                        , column_content, column_name, file_name, file_line);\n+                        }\n+                };\n+\n+                struct invalid_single_character :\n+                        base,\n+                        with_file_name,\n+                        with_file_line,\n+                        with_column_name,\n+                        with_column_content{\n+                        void format_error_message()const{\n+                                std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n+                                        \"The content \\\"%s\\\" of column \\\"%s\\\" in file \\\"%s\\\" in line \\\"%d\\\" is not a single character.\"\n+                                        , column_content, column_name, file_name, file_line);\n+                        }\n+                };\n+        }\n+\n+        typedef unsigned ignore_column;\n+        static const ignore_column ignore_no_column = 0;\n+        static const ignore_column ignore_extra_column = 1;\n+        static const ignore_column ignore_missing_column = 2;\n+\n+        template<char ... trim_char_list>\n+        struct trim_chars{\n+        private:\n+                constexpr static bool is_trim_char(char){\n+                        return false;\n+                }\n+       \n+                template<class ...OtherTrimChars>\n+                constexpr static bool is_trim_char(char c, char trim_char, OtherTrimChars...other_trim_chars){\n+                        return c == trim_char || is_trim_char(c, other_trim_chars...);\n+                }\n+\n+        public:\n+                static void trim(char*&str_begin, char*&str_end){\n+                        while(is_trim_char(*str_begin, trim_char_list...) && str_begin != str_end)\n+                                ++str_begin;\n+                        while(is_trim_char(*(str_end-1), trim_char_list...) && str_begin != str_end)\n+                                --str_end;\n+                        *str_end = '\\0';\n+                }\n+        };\n+\n+\n+        struct no_comment{\n+                static bool is_comment(const char*){\n+                        return false;\n+                }\n+        };\n+\n+        template<char ... comment_start_char_list>\n+        struct single_line_comment{\n+        private:\n+                constexpr static bool is_comment_start_char(char){\n+                        return false;\n+                }\n+       \n+                template<class ...OtherCommentStartChars>\n+                constexpr static bool is_comment_start_char(char c, char comment_start_char, OtherCommentStartChars...other_comment_start_chars){\n+                        return c == comment_start_char || is_comment_start_char(c, other_comment_start_chars...);\n+                }\n+\n+        public:\n+\n+                static bool is_comment(const char*line){\n+                        return is_comment_start_char(*line, comment_start_char_list...);\n+                }\n+        };\n+\n+        struct empty_line_comment{\n+                static bool is_comment(const char*line){\n+                        if(*line == '\\0')\n+                                return true;\n+                        while(*line == ' ' || *line == '\\t'){\n+                                ++line;\n+                                if(*line == 0)\n+                                        return true;\n+                        }\n+                        return false;\n+                }\n+        };\n+\n+        template<char ... comment_start_char_list>\n+        struct single_and_empty_line_comment{\n+                static bool is_comment(const char*line){\n+                        return single_line_comment<comment_start_char_list...>::is_comment(line) || empty_line_comment::is_comment(line);\n+                }\n+        };\n+\n+        template<char sep>\n+        struct no_quote_escape{\n+                static const char*find_next_column_end(const char*col_begin){\n+                        while(*col_begin != sep && *col_begin != '\\0')\n+                                ++col_begin;\n+                        return col_begin;\n+                }\n+\n+                static void unescape(char*&, char*&){\n+\n+                }\n+        };\n+\n+        template<char sep, char quote>\n+        struct double_quote_escape{\n+                static const char*find_next_column_end(const char*col_begin){\n+                        while(*col_begin != sep && *col_begin != '\\0')\n+                                if(*col_begin != quote)\n+                                        ++col_begin;\n+                                else{\n+                                        do{\n+                                                ++col_begin;\n+                                                while(*col_begin != quote){\n+                                                        if(*col_begin == '\\0')\n+                                                                throw error::escaped_string_not_closed();\n+                                                        ++col_begin;\n+                                                }\n+                                                ++col_begin;\n+                                        }while(*col_begin == quote);\n+                                }      \n+                        return col_begin;      \n+                }\n+\n+                static void unescape(char*&col_begin, char*&col_end){\n+                        if(col_end - col_begin >= 2){\n+                                if(*col_begin == quote && *(col_end-1) == quote){\n+                                        ++col_begin;\n+                                        --col_end;\n+                                        char*out = col_begin;\n+                                        for(char*in = col_begin; in!=col_end; ++in){\n+                                                if(*in == quote && (in+1) != col_end && *(in+1) == quote){\n+                                                         ++in;\n+                                                }\n+                                                *out = *in;\n+                                                ++out;\n+                                        }\n+                                        col_end = out;\n+                                        *col_end = '\\0';\n+                                }\n+                        }\n+                       \n+                }\n+        };\n+\n+        struct throw_on_overflow{\n+                template<class T>\n+                static void on_overflow(T&){\n+                        throw error::integer_overflow();\n+                }\n+               \n+                template<class T>\n+                static void on_underflow(T&){\n+                        throw error::integer_underflow();\n+                }\n+        };\n+\n+        struct ignore_overflow{\n+                template<class T>\n+                static void on_overflow(T&){}\n+               \n+                template<class T>\n+                static void on_underflow(T&){}\n+        };\n+\n+        struct set_to_max_on_overflow{\n+                template<class T>\n+                static void on_overflow(T&x){\n+                        x = std::numeric_limits<T>::max();\n+                }\n+               \n+                template<class T>\n+                static void on_underflow(T&x){\n+                        x = std::numeric_limits<T>::min();\n+                }\n+        };\n+\n+\n+        namespace detail{\n+                template<class quote_policy>\n+                void chop_next_column(\n+                        char*&line, char*&col_begin, char*&col_end\n+                ){\n+                        assert(line != nullptr);\n+\n+                        col_begin = line;\n+                        // the col_begin + (... - col_begin) removes the constness\n+                        col_end = col_begin + (quote_policy::find_next_column_end(col_begin) - col_begin);\n+                       \n+                        if(*col_end == '\\0'){\n+                                line = nullptr;\n+                        }else{\n+                                *col_end = '\\0';\n+                                line = col_end + 1;    \n+                        }\n+                }\n+\n+                template<class trim_policy, class quote_policy>\n+                void parse_line(\n+                        char*line,\n+                        char**sorted_col,\n+                        const std::vector<int>&col_order\n+                ){\n+                        for(std::size_t i=0; i<col_order.size(); ++i){\n+                                if(line == nullptr)\n+                                        throw ::io::error::too_few_columns();\n+                                char*col_begin, *col_end;\n+                                chop_next_column<quote_policy>(line, col_begin, col_end);\n+\n+                                if(col_order[i] != -1){\n+                                        trim_policy::trim(col_begin, col_end);\n+                                        quote_policy::unescape(col_begin, col_end);\n+                                                               \n+                                        sorted_col[col_order[i]] = col_begin;\n+                                }\n+                        }\n+                        if(line != nullptr)\n+                                throw ::io::error::too_many_columns();\n+                }\n+\n+                template<unsigned column_count, class trim_policy, class quote_policy>\n+                void parse_header_line(\n+                        char*line,\n+                        std::vector<int>&col_order,\n+                        const std::string*col_name,\n+                        ignore_column ignore_policy\n+                ){\n+                        col_order.clear();\n+\n+                        bool found[column_count];\n+                        std::fill(found, found + column_count, false);\n+                        while(line){\n+                                char*col_begin,*col_end;\n+                                chop_next_column<quote_policy>(line, col_begin, col_end);\n+\n+                                trim_policy::trim(col_begin, col_end);\n+                                quote_policy::unescape(col_begin, col_end);\n+                               \n+                                for(unsigned i=0; i<column_count; ++i)\n+                                        if(col_begin == col_name[i]){\n+                                                if(found[i]){\n+                                                        error::duplicated_column_in_header err;\n+                                                        err.set_column_name(col_begin);\n+                                                        throw err;\n+                                                }\n+                                                found[i] = true;\n+                                                col_order.push_back(i);\n+                                                col_begin = 0;\n+                                                break;\n+                                        }\n+                                if(col_begin){\n+                                        if(ignore_policy & ::io::ignore_extra_column)\n+                                                col_order.push_back(-1);\n+                                        else{\n+                                                error::extra_column_in_header err;\n+                                                err.set_column_name(col_begin);\n+                                                throw err;\n+                                        }\n+                                }\n+                        }\n+                        if(!(ignore_policy & ::io::ignore_missing_column)){\n+                                for(unsigned i=0; i<column_count; ++i){\n+                                        if(!found[i]){\n+                                                error::missing_column_in_header err;\n+                                                err.set_column_name(col_name[i].c_str());\n+                                                throw err;\n+                                        }\n+                                }\n+                        }\n+                }\n+\n+                template<class overflow_policy>\n+                void parse(char*col, char &x){\n+                        if(!*col)\n+                                throw error::invalid_single_character();\n+                        x = *col;\n+                        ++col;\n+                        if(*col)\n+                                throw error::invalid_single_character();\n+                }\n+               \n+                template<class overflow_policy>\n+                void parse(char*col, std::string&x){\n+                        x = col;\n+                }\n+\n+                template<class overflow_policy>\n+                void parse(char*col, const char*&x){\n+                        x = col;\n+                }\n+\n+                template<class overflow_policy>\n+                void parse(char*col, char*&x){\n+                        x = col;\n+                }\n+\n+                template<class overflow_policy, class T>\n+                void parse_unsigned_integer(const char*col, T&x){\n+                        x = 0;\n+                        while(*col != '\\0'){\n+                                if('0' <= *col && *col <= '9'){\n+                                        T y = *col - '0';\n+                                        if(x > (std::numeric_limits<T>::max()-y)/10){\n+                                                overflow_policy::on_overflow(x);\n+                                                return;\n+                                        }\n+                                        x = 10*x+y;\n+                                }else\n+                                        throw error::no_digit();\n+                                ++col;\n+                        }\n+                }\n+\n+                template<class overflow_policy>void parse(char*col, unsigned char &x)\n+                        {parse_unsigned_integer<overflow_policy>(col, x);}\n+                template<class overflow_policy>void parse(char*col, unsigned short &x)\n+                        {parse_unsigned_integer<overflow_policy>(col, x);}\n+                template<class overflow_policy>void parse(char*col, unsigned int &x)\n+                        {parse_unsigned_integer<overflow_policy>(col, x);}\n+                template<class overflow_policy>void parse(char*col, unsigned long &x)\n+                        {parse_unsigned_integer<overflow_policy>(col, x);}\n+                template<class overflow_policy>void parse(char*col, unsigned long long &x)\n+                        {parse_unsigned_integer<overflow_policy>(col, x);}\n+               \n+                template<class overflow_policy, class T>\n+                void parse_signed_integer(const char*col, T&x){\n+                        if(*col == '-'){\n+                                ++col;\n+\n+                                x = 0;\n+                                while(*col != '\\0'){\n+                                        if('0' <= *col && *col <= '9'){\n+                                                T y = *col - '0';\n+                                                if(x < (std::numeric_limits<T>::min()+y)/10){\n+                                                        overflow_policy::on_underflow(x);\n+                                                        return;\n+                                                }\n+                                                x = 10*x-y;\n+                                        }else\n+                                                throw error::no_digit();\n+                                        ++col;\n+                                }\n+                                return;\n+                        }else if(*col == '+')\n+                                ++col;\n+                        parse_unsigned_integer<overflow_policy>(col, x);\n+                }      \n+\n+                template<class overflow_policy>void parse(char*col, signed char &x)\n+                        {parse_signed_integer<overflow_policy>(col, x);}\n+                template<class overflow_policy>void parse(char*col, signed short &x)\n+                        {parse_signed_integer<overflow_policy>(col, x);}\n+                template<class overflow_policy>void parse(char*col, signed int &x)\n+                        {parse_signed_integer<overflow_policy>(col, x);}\n+                template<class overflow_policy>void parse(char*col, signed long &x)\n+                        {parse_signed_integer<overflow_policy>(col, x);}\n+                template<class overflow_policy>void parse(char*col, signed long long &x)\n+                        {parse_signed_integer<overflow_policy>(col, x);}\n+\n+                template<class T>\n+                void parse_float(const char*col, T&x){\n+                        bool is_neg = false;\n+                        if(*col == '-'){\n+                                is_neg = true;\n+                                ++col;\n+                        }else if(*col == '+')\n+                                ++col;\n+\n+                        x = 0;\n+                        while('0' <= *col && *col <= '9'){\n+                                int y = *col - '0';\n+                                x *= 10;\n+                                x += y;\n+                                ++col;\n+                        }\n+                       \n+                        if(*col == '.'|| *col == ','){\n+                                ++col;\n+                                T pos = 1;\n+                                while('0' <= *col && *col <= '9'){\n+                                        pos /= 10;\n+                                        int y = *col - '0';\n+                                        ++col;\n+                                        x += y*pos;\n+                                }\n+                        }\n+\n+                        if(*col == 'e' || *col == 'E'){\n+                                ++col;\n+                                int e;\n+\n+                                parse_signed_integer<set_to_max_on_overflow>(col, e);\n+                               \n+                                if(e != 0){\n+                                        T base;\n+                                        if(e < 0){\n+                                                base = 0.1;\n+                                                e = -e;\n+                                        }else{\n+                                                base = 10;\n+                                        }\n+       \n+                                        while(e != 1){\n+                                                if((e & 1) == 0){\n+                                                        base = base*base;\n+                                                        e >>= 1;\n+                                                }else{\n+                                                        x *= base;\n+                                                        --e;\n+                                                }\n+                                        }\n+                                        x *= base;\n+                                }\n+                        }else{\n+                                if(*col != '\\0')\n+                                        throw error::no_digit();\n+                        }\n+\n+                        if(is_neg)\n+                                x = -x;\n+                }\n+\n+                template<class overflow_policy> void parse(char*col, float&x) { parse_float(col, x); }\n+                template<class overflow_policy> void parse(char*col, double&x) { parse_float(col, x); }\n+                template<class overflow_policy> void parse(char*col, long double&x) { parse_float(col, x); }\n+\n+                template<class overflow_policy, class T>\n+                void parse(char*col, T&x){\n+                        // GCC evalutes \"false\" when reading the template and\n+                        // \"sizeof(T)!=sizeof(T)\" only when instantiating it. This is why\n+                        // this strange construct is used.\n+                        static_assert(sizeof(T)!=sizeof(T),\n+                                \"Can not parse this type. Only buildin integrals, floats, char, char*, const char* and std::string are supported\");\n+                }\n+\n+        }\n+\n+        template<unsigned column_count,\n+                class trim_policy = trim_chars<' ', '\\t'>,\n+                class quote_policy = no_quote_escape<','>,\n+                class overflow_policy = throw_on_overflow,\n+                class comment_policy = no_comment\n+        >\n+        class CSVReader{\n+        private:\n+                LineReader in;\n+\n+                char*(row[column_count]);\n+                std::string column_names[column_count];\n+\n+                std::vector<int>col_order;\n+\n+                template<class ...ColNames>\n+                void set_column_names(std::string s, ColNames...cols){\n+                        column_names[column_count-sizeof...(ColNames)-1] = std::move(s);\n+                        set_column_names(std::forward<ColNames>(cols)...);\n+                }\n+\n+                void set_column_names(){}\n+\n+\n+        public:\n+                CSVReader() = delete;\n+                CSVReader(const CSVReader&) = delete;\n+                CSVReader&operator=(const CSVReader&);\n+\n+                template<class ...Args>\n+                explicit CSVReader(Args&&...args):in(std::forward<Args>(args)...){\n+                        std::fill(row, row+column_count, nullptr);\n+                        col_order.resize(column_count);\n+                        for(unsigned i=0; i<column_count; ++i)\n+                                col_order[i] = i;\n+                        for(unsigned i=1; i<=column_count; ++i)\n+                                column_names[i-1] = \"col\"+std::to_string(i);\n+                }\n+\n+\t\tchar*next_line(){\n+\t\t\treturn in.next_line();\n+\t\t}\n+\n+                template<class ...ColNames>\n+                void read_header(ignore_column ignore_policy, ColNames...cols){\n+                        static_assert(sizeof...(ColNames)>=column_count, \"not enough column names specified\");\n+                        static_assert(sizeof...(ColNames)<=column_count, \"too many column names specified\");\n+                        try{\n+                                set_column_names(std::forward<ColNames>(cols)...);\n+\n+                                char*line;\n+                                do{\n+                                        line = in.next_line();\n+                                        if(!line)\n+                                                throw error::header_missing();\n+                                }while(comment_policy::is_comment(line));\n+\n+                                detail::parse_header_line\n+                                        <column_count, trim_policy, quote_policy>\n+                                        (line, col_order, column_names, ignore_policy);\n+                        }catch(error::with_file_name&err){\n+                                err.set_file_name(in.get_truncated_file_name());\n+                                throw;\n+                        }\n+                }\n+\n+                template<class ...ColNames>\n+                void set_header(ColNames...cols){\n+                        static_assert(sizeof...(ColNames)>=column_count,\n+                                \"not enough column names specified\");\n+                        static_assert(sizeof...(ColNames)<=column_count,\n+                                \"too many column names specified\");\n+                        set_column_names(std::forward<ColNames>(cols)...);\n+                        std::fill(row, row+column_count, nullptr);\n+                        col_order.resize(column_count);\n+                        for(unsigned i=0; i<column_count; ++i)\n+                                col_order[i] = i;\n+                }\n+\n+                bool has_column(const std::string&name) const {\n+                        return col_order.end() != std::find(\n+                                col_order.begin(), col_order.end(),\n+                                        std::find(std::begin(column_names), std::end(column_names), name)\n+                                - std::begin(column_names));\n+                }\n+\n+                void set_file_name(const std::string&file_name){\n+                        in.set_file_name(file_name);\n+                }\n+\n+                void set_file_name(const char*file_name){\n+                        in.set_file_name(file_name);\n+                }\n+\n+                const char*get_truncated_file_name()const{\n+                        return in.get_truncated_file_name();\n+                }\n+\n+                void set_file_line(unsigned file_line){\n+                        in.set_file_line(file_line);\n+                }\n+\n+                unsigned get_file_line()const{\n+                        return in.get_file_line();\n+                }\n+\n+        private:\n+                void parse_helper(std::size_t){}\n+\n+                template<class T, class ...ColType>\n+                void parse_helper(std::size_t r, T&t, ColType&...cols){                        \n+                        if(row[r]){\n+                                try{\n+                                        try{\n+                                                ::io::detail::parse<overflow_policy>(row[r], t);\n+                                        }catch(error::with_column_content&err){\n+                                                err.set_column_content(row[r]);\n+                                                throw;\n+                                        }\n+                                }catch(error::with_column_name&err){\n+                                        err.set_column_name(column_names[r].c_str());\n+                                        throw;\n+                                }\n+                        }\n+                        parse_helper(r+1, cols...);\n+                }\n+\n+       \n+        public:\n+                template<class ...ColType>\n+                bool read_row(ColType& ...cols){\n+                        static_assert(sizeof...(ColType)>=column_count,\n+                                \"not enough columns specified\");\n+                        static_assert(sizeof...(ColType)<=column_count,\n+                                \"too many columns specified\");\n+                        try{\n+                                try{\n+       \n+                                        char*line;\n+                                        do{\n+                                                line = in.next_line();\n+                                                if(!line)\n+                                                        return false;\n+                                        }while(comment_policy::is_comment(line));\n+                                       \n+                                        detail::parse_line<trim_policy, quote_policy>\n+                                                (line, row, col_order);\n+               \n+                                        parse_helper(0, cols...);\n+                                }catch(error::with_file_name&err){\n+                                        err.set_file_name(in.get_truncated_file_name());\n+                                        throw;\n+                                }\n+                        }catch(error::with_file_line&err){\n+                                err.set_file_line(in.get_file_line());\n+                                throw;\n+                        }\n+\n+                        return true;\n+                }\n+        };\n+}\n+#endif\n+"
      }
    ]
  }
]