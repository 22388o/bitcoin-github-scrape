[
  {
    "sha": "119c3b90d6b7e9b81915a09f5ca5370f2ef1ea57",
    "node_id": "C_kwDOABII59oAKDExOWMzYjkwZDZiN2U5YjgxOTE1YTA5ZjVjYTUzNzBmMmVmMWVhNTc",
    "commit": {
      "author": {
        "name": "Martin Leitner-Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2021-11-13T17:56:41Z"
      },
      "committer": {
        "name": "Martin Leitner-Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2021-11-15T20:17:15Z"
      },
      "message": "Correctly calculate node size for std::unordered_map\n\nNode sizes are calculated correctly for libc++, libstdc++ and MSVC\nimplementations of std::unordered_map. This is tested for all kind of\npossible types used for std::unordered_map.",
      "tree": {
        "sha": "3a3285f4732c3e6fc79c762474a766fa1b7f8bbf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3a3285f4732c3e6fc79c762474a766fa1b7f8bbf"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/119c3b90d6b7e9b81915a09f5ca5370f2ef1ea57",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCAAdFiEEqyQrdqB7R6j2Hv2k++qtf8b//oEFAmGSwEsACgkQ++qtf8b/\n/oGdJAv+LsfTHBOWkT6T1J/1PUNFF8eFJOGTooIqV//WxocIiLeWBsA/4ja18vyd\nHGPxHl6pwlhvxPfMcW9g+P+fnlFuAbrPYVbsZzesebr99JENv9rm/pQ6witzGq5W\nJGrk4hZml0gb7Q0X8NLGC/bcL9HyhozGC5c5o+r+5tNv/p6lHjW970qmfkU0wVMp\noTImu6M6/RJxK6J3ozG8fj+34jQdLS+awMjjhRB7EmG4m2uEH2rHrE/kVOj89NfE\nroI0nF3kSz/F2o1I0kwPVfYbQ+yaH7igEVJVeubPxpsh8o8c/C7Zu+WLynXtXFmo\naWPI5s70GwenNmAsUKZ1PmbwQXQgpklj0NA3bepAkt9oENYpEUcjIzU7DPXIWjBx\n5idplSQFdDT9cwAkyUBWyY8a5ySHqf7AtSfcSu27KopZ6k0CfCESxpP3bPp/iSDv\niIklDHfkiUm5rPVT1Sws/+JF9xmmuXJk2wfHGb6yQqaiKAhFhWq1b4J46iMT1XI9\nDkz54VSX\n=0mvR\n-----END PGP SIGNATURE-----",
        "payload": "tree 3a3285f4732c3e6fc79c762474a766fa1b7f8bbf\nparent 5ccab7187b35142e03c15dd55390e45b3d233c52\nauthor Martin Leitner-Ankerl <martin.ankerl@gmail.com> 1636826201 +0100\ncommitter Martin Leitner-Ankerl <martin.ankerl@gmail.com> 1637007435 +0100\n\nCorrectly calculate node size for std::unordered_map\n\nNode sizes are calculated correctly for libc++, libstdc++ and MSVC\nimplementations of std::unordered_map. This is tested for all kind of\npossible types used for std::unordered_map.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/119c3b90d6b7e9b81915a09f5ca5370f2ef1ea57",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/119c3b90d6b7e9b81915a09f5ca5370f2ef1ea57",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/119c3b90d6b7e9b81915a09f5ca5370f2ef1ea57/comments",
    "author": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5ccab7187b35142e03c15dd55390e45b3d233c52",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5ccab7187b35142e03c15dd55390e45b3d233c52",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5ccab7187b35142e03c15dd55390e45b3d233c52"
      }
    ],
    "stats": {
      "total": 200,
      "additions": 200,
      "deletions": 0
    },
    "files": [
      {
        "sha": "28aa85c4ecc3919dd94858e1d5a95a430a03bf40",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/119c3b90d6b7e9b81915a09f5ca5370f2ef1ea57/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/119c3b90d6b7e9b81915a09f5ca5370f2ef1ea57/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=119c3b90d6b7e9b81915a09f5ca5370f2ef1ea57",
        "patch": "@@ -217,6 +217,7 @@ BITCOIN_CORE_H = \\\n   shutdown.h \\\n   signet.h \\\n   streams.h \\\n+  support/allocators/node_allocator/node_size.h \\\n   support/allocators/secure.h \\\n   support/allocators/zeroafterfree.h \\\n   support/cleanse.h \\"
      },
      {
        "sha": "51b2ecf7ef50c3f8975367f608f687df6b0caaf8",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/119c3b90d6b7e9b81915a09f5ca5370f2ef1ea57/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/119c3b90d6b7e9b81915a09f5ca5370f2ef1ea57/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=119c3b90d6b7e9b81915a09f5ca5370f2ef1ea57",
        "patch": "@@ -109,6 +109,8 @@ BITCOIN_TESTS =\\\n   test/net_peer_eviction_tests.cpp \\\n   test/net_tests.cpp \\\n   test/netbase_tests.cpp \\\n+  test/node_allocator_helpers.h \\\n+  test/node_size_tests.cpp \\\n   test/pmt_tests.cpp \\\n   test/policy_fee_tests.cpp \\\n   test/policyestimator_tests.cpp \\"
      },
      {
        "sha": "97d9568da3f69a072463d843590ea7f97e6a9122",
        "filename": "src/support/allocators/node_allocator/node_size.h",
        "status": "added",
        "additions": 60,
        "deletions": 0,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/119c3b90d6b7e9b81915a09f5ca5370f2ef1ea57/src/support/allocators/node_allocator/node_size.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/119c3b90d6b7e9b81915a09f5ca5370f2ef1ea57/src/support/allocators/node_allocator/node_size.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/support/allocators/node_allocator/node_size.h?ref=119c3b90d6b7e9b81915a09f5ca5370f2ef1ea57",
        "patch": "@@ -0,0 +1,60 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_NODE_SIZE_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_NODE_SIZE_H\n+\n+#include <cstddef>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+\n+namespace node_allocator {\n+\n+/**\n+ * Calculates memory usage of nodes for different containers.\n+ */\n+template <typename T>\n+struct NodeSize;\n+\n+/**\n+ * It is important that the calculation here matches exactly the behavior of std::unordered_map\n+ * so the node_allocator actually works. This is tested in node_allocator_tests/test_allocations_are_used\n+ * with multiple configurations (alignments, noexcept hash, node sizes).\n+ */\n+template <typename Key, typename V, typename Hash, typename Equals, typename Allocator>\n+struct NodeSize<std::unordered_map<Key, V, Hash, Equals, Allocator>> {\n+    using ContainerType = std::unordered_map<Key, V, Hash, Equals, Allocator>;\n+    using ValueType = typename ContainerType::value_type;\n+\n+#if defined(_MSC_VER)\n+    // libstdc++, libc++, and MSVC implement the nodes differently. To get the correct size with\n+    // the correct alignment, we can simulate the memory layouts with accordingly nested std::pairs.\n+    //\n+    // list node contains 2 pointers and no hash; see\n+    // https://github.com/microsoft/STL/blob/main/stl/inc/unordered_map and\n+    // https://github.com/microsoft/STL/blob/main/stl/inc/list\n+    using SimulatedNodeType = std::pair<std::pair<void*, void*>, ValueType>;\n+#elif defined(_LIBCPP_VERSION) // defined in any C++ header from libc++\n+    // libc++ always stores hash and pointer in the node\n+    // see https://github.com/llvm/llvm-project/blob/release/13.x/libcxx/include/__hash_table#L92\n+    using SimulatedNodeType = std::pair<ValueType, std::pair<size_t, void*>>;\n+#else\n+    // libstdc++ doesn't store hash when its operator() is noexcept;\n+    // see hashtable_policy.h, struct _Hash_node\n+    // https://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a05689.html\n+    using SimulatedNodeType = std::conditional_t<noexcept(std::declval<Hash>()(std::declval<const Key&>())),\n+                                                 std::pair<void*, ValueType>,                     // no hash stored\n+                                                 std::pair<void*, std::pair<ValueType, size_t>>>; // hash stored along ValueType, and that is wrapped with the pointer.\n+#endif\n+\n+    [[nodiscard]] static constexpr size_t Value()\n+    {\n+        return sizeof(SimulatedNodeType);\n+    }\n+};\n+\n+} // namespace node_allocator\n+\n+#endif // BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_NODE_SIZE_H"
      },
      {
        "sha": "7cc7a2ec10dc3af4da33a2b5ac15c5ce1b4dc72a",
        "filename": "src/test/node_allocator_helpers.h",
        "status": "added",
        "additions": 27,
        "deletions": 0,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/119c3b90d6b7e9b81915a09f5ca5370f2ef1ea57/src/test/node_allocator_helpers.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/119c3b90d6b7e9b81915a09f5ca5370f2ef1ea57/src/test/node_allocator_helpers.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/node_allocator_helpers.h?ref=119c3b90d6b7e9b81915a09f5ca5370f2ef1ea57",
        "patch": "@@ -0,0 +1,27 @@\n+#ifndef BITCOIN_TEST_NODE_ALLOCATOR_HELPERS_H\n+#define BITCOIN_TEST_NODE_ALLOCATOR_HELPERS_H\n+\n+#include <cstddef>\n+#include <utility>\n+\n+/**\n+ * Wrapper around std::hash, but without noexcept. Useful for testing unordered containers\n+ * because they potentially behave differently with/without a noexcept hash.\n+ */\n+template <typename T>\n+struct NotNoexceptHash {\n+    size_t operator()(const T& x) const /* not noexcept */\n+    {\n+        return std::hash<T>{}(x);\n+    }\n+};\n+\n+/**\n+ * Generic struct with customizeable size and alignment.\n+ */\n+template <size_t ALIGNMENT, size_t SIZE>\n+struct alignas(ALIGNMENT) AlignedSize {\n+    char data[SIZE];\n+};\n+\n+#endif // BITCOIN_TEST_NODE_ALLOCATOR_HELPERS_H"
      },
      {
        "sha": "2224a91c1e3397dde88cd4e018168b25f0f190f2",
        "filename": "src/test/node_size_tests.cpp",
        "status": "added",
        "additions": 110,
        "deletions": 0,
        "changes": 110,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/119c3b90d6b7e9b81915a09f5ca5370f2ef1ea57/src/test/node_size_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/119c3b90d6b7e9b81915a09f5ca5370f2ef1ea57/src/test/node_size_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/node_size_tests.cpp?ref=119c3b90d6b7e9b81915a09f5ca5370f2ef1ea57",
        "patch": "@@ -0,0 +1,110 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator/node_size.h>\n+#include <test/node_allocator_helpers.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <tuple>\n+#include <typeindex>\n+#include <unordered_map>\n+\n+namespace {\n+\n+struct AllocationInfo {\n+    AllocationInfo(size_t size) : size(size) {}\n+\n+    const size_t size{};\n+    size_t num_allocations{};\n+};\n+\n+/**\n+ * Singleton used by CountSingleAllocationsAllocator to record allocations for each type\n+ */\n+std::unordered_map<std::type_index, AllocationInfo>& SingletonAllocationInfo()\n+{\n+    static std::unordered_map<std::type_index, AllocationInfo> map{};\n+    return map;\n+}\n+\n+/**\n+ * A minimal allocator that records all n==1 allocations into SingletonAllocationInfo().\n+ * That way we can actually find out the size of the allocated nodes.\n+ */\n+template <typename T>\n+struct CountSingleAllocationsAllocator {\n+public:\n+    using value_type = T;\n+    using propagate_on_container_move_assignment = std::true_type;\n+    using is_always_equal = std::true_type;\n+\n+    CountSingleAllocationsAllocator() = default;\n+    CountSingleAllocationsAllocator(const CountSingleAllocationsAllocator&) noexcept = default;\n+\n+    template <typename U>\n+    CountSingleAllocationsAllocator(CountSingleAllocationsAllocator<U> const&) noexcept\n+    {\n+    }\n+\n+    T* allocate(size_t n)\n+    {\n+        if (n == 1) {\n+            auto [it, isInserted] = SingletonAllocationInfo().try_emplace(std::type_index(typeid(T)), sizeof(T));\n+            it->second.num_allocations += 1;\n+        }\n+        return static_cast<T*>(::operator new(n * sizeof(T)));\n+    }\n+\n+    void deallocate(T* p, size_t n)\n+    {\n+        ::operator delete(p);\n+    }\n+};\n+\n+template <typename Key, typename Value, typename Hash = std::hash<Key>>\n+void TestCorrectNodeSize()\n+{\n+    std::unordered_map<Key, Value, Hash, std::equal_to<Key>, CountSingleAllocationsAllocator<std::pair<const Key, Value>>> map;\n+\n+    SingletonAllocationInfo().clear();\n+\n+    const size_t num_entries = 123;\n+    for (size_t i = 0; i < num_entries; ++i) {\n+        map[i];\n+    }\n+\n+    // there should be a entry with exactly 123 allocations\n+    auto it = std::find_if(SingletonAllocationInfo().begin(), SingletonAllocationInfo().end(), [](const auto& kv) {\n+        return kv.second.num_allocations == 123;\n+    });\n+    BOOST_CHECK(it != SingletonAllocationInfo().end());\n+\n+    auto node_size = node_allocator::NodeSize<std::unordered_map<Key, Value, Hash>>::Value();\n+    BOOST_CHECK_EQUAL(it->second.size, node_size);\n+}\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_SUITE(node_size_tests)\n+\n+using MappedTypes = std::tuple<uint8_t, uint16_t, uint32_t, uint64_t, std::string, AlignedSize<16, 16>>;\n+\n+BOOST_AUTO_TEST_CASE_TEMPLATE(node_sizes, T, MappedTypes)\n+{\n+    TestCorrectNodeSize<uint8_t, T>();\n+    TestCorrectNodeSize<uint8_t, T, NotNoexceptHash<uint8_t>>();\n+\n+    TestCorrectNodeSize<uint16_t, T>();\n+    TestCorrectNodeSize<uint16_t, T, NotNoexceptHash<uint16_t>>();\n+\n+    TestCorrectNodeSize<uint32_t, T>();\n+    TestCorrectNodeSize<uint32_t, T, NotNoexceptHash<uint32_t>>();\n+\n+    TestCorrectNodeSize<uint64_t, T>();\n+    TestCorrectNodeSize<uint64_t, T, NotNoexceptHash<uint64_t>>();\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "551e659648067820f718e97cc17d8d7fec2f6c0b",
    "node_id": "C_kwDOABII59oAKDU1MWU2NTk2NDgwNjc4MjBmNzE4ZTk3Y2MxN2Q4ZDdmZWMyZjZjMGI",
    "commit": {
      "author": {
        "name": "Martin Leitner-Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2021-11-13T18:02:12Z"
      },
      "committer": {
        "name": "Martin Leitner-Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2021-11-15T20:17:15Z"
      },
      "message": "Make use of node_allocator::NodeSize in DynamicUsage\n\nMakes use of the new NodeSize calculation in memusage::DynamicUsage\nso that the memory usage is more accurate.",
      "tree": {
        "sha": "53ac7f9c763e5b5252e8f0cbcde09b0d41530dd5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/53ac7f9c763e5b5252e8f0cbcde09b0d41530dd5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/551e659648067820f718e97cc17d8d7fec2f6c0b",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCAAdFiEEqyQrdqB7R6j2Hv2k++qtf8b//oEFAmGSwEsACgkQ++qtf8b/\n/oF7/wv/YzyyGoD5zMwGsJReaYsEdQhmaNgThdkdlUYQ6RyNeHZG+fqiQPm1/0vU\nQsuIfENUsk2Dz80ulMhUH7TQ1PXzspNKfMQ/vPWruqyfjgpcaUR4FO66p0T2xsyJ\nrKdQHugFWPIZUglg9NMURe9kvg1ovoVlfYrnUurbFkwNLE+m43J/2+t6C0SSuibt\nO6yvd9U9Im4KXl5AoEgZh/jeIQfT+kTyMKWw/sC7Noq9u8ovh6m5HZOo1r4GYJP/\n5KwFfJ34LHZTIKNhLkdUsqRts7zykL5JVKYrGAwmX7K3BsTYaOQ3TRvXW0uasI7L\nlgCUO2ef9OTCevg9/I6QOCw0mPnNyi4BTZrxicRTpgGOpuhGtssJtMjEorPwx0/Z\n7eEhIH815gPZ1g/4hijWZPS+jAlUhFdiuqv8S4TiCBwJvf5dvkka6WOVBYAVrW2G\nNAbH9RwNOAmH1fWkNCZRj3rcypjsEiomNO8rgx5Bm5v8mLyiCPWjPd1Ny8yWvVcc\ncJJ5NZJ/\n=c9aw\n-----END PGP SIGNATURE-----",
        "payload": "tree 53ac7f9c763e5b5252e8f0cbcde09b0d41530dd5\nparent 119c3b90d6b7e9b81915a09f5ca5370f2ef1ea57\nauthor Martin Leitner-Ankerl <martin.ankerl@gmail.com> 1636826532 +0100\ncommitter Martin Leitner-Ankerl <martin.ankerl@gmail.com> 1637007435 +0100\n\nMake use of node_allocator::NodeSize in DynamicUsage\n\nMakes use of the new NodeSize calculation in memusage::DynamicUsage\nso that the memory usage is more accurate.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/551e659648067820f718e97cc17d8d7fec2f6c0b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/551e659648067820f718e97cc17d8d7fec2f6c0b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/551e659648067820f718e97cc17d8d7fec2f6c0b/comments",
    "author": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "119c3b90d6b7e9b81915a09f5ca5370f2ef1ea57",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/119c3b90d6b7e9b81915a09f5ca5370f2ef1ea57",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/119c3b90d6b7e9b81915a09f5ca5370f2ef1ea57"
      }
    ],
    "stats": {
      "total": 8,
      "additions": 5,
      "deletions": 3
    },
    "files": [
      {
        "sha": "b9dc0764a6088da743ecd528fb4219e401063476",
        "filename": "src/memusage.h",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/551e659648067820f718e97cc17d8d7fec2f6c0b/src/memusage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/551e659648067820f718e97cc17d8d7fec2f6c0b/src/memusage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/memusage.h?ref=551e659648067820f718e97cc17d8d7fec2f6c0b",
        "patch": "@@ -7,6 +7,7 @@\n \n #include <indirectmap.h>\n #include <prevector.h>\n+#include <support/allocators/node_allocator/node_size.h>\n \n #include <stdlib.h>\n \n@@ -161,10 +162,11 @@ static inline size_t DynamicUsage(const std::unordered_set<X, Y>& s)\n     return MallocUsage(sizeof(unordered_node<X>)) * s.size() + MallocUsage(sizeof(void*) * s.bucket_count());\n }\n \n-template<typename X, typename Y, typename Z>\n-static inline size_t DynamicUsage(const std::unordered_map<X, Y, Z>& m)\n+template <typename Key, typename Value, typename Hash, typename Equals>\n+static inline size_t DynamicUsage(const std::unordered_map<Key, Value, Hash, Equals>& m)\n {\n-    return MallocUsage(sizeof(unordered_node<std::pair<const X, Y> >)) * m.size() + MallocUsage(sizeof(void*) * m.bucket_count());\n+    auto node_size = node_allocator::NodeSize<std::unordered_map<Key, Value, Hash, Equals>>::Value();\n+    return MallocUsage(node_size) * m.size() + MallocUsage(sizeof(void*) * m.bucket_count());\n }\n \n }"
      }
    ]
  },
  {
    "sha": "96d8e33acaa079491403d8e8afa6709978dec205",
    "node_id": "C_kwDOABII59oAKDk2ZDhlMzNhY2FhMDc5NDkxNDAzZDhlOGFmYTY3MDk5NzhkZWMyMDU",
    "commit": {
      "author": {
        "name": "Martin Leitner-Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2021-11-13T18:15:43Z"
      },
      "committer": {
        "name": "Martin Leitner-Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2021-11-15T20:17:16Z"
      },
      "message": "Add allocator for node based containers\n\nThis allocator is potentially useful for all node-based containers like\n`std::list`, `std::map`, `std::unordered_map` that are heavily used.\n\nThe allocator uses pools to be more memory efficient and faster than\nthe default std::allocator. Currently this provides specializations for\n`std::unordered_map`, and other specializations can be added as needed.\n\nThis updates the `memusage::DynamicUsage` calculation to take the\nnode_allocator allocator into account.\n\nAlso, the dynamic usage for standard `std::unordered_map` is made more\naccurate with the new node_size calculation.\n\nRule of 5, drop unused function, spelling fixups and more code cleanup\nby jonatack, countless suggestions & improvements by ryanofsky.\n\nCo-authored-by: Jon Atack <jon@atack.com>\nCo-authored-by: Russell Yanofsky <russ@yanofsky.org>",
      "tree": {
        "sha": "9a2f407404312e1664cab22d068c6f975d511d0b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9a2f407404312e1664cab22d068c6f975d511d0b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/96d8e33acaa079491403d8e8afa6709978dec205",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCAAdFiEEqyQrdqB7R6j2Hv2k++qtf8b//oEFAmGSwEwACgkQ++qtf8b/\n/oGqrAwAhW5EdA/dwViXPNEDFxhrMWyiQPa56HyrFEjp84zuVRKvKjxMtKQxLbhG\nIMqF5Z03ODiaRQkdZWW1054p/ZFuOgOlQhPUXsX6QgkjXfv/qAHJa5twBaz7Uy/D\nBmYWpMDyOoRwxDzSU4pOar4slvHC1QXfIEHhPUQRgzr+MptPF7FfIjs+jlG0SY9P\n+qc5w5AM//IJ8AiveC0xVY6RmirffFq8TwKBqmJjBcsduPpoPlL3laM61/GG/0Lf\ni/zOq7D3P9mivTnhqlJ/reT2fhyN2osK97jmfXk+bAZuMMfMZh7WXevBfQI8bYnb\nNjNIqqnOmjHiGKkwk5KpsEZPKzu4vMSO8MVuFRfZP04M/hq/q3t4Xi8uHuar+037\n8X6/cDIV07tRZuWa+WfjszC1Vzx0i+ZtKKrieUDypSGBOg4HSP3EH4cJuwaWjEtf\nHyK1/bwjr14kJ6CxFRz/ijLXyReuRJWw/elWQo5dZZWkXaEmamWiWwt+4BCm54WQ\nYCQPk6kF\n=D5Pt\n-----END PGP SIGNATURE-----",
        "payload": "tree 9a2f407404312e1664cab22d068c6f975d511d0b\nparent 551e659648067820f718e97cc17d8d7fec2f6c0b\nauthor Martin Leitner-Ankerl <martin.ankerl@gmail.com> 1636827343 +0100\ncommitter Martin Leitner-Ankerl <martin.ankerl@gmail.com> 1637007436 +0100\n\nAdd allocator for node based containers\n\nThis allocator is potentially useful for all node-based containers like\n`std::list`, `std::map`, `std::unordered_map` that are heavily used.\n\nThe allocator uses pools to be more memory efficient and faster than\nthe default std::allocator. Currently this provides specializations for\n`std::unordered_map`, and other specializations can be added as needed.\n\nThis updates the `memusage::DynamicUsage` calculation to take the\nnode_allocator allocator into account.\n\nAlso, the dynamic usage for standard `std::unordered_map` is made more\naccurate with the new node_size calculation.\n\nRule of 5, drop unused function, spelling fixups and more code cleanup\nby jonatack, countless suggestions & improvements by ryanofsky.\n\nCo-authored-by: Jon Atack <jon@atack.com>\nCo-authored-by: Russell Yanofsky <russ@yanofsky.org>\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/96d8e33acaa079491403d8e8afa6709978dec205",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/96d8e33acaa079491403d8e8afa6709978dec205",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/96d8e33acaa079491403d8e8afa6709978dec205/comments",
    "author": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "551e659648067820f718e97cc17d8d7fec2f6c0b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/551e659648067820f718e97cc17d8d7fec2f6c0b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/551e659648067820f718e97cc17d8d7fec2f6c0b"
      }
    ],
    "stats": {
      "total": 920,
      "additions": 920,
      "deletions": 0
    },
    "files": [
      {
        "sha": "b39d03fe8cb245cac4b3f8007637d1b7b5f82304",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96d8e33acaa079491403d8e8afa6709978dec205/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96d8e33acaa079491403d8e8afa6709978dec205/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=96d8e33acaa079491403d8e8afa6709978dec205",
        "patch": "@@ -217,6 +217,10 @@ BITCOIN_CORE_H = \\\n   shutdown.h \\\n   signet.h \\\n   streams.h \\\n+  support/allocators/node_allocator/allocator_fwd.h \\\n+  support/allocators/node_allocator/allocator.h \\\n+  support/allocators/node_allocator/factory.h \\\n+  support/allocators/node_allocator/memory_resource.h \\\n   support/allocators/node_allocator/node_size.h \\\n   support/allocators/secure.h \\\n   support/allocators/zeroafterfree.h \\\n@@ -571,6 +575,7 @@ libbitcoin_util_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n libbitcoin_util_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libbitcoin_util_a_SOURCES = \\\n   support/lockedpool.cpp \\\n+  support/allocators/node_allocator/memory_resource.cpp \\\n   chainparamsbase.cpp \\\n   clientversion.cpp \\\n   compat/glibcxx_sanity.cpp \\"
      },
      {
        "sha": "9f03935e8b0c78ead270e26515acd4d86c890a3b",
        "filename": "src/Makefile.bench.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96d8e33acaa079491403d8e8afa6709978dec205/src/Makefile.bench.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96d8e33acaa079491403d8e8afa6709978dec205/src/Makefile.bench.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.bench.include?ref=96d8e33acaa079491403d8e8afa6709978dec205",
        "patch": "@@ -35,6 +35,7 @@ bench_bench_bitcoin_SOURCES = \\\n   bench/mempool_stress.cpp \\\n   bench/nanobench.h \\\n   bench/nanobench.cpp \\\n+  bench/node_allocator.cpp \\\n   bench/peer_eviction.cpp \\\n   bench/rpc_blockchain.cpp \\\n   bench/rpc_mempool.cpp \\"
      },
      {
        "sha": "79ca59458787cb2a5e8dc23950561231f2aa86b8",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96d8e33acaa079491403d8e8afa6709978dec205/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96d8e33acaa079491403d8e8afa6709978dec205/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=96d8e33acaa079491403d8e8afa6709978dec205",
        "patch": "@@ -110,6 +110,7 @@ BITCOIN_TESTS =\\\n   test/net_tests.cpp \\\n   test/netbase_tests.cpp \\\n   test/node_allocator_helpers.h \\\n+  test/node_allocator_tests.cpp \\\n   test/node_size_tests.cpp \\\n   test/pmt_tests.cpp \\\n   test/policy_fee_tests.cpp \\"
      },
      {
        "sha": "bd78fa10c27ec484e0516b7bda8ec46ca2add9f4",
        "filename": "src/bench/node_allocator.cpp",
        "status": "added",
        "additions": 45,
        "deletions": 0,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96d8e33acaa079491403d8e8afa6709978dec205/src/bench/node_allocator.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96d8e33acaa079491403d8e8afa6709978dec205/src/bench/node_allocator.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/node_allocator.cpp?ref=96d8e33acaa079491403d8e8afa6709978dec205",
        "patch": "@@ -0,0 +1,45 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+#include <support/allocators/node_allocator/factory.h>\n+\n+#include <cstring>\n+#include <unordered_map>\n+\n+template <typename Map>\n+void BenchFillClearMap(benchmark::Bench& bench, Map& map)\n+{\n+    size_t batch_size = 5000;\n+\n+    // make sure each iteration of the benchmark contains exactly 5000 inserts and one clear.\n+    // do this at least 10 times so we get reasonable accurate results\n+\n+    bench.batch(batch_size).minEpochIterations(10).run([&] {\n+        uint64_t key = 0;\n+        for (size_t i = 0; i < batch_size; ++i) {\n+            // add a random number for better spread in the map\n+            key += 0x967f29d1;\n+            map[key];\n+        }\n+        map.clear();\n+    });\n+}\n+\n+static void NodeAllocator_StdUnorderedMap(benchmark::Bench& bench)\n+{\n+    auto map = std::unordered_map<uint64_t, uint64_t>();\n+    BenchFillClearMap(bench, map);\n+}\n+\n+static void NodeAllocator_StdUnorderedMapWithNodeAllocator(benchmark::Bench& bench)\n+{\n+    using Factory = node_allocator::Factory<std::unordered_map<uint64_t, uint64_t>>;\n+    Factory::MemoryResourceType memory_resource{};\n+    auto map = Factory::CreateContainer(&memory_resource);\n+    BenchFillClearMap(bench, map);\n+}\n+\n+BENCHMARK(NodeAllocator_StdUnorderedMap);\n+BENCHMARK(NodeAllocator_StdUnorderedMapWithNodeAllocator);"
      },
      {
        "sha": "bc20ee4052c7693fa0dda250d2db21e6387cc88d",
        "filename": "src/memusage.h",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96d8e33acaa079491403d8e8afa6709978dec205/src/memusage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96d8e33acaa079491403d8e8afa6709978dec205/src/memusage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/memusage.h?ref=96d8e33acaa079491403d8e8afa6709978dec205",
        "patch": "@@ -7,6 +7,7 @@\n \n #include <indirectmap.h>\n #include <prevector.h>\n+#include <support/allocators/node_allocator/allocator_fwd.h>\n #include <support/allocators/node_allocator/node_size.h>\n \n #include <stdlib.h>\n@@ -169,6 +170,14 @@ static inline size_t DynamicUsage(const std::unordered_map<Key, Value, Hash, Equ\n     return MallocUsage(node_size) * m.size() + MallocUsage(sizeof(void*) * m.bucket_count());\n }\n \n+template <typename Key, typename Value, typename Hash, typename Equals, typename AllocT, size_t AllocS>\n+static inline size_t DynamicUsage(const std::unordered_map<Key, Value, Hash, Equals, node_allocator::Allocator<AllocT, AllocS>>& m)\n+{\n+    // Since node_allocator is used, the memory of the nodes are the MemoryResource's responsibility and\n+    // won't be added here. Also multiple maps could use the same MemoryResource.\n+    return MallocUsage(sizeof(void*) * m.bucket_count());\n+}\n+\n }\n \n #endif // BITCOIN_MEMUSAGE_H"
      },
      {
        "sha": "778471bb20be0b426c900446b5173af755a885d6",
        "filename": "src/support/allocators/node_allocator/allocator.h",
        "status": "added",
        "additions": 222,
        "deletions": 0,
        "changes": 222,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96d8e33acaa079491403d8e8afa6709978dec205/src/support/allocators/node_allocator/allocator.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96d8e33acaa079491403d8e8afa6709978dec205/src/support/allocators/node_allocator/allocator.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/support/allocators/node_allocator/allocator.h?ref=96d8e33acaa079491403d8e8afa6709978dec205",
        "patch": "@@ -0,0 +1,222 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_ALLOCATOR_H\n+\n+#include <support/allocators/node_allocator/allocator_fwd.h>\n+#include <support/allocators/node_allocator/memory_resource.h>\n+\n+#include <cstdint>\n+#include <new>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based\n+ * containers that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs pools of memory and uses these to carve out memory for the nodes. Nodes\n+ * that are freed by the Allocator are actually put back into a free list for further use. This\n+ * behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored\n+ * in-place. This typically saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with\n+ * low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but\n+ * there is no standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to\n+ * the system. Memory is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on\n+ * proximity. So freeing and malloc'ing again can become a random access pattern which can lead to\n+ * more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers.\n+ * Similar to `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages memory. Currently\n+ * it is only able to provide optimized alloc/free for a single fixed allocation size which is given\n+ * in the constructor. Only allocations that match this size will be provided from the preallocated\n+ * pools of memory; all other requests simply use `::operator new()`. Using node_allocator with a\n+ * standard container types like std::list, std::unordered_map requires knowing node sizes of those\n+ * containers which are non-standard implementation details. The \\ref memusage::NodeSize trait and\n+ * \\ref node_allocator::Factory class can be used to help with this.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios\n+ * in `node_allocator_tests/test_allocations_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d\n+ *   https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d\n+ *   https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *   https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Allocator that's usable for node-based containers like std::unordered_map or std::list.\n+ *\n+ * The allocator is stateful, and can be cheaply copied. Its state is an immobile MemoryResource,\n+ * which actually does all the allocation/deallocations. So this class is just a simple wrapper that\n+ * conforms to the required STL interface to be usable for the node-based containers.\n+ */\n+template <typename T, size_t ALLOCATION_SIZE_BYTES>\n+class Allocator\n+{\n+    template <typename U, size_t AS>\n+    friend class Allocator;\n+\n+    template <typename X, typename Y, size_t AS>\n+    friend bool operator==(const Allocator<X, AS>& a, const Allocator<Y, AS>& b) noexcept;\n+\n+public:\n+    using value_type = T;\n+\n+    /**\n+     * The allocator is stateful so we can't use the compile time `is_always_equal` optimization and\n+     * have to use the runtime operator==.\n+     */\n+    using is_always_equal = std::false_type;\n+\n+    /**\n+     * Move assignment should be a fast operation. In the case of a = std::move(b), we want\n+     * a to be able to use b's allocator, otherwise all elements would have to be recreated with a's\n+     * old allocator.\n+     */\n+    using propagate_on_container_move_assignment = std::true_type;\n+\n+    /**\n+     * The default for propagate_on_container_swap is std::false_type. This is bad,because swapping\n+     * two containers with unequal allocators but not propagating the allocator is undefined\n+     * behavior! Obviously, we want so swap the allocator as well, so we set that to true.\n+     *\n+     * see https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+     */\n+    using propagate_on_container_swap = std::true_type; // to avoid the undefined behavior\n+\n+    /**\n+     * Move and swap have to propagate the allocator, so for consistency we do the same for copy\n+     * assignment.\n+     */\n+    using propagate_on_container_copy_assignment = std::true_type;\n+\n+    /**\n+     * Construct a new Allocator object which will delegate all allocations/deallocations to the\n+     * memory resource.\n+     */\n+    explicit Allocator(MemoryResource<ALLOCATION_SIZE_BYTES>* memory_resource) noexcept\n+        : m_memory_resource(memory_resource)\n+    {\n+    }\n+\n+    /**\n+     * Conversion constructor for rebinding. All Allocators use the same memory_resource.\n+     *\n+     * The rebound type is determined with the `struct rebind`. The rebind is necessary feature\n+     * for standard allocators, and it happens when the allocator shall be used for different types.\n+     * E.g. for std::unordered_map this happens for allocation of the internally used nodes, for the\n+     * underlying index array, and possibly for some control structure. In fact the type required by\n+     * the standard `std::pair<const Key, Value>` type is never actually used for any allocation\n+     * (which is therefore a stupid requirement, but that's just C++ being C++).\n+     */\n+    template <typename U>\n+    Allocator(const Allocator<U, ALLOCATION_SIZE_BYTES>& other) noexcept\n+        : m_memory_resource(other.m_memory_resource)\n+    {\n+    }\n+\n+    /**\n+     * From the standard: rebind is only optional (provided by std::allocator_traits) if this\n+     * allocator is a template of the form SomeAllocator<T, Args>, where Args is zero or more\n+     * additional template type parameters.\n+     *\n+     * Since we use a size_t as additional argument, it's *not* optional.\n+     * @see https://en.cppreference.com/w/cpp/named_req/Allocator#cite_note-2\n+     */\n+    template <typename U>\n+    struct rebind {\n+        using other = Allocator<U, ALLOCATION_SIZE_BYTES>;\n+    };\n+\n+    /**\n+     * Allocates n entries of the given type.\n+     */\n+    T* allocate(size_t n)\n+    {\n+        if constexpr (ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>()) {\n+            if (n != 1) {\n+                // pool is not used so forward to operator new.\n+                return static_cast<T*>(::operator new(n * sizeof(T)));\n+            }\n+\n+            // Forward all allocations to the memory_resource\n+            return m_memory_resource->template Allocate<T>();\n+        } else {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+    }\n+\n+    /**\n+     * Deallocates n entries of the given type.\n+     */\n+    void deallocate(T* p, size_t n)\n+    {\n+        if constexpr (ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>()) {\n+            if (n != 1) {\n+                // allocation didn't happen with the pool\n+                ::operator delete(p);\n+                return;\n+            }\n+            m_memory_resource->template Deallocate<T>(p);\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+private:\n+    //! Stateful allocator, where the state is a simple pointer that can be cheaply copied.\n+    MemoryResource<ALLOCATION_SIZE_BYTES>* m_memory_resource;\n+};\n+\n+\n+/**\n+ * Since Allocator is stateful, comparison with another one only returns true if it uses the same\n+ * memory_resource.\n+ */\n+template <typename T, typename U, size_t CS>\n+bool operator==(const Allocator<T, CS>& a, const Allocator<U, CS>& b) noexcept\n+{\n+    // \"Equality of an allocator is determined through the ability of allocating memory with one\n+    // allocator and deallocating it with another.\" - Jonathan M\u00fcller\n+    // See https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+    //\n+    // For us that is the case when both allocators use the same memory resource.\n+    return a.m_memory_resource == b.m_memory_resource;\n+}\n+\n+template <typename T, typename U, size_t CS>\n+bool operator!=(const Allocator<T, CS>& a, const Allocator<U, CS>& b) noexcept\n+{\n+    return !(a == b);\n+}\n+\n+} // namespace node_allocator\n+\n+#endif // BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_ALLOCATOR_H"
      },
      {
        "sha": "e3fa0ddd8899f15bd1ef564007cba1ce6ea42cdd",
        "filename": "src/support/allocators/node_allocator/allocator_fwd.h",
        "status": "added",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96d8e33acaa079491403d8e8afa6709978dec205/src/support/allocators/node_allocator/allocator_fwd.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96d8e33acaa079491403d8e8afa6709978dec205/src/support/allocators/node_allocator/allocator_fwd.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/support/allocators/node_allocator/allocator_fwd.h?ref=96d8e33acaa079491403d8e8afa6709978dec205",
        "patch": "@@ -0,0 +1,17 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_ALLOCATOR_FWD_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_ALLOCATOR_FWD_H\n+\n+#include <cstddef>\n+\n+namespace node_allocator {\n+\n+template <typename T, size_t ALLOCATION_SIZE_BYTES>\n+class Allocator;\n+\n+} // namespace node_allocator\n+\n+#endif // BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_ALLOCATOR_FWD_H"
      },
      {
        "sha": "38333d9475828d82102e51bebe9c679781dfa326",
        "filename": "src/support/allocators/node_allocator/factory.h",
        "status": "added",
        "additions": 52,
        "deletions": 0,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96d8e33acaa079491403d8e8afa6709978dec205/src/support/allocators/node_allocator/factory.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96d8e33acaa079491403d8e8afa6709978dec205/src/support/allocators/node_allocator/factory.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/support/allocators/node_allocator/factory.h?ref=96d8e33acaa079491403d8e8afa6709978dec205",
        "patch": "@@ -0,0 +1,52 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_FACTORY_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_FACTORY_H\n+\n+#include <support/allocators/node_allocator/allocator.h>\n+#include <support/allocators/node_allocator/node_size.h>\n+\n+#include <cassert>\n+#include <unordered_map>\n+\n+namespace node_allocator {\n+\n+/**\n+ * Generic factory to create node_allocator based containers.\n+ */\n+template <typename Container>\n+class Factory;\n+\n+/**\n+ * Helper to create std::unordered_map which uses the node_allocator.\n+ *\n+ * This calculates the size of the container's internally used node correctly for all supported\n+ * platforms, which is also asserted by the unit tests.\n+ */\n+template <typename Key, typename Value, typename Hash, typename Equals>\n+class Factory<std::unordered_map<Key, Value, Hash, Equals>>\n+{\n+    using BaseContainerType = std::unordered_map<Key, Value, Hash, Equals>;\n+    using ValueType = typename BaseContainerType::value_type;\n+    static constexpr size_t ALLOCATION_SIZE_BYTES = detail::RequiredAllocationSizeBytes<typename NodeSize<BaseContainerType>::SimulatedNodeType>();\n+\n+public:\n+    using MemoryResourceType = MemoryResource<ALLOCATION_SIZE_BYTES>;\n+    using AllocatorType = Allocator<std::pair<const Key, Value>, ALLOCATION_SIZE_BYTES>;\n+    using ContainerType = std::unordered_map<Key, Value, Hash, Equals, AllocatorType>;\n+\n+    /**\n+     * Creates the std::unordered_map container, and asserts that the specified memory_resource is correct.\n+     */\n+    [[nodiscard]] static ContainerType CreateContainer(MemoryResourceType* memory_resource)\n+    {\n+        assert(memory_resource != nullptr);\n+        return ContainerType{0, Hash{}, Equals{}, AllocatorType{memory_resource}};\n+    }\n+};\n+\n+} // namespace node_allocator\n+\n+#endif // BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_FACTORY_H"
      },
      {
        "sha": "368752fa2b98f72b7f5a5ed4911cda76d8353e97",
        "filename": "src/support/allocators/node_allocator/memory_resource.cpp",
        "status": "added",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96d8e33acaa079491403d8e8afa6709978dec205/src/support/allocators/node_allocator/memory_resource.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96d8e33acaa079491403d8e8afa6709978dec205/src/support/allocators/node_allocator/memory_resource.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/support/allocators/node_allocator/memory_resource.cpp?ref=96d8e33acaa079491403d8e8afa6709978dec205",
        "patch": "@@ -0,0 +1,12 @@\n+#include <support/allocators/node_allocator/memory_resource.h>\n+\n+#include <memusage.h>\n+\n+namespace node_allocator::detail {\n+\n+size_t DynamicMemoryUsage(size_t pool_size_bytes, std::vector<std::unique_ptr<char[]>> const& allocated_pools)\n+{\n+    return memusage::MallocUsage(pool_size_bytes) * allocated_pools.size() + memusage::DynamicUsage(allocated_pools);\n+}\n+\n+} // namespace node_allocator::detail"
      },
      {
        "sha": "f4ba01389243fe23958cebdf8e7382d6b535c893",
        "filename": "src/support/allocators/node_allocator/memory_resource.h",
        "status": "added",
        "additions": 196,
        "deletions": 0,
        "changes": 196,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96d8e33acaa079491403d8e8afa6709978dec205/src/support/allocators/node_allocator/memory_resource.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96d8e33acaa079491403d8e8afa6709978dec205/src/support/allocators/node_allocator/memory_resource.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/support/allocators/node_allocator/memory_resource.h?ref=96d8e33acaa079491403d8e8afa6709978dec205",
        "patch": "@@ -0,0 +1,196 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cstddef>\n+#include <memory>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_MEMORY_RESOURCE_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_MEMORY_RESOURCE_H\n+\n+namespace node_allocator {\n+\n+namespace detail {\n+\n+/**\n+ * In-place linked list of the allocations, used for the free list.\n+ */\n+struct FreeList {\n+    FreeList* next;\n+};\n+\n+static_assert(std::is_trivially_destructible_v<FreeList>, \"make sure we don't need to manually destruct the FreeList\");\n+\n+/**\n+ * Calculates the required allocation size for the given type.\n+ * The memory needs to be correctly aligned and large enough for both both T and FreeList.\n+ */\n+template <typename T>\n+[[nodiscard]] constexpr size_t RequiredAllocationSizeBytes() noexcept\n+{\n+    const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<FreeList>);\n+    const auto size_max = std::max(sizeof(T), sizeof(FreeList));\n+\n+    // find closest multiple of alignment_max that holds size_max\n+    return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+}\n+\n+/**\n+ * Calculates dynamic memory usage of a MemoryResource. Not a member of MemoryResource so we can implement this\n+ * in a cpp and don't depend on memusage.h in the header.\n+ */\n+[[nodiscard]] size_t DynamicMemoryUsage(size_t pool_size_bytes, std::vector<std::unique_ptr<char[]>> const& allocated_pools);\n+\n+} // namespace detail\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It\n+ * stores a number of memory pools which are used to quickly give out memory of a fixed allocation\n+ * size. The class is purposely kept very simple. It only knows about \"Allocations\" and \"Pools\".\n+ *\n+ * - Pool: MemoryResource allocates one memory pool at a time. These pools are kept around until the\n+ * memory resource is destroyed.\n+ *\n+ * - Allocations: Node-based containers allocate one node at a time. Whenever that happens, the\n+ * MemoryResource's Allocate() gives out memory for one node. These are carved out from a previously\n+ * allocated memory pool, or from a free list if it contains entries. Whenever a node is given back\n+ * with Deallocate(), it is put into that free list.\n+ */\n+template <size_t ALLOCATION_SIZE_BYTES>\n+class MemoryResource\n+{\n+    /**\n+     * Size in bytes to allocate per pool, currently hardcoded to multiple of ALLOCATION_SIZE_BYTES\n+     * that comes closest to 256 KiB.\n+     */\n+    static constexpr size_t POOL_SIZE_BYTES = (262144 / ALLOCATION_SIZE_BYTES) * ALLOCATION_SIZE_BYTES;\n+\n+public:\n+    /**\n+     * Construct a new MemoryResource object that uses the specified allocation size to optimize for.\n+     */\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated pools.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling\n+     * clear() on an unordered_map, it is not certain that all allocated nodes are given back to the\n+     * MemoryResource. Microsoft's STL still uses a control structure that might have the same size\n+     * as the nodes, and therefore needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() = default;\n+\n+    /**\n+     * Allocates memory for sizeof(T).\n+     *\n+     * @tparam T Object to allocate memory for.\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate()\n+    {\n+        static_assert(ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>());\n+        static_assert(__STDCPP_DEFAULT_NEW_ALIGNMENT__ >= std::alignment_of_v<T>, \"make sure AllocatePool() aligns correctly\");\n+\n+        if (m_free_allocations) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_allocations;\n+            m_free_allocations = m_free_allocations->next;\n+            return reinterpret_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one allocation from allocated pool memory.\n+        // It makes sense to not create the fully linked list of an allocated pool up-front, for\n+        // several reasons. On the one hand, the latency is higher when we need to iterate and\n+        // update pointers for the whole pool at once. More importantly, most systems lazily\n+        // allocate data. So when we allocate a big pool of memory the memory for a page is only\n+        // actually made available to the program when it is first touched. So when we allocate\n+        // a big pool and only use very little memory from it, the total memory usage is lower\n+        // than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new pool needs to be allocated\n+            AllocatePool();\n+        }\n+\n+        // peel off one allocation from the untouched memory. The next pointer of in-use\n+        // elements doesn't matter until it is deallocated, only then it is used to form the\n+        // free list.\n+        char* tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = tmp + ALLOCATION_SIZE_BYTES;\n+        return reinterpret_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list.\n+     */\n+    template <typename T>\n+    void Deallocate(void* p) noexcept\n+    {\n+        static_assert(ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>());\n+\n+        // put it into the linked list.\n+        //\n+        // Note: We can't just static_cast<detail::FreeList*>(p) because this is technically\n+        // undefined behavior. But we can use placement new instead. Correct alignment is\n+        // guaranteed by the static_asserts in Allocate().\n+        auto* const allocation = new (p) detail::FreeList;\n+        allocation->next = m_free_allocations;\n+        m_free_allocations = allocation;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        return detail::DynamicMemoryUsage(POOL_SIZE_BYTES, m_allocated_pools);\n+    }\n+\n+private:\n+    //! Access to internals for testing purpose only\n+    friend class MemoryResourceTester;\n+\n+    /**\n+     * Allocate one full memory pool which is used to carve out allocations.\n+     */\n+    void AllocatePool()\n+    {\n+        m_allocated_pools.emplace_back(new char[POOL_SIZE_BYTES]);\n+        m_untouched_memory_iterator = m_allocated_pools.back().get();\n+        m_untouched_memory_end = m_untouched_memory_iterator + POOL_SIZE_BYTES;\n+    }\n+\n+    //! Contains all allocated pools of memory, used to free the data in the destructor.\n+    std::vector<std::unique_ptr<char[]>> m_allocated_pools{};\n+\n+    //! A single linked list of all data available in the MemoryResource. This list is used for\n+    //! allocations of single elements.\n+    detail::FreeList* m_free_allocations = nullptr;\n+\n+    //! Points to the beginning of available memory for carving out allocations.\n+    char* m_untouched_memory_iterator = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to\n+     * `m_allocated_pools.back().get() + POOL_SIZE_BYTES` whenever it is accessed, but\n+     * `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    char* m_untouched_memory_end = nullptr;\n+};\n+\n+} // namespace node_allocator\n+\n+#endif // BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_MEMORY_RESOURCE_H"
      },
      {
        "sha": "27ef5d7e4958e67c2f0d7731e7eaae9862b86df5",
        "filename": "src/test/node_allocator_tests.cpp",
        "status": "added",
        "additions": 360,
        "deletions": 0,
        "changes": 360,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/96d8e33acaa079491403d8e8afa6709978dec205/src/test/node_allocator_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/96d8e33acaa079491403d8e8afa6709978dec205/src/test/node_allocator_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/node_allocator_tests.cpp?ref=96d8e33acaa079491403d8e8afa6709978dec205",
        "patch": "@@ -0,0 +1,360 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator/factory.h>\n+#include <test/node_allocator_helpers.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <list>\n+#include <map>\n+#include <string>\n+#include <type_traits>\n+#include <unordered_map>\n+\n+namespace node_allocator {\n+\n+class MemoryResourceTester\n+{\n+public:\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumFreeAllocations(\n+        MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        size_t length = 0;\n+        auto allocation = mr.m_free_allocations;\n+        while (allocation) {\n+            allocation = static_cast<detail::FreeList const*>(allocation)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory pools that have been allocated\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumPools(MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        return mr.m_allocated_pools.size();\n+    }\n+\n+\n+    /**\n+     * Extracts allocation size from the type\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static constexpr size_t AllocationSizeBytes(MemoryResource<ALLOCATION_SIZE_BYTES> const&) noexcept\n+    {\n+        return ALLOCATION_SIZE_BYTES;\n+    }\n+};\n+\n+} // namespace node_allocator\n+\n+#define CHECK_IN_RANGE(what, lower_inclusive, upper_inclusive) \\\n+    BOOST_TEST(what >= lower_inclusive);                       \\\n+    BOOST_TEST(what <= upper_inclusive);\n+\n+namespace {\n+\n+struct TwoMapsSetup {\n+    using Factory = node_allocator::Factory<std::unordered_map<uint64_t, uint64_t>>;\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    std::optional<Factory::ContainerType> map_a{};\n+    std::optional<Factory::ContainerType> map_b{};\n+\n+    TwoMapsSetup()\n+    {\n+        map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            (*map_a)[i] = i;\n+        }\n+\n+        map_b = Factory::CreateContainer(&mr_b);\n+        (*map_b)[123] = 321;\n+\n+        BOOST_CHECK(map_a->get_allocator() != map_b->get_allocator());\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 0);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+    }\n+\n+    void DestroyMapBAndCheckAfterAssignment()\n+    {\n+        // map_a now uses mr_b, since propagate_on_container_copy_assignment is std::true_type\n+        BOOST_CHECK(map_a->get_allocator() == map_b->get_allocator());\n+\n+        // With MSVC there might be an additional allocation used for a control structure, so we\n+        // can't just use BOOST_CHECK_EQUAL.\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+        // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        map_b.reset();\n+\n+        // map_b destroyed, should not have any effect on mr_b\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+        // but we'll get more free allocations in mr_a\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    }\n+};\n+\n+template <typename Key, typename Value, typename Hash = std::hash<Key>>\n+void TestAllocationsAreUsed()\n+{\n+    using Factory = node_allocator::Factory<std::unordered_map<Key, Value, Hash>>;\n+    typename Factory::MemoryResourceType mr{};\n+    BOOST_TEST_MESSAGE(\n+        strprintf(\"%u sizeof(void*), %u/%u/%u sizeof Key/Value/Pair, %u ALLOCATION_SIZE_BYTES\",\n+                  sizeof(void*), sizeof(Key), sizeof(Value), sizeof(std::pair<const Key, Value>),\n+                  node_allocator::MemoryResourceTester::AllocationSizeBytes(mr)));\n+    {\n+        auto map = Factory::CreateContainer(&mr);\n+        for (size_t i = 0; i < 5; ++i) {\n+            map[i];\n+        }\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr), 0);\n+        map.clear();\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr), 5);\n+\n+        for (size_t i = 0; i < 5; ++i) {\n+            map[i];\n+        }\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr), 0);\n+        map.clear();\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr), 5);\n+    }\n+\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr), 5, 6);\n+}\n+\n+} // namespace\n+\n+BOOST_FIXTURE_TEST_SUITE(node_allocator_tests, BasicTestingSetup)\n+\n+#define CHECK_NUMS_FREES_POOLS(mr, num_free_allocations, num_pools)                  \\\n+    BOOST_CHECK_EQUAL(num_free_allocations,                                          \\\n+                      node_allocator::MemoryResourceTester::NumFreeAllocations(mr)); \\\n+    BOOST_CHECK_EQUAL(num_pools, node_allocator::MemoryResourceTester::NumPools(mr));\n+\n+BOOST_AUTO_TEST_CASE(too_small)\n+{\n+    using T = std::pair<char, char>;\n+    node_allocator::MemoryResource<node_allocator::detail::RequiredAllocationSizeBytes<T>()> mr{};\n+    void* ptr{mr.Allocate<char>()};\n+    BOOST_CHECK(ptr != nullptr);\n+\n+    // mr is used\n+    CHECK_NUMS_FREES_POOLS(mr, 0, 1);\n+    mr.Deallocate<char>(ptr);\n+    CHECK_NUMS_FREES_POOLS(mr, 1, 1);\n+\n+    // void* works too, use freelist\n+    ptr = mr.Allocate<T>();\n+    BOOST_CHECK(ptr != nullptr);\n+    CHECK_NUMS_FREES_POOLS(mr, 0, 1);\n+    mr.Deallocate<char>(ptr);\n+    CHECK_NUMS_FREES_POOLS(mr, 1, 1);\n+}\n+\n+BOOST_AUTO_TEST_CASE(std_unordered_map)\n+{\n+    using Factory = node_allocator::Factory<std::unordered_map<uint64_t, uint64_t>>;\n+\n+    Factory::MemoryResourceType mr{};\n+    auto m = Factory::CreateContainer(&mr);\n+    size_t num_free_allocations = 0;\n+    {\n+        auto a = Factory::CreateContainer(&mr);\n+\n+        // Allocator compares equal because the same memory resource is used\n+        BOOST_CHECK(a.get_allocator() == m.get_allocator());\n+        for (uint64_t i = 0; i < 1000; ++i) {\n+            a[i] = i;\n+        }\n+\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // create a copy of the map, destroy the map => now a lot more free allocations should be\n+        // available\n+        {\n+            auto b = a;\n+        }\n+\n+        BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >=\n+                    num_free_allocations + 1000);\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // creating another copy, and then destroying everything should reuse all the allocations\n+        {\n+            auto b = a;\n+        }\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr),\n+                          num_free_allocations);\n+\n+        // moving the map should not create new nodes\n+        m = std::move(a);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr),\n+                          num_free_allocations);\n+    }\n+\n+    // a is destroyed, still all allocations should stay roughly the same because its contents were\n+    // moved to m which is still alive\n+    BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) <=\n+                num_free_allocations + 5);\n+\n+    num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+    m = Factory::CreateContainer(&mr);\n+\n+    // now that m is replaced its content is freed\n+    BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >=\n+                num_free_allocations + 1000);\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(different_memoryresource_assignment, TwoMapsSetup)\n+{\n+    map_b = map_a;\n+\n+    DestroyMapBAndCheckAfterAssignment();\n+\n+    // finally map_a is destroyed, getting more free allocations.\n+    map_a.reset();\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 200U, 202U);\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(different_memoryresource_move, TwoMapsSetup)\n+{\n+    map_b = std::move(map_a);\n+\n+    DestroyMapBAndCheckAfterAssignment();\n+\n+    // finally map_a is destroyed, but since it was moved, no more free allocations.\n+    map_a.reset();\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 102U);\n+}\n+\n+\n+BOOST_FIXTURE_TEST_CASE(different_memoryresource_swap, TwoMapsSetup)\n+{\n+    auto alloc_a = map_a->get_allocator();\n+    auto alloc_b = map_b->get_allocator();\n+\n+    std::swap(map_a, map_b);\n+\n+    // The maps have swapped, so their allocators have swapped, too.\n+    // No additional allocations have occurred!\n+    BOOST_CHECK(map_a->get_allocator() != map_b->get_allocator());\n+    BOOST_CHECK(alloc_a == map_b->get_allocator());\n+    BOOST_CHECK(alloc_b == map_a->get_allocator());\n+    map_b.reset();\n+\n+    // map_b destroyed, so mr_a must have plenty of free allocations now\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+\n+    // nothing happened to map_a, so mr_b still has no free allocations\n+    BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 0);\n+    map_a.reset();\n+\n+    // finally map_a is destroyed, so we got an entry back for mr_b.\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+}\n+\n+BOOST_AUTO_TEST_CASE(calc_required_allocation_size)\n+{\n+    static_assert(sizeof(AlignedSize<1, 1>) == 1U);\n+    static_assert(std::alignment_of_v<AlignedSize<1, 1>> == 1U);\n+\n+    static_assert(sizeof(AlignedSize<16, 1>) == 16U);\n+    static_assert(std::alignment_of_v<AlignedSize<16, 1>> == 16U);\n+    static_assert(sizeof(AlignedSize<16, 16>) == 16U);\n+    static_assert(std::alignment_of_v<AlignedSize<16, 16>> == 16U);\n+    static_assert(sizeof(AlignedSize<16, 24>) == 32U);\n+    static_assert(std::alignment_of_v<AlignedSize<16, 24>> == 16U);\n+\n+#if UINTPTR_MAX == 0xFFFFFFFFFFFFFFFF\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<AlignedSize<1, 1>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<AlignedSize<1, 7>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<AlignedSize<1, 8>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<AlignedSize<1, 9>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<AlignedSize<1, 15>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<AlignedSize<1, 16>>());\n+    static_assert(24U == node_allocator::detail::RequiredAllocationSizeBytes<AlignedSize<1, 17>>());\n+    static_assert(104U == node_allocator::detail::RequiredAllocationSizeBytes<AlignedSize<1, 100>>());\n+\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<AlignedSize<4, 4>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<AlignedSize<4, 7>>());\n+    static_assert(104U == node_allocator::detail::RequiredAllocationSizeBytes<AlignedSize<4, 100>>());\n+#elif UINTPTR_MAX == 0xFFFFFFFF\n+    static_assert(4U == node_allocator::detail::RequiredAllocationSizeBytes<AlignedSize<1, 1>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<AlignedSize<1, 7>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<AlignedSize<1, 8>>());\n+    static_assert(12U == node_allocator::detail::RequiredAllocationSizeBytes<AlignedSize<1, 9>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<AlignedSize<1, 15>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<AlignedSize<1, 16>>());\n+    static_assert(20U == node_allocator::detail::RequiredAllocationSizeBytes<AlignedSize<1, 17>>());\n+    static_assert(100U == node_allocator::detail::RequiredAllocationSizeBytes<AlignedSize<1, 100>>());\n+\n+    static_assert(4U == node_allocator::detail::RequiredAllocationSizeBytes<AlignedSize<4, 4>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<AlignedSize<4, 7>>());\n+    static_assert(100U == node_allocator::detail::RequiredAllocationSizeBytes<AlignedSize<4, 100>>());\n+#else\n+#error \"Invalid sizeof(void*)\"\n+#endif\n+\n+    // Anything with alignment >= 8 is the same in both 32bit and 64bit\n+\n+    static_assert(104U == node_allocator::detail::RequiredAllocationSizeBytes<AlignedSize<8, 100>>());\n+\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<AlignedSize<8, 1>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<AlignedSize<8, 8>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<AlignedSize<8, 16>>());\n+\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<AlignedSize<16, 1>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<AlignedSize<16, 8>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<AlignedSize<16, 16>>());\n+    static_assert(32U == node_allocator::detail::RequiredAllocationSizeBytes<AlignedSize<16, 17>>());\n+}\n+\n+using MappedTypes = std::tuple<\n+    uint8_t,\n+    uint16_t,\n+    uint32_t,\n+    uint64_t,\n+    std::string,\n+    AlignedSize<__STDCPP_DEFAULT_NEW_ALIGNMENT__, 1> // Biggest allowed alignment is __STDCPP_DEFAULT_NEW_ALIGNMENT__\n+    >;\n+\n+BOOST_AUTO_TEST_CASE_TEMPLATE(allocations_are_used, T, MappedTypes)\n+{\n+#if defined(_LIBCPP_VERSION) // defined in any C++ header from libc++\n+    BOOST_TEST_MESSAGE(\"_LIBCPP_VERSION is defined\");\n+#endif\n+#if defined(__GLIBCXX__) || defined(__GLIBCPP__)\n+    BOOST_TEST_MESSAGE(\"__GLIBCXX__ or __GLIBCPP__ is defined\");\n+#endif\n+\n+    TestAllocationsAreUsed<uint8_t, T>();\n+    TestAllocationsAreUsed<uint8_t, T, NotNoexceptHash<uint8_t>>();\n+\n+    TestAllocationsAreUsed<uint16_t, T>();\n+    TestAllocationsAreUsed<uint16_t, T, NotNoexceptHash<uint16_t>>();\n+\n+    TestAllocationsAreUsed<uint32_t, T>();\n+    TestAllocationsAreUsed<uint32_t, T, NotNoexceptHash<uint32_t>>();\n+\n+    TestAllocationsAreUsed<uint64_t, T>();\n+    TestAllocationsAreUsed<uint64_t, T, NotNoexceptHash<uint64_t>>();\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "66f745394ddfb546b9d0d29fe764110944dea158",
    "node_id": "C_kwDOABII59oAKDY2Zjc0NTM5NGRkZmI1NDZiOWQwZDI5ZmU3NjQxMTA5NDRkZWExNTg",
    "commit": {
      "author": {
        "name": "Martin Leitner-Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2021-11-13T07:32:28Z"
      },
      "committer": {
        "name": "Martin Leitner-Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2021-11-15T20:18:55Z"
      },
      "message": "Make use of node_allocator in CCoinsMap\n\nIn my benchmarks, using this pool allocator for CCoinsMap gives about\n20% faster `-reindex-chainstate` with -dbcache=5000 with practically the\nsame memory usage. The change in max RSS changed was 0.3%.\n\nNote that the memory usage behavior is now different, since MemoryResource\ndoes not free any memory when the map is cleared. Instead, the memory is\nheld in a freelist. This requires now that `CCoinsViewCache::Flush`\nneeds to call `ReallocateCache` so memory is actually freed. If that\nwouldn't happen, memory usage would not decrease and Flush() would be\ntriggered again soon after.\n\nAlso, the `validation_flush_tests` tests need to be updated because\nmemory allocation is now done in large pools instead of one node at a\ntime, so the limits need to be updated accordingly.",
      "tree": {
        "sha": "5f0ad5a0570294ba159e705deebbe3d00f05ed32",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5f0ad5a0570294ba159e705deebbe3d00f05ed32"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/66f745394ddfb546b9d0d29fe764110944dea158",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCAAdFiEEqyQrdqB7R6j2Hv2k++qtf8b//oEFAmGSwLMACgkQ++qtf8b/\n/oFJDAv+IvDJAj/DWb850bY5nbZV5MDx7UD4/e+pcuMaqOVyeySOERS3S/GAom/f\nZ9fND61hXC/lfxariScSN1Qpwxo303GrEE4aPCpB0zmjyulRfWnxBKHs7JuSJvGE\n6MOxu0AnstfDWGhFacPEL+fDJRLQcgtRxiwzQVch1cRXOx8DfIvuicFszGKB+dE9\nW7kgwinIa635diDKXLvBS9+PBoyMeqIaH07GbLijJ9p1CdpGx9Nr+NnhkiCDeHbt\nA+z75vBgJzm4/gmbTHKw9la1hn0ZbGmUHfLwhuG98L5ePufCwxj1AOf/A34Q6xy/\nF42T31+BDxxSIZBq4J/eMYROYumse3/BiEJQShwDa5hMIYf1j4fetfYEgHccgtQB\nupJjCG8CVgwV8NEZY3hpiRlPbxQNI8yqlsdqN+PFXQtzgRqLLa6+Ju+YGzEqB/AU\nWL4NeH+EpNovFzJPjdi98QA3tyzZAXr1ZoW0PwlBl6UOGMz0j6yoMCPiPu5OgGP0\nzJS+GGd2\n=biq+\n-----END PGP SIGNATURE-----",
        "payload": "tree 5f0ad5a0570294ba159e705deebbe3d00f05ed32\nparent 96d8e33acaa079491403d8e8afa6709978dec205\nauthor Martin Leitner-Ankerl <martin.ankerl@gmail.com> 1636788748 +0100\ncommitter Martin Leitner-Ankerl <martin.ankerl@gmail.com> 1637007535 +0100\n\nMake use of node_allocator in CCoinsMap\n\nIn my benchmarks, using this pool allocator for CCoinsMap gives about\n20% faster `-reindex-chainstate` with -dbcache=5000 with practically the\nsame memory usage. The change in max RSS changed was 0.3%.\n\nNote that the memory usage behavior is now different, since MemoryResource\ndoes not free any memory when the map is cleared. Instead, the memory is\nheld in a freelist. This requires now that `CCoinsViewCache::Flush`\nneeds to call `ReallocateCache` so memory is actually freed. If that\nwouldn't happen, memory usage would not decrease and Flush() would be\ntriggered again soon after.\n\nAlso, the `validation_flush_tests` tests need to be updated because\nmemory allocation is now done in large pools instead of one node at a\ntime, so the limits need to be updated accordingly.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/66f745394ddfb546b9d0d29fe764110944dea158",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/66f745394ddfb546b9d0d29fe764110944dea158",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/66f745394ddfb546b9d0d29fe764110944dea158/comments",
    "author": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "96d8e33acaa079491403d8e8afa6709978dec205",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/96d8e33acaa079491403d8e8afa6709978dec205",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/96d8e33acaa079491403d8e8afa6709978dec205"
      }
    ],
    "stats": {
      "total": 60,
      "additions": 38,
      "deletions": 22
    },
    "files": [
      {
        "sha": "cf306a9036c19ff98c0f523a839938426d25910b",
        "filename": "src/coins.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 3,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/66f745394ddfb546b9d0d29fe764110944dea158/src/coins.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/66f745394ddfb546b9d0d29fe764110944dea158/src/coins.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.cpp?ref=66f745394ddfb546b9d0d29fe764110944dea158",
        "patch": "@@ -31,10 +31,10 @@ bool CCoinsViewBacked::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock)\n std::unique_ptr<CCoinsViewCursor> CCoinsViewBacked::Cursor() const { return base->Cursor(); }\n size_t CCoinsViewBacked::EstimateSize() const { return base->EstimateSize(); }\n \n-CCoinsViewCache::CCoinsViewCache(CCoinsView *baseIn) : CCoinsViewBacked(baseIn), cachedCoinsUsage(0) {}\n+CCoinsViewCache::CCoinsViewCache(CCoinsView *baseIn) : CCoinsViewBacked(baseIn) {}\n \n size_t CCoinsViewCache::DynamicMemoryUsage() const {\n-    return memusage::DynamicUsage(cacheCoins) + cachedCoinsUsage;\n+    return memusage::DynamicUsage(cacheCoins) + cacheCoinsMemoryResource.DynamicMemoryUsage() + cachedCoinsUsage;\n }\n \n CCoinsMap::iterator CCoinsViewCache::FetchCoin(const COutPoint &outpoint) const {\n@@ -222,6 +222,7 @@ bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn\n bool CCoinsViewCache::Flush() {\n     bool fOk = base->BatchWrite(cacheCoins, hashBlock);\n     cacheCoins.clear();\n+    ReallocateCache();\n     cachedCoinsUsage = 0;\n     return fOk;\n }\n@@ -256,7 +257,9 @@ void CCoinsViewCache::ReallocateCache()\n     // Cache should be empty when we're calling this.\n     assert(cacheCoins.size() == 0);\n     cacheCoins.~CCoinsMap();\n-    ::new (&cacheCoins) CCoinsMap();\n+    cacheCoinsMemoryResource.~MemoryResource();\n+    ::new (&cacheCoinsMemoryResource) CCoinsMapFactory::MemoryResourceType{};\n+    ::new (&cacheCoins) CCoinsMap{CCoinsMapFactory::CreateContainer(&cacheCoinsMemoryResource)};\n }\n \n static const size_t MIN_TRANSACTION_OUTPUT_WEIGHT = WITNESS_SCALE_FACTOR * ::GetSerializeSize(CTxOut(), PROTOCOL_VERSION);"
      },
      {
        "sha": "eaeb8ebfa3fd3270fc727ac449672b0fe5de4dc2",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 6,
        "deletions": 3,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/66f745394ddfb546b9d0d29fe764110944dea158/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/66f745394ddfb546b9d0d29fe764110944dea158/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=66f745394ddfb546b9d0d29fe764110944dea158",
        "patch": "@@ -11,6 +11,7 @@\n #include <memusage.h>\n #include <primitives/transaction.h>\n #include <serialize.h>\n+#include <support/allocators/node_allocator/factory.h>\n #include <uint256.h>\n #include <util/hasher.h>\n \n@@ -131,7 +132,8 @@ struct CCoinsCacheEntry\n     CCoinsCacheEntry(Coin&& coin_, unsigned char flag) : coin(std::move(coin_)), flags(flag) {}\n };\n \n-typedef std::unordered_map<COutPoint, CCoinsCacheEntry, SaltedOutpointHasher> CCoinsMap;\n+using CCoinsMapFactory = node_allocator::Factory<std::unordered_map<COutPoint, CCoinsCacheEntry, SaltedOutpointHasher>>;\n+using CCoinsMap = CCoinsMapFactory::ContainerType;\n \n /** Cursor for iterating over CoinsView state */\n class CCoinsViewCursor\n@@ -218,10 +220,11 @@ class CCoinsViewCache : public CCoinsViewBacked\n      * declared as \"const\".\n      */\n     mutable uint256 hashBlock;\n-    mutable CCoinsMap cacheCoins;\n+    mutable CCoinsMapFactory::MemoryResourceType cacheCoinsMemoryResource{};\n+    mutable CCoinsMap cacheCoins = CCoinsMapFactory::CreateContainer(&cacheCoinsMemoryResource);\n \n     /* Cached dynamic memory usage for the inner Coin objects. */\n-    mutable size_t cachedCoinsUsage;\n+    mutable size_t cachedCoinsUsage{0};\n \n public:\n     CCoinsViewCache(CCoinsView *baseIn);"
      },
      {
        "sha": "33dd7d861009b1d6bd387809d71fa65d5e60f3ac",
        "filename": "src/test/coins_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/66f745394ddfb546b9d0d29fe764110944dea158/src/test/coins_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/66f745394ddfb546b9d0d29fe764110944dea158/src/test/coins_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/coins_tests.cpp?ref=66f745394ddfb546b9d0d29fe764110944dea158",
        "patch": "@@ -81,7 +81,7 @@ class CCoinsViewCacheTest : public CCoinsViewCache\n     void SelfTest() const\n     {\n         // Manually recompute the dynamic usage of the whole data, and compare it.\n-        size_t ret = memusage::DynamicUsage(cacheCoins);\n+        size_t ret = memusage::DynamicUsage(cacheCoins) + cacheCoinsMemoryResource.DynamicMemoryUsage();\n         size_t count = 0;\n         for (const auto& entry : cacheCoins) {\n             ret += entry.second.coin.DynamicMemoryUsage();\n@@ -609,7 +609,8 @@ void GetCoinsMapEntry(const CCoinsMap& map, CAmount& value, char& flags)\n \n void WriteCoinsViewEntry(CCoinsView& view, CAmount value, char flags)\n {\n-    CCoinsMap map;\n+    CCoinsMapFactory::MemoryResourceType memory_resource{};\n+    auto map = CCoinsMapFactory::CreateContainer(&memory_resource);\n     InsertCoinsMapEntry(map, value, flags);\n     BOOST_CHECK(view.BatchWrite(map, {}));\n }"
      },
      {
        "sha": "cc24ba1dbe0db9d86be86c74abcd7a157b72a5f0",
        "filename": "src/test/fuzz/coins_view.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/66f745394ddfb546b9d0d29fe764110944dea158/src/test/fuzz/coins_view.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/66f745394ddfb546b9d0d29fe764110944dea158/src/test/fuzz/coins_view.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/coins_view.cpp?ref=66f745394ddfb546b9d0d29fe764110944dea158",
        "patch": "@@ -113,7 +113,8 @@ FUZZ_TARGET_INIT(coins_view, initialize_coins_view)\n                 random_mutable_transaction = *opt_mutable_transaction;\n             },\n             [&] {\n-                CCoinsMap coins_map;\n+                CCoinsMapFactory::MemoryResourceType cacheCoinsMemoryResource{};\n+                auto coins_map = CCoinsMapFactory::CreateContainer(&cacheCoinsMemoryResource);\n                 LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000) {\n                     CCoinsCacheEntry coins_cache_entry;\n                     coins_cache_entry.flags = fuzzed_data_provider.ConsumeIntegral<unsigned char>();"
      },
      {
        "sha": "e929c080f0321ea7ac3a0053a32c3f56b10707a5",
        "filename": "src/test/validation_flush_tests.cpp",
        "status": "modified",
        "additions": 21,
        "deletions": 13,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/66f745394ddfb546b9d0d29fe764110944dea158/src/test/validation_flush_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/66f745394ddfb546b9d0d29fe764110944dea158/src/test/validation_flush_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/validation_flush_tests.cpp?ref=66f745394ddfb546b9d0d29fe764110944dea158",
        "patch": "@@ -52,12 +52,12 @@ BOOST_AUTO_TEST_CASE(getcoinscachesizestate)\n         BOOST_TEST_MESSAGE(\"CCoinsViewCache memory usage: \" << view.DynamicMemoryUsage());\n     };\n \n-    constexpr size_t MAX_COINS_CACHE_BYTES = 1024;\n+    // node_allocator defaults to 256 KiB that will be allocated, so we'll take that and make it a bit larger.\n+    constexpr size_t MAX_COINS_CACHE_BYTES = (1 << 18) + 512;\n \n     // Without any coins in the cache, we shouldn't need to flush.\n-    BOOST_CHECK_EQUAL(\n-        chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, /*max_mempool_size_bytes*/ 0),\n-        CoinsCacheSizeState::OK);\n+    BOOST_TEST(\n+        chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, /*max_mempool_size_bytes*/ 0) != CoinsCacheSizeState::CRITICAL);\n \n     // If the initial memory allocations of cacheCoins don't match these common\n     // cases, we can't really continue to make assertions about memory usage.\n@@ -87,17 +87,25 @@ BOOST_AUTO_TEST_CASE(getcoinscachesizestate)\n     // cacheCoins (unordered_map) preallocates.\n     constexpr int COINS_UNTIL_CRITICAL{3};\n \n+    // no coin added, so we have plenty of space left.\n+    BOOST_CHECK_EQUAL(\n+        chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, /*max_mempool_size_bytes*/ 0),\n+        CoinsCacheSizeState::OK);\n+\n     for (int i{0}; i < COINS_UNTIL_CRITICAL; ++i) {\n         COutPoint res = add_coin(view);\n         print_view_mem_usage(view);\n         BOOST_CHECK_EQUAL(view.AccessCoin(res).DynamicMemoryUsage(), COIN_SIZE);\n+\n+        // adding first coin causes the MemoryResource to allocate one 256 KiB chunk of memory,\n+        // pushing us immediately over to LARGE\n         BOOST_CHECK_EQUAL(\n             chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, /*max_mempool_size_bytes*/ 0),\n-            CoinsCacheSizeState::OK);\n+            CoinsCacheSizeState::LARGE);\n     }\n \n     // Adding some additional coins will push us over the edge to CRITICAL.\n-    for (int i{0}; i < 4; ++i) {\n+    for (int i{0}; i < 50; ++i) {\n         add_coin(view);\n         print_view_mem_usage(view);\n         if (chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, /*max_mempool_size_bytes*/ 0) ==\n@@ -110,16 +118,16 @@ BOOST_AUTO_TEST_CASE(getcoinscachesizestate)\n         chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, /*max_mempool_size_bytes*/ 0),\n         CoinsCacheSizeState::CRITICAL);\n \n-    // Passing non-zero max mempool usage should allow us more headroom.\n+    // Passing non-zero max mempool usage (512 KiB) should allow us more headroom.\n     BOOST_CHECK_EQUAL(\n-        chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, /*max_mempool_size_bytes*/ 1 << 10),\n+        chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, /*max_mempool_size_bytes*/ 1 << 19),\n         CoinsCacheSizeState::OK);\n \n     for (int i{0}; i < 3; ++i) {\n         add_coin(view);\n         print_view_mem_usage(view);\n         BOOST_CHECK_EQUAL(\n-            chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, /*max_mempool_size_bytes*/ 1 << 10),\n+            chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, /*max_mempool_size_bytes*/ 1 << 19),\n             CoinsCacheSizeState::OK);\n     }\n \n@@ -135,7 +143,7 @@ BOOST_AUTO_TEST_CASE(getcoinscachesizestate)\n         BOOST_CHECK(usage_percentage >= 0.9);\n         BOOST_CHECK(usage_percentage < 1);\n         BOOST_CHECK_EQUAL(\n-            chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, 1 << 10),\n+            chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, /*max_mempool_size_bytes*/ 1 << 10), // 1024\n             CoinsCacheSizeState::LARGE);\n     }\n \n@@ -147,8 +155,8 @@ BOOST_AUTO_TEST_CASE(getcoinscachesizestate)\n             CoinsCacheSizeState::OK);\n     }\n \n-    // Flushing the view doesn't take us back to OK because cacheCoins has\n-    // preallocated memory that doesn't get reclaimed even after flush.\n+    // Flushing the view does take us back to OK because cacheCoins' MemoryResource frees its\n+    // preallocated memory\n \n     BOOST_CHECK_EQUAL(\n         chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, 0),\n@@ -160,7 +168,7 @@ BOOST_AUTO_TEST_CASE(getcoinscachesizestate)\n \n     BOOST_CHECK_EQUAL(\n         chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, 0),\n-        CoinsCacheSizeState::CRITICAL);\n+        CoinsCacheSizeState::OK);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "node_id": "C_kwDOABII59oAKDhkZmQ3MWNhN2ZkZGYxYTk0MzZkMDRhMTZmNWE4ZDlkOThlZThjNzQ",
    "commit": {
      "author": {
        "name": "Martin Leitner-Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2021-10-26T08:38:14Z"
      },
      "committer": {
        "name": "Martin Leitner-Ankerl",
        "email": "martin.ankerl@gmail.com",
        "date": "2021-11-15T20:18:59Z"
      },
      "message": "Don't call ReallocateCache twice in  ResizeCoinsCaches\n\nRemoves the call to CoinsTip().ReallocateCache() in ResizeCoinsCaches because this is now done in CCoinsViewCache::Flush().\n\nAlso makes ReallocateCache private because it's not needed outside any more.",
      "tree": {
        "sha": "11a2f39dd9470fe083aeed01bc00d64497df0a21",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/11a2f39dd9470fe083aeed01bc00d64497df0a21"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCAAdFiEEqyQrdqB7R6j2Hv2k++qtf8b//oEFAmGSwLMACgkQ++qtf8b/\n/oFIPgwAlfFoWw6CP0h1I8Tbv2/j+gk30EBeJFujCoSlPgvWtvPR3QzFh5K5+wJV\ntIi4w0ZjphqvNXu9CVNTwdd1b81xVYf0v4AKLI48WWJ/++4TUsIV/hSzuK9Tm4En\nxp3fuKnyYQqw7GybWKWh9anNOuDxFOk5ZYfnCINpwt3muq0BDky3n6lZJB6AF0QH\n/CkHoBwQwOF6I4cgGv6KSdx1ek2Ix0H4H5xG9QpDECiI2kSUjs72KZnAUccNEIvo\nFgvw5ZPnkpDA+p70KTtKyvBr64f7VS7DKp6ZBYQlPknHPe0NI9xW3UgKoby1xo2l\nYwhh4aHLGEQM93QNBKab5I87MSRKeZYMrW1VTZhxPUnoaZZOqpoNSHaKg1yWAtq3\ngkH5QsX0AVEyrtHjKZlofne1gMFaHf870EneQIyR7blQ4za1NvWet4fSczfc3Vff\nDlm3kywlkxWtSx+XyAvgdkGJk8NqF8LmkWRfp4n0kFTSo0yLCGsf7zUqJkCzmQXw\n2v5m4a8p\n=Ozt7\n-----END PGP SIGNATURE-----",
        "payload": "tree 11a2f39dd9470fe083aeed01bc00d64497df0a21\nparent 66f745394ddfb546b9d0d29fe764110944dea158\nauthor Martin Leitner-Ankerl <martin.ankerl@gmail.com> 1635237494 +0200\ncommitter Martin Leitner-Ankerl <martin.ankerl@gmail.com> 1637007539 +0100\n\nDon't call ReallocateCache twice in  ResizeCoinsCaches\n\nRemoves the call to CoinsTip().ReallocateCache() in ResizeCoinsCaches because this is now done in CCoinsViewCache::Flush().\n\nAlso makes ReallocateCache private because it's not needed outside any more.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74/comments",
    "author": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "66f745394ddfb546b9d0d29fe764110944dea158",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/66f745394ddfb546b9d0d29fe764110944dea158",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/66f745394ddfb546b9d0d29fe764110944dea158"
      }
    ],
    "stats": {
      "total": 3,
      "additions": 1,
      "deletions": 2
    },
    "files": [
      {
        "sha": "60ec28dda72d2f8d0d2275d5a3e6cf5d0be2683b",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
        "patch": "@@ -307,14 +307,14 @@ class CCoinsViewCache : public CCoinsViewBacked\n     //! Check whether all prevouts of the transaction are present in the UTXO set represented by this view\n     bool HaveInputs(const CTransaction& tx) const;\n \n+private:\n     //! Force a reallocation of the cache map. This is required when downsizing\n     //! the cache because the map's allocator may be hanging onto a lot of\n     //! memory despite having called .clear().\n     //!\n     //! See: https://stackoverflow.com/questions/42114044/how-to-release-unordered-map-memory\n     void ReallocateCache();\n \n-private:\n     /**\n      * @note this is marked const, but may actually append to `cacheCoins`, increasing\n      * memory usage."
      },
      {
        "sha": "904f84d3ee7e4834a9063cb12e040477f1e6e3de",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
        "patch": "@@ -4515,7 +4515,6 @@ bool CChainState::ResizeCoinsCaches(size_t coinstip_size, size_t coinsdb_size)\n     } else {\n         // Otherwise, flush state to disk and deallocate the in-memory coins map.\n         ret = FlushStateToDisk(state, FlushStateMode::ALWAYS);\n-        CoinsTip().ReallocateCache();\n     }\n     return ret;\n }"
      }
    ]
  }
]